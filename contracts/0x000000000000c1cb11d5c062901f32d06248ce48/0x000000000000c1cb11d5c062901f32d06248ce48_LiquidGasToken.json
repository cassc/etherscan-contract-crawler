{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.9;\r\n\r\n\r\n// Part: IERC20\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// Part: SafeMath\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// Part: ERC20PointerSupply\r\n\r\n/// @title ERC20-Token where total supply is calculated from minted and burned tokens\r\n/// @author Matthias Nadler\r\ncontract ERC20PointerSupply is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    // ****** ERC20 Pointer Supply Token\r\n    //        --------------------------\r\n    //        totalSupply is stored in two variables:\r\n    //        The number of tokens minted and burned, where minted - burned = totalSupply.\r\n    //        Additionally, the supply is split into:\r\n    //        - ownedSupply: Number of tokens owned by accounts.\r\n    //        - tokenReserves: Implicitly defined as totalSupply - ownedSupply, this is the number\r\n    //                        of tokens \"owned\" by this contract.\r\n    //        To keep the contract more gas efficient, no Transfer events are emitted when\r\n    //        minting or burning tokens.\r\n\r\n    mapping (address => uint256) internal _balances;\r\n    mapping (address => mapping (address => uint256)) internal _allowances;\r\n\r\n    uint256 internal _ownedSupply;\r\n    uint256 internal _totalBurned;\r\n    uint256 internal _totalMinted;\r\n\r\n    string constant public name = \"Liquid Gas Token\";\r\n    string constant public symbol = \"LGT\";\r\n    uint8 constant public decimals = 0;\r\n\r\n    /// @notice Return the total supply of tokens.\r\n    /// @dev This is different from a classic ERC20 implementation as the supply is calculated\r\n    ///      from the burned and minted tokens instead of stored in its own variable.\r\n    /// @return Total number of tokens in circulation.\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalMinted.sub(_totalBurned);\r\n    }\r\n\r\n    /// @notice Return the number of tokens owned by accounts.\r\n    /// @dev Unowned tokens belong to this contract and their supply can be\r\n    ///      calculated implicitly. This means we need to manually track owned tokens,\r\n    ///      but it makes operations on unowned tokens much more efficient.\r\n    /// @return Total number of tokens owned by specific addresses.\r\n    function ownedSupply() external view returns (uint256) {\r\n        return _ownedSupply;\r\n    }\r\n\r\n    /// @notice Returns the amount of tokens owned by `account`.\r\n    /// @param account The account to query for the balance.\r\n    /// @return The amount of tokens owned by `account`.\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /// @notice Moves `amount` tokens from the caller's account to `recipient`.\r\n    ///         Emits a {Transfer} event.\r\n    /// @dev Requirements:\r\n    //       - `recipient` cannot be the zero address.\r\n    //       - the caller must have a balance of at least `amount`.\r\n    /// @param recipient The tokens are transferred to this address.\r\n    /// @param amount The amount of tokens to be transferred.\r\n    /// @return True if the transfer succeeded, False otherwise.\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Returns the remaining number of tokens that `spender` will be\r\n    ///         allowed to spend on behalf of `owner` through {transferFrom}.\r\n    ///         This is zero by default.\r\n    /// @param owner The address that holds the tokens that can be spent by `spender`.\r\n    /// @param spender The address that is allowed to spend the tokens held by `owner`.\r\n    /// @return Remaining number of tokens that `spender` will be\r\n    ///         allowed to spend on behalf of `owner`\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n    ///         Emits an {Approval} event.\r\n    /// @dev    IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n    ///         that someone may use both the old and the new allowance by unfortunate\r\n    ///         transaction ordering. This contracts provides {increaseAllowance} and\r\n    ///         {decreaseAllowance} to mitigate this problem. See:\r\n    ///         https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    ///         Requirements:\r\n    ///         - `spender` cannot be the zero address.\r\n    /// @param spender The address that is allowed to spend the tokens held by the caller.\r\n    /// @param amount The amount of tokens the `spender` can spend from the caller's supply.\r\n    /// @return True if the approval succeeded, False otherwise.\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @notice Moves `amount` tokens from `sender` to `recipient` using the allowance\r\n    ///         mechanism. `amount` is then deducted from the caller's allowance.\r\n    ///         Emits a {Transfer} and an {Approval} event.\r\n    /// @dev Requirements:\r\n    ///      - `sender` and `recipient` cannot be the zero address.\r\n    ///      - `sender` must have a balance of at least `amount`.\r\n    ///      - the caller must have allowance for `sender`'s tokens of at least `amount`.\r\n    /// @param sender The tokens are transferred from this address.\r\n    /// @param recipient The tokens are transferred to this address.\r\n    /// @param amount The amount of tokens to be transferred.\r\n    /// @return True if the transfer succeeded, False otherwise.\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            msg.sender,\r\n            _allowances[sender][msg.sender].sub(amount, \"ERC20: exceeds allowance\")\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /// @notice Atomically increases the allowance granted to `spender` by the caller.\r\n    ///         This is an alternative to {approve} that can be used as a mitigation for\r\n    ///         problems described in {approve}.\r\n    ///         Emits an {Approval} event.\r\n    /// @dev Requirements:\r\n    ///      - `spender` cannot be the zero address.\r\n    /// @param spender The address that is allowed to spend the tokens held by the caller.\r\n    /// @param addedValue The amount of tokens to add to the current `allowance`.\r\n    /// @return True if the approval succeeded, False otherwise.\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /// @notice Atomically decreases the allowance granted to `spender` by the caller.\r\n    ///         This is an alternative to {approve} that can be used as a mitigation for\r\n    ///         problems described in {approve}.\r\n    ///         Emits an {Approval} event.\r\n    /// @dev Requirements:\r\n    ///      - `spender` cannot be the zero address.\r\n    ///      - `spender` must have allowance for the caller of at least `subtractedValue`.\r\n    /// @param spender The address that is allowed to spend the tokens held by the caller.\r\n    /// @param subtractedValue The amount of tokens to subtract from the current `allowance`.\r\n    /// @return True if the approval succeeded, False otherwise.\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: allowance below zero\")\r\n        );\r\n        return true;\r\n    }\r\n\r\n\r\n    // ****** Internal ERC20 Functions\r\n    //        ------------------------\r\n\r\n    /// @dev Triggered when tokens are transferred to this contract.\r\n    ///      Can be overridden by an implementation to allow and handle this behaviour.\r\n    ///      This should emit a {Transfer} event if an ownership change is made.\r\n    function _transferToSelf(address sender, uint256 amount) internal virtual {\r\n        revert(\"ERC20: transfer to contract\");\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(recipient != address(0), \"ERC20: transfer to zero address\");\r\n        if (recipient == address(this)) {\r\n            _transferToSelf(sender, amount);\r\n        } else {\r\n            _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer exceeds balance\");\r\n            _balances[recipient] += amount;\r\n            emit Transfer(sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}\r\n\r\n// Part: LiquidERC20\r\n\r\n/// @title ERC20-Token with built in Liquidity Pool\r\n/// @dev The Liquidity Shares do not adhere to ERC20 standards,\r\n///      only the underlying token does. Liquidity can not be traded.\r\n/// @author Matthias Nadler\r\ncontract LiquidERC20 is ERC20PointerSupply {\r\n\r\n    // ***** Liquidity Pool\r\n    //       --------------\r\n    //       Integrated Liquidity Pool for an ERC20 Pointer Supply Token.\r\n    //       More efficient due to shortcuts in the ownership transfers.\r\n    //       Modelled after Uniswap V1 by Hayden Adams:\r\n    //       https://github.com/Uniswap/uniswap-v1/blob/master/contracts/uniswap_exchange.vy\r\n    //       Sell and Buy events are not implemented in the interest of gas efficiency.\r\n    //       Liquidity shares do not adhere to ERC20 specifications.\r\n    //       However, a subset of ERC20-like functions are implemented.\r\n\r\n    uint256 internal _poolTotalSupply;\r\n    mapping (address => uint256) internal _poolBalances;\r\n\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256 indexed eth_amount,\r\n        uint256 indexed token_amount\r\n    );\r\n    event RemoveLiquidity(\r\n        address indexed provider,\r\n        uint256 indexed eth_amount,\r\n        uint256 indexed token_amount\r\n    );\r\n    event TransferLiquidity(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    /// @notice Returns the amount of liquidity shares owned by `account`.\r\n    /// @param account The account to query for the balance.\r\n    /// @return The amount of liquidity shares owned by `account`.\r\n    function poolBalanceOf(address account) external view returns (uint256) {\r\n        return _poolBalances[account];\r\n    }\r\n\r\n    /// @notice Return the total supply of liquidity shares.\r\n    /// @return Total number of liquidity shares.\r\n    function poolTotalSupply() external view returns (uint256) {\r\n        return _poolTotalSupply;\r\n    }\r\n\r\n    /// @notice The amount of tokens in the liquidity pool.\r\n    /// @dev This is defined implicitly as the difference between\r\n    ///      The total supply and the privately owned supply of the token.\r\n    /// @return The amount of tokens in the liquidity pool.\r\n    function poolTokenReserves() external view returns (uint256) {\r\n        return _totalMinted.sub(_totalBurned + _ownedSupply);\r\n    }\r\n\r\n    /// @notice Moves `amount` liquidity shares from the caller's account to `recipient`.\r\n    ///         Emits a {Transfer} event.\r\n    /// @dev Requirements:\r\n    //       - `recipient` cannot be the zero address.\r\n    //       - the caller must have a balance of at least `amount`.\r\n    /// @param recipient The tokens are transferred to this address.\r\n    /// @param amount The amount of tokens to be transferred.\r\n    /// @return True if the transfer succeeded, False otherwise.\r\n    function poolTransfer(address recipient, uint256 amount) external returns (bool) {\r\n        require(recipient != address(0)); // dev: can't transfer liquidity to zero address\r\n        require(recipient != address(this)); // dev: can't transfer liquidity to token contract\r\n        _poolBalances[msg.sender] = _poolBalances[msg.sender].sub(amount, \"LGT: transfer exceeds balance\");\r\n        _poolBalances[recipient]= _poolBalances[recipient].add(amount);\r\n        emit TransferLiquidity(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    // *** Constructor\r\n    /// @dev Start with initial liquidity. Contract must be pre-funded.\r\n    ///      This initial liquidity must never be removed.\r\n    constructor() public {\r\n        // Implementation must mint at least 1 token to the pool during deployment.\r\n        uint ethReserve = address(this).balance;\r\n        require(ethReserve > 1000000000);\r\n        _poolTotalSupply += ethReserve;\r\n        _poolBalances[msg.sender] += ethReserve;\r\n    }\r\n\r\n    // ***** Liquidity Pool\r\n    //       --------------------\r\n    //       Add, remove or transfer liquidity shares.\r\n\r\n    /// @notice Add liquidity to the pool and receive liquidity shares. Must deposit\r\n    ///         an equal amount of ether and tokens at the current exchange rate.\r\n    ///         Emits an {AddLiquidity} event.\r\n    /// @param minLiquidity The minimum amount of liquidity shares to create,\r\n    ///        will revert if not enough liquidity can be created.\r\n    /// @param maxTokens The maximum amount of tokens to transfer to match the provided\r\n    ///        ether liquidity. Will revert if too many tokens are needed.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @return The amount of liquidity shares created.\r\n    function addLiquidity(uint256 minLiquidity, uint256 maxTokens, uint256 deadline)\r\n        external\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        require(deadline >= now); // dev: deadline passed\r\n        require(maxTokens != 0); // dev: no tokens to add\r\n        require(msg.value != 0); // dev: no ether to add\r\n        require(minLiquidity != 0); // dev: no min_liquidity specified\r\n\r\n        uint256 ethReserve = address(this).balance - msg.value;\r\n        uint256 ownedSupply = _ownedSupply;\r\n        uint256 tokenReserve = _totalMinted.sub(_totalBurned + ownedSupply);\r\n        uint256 tokenAmount = msg.value.mul(tokenReserve) / ethReserve + 1;\r\n        uint256 poolTotalSupply = _poolTotalSupply;\r\n        uint256 liquidityCreated = msg.value.mul(poolTotalSupply) / ethReserve;\r\n        require(maxTokens >= tokenAmount); // dev: need more tokens\r\n        require(liquidityCreated >= minLiquidity); // dev: not enough liquidity can be created\r\n\r\n        // create liquidity shares\r\n        _poolTotalSupply = poolTotalSupply + liquidityCreated;\r\n        _poolBalances[msg.sender] += liquidityCreated;\r\n\r\n        // remove LGTs from sender\r\n        _balances[msg.sender] = _balances[msg.sender].sub(\r\n            tokenAmount, \"LGT: amount exceeds balance\"\r\n        );\r\n        _ownedSupply = ownedSupply.sub(tokenAmount);\r\n\r\n        emit AddLiquidity(msg.sender, msg.value, tokenAmount);\r\n        return liquidityCreated;\r\n    }\r\n\r\n\r\n    /// @notice Remove liquidity shares and receive an equal amount of tokens and ether\r\n    ///         at the current exchange rate from the liquidity pool.\r\n    ///         Emits a {RemoveLiquidity} event.\r\n    /// @param amount The amount of liquidity shares to remove from the pool.\r\n    /// @param minEth The minimum amount of ether you want to receive in the transaction.\r\n    ///        Will revert if less than `minEth` ether would be transferred.\r\n    /// @param minTokens The minimum amount of tokens you want to receive in the transaction.\r\n    ///        Will revert if less than `minTokens` tokens would be transferred.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @dev Requirements:\r\n    ///      - `sender` must have a liquidity pool balance of at least `amount`.\r\n    /// @return The amount of ether and tokens refunded.\r\n    function removeLiquidity(uint256 amount, uint256 minEth, uint256 minTokens, uint256 deadline)\r\n        external\r\n        returns (uint256, uint256)\r\n    {\r\n        require(deadline >= now); // dev: deadline passed\r\n        require(amount != 0); // dev: amount of liquidity to remove must be positive\r\n        require(minEth != 0); // dev: must remove positive eth amount\r\n        require(minTokens != 0); // dev: must remove positive token amount\r\n        uint256 totalLiquidity = _poolTotalSupply;\r\n        uint256 ownedSupply = _ownedSupply;\r\n        uint256 tokenReserve = _totalMinted.sub(_totalBurned + ownedSupply);\r\n        uint256 ethAmount = amount.mul(address(this).balance) / totalLiquidity;\r\n        uint256 tokenAmount = amount.mul(tokenReserve) / totalLiquidity;\r\n        require(ethAmount >= minEth); // dev: can't remove enough eth\r\n        require(tokenAmount >= minTokens); // dev: can't remove enough tokens\r\n\r\n        // Remove liquidity shares\r\n        _poolBalances[msg.sender] = _poolBalances[msg.sender].sub(amount);\r\n        _poolTotalSupply = totalLiquidity.sub(amount);\r\n\r\n        // Transfer tokens\r\n        _balances[msg.sender] += tokenAmount;\r\n        _ownedSupply = ownedSupply + tokenAmount;\r\n\r\n        emit RemoveLiquidity(msg.sender, ethAmount, tokenAmount);\r\n\r\n        // Transfer ether\r\n        msg.sender.call{value: ethAmount}(\"\");\r\n\r\n        return (ethAmount, tokenAmount);\r\n    }\r\n\r\n    // ***** Constant Price Model\r\n    //       --------------------\r\n    //       Internal price calculation functions for the constant price model with fees.\r\n\r\n\r\n    /// @dev token reserve and pool balance are guaranteed to be non-zero\r\n    ///      No need to require inputReserve != 0\r\n    function getInputPrice(uint256 inputAmount, uint256 inputReserve, uint256 outputReserve)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 inputAmountWithFee = inputAmount.mul(995);\r\n        uint256 numerator = inputAmountWithFee.mul(outputReserve);\r\n        uint256 denominator = inputReserve.mul(1000).add(inputAmountWithFee);\r\n        return numerator / denominator;\r\n    }\r\n\r\n    /// @dev Requirements:\r\n    ///      - `OutputAmount` must be greater than `OutputReserve`\r\n    ///      Token reserve and pool balance are guaranteed to be non-zero\r\n    ///      No need to require inputReserve != 0 or outputReserve != 0\r\n    function getOutputPrice(uint256 outputAmount, uint256 inputReserve, uint256 outputReserve)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 numerator = inputReserve.mul(outputAmount).mul(1000);\r\n        uint256 denominator = outputReserve.sub(outputAmount).mul(995);\r\n        return numerator.div(denominator).add(1);\r\n    }\r\n\r\n    // ***** Trade Ether to Tokens\r\n    //       -------------------\r\n\r\n    /// @dev Exact amount of ether -> As many tokens as can be bought, without partial refund\r\n    function ethToTokenInput(\r\n        uint256 ethSold,\r\n        uint256 minTokens,\r\n        uint256 deadline,\r\n        address recipient\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        require(deadline >= now); // dev: deadline passed\r\n        require(ethSold != 0); // dev: no eth to sell\r\n        require(minTokens != 0); // dev: must buy one or more tokens\r\n        uint256 ownedSupply = _ownedSupply;\r\n        uint256 tokenReserve = _totalMinted.sub(_totalBurned + ownedSupply);\r\n        uint256 ethReserve = address(this).balance.sub(ethSold);\r\n        uint256 tokensBought = getInputPrice(ethSold, ethReserve, tokenReserve);\r\n        require(tokensBought >= minTokens); // dev: not enough eth to buy tokens\r\n        _balances[recipient] += tokensBought;\r\n        _ownedSupply = ownedSupply + tokensBought;\r\n        return tokensBought;\r\n    }\r\n\r\n    /// @notice Convert ETH to Tokens\r\n    /// @dev User cannot specify minimum output or deadline.\r\n    receive() external payable {\r\n        ethToTokenInput(msg.value, 1, now, msg.sender);\r\n    }\r\n\r\n    /// @notice Convert ether to tokens. Specify the exact input (in ether) and\r\n    ///         the minimum output (in tokens).\r\n    /// @param minTokens The minimum amount of tokens you want to receive in the\r\n    ///        transaction for your sold ether. Will revert if less than `minTokens`\r\n    ///        tokens would be transferred.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @dev Excess ether for buying a partial token is not refunded.\r\n    /// @return The amount of tokens bought.\r\n    function ethToTokenSwapInput(uint256 minTokens, uint256 deadline)\r\n        external\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        return ethToTokenInput(msg.value, minTokens, deadline, msg.sender);\r\n    }\r\n\r\n    /// @notice Convert ether to tokens and transfer tokens to `recipient`.\r\n    ///         Specify the exact input (in ether) and the minimum output (in tokens).\r\n    /// @param minTokens The minimum amount of tokens you want the `recipient` to\r\n    ///        receive in the transaction for your sold ether.\r\n    ///        Will revert if less than `minTokens` tokens would be transferred.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @param recipient Bought tokens will be transferred to this address.\r\n    /// @dev Excess ether for buying a partial token is not refunded.\r\n    ///      Requirements:\r\n    ///      - `recipient` can't be this contract or the zero address\r\n    /// @return The amount of tokens bought and transferred to `recipient`.\r\n    function ethToTokenTransferInput(uint256 minTokens, uint256 deadline, address recipient)\r\n        external\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        require(recipient != address(this)); // dev: can't send to liquid token contract\r\n        require(recipient != address(0)); // dev: can't send to zero address\r\n        return ethToTokenInput(msg.value, minTokens, deadline, recipient);\r\n    }\r\n\r\n\r\n    /// @dev Any amount of ether (at least cost of tokens) -> Exact amount of tokens + refund\r\n    function ethToTokenOutput(\r\n        uint256 tokensBought,\r\n        uint256 maxEth,\r\n        uint256 deadline,\r\n        address payable buyer,\r\n        address recipient\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        require(deadline >= now); // dev: deadline passed\r\n        require(tokensBought != 0); // dev: must buy one or more tokens\r\n        require(maxEth != 0); // dev: maxEth must greater than 0\r\n        uint256 ownedSupply = _ownedSupply;\r\n        uint256 tokenReserve = _totalMinted.sub(_totalBurned + ownedSupply);\r\n        uint256 ethReserve = address(this).balance.sub(maxEth);\r\n        uint256 ethSold = getOutputPrice(tokensBought, ethReserve, tokenReserve);\r\n        uint256 ethRefund = maxEth.sub(ethSold, \"LGT: not enough ETH\");\r\n        _balances[recipient] += tokensBought;\r\n        _ownedSupply = ownedSupply + tokensBought;\r\n        if (ethRefund != 0) {\r\n            buyer.call{value: ethRefund}(\"\");\r\n        }\r\n        return ethSold;\r\n    }\r\n\r\n    /// @notice Convert ether to tokens. Specify the maximum input (in ether) and\r\n    ///         the exact output (in tokens). Any remaining ether is refunded.\r\n    /// @param tokensBought The exact amount of tokens you want to receive.\r\n    ///        Will revert if less than `tokensBought` tokens can be bought\r\n    ///        with the sent amount of ether.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @dev Excess ether after buying `tokensBought` tokens is refunded.\r\n    /// @return The amount of ether sold to buy `tokensBought` tokens.\r\n    function ethToTokenSwapOutput(uint256 tokensBought, uint256 deadline)\r\n        external\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        return ethToTokenOutput(tokensBought, msg.value, deadline, msg.sender, msg.sender);\r\n    }\r\n\r\n    /// @notice Convert ether to tokens and transfer tokens to `recipient`.\r\n    ///         Specify the maximum input (in ether) and the exact output (in tokens).\r\n    ///         Any remaining ether is refunded.\r\n    /// @param tokensBought The exact amount of tokens you want to buy and transfer to\r\n    ///        `recipient`. Will revert if less than `tokensBought` tokens can be bought\r\n    ///        with the sent amount of ether.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @param recipient Bought tokens will be transferred to this address.\r\n    /// @dev Excess ether for buying a partial token is not refunded.\r\n    ///      Requirements:\r\n    ///      - `recipient` can't be this contract or the zero address\r\n    /// @return The amount of ether sold to buy `tokensBought` tokens.\r\n    function ethToTokenTransferOutput(uint256 tokensBought, uint256 deadline, address recipient)\r\n        external\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        require(recipient != address(this)); // dev: can't send to liquid token contract\r\n        require(recipient != address(0)); // dev: can't send to zero address\r\n        return ethToTokenOutput(tokensBought, msg.value, deadline, msg.sender, recipient);\r\n    }\r\n\r\n\r\n    // ***** Trade Tokens to Ether\r\n    //       ---------------------\r\n\r\n    /// @dev Exact amount of tokens -> Minimum amount of ether\r\n    function tokenToEthInput(\r\n        uint256 tokensSold,\r\n        uint256 minEth,\r\n        uint256 deadline,\r\n        address buyer,\r\n        address payable recipient\r\n    ) internal returns (uint256) {\r\n        require(deadline >= now); // dev: deadline passed\r\n        require(tokensSold != 0); // dev: must sell one or more tokens\r\n        require(minEth != 0); // dev: minEth not set\r\n        uint256 ownedSupply = _ownedSupply;\r\n        uint256 tokenReserve = _totalMinted.sub(_totalBurned + ownedSupply);\r\n        uint256 ethBought = getInputPrice(tokensSold, tokenReserve, address(this).balance);\r\n        require(ethBought >= minEth); // dev: tokens not worth enough\r\n        _balances[buyer] = _balances[buyer].sub(tokensSold, \"LGT: amount exceeds balance\");\r\n        _ownedSupply = ownedSupply.sub(tokensSold);\r\n        recipient.call{value: ethBought}(\"\");\r\n        return ethBought;\r\n    }\r\n\r\n    /// @dev Transferring tokens to this contract will sell them.\r\n    ///      User cannot specify minEth or deadline.\r\n    function _transferToSelf(address sender, uint256 amount) internal override {\r\n        address payable _sender = payable(sender);\r\n        tokenToEthInput(amount, 1, now, _sender, _sender);\r\n    }\r\n\r\n    /// @notice Convert tokens to ether. Specify the exact input (in tokens) and\r\n    ///         the minimum output (in ether).\r\n    /// @param tokensSold The exact amount of tokens you want to sell in the\r\n    ///        transaction. Will revert you own less than `minTokens` tokens.\r\n    /// @param minEth The minimum amount of ether you want to receive for the sale\r\n    ///        of `tokensSold` tokens. Will revert if less ether would be received.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @return The amount of ether bought.\r\n    function tokenToEthSwapInput(uint256 tokensSold, uint256 minEth, uint256 deadline)\r\n        external\r\n        returns (uint256)\r\n    {\r\n        return tokenToEthInput(tokensSold, minEth, deadline, msg.sender, msg.sender);\r\n    }\r\n\r\n    /// @notice Convert tokens to ether and transfer it to `recipient`.\r\n    ///         Specify the exact input (in tokens) and the minimum output (in ether).\r\n    /// @param tokensSold The exact amount of tokens you want to sell in the\r\n    ///        transaction. Will revert you own less than `minTokens` tokens.\r\n    /// @param minEth The minimum amount of ether you want the `recipient` to receive for\r\n    ///        the sale of `tokensSold` tokens. Will revert if less ether would be transferred.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @param recipient Bought ether will be transferred to this address.\r\n    /// @dev Requirements:\r\n    ///      - `recipient` can't be this contract or the zero address\r\n    /// @return The amount of ether bought.\r\n    function tokenToEthTransferInput(\r\n        uint256 tokensSold,\r\n        uint256 minEth,\r\n        uint256 deadline,\r\n        address payable recipient\r\n    ) external returns (uint256) {\r\n        require(recipient != address(this)); // dev: can't send to liquid token contract\r\n        require(recipient != address(0)); // dev: can't send to zero address\r\n        return tokenToEthInput(tokensSold, minEth, deadline, msg.sender, recipient);\r\n    }\r\n\r\n\r\n    /// @dev Maximum amount of tokens -> Exact amount of ether\r\n    function tokenToEthOutput(\r\n        uint256 ethBought,\r\n        uint256 maxTokens,\r\n        uint256 deadline,\r\n        address buyer,\r\n        address payable recipient\r\n    ) internal returns (uint256) {\r\n        require(deadline >= now); // dev: deadline passed\r\n        require(ethBought != 0); // dev: must buy more than 0 eth\r\n        uint256 ownedSupply = _ownedSupply;\r\n        uint256 tokenReserve = _totalMinted.sub(_totalBurned + ownedSupply);\r\n        uint256 tokensSold = getOutputPrice(ethBought, tokenReserve, address(this).balance);\r\n        require(maxTokens >= tokensSold); // dev: need more tokens to sell\r\n        _balances[buyer] = _balances[buyer].sub(tokensSold, \"LGT: amount exceeds balance\");\r\n        _ownedSupply = ownedSupply.sub(tokensSold);\r\n        recipient.call{value: ethBought}(\"\");\r\n        return tokensSold;\r\n    }\r\n\r\n    /// @notice Convert tokens to ether. Specify the maximum input (in tokens) and\r\n    ///         the exact output (in ether).\r\n    /// @param ethBought The exact amount of ether you want to receive in the\r\n    ///        transaction. Will revert if tokens can't be sold for enough ether.\r\n    /// @param maxTokens The maximum amount of tokens you are willing to sell to\r\n    ///        receive `ethBought` ether. Will revert if more tokens would be needed.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @return The amount of tokens sold.\r\n    function tokenToEthSwapOutput(uint256 ethBought, uint256 maxTokens, uint256 deadline)\r\n        external\r\n        returns (uint256)\r\n    {\r\n        return tokenToEthOutput(ethBought, maxTokens, deadline, msg.sender, msg.sender);\r\n    }\r\n\r\n    /// @notice Convert tokens to ether and transfer it to `recipient`.\r\n    ///         Specify the maximum input (in tokens) and the exact output (in ether).\r\n    /// @param ethBought The exact amount of ether you want `recipient` to receive in the\r\n    ///        transaction. Will revert if tokens can't be sold for enough ether.\r\n    /// @param maxTokens The maximum amount of tokens you are willing to sell to\r\n    ///        buy `ethBought` ether. Will revert if more tokens would be needed.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @param recipient Bought ether will be transferred to this address.\r\n    /// @dev Requirements:\r\n    ///      - `recipient` can't be this contract or the zero address\r\n    /// @return The amount of tokens sold.\r\n    function tokenToEthTransferOutput(\r\n        uint256 ethBought,\r\n        uint256 maxTokens,\r\n        uint256 deadline,\r\n        address payable recipient\r\n    )\r\n        external\r\n        returns (uint256)\r\n    {\r\n        require(recipient != address(this)); // dev: can't send to liquid token contract\r\n        require(recipient != address(0)); // dev: can't send to zero address\r\n        return tokenToEthOutput(ethBought, maxTokens, deadline, msg.sender, recipient);\r\n    }\r\n\r\n    // ***** Public Price Functions\r\n    //       --------------------\r\n\r\n    /// @notice How many tokens can I buy with `ethSold` ether?\r\n    /// @param ethSold The exact amount of ether you are selling.\r\n    /// @return The amount of tokens that can be bought with `ethSold` ether.\r\n    function getEthToTokenInputPrice(uint256 ethSold) public view returns(uint256) {\r\n        uint256 tokenReserve = _totalMinted.sub(_totalBurned + _ownedSupply);\r\n        return getInputPrice(ethSold, address(this).balance, tokenReserve);\r\n    }\r\n\r\n    /// @notice What is the price for `tokensBought` tokens?\r\n    /// @param tokensBought The exact amount of tokens bought\r\n    /// @return The amount of ether needed to buy `tokensBought` tokens\r\n    function getEthToTokenOutputPrice(uint256 tokensBought) public view returns (uint256) {\r\n        uint256 tokenReserve = _totalMinted.sub(_totalBurned + _ownedSupply);\r\n        return getOutputPrice(tokensBought, address(this).balance, tokenReserve);\r\n    }\r\n\r\n    /// @notice How much ether do I receive when selling `tokensSold` tokens?\r\n    /// @param tokensSold The exact amount of tokens you are selling.\r\n    /// @return The amount of ether you receive for selling `tokensSold` tokens.\r\n    function getTokenToEthInputPrice(uint256 tokensSold) public view returns (uint256) {\r\n        uint256 tokenReserve = _totalMinted.sub(_totalBurned + _ownedSupply);\r\n        return getInputPrice(tokensSold, tokenReserve, address(this).balance);\r\n    }\r\n\r\n    /// @notice How many tokens do I need to sell to receive `ethBought` ether?\r\n    /// @param ethBought The exact amount of ether you are buying.\r\n    /// @return The amount of tokens needed to buy `ethBought` ether.\r\n    function getTokenToEthOutputPrice(uint256 ethBought) public view returns (uint256) {\r\n        uint256 tokenReserve = _totalMinted.sub(_totalBurned + _ownedSupply);\r\n        return getOutputPrice(ethBought, tokenReserve, address(this).balance);\r\n    }\r\n}\r\n\r\n// File: LiquidGasToken.sol\r\n\r\n/// @title The Liquid Gas Token. An ERC20 Gas Token with integrated liquidity pool.\r\n///        Allows for efficient ownership transfers and lower cost when buying or selling.\r\n/// @author Matthias Nadler\r\ncontract LiquidGasToken is LiquidERC20 {\r\n\r\n    // ***** Gas Token Core\r\n    //       --------------\r\n    //       Create and destroy contracts\r\n\r\n    /// @dev Create `amount` contracts that can be destroyed by this contract.\r\n    ///      Pass _totalMinted as `i`\r\n    function _createContracts(uint256 amount, uint256 i) internal {\r\n        assembly {\r\n            let end := add(i, amount)\r\n            mstore(0,\r\n                add(\r\n                    add(\r\n                        0x746d000000000000000000000000000000000000000000000000000000000000,\r\n                        shl(0x80, address())\r\n                        ),\r\n                    0x3318585733ff6000526015600bf30000\r\n                )\r\n            )\r\n            for {let j := div(amount, 32)} j {j := sub(j, 1)} {\r\n                pop(create2(0, 0, 30, add(i, 0))) pop(create2(0, 0, 30, add(i, 1)))\r\n                pop(create2(0, 0, 30, add(i, 2))) pop(create2(0, 0, 30, add(i, 3)))\r\n                pop(create2(0, 0, 30, add(i, 4))) pop(create2(0, 0, 30, add(i, 5)))\r\n                pop(create2(0, 0, 30, add(i, 6))) pop(create2(0, 0, 30, add(i, 7)))\r\n                pop(create2(0, 0, 30, add(i, 8))) pop(create2(0, 0, 30, add(i, 9)))\r\n                pop(create2(0, 0, 30, add(i, 10))) pop(create2(0, 0, 30, add(i, 11)))\r\n                pop(create2(0, 0, 30, add(i, 12))) pop(create2(0, 0, 30, add(i, 13)))\r\n                pop(create2(0, 0, 30, add(i, 14))) pop(create2(0, 0, 30, add(i, 15)))\r\n                pop(create2(0, 0, 30, add(i, 16))) pop(create2(0, 0, 30, add(i, 17)))\r\n                pop(create2(0, 0, 30, add(i, 18))) pop(create2(0, 0, 30, add(i, 19)))\r\n                pop(create2(0, 0, 30, add(i, 20))) pop(create2(0, 0, 30, add(i, 21)))\r\n                pop(create2(0, 0, 30, add(i, 22))) pop(create2(0, 0, 30, add(i, 23)))\r\n                pop(create2(0, 0, 30, add(i, 24))) pop(create2(0, 0, 30, add(i, 25)))\r\n                pop(create2(0, 0, 30, add(i, 26))) pop(create2(0, 0, 30, add(i, 27)))\r\n                pop(create2(0, 0, 30, add(i, 28))) pop(create2(0, 0, 30, add(i, 29)))\r\n                pop(create2(0, 0, 30, add(i, 30))) pop(create2(0, 0, 30, add(i, 31)))\r\n                i := add(i, 32)\r\n            }\r\n\r\n            for { } lt(i, end) { i := add(i, 1) } {\r\n                pop(create2(0, 0, 30, i))\r\n            }\r\n            sstore(_totalMinted_slot, end)\r\n        }\r\n    }\r\n\r\n    /// @dev calculate the address of a child contract given its salt\r\n    function computeAddress2(uint256 salt) external view returns (address child) {\r\n        assembly {\r\n            let data := mload(0x40)\r\n            mstore(data,\r\n                add(\r\n                    0xff00000000000000000000000000000000000000000000000000000000000000,\r\n                    shl(0x58, address())\r\n                )\r\n            )\r\n            mstore(add(data, 21), salt)\r\n            mstore(add(data, 53),\r\n                add(\r\n                    add(\r\n                        0x746d000000000000000000000000000000000000000000000000000000000000,\r\n                        shl(0x80, address())\r\n                    ),\r\n                    0x3318585733ff6000526015600bf30000\r\n                )\r\n            )\r\n            mstore(add(data, 53), keccak256(add(data, 53), 30))\r\n            child := and(keccak256(data, 85), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n        }\r\n    }\r\n\r\n    /// @dev Destroy `amount` contracts and free the gas.\r\n    ///      Pass _totalBurned as `i`\r\n    function _destroyContracts(uint256 amount, uint256 i) internal {\r\n        assembly {\r\n            let end := add(i, amount)\r\n\r\n            let data := mload(0x40)\r\n            mstore(data,\r\n                add(\r\n                    0xff00000000000000000000000000000000000000000000000000000000000000,\r\n                    shl(0x58, address())\r\n                )\r\n            )\r\n            mstore(add(data, 53),\r\n                add(\r\n                    add(\r\n                        0x746d000000000000000000000000000000000000000000000000000000000000,\r\n                        shl(0x80, address())\r\n                    ),\r\n                    0x3318585733ff6000526015600bf30000\r\n                )\r\n            )\r\n            mstore(add(data, 53), keccak256(add(data, 53), 30))\r\n            let ptr := add(data, 21)\r\n            for { } lt(i, end) { i := add(i, 1) } {\r\n                mstore(ptr, i)\r\n                pop(call(gas(), keccak256(data, 85), 0, 0, 0, 0, 0))\r\n            }\r\n\r\n            sstore(_totalBurned_slot, end)\r\n        }\r\n    }\r\n\r\n    // *** Constructor\r\n\r\n    // @dev: Set initial liquidity. Must mint at least 1 token to the pool.\r\n    constructor() public {\r\n        _createContracts(1, 0);\r\n    }\r\n\r\n    // ***** Gas Token Minting\r\n    //       -----------------\r\n    //       Different ways to mint Gas Tokens\r\n\r\n\r\n    // *** Mint to owner\r\n\r\n    /// @notice Mint personally owned Liquid Gas Tokens.\r\n    /// @param amount The amount of tokens to mint.\r\n    function mint(uint256 amount) external {\r\n        _createContracts(amount, _totalMinted);\r\n        _balances[msg.sender] += amount;\r\n        _ownedSupply += amount;\r\n    }\r\n\r\n    /// @notice Mint Liquid Gas Tokens for `recipient`.\r\n    /// @param amount The amount of tokens to mint.\r\n    /// @param recipient The owner of the minted Liquid Gas Tokens.\r\n    function mintFor(uint256 amount, address recipient) external {\r\n        _createContracts(amount, _totalMinted);\r\n        _balances[recipient] += amount;\r\n        _ownedSupply += amount;\r\n    }\r\n\r\n    // *** Mint to liquidity pool\r\n\r\n    /// @notice Mint Liquid Gas Tokens and add them to the Liquidity Pool.\r\n    ///         The amount of tokens minted and added to the pool is calculated\r\n    ///         from the amount of ether sent and `maxTokens`.\r\n    ///         The liquidity shares are created for the `recipient`.\r\n    ///         Emits an {AddLiquidity} event.\r\n    /// @dev This is much more efficient than minting tokens and adding them\r\n    ///      to the liquidity pool in two separate steps.\r\n    ///      Excess ether that is not added to the pool will be refunded.\r\n    ///      Requirements:\r\n    ///      - `recipient` can't be this contract or the zero address\r\n    /// @param maxTokens The maximum amount of tokens that will be minted.\r\n    ///         Set this to cap the gas the transaction will use.\r\n    ///         If more than maxTokens could be created, the remaining ether is refunded.\r\n    /// @param minLiquidity The minimum amount of liquidity shares to create,\r\n    ///         will revert if not enough liquidity can be created.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @param recipient Liquidity shares are created for this address.\r\n    /// @return tokenAmount Amount of tokens minted and invested.\r\n    /// @return ethAmount Amount of ether invested.\r\n    /// @return liquidityCreated Number of liquidity shares created.\r\n    function mintToLiquidity(\r\n        uint256 maxTokens,\r\n        uint256 minLiquidity,\r\n        uint256 deadline,\r\n        address recipient\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256 tokenAmount, uint256 ethAmount, uint256 liquidityCreated)\r\n    {\r\n        require(deadline >= now); // dev: deadline passed\r\n        require(maxTokens != 0); // dev: can't mint less than 1 token\r\n        require(msg.value != 0); // dev: must provide ether to add liquidity\r\n\r\n        // calculate optimum values for tokens and ether to add\r\n        uint256 totalMinted = _totalMinted;\r\n        tokenAmount = maxTokens;\r\n        uint256 tokenReserve = totalMinted.sub(_totalBurned + _ownedSupply);\r\n        uint ethReserve = address(this).balance - msg.value;\r\n        ethAmount = (tokenAmount.mul(ethReserve) / tokenReserve).sub(1);\r\n        if (ethAmount > msg.value) {\r\n            // reduce amount of tokens minted to provide maximum possible liquidity\r\n            tokenAmount = (msg.value + 1).mul(tokenReserve) / ethReserve;\r\n            ethAmount = (tokenAmount.mul(ethReserve) / tokenReserve).sub(1);\r\n        }\r\n        uint256 totalLiquidity = _poolTotalSupply;\r\n        liquidityCreated = ethAmount.mul(totalLiquidity) / ethReserve;\r\n        require(liquidityCreated >= minLiquidity); // dev: not enough liquidity can be created\r\n\r\n        // Mint tokens directly to the liquidity pool\r\n        _createContracts(tokenAmount, totalMinted);\r\n\r\n        // Create liquidity shares for recipient\r\n        _poolTotalSupply = totalLiquidity + liquidityCreated;\r\n        _poolBalances[recipient] += liquidityCreated;\r\n\r\n        emit AddLiquidity(recipient, ethAmount, tokenAmount);\r\n\r\n        // refund excess ether\r\n        if (msg.value > ethAmount) {\r\n            msg.sender.call{value: msg.value - ethAmount}(\"\");\r\n        }\r\n        return (tokenAmount, ethAmount, liquidityCreated);\r\n    }\r\n\r\n    // *** Mint to sell\r\n\r\n    /// @notice Mint Liquid Gas Tokens, immediately sell them for ether and\r\n    ///         transfer the ether to the `recipient`.\r\n    /// @dev This is much more efficient than minting tokens and then selling them\r\n    ///      in two separate steps.\r\n    /// @param amount The amount of tokens to mint and sell.\r\n    /// @param minEth The minimum amount of ether to receive for the transaction.\r\n    ///         Will revert if the tokens don't sell for enough ether;\r\n    ///         The gas for minting is not used.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @return The amount of ether received from the sale.\r\n    function mintToSellTo(\r\n        uint256 amount,\r\n        uint256 minEth,\r\n        uint256 deadline,\r\n        address payable recipient\r\n    )\r\n        public\r\n        returns (uint256)\r\n    {\r\n        require(deadline >= now); // dev: deadline passed\r\n        require(amount != 0); // dev: must sell one or more tokens\r\n        uint256 totalMinted = _totalMinted;\r\n        uint256 tokenReserve = totalMinted.sub(_totalBurned + _ownedSupply);\r\n        uint256 ethBought = getInputPrice(amount, tokenReserve, address(this).balance);\r\n        require(ethBought >= minEth); // dev: tokens not worth enough\r\n        _createContracts(amount, totalMinted);\r\n        recipient.call{value: ethBought}(\"\");\r\n        return ethBought;\r\n    }\r\n\r\n    /// @notice Mint Liquid Gas Tokens and immediately sell them for ether.\r\n    /// @dev This is much more efficient than minting tokens and then selling them\r\n    ///      in two separate steps.\r\n    /// @param amount The amount of tokens to mint and sell.\r\n    /// @param minEth The minimum amount of ether to receive for the transaction.\r\n    ///         Will revert if the tokens don't sell for enough ether;\r\n    ///         The gas for minting is not used.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @return The amount of ether received from the sale.\r\n    function mintToSell(\r\n        uint256 amount,\r\n        uint256 minEth,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (uint256)\r\n    {\r\n        return mintToSellTo(amount, minEth, deadline, msg.sender);\r\n    }\r\n\r\n    // ***** Gas Token Freeing\r\n    //       -----------------\r\n    //       Different ways to free Gas Tokens\r\n\r\n\r\n    // *** Free owned tokens\r\n\r\n    /// @notice Free `amount` of Liquid Gas Tokens from the `sender`'s balance.\r\n    /// @param amount The amount of tokens to free\r\n    /// @return True if `tokenAmount` tokens could be freed, False otherwise.\r\n    function free(uint256 amount) external returns (bool) {\r\n        uint256 balance = _balances[msg.sender];\r\n        if (balance < amount) {\r\n            return false;\r\n        }\r\n        _balances[msg.sender] = balance - amount;\r\n        _ownedSupply = _ownedSupply.sub(amount);\r\n        _destroyContracts(amount, _totalBurned);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Free `amount` of Liquid Gas Tokens from the `owners`'s balance.\r\n    /// @param amount The amount of tokens to free\r\n    /// @param owner The `owner` of the tokens. The `sender` must have an allowance.\r\n    /// @return True if `tokenAmount` tokens could be freed, False otherwise.\r\n    function freeFrom(uint256 amount, address owner) external returns (bool) {\r\n        uint256 balance = _balances[owner];\r\n        if (balance < amount) {\r\n            return false;\r\n        }\r\n        uint256 currentAllowance = _allowances[owner][msg.sender];\r\n        if (currentAllowance < amount) {\r\n            return false;\r\n        }\r\n        _balances[owner] = balance - amount;\r\n        _ownedSupply = _ownedSupply.sub(amount);\r\n        _approve(owner, msg.sender, currentAllowance - amount);\r\n        _destroyContracts(amount, _totalBurned);\r\n        return true;\r\n    }\r\n\r\n    // *** Free from liquidity pool\r\n\r\n    /// @notice Buy `amount` tokens from the liquidity pool and immediately free them.\r\n    /// @param amount The amount of tokens to buy and free.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @param refundTo Any excess ether will be refunded to this address.\r\n    /// @dev This will not revert unless an unexpected error occurs. Instead it will return 0.\r\n    /// @return The amount of ether spent to buy `amount` tokens.\r\n    function buyAndFree(\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        address payable refundTo\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        if (deadline < now) {\r\n            refundTo.call{value: msg.value}(\"\");\r\n            return 0;\r\n        }\r\n        uint256 totalBurned = _totalBurned;\r\n        uint256 tokenReserve = _totalMinted.sub(totalBurned + _ownedSupply);\r\n        if (tokenReserve < amount) {\r\n            refundTo.call{value: msg.value}(\"\");\r\n            return 0;\r\n        }\r\n        uint256 ethReserve = address(this).balance - msg.value;\r\n        uint256 ethSold = getOutputPrice(amount, ethReserve, tokenReserve);\r\n        if (msg.value < ethSold) {\r\n            refundTo.call{value: msg.value}(\"\");\r\n            return 0;\r\n        }\r\n        uint256 ethRefund = msg.value - ethSold;\r\n        _destroyContracts(amount, totalBurned);\r\n        if (ethRefund != 0) {\r\n            refundTo.call{value: ethRefund}(\"\");\r\n        }\r\n        return ethSold;\r\n    }\r\n\r\n    /// @notice Buy as many tokens as possible from the liquidity pool and immediately free them.\r\n    ///         Will buy less than `maxTokens` if not enough ether is provided.\r\n    ///         Excess ether is not refunded!\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @dev Will revert if deadline passed to refund the ether.\r\n    /// @return The amount of tokens bought and freed.\r\n    function buyMaxAndFree(uint256 deadline)\r\n        external\r\n        payable\r\n        returns (uint256)\r\n    {\r\n        require(deadline >= now); // dev: deadline passed\r\n        uint256 ethReserve = address(this).balance - msg.value;\r\n        uint256 totalBurned = _totalBurned;\r\n        uint256 tokenReserve = _totalMinted.sub(totalBurned + _ownedSupply);\r\n        uint256 tokensBought = getInputPrice(msg.value, ethReserve, tokenReserve);\r\n        _destroyContracts(tokensBought, totalBurned);\r\n        return tokensBought;\r\n    }\r\n\r\n    // ***** Deployment Functions\r\n    //       ------------------\r\n    //       Execute a deployment while buying tokens and freeing them.\r\n\r\n\r\n    /// @notice Deploy a contract via create() while buying and freeing `tokenAmount` tokens\r\n    ///         to reduce the gas cost. You need to provide ether to buy the tokens.\r\n    ///         Any excess ether is refunded.\r\n    /// @param tokenAmount The number of tokens bought and freed.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @param bytecode The bytecode of the contract you want to deploy.\r\n    /// @dev Will revert if deadline passed or not enough ether is sent.\r\n    ///      Can't send ether with deployment. Pre-fund the address instead.\r\n    /// @return contractAddress The address where the contract was deployed.\r\n\r\n    function deploy(uint256 tokenAmount, uint256 deadline, bytes memory bytecode)\r\n        external\r\n        payable\r\n        returns (address contractAddress)\r\n    {\r\n        require(deadline >= now); // dev: deadline passed\r\n        uint256 totalBurned = _totalBurned;\r\n        uint256 tokenReserve = _totalMinted.sub(totalBurned + _ownedSupply);\r\n        uint256 price = getOutputPrice(tokenAmount, address(this).balance - msg.value, tokenReserve);\r\n        uint256 refund = msg.value.sub(price, \"LGT: insufficient ether\");\r\n        _destroyContracts(tokenAmount, totalBurned);\r\n\r\n        if (refund > 0) {\r\n            msg.sender.call{value: refund}(\"\");\r\n        }\r\n        assembly {\r\n            contractAddress := create(0, add(bytecode, 32), mload(bytecode))\r\n        }\r\n        return contractAddress;\r\n    }\r\n\r\n    /// @notice Deploy a contract via create2() while buying and freeing `tokenAmount` tokens\r\n    ///         to reduce the gas cost. You need to provide ether to buy the tokens.\r\n    ///         Any excess ether is refunded.\r\n    /// @param tokenAmount The number of tokens bought and freed.\r\n    /// @param deadline The time after which the transaction can no longer be executed.\r\n    ///        Will revert if the current timestamp is after the deadline.\r\n    /// @param salt The salt is used for create2() to determine the deployment address.\r\n    /// @param bytecode The bytecode of the contract you want to deploy.\r\n    /// @dev Will revert if deadline passed or not enough ether is sent.\r\n    ///      Can't send ether with deployment. Pre-fund the address instead.\r\n    /// @return contractAddress The address where the contract was deployed.\r\n    function create2(uint256 tokenAmount, uint256 deadline, uint256 salt, bytes memory bytecode)\r\n        external\r\n        payable\r\n        returns (address contractAddress)\r\n    {\r\n        require(deadline >= now); // dev: deadline passed\r\n        uint256 totalBurned = _totalBurned;\r\n        uint256 tokenReserve = _totalMinted.sub(totalBurned + _ownedSupply);\r\n        uint256 price = getOutputPrice(tokenAmount, address(this).balance - msg.value, tokenReserve);\r\n        uint256 refund = msg.value.sub(price, \"LGT: insufficient ether\");\r\n        _destroyContracts(tokenAmount, totalBurned);\r\n\r\n        if (refund > 0) {\r\n            msg.sender.call{value: refund}(\"\");\r\n        }\r\n        assembly {\r\n            contractAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        return contractAddress;\r\n    }\r\n\r\n    // ***** Advanced Functions !!! USE AT YOUR OWN RISK !!!\r\n    //       -----------------------------------------------\r\n    //       These functions are gas optimized and intended for experienced users.\r\n    //       The function names are constructed to have 3 or 4 leading zero bytes\r\n    //       in the function selector.\r\n    //       Additionally, all checks have been omitted and need to be done before\r\n    //       sending the call if desired.\r\n    //       There are also no return values to further save gas.\r\n\r\n\r\n    /// @notice Mint Liquid Gas Tokens and immediately sell them for ether.\r\n    /// @dev 3 zero bytes function selector (0x000000079) and removed all checks.\r\n    ///      !!! USE AT YOUR OWN RISK !!!\r\n    /// @param amount The amount of tokens to mint and sell.\r\n    function mintToSell9630191(uint256 amount) external {\r\n        uint256 totalMinted = _totalMinted;\r\n        uint256 ethBought = getInputPrice(\r\n            amount,\r\n            totalMinted.sub(_totalBurned + _ownedSupply),\r\n            address(this).balance\r\n        );\r\n        _createContracts(amount, totalMinted);\r\n        msg.sender.call{value: ethBought}(\"\");\r\n    }\r\n\r\n    /// @notice Mint Liquid Gas Tokens, immediately sell them for ether and\r\n    ///         transfer the ether to the `recipient`.\r\n    /// @dev 3 zero bytes function selector (0x00000056) and removed all checks.\r\n    ///      !!! USE AT YOUR OWN RISK !!!\r\n    /// @param amount The amount of tokens to mint and sell.\r\n    /// @param recipient The address the ether is sent to\r\n    function mintToSellTo25630722(uint256 amount, address payable recipient) external {\r\n        uint256 totalMinted = _totalMinted;\r\n        uint256 ethBought = getInputPrice(\r\n            amount,\r\n            totalMinted.sub(_totalBurned + _ownedSupply),\r\n            address(this).balance\r\n        );\r\n        _createContracts(amount, totalMinted);\r\n        recipient.call{value: ethBought}(\"\");\r\n    }\r\n\r\n\r\n    /// @notice Buy `amount` tokens from the liquidity pool and immediately free them.\r\n    ///         Make sure to pass the exact amount for tokens and sent ether:\r\n    ///             - There are no refunds for unspent ether!\r\n    ///             - Get the exact price by calling getEthToTokenOutputPrice(`amount`)\r\n    ///               before sending the call in the same transaction.\r\n    /// @dev 4 zero bytes function selector (0x00000000) and removed all checks.\r\n    ///      !!! USE AT YOUR OWN RISK !!!\r\n    /// @param amount The amount of tokens to buy and free.\r\n    function buyAndFree22457070633(uint256 amount) external payable {\r\n        uint256 totalBurned = _totalBurned;\r\n        uint256 ethSold = getOutputPrice(\r\n            amount,\r\n            address(this).balance - msg.value,\r\n            _totalMinted.sub(totalBurned + _ownedSupply)\r\n        );\r\n        if (msg.value >= ethSold) {\r\n            _destroyContracts(amount, totalBurned);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"eth_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"token_amount\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"eth_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"token_amount\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferLiquidity\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"refundTo\",\"type\":\"address\"}],\"name\":\"buyAndFree\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyAndFree22457070633\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"buyMaxAndFree\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"computeAddress2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"child\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"}],\"name\":\"create2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"ethToTokenSwapInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"ethToTokenSwapOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"ethToTokenTransferInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"ethToTokenTransferOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"free\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"freeFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethSold\",\"type\":\"uint256\"}],\"name\":\"getEthToTokenInputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"}],\"name\":\"getEthToTokenOutputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensSold\",\"type\":\"uint256\"}],\"name\":\"getTokenToEthInputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethBought\",\"type\":\"uint256\"}],\"name\":\"getTokenToEthOutputPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintToLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityCreated\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"mintToSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintToSell9630191\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintToSellTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintToSellTo25630722\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"poolBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTokenReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"poolTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"tokenToEthSwapInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethBought\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"tokenToEthSwapOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"tokenToEthTransferInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethBought\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"tokenToEthTransferOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LiquidGasToken", "CompilerVersion": "v0.6.9+commit.3e3065ac", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d4dc0e6f45a475542267839c0aefc2c9869bbb318a9af1e1630bd6bded780fc6"}