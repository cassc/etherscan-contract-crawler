{"SourceCode": "pragma solidity ^0.6.0;\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals()\r\n    external\r\n    view\r\n    returns (\r\n      uint8\r\n    );\r\n\r\n  function description()\r\n    external\r\n    view\r\n    returns (\r\n      string memory\r\n    );\r\n\r\n  function version()\r\n    external\r\n    view\r\n    returns (\r\n      uint256\r\n    );\r\n\r\n  function getRoundData(\r\n    uint80 _roundId\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\n\r\npragma solidity 0.6.0;\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary SafeMath {\r\n    function percent(uint value,uint numerator, uint denominator, uint precision) internal pure  returns(uint quotient) {\r\n        uint _numerator  = numerator * 10 ** (precision+1);\r\n        uint _quotient =  ((_numerator / denominator) + 5) / 10;\r\n        return (value*_quotient/1000000000000000000);\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n  // Empty internal constructor, to prevent people from mistakenly deploying\r\n  // an instance of this contract, which should be used via inheritance.\r\n  constructor () internal { }\r\n\r\n  function _msgSender() internal view returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context{\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor () internal {\r\n    address msgSender = 0x31b1741aDD90421b14dc5801803d1958AC07c53D;//_msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns ( address ) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n//   function renounceOwnership() public onlyOwner {\r\n//     emit OwnershipTransferred(_owner, address(0));\r\n//     _owner = address(0);\r\n//   }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n//   function transferOwnership(address newOwner) public onlyOwner {\r\n//     _transferOwnership(newOwner);\r\n//   }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract PriceContract {\r\n    \r\n    AggregatorV3Interface internal priceFeed;\r\n    address private priceAddress = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419; // ETH/USD Mainnet\r\n    // address private priceAddress = 0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e; // ETH/USD Goerli Testnet\r\n    //https://docs.chain.link/docs/bnb-chain-addresses/\r\n\r\n    constructor() public {\r\n        priceFeed = AggregatorV3Interface(priceAddress);\r\n    }\r\n\r\n    function getLatestPrice() public view returns (uint) {\r\n        (,int price,,uint timeStamp,)= priceFeed.latestRoundData();\r\n        // If the round is not complete yet, timestamp is 0\r\n        require(timeStamp > 0, \"Round not complete\");\r\n        return (uint)(price);\r\n    }\r\n}\r\n\r\ncontract tokenSale is Ownable,PriceContract{\r\n    \r\n    address public reduxToken;\r\n    uint256 internal price = 1111*1e18; //0.0009 usdt // 1111 token per USD\r\n    uint256 public minInvestment = 50*1e18; \r\n    bool saleActive=false; \r\n    //uint256 public softCap = 1200000*1e18;\r\n    //uint256 public hardCap = 3000000*1e18;\r\n    uint256 public totalInvestment = 0;\r\n    Token token = Token(0x8b4F9739DC6BA5076bcdCF786C96baeE6A2e8F0B); // Token;\r\n    Token usdt = Token(0xdAC17F958D2ee523a2206206994597C13D831ec7); // USDT\r\n\r\n    struct userStruct{\r\n        bool isExist;\r\n        uint256 investment;\r\n        uint256 ClaimTime;\r\n        uint256 lockedAmount;\r\n    }\r\n    mapping(address => userStruct) public user;\r\n    mapping(address => uint256) public ethInvestment;\r\n    mapping(address => uint256) public usdtInvestment;\r\n\r\n    constructor() public{\r\n    }\r\n    \r\n    fallback() external  {\r\n        purchaseTokensWithETH();\r\n    }\r\n    \r\n    \r\n    function purchaseTokensWithETH() payable public{   // with BNB\r\n        uint256 amount = msg.value;       \r\n        require(saleActive == true, \"Sale not started yet!\");\r\n     \r\n        //busd.transferFrom(msg.sender, address(this), amount);\r\n        uint256 ethToUsd =  calculateUsd(amount); \r\n        require(ethToUsd>=minInvestment ,\"Check minimum investment!\");\r\n        uint256 usdToTokens = SafeMath.mul(price, ethToUsd);\r\n        uint256 tokenAmount = SafeMath.div(usdToTokens,1e18);\r\n        \r\n        user[msg.sender].lockedAmount = user[msg.sender].lockedAmount + tokenAmount;\r\n        user[msg.sender].ClaimTime = now;\r\n\r\n        ethInvestment[msg.sender] = ethInvestment[msg.sender] + msg.value ;\r\n        totalInvestment = totalInvestment + ethToUsd;\r\n\r\n        //require(totalInvestment <= hardCap, \"Trying to cross Hardcap!\"); \r\n        forwardFunds();\r\n    }\r\n\r\n    function calculateUsd(uint256 bnbAmount) public view returns(uint256){\r\n        uint256 ethPrice = getLatestPrice();\r\n        uint256 incomingEthToUsd = SafeMath.mul(bnbAmount, ethPrice) ;\r\n        uint256 fixIncomingEthToUsd = SafeMath.div(incomingEthToUsd,1e8);\r\n        return fixIncomingEthToUsd;\r\n    }\r\n\r\n    function purchaseTokensWithStableCoin(uint256 amount) public {\r\n        require(amount>=minInvestment ,\"Check minimum investment!\");   \r\n        require(saleActive == true, \"Sale not started yet!\");\r\n\r\n        uint256 usdToTokens = SafeMath.mul(price, amount);\r\n        uint256 tokenAmount = SafeMath.div(usdToTokens,1e18);\r\n       \r\n        usdt.transferFrom(msg.sender, address(this), amount/1e12);\r\n        usdtInvestment[msg.sender] = usdtInvestment[msg.sender] + amount ;\r\n        \r\n        user[msg.sender].lockedAmount = user[msg.sender].lockedAmount + tokenAmount;\r\n        user[msg.sender].ClaimTime = now; \r\n        totalInvestment = totalInvestment + amount;\r\n\r\n        //require(totalInvestment <= hardCap, \"Trying to cross Hardcap!\"); \r\n        forwardFunds();\r\n    }\r\n    \r\n    function claimTokens() public{ \r\n        require(user[msg.sender].ClaimTime < now,\"Claim time not reached!\");\r\n        require(user[msg.sender].lockedAmount >=0,\"No Amount to Claim\");\r\n        token.transfer(msg.sender,user[msg.sender].lockedAmount);\r\n        user[msg.sender].lockedAmount = 0;\r\n    }\r\n     \r\n    function updatePrice(uint256 tokenPrice) public {\r\n        require(msg.sender==owner(),\"Only owner can update contract!\");\r\n        price=tokenPrice;\r\n    }\r\n    \r\n    function startSale() public{\r\n        require(msg.sender==owner(),\"Only owner can update contract!\");\r\n        saleActive = true;\r\n    }\r\n\r\n    function stopSale() public{\r\n        require(msg.sender==owner(),\"Only owner can update contract!\");\r\n        saleActive = false;\r\n    }\r\n\r\n    function setMin(uint256 min) public{\r\n        require(msg.sender==owner(),\"Only owner can update contract!\");\r\n        minInvestment=min;\r\n    }\r\n        \r\n    function withdrawRemainingTokensAfterICO() public{\r\n        require(msg.sender==owner(),\"Only owner can update contract!\");\r\n        require(token.balanceOf(address(this)) >=0 , \"Tokens Not Available in contract, contact Admin!\");\r\n        token.transfer(msg.sender,token.balanceOf(address(this)));\r\n    }\r\n    \r\n    function forwardFunds() internal {\r\n        address payable ICOadmin = address(uint160(owner()));\r\n        ICOadmin.transfer(address(this).balance);   \r\n        usdt.transfer(owner(), usdt.balanceOf(address(this)));\r\n    }\r\n    \r\n    function withdrawFunds() public{\r\n        //require(totalInvestment >= softCap,\"Sale Not Success!\");\r\n        require(msg.sender==owner(),\"Only owner can Withdraw!\");\r\n        forwardFunds();\r\n    }\r\n\r\n       \r\n    function calculateTokenAmount(uint256 amount) external view returns (uint256){\r\n        uint tokens = SafeMath.mul(amount,price);\r\n        return tokens;\r\n    }\r\n    \r\n    function tokenPrice() external view returns (uint256){\r\n        return price;\r\n    }\r\n    \r\n    function investments(address add) external view returns (uint256,uint256,uint256,uint256){\r\n        return (ethInvestment[add], ethInvestment[add], usdtInvestment[add],totalInvestment);\r\n    }\r\n}\r\n\r\nabstract contract Token {\r\n    function transferFrom(address sender, address recipient, uint256 amount) virtual external;\r\n    function transfer(address recipient, uint256 amount) virtual external;\r\n    function balanceOf(address account) virtual external view returns (uint256)  ;\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bnbAmount\",\"type\":\"uint256\"}],\"name\":\"calculateUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"investments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchaseTokensWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"purchaseTokensWithStableCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reduxToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"}],\"name\":\"setMin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usdtInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ClaimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRemainingTokensAfterICO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "tokenSale", "CompilerVersion": "v0.6.0+commit.26b70077", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://80dffe49c0513fb0ae35884a787b26ef57f9a55fe67fb5630fd584b25a1110cc"}