{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Resolver.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: WTFPL.ETH\\npragma solidity >0.8.0 <0.9.0;\\n\\n/**\\n * @author 0xc0de4c0ffee, sshmatrix (BeenSick Labs)\\n * @title IsTest CCIP Resolver\\n * @notice GOERLI DEPLOY\\n */\\ncontract Resolver {\\n    address public Dev;\\n    string public chainID = \\\"5\\\";\\n\\n    /// @dev : Error events\\n    error RequestError();\\n    error InvalidSignature(string reason);\\n    error InvalidHash();\\n    error InvalidResponse();\\n    error SignatureExpired();\\n    error OffchainLookup(\\n        address sender,\\n        string[] urls,\\n        bytes callData,\\n        bytes4 callbackFunction,\\n        bytes extraData\\n    );\\n\\n    function supportsInterface(bytes4 sig) external pure returns (bool) {\\n        return (sig == Resolver.resolve.selector ||\\n            sig == Resolver.supportsInterface.selector);\\n    }\\n\\n    /// @dev : Emitted events\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n    event ChainIDChanged(string chainID, string newChainID);\\n    event NewGateway(address operator, string domain);\\n    event RemovedGateway(uint index, address operator, string domain);\\n    event ReplacedGateway(\\n        uint index,\\n        address operator,\\n        string oldDomain,\\n        string newDomain\\n    );\\n\\n    /// @dev : Gateway struct\\n    struct Gate {\\n        string domain;\\n        address operator;\\n    }\\n    Gate[] public Gateways;\\n    mapping(address => bool) public isSigner;\\n\\n    /**\\n     * @dev Constructor\\n     */\\n    constructor() {\\n        Dev = msg.sender;\\n        /// @dev : set initial Gateway here\\n        Gateways.push(\\n            Gate(\\n                \\\"sshmatrix.club:3002\\\",\\n                0xa4353251b65597F11aCD84a7F2de75aEd9e92F7C\\n            )\\n        );\\n        isSigner[0xa4353251b65597F11aCD84a7F2de75aEd9e92F7C] = true;\\n    }\\n\\n    /**\\n     * @dev Custom DNSDecode() function [see ENSIP-10]\\n     * @param encoded : encoded byte string\\n     * @return _name : name to resolve on testnet\\n     * @return namehash : hash of name to resolve on testnet\\n     */\\n    function DNSDecode(\\n        bytes calldata encoded\\n    ) public pure returns (string memory _name, bytes32 namehash) {\\n        uint j;\\n        uint len;\\n        bytes[] memory labels = new bytes[](12); // max 11 ...bob.alice.istest.eth\\n        for (uint i; encoded[i] > 0x0; ) {\\n            len = uint8(bytes1(encoded[i:++i]));\\n            labels[j] = encoded[i:i += len];\\n            j++;\\n        }\\n        _name = string(labels[--j]); // 'eth' label\\n        // pop 'istest' label\\n        namehash = keccak256(\\n            abi.encodePacked(bytes32(0), keccak256(labels[j--]))\\n        ); // namehash of 'eth'\\n        if (j == 0) {\\n            // istest.eth\\n            return (\\n                string.concat(string(labels[0]), \\\".\\\", _name),\\n                keccak256(abi.encodePacked(namehash, keccak256(labels[0])))\\n            );\\n        }\\n\\n        while (j > 0) {\\n            // return ...bob.alice.eth\\n            _name = string.concat(string(labels[--j]), \\\".\\\", _name); // pop 'istest' label\\n            namehash = keccak256(\\n                abi.encodePacked(namehash, keccak256(labels[j]))\\n            ); // namehash without 'istest' label\\n        }\\n    }\\n\\n    /**\\n     * @dev Selects and construct random gateways for CCIP resolution\\n     * @param _name : name to resolve on testnet e.g. alice.eth\\n     * @return urls : ordered list of gateway URLs for HTTP calls\\n     */\\n    function randomGateways(\\n        string memory _name\\n    ) public view returns (string[] memory urls) {\\n        uint gLen = Gateways.length;\\n        uint len = (gLen / 2) + 1;\\n        if (len > 5) len = 5;\\n        urls = new string[](len);\\n        // pseudo random seeding\\n        uint k = uint(\\n            keccak256(\\n                abi.encodePacked(\\n                    block.timestamp,\\n                    _name,\\n                    msg.sender,\\n                    blockhash(block.number - 1)\\n                )\\n            )\\n        );\\n        for (uint i; i < len; ) {\\n            k = uint(keccak256(abi.encodePacked(k, msg.sender))) % gLen;\\n            // Gateway @ URL e.g. https://example.xyz/eip155:1/alice.eth/{data}\\n            urls[i++] = string.concat(\\n                \\\"https://\\\",\\n                Gateways[k].domain,\\n                \\\"/eip155\\\",\\n                \\\":\\\",\\n                chainID,\\n                \\\"/\\\",\\n                _name,\\n                \\\"/{data}\\\"\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Resolves a name with CCIP-Read OffChainLookup()\\n     * @param encoded : DNS-encoded mainnet name e.g. alice.istest.eth\\n     * @param data : CCIP call data\\n     */\\n    function resolve(\\n        bytes calldata encoded,\\n        bytes calldata data\\n    ) external view returns (bytes memory) {\\n        (string memory _name, bytes32 namehash) = DNSDecode(encoded);\\n        revert OffchainLookup(\\n            address(this), // sender/callback contract\\n            randomGateways(_name), // gateway URL array\\n            bytes.concat( // custom callData {data} [see ENSIP-10] + encoded name for eth_call by HTTP gateway\\n                data[:4],\\n                namehash,\\n                data.length > 36 ? data[36:] : bytes(\\\"\\\")\\n            ),\\n            Resolver.__callback.selector, // callback function\\n            abi.encode( // callback extradata\\n                block.number,\\n                namehash,\\n                keccak256(\\n                    abi.encodePacked(\\n                        blockhash(block.number - 1),\\n                        namehash,\\n                        msg.sender\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev CCIP callback function\\n     * @param response : response of HTTP call\\n     * @param extraData : extradata from resolve function\\n     */\\n    function __callback(\\n        bytes calldata response,\\n        bytes calldata extraData\\n    ) external view returns (bytes memory) {\\n        /// decode extraData\\n        (uint blocknum, bytes32 namehash, bytes32 _hash) = abi.decode(\\n            extraData,\\n            (uint, bytes32, bytes32)\\n        );\\n        /// check hash & timeout @ 3 blocks\\n        if (\\n            block.number > blocknum + 3 ||\\n            _hash !=\\n            keccak256(\\n                abi.encodePacked(blockhash(blocknum - 1), namehash, msg.sender)\\n            )\\n        ) revert InvalidHash();\\n        /// decode signature\\n        (uint64 _validity, bytes memory _signature, bytes memory _result) = abi\\n            .decode(response, (uint64, bytes, bytes));\\n        /// check signature expiry\\n        if (block.timestamp > _validity) revert SignatureExpired();\\n        /// check signature content\\n        if (\\n            !Resolver(address(this)).isValid(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\\"1900\\\",\\n                        address(this),\\n                        _validity,\\n                        namehash,\\n                        _result\\n                    )\\n                ),\\n                _signature\\n            )\\n        ) revert InvalidSignature(\\\"BAD_SIGNATURE\\\");\\n        return _result;\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid\\n     * @param digest : hash of signed message\\n     * @param signature : compact signature to verify\\n     */\\n    function isValid(\\n        bytes32 digest,\\n        bytes calldata signature\\n    ) external view returns (bool) {\\n        // First 32 bytes of signature\\n        bytes32 r = bytes32(signature[:32]);\\n        // Next 32 bytes of signature\\n        bytes32 s;\\n        // Last 1 byte\\n        uint8 v;\\n        if (signature.length > 64) {\\n            s = bytes32(signature[32:64]);\\n            v = uint8(uint256(bytes32(signature[64:])));\\n        } else if (signature.length == 64) {\\n            bytes32 vs = bytes32(signature[32:]);\\n            s =\\n                vs &\\n                bytes32(\\n                    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                );\\n            v = uint8((uint256(vs) >> 255) + 27);\\n        } else {\\n            revert InvalidSignature(\\\"BAD_SIG_LENGTH\\\");\\n        }\\n        /// Check for bad signature\\n        if (\\n            uint256(s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) revert InvalidSignature(\\\"SIG_OVERFLOW\\\");\\n        /// Recover signer\\n        address _signer = ecrecover(digest, v, r, s);\\n        return (_signer != address(0) && isSigner[_signer]);\\n    }\\n\\n    /// @dev : Gateway and Chain Management Functions\\n    modifier onlyDev() {\\n        require(msg.sender == Dev);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Push new gateway to the list\\n     * @param operator : controller of new gateway\\n     * @param domain : new gateway domain\\n     */\\n    function addGateway(\\n        address operator,\\n        string calldata domain\\n    ) external onlyDev {\\n        require(!isSigner[operator], \\\"OPERATOR_EXISTS\\\");\\n        Gateways.push(Gate(domain, operator));\\n        isSigner[operator] = true;\\n        emit NewGateway(operator, domain);\\n    }\\n\\n    /**\\n     * @dev Remove gateway from the list\\n     * @param _index : gateway index to remove\\n     */\\n    function removeGateway(uint _index) external onlyDev {\\n        isSigner[Gateways[_index].operator] = false;\\n        emit RemovedGateway(\\n            _index,\\n            Gateways[_index].operator,\\n            Gateways[_index].domain\\n        );\\n        unchecked {\\n            if (Gateways.length > _index + 1)\\n                Gateways[_index] = Gateways[Gateways.length - 1];\\n        }\\n        Gateways.pop();\\n    }\\n\\n    /**\\n     * @dev Replace gateway for a given controller\\n     * @param _index : gateway index to replace\\n     * @param operator : controller of gateway\\n     * @param domain : new gateway domain\\n     */\\n    function replaceGateway(\\n        uint _index,\\n        address operator,\\n        string calldata domain\\n    ) external onlyDev {\\n        require(!isSigner[operator], \\\"DUPLICATE_OPERATOR\\\");\\n        emit ReplacedGateway(_index, operator, Gateways[_index].domain, domain);\\n        isSigner[Gateways[_index].operator] = false;\\n        Gateways[_index] = Gate(domain, operator);\\n        isSigner[operator] = true;\\n    }\\n\\n    /**\\n     * @dev : Transfer contract ownership to new Dev\\n     * @param newDev : new Dev\\n     */\\n    function changeDev(address newDev) external onlyDev {\\n        emit OwnershipTransferred(Dev, newDev);\\n        Dev = newDev;\\n    }\\n\\n    /**\\n     * @dev : Changes CCIP-Read source chain ID\\n     * @param newChainID : new source chain ID\\n     */\\n    function changeChainID(string calldata newChainID) external onlyDev {\\n        emit ChainIDChanged(chainID, newChainID);\\n        chainID = newChainID;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidResponse\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunction\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"OffchainLookup\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequestError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"chainID\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newChainID\",\"type\":\"string\"}],\"name\":\"ChainIDChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"}],\"name\":\"NewGateway\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"}],\"name\":\"RemovedGateway\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"oldDomain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newDomain\",\"type\":\"string\"}],\"name\":\"ReplacedGateway\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"DNSDecode\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"namehash\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Gateways\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"__callback\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"}],\"name\":\"addGateway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainID\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newChainID\",\"type\":\"string\"}],\"name\":\"changeChainID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDev\",\"type\":\"address\"}],\"name\":\"changeDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"randomGateways\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeGateway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"}],\"name\":\"replaceGateway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Resolver", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}