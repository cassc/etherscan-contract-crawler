{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/diamonds/nayms/facets/NaymsTokenFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { INaymsTokenFacet } from \\\"../interfaces/INaymsTokenFacet.sol\\\";\\nimport { LibNaymsToken } from \\\"../libs/LibNaymsToken.sol\\\";\\n\\n/**\\n * @title Nayms token facet.\\n * @notice Use it to access and manipulate Nayms token.\\n * @dev Use it to access and manipulate Nayms token.\\n */\\ncontract NaymsTokenFacet is INaymsTokenFacet {\\n    /**\\n     * @dev Get total supply of token.\\n     * @return total supply.\\n     */\\n    function totalSupply() external view returns (uint256) {\\n        return LibNaymsToken._totalSupply();\\n    }\\n\\n    /**\\n     * @dev Get token balance of given wallet.\\n     * @param addr wallet whose balance to get.\\n     * @return balance of wallet.\\n     */\\n    function balanceOf(address addr) external view returns (uint256) {\\n        return LibNaymsToken._balanceOf(addr);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/INaymsTokenFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title Nayms token facet.\\n * @dev Use it to access and manipulate Nayms token.\\n */\\ninterface INaymsTokenFacet {\\n    /**\\n     * @dev Get total supply of token.\\n     * @return total supply.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Get token balance of given wallet.\\n     * @param addr wallet whose balance to get.\\n     * @return balance of wallet.\\n     */\\n    function balanceOf(address addr) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/libs/LibNaymsToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport { AppStorage, LibAppStorage } from \\\"../AppStorage.sol\\\";\\n\\n/// @notice Contains internal methods for Nayms token functionality\\nlibrary LibNaymsToken {\\n    function _totalSupply() internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.totalSupply;\\n    }\\n\\n    function _balanceOf(address addr) internal view returns (uint256) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.balances[addr];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/AppStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice storage for nayms v3 decentralized insurance platform\\n\\n// solhint-disable no-global-import\\nimport \\\"./interfaces/FreeStructs.sol\\\";\\n\\nstruct AppStorage {\\n    // Has this diamond been initialized?\\n    bool diamondInitialized;\\n    //// EIP712 domain separator ////\\n    uint256 initialChainId;\\n    bytes32 initialDomainSeparator;\\n    //// Reentrancy guard ////\\n    uint256 reentrancyStatus;\\n    //// NAYMS ERC20 TOKEN ////\\n    string name;\\n    mapping(address => mapping(address => uint256)) allowance;\\n    uint256 totalSupply;\\n    mapping(bytes32 => bool) internalToken;\\n    mapping(address => uint256) balances;\\n    //// Object ////\\n    mapping(bytes32 => bool) existingObjects; // objectId => is an object?\\n    mapping(bytes32 => bytes32) objectParent; // objectId => parentId\\n    mapping(bytes32 => bytes32) objectDataHashes;\\n    mapping(bytes32 => string) objectTokenSymbol;\\n    mapping(bytes32 => string) objectTokenName;\\n    mapping(bytes32 => address) objectTokenWrapper;\\n    mapping(bytes32 => bool) existingEntities; // entityId => is an entity?\\n    mapping(bytes32 => bool) existingSimplePolicies; // simplePolicyId => is a simple policy?\\n    //// ENTITY ////\\n    mapping(bytes32 => Entity) entities; // objectId => Entity struct\\n    //// SIMPLE POLICY ////\\n    mapping(bytes32 => SimplePolicy) simplePolicies; // objectId => SimplePolicy struct\\n    //// External Tokens ////\\n    mapping(address => bool) externalTokenSupported;\\n    address[] supportedExternalTokens;\\n    //// TokenizedObject ////\\n    mapping(bytes32 => mapping(bytes32 => uint256)) tokenBalances; // tokenId => (ownerId => balance)\\n    mapping(bytes32 => uint256) tokenSupply; // tokenId => Total Token Supply\\n    //// Dividends ////\\n    uint8 maxDividendDenominations;\\n    mapping(bytes32 => bytes32[]) dividendDenominations; // object => tokenId of the dividend it allows\\n    mapping(bytes32 => mapping(bytes32 => uint8)) dividendDenominationIndex; // entity ID => (token ID => index of dividend denomination)\\n    mapping(bytes32 => mapping(uint8 => bytes32)) dividendDenominationAtIndex; // entity ID => (index of dividend denomination => token id)\\n    mapping(bytes32 => mapping(bytes32 => uint256)) totalDividends; // token ID => (denomination ID => total dividend)\\n    mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => uint256))) withdrawnDividendPerOwner; // entity => (tokenId => (owner => total withdrawn dividend)) NOT per share!!! this is TOTAL\\n    //// ACL Configuration////\\n    mapping(bytes32 => mapping(bytes32 => bool)) groups; //role => (group => isRoleInGroup)\\n    mapping(bytes32 => bytes32) canAssign; //role => Group that can assign/unassign that role\\n    //// User Data ////\\n    mapping(bytes32 => mapping(bytes32 => bytes32)) roles; // userId => (contextId => role)\\n    //// MARKET ////\\n    uint256 lastOfferId;\\n    mapping(uint256 => MarketInfo) offers; // offer Id => MarketInfo struct\\n    mapping(bytes32 => mapping(bytes32 => uint256)) bestOfferId; // sell token => buy token => best offer Id\\n    mapping(bytes32 => mapping(bytes32 => uint256)) span; // sell token => buy token => span\\n    address naymsToken; // represents the address key for this NAYMS token in AppStorage\\n    bytes32 naymsTokenId; // represents the bytes32 key for this NAYMS token in AppStorage\\n    /// Trading Commissions (all in basis points) ///\\n    uint16 tradingCommissionTotalBP; // note DEPRECATED // the total amount that is deducted for trading commissions (BP)\\n    // The total commission above is further divided as follows:\\n    uint16 tradingCommissionNaymsLtdBP; // note DEPRECATED\\n    uint16 tradingCommissionNDFBP; // note DEPRECATED\\n    uint16 tradingCommissionSTMBP; // note DEPRECATED\\n    uint16 tradingCommissionMakerBP;\\n    // Premium Commissions\\n    uint16 premiumCommissionNaymsLtdBP; // note DEPRECATED\\n    uint16 premiumCommissionNDFBP; // note DEPRECATED\\n    uint16 premiumCommissionSTMBP; // note DEPRECATED\\n    // A policy can pay out additional commissions on premiums to entities having a variety of roles on the policy\\n    mapping(bytes32 => mapping(bytes32 => uint256)) lockedBalances; // keep track of token balance that is locked, ownerId => tokenId => lockedAmount\\n    /// Simple two phase upgrade scheme\\n    mapping(bytes32 => uint256) upgradeScheduled; // id of the upgrade => the time that the upgrade is valid until.\\n    uint256 upgradeExpiration; // the period of time that an upgrade is valid until.\\n    uint256 sysAdmins; // counter for the number of sys admin accounts currently assigned\\n    mapping(address => bytes32) objectTokenWrapperId; // reverse mapping token wrapper address => object ID\\n    mapping(string => bytes32) tokenSymbolObjectId; // reverse mapping token symbol => object ID, to ensure symbol uniqueness\\n    mapping(bytes32 => mapping(uint256 => FeeSchedule)) feeSchedules; // map entity ID to a fee schedule type and then to array of FeeReceivers (feeScheduleType (1-premium, 2-trading, n-others))\\n}\\n\\nstruct FunctionLockedStorage {\\n    mapping(bytes4 => bool) locked; // function selector => is locked?\\n}\\n\\nlibrary LibAppStorage {\\n    bytes32 internal constant NAYMS_DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.nayms.storage\\\");\\n    bytes32 internal constant FUNCTION_LOCK_STORAGE_POSITION = keccak256(\\\"diamond.function.lock.storage\\\");\\n\\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\\n        bytes32 position = NAYMS_DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function functionLockStorage() internal pure returns (FunctionLockedStorage storage ds) {\\n        bytes32 position = FUNCTION_LOCK_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/diamonds/nayms/interfaces/FreeStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nstruct MarketInfo {\\n    bytes32 creator; // entity ID\\n    bytes32 sellToken;\\n    uint256 sellAmount;\\n    uint256 sellAmountInitial;\\n    bytes32 buyToken;\\n    uint256 buyAmount;\\n    uint256 buyAmountInitial;\\n    uint256 feeSchedule;\\n    uint256 state;\\n    uint256 rankNext;\\n    uint256 rankPrev;\\n}\\n\\nstruct TokenAmount {\\n    bytes32 token;\\n    uint256 amount;\\n}\\n\\n/**\\n * @param maxCapacity Maximum allowable amount of capacity that an entity is given. Denominated by assetId.\\n * @param utilizedCapacity The utilized capacity of the entity. Denominated by assetId.\\n */\\nstruct Entity {\\n    bytes32 assetId;\\n    uint256 collateralRatio;\\n    uint256 maxCapacity;\\n    uint256 utilizedCapacity;\\n    bool simplePolicyEnabled;\\n}\\n\\n/// @dev Only pass in the fields that are allowed to be updated.\\n/// @dev These are the variables of an entity that are allowed to be updated by the method updateEntity()\\nstruct UpdateEntityTypeCell {\\n    uint256 collateralRatio;\\n    uint256 maxCapacity;\\n    bool simplePolicyEnabled;\\n}\\n\\nstruct SimplePolicy {\\n    uint256 startDate;\\n    uint256 maturationDate;\\n    bytes32 asset;\\n    uint256 limit;\\n    bool fundsLocked;\\n    bool cancelled;\\n    uint256 claimsPaid;\\n    uint256 premiumsPaid;\\n    bytes32[] commissionReceivers;\\n    uint256[] commissionBasisPoints;\\n}\\n\\nstruct SimplePolicyInfo {\\n    uint256 startDate;\\n    uint256 maturationDate;\\n    bytes32 asset;\\n    uint256 limit;\\n    bool fundsLocked;\\n    bool cancelled;\\n    uint256 claimsPaid;\\n    uint256 premiumsPaid;\\n}\\n\\nstruct Stakeholders {\\n    bytes32[] roles;\\n    bytes32[] entityIds;\\n    bytes[] signatures;\\n}\\n\\n// Used in StakingFacet\\nstruct LockedBalance {\\n    uint256 amount;\\n    uint256 endTime;\\n}\\n\\nstruct StakingCheckpoint {\\n    int128 bias;\\n    int128 slope; // - dweight / dt\\n    uint256 ts; // timestamp\\n    uint256 blk; // block number\\n}\\n\\nstruct FeeSchedule {\\n    bytes32[] receiver;\\n    uint16[] basisPoints;\\n}\\n\\nstruct FeeAllocation {\\n    bytes32 from; // The ID of the entity that paid the fee\\n    bytes32 to; // The ID of the entity that receives the fee\\n    bytes32 token; // The ID of the token that was used to pay the fee\\n    uint256 fee; // The amount of fees paid to the receiver\\n    uint256 basisPoints; // The basis points taken from the amount transacted\\n}\\n\\nstruct CalculatedFees {\\n    uint256 totalFees; // total amount of fees paid\\n    uint256 totalBP; // total basis points of fees paid\\n    FeeAllocation[] feeAllocations; // The list of entities that receive a portion of the fees.\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/ozv4/\",\r\n      \"@uniswap/lib/=lib/solidity-lib/\",\r\n      \"@uniswap/v2-core/=lib/v2-core/\",\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"base64-sol/=lib/base64/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/ozv4/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ozv4/=lib/ozv4/\",\r\n      \"script/=script/\",\r\n      \"solidity-lib/=lib/solidity-lib/contracts/\",\r\n      \"solidity-stringutils/=lib/solidity-stringutils/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"debug\": {\r\n      \"revertStrings\": \"default\"\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NaymsTokenFacet", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}