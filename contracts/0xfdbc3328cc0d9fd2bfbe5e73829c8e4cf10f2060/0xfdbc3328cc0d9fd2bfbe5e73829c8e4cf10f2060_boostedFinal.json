{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\ninterface Token {\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n  function symbol() external view returns (string memory);\r\n  function name() external view returns (string memory);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address); \r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function allPairsLength() external view returns (uint);\r\n    function allPairs(uint) external view returns (address);\r\n}\r\n\r\ncontract boostedFinal {\r\n  /* Fallback function, don't accept any ETH */\r\n    receive() external payable {\r\n        revert(\"Not accept\");\r\n    }\r\n\r\n    IUniswapV2Factory public factory;\r\n    constructor(address _factoryAddress) {\r\n    factory = IUniswapV2Factory(_factoryAddress);\r\n    }\r\n\r\n    // Address Functions\r\n    function multipleEtherBalances(address[] memory users) public view returns (uint[] memory) {\r\n            uint[] memory etherBalances = new uint[](users.length);\r\n\r\n            for (uint i = 0; i < users.length; i++) {\r\n                etherBalances[i] = users[i].balance;\r\n            }\r\n\r\n            return etherBalances;\r\n    }\r\n    function tokenBalance(address user, address token) public view returns (uint) {\r\n        // check if token is actually a contract\r\n        uint256 tokenCode;\r\n        assembly { tokenCode := extcodesize(token) } // contract code size\r\n    \r\n        // is it a contract and does it implement balanceOf \r\n        if (tokenCode > 0) {  \r\n        try Token(token).balanceOf(user) returns (uint balance) {\r\n            return balance;\r\n        } catch {\r\n            return 0;\r\n        }\r\n        } else {\r\n        return 0;\r\n        }\r\n    }\r\n\r\n    struct TokenInfo {\r\n        address tokenAddress;\r\n        string name;\r\n        string symbol;\r\n        uint8 decimals;\r\n    }\r\n    struct pairElement {\r\n        uint index;\r\n        address pairAdress;\r\n        address token0;\r\n        string token0Name;\r\n        string token0Symbol;\r\n        uint token0Decimals;\r\n        address token1;\r\n        string token1Name;\r\n        string token1Symbol;\r\n        uint token1Decimals;\r\n        \r\n    }\r\n    struct FullInfo {\r\n        TokenInfo token0Info;\r\n        uint reserve0;\r\n        TokenInfo token1Info;\r\n        uint reserve1;\r\n    }\r\n\r\n    struct ReserveData {\r\n      uint reserve0;\r\n      uint reserve1;\r\n      address pairAdress;\r\n    }\r\n    function getReservesRangeIndexs(uint startIndex, uint endIndex) public view returns (ReserveData[] memory) {\r\n        require(startIndex <= endIndex && endIndex < factory.allPairsLength(), \"Invalid indices provided\");\r\n        uint rangeLength = endIndex - startIndex + 1;\r\n        ReserveData[] memory reserves = new ReserveData[](rangeLength);\r\n        for (uint i = startIndex; i <= endIndex; i++) {\r\n            address pairAddress = factory.allPairs(i);\r\n            (uint112 reserve0, uint112 reserve1, ) = IUniswapV2Pair(pairAddress).getReserves();\r\n            reserves[i - startIndex] = ReserveData(uint(reserve0), uint(reserve1),pairAddress);\r\n        }\r\n\r\n        return reserves;\r\n    }\r\n    function balancesTokensPerAdresss(address[] memory users, address[] memory tokens) external view returns (uint[] memory) {\r\n        uint[] memory addrBalances = new uint[](tokens.length * users.length);\r\n        for(uint i = 0; i < users.length; i++) {\r\n            for (uint j = 0; j < tokens.length; j++) {\r\n                uint addrIdx = j + tokens.length * i;              \r\n                if (tokens[j] != address(0)) { \r\n                uint balance = tokenBalance(users[i], tokens[j]);\r\n                //uint tokenDecimals = Token(tokens[j]).decimals();\r\n                addrBalances[addrIdx] = balance; /// (10 ** tokenDecimals);\r\n                } else {\r\n                addrBalances[addrIdx] = users[i].balance; // ETH balance    \r\n                }\r\n            }  \r\n        }\r\n          \r\n        return addrBalances;\r\n    }\r\n    function getReservesArrayIndexes(uint[] memory indexes) public view returns (ReserveData[] memory) {\r\n        ReserveData[] memory reserves = new ReserveData[](indexes.length);\r\n\r\n        for (uint j = 0; j < indexes.length; j++) {\r\n            uint i = indexes[j];\r\n            address pairAddress = factory.allPairs(i); // Suponiendo que 'factory' est\u00e9 definido en alg\u00fan lugar\r\n            (uint112 reserve0, uint112 reserve1, ) = IUniswapV2Pair(pairAddress).getReserves();\r\n            reserves[j] = ReserveData(uint(reserve0), uint(reserve1), pairAddress);\r\n        }\r\n\r\n        return reserves;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factoryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"balancesTokensPerAdresss\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexes\",\"type\":\"uint256[]\"}],\"name\":\"getReservesArrayIndexes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairAdress\",\"type\":\"address\"}],\"internalType\":\"struct boostedFinal.ReserveData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"getReservesRangeIndexs\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairAdress\",\"type\":\"address\"}],\"internalType\":\"struct boostedFinal.ReserveData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"multipleEtherBalances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "boostedFinal", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ea36708a8fb0e73467029ad7a1e6a8f5062b42db960ace08bf72619a829af58f"}