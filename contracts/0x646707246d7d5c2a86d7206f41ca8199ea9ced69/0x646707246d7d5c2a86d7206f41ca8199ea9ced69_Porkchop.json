{"SourceCode": "{\"DistributedStorage.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\nimport \\\"./StorageUnit.sol\\\";\\nimport \\\"./IsContract.sol\\\";\\n\\n\\nlibrary DistributedStorage {\\n    function contractSlot(bytes32 _struct) private view returns (address) {\\n        return address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        byte(0xff),\\n                        address(this),\\n                        _struct,\\n                        keccak256(type(StorageUnit).creationCode)\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function deploy(bytes32 _struct) private {\\n        bytes memory slotcode = type(StorageUnit).creationCode;\\n        /* solium-disable-next-line */\\n        assembly{ pop(create2(0, add(slotcode, 0x20), mload(slotcode), _struct)) }\\n    }\\n\\n    function write(\\n        bytes32 _struct,\\n        bytes32 _key,\\n        bytes32 _value\\n    ) internal {\\n        StorageUnit store = StorageUnit(contractSlot(_struct));\\n        if (!IsContract.isContract(address(store))) {\\n            deploy(_struct);\\n        }\\n\\n        /* solium-disable-next-line */\\n        (bool success, ) = address(store).call(\\n            abi.encodeWithSelector(\\n                store.write.selector,\\n                _key,\\n                _value\\n            )\\n        );\\n\\n        require(success, \\\"error writing storage\\\");\\n    }\\n\\n    function read(\\n        bytes32 _struct,\\n        bytes32 _key\\n    ) internal view returns (bytes32) {\\n        StorageUnit store = StorageUnit(contractSlot(_struct));\\n        if (!IsContract.isContract(address(store))) {\\n            return bytes32(0);\\n        }\\n\\n        /* solium-disable-next-line */\\n        (bool success, bytes memory data) = address(store).staticcall(\\n            abi.encodeWithSelector(\\n                store.read.selector,\\n                _key\\n            )\\n        );\\n\\n        require(success, \\\"error reading storage\\\");\\n        return abi.decode(data, (bytes32));\\n    }\\n}\\n\"},\"Farm.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n/*\\n    \\n*/\\n\\n\\nlibrary Farm {\\n    using Farm for Farm.Pigpen;\\n\\n    struct Pigpen {\\n        uint256[] entries;\\n        mapping(address =\\u003e uint256) index;\\n    }\\n\\n    function initialize(Pigpen storage _pigpen) internal {\\n        require(_pigpen.entries.length == 0, \\\"already initialized\\\");\\n        _pigpen.entries.push(0);\\n    }\\n\\n    function encode(address _addr, uint256 _value) internal pure returns (uint256 _entry) {\\n        /* solium-disable-next-line */\\n        assembly {\\n            _entry := not(or(and(0xffffffffffffffffffffffffffffffffffffffff, _addr), shl(160, _value)))\\n        }\\n    }\\n\\n    function decode(uint256 _entry) internal pure returns (address _addr, uint256 _value) {\\n        /* solium-disable-next-line */\\n        assembly {\\n            let entry := not(_entry)\\n            _addr := and(entry, 0xffffffffffffffffffffffffffffffffffffffff)\\n            _value := shr(160, entry)\\n        }\\n    }\\n\\n    function decodeAddress(uint256 _entry) internal pure returns (address _addr) {\\n        /* solium-disable-next-line */\\n        assembly {\\n            _addr := and(not(_entry), 0xffffffffffffffffffffffffffffffffffffffff)\\n        }\\n    }\\n\\n    function top(Pigpen storage _pigpen) internal view returns(address, uint256) {\\n        if (_pigpen.entries.length \\u003c 2) {\\n            return (address(0), 0);\\n        }\\n\\n        return decode(_pigpen.entries[1]);\\n    }\\n\\n    function has(Pigpen storage _pigpen, address _addr) internal view returns (bool) {\\n        return _pigpen.index[_addr] != 0;\\n    }\\n\\n    function size(Pigpen storage _pigpen) internal view returns (uint256) {\\n        return _pigpen.entries.length - 1;\\n    }\\n\\n    function entry(Pigpen storage _pigpen, uint256 _i) internal view returns (address, uint256) {\\n        return decode(_pigpen.entries[_i + 1]);\\n    }\\n\\n    // RemoveMax pops off the root element of the pigpen (the highest value here) and rebalances the pigpen\\n    function popTop(Pigpen storage _pigpen) internal returns(address _addr, uint256 _value) {\\n        // Ensure the pigpen exists\\n        uint256 pigpenLength = _pigpen.entries.length;\\n        require(pigpenLength \\u003e 1, \\\"The pigpen does not exists\\\");\\n\\n        // take the root value of the pigpen\\n        (_addr, _value) = decode(_pigpen.entries[1]);\\n        _pigpen.index[_addr] = 0;\\n\\n        if (pigpenLength == 2) {\\n            _pigpen.entries.length = 1;\\n        } else {\\n            // Takes the last element of the array and put it at the root\\n            uint256 val = _pigpen.entries[pigpenLength - 1];\\n            _pigpen.entries[1] = val;\\n\\n            // Delete the last element from the array\\n            _pigpen.entries.length = pigpenLength - 1;\\n\\n            // Start at the top\\n            uint256 ind = 1;\\n\\n            // Bubble down\\n            ind = _pigpen.bubbleDown(ind, val);\\n\\n            // Update index\\n            _pigpen.index[decodeAddress(val)] = ind;\\n        }\\n    }\\n\\n    // Inserts adds in a value to our pigpen.\\n    function insert(Pigpen storage _pigpen, address _addr, uint256 _value) internal {\\n        require(_pigpen.index[_addr] == 0, \\\"The entry already exists\\\");\\n\\n        // Add the value to the end of our array\\n        uint256 encoded = encode(_addr, _value);\\n        _pigpen.entries.push(encoded);\\n\\n        // Start at the end of the array\\n        uint256 currentIndex = _pigpen.entries.length - 1;\\n\\n        // Bubble Up\\n        currentIndex = _pigpen.bubbleUp(currentIndex, encoded);\\n\\n        // Update index\\n        _pigpen.index[_addr] = currentIndex;\\n    }\\n\\n    function update(Pigpen storage _pigpen, address _addr, uint256 _value) internal {\\n        uint256 ind = _pigpen.index[_addr];\\n        require(ind != 0, \\\"The entry does not exists\\\");\\n\\n        uint256 can = encode(_addr, _value);\\n        uint256 val = _pigpen.entries[ind];\\n        uint256 newInd;\\n\\n        if (can \\u003c val) {\\n            // Bubble down\\n            newInd = _pigpen.bubbleDown(ind, can);\\n        } else if (can \\u003e val) {\\n            // Bubble up\\n            newInd = _pigpen.bubbleUp(ind, can);\\n        } else {\\n            // no changes needed\\n            return;\\n        }\\n\\n        // Update entry\\n        _pigpen.entries[newInd] = can;\\n\\n        // Update index\\n        if (newInd != ind) {\\n            _pigpen.index[_addr] = newInd;\\n        }\\n    }\\n\\n    function bubbleUp(Pigpen storage _pigpen, uint256 _ind, uint256 _val) internal returns (uint256 ind) {\\n        // Bubble up\\n        ind = _ind;\\n        if (ind != 1) {\\n            uint256 pen = _pigpen.entries[ind / 2];\\n            while (pen \\u003c _val) {\\n                // If the pen value is lower than our current value, we swap them\\n                (_pigpen.entries[ind / 2], _pigpen.entries[ind]) = (_val, pen);\\n\\n                // Update moved Index\\n                _pigpen.index[decodeAddress(pen)] = ind;\\n\\n                // change our current Index to go up to the pen\\n                ind = ind / 2;\\n                if (ind == 1) {\\n                    break;\\n                }\\n\\n                // Update pen\\n                pen = _pigpen.entries[ind / 2];\\n            }\\n        }\\n    }\\n\\n    function bubbleDown(Pigpen storage _pigpen, uint256 _ind, uint256 _val) internal returns (uint256 ind) {\\n        // Bubble down\\n        ind = _ind;\\n\\n        uint256 lenght = _pigpen.entries.length;\\n        uint256 target = lenght - 1;\\n\\n        while (ind * 2 \\u003c lenght) {\\n            // get the current index of the pigs\\n            uint256 j = ind * 2;\\n\\n            // left pig value\\n            uint256 leftPig = _pigpen.entries[j];\\n\\n            // Store the value of the pigs\\n            uint256 pigValue;\\n\\n            if (target \\u003e j) {\\n                // The pen has two pigs\\n\\n                // Load right pig value\\n                uint256 rightPig = _pigpen.entries[j + 1];\\n\\n                // Compare the left and right pigs\\n                // if the rightPig is greater, then point j to it\\u0027s index\\n                // and save the value\\n                if (leftPig \\u003c rightPig) {\\n                    pigValue = rightPig;\\n                    j = j + 1;\\n                } else {\\n                    // The left pig is greater\\n                    pigValue = leftPig;\\n                }\\n            } else {\\n                // The pen has a single pig \\n                pigValue = leftPig;\\n            }\\n\\n            // Check if the pig has a lower value\\n            if (_val \\u003e pigValue) {\\n                break;\\n            }\\n\\n            // else swap the value\\n            (_pigpen.entries[ind], _pigpen.entries[j]) = (pigValue, _val);\\n\\n            // Update moved Index\\n            _pigpen.index[decodeAddress(pigValue)] = ind;\\n\\n            // and let\\u0027s keep going down the pigpen\\n            ind = j;\\n        }\\n    }\\n}\\n\"},\"GasPump.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n\\ncontract GasPump {\\n    bytes32 private stub;\\n\\n    modifier requestGas(uint256 _factor) {\\n        if (tx.gasprice == 0 || gasleft() \\u003e block.gaslimit) {\\n            uint256 startgas = gasleft();\\n            _;\\n            uint256 delta = startgas - gasleft();\\n            uint256 target = (delta * _factor) / 100;\\n            startgas = gasleft();\\n            while (startgas - gasleft() \\u003c target) {\\n                // Burn gas\\n                stub = keccak256(abi.encodePacked(stub));\\n            }\\n        } else {\\n            _;\\n        }\\n    }\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n\\ninterface IERC20 {\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n    function transfer(address _to, uint _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n}\\n\"},\"IsContract.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n\\nlibrary IsContract {\\n    function isContract(address _addr) internal view returns (bool) {\\n        bytes32 codehash;\\n        /* solium-disable-next-line */\\n        assembly { codehash := extcodehash(_addr) }\\n        return codehash != bytes32(0) \\u0026\\u0026 codehash != bytes32(0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\\n    }\\n}\\n\"},\"Math.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n\\nlibrary Math {\\n    function orderOfMagnitude(uint256 input) internal pure returns (uint256){\\n        uint256 counter = uint(-1);\\n        uint256 temp = input;\\n\\n        do {\\n            temp /= 10;\\n            counter++;\\n        } while (temp != 0);\\n\\n        return counter;\\n    }\\n\\n    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        if (_a \\u003c _b) {\\n            return _a;\\n        } else {\\n            return _b;\\n        }\\n    }\\n\\n    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        if (_a \\u003e _b) {\\n            return _a;\\n        } else {\\n            return _b;\\n        }\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n\\ncontract Ownable {\\n    address public owner;\\n\\n    event TransferOwnership(address _from, address _to);\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        emit TransferOwnership(address(0), msg.sender);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"only owner\\\");\\n        _;\\n    }\\n\\n    function setOwner(address _owner) external onlyOwner {\\n        emit TransferOwnership(owner, _owner);\\n        owner = _owner;\\n    }\\n}\\n\"},\"Pigpen.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Farm.sol\\\";\\n\\ncontract Pigpen is Ownable {\\n    using Farm for Farm.Pigpen;\\n\\n    // pigpen\\n    Farm.Pigpen private pigpen;\\n\\n    // Pigpen events\\n    event JoinPigpen(address indexed _address, uint256 _balance, uint256 _prevSize);\\n    event LeavePigpen(address indexed _address, uint256 _balance, uint256 _prevSize);\\n\\n    uint256 public constant TOP_SIZE = 100;\\n\\n    constructor() public {\\n        pigpen.initialize();\\n    }\\n\\n    function topSize() external pure returns (uint256) {\\n        return TOP_SIZE;\\n    }\\n\\n    function addressAt(uint256 _i) external view returns (address addr) {\\n        (addr, ) = pigpen.entry(_i);\\n    }\\n\\n    function indexOf(address _addr) external view returns (uint256) {\\n        return pigpen.index[_addr];\\n    }\\n\\n    function entry(uint256 _i) external view returns (address, uint256) {\\n        return pigpen.entry(_i);\\n    }\\n\\n    function top() external view returns (address, uint256) {\\n        return pigpen.top();\\n    }\\n\\n    function size() external view returns (uint256) {\\n        return pigpen.size();\\n    }\\n\\n    function update(address _addr, uint256 _new) external onlyOwner {\\n        uint256 _size = pigpen.size();\\n\\n        // If the pigpen is empty\\n        // join the _addr\\n        if (_size == 0) {\\n            emit JoinPigpen(_addr, _new, 0);\\n            pigpen.insert(_addr, _new);\\n            return;\\n        }\\n\\n        // Load top value of the pigpen\\n        (, uint256 lastBal) = pigpen.top();\\n\\n        // If our target address already is in the pigpen\\n        if (pigpen.has(_addr)) {\\n            // Update the target address value\\n            pigpen.update(_addr, _new);\\n            // If the new value is 0\\n            // always pop the pigpen\\n            // we updated the pigpen, so our address should be on top\\n            if (_new == 0) {\\n                pigpen.popTop();\\n                emit LeavePigpen(_addr, 0, _size);\\n            }\\n        } else {\\n            // IF pigpen is full or new balance is higher than pop pigpen\\n            if (_new != 0 \\u0026\\u0026 (_size \\u003c TOP_SIZE || lastBal \\u003c _new)) {\\n                // If pigpen is full pop pigpen\\n                if (_size \\u003e= TOP_SIZE) {\\n                    (address _poped, uint256 _balance) = pigpen.popTop();\\n                    emit LeavePigpen(_poped, _balance, _size);\\n                }\\n\\n                // Insert new value\\n                pigpen.insert(_addr, _new);\\n                emit JoinPigpen(_addr, _new, _size);\\n            }\\n        }\\n    }\\n}\\n\"},\"Porkchop.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./DistributedStorage.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Math.sol\\\";\\nimport \\\"./GasPump.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Pigpen.sol\\\";\\n\\ncontract Porkchop is Ownable, GasPump, IERC20 {\\n    using DistributedStorage for bytes32;\\n    using SafeMath for uint256;\\n\\n    // Pork events\\n    event Winner(address indexed _addr, uint256 _value);\\n\\n    // Managment events\\n    event SetName(string _prev, string _new);\\n    event SetExtraGas(uint256 _prev, uint256 _new);\\n    event SetPigpen(address _prev, address _new);\\n    event WhitelistFrom(address _addr, bool _whitelisted);\\n    event WhitelistTo(address _addr, bool _whitelisted);\\n\\n    uint256 public totalSupply;\\n\\n    bytes32 private constant BALANCE_KEY = keccak256(\\\"balance\\\");\\n\\n    // game\\n    uint256 public constant FEE = 100;\\n\\n    // metadata\\n    string public name = \\\"Porkchop\\\";\\n    string public constant symbol = \\\"CHOP\\\";\\n    uint8 public constant decimals = 18;\\n\\n    // fee whitelist\\n    mapping(address =\\u003e bool) public whitelistFrom;\\n    mapping(address =\\u003e bool) public whitelistTo;\\n\\n    // pigpen\\n    Pigpen public pigpen;\\n\\n    // internal\\n    uint256 public extraGas;\\n    bool inited;\\n\\n    function init(\\n        address _to,\\n        uint256 _amount\\n    ) external {\\n        // Only init once\\n        assert(!inited);\\n        inited = true;\\n\\n        // Sanity checks\\n        assert(totalSupply == 0);\\n        assert(address(pigpen) == address(0));\\n\\n        // Create Pigpen\\n        pigpen = new Pigpen();\\n        emit SetPigpen(address(0), address(pigpen));\\n\\n        // Init contract variables and mint\\n        // entire token balance\\n        extraGas = 15;\\n        emit SetExtraGas(0, extraGas);\\n        emit Transfer(address(0), _to, _amount);\\n        _setBalance(_to, _amount);\\n        totalSupply = _amount;\\n    }\\n\\n    ///\\n    // Storage access functions\\n    ///\\n\\n    // Getters\\n\\n    function _toKey(address a) internal pure returns (bytes32) {\\n        return bytes32(uint256(a));\\n    }\\n\\n    function _balanceOf(address _addr) internal view returns (uint256) {\\n        return uint256(_toKey(_addr).read(BALANCE_KEY));\\n    }\\n\\n    function _allowance(address _addr, address _spender) internal view returns (uint256) {\\n        return uint256(_toKey(_addr).read(keccak256(abi.encodePacked(\\\"allowance\\\", _spender))));\\n    }\\n\\n    function _nonce(address _addr, uint256 _cat) internal view returns (uint256) {\\n        return uint256(_toKey(_addr).read(keccak256(abi.encodePacked(\\\"nonce\\\", _cat))));\\n    }\\n\\n    // Setters\\n\\n    function _setAllowance(address _addr, address _spender, uint256 _value) internal {\\n        _toKey(_addr).write(keccak256(abi.encodePacked(\\\"allowance\\\", _spender)), bytes32(_value));\\n    }\\n\\n    function _setNonce(address _addr, uint256 _cat, uint256 _value) internal {\\n        _toKey(_addr).write(keccak256(abi.encodePacked(\\\"nonce\\\", _cat)), bytes32(_value));\\n    }\\n\\n    function _setBalance(address _addr, uint256 _balance) internal {\\n        _toKey(_addr).write(BALANCE_KEY, bytes32(_balance));\\n        pigpen.update(_addr, _balance);\\n    }\\n\\n    ///\\n    // Internal methods\\n    ///\\n\\n    function _isWhitelisted(address _from, address _to) internal view returns (bool) {\\n        return whitelistFrom[_from]||whitelistTo[_to];\\n    }\\n\\n    function _random(address _s1, uint256 _s2, uint256 _s3, uint256 _max) internal pure returns (uint256) {\\n        uint256 rand = uint256(keccak256(abi.encodePacked(_s1, _s2, _s3)));\\n        return rand % (_max + 1);\\n    }\\n\\n    function _pickWinner(address _from, uint256 _value) internal returns (address winner) {\\n        // Get order of magnitude of the tx\\n        uint256 magnitude = Math.orderOfMagnitude(_value);\\n        // Pull nonce for a given order of magnitude\\n        uint256 nonce = _nonce(_from, magnitude);\\n        _setNonce(_from, magnitude, nonce + 1);\\n        // pick entry from pigpen\\n        winner = pigpen.addressAt(_random(_from, nonce, magnitude, pigpen.size() - 1));\\n    }\\n\\n    function _transferFrom(address _operator, address _from, address _to, uint256 _value, bool _payFee) internal {\\n        // If transfer amount is zero\\n        // emit event and stop execution\\n        if (_value == 0) {\\n            emit Transfer(_from, _to, 0);\\n            return;\\n        }\\n\\n        // Load sender balance\\n        uint256 balanceFrom = _balanceOf(_from);\\n        require(balanceFrom \\u003e= _value, \\\"balance not enough\\\");\\n\\n        // Check if operator is sender\\n        if (_from != _operator) {\\n            // If not, validate allowance\\n            uint256 allowanceFrom = _allowance(_from, _operator);\\n            // If allowance is not 2 ** 256 - 1, consume allowance\\n            if (allowanceFrom != uint(-1)) {\\n                // Check allowance and save new one\\n                require(allowanceFrom \\u003e= _value, \\\"allowance not enough\\\");\\n                _setAllowance(_from, _operator, allowanceFrom.sub(_value));\\n            }\\n        }\\n\\n        // Calculate receiver balance\\n        // initial receive is full value\\n        uint256 receive = _value;\\n        uint256 burn = 0;\\n        uint256 chop = 0;\\n\\n        // Change sender balance\\n        _setBalance(_from, balanceFrom.sub(_value));\\n\\n        // If the transaction is not whitelisted\\n        // or if sender requested to pay the fee\\n        // calculate fees\\n        if (_payFee || !_isWhitelisted(_from, _to)) {\\n            // Fee is the same for BURN and CHOP\\n            // If we are sending value one\\n            // give priority to BURN\\n            burn = _value.divRound(FEE);\\n            chop = _value == 1 ? 0 : burn;\\n\\n            // Subtract fees from receiver amount\\n            receive = receive.sub(burn.add(chop));\\n\\n            // Burn tokens\\n            totalSupply = totalSupply.sub(burn);\\n            emit Transfer(_from, address(0), burn);\\n\\n            // Porkchop tokens\\n            // Pick winner pseudo-randomly\\n            address winner = _pickWinner(_from, _value);\\n            // Transfer balance to winner\\n            _setBalance(winner, _balanceOf(winner).add(chop));\\n            emit Winner(winner, chop);\\n            emit Transfer(_from, winner, chop);\\n        }\\n\\n        // Sanity checks\\n        // no tokens where created\\n        assert(burn.add(chop).add(receive) == _value);\\n\\n        // Add tokens to receiver\\n        _setBalance(_to, _balanceOf(_to).add(receive));\\n        emit Transfer(_from, _to, receive);\\n    }\\n\\n\\n/*\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmy/-```:hMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMmysydMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmy-`-:::::/ dMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMo`.::.-odMMMMMMMMMMMMMmmmmmmmmNMMMNo`.:/--::..o /MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMN:`::.-::-.:ymMMNdys+:.............+.`::.-/+/o..+ /MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMs ::.+/:.-::..+:----:::::::::::::::::/-.:+:::o..o /MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMM-`+.-o:/+-.-/::::--.....-----------.....////:+../.-MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMM `+.:+::++...-.-:://+ooooossoooosooooo+///:/+:..:: MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMM- +.-o//:--:/+ooossssoooooooooooooooooosssooo+/:/- mMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMs ::.:::+oosssoooooossssssssssssssssssooooooosssso..hMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMs .o/+ossooooosssoo++//:::------:::://+ooosssooooss-`hMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMo`-ssssooossoo+/:--....................-:---:/+oossos:`yMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMh`-ssooosso+:-......................-::/:-......--:+oss-`mMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMd.-soosoo/-..........................----:::-.........-/o..hMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMN-`ssso/-:::----......-:://////:-......./yhdhyo-.........-+-./ymMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMo +o/-....---::-....-///:::::/:://-....-hddddddy-.........:ys+:-/sdNMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMm -+-....:+so+-.....-o:+s:::::yy::/+....-hddddddy-..........ssssso/-:+symMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMo +-....ohddddh/....+/:ys:::::/o/::o.....:oyhhyo:.........../ysssssyso+.`yMMMMMMMMMMM\\nMMMMMMMNMMMMMMM/`+....:dddddddy....:+:::::::::::/+-........--..............-yssssssssy.`NMMMMMMMMMMM\\nMMMMMMMMMMMMMMM../....-ydddddh/.....-////:::////-...........................ssssssssso +MMMMMMMMMMMM\\nMMMMMMMMMMMMMMM`-/.....-/ooo/-.........--:::-..............................-+`:sssssy- NMMMMMMMMMMMM\\nMMMMMMMMMMMMMMM/./........................................................./y- `/ssss +MMMMMMMMMMMMM\\nMMMMMMMMMMMMMMM/`+........................................................-ysy:  `/s: mMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMh /:......................................................:ssssy+``.``/MMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMM:`+-...................................................-oysssssyo..yMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMN-`/-................................................://yssssssssy: /mMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMN+ :/-...........................................:::.` +yssssssssy+`.dMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMN: `/+:....................................-:::-``/sM.`ssssssssssss- sMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMo`/::::////:--....................--::::-:o:.----`-+md.-ysssssyso+:`.yMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMh /:......:/`.-::::::+::/:::+::::/:/+/.`.:-`     `-:.`sy /yso+:..:/shNMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMN:`/-.....:-       ./-``::` -/-.-::-` .:-`  `....`  -:`:s/:-:+sdNMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMm+`-::--:/      `::`    ./` `/+-` .--.  `:::---+.   ./ oMNNMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMmo-`.-/---...:yho:.    `:-  -::-.`    /-.....-/    :..dMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMNmhho:``-/-`./shhy+:.` .:. `::`     /-......+    /`.dMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMdo..-:::`    .:+yhhys+///` `:-`   `::--..:/`.-:.`yMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMmy-..--`  `-:.     `.-/oyhhdhysooy+::::/+osshyo..:odMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMNh+..--`       `.:-`     `/ohdhdo+yysyyyhhyyyyyyys`:NMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMm:.-/+.            `--..` `+hs:sdy.`-:-``-/:-`````:.`MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMy +-.-/-              `.--..-` /++-   .--.``--.`  -- MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMh ::.../-             `--``.---...``    `.--.`.-:-:: MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMN/`/:..-+      ````..---:---.```....-------:/:---::: MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMm-`--::/------...---:/oyo+:--.----.              `/ MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMNho++//////+osyyddNMMMMMMMmhyo+:`:-             .: MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMo -:            :- MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMh /:            /`:MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMN`-//-`         :- yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMd -:.-/-``    .:.`yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:`-/-.-:::/::.`/mMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNy-`.:::::-`-sNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNs+/-/ohNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n*/\\n    ///\\n    // Managment\\n    ///\\n\\n    function setWhitelistedTo(address _addr, bool _whitelisted) external onlyOwner {\\n        emit WhitelistTo(_addr, _whitelisted);\\n        whitelistTo[_addr] = _whitelisted;\\n    }\\n\\n    function setWhitelistedFrom(address _addr, bool _whitelisted) external onlyOwner {\\n        emit WhitelistFrom(_addr, _whitelisted);\\n        whitelistFrom[_addr] = _whitelisted;\\n    }\\n\\n    function setName(string calldata _name) external onlyOwner {\\n        emit SetName(name, _name);\\n        name = _name;\\n    }\\n\\n    function setExtraGas(uint256 _gas) external onlyOwner {\\n        emit SetExtraGas(extraGas, _gas);\\n        extraGas = _gas;\\n    }\\n\\n    function setPigpen(Pigpen _pigpen) external onlyOwner {\\n        emit SetPigpen(address(pigpen), address(_pigpen));\\n        pigpen = _pigpen;\\n    }\\n\\n    /////\\n    // Pigpen methods\\n    /////\\n\\n    function topSize() external view returns (uint256) {\\n        return pigpen.topSize();\\n    }\\n\\n    function pigpenSize() external view returns (uint256) {\\n        return pigpen.size();\\n    }\\n\\n    function pigpenEntry(uint256 _i) external view returns (address, uint256) {\\n        return pigpen.entry(_i);\\n    }\\n\\n    function pigpenTop() external view returns (address, uint256) {\\n        return pigpen.top();\\n    }\\n\\n    function pigpenIndex(address _addr) external view returns (uint256) {\\n        return pigpen.indexOf(_addr);\\n    }\\n\\n    function getNonce(address _addr, uint256 _cat) external view returns (uint256) {\\n        return _nonce(_addr, _cat);\\n    }\\n\\n    /////\\n    // ERC20\\n    /////\\n\\n    function balanceOf(address _addr) external view returns (uint256) {\\n        return _balanceOf(_addr);\\n    }\\n\\n    function allowance(address _addr, address _spender) external view returns (uint256) {\\n        return _allowance(_addr, _spender);\\n    }\\n\\n    function approve(address _spender, uint256 _value) external returns (bool) {\\n        emit Approval(msg.sender, _spender, _value);\\n        _setAllowance(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    function transfer(address _to, uint256 _value) external requestGas(extraGas) returns (bool) {\\n        _transferFrom(msg.sender, msg.sender, _to, _value, false);\\n        return true;\\n    }\\n\\n    function transferWithFee(address _to, uint256 _value) external requestGas(extraGas) returns (bool) {\\n        _transferFrom(msg.sender, msg.sender, _to, _value, true);\\n        return true;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _value) external requestGas(extraGas) returns (bool) {\\n        _transferFrom(msg.sender, _from, _to, _value, false);\\n        return true;\\n    }\\n\\n    function transferFromWithFee(address _from, address _to, uint256 _value) external requestGas(extraGas) returns (bool) {\\n        _transferFrom(msg.sender, _from, _to, _value, true);\\n        return true;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n\\nlibrary SafeMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 z = x + y;\\n        require(z \\u003e= x, \\\"Add overflow\\\");\\n        return z;\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256) {\\n        require(x \\u003e= y, \\\"Sub underflow\\\");\\n        return x - y;\\n    }\\n\\n    function mult(uint256 x, uint256 y) internal pure returns (uint256) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        uint256 z = x * y;\\n        require(z / x == y, \\\"Mult overflow\\\");\\n        return z;\\n    }\\n\\n    function div(uint256 x, uint256 y) internal pure returns (uint256) {\\n        require(y != 0, \\\"Div by zero\\\");\\n        return x / y;\\n    }\\n\\n    function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\\n        require(y != 0, \\\"Div by zero\\\");\\n        uint256 r = x / y;\\n        if (x % y != 0) {\\n            r = r + 1;\\n        }\\n\\n        return r;\\n    }\\n}\\n\"},\"StorageUnit.sol\":{\"content\":\"pragma solidity ^0.5.10;\\n\\n\\ncontract StorageUnit {\\n    address private owner;\\n    mapping(bytes32 =\\u003e bytes32) private store;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    function write(bytes32 _key, bytes32 _value) external {\\n        /* solium-disable-next-line */\\n        require(msg.sender == owner);\\n        store[_key] = _value;\\n    }\\n\\n    function read(bytes32 _key) external view returns (bytes32) {\\n        return store[_key];\\n    }\\n}\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prev\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"SetExtraGas\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_prev\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_new\",\"type\":\"string\"}],\"name\":\"SetName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_prev\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"SetPigpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"WhitelistFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"WhitelistTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extraGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cat\",\"type\":\"uint256\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pigpen\",\"outputs\":[{\"internalType\":\"contract Pigpen\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_i\",\"type\":\"uint256\"}],\"name\":\"pigpenEntry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"pigpenIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pigpenSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pigpenTop\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"setExtraGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Pigpen\",\"name\":\"_pigpen\",\"type\":\"address\"}],\"name\":\"setPigpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelistedFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelistedTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"topSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFromWithFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferWithFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistTo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Porkchop", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://bbd5f82a62e19b1c598e5cc8fc397223264e00ee6fa368b486f4dffb19454d73"}