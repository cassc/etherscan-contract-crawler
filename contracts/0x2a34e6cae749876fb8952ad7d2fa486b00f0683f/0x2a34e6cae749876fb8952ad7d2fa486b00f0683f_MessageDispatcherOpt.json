{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ethereum-optimism/EthereumToOptimismDispatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.16;\\n\\nimport { ICrossDomainMessenger } from \\\"../vendor/optimism/ICrossDomainMessenger.sol\\\";\\n\\nimport { IMessageExecutor } from \\\"../interfaces/IMessageExecutor.sol\\\";\\nimport { IMessageDispatcher, ISingleMessageDispatcher } from \\\"../interfaces/ISingleMessageDispatcher.sol\\\";\\nimport { IBatchedMessageDispatcher } from \\\"../interfaces/IBatchedMessageDispatcher.sol\\\";\\n\\nimport { MessageLib } from \\\"../libraries/MessageLib.sol\\\";\\n\\n/**\\n * @title MessageDispatcherOptimism contract\\n * @notice The MessageDispatcherOptimism contract allows a user or contract to send messages from Ethereum to Optimism.\\n *         It lives on the Ethereum chain and communicates with the `MessageExecutorOptimism` contract on the Optimism chain.\\n */\\ncontract MessageDispatcherOptimism is ISingleMessageDispatcher, IBatchedMessageDispatcher {\\n  /* ============ Variables ============ */\\n\\n  /// @notice Address of the Optimism cross domain messenger on the Ethereum chain.\\n  ICrossDomainMessenger public immutable crossDomainMessenger;\\n\\n  /// @notice Address of the executor contract on the Optimism chain.\\n  IMessageExecutor internal executor;\\n\\n  /// @notice Nonce used to compute unique `messageId`s.\\n  uint256 internal nonce;\\n\\n  /// @notice ID of the chain receiving the dispatched messages. i.e.: 10 for Mainnet, 420 for Goerli.\\n  uint256 internal immutable toChainId;\\n\\n  /// @notice Gas limit at which the transaction is executed on L2 when calling `dispatchMessage`.\\n  uint32 internal immutable gasLimit;\\n\\n  /* ============ Constructor ============ */\\n\\n  /**\\n   * @notice MessageDispatcherOptimism constructor.\\n   * @param _crossDomainMessenger Address of the Optimism cross domain messenger\\n   * @param _toChainId ID of the chain receiving the dispatched messages\\n   * @param _gasLimit Gas limit at which the transaction is executed on L2 when calling `dispatchMessage`\\n   */\\n  constructor(ICrossDomainMessenger _crossDomainMessenger, uint256 _toChainId, uint32 _gasLimit) {\\n    require(address(_crossDomainMessenger) != address(0), \\\"Dispatcher/CDM-not-zero-address\\\");\\n    require(_toChainId != 0, \\\"Dispatcher/chainId-not-zero\\\");\\n\\n    crossDomainMessenger = _crossDomainMessenger;\\n    toChainId = _toChainId;\\n    gasLimit = _gasLimit;\\n  }\\n\\n  /* ============ External Functions ============ */\\n\\n  /// @inheritdoc ISingleMessageDispatcher\\n  function dispatchMessage(\\n    uint256 _toChainId,\\n    address _to,\\n    bytes calldata _data\\n  ) external returns (bytes32) {\\n    return _dispatchMessage(_toChainId, _to, _data, gasLimit);\\n  }\\n\\n  /**\\n   * @notice Dispatch and process a message to the receiving chain.\\n   * @dev Must compute and return an ID uniquely identifying the message.\\n   * @dev Must emit the `MessageDispatched` event when successfully dispatched.\\n   * @param _toChainId ID of the receiving chain\\n   * @param _to Address on the receiving chain that will receive `data`\\n   * @param _data Data dispatched to the receiving chain\\n   * @param _gasLimit Gas limit at which the message will be executed on Optimism\\n   * @return bytes32 ID uniquely identifying the message\\n   */\\n  function dispatchMessageWithGasLimit(\\n    uint256 _toChainId,\\n    address _to,\\n    bytes calldata _data,\\n    uint32 _gasLimit\\n  ) external returns (bytes32) {\\n    return _dispatchMessage(_toChainId, _to, _data, _gasLimit);\\n  }\\n\\n  /// @inheritdoc IBatchedMessageDispatcher\\n  function dispatchMessageBatch(\\n    uint256 _toChainId,\\n    MessageLib.Message[] calldata _messages\\n  ) external returns (bytes32) {\\n    return _dispatchMessageBatch(_toChainId, _messages, gasLimit);\\n  }\\n\\n  /**\\n   * @notice Dispatch and process `messages` to the receiving chain.\\n   * @dev Must compute and return an ID uniquely identifying the `messages`.\\n   * @dev Must emit the `MessageBatchDispatched` event when successfully dispatched.\\n   * @param _toChainId ID of the receiving chain\\n   * @param _messages Array of Message dispatched\\n   * @param _gasLimit Gas limit at which the message will be executed on Optimism\\n   * @return bytes32 ID uniquely identifying the `messages`\\n   */\\n  function dispatchMessageWithGasLimitBatch(\\n    uint256 _toChainId,\\n    MessageLib.Message[] calldata _messages,\\n    uint32 _gasLimit\\n  ) external returns (bytes32) {\\n    return _dispatchMessageBatch(_toChainId, _messages, _gasLimit);\\n  }\\n\\n  /// @inheritdoc IMessageDispatcher\\n  function getMessageExecutorAddress(uint256 _toChainId) external view returns (address) {\\n    return _getMessageExecutorAddress(_toChainId);\\n  }\\n\\n  /**\\n   * @notice Set executor contract address.\\n   * @dev Will revert if it has already been set.\\n   * @param _executor Address of the executor contract on the Optimism chain\\n   */\\n  function setExecutor(IMessageExecutor _executor) external {\\n    require(address(executor) == address(0), \\\"Dispatcher/executor-already-set\\\");\\n    executor = _executor;\\n  }\\n\\n  /* ============ Internal Functions ============ */\\n\\n  /* ============ Require Functions ============ */\\n\\n  /**\\n   * @notice Check toChainId to ensure messages can be dispatched to this chain.\\n   * @dev Will revert if `_toChainId` is not supported.\\n   * @param _toChainId ID of the chain receiving the message\\n   */\\n  function _checkToChainId(uint256 _toChainId) internal view {\\n    require(_toChainId == toChainId, \\\"Dispatcher/chainId-not-supported\\\");\\n  }\\n\\n  /**\\n   * @notice Check dispatch parameters to ensure messages can be dispatched.\\n   * @dev Will revert if `executor` is not set.\\n   * @param _executor Address of the executor contract on the Optimism chain\\n   */\\n  function _checkExecutor(address _executor) internal pure {\\n    require(_executor != address(0), \\\"Dispatcher/executor-not-set\\\");\\n  }\\n\\n  /* ============ Getter Functions ============ */\\n\\n  /**\\n   * @notice Retrieves address of the MessageExecutor contract on the receiving chain.\\n   * @dev Will revert if `_toChainId` is not supported.\\n   * @param _toChainId ID of the chain with which MessageDispatcher is communicating\\n   * @return address MessageExecutor contract address\\n   */\\n  function _getMessageExecutorAddress(uint256 _toChainId) internal view returns (address) {\\n    _checkToChainId(_toChainId);\\n    return address(executor);\\n  }\\n\\n  /* ============ State Functions ============ */\\n\\n  /**\\n   * @notice Helper to increment nonce.\\n   * @return uint256 Incremented nonce\\n   */\\n  function _incrementNonce() internal returns (uint256) {\\n    unchecked {\\n      nonce++;\\n    }\\n\\n    return nonce;\\n  }\\n\\n  /* ============ Dispatch Functions ============ */\\n\\n  /**\\n   * @notice Dispatch a message to the receiving chain.\\n   * @dev Must compute and return an ID uniquely identifying the message.\\n   * @dev Must emit the `MessageDispatched` event when successfully dispatched.\\n   * @param _toChainId ID of the receiving chain\\n   * @param _to Address on the receiving chain that will receive `data`\\n   * @param _data Data dispatched to the receiving chain\\n   * @param _gasLimit Gas limit at which the message will be executed on Optimism\\n   * @return bytes32 ID uniquely identifying the message\\n   */\\n  function _dispatchMessage(\\n    uint256 _toChainId,\\n    address _to,\\n    bytes calldata _data,\\n    uint32 _gasLimit\\n  ) internal returns (bytes32) {\\n    address _executorAddress = _getMessageExecutorAddress(_toChainId);\\n    _checkExecutor(_executorAddress);\\n\\n    uint256 _nonce = _incrementNonce();\\n    bytes32 _messageId = MessageLib.computeMessageId(_nonce, msg.sender, _to, _data);\\n\\n    _sendMessage(\\n      _executorAddress,\\n      MessageLib.encodeMessage(_to, _data, _messageId, block.chainid, msg.sender),\\n      _gasLimit\\n    );\\n\\n    emit MessageDispatched(_messageId, msg.sender, _toChainId, _to, _data);\\n\\n    return _messageId;\\n  }\\n\\n  /**\\n   * @notice Dispatch `messages` to the receiving chain.\\n   * @dev Must compute and return an ID uniquely identifying the `messages`.\\n   * @dev Must emit the `MessageBatchDispatched` event when successfully dispatched.\\n   * @param _toChainId ID of the receiving chain\\n   * @param _messages Array of Message dispatched\\n   * @param _gasLimit Gas limit at which the messages will be executed on Optimism\\n   * @return bytes32 ID uniquely identifying the `messages`\\n   */\\n  function _dispatchMessageBatch(\\n    uint256 _toChainId,\\n    MessageLib.Message[] calldata _messages,\\n    uint32 _gasLimit\\n  ) internal returns (bytes32) {\\n    address _executorAddress = _getMessageExecutorAddress(_toChainId);\\n    _checkExecutor(_executorAddress);\\n\\n    uint256 _nonce = _incrementNonce();\\n    bytes32 _messageId = MessageLib.computeMessageBatchId(_nonce, msg.sender, _messages);\\n\\n    _sendMessage(\\n      _executorAddress,\\n      MessageLib.encodeMessageBatch(_messages, _messageId, block.chainid, msg.sender),\\n      _gasLimit\\n    );\\n\\n    emit MessageBatchDispatched(_messageId, msg.sender, _toChainId, _messages);\\n\\n    return _messageId;\\n  }\\n\\n  /**\\n   * @notice Dispatch message to Optimism chain.\\n   * @param _executor Address of the executor contract on the Optimism chain\\n   * @param _message Message dispatched\\n   * @param _gasLimit Gas limit at which the message will be executed on Optimism\\n   */\\n  function _sendMessage(address _executor, bytes memory _message, uint32 _gasLimit) internal {\\n    crossDomainMessenger.sendMessage(_executor, _message, _gasLimit);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/vendor/optimism/ICrossDomainMessenger.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.16;\\n\\n// Right now this is copy/pasted from the contracts package. We need to do this because we don't\\n// currently copy the contracts into the root of the contracts package in the correct way until\\n// we bundle the contracts package for publication. As a result, we can't properly use the\\n// package the way we want to from inside the monorepo (yet). Needs to be fixed as part of a\\n// separate pull request.\\n\\ninterface ICrossDomainMessenger {\\n  /**********\\n   * Events *\\n   **********/\\n\\n  event SentMessage(\\n    address indexed target,\\n    address sender,\\n    bytes message,\\n    uint256 messageNonce,\\n    uint256 gasLimit\\n  );\\n  event RelayedMessage(bytes32 indexed msgHash);\\n  event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n  /*************\\n   * Variables *\\n   *************/\\n\\n  function xDomainMessageSender() external view returns (address);\\n\\n  function messageNonce() external view returns (uint256);\\n\\n  /********************\\n   * Public Functions *\\n   ********************/\\n\\n  /**\\n   * Sends a cross domain message to the target messenger.\\n   * @param _target Target contract address.\\n   * @param _message Message to send to the target.\\n   * @param _gasLimit Gas limit for the provided message.\\n   */\\n  function sendMessage(address _target, bytes calldata _message, uint32 _gasLimit) external;\\n\\n  /// @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\\n  ///         be executed via cross-chain call from the other messenger OR if the message was\\n  ///         already received once and is currently being replayed.\\n  /// @param _nonce       Nonce of the message being relayed.\\n  /// @param _sender      Address of the user who sent the message.\\n  /// @param _target      Address that the message is targeted at.\\n  /// @param _value       ETH value to send with the message.\\n  /// @param _minGasLimit Minimum amount of gas that the message can be executed with.\\n  /// @param _message     Message to send to the target.\\n  function relayMessage(\\n    uint256 _nonce,\\n    address _sender,\\n    address _target,\\n    uint256 _value,\\n    uint256 _minGasLimit,\\n    bytes calldata _message\\n  ) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMessageExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.16;\\n\\nimport { MessageLib } from \\\"../libraries/MessageLib.sol\\\";\\n\\n/**\\n * @title MessageExecutor interface\\n * @notice MessageExecutor interface of the ERC-5164 standard as defined in the EIP.\\n */\\ninterface IMessageExecutor {\\n  /**\\n   * @notice Emitted when a message has successfully been executed.\\n   * @param fromChainId ID of the chain that dispatched the message\\n   * @param messageId ID uniquely identifying the message that was executed\\n   */\\n  event MessageIdExecuted(uint256 indexed fromChainId, bytes32 indexed messageId);\\n\\n  /**\\n   * @notice Execute message from the origin chain.\\n   * @dev Should authenticate that the call has been performed by the bridge transport layer.\\n   * @dev Must revert if the message fails.\\n   * @dev Must emit the `MessageIdExecuted` event once the message has been executed.\\n   * @param to Address that will receive `data`\\n   * @param data Data forwarded to address `to`\\n   * @param messageId ID uniquely identifying the message\\n   * @param fromChainId ID of the chain that dispatched the message\\n   * @param from Address of the sender on the origin chain\\n   */\\n  function executeMessage(\\n    address to,\\n    bytes calldata data,\\n    bytes32 messageId,\\n    uint256 fromChainId,\\n    address from\\n  ) external;\\n\\n  /**\\n   * @notice Execute a batch messages from the origin chain.\\n   * @dev Should authenticate that the call has been performed by the bridge transport layer.\\n   * @dev Must revert if one of the messages fails.\\n   * @dev Must emit the `MessageIdExecuted` event once messages have been executed.\\n   * @param messages Array of messages being executed\\n   * @param messageId ID uniquely identifying the messages\\n   * @param fromChainId ID of the chain that dispatched the messages\\n   * @param from Address of the sender on the origin chain\\n   */\\n  function executeMessageBatch(\\n    MessageLib.Message[] calldata messages,\\n    bytes32 messageId,\\n    uint256 fromChainId,\\n    address from\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISingleMessageDispatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.16;\\n\\nimport { IMessageDispatcher } from \\\"./IMessageDispatcher.sol\\\";\\n\\n/**\\n * @title ERC-5164: Cross-Chain Execution Standard, optional SingleMessageDispatcher extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-5164\\n */\\ninterface ISingleMessageDispatcher is IMessageDispatcher {\\n  /**\\n   * @notice Dispatch a message to the receiving chain.\\n   * @dev Must compute and return an ID uniquely identifying the message.\\n   * @dev Must emit the `MessageDispatched` event when successfully dispatched.\\n   * @param toChainId ID of the receiving chain\\n   * @param to Address on the receiving chain that will receive `data`\\n   * @param data Data dispatched to the receiving chain\\n   * @return bytes32 ID uniquely identifying the message\\n   */\\n  function dispatchMessage(\\n    uint256 toChainId,\\n    address to,\\n    bytes calldata data\\n  ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBatchedMessageDispatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.16;\\n\\nimport { IMessageDispatcher } from \\\"./IMessageDispatcher.sol\\\";\\nimport { MessageLib } from \\\"../../src/libraries/MessageLib.sol\\\";\\n\\n/**\\n * @title ERC-5164: Cross-Chain Execution Standard, optional BatchMessageDispatcher extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-5164\\n */\\ninterface IBatchedMessageDispatcher is IMessageDispatcher {\\n  /**\\n   * @notice Dispatch `messages` to the receiving chain.\\n   * @dev Must compute and return an ID uniquely identifying the `messages`.\\n   * @dev Must emit the `MessageBatchDispatched` event when successfully dispatched.\\n   * @param toChainId ID of the receiving chain\\n   * @param messages Array of Message dispatched\\n   * @return bytes32 ID uniquely identifying the `messages`\\n   */\\n  function dispatchMessageBatch(\\n    uint256 toChainId,\\n    MessageLib.Message[] calldata messages\\n  ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/libraries/MessageLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.16;\\n\\nimport { IMessageExecutor } from \\\"../interfaces/IMessageExecutor.sol\\\";\\n\\n/**\\n * @title MessageLib\\n * @notice Library to declare and manipulate Message(s).\\n */\\nlibrary MessageLib {\\n  /* ============ Structs ============ */\\n\\n  /**\\n   * @notice Message data structure\\n   * @param to Address that will be dispatched on the receiving chain\\n   * @param data Data that will be sent to the `to` address\\n   */\\n  struct Message {\\n    address to;\\n    bytes data;\\n  }\\n\\n  /* ============ Events ============ */\\n\\n  /* ============ Custom Errors ============ */\\n\\n  /**\\n   * @notice Emitted when a messageId has already been executed.\\n   * @param messageId ID uniquely identifying the message or message batch that were re-executed\\n   */\\n  error MessageIdAlreadyExecuted(bytes32 messageId);\\n\\n  /**\\n   * @notice Emitted if a call to a contract fails.\\n   * @param messageId ID uniquely identifying the message\\n   * @param errorData Error data returned by the call\\n   */\\n  error MessageFailure(bytes32 messageId, bytes errorData);\\n\\n  /**\\n   * @notice Emitted if a call to a contract fails inside a batch of messages.\\n   * @param messageId ID uniquely identifying the batch of messages\\n   * @param messageIndex Index of the message\\n   * @param errorData Error data returned by the call\\n   */\\n  error MessageBatchFailure(bytes32 messageId, uint256 messageIndex, bytes errorData);\\n\\n  /* ============ Internal Functions ============ */\\n\\n  /**\\n   * @notice Helper to compute messageId.\\n   * @param nonce Monotonically increased nonce to ensure uniqueness\\n   * @param from Address that dispatched the message\\n   * @param to Address that will receive the message\\n   * @param data Data that was dispatched\\n   * @return bytes32 ID uniquely identifying the message that was dispatched\\n   */\\n  function computeMessageId(\\n    uint256 nonce,\\n    address from,\\n    address to,\\n    bytes memory data\\n  ) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(nonce, from, to, data));\\n  }\\n\\n  /**\\n   * @notice Helper to compute messageId for a batch of messages.\\n   * @param nonce Monotonically increased nonce to ensure uniqueness\\n   * @param from Address that dispatched the messages\\n   * @param messages Array of Message dispatched\\n   * @return bytes32 ID uniquely identifying the message that was dispatched\\n   */\\n  function computeMessageBatchId(\\n    uint256 nonce,\\n    address from,\\n    Message[] memory messages\\n  ) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(nonce, from, messages));\\n  }\\n\\n  /**\\n   * @notice Helper to encode message for execution by the MessageExecutor.\\n   * @param to Address that will receive the message\\n   * @param data Data that will be dispatched\\n   * @param messageId ID uniquely identifying the message being dispatched\\n   * @param fromChainId ID of the chain that dispatched the message\\n   * @param from Address that dispatched the message\\n   */\\n  function encodeMessage(\\n    address to,\\n    bytes memory data,\\n    bytes32 messageId,\\n    uint256 fromChainId,\\n    address from\\n  ) internal pure returns (bytes memory) {\\n    return\\n      abi.encodeCall(IMessageExecutor.executeMessage, (to, data, messageId, fromChainId, from));\\n  }\\n\\n  /**\\n   * @notice Helper to encode a batch of messages for execution by the MessageExecutor.\\n   * @param messages Array of Message that will be dispatched\\n   * @param messageId ID uniquely identifying the batch of messages being dispatched\\n   * @param fromChainId ID of the chain that dispatched the batch of messages\\n   * @param from Address that dispatched the batch of messages\\n   */\\n  function encodeMessageBatch(\\n    Message[] memory messages,\\n    bytes32 messageId,\\n    uint256 fromChainId,\\n    address from\\n  ) internal pure returns (bytes memory) {\\n    return\\n      abi.encodeCall(\\n        IMessageExecutor.executeMessageBatch,\\n        (messages, messageId, fromChainId, from)\\n      );\\n  }\\n\\n  /**\\n   * @notice Execute message from the origin chain.\\n   * @dev Will revert if `message` has already been executed.\\n   * @param to Address that will receive the message\\n   * @param data Data that was dispatched\\n   * @param messageId ID uniquely identifying message\\n   * @param fromChainId ID of the chain that dispatched the `message`\\n   * @param from Address of the sender on the origin chain\\n   * @param executedMessageId Whether `message` has already been executed or not\\n   */\\n  function executeMessage(\\n    address to,\\n    bytes memory data,\\n    bytes32 messageId,\\n    uint256 fromChainId,\\n    address from,\\n    bool executedMessageId\\n  ) internal {\\n    if (executedMessageId) {\\n      revert MessageIdAlreadyExecuted(messageId);\\n    }\\n\\n    _requireContract(to);\\n\\n    (bool _success, bytes memory _returnData) = to.call(\\n      abi.encodePacked(data, messageId, fromChainId, from)\\n    );\\n\\n    if (!_success) {\\n      revert MessageFailure(messageId, _returnData);\\n    }\\n  }\\n\\n  /**\\n   * @notice Execute messages from the origin chain.\\n   * @dev Will revert if `messages` have already been executed.\\n   * @param messages Array of messages being executed\\n   * @param messageId Nonce to uniquely identify the messages\\n   * @param from Address of the sender on the origin chain\\n   * @param fromChainId ID of the chain that dispatched the `messages`\\n   * @param executedMessageId Whether `messages` have already been executed or not\\n   */\\n  function executeMessageBatch(\\n    Message[] memory messages,\\n    bytes32 messageId,\\n    uint256 fromChainId,\\n    address from,\\n    bool executedMessageId\\n  ) internal {\\n    if (executedMessageId) {\\n      revert MessageIdAlreadyExecuted(messageId);\\n    }\\n\\n    uint256 _messagesLength = messages.length;\\n\\n    for (uint256 _messageIndex; _messageIndex < _messagesLength; ) {\\n      Message memory _message = messages[_messageIndex];\\n      _requireContract(_message.to);\\n\\n      (bool _success, bytes memory _returnData) = _message.to.call(\\n        abi.encodePacked(_message.data, messageId, fromChainId, from)\\n      );\\n\\n      if (!_success) {\\n        revert MessageBatchFailure(messageId, _messageIndex, _returnData);\\n      }\\n\\n      unchecked {\\n        _messageIndex++;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Check that the call is being made to a contract.\\n   * @param to Address to check\\n   */\\n  function _requireContract(address to) internal view {\\n    require(to.code.length > 0, \\\"MessageLib/no-contract-at-to\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMessageDispatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.16;\\n\\nimport { MessageLib } from \\\"../libraries/MessageLib.sol\\\";\\n\\n/**\\n * @title ERC-5164: Cross-Chain Execution Standard\\n * @dev See https://eips.ethereum.org/EIPS/eip-5164\\n */\\ninterface IMessageDispatcher {\\n  /**\\n   * @notice Emitted when a message has successfully been dispatched to the executor chain.\\n   * @param messageId ID uniquely identifying the message\\n   * @param from Address that dispatched the message\\n   * @param toChainId ID of the chain receiving the message\\n   * @param to Address that will receive the message\\n   * @param data Data that was dispatched\\n   */\\n  event MessageDispatched(\\n    bytes32 indexed messageId,\\n    address indexed from,\\n    uint256 indexed toChainId,\\n    address to,\\n    bytes data\\n  );\\n\\n  /**\\n   * @notice Emitted when a batch of messages has successfully been dispatched to the executor chain.\\n   * @param messageId ID uniquely identifying the messages\\n   * @param from Address that dispatched the messages\\n   * @param toChainId ID of the chain receiving the messages\\n   * @param messages Array of Message that was dispatched\\n   */\\n  event MessageBatchDispatched(\\n    bytes32 indexed messageId,\\n    address indexed from,\\n    uint256 indexed toChainId,\\n    MessageLib.Message[] messages\\n  );\\n\\n  /**\\n   * @notice Retrieves address of the MessageExecutor contract on the receiving chain.\\n   * @dev Must revert if `toChainId` is not supported.\\n   * @param toChainId ID of the chain with which MessageDispatcher is communicating\\n   * @return address MessageExecutor contract address\\n   */\\n  function getMessageExecutorAddress(uint256 toChainId) external returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solidity-stringutils/=lib/solidity-stringutils/src/\",\r\n      \"@maticnetwork/fx-portal/=lib/contracts/\",\r\n      \"@arbitrum/nitro-contracts/=lib/nitro/contracts/\",\r\n      \"@handlers/=lib/contracts/test/handlers/\",\r\n      \"@mock/=lib/contracts/test/mock/\",\r\n      \"@openzeppelin/=lib/contracts/lib/openzeppelin-contracts/\",\r\n      \"@utils/=lib/contracts/test/utils/\",\r\n      \"contracts/=lib/contracts/contracts/\",\r\n      \"nitro/=lib/nitro/\",\r\n      \"openzeppelin-contracts/=lib/contracts/lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ICrossDomainMessenger\",\"name\":\"_crossDomainMessenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_gasLimit\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct MessageLib.Message[]\",\"name\":\"messages\",\"type\":\"tuple[]\"}],\"name\":\"MessageBatchDispatched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MessageDispatched\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"crossDomainMessenger\",\"outputs\":[{\"internalType\":\"contract ICrossDomainMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"dispatchMessage\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct MessageLib.Message[]\",\"name\":\"_messages\",\"type\":\"tuple[]\"}],\"name\":\"dispatchMessageBatch\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"_gasLimit\",\"type\":\"uint32\"}],\"name\":\"dispatchMessageWithGasLimit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct MessageLib.Message[]\",\"name\":\"_messages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint32\",\"name\":\"_gasLimit\",\"type\":\"uint32\"}],\"name\":\"dispatchMessageWithGasLimitBatch\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"}],\"name\":\"getMessageExecutorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMessageExecutor\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"setExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MessageDispatcherOptimism", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000025ace71c97b33cc4729cf772ae268934f7ab5fa1000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000001d4c00", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}