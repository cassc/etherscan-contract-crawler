{"SourceCode": "contract Assertive {\r\n  function assert(bool assertion) {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract TokenRecipient {\r\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\ncontract Owned is Assertive {\r\n  address internal owner;\r\n  event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n  function Owned () {\r\n    owner = msg.sender;\r\n  }\r\n  modifier onlyOwner {\r\n    assert(msg.sender == owner);\r\n    _\r\n  }\r\n  function setOwner(address newOwner) onlyOwner {\r\n    SetOwner(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n  function getOwner() returns (address out) {\r\n    return owner;\r\n  }\r\n}\r\n\r\ncontract StateTransferrable is Owned {\r\n  bool internal locked;\r\n  event Locked(address indexed from);\r\n  event PropertySet(address indexed from);\r\n  modifier onlyIfUnlocked {\r\n    assert(!locked);\r\n    _\r\n  }\r\n  modifier setter {\r\n    _\r\n    PropertySet(msg.sender);\r\n  }\r\n  modifier onlyOwnerUnlocked {\r\n    assert(!locked && msg.sender == owner);\r\n    _\r\n  }\r\n  function lock() onlyOwner onlyIfUnlocked {\r\n    locked = true;\r\n    Locked(msg.sender);\r\n  }\r\n  function isLocked() returns (bool status) {\r\n    return locked;\r\n  }\r\n}\r\n\r\ncontract TrustEvents {\r\n  event AuthInit(address indexed from);\r\n  event AuthComplete(address indexed from, address indexed with);\r\n  event AuthPending(address indexed from);\r\n  event Unauthorized(address indexed from);\r\n  event InitCancel(address indexed from);\r\n  event NothingToCancel(address indexed from);\r\n  event SetMasterKey(address indexed from);\r\n  event AuthCancel(address indexed from, address indexed with);\r\n  event NameRegistered(address indexed from, bytes32 indexed name);\r\n}\r\n\r\ncontract Trust is StateTransferrable, TrustEvents {\r\n  mapping (address => bool) public masterKeys;\r\n  mapping (address => bytes32) public nameRegistry;\r\n  address[] public masterKeyIndex;\r\n  mapping (address => bool) public masterKeyActive;\r\n  mapping (address => bool) public trustedClients;\r\n  mapping (uint256 => address) public functionCalls;\r\n  mapping (address => uint256) public functionCalling;\r\n  function activateMasterKey(address addr) internal {\r\n    if (!masterKeyActive[addr]) {\r\n      masterKeyActive[addr] = true;\r\n      masterKeyIndex.push(addr);\r\n    }\r\n  }\r\n  function setTrustedClient(address addr) onlyOwnerUnlocked setter {\r\n    trustedClients[addr] = true;\r\n  }\r\n  function untrustClient(address addr) multisig(sha3(msg.data)) {\r\n    trustedClients[addr] = false;\r\n  }\r\n  function trustClient(address addr) multisig(sha3(msg.data)) {\r\n    trustedClients[addr] = true;\r\n  }\r\n  function setMasterKey(address addr) onlyOwnerUnlocked {\r\n    assert(!masterKeys[addr]);\r\n    activateMasterKey(addr);\r\n    masterKeys[addr] = true;\r\n    SetMasterKey(msg.sender);\r\n  }\r\n  modifier onlyMasterKey {\r\n    assert(masterKeys[msg.sender]);\r\n    _\r\n  }\r\n  function extractMasterKeyIndexLength() returns (uint256 length) {\r\n    return masterKeyIndex.length;\r\n  }\r\n  function resetAction(uint256 hash) internal {\r\n    address addr = functionCalls[hash];\r\n    functionCalls[hash] = 0x0;\r\n    functionCalling[addr] = 0;\r\n  }\r\n  function authCancel(address from) external returns (uint8 status) {\r\n    if (!masterKeys[from] || !trustedClients[msg.sender]) {\r\n      Unauthorized(from);\r\n      return 0;\r\n    }\r\n    uint256 call = functionCalling[from];\r\n    if (call == 0) {\r\n      NothingToCancel(from);\r\n      return 1;\r\n    } else {\r\n      AuthCancel(from, from);\r\n      functionCalling[from] = 0;\r\n      functionCalls[call] = 0x0;\r\n      return 2;\r\n    }\r\n  }\r\n  function cancel() returns (uint8 code) {\r\n    if (!masterKeys[msg.sender]) {\r\n      Unauthorized(msg.sender);\r\n      return 0;\r\n    }\r\n    uint256 call = functionCalling[msg.sender];\r\n    if (call == 0) {\r\n      NothingToCancel(msg.sender);\r\n      return 1;\r\n    } else {\r\n      AuthCancel(msg.sender, msg.sender);\r\n      uint256 hash = functionCalling[msg.sender];\r\n      functionCalling[msg.sender] = 0x0;\r\n      functionCalls[hash] = 0;\r\n      return 2;\r\n    }\r\n  }\r\n  function authCall(address from, bytes32 hash) external returns (uint8 code) {\r\n    if (!masterKeys[from] && !trustedClients[msg.sender]) {\r\n      Unauthorized(from);\r\n      return 0;\r\n    }\r\n    if (functionCalling[from] == 0) {\r\n      if (functionCalls[uint256(hash)] == 0x0) {\r\n        functionCalls[uint256(hash)] = from;\r\n        functionCalling[from] = uint256(hash);\r\n        AuthInit(from);\r\n        return 1;\r\n      } else { \r\n        AuthComplete(functionCalls[uint256(hash)], from);\r\n        resetAction(uint256(hash));\r\n        return 2;\r\n      }\r\n    } else {\r\n      AuthPending(from);\r\n      return 3;\r\n    }\r\n  }\r\n  modifier multisig (bytes32 hash) {\r\n    if (!masterKeys[msg.sender]) {\r\n      Unauthorized(msg.sender);\r\n    } else if (functionCalling[msg.sender] == 0) {\r\n      if (functionCalls[uint256(hash)] == 0x0) {\r\n        functionCalls[uint256(hash)] = msg.sender;\r\n        functionCalling[msg.sender] = uint256(hash);\r\n        AuthInit(msg.sender);\r\n      } else { \r\n        AuthComplete(functionCalls[uint256(hash)], msg.sender);\r\n        resetAction(uint256(hash));\r\n        _\r\n      }\r\n    } else {\r\n      AuthPending(msg.sender);\r\n    }\r\n  }\r\n  function voteOutMasterKey(address addr) multisig(sha3(msg.data)) {\r\n    assert(masterKeys[addr]);\r\n    masterKeys[addr] = false;\r\n  }\r\n  function voteInMasterKey(address addr) multisig(sha3(msg.data)) {\r\n    assert(!masterKeys[addr]);\r\n    activateMasterKey(addr);\r\n    masterKeys[addr] = true;\r\n  }\r\n  function identify(bytes32 name) onlyMasterKey {\r\n    nameRegistry[msg.sender] = name;\r\n    NameRegistered(msg.sender, name);\r\n  }\r\n  function nameFor(address addr) returns (bytes32 name) {\r\n    return nameRegistry[addr];\r\n  }\r\n}\r\n\r\n\r\ncontract TrustClient is StateTransferrable, TrustEvents {\r\n  address public trustAddress;\r\n  function setTrust(address addr) setter onlyOwnerUnlocked {\r\n    trustAddress = addr;\r\n  }\r\n  function nameFor(address addr) constant returns (bytes32 name) {\r\n    return Trust(trustAddress).nameFor(addr);\r\n  }\r\n  function cancel() returns (uint8 status) {\r\n    assert(trustAddress != address(0x0));\r\n    uint8 code = Trust(trustAddress).authCancel(msg.sender);\r\n    if (code == 0) Unauthorized(msg.sender);\r\n    else if (code == 1) NothingToCancel(msg.sender);\r\n    else if (code == 2) AuthCancel(msg.sender, msg.sender);\r\n    return code;\r\n  }\r\n  modifier multisig (bytes32 hash) {\r\n    assert(trustAddress != address(0x0));\r\n    address current = Trust(trustAddress).functionCalls(uint256(hash));\r\n    uint8 code = Trust(trustAddress).authCall(msg.sender, hash);\r\n    if (code == 0) Unauthorized(msg.sender);\r\n    else if (code == 1) AuthInit(msg.sender);\r\n    else if (code == 2) {\r\n      AuthComplete(current, msg.sender);\r\n      _\r\n    }\r\n    else if (code == 3) {\r\n      AuthPending(msg.sender);\r\n    }\r\n  }\r\n}\r\ncontract Relay {\r\n  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success);\r\n}\r\ncontract TokenBase is Owned {\r\n    bytes32 public standard = 'Token 0.1';\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    bool public allowTransactions;\r\n\r\n    event Approval(address indexed from, address indexed spender, uint256 amount);\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n}\r\n\r\ncontract Precision {\r\n  uint8 public decimals;\r\n}\r\ncontract Token is TokenBase, Precision {}\r\ncontract Util {\r\n  function pow10(uint256 a, uint8 b) internal returns (uint256 result) {\r\n    for (uint8 i = 0; i < b; i++) {\r\n      a *= 10;\r\n    }\r\n    return a;\r\n  }\r\n  function div10(uint256 a, uint8 b) internal returns (uint256 result) {\r\n    for (uint8 i = 0; i < b; i++) {\r\n      a /= 10;\r\n    }\r\n    return a;\r\n  }\r\n  function max(uint256 a, uint256 b) internal returns (uint256 res) {\r\n    if (a >= b) return a;\r\n    return b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title DVIP Contract. DCAsset Membership Token contract.\r\n *\r\n * @author Ray Pulver, ray@decentralizedcapital.com\r\n */\r\ncontract DVIP is Token, StateTransferrable, TrustClient, Util {\r\n\r\n  uint256 public totalSupply;\r\n\r\n  mapping (address => bool) public frozenAccount;\r\n\r\n  mapping (address => address[]) public allowanceIndex;\r\n  mapping (address => mapping (address => bool)) public allowanceActive;\r\n  address[] public accountIndex;\r\n  mapping (address => bool) public accountActive;\r\n  address public oversightAddress;\r\n  uint256 public expiry;\r\n\r\n  uint256 public treasuryBalance;\r\n\r\n  bool public isActive;\r\n  mapping (address => uint256) public exportFee;\r\n  address[] public exportFeeIndex;\r\n  mapping (address => bool) exportFeeActive;\r\n\r\n  mapping (address => uint256) public importFee;\r\n  address[] public importFeeIndex;\r\n  mapping (address => bool) importFeeActive;\r\n\r\n  event FrozenFunds(address target, bool frozen);\r\n  event PrecisionSet(address indexed from, uint8 precision);\r\n  event TransactionsShutDown(address indexed from);\r\n  event FeeSetup(address indexed from, address indexed target, uint256 amount);\r\n\r\n\r\n  /**\r\n   * Constructor.\r\n   *\r\n   */\r\n  function DVIP() {\r\n    isActive = true;\r\n    treasuryBalance = 0;\r\n    totalSupply = 0;\r\n    name = \"DVIP\";\r\n    symbol = \"DVIP\";\r\n    decimals = 6;\r\n    allowTransactions = true;\r\n    expiry = 1514764800; //1 jan 2018\r\n  }\r\n\r\n\r\n  /* ---------------  modifiers  --------------*/\r\n\r\n  /**\r\n   * Makes sure a method is only called by an overseer.\r\n   */\r\n  modifier onlyOverseer {\r\n    assert(msg.sender == oversightAddress);\r\n    _\r\n  }\r\n\r\n  /* ---------------  setter methods, only for the unlocked state --------------*/\r\n\r\n\r\n  /**\r\n   * Sets the oversight address (not the contract).\r\n   *\r\n   * @param addr The oversight contract address.\r\n   */\r\n  function setOversight(address addr) onlyOwnerUnlocked setter {\r\n    oversightAddress = addr;\r\n  }\r\n\r\n\r\n  /**\r\n   * Sets the total supply\r\n   *\r\n   * @param total Total supply of the asset.\r\n   */\r\n  function setTotalSupply(uint256 total) onlyOwnerUnlocked setter {\r\n    totalSupply = total;\r\n  }\r\n\r\n  /**\r\n   * Set the Token Standard the contract applies to.\r\n   *\r\n   * @param std the Standard.\r\n   */\r\n  function setStandard(bytes32 std) onlyOwnerUnlocked setter {\r\n    standard = std;\r\n  }\r\n\r\n  /**\r\n   * Sets the name of the contraxt\r\n   *\r\n   * @param _name the name.\r\n   */\r\n  function setName(bytes32 _name) onlyOwnerUnlocked setter {\r\n    name = _name;\r\n  }\r\n\r\n  /**\r\n   * Sets the symbol\r\n   *\r\n   * @param sym The Symbol\r\n   */\r\n  function setSymbol(bytes32 sym) onlyOwnerUnlocked setter {\r\n    symbol = sym;\r\n  }\r\n\r\n  /**\r\n   * Sets the precision\r\n   *\r\n   * @param precision Amount of decimals\r\n   */\r\n  function setPrecisionDirect(uint8 precision) onlyOwnerUnlocked {\r\n    decimals = precision;\r\n    PrecisionSet(msg.sender, precision);\r\n  }\r\n\r\n  /**\r\n   * Sets the balance of a certain account.\r\n   *\r\n   * @param addr Address of the account\r\n   * @param amount Amount of assets to set on the account\r\n   */\r\n  function setAccountBalance(address addr, uint256 amount) onlyOwnerUnlocked {\r\n    balanceOf[addr] = amount;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  /**\r\n   * Sets an allowance from a specific account to a specific account.\r\n   *\r\n   * @param from From-part of the allowance\r\n   * @param to To-part of the allowance\r\n   * @param amount Amount of the allowance\r\n   */\r\n  function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked {\r\n    allowance[from][to] = amount;\r\n    activateAllowanceRecord(from, to);\r\n  }\r\n\r\n  /**\r\n   * Sets the treasure balance to a certain account.\r\n   *\r\n   * @param amount Amount of assets to pre-set in the treasury\r\n   */\r\n  function setTreasuryBalance(uint256 amount) onlyOwnerUnlocked {\r\n    treasuryBalance = amount;\r\n  }\r\n\r\n  /**\r\n   * Sets a certain account on frozen/unfrozen\r\n   *\r\n   * @param addr Account that will be frozen/unfrozen\r\n   * @param frozen Boolean to freeze or unfreeze\r\n   */\r\n  function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked {\r\n    activateAccount(addr);\r\n    frozenAccount[addr] = frozen;\r\n  }\r\n\r\n  /**\r\n   * Sets up a import fee for a certain address.\r\n   *\r\n   * @param addr Address that will require fee\r\n   * @param fee Amount of fee\r\n   */\r\n  function setupImportFee(address addr, uint256 fee) onlyOwnerUnlocked {\r\n    importFee[addr] = fee;\r\n    activateImportFeeChargeRecord(addr);\r\n    FeeSetup(msg.sender, addr, fee);\r\n  }\r\n \r\n  /**\r\n   * Sets up a export fee for a certain address.\r\n   *\r\n   * @param addr Address that will require fee\r\n   * @param fee Amount of fee\r\n   */\r\n  function setupExportFee(address addr, uint256 fee) onlyOwnerUnlocked {\r\n    exportFee[addr] = fee;\r\n    activateExportFeeChargeRecord(addr);\r\n    FeeSetup(msg.sender, addr, fee);\r\n  }\r\n\r\n  /* ---------------  main token methods  --------------*/\r\n\r\n\r\n  /**\r\n   * @notice Transfer `_amount` from `msg.sender.address()` to `_to`.\r\n   *\r\n   * @param _to Address that will receive.\r\n   * @param _amount Amount to be transferred.\r\n   */\r\n  function transfer(address _to, uint256 _amount) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    assert(balanceOf[msg.sender] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    activateAccount(msg.sender);\r\n    activateAccount(_to);\r\n    balanceOf[msg.sender] -= _amount;\r\n    if (_to == address(this)) treasuryBalance += _amount;\r\n    else balanceOf[_to] += _amount;\r\n    Transfer(msg.sender, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `_amount` from `_from` to `_to`.\r\n   *\r\n   * @param _from Origin address\r\n   * @param _to Address that will receive\r\n   * @param _amount Amount to be transferred.\r\n   * @return result of the method call\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    assert(!frozenAccount[_from]);\r\n    assert(balanceOf[_from] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    assert(_amount <= allowance[_from][msg.sender]);\r\n    balanceOf[_from] -= _amount;\r\n    balanceOf[_to] += _amount;\r\n    allowance[_from][msg.sender] -= _amount;\r\n    activateAccount(_from);\r\n    activateAccount(_to);\r\n    activateAccount(msg.sender);\r\n    Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Approve spender `_spender` to transfer `_amount` from `msg.sender.address()`\r\n   *\r\n   * @param _spender Address that receives the cheque\r\n   * @param _amount Amount on the cheque\r\n   * @param _extraData Consequential contract to be executed by spender in same transcation.\r\n   * @return result of the method call\r\n   */\r\n  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    allowance[msg.sender][_spender] = _amount;\r\n    activateAccount(msg.sender);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(msg.sender, _spender);\r\n    TokenRecipient spender = TokenRecipient(_spender);\r\n    spender.receiveApproval(msg.sender, _amount, this, _extraData);\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Approve spender `_spender` to transfer `_amount` from `msg.sender.address()`\r\n   *\r\n   * @param _spender Address that receives the cheque\r\n   * @param _amount Amount on the cheque\r\n   * @return result of the method call\r\n   */\r\n  function approve(address _spender, uint256 _amount) returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[msg.sender]);\r\n    allowance[msg.sender][_spender] = _amount;\r\n    activateAccount(msg.sender);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(msg.sender, _spender);\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  /* ---------------  multisig admin methods  --------------*/\r\n\r\n\r\n\r\n  /**\r\n   * @notice Sets the expiry time in milliseconds since 1970.\r\n   *\r\n   * @param ts milliseconds since 1970.\r\n   *\r\n   */\r\n  function setExpiry(uint256 ts) multisig(sha3(msg.data)) {\r\n    expiry = ts;\r\n  }\r\n\r\n  /**\r\n   * @notice Mints `mintedAmount` new tokens to the hotwallet `hotWalletAddress`.\r\n   *\r\n   * @param mintedAmount Amount of new tokens to be minted.\r\n   */\r\n  function mint(uint256 mintedAmount) multisig(sha3(msg.data)) {\r\n    treasuryBalance += mintedAmount;\r\n    totalSupply += mintedAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice Destroys `destroyAmount` new tokens from the hotwallet `hotWalletAddress`\r\n   *\r\n   * @param destroyAmount Amount of new tokens to be minted.\r\n   */\r\n  function destroyTokens(uint256 destroyAmount) multisig(sha3(msg.data)) {\r\n    assert(treasuryBalance >= destroyAmount);\r\n    treasuryBalance -= destroyAmount;\r\n    totalSupply -= destroyAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers `amount` from the treasury to `to`\r\n   *\r\n   * @param to Address to transfer to\r\n   * @param amount Amount to transfer from treasury\r\n   */\r\n  function transferFromTreasury(address to, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(treasuryBalance >= amount);\r\n    treasuryBalance -= amount;\r\n    balanceOf[to] += amount;\r\n    activateAccount(to);\r\n  }\r\n\r\n  /* ---------------  fee setting administration methods  --------------*/\r\n\r\n  /**\r\n   * @notice Sets an import fee of `fee` on address `addr`\r\n   *\r\n   * @param addr Address for which the fee is valid\r\n   * @param addr fee Fee\r\n   *\r\n   */\r\n  function setImportFee(address addr, uint256 fee) multisig(sha3(msg.data)) {\r\n    uint256 max = 1;\r\n    max = pow10(1, decimals);\r\n    assert(fee <= max);\r\n    importFee[addr] = fee;\r\n    activateImportFeeChargeRecord(addr);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets an export fee of `fee` on address `addr`\r\n   *\r\n   * @param addr Address for which the fee is valid\r\n   * @param addr fee Fee\r\n   *\r\n   */\r\n  function setExportFee(address addr, uint256 fee) multisig(sha3(msg.data)) {\r\n    uint256 max = 1;\r\n    max = pow10(1, decimals);\r\n    assert(fee <= max);\r\n    exportFee[addr] = fee;\r\n    activateExportFeeChargeRecord(addr);\r\n  }\r\n\r\n\r\n  /* ---------------  multisig emergency methods --------------*/\r\n\r\n  /**\r\n   * @notice Sets allow transactions to `allow`\r\n   *\r\n   * @param allow Allow or disallow transactions\r\n   */\r\n  function voteAllowTransactions(bool allow) multisig(sha3(msg.data)) {\r\n    assert(allow != allowTransactions);\r\n    allowTransactions = allow;\r\n  }\r\n\r\n  /**\r\n   * @notice Destructs the contract and sends remaining `this.balance` Ether to `beneficiary`\r\n   *\r\n   * @param beneficiary Beneficiary of remaining Ether on contract\r\n   */\r\n  function voteSuicide(address beneficiary) multisig(sha3(msg.data)) {\r\n    selfdestruct(beneficiary);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets frozen to `freeze` for account `target`\r\n   *\r\n   * @param addr Address to be frozen/unfrozen\r\n   * @param freeze Freeze/unfreeze account\r\n   */\r\n  function freezeAccount(address addr, bool freeze) multisig(sha3(msg.data)) {\r\n    frozenAccount[addr] = freeze;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  /**\r\n   * @notice Seizes `seizeAmount` of tokens from `address` and transfers it to hotwallet\r\n   *\r\n   * @param addr Adress to seize tokens from\r\n   * @param amount Amount of tokens to seize\r\n   */\r\n  function seizeTokens(address addr, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(balanceOf[addr] >= amount);\r\n    assert(frozenAccount[addr]);\r\n    activateAccount(addr);\r\n    balanceOf[addr] -= amount;\r\n    treasuryBalance += amount;\r\n  }\r\n\r\n  /* --------------- fee calculation method ---------------- */\r\n\r\n\r\n  /**\r\n   * @notice 'Returns the fee for a transfer from `from` to `to` on an amount `amount`.\r\n   *\r\n   * Fee's consist of a possible\r\n   *    - import fee on transfers to an address\r\n   *    - export fee on transfers from an address\r\n   * DVIP ownership on an address\r\n   *    - reduces fee on a transfer from this address to an import fee-ed address\r\n   *    - reduces the fee on a transfer to this address from an export fee-ed address\r\n   * DVIP discount does not work for addresses that have an import fee or export fee set up against them.\r\n   *\r\n   * DVIP discount goes up to 100%\r\n   *\r\n   * @param from From address\r\n   * @param to To address\r\n   * @param amount Amount for which fee needs to be calculated.\r\n   *\r\n   */\r\n  function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value) {\r\n    uint256 fee = exportFee[from] + importFee[to];\r\n    if (fee == 0) return 0;\r\n    uint256 amountHeld;\r\n    bool discounted = true;\r\n    uint256 oneDVIPUnit;\r\n    if (exportFee[from] == 0 && balanceOf[from] != 0 && now < expiry) {\r\n      amountHeld = balanceOf[from];\r\n    } else if (importFee[to] == 0 && balanceOf[to] != 0 && now < expiry) {\r\n      amountHeld = balanceOf[to];\r\n    } else discounted = false;\r\n    if (discounted) {\r\n      oneDVIPUnit = pow10(1, decimals);\r\n      if (amountHeld > oneDVIPUnit) amountHeld = oneDVIPUnit;\r\n      uint256 remaining = oneDVIPUnit - amountHeld;\r\n      return div10(amount*fee*remaining, decimals*2);\r\n    }\r\n    return div10(amount*fee, decimals);\r\n  }\r\n\r\n\r\n  /* ---------------  overseer methods for emergency --------------*/\r\n\r\n  /**\r\n   * @notice Shuts down all transaction and approval options on the asset contract\r\n   */\r\n  function shutdownTransactions() onlyOverseer {\r\n    allowTransactions = false;\r\n    TransactionsShutDown(msg.sender);\r\n  }\r\n\r\n  /* ---------------  helper methods for siphoning --------------*/\r\n\r\n  function extractAccountAllowanceRecordLength(address addr) constant returns (uint256 len) {\r\n    return allowanceIndex[addr].length;\r\n  }\r\n\r\n  function extractAccountLength() constant returns (uint256 length) {\r\n    return accountIndex.length;\r\n  }\r\n\r\n  /* ---------------  private methods --------------*/\r\n\r\n  function activateAccount(address addr) internal {\r\n    if (!accountActive[addr]) {\r\n      accountActive[addr] = true;\r\n      accountIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateAllowanceRecord(address from, address to) internal {\r\n    if (!allowanceActive[from][to]) {\r\n      allowanceActive[from][to] = true;\r\n      allowanceIndex[from].push(to);\r\n    }\r\n  }\r\n\r\n  function activateExportFeeChargeRecord(address addr) internal {\r\n    if (!exportFeeActive[addr]) {\r\n      exportFeeActive[addr] = true;\r\n      exportFeeIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateImportFeeChargeRecord(address addr) internal {\r\n    if (!importFeeActive[addr]) {\r\n      importFeeActive[addr] = true;\r\n      importFeeIndex.push(addr);\r\n    }\r\n  }\r\n  function extractImportFeeChargeLength() returns (uint256 length) {\r\n    return importFeeIndex.length;\r\n  }\r\n\r\n  function extractExportFeeChargeLength() returns (uint256 length) {\r\n    return exportFeeIndex.length;\r\n  }\r\n}\r\n\r\n/**\r\n * @title DCAssetBackend Contract\r\n *\r\n * @author Ray Pulver, ray@decentralizedcapital.com\r\n */\r\ncontract DCAssetBackend is Owned, Precision, StateTransferrable, TrustClient, Util {\r\n\r\n  bytes32 public standard = 'Token 0.1';\r\n  bytes32 public name;\r\n  bytes32 public symbol;\r\n\r\n  bool public allowTransactions;\r\n\r\n  event Approval(address indexed from, address indexed spender, uint256 amount);\r\n\r\n  mapping (address => uint256) public balanceOf;\r\n  mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  uint256 public totalSupply;\r\n\r\n  address public hotWalletAddress;\r\n  address public assetAddress;\r\n  address public oversightAddress;\r\n  address public membershipAddress;\r\n\r\n  mapping (address => bool) public frozenAccount;\r\n\r\n  mapping (address => address[]) public allowanceIndex;\r\n  mapping (address => mapping (address => bool)) public allowanceActive;\r\n  address[] public accountIndex;\r\n  mapping (address => bool) public accountActive;\r\n\r\n  bool public isActive;\r\n  uint256 public treasuryBalance;\r\n\r\n  mapping (address => uint256) public feeCharge;\r\n  address[] public feeChargeIndex;\r\n  mapping (address => bool) feeActive;\r\n\r\n  event FrozenFunds(address target, bool frozen);\r\n  event PrecisionSet(address indexed from, uint8 precision);\r\n  event TransactionsShutDown(address indexed from);\r\n  event FeeSetup(address indexed from, address indexed target, uint256 amount);\r\n\r\n\r\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param tokenName Name of the Token\r\n   * @param tokenSymbol The Token Symbol\r\n   */\r\n  function DCAssetBackend(bytes32 tokenSymbol, bytes32 tokenName) {\r\n    isActive = true;\r\n    name = tokenName;\r\n    symbol = tokenSymbol;\r\n    decimals = 6;\r\n    allowTransactions = true;\r\n  }\r\n\r\n  /* ---------------  modifiers  --------------*/\r\n\r\n  /**\r\n   * Makes sure a method is only called by an overseer.\r\n   */\r\n  modifier onlyOverseer {\r\n    assert(msg.sender == oversightAddress);\r\n    _\r\n  }\r\n\r\n  /**\r\n   * Make sure only the front end Asset can call the transfer methods\r\n   */\r\n   modifier onlyAsset {\r\n    assert(msg.sender == assetAddress);\r\n    _\r\n   }\r\n\r\n  /* ---------------  setter methods, only for the unlocked state --------------*/\r\n\r\n\r\n  /**\r\n   * Sets the hot wallet contract address\r\n   *\r\n   * @param addr Address of the Hotwallet\r\n   */\r\n  function setHotWallet(address addr) onlyOwnerUnlocked setter {\r\n    hotWalletAddress = addr;\r\n  }\r\n\r\n  /**\r\n    * Sets the token facade contract address\r\n    *\r\n    * @param addr Address of the front-end Asset\r\n    */\r\n  function setAsset(address addr) onlyOwnerUnlocked setter {\r\n    assetAddress = addr;\r\n  }\r\n\r\n  /**\r\n   * Sets the membership contract address\r\n   *\r\n   * @param addr Address of the membership contract\r\n   */\r\n  function setMembership(address addr) onlyOwnerUnlocked setter {\r\n    membershipAddress = addr;\r\n  }\r\n\r\n  /**\r\n   * Sets the oversight address (not the contract).\r\n   *\r\n   * @param addr The oversight contract address.\r\n   */\r\n  function setOversight(address addr) onlyOwnerUnlocked setter {\r\n    oversightAddress = addr;\r\n  }\r\n\r\n  /**\r\n   * Sets the total supply\r\n   *\r\n   * @param total Total supply of the asset.\r\n   */\r\n  function setTotalSupply(uint256 total) onlyOwnerUnlocked setter {\r\n    totalSupply = total;\r\n  }\r\n\r\n  /**\r\n   * Set the Token Standard the contract applies to.\r\n   *\r\n   * @param std the Standard.\r\n   */\r\n  function setStandard(bytes32 std) onlyOwnerUnlocked setter {\r\n    standard = std;\r\n  }\r\n\r\n  /**\r\n   * Sets the name of the contraxt\r\n   *\r\n   * @param _name the name.\r\n   */\r\n  function setName(bytes32 _name) onlyOwnerUnlocked setter {\r\n    name = _name;\r\n  }\r\n\r\n  /**\r\n   * Sets the symbol\r\n   *\r\n   * @param sym The Symbol\r\n   */\r\n  function setSymbol(bytes32 sym) onlyOwnerUnlocked setter {\r\n    symbol = sym;\r\n  }\r\n\r\n  /**\r\n   * Sets the precision\r\n   *\r\n   * @param precision Amount of decimals\r\n   */\r\n  function setPrecisionDirect(uint8 precision) onlyOwnerUnlocked {\r\n    decimals = precision;\r\n    PrecisionSet(msg.sender, precision);\r\n  }\r\n\r\n  /**\r\n   * Sets the balance of a certain account.\r\n   *\r\n   * @param addr Address of the account\r\n   * @param amount Amount of assets to set on the account\r\n   */\r\n  function setAccountBalance(address addr, uint256 amount) onlyOwnerUnlocked {\r\n    balanceOf[addr] = amount;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  /**\r\n   * Sets an allowance from a specific account to a specific account.\r\n   *\r\n   * @param from From-part of the allowance\r\n   * @param to To-part of the allowance\r\n   * @param amount Amount of the allowance\r\n   */\r\n  function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked {\r\n    allowance[from][to] = amount;\r\n    activateAllowanceRecord(from, to);\r\n  }\r\n\r\n  /**\r\n   * Sets the treasure balance to a certain account.\r\n   *\r\n   * @param amount Amount of assets to pre-set in the treasury\r\n   */\r\n  function setTreasuryBalance(uint256 amount) onlyOwnerUnlocked {\r\n    treasuryBalance = amount;\r\n  }\r\n\r\n  /**\r\n   * Sets a certain account on frozen/unfrozen\r\n   *\r\n   * @param addr Account that will be frozen/unfrozen\r\n   * @param frozen Boolean to freeze or unfreeze\r\n   */\r\n  function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked {\r\n    activateAccount(addr);\r\n    frozenAccount[addr] = frozen;\r\n  }\r\n\r\n  /* ---------------  main token methods  --------------*/\r\n\r\n\r\n  /**\r\n   * @notice Transfer `_amount` from `_caller` to `_to`.\r\n   *\r\n   * @param _caller Origin address\r\n   * @param _to Address that will receive.\r\n   * @param _amount Amount to be transferred.\r\n   */\r\n  function transfer(address _caller, address _to, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    assert(balanceOf[_caller] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    activateAccount(_caller);\r\n    activateAccount(_to);\r\n    balanceOf[_caller] -= _amount;\r\n    if (_to == address(this)) treasuryBalance += _amount;\r\n    else {\r\n        uint256 fee = feeFor(_caller, _to, _amount);\r\n        balanceOf[_to] += _amount - fee;\r\n        treasuryBalance += fee;\r\n    }\r\n    Transfer(_caller, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `_amount` from `_from` to `_to`, invoked by `_caller`.\r\n   *\r\n   * @param _caller Invoker of the call (owner of the allowance)\r\n   * @param _from Origin address\r\n   * @param _to Address that will receive\r\n   * @param _amount Amount to be transferred.\r\n   * @return result of the method call\r\n   */\r\n  function transferFrom(address _caller, address _from, address _to, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    assert(!frozenAccount[_from]);\r\n    assert(balanceOf[_from] >= _amount);\r\n    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\r\n    assert(_amount <= allowance[_from][_caller]);\r\n    balanceOf[_from] -= _amount;\r\n    uint256 fee = feeFor(_from, _to, _amount);\r\n    balanceOf[_to] += _amount - fee;\r\n    treasuryBalance += fee;\r\n    allowance[_from][_caller] -= _amount;\r\n    activateAccount(_from);\r\n    activateAccount(_to);\r\n    activateAccount(_caller);\r\n    Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Approve Approves spender `_spender` to transfer `_amount` from `_caller`\r\n   *\r\n   * @param _caller Address that grants the allowance\r\n   * @param _spender Address that receives the cheque\r\n   * @param _amount Amount on the cheque\r\n   * @param _extraData Consequential contract to be executed by spender in same transcation.\r\n   * @return result of the method call\r\n   */\r\n  function approveAndCall(address _caller, address _spender, uint256 _amount, bytes _extraData) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    allowance[_caller][_spender] = _amount;\r\n    activateAccount(_caller);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(_caller, _spender);\r\n    TokenRecipient spender = TokenRecipient(_spender);\r\n    assert(Relay(assetAddress).relayReceiveApproval(_caller, _spender, _amount, _extraData));\r\n    Approval(_caller, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Approve Approves spender `_spender` to transfer `_amount` from `_caller`\r\n   *\r\n   * @param _caller Address that grants the allowance\r\n   * @param _spender Address that receives the cheque\r\n   * @param _amount Amount on the cheque\r\n   * @return result of the method call\r\n   */\r\n  function approve(address _caller, address _spender, uint256 _amount) onlyAsset returns (bool success) {\r\n    assert(allowTransactions);\r\n    assert(!frozenAccount[_caller]);\r\n    allowance[_caller][_spender] = _amount;\r\n    activateAccount(_caller);\r\n    activateAccount(_spender);\r\n    activateAllowanceRecord(_caller, _spender);\r\n    Approval(_caller, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  /* ---------------  multisig admin methods  --------------*/\r\n\r\n\r\n  /**\r\n   * @notice Mints `mintedAmount` new tokens to the hotwallet `hotWalletAddress`.\r\n   *\r\n   * @param mintedAmount Amount of new tokens to be minted.\r\n   */\r\n  function mint(uint256 mintedAmount) multisig(sha3(msg.data)) {\r\n    activateAccount(hotWalletAddress);\r\n    balanceOf[hotWalletAddress] += mintedAmount;\r\n    totalSupply += mintedAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice Destroys `destroyAmount` new tokens from the hotwallet `hotWalletAddress`\r\n   *\r\n   * @param destroyAmount Amount of new tokens to be minted.\r\n   */\r\n  function destroyTokens(uint256 destroyAmount) multisig(sha3(msg.data)) {\r\n    assert(balanceOf[hotWalletAddress] >= destroyAmount);\r\n    activateAccount(hotWalletAddress);\r\n    balanceOf[hotWalletAddress] -= destroyAmount;\r\n    totalSupply -= destroyAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers `amount` from the treasury to `to`\r\n   *\r\n   * @param to Address to transfer to\r\n   * @param amount Amount to transfer from treasury\r\n   */\r\n  function transferFromTreasury(address to, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(treasuryBalance >= amount);\r\n    treasuryBalance -= amount;\r\n    balanceOf[to] += amount;\r\n    activateAccount(to);\r\n  }\r\n\r\n  /* ---------------  multisig emergency methods --------------*/\r\n\r\n  /**\r\n   * @notice Sets allow transactions to `allow`\r\n   *\r\n   * @param allow Allow or disallow transactions\r\n   */\r\n  function voteAllowTransactions(bool allow) multisig(sha3(msg.data)) {\r\n    if (allow == allowTransactions) throw;\r\n    allowTransactions = allow;\r\n  }\r\n\r\n  /**\r\n   * @notice Destructs the contract and sends remaining `this.balance` Ether to `beneficiary`\r\n   *\r\n   * @param beneficiary Beneficiary of remaining Ether on contract\r\n   */\r\n  function voteSuicide(address beneficiary) multisig(sha3(msg.data)) {\r\n    selfdestruct(beneficiary);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets frozen to `freeze` for account `target`\r\n   *\r\n   * @param addr Address to be frozen/unfrozen\r\n   * @param freeze Freeze/unfreeze account\r\n   */\r\n  function freezeAccount(address addr, bool freeze) multisig(sha3(msg.data)) {\r\n    frozenAccount[addr] = freeze;\r\n    activateAccount(addr);\r\n  }\r\n\r\n  /**\r\n   * @notice Seizes `seizeAmount` of tokens from `address` and transfers it to hotwallet\r\n   *\r\n   * @param addr Adress to seize tokens from\r\n   * @param amount Amount of tokens to seize\r\n   */\r\n  function seizeTokens(address addr, uint256 amount) multisig(sha3(msg.data)) {\r\n    assert(balanceOf[addr] >= amount);\r\n    assert(frozenAccount[addr]);\r\n    activateAccount(addr);\r\n    balanceOf[addr] -= amount;\r\n    balanceOf[hotWalletAddress] += amount;\r\n  }\r\n\r\n  /* ---------------  overseer methods for emergency --------------*/\r\n\r\n  /**\r\n   * @notice Shuts down all transaction and approval options on the asset contract\r\n   */\r\n  function shutdownTransactions() onlyOverseer {\r\n    allowTransactions = false;\r\n    TransactionsShutDown(msg.sender);\r\n  }\r\n\r\n  /* ---------------  helper methods for siphoning --------------*/\r\n\r\n  function extractAccountAllowanceRecordLength(address addr) returns (uint256 len) {\r\n    return allowanceIndex[addr].length;\r\n  }\r\n\r\n  function extractAccountLength() returns (uint256 length) {\r\n    return accountIndex.length;\r\n  }\r\n\r\n\r\n  /* ---------------  private methods --------------*/\r\n\r\n  function activateAccount(address addr) internal {\r\n    if (!accountActive[addr]) {\r\n      accountActive[addr] = true;\r\n      accountIndex.push(addr);\r\n    }\r\n  }\r\n\r\n  function activateAllowanceRecord(address from, address to) internal {\r\n    if (!allowanceActive[from][to]) {\r\n      allowanceActive[from][to] = true;\r\n      allowanceIndex[from].push(to);\r\n    }\r\n  }\r\n  function feeFor(address a, address b, uint256 amount) returns (uint256 value) {\r\n    if (membershipAddress == address(0x0)) return 0;\r\n    return DVIP(membershipAddress).feeFor(a, b, amount);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DCAssetFacade, Facade for the underlying back-end dcasset token contract. Allow to be updated later.\r\n *\r\n * @author P.S.D. Reitsma, peter@decentralizedcapital.com\r\n *\r\n */\r\ncontract DCAsset is TokenBase, StateTransferrable, TrustClient, Relay {\r\n\r\n   address public backendContract;\r\n\r\n   /**\r\n    * Constructor\r\n    *\r\n    *\r\n    */\r\n   function DCAsset(address _backendContract) {\r\n     backendContract = _backendContract;\r\n   }\r\n\r\n   function standard() constant returns (bytes32 std) {\r\n     return DCAssetBackend(backendContract).standard();\r\n   }\r\n\r\n   function name() constant returns (bytes32 nm) {\r\n     return DCAssetBackend(backendContract).name();\r\n   }\r\n\r\n   function symbol() constant returns (bytes32 sym) {\r\n     return DCAssetBackend(backendContract).symbol();\r\n   }\r\n\r\n   function decimals() constant returns (uint8 precision) {\r\n     return DCAssetBackend(backendContract).decimals();\r\n   }\r\n  \r\n   function allowance(address from, address to) constant returns (uint256 res) {\r\n     return DCAssetBackend(backendContract).allowance(from, to);\r\n   }\r\n\r\n\r\n   /* ---------------  multisig admin methods  --------------*/\r\n\r\n\r\n   /**\r\n    * @notice Sets the backend contract to `_backendContract`. Can only be switched by multisig.\r\n    *\r\n    * @param _backendContract Address of the underlying token contract.\r\n    */\r\n   function setBackend(address _backendContract) multisig(sha3(msg.data)) {\r\n     backendContract = _backendContract;\r\n   }\r\n\r\n   /* ---------------  main token methods  --------------*/\r\n\r\n   /**\r\n    * @notice Returns the balance of `_address`.\r\n    *\r\n    * @param _address The address of the balance.\r\n    */\r\n   function balanceOf(address _address) constant returns (uint256 balance) {\r\n      return DCAssetBackend(backendContract).balanceOf(_address);\r\n   }\r\n\r\n   /**\r\n    * @notice Returns the total supply of the token\r\n    *\r\n    */\r\n   function totalSupply() constant returns (uint256 balance) {\r\n      return DCAssetBackend(backendContract).totalSupply();\r\n   }\r\n\r\n  /**\r\n   * @notice Transfer `_amount` to `_to`.\r\n   *\r\n   * @param _to Address that will receive.\r\n   * @param _amount Amount to be transferred.\r\n   */\r\n   function transfer(address _to, uint256 _amount) returns (bool success)  {\r\n      if (!DCAssetBackend(backendContract).transfer(msg.sender, _to, _amount)) throw;\r\n      Transfer(msg.sender, _to, _amount);\r\n      return true;\r\n   }\r\n\r\n  /**\r\n   * @notice Approve Approves spender `_spender` to transfer `_amount`.\r\n   *\r\n   * @param _spender Address that receives the cheque\r\n   * @param _amount Amount on the cheque\r\n   * @param _extraData Consequential contract to be executed by spender in same transcation.\r\n   * @return result of the method call\r\n   */\r\n   function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n      if (!DCAssetBackend(backendContract).approveAndCall(msg.sender, _spender, _amount, _extraData)) throw;\r\n      Approval(msg.sender, _spender, _amount);\r\n      return true;\r\n   }\r\n\r\n  /**\r\n   * @notice Approve Approves spender `_spender` to transfer `_amount`.\r\n   *\r\n   * @param _spender Address that receives the cheque\r\n   * @param _amount Amount on the cheque\r\n   * @return result of the method call\r\n   */\r\n   function approve(address _spender, uint256 _amount) returns (bool success) {\r\n      if (!DCAssetBackend(backendContract).approve(msg.sender, _spender, _amount)) throw;\r\n      Approval(msg.sender, _spender, _amount);\r\n      return true;\r\n   }\r\n\r\n  /**\r\n   * @notice Transfer `_amount` from `_from` to `_to`.\r\n   *\r\n   * @param _from Origin address\r\n   * @param _to Address that will receive\r\n   * @param _amount Amount to be transferred.\r\n   * @return result of the method call\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\r\n      if (!DCAssetBackend(backendContract).transferFrom(msg.sender, _from, _to, _amount)) throw;\r\n      Transfer(_from, _to, _amount);\r\n      return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns fee for transferral of `_amount` from `_from` to `_to`.\r\n   *\r\n   * @param _from Origin address\r\n   * @param _to Address that will receive\r\n   * @param _amount Amount to be transferred.\r\n   * @return height of the fee\r\n   */\r\n  function feeFor(address _from, address _to, uint256 _amount) returns (uint256 amount) {\r\n      return DCAssetBackend(backendContract).feeFor(_from, _to, _amount);\r\n  }\r\n\r\n  /* ---------------  to be called by backend  --------------*/\r\n\r\n  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\r\n     assert(msg.sender == backendContract);\r\n     TokenRecipient spender = TokenRecipient(_spender);\r\n     spender.receiveApproval(_caller, _amount, this, _extraData);\r\n     return true;\r\n  }\r\n\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"assertion\",\"type\":\"bool\"}],\"name\":\"assert\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"nm\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"nameFor\",\"outputs\":[{\"name\":\"name\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"precision\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"std\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trustAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"backendContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"out\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"sym\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowTransactions\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"feeFor\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_caller\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"relayReceiveApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_backendContract\",\"type\":\"address\"}],\"name\":\"setBackend\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setTrust\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"res\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancel\",\"outputs\":[{\"name\":\"status\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_backendContract\",\"type\":\"address\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"AuthInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"with\",\"type\":\"address\"}],\"name\":\"AuthComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"AuthPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"Unauthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"InitCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"NothingToCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"SetMasterKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"with\",\"type\":\"address\"}],\"name\":\"AuthCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"NameRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"PropertySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"type\":\"event\"}]", "ContractName": "DCAsset", "CompilerVersion": "v0.3.6+commit.3fc68da", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000815a46107e5ee2291a76274dc879ce947a3f0850", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}