{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Webstela.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NONE\\n\\npragma solidity ^0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\n/**\\n * @title Webstela\\n * @author Kang Myung-hun\\n */\\n\\ncontract Base {\\n    struct Token {\\n        address owner;\\n        address royaltyHolder;\\n        uint256 price;\\n        bytes32 hashed;    // SHA256\\n        bytes32 namespace; // UTF-8\\n        string  uri;\\n        mapping(bytes32 => bytes32) meta; // custom meta data\\n    }\\n\\n    struct MintFeeTable {\\n        uint256 on;      // permyriad\\n        uint256 royalty; // permyriad\\n    }\\n\\n    struct BuyFeeTable {\\n        uint256 fee;     // royalty + implicit contract owner commission\\n        uint256 royalty; // permyriad\\n    }\\n\\n    struct Transferring {\\n        address to;\\n        uint256 value;\\n    }\\n\\n    address internal _contractOwner; // contract owner\\n    address internal _manager;\\n\\n    string internal _name;\\n    string internal _symbol;\\n    string internal _baseURI;\\n\\n    uint256 internal _tokenIdCounter;\\n    MintFeeTable internal _mintFeeTable;\\n    BuyFeeTable internal _buyFeeTable;\\n\\n    mapping(uint256 => Token) internal _tokens;\\n    mapping(bytes32 => uint256) internal _hashedToTokenIds;\\n    mapping(address => uint256) internal _balances;\\n    mapping(address => uint256) internal _names;\\n    \\n    mapping(uint256 => address) internal _tokenApprovals;\\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\\n\\n    event Symbol(string indexed symbol);\\n    event ContractOwner(address indexed from, address indexed to);\\n    event Manager(address indexed from, address indexed to);\\n\\n    event MintFee(uint256 on, uint256 royalty);\\n    event BuyFee(uint256 fee, uint256 royalty);\\n\\n    event TokenURIBase(string uri);\\n\\n    event AccountName(address indexed owner, bytes32 indexed name);\\n    event Mint(uint256 indexed tokenId, bytes32 indexed hashed, bytes32 indexed on);\\n    event Buy(uint256 indexed tokenID, uint256 price);\\n    event TokenMeta(\\n        uint256 indexed tokenId,\\n        bytes32[] keys,\\n        bytes32[] values\\n    );\\n    event TokenNamespace(uint256 indexed tokenId, bytes32 indexed namespace);\\n    event TokenRoyaltyHolder(uint256 indexed tokenId, address indexed holder);\\n    event TokenPrice(uint256 indexed tokenId, uint256 to);\\n    event TokenURI(uint256 indexed tokenId, string uri);\\n\\n\\n    /* IERC721 */\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n\\n    /* Utils */\\n\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _isContract(address account) internal view returns (bool) {\\n        return account.code.length > 0;\\n    }\\n\\n    function _checkTokenOwner(address owner) internal view {\\n        require(owner == _msgSender(), \\\"caller is not the token owner\\\");\\n    }\\n\\n    function _transferEthers(address to, uint256 value) internal returns (uint256 refund) {\\n        if (to == address(0) || to == address(this) || to == _contractOwner) return 0;\\n        if (to == _msgSender()) return value;\\n        payable(to).transfer(value);\\n    }\\n\\n    function _transferEthers(Transferring memory a, Transferring memory b) internal returns (uint256 refund) {\\n        if (a.to == b.to) {\\n            return _transferEthers(a.to, a.value + b.value);\\n        }\\n        return _transferEthers(a.to, a.value) + _transferEthers(b.to, b.value);\\n    }\\n\\n    function _setTokenPrice(uint256 tokenId, Token storage token, uint256 to) internal {\\n        require(to <= 100_00 * to, \\\"too high price\\\");\\n        if (token.price == to) return;\\n\\n        token.price = to;\\n        emit TokenPrice(tokenId, to);\\n    }\\n}\\n\\ncontract Managed is Base {\\n    function contractOwner() public view returns (address) {\\n        return _contractOwner;\\n    }\\n\\n    function manager() public view returns (address) {\\n        return _manager;\\n    }\\n\\n    function setContractOwner(address to) public onlyContractOwner {\\n        require(to.balance > 0, \\\"invalid address\\\");\\n        withdraw();\\n\\n        address from = _contractOwner;\\n        _contractOwner = to;\\n        emit ContractOwner(from, to);\\n    }\\n\\n    function setManager(address to) public {\\n        require(\\n            _contractOwner == _msgSender() || _manager == _msgSender(),\\n            \\\"caller is not the contract owner or the manager\\\"\\n        );\\n        address from = _manager;\\n        _manager = to;\\n        emit Manager(from, to);\\n    }\\n\\n    function setTokenURIBase(string calldata baseURI) public onlyManager {\\n        _baseURI = baseURI;\\n        emit TokenURIBase(baseURI);\\n    }\\n\\n    function setMintFee(uint256 on, uint256 royalty) public onlyManager {\\n        require(100_00 > on + royalty, \\\"too low commission\\\");\\n\\n        _mintFeeTable.on = on;\\n        _mintFeeTable.royalty = royalty;\\n        // commission = 100_00 - on - royalty;\\n\\n        emit MintFee(on, royalty);\\n    }\\n\\n    function setBuyFee(uint256 fee, uint256 royalty) public onlyManager {\\n        require(100_00 > fee, \\\"too high fee\\\");\\n        require(fee > royalty, \\\"too low commission\\\");\\n\\n        _buyFeeTable.fee = fee;\\n        _buyFeeTable.royalty = royalty;\\n        // commission = fee - royalty;\\n\\n        emit BuyFee(fee, royalty);\\n    }\\n\\n    function withdraw() public {\\n        payable(_contractOwner).transfer(address(this).balance);\\n    }\\n\\n    function callFor(\\n        address to,\\n        uint256 value,\\n        uint256 gas,\\n        bytes calldata data\\n    ) public payable onlyContractOwner() returns (bool, bytes memory) {\\n        return to.call{value: value, gas: gas}(data);\\n    }\\n\\n    modifier onlyContractOwner() {\\n        require(_contractOwner == _msgSender(), \\\"caller is not the contract owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        require(_manager == _msgSender(), \\\"caller is not the manager\\\");\\n        _;\\n    }\\n}\\n\\ncontract ERCToken is Managed {\\n    using Strings for uint256;\\n\\n    function totalSupply() public view returns (uint256) {\\n        return _tokenIdCounter - 1;\\n    }\\n\\n\\n    /* IERC615 */\\n\\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165\\n            interfaceId == 0x80ac58cd || // ERC721\\n            interfaceId == 0x5b5e139f;   // ERC721Metadata\\n    }\\n\\n\\n    /* IERC721Metadata */\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\n        string memory uri = _tokens[tokenId].uri;\\n        if (bytes(uri).length > 0) {\\n            return uri;\\n        }\\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\\n    }\\n\\n    function setSymbol(string calldata to) external onlyManager() {\\n        _symbol = to;\\n        emit Symbol(to);\\n    }\\n\\n    function setTokenURI(uint256 tokenId, string calldata uri) external {\\n        Token storage token = _tokens[tokenId];\\n        _checkTokenOwner(token.owner);\\n\\n        token.uri = uri;\\n        emit TokenURI(tokenId, uri);\\n    }\\n\\n\\n    /* IERC721 */\\n\\n    function balanceOf(address owner) public view returns (uint256) {\\n        require(owner != address(0), \\\"address zero is not a valid owner\\\");\\n\\n        return _balances[owner];\\n    }\\n\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\n        address owner = _ownerOf(tokenId);\\n\\n        return owner;\\n    }\\n\\n    function approve(address to, uint256 tokenId) public {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"approval to current owner\\\");\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"approve caller is not the token owner or the approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId) public view returns (address) {\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"caller is not the token owner or the approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n        _setTokenPrice(tokenId, _tokens[tokenId], 0);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"caller is not the token owner or the approved\\\");\\n\\n        _safeTransfer(from, to, tokenId, data);\\n        _setTokenPrice(tokenId, _tokens[tokenId], 0);\\n    }\\n\\n\\n    /* Internal */\\n\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    function _ownerOf(uint256 tokenId) internal view returns (address) {\\n        return _tokens[tokenId].owner;\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        require(ownerOf(tokenId) == from, \\\"transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"transfer to the zero address\\\");\\n\\n        if (_tokenApprovals[tokenId] != address(0)) {\\n            delete _tokenApprovals[tokenId];\\n        }\\n\\n        unchecked {\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _tokens[tokenId].owner = to;\\n\\n        if (_names[from] == tokenId) {\\n            delete _names[from];\\n            emit AccountName(from, \\\"\\\");\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) internal {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal {\\n        require(owner != operator, \\\"approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal returns (bool) {\\n        if (_isContract(to)) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n}\\n\\ncontract HashableToken is ERCToken {\\n    function tokenIdOf(bytes32 hashed) public view returns (uint256) {\\n        return _hashedToTokenIds[hashed];\\n    }\\n\\n    function ownerOf(bytes32 hashed) public view returns (address) {\\n        return ownerOf(tokenIdOf(hashed));\\n    }\\n\\n    function hashOf(uint256 tokenId) public view returns (bytes32) {\\n        return _tokens[tokenId].hashed;\\n    }\\n\\n    function mintByManager(\\n        bytes32 hashed,\\n        bytes32 on,\\n        address creator,\\n        address to,\\n        uint256 price,\\n        uint256 nextPrice\\n    ) external payable onlyManager {\\n        require(to != address(0), \\\"invalid token owner\\\");\\n\\n        _mint(hashed, on, creator, to, price, nextPrice);\\n    }\\n\\n    function mintBatchByManager(\\n        bytes32[] calldata hashes,\\n        bytes32 on,\\n        address creator,\\n        address to,\\n        uint256 price,\\n        uint256[] calldata nextPrices\\n    ) external payable onlyManager {\\n        require(to != address(0), \\\"invalid token owner\\\");\\n\\n        _mintBatch(hashes, on, creator, to, price, nextPrices);\\n    }\\n\\n    function mint(\\n        bytes32 hashed,\\n        bytes32 on,\\n        address creator,\\n        uint256 price,\\n        uint256 nextPrice,\\n        uint256 discount,\\n        uint256 timeout,\\n        bytes calldata signature\\n    ) external payable {\\n        address to = _msgSender();\\n        bytes32 challenge = sha256(abi.encodePacked(hashed, on, creator, to, price, discount, timeout));\\n        _validateMinting(\\n            price,\\n            discount,\\n            timeout,\\n            challenge,\\n            signature\\n        );\\n\\n        _mint(hashed, on, creator, to, price, nextPrice);\\n    }\\n\\n    function mintBatch(\\n        bytes32[] calldata hashes,\\n        bytes32 on,\\n        address creator,\\n        uint256 price,\\n        uint256[] calldata nextPrices,\\n        uint256 discount,\\n        uint256 timeout,\\n        bytes calldata signature\\n    ) external payable {\\n        address to = _msgSender();\\n        bytes32 challenge = sha256(abi.encodePacked(hashes, on, creator, to, price, discount, timeout));\\n        _validateMinting(\\n            price,\\n            discount,\\n            timeout,\\n            challenge,\\n            signature\\n        );\\n\\n        _mintBatch(hashes, on, creator, to, price, nextPrices);\\n    }\\n\\n    function _validateMinting(\\n        uint256 price,\\n        uint256 discount,\\n        uint256 timeout,\\n        bytes32 challenge,\\n        bytes calldata signature\\n    ) private {\\n        require(timeout > block.timestamp, \\\"timed out\\\");\\n        require(msg.value >= price - discount, \\\"not enough ethers\\\");\\n        require(manager() == ECDSA.recover(\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", challenge)\\n            ),\\n            signature\\n        ), \\\"invalid signature\\\");\\n    }\\n\\n    function _mint(\\n        bytes32 hashed,\\n        bytes32 on,\\n        address creator,\\n        address to,\\n        uint256 price,\\n        uint256 nextPrice\\n    ) private {\\n        require(creator != address(0), \\\"invalid token creator\\\");\\n\\n        uint256 tokenId = _tokenIdCounter;\\n        _unsafeMint(tokenId, hashed, on, creator, to, price, nextPrice);\\n        _completeMint(on, creator, to, price, 1);\\n    }\\n\\n    function _mintBatch(\\n        bytes32[] calldata hashes,\\n        bytes32 on,\\n        address creator,\\n        address to,\\n        uint256 price,\\n        uint256[] calldata nextPrices\\n    ) private {\\n        require(creator != address(0), \\\"invalid token creator\\\");\\n\\n        uint256 len = hashes.length;\\n        require(len == nextPrices.length, \\\"invalid next prices\\\");\\n        for (uint256 i = 0; i < len; i++) {\\n            _unsafeMint(_tokenIdCounter + i, hashes[i], on, creator, to, price, nextPrices[i]);\\n        }\\n        _completeMint(on, creator, to, price, len);\\n    }\\n\\n    function _unsafeMint(\\n        uint256 tokenId,\\n        bytes32 hashed,\\n        bytes32 on,\\n        address creator,\\n        address to,\\n        uint256 price,\\n        uint256 nextPrice\\n    ) private {\\n        require(hashed != \\\"\\\", \\\"invalid hashed\\\");\\n        require(_hashedToTokenIds[hashed] == 0, \\\"already exists\\\");\\n\\n        emit Mint(tokenId, hashed, on);\\n        emit TokenRoyaltyHolder(tokenId, creator);\\n        emit TokenPrice(tokenId, price);\\n\\n        _hashedToTokenIds[hashed] = tokenId;\\n        Token storage token = _tokens[tokenId];\\n        token.owner = to;\\n        token.hashed = hashed;\\n        token.royaltyHolder = creator;\\n\\n        emit Buy(tokenId, price);\\n        emit Transfer(address(0), to, tokenId);\\n        _setTokenPrice(tokenId, token, nextPrice);\\n    }\\n\\n    function _completeMint(\\n        bytes32 on,\\n        address creator,\\n        address to,\\n        uint256 price,\\n        uint256 count\\n    ) private {\\n        unchecked {\\n            _tokenIdCounter += count;\\n            _balances[to] += count;\\n        }\\n\\n        _transferEthers(\\n            Transferring(creator, price * _mintFeeTable.royalty / 100_00),\\n            Transferring(ownerOf(on), price * _mintFeeTable.on / 100_00)\\n        );\\n    }\\n}\\n\\ncontract Webstela is HashableToken {\\n    constructor(address manager) {\\n        _contractOwner = msg.sender;\\n        _manager = manager;\\n\\n        _name = \\\"Webstela\\\";\\n        _symbol = \\\"WSTLA\\\";\\n        _baseURI = \\\"https://static.webstela.com/nft/\\\";\\n\\n        _tokenIdCounter = 1;\\n\\n        _mintFeeTable.on = 20_00;\\n        _mintFeeTable.royalty = 70_00;\\n        // 10% commission\\n\\n        _buyFeeTable.fee = 10_00;\\n        _buyFeeTable.royalty = 5_00;\\n        //  5% commission\\n\\n        emit Symbol(_symbol);\\n        emit ContractOwner(address(0), _contractOwner);\\n        emit Manager(address(0), _manager);\\n\\n        emit TokenURIBase(_baseURI);\\n        emit MintFee(\\n            _mintFeeTable.on,\\n            _mintFeeTable.royalty\\n        );\\n        emit BuyFee(_buyFeeTable.fee, _buyFeeTable.royalty);\\n    }\\n\\n    fallback() external payable {}\\n    receive() external payable {}\\n\\n\\n    /* Namespace */\\n\\n    /// @return namespace UTF-8\\n    function namespaceOf(uint256 tokenId) public view returns (bytes32) {\\n        return _tokens[tokenId].namespace;\\n    }\\n\\n    /// @return namespace UTF-8\\n    function nameOf(address owner) public view returns (bytes32) {\\n        return namespaceOf(_names[owner]);\\n    }\\n\\n    function setAccountName(uint256 tokenId) external {\\n        Token storage token = _tokens[tokenId];\\n        _checkTokenOwner(token.owner);\\n        require(token.namespace != \\\"\\\", \\\"invalid namespace\\\");\\n\\n        _names[token.owner] = tokenId;\\n        emit AccountName(token.owner, token.namespace);\\n    }\\n\\n    /// @param namespace UTF-8\\n    function setTokenNamespace(uint256 tokenId, bytes calldata namespace) public {\\n        for (uint i = 0; i < namespace.length; i++) {\\n            uint8 char = uint8(namespace[i]);\\n            require(\\n                (char > 47 && char < 58) ||\\n                (char > 96 && char < 123), \\\"invalid namespace - only lowercased alphanumeric\\\");\\n        }\\n        _unsafeSetTokenNamespace(tokenId, namespace);\\n    }\\n\\n    /// @param namespace UTF-8\\n    function unsafeSetTokenNamespace(uint256 tokenId, bytes calldata namespace) public onlyManager {\\n        _unsafeSetTokenNamespace(tokenId, namespace);\\n    }\\n\\n    function _unsafeSetTokenNamespace(uint256 tokenId, bytes calldata namespace) private {\\n        Token storage token = _tokens[tokenId];\\n\\n        require(namespace.length < 33, \\\"invalid namespace length\\\");\\n        require(token.hashed == sha256(namespace), \\\"invalid namespace hash\\\");\\n\\n        token.namespace = bytes32(namespace);\\n        emit TokenNamespace(tokenId, token.namespace);\\n    }\\n\\n\\n    /* Meta */\\n\\n    function valueOf(uint256 tokenId, bytes32 key) public view returns (bytes32) {\\n        return _tokens[tokenId].meta[key];\\n    }\\n\\n    function valueOf(bytes32 hashed, bytes32 key) public view returns (bytes32) {\\n        return valueOf(tokenIdOf(hashed), key);\\n    }\\n\\n    function setTokenMeta(uint256 tokenId, bytes32[] calldata keys, bytes32[] calldata values) external {\\n        Token storage token = _tokens[tokenId];\\n        _checkTokenOwner(token.owner);\\n        require(keys.length == values.length, \\\"invalid key value pairs\\\");\\n\\n        for (uint256 i = 0; i < keys.length; ++i) {\\n            token.meta[keys[i]] = values[i];\\n        }\\n        emit TokenMeta(tokenId, keys, values);\\n    }\\n\\n\\n    /* Account Migration */\\n\\n    function migrateAccount(address to, uint256[] calldata tokenIds) public {\\n        address from = _msgSender();\\n        uint256 balance = 0;\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            uint256 tokenId = tokenIds[i];\\n            Token storage token = _tokens[tokenId];\\n            if (from == token.royaltyHolder) {\\n                token.royaltyHolder = to;\\n                emit TokenRoyaltyHolder(tokenId, to);\\n            }\\n            if (from == token.owner) {\\n                token.owner = to;\\n                emit Transfer(from, to, tokenId);\\n                balance += 1;\\n            }\\n        }\\n        if (balance > 0) {\\n            _balances[from] -= balance;\\n            _balances[to] += balance;\\n        }\\n    }\\n\\n\\n    /* Market */\\n\\n    function royaltyHolderOf(uint256 tokenId) public view returns (address) {\\n        return _tokens[tokenId].royaltyHolder;\\n    }\\n\\n    function priceOf(uint256 tokenId) public view returns (uint256) {\\n        return _tokens[tokenId].price;\\n    }\\n\\n    function setTokenRoyaltyHolder(uint256 tokenId, address to) external {\\n        Token storage token = _tokens[tokenId];\\n        require(token.royaltyHolder == _msgSender(), \\\"caller is not the royalty holder\\\");\\n\\n        token.royaltyHolder = to;\\n        emit TokenRoyaltyHolder(tokenId, to);\\n    }\\n\\n    function setTokenPrice(uint256 tokenId, uint256 price) external {\\n        Token storage token = _tokens[tokenId];\\n        _checkTokenOwner(token.owner);\\n        _setTokenPrice(tokenId, token, price);\\n    }\\n\\n    function buyFor(uint256 tokenId, uint256 nextPrice, address _for) public payable {\\n        Token storage token = _tokens[tokenId];\\n\\n        address from = token.owner;\\n        uint256 price = token.price;\\n        require(price > 0, \\\"locked to sell\\\");\\n        require(msg.value >= price, \\\"not enough ethers\\\");\\n\\n        uint256 royalty = price * _buyFeeTable.royalty / 100_00;\\n        uint256 net = price * (100_00 - _buyFeeTable.fee) / 100_00;\\n\\n        emit Buy(tokenId, price);\\n        _transfer(from, _for, tokenId);\\n        _setTokenPrice(tokenId, token, nextPrice);\\n\\n        uint256 refund;\\n        if (msg.value > price) {\\n            refund = msg.value - price;\\n        }\\n        refund += _transferEthers(token.royaltyHolder, royalty);\\n        refund += _transferEthers(from, net);\\n        if (refund > 0) {\\n            payable(_msgSender()).transfer(refund);\\n        }\\n    }\\n\\n    function buy(uint256 tokenId, uint256 nextPrice) public payable {\\n       buyFor(tokenId, nextPrice, _msgSender()); \\n    }\\n\\n    function buyBatch(uint256[] calldata tokenIds, uint256[] calldata nextPrices) public payable {\\n        require(tokenIds.length == nextPrices.length, \\\"invalid arguments\\\");\\n\\n        address sender = _msgSender();\\n        address[] memory addresses = new address[](tokenIds.length * 2);\\n        uint256[] memory values = new uint256[](tokenIds.length * 2);\\n        uint256 total;\\n\\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\\n            uint256 tokenId = tokenIds[i];\\n\\n            Token storage token = _tokens[tokenId];\\n            uint256 price = token.price;\\n            require(price > 0, \\\"locked to sell\\\");\\n\\n            uint256 royalty = price * _buyFeeTable.royalty / 100_00;\\n            uint256 net = price * (100_00 - _buyFeeTable.fee) / 100_00;\\n\\n            _transferring(addresses, values, token.royaltyHolder, royalty);\\n            _transferring(addresses, values, token.owner, net);\\n            total += price;\\n\\n            emit Buy(tokenId, price);\\n            _transfer(token.owner, sender, tokenId);\\n            _setTokenPrice(tokenId, token, nextPrices[i]);\\n        }\\n\\n        require(msg.value >= total, \\\"not enough ethers\\\");\\n\\n        uint256 refund;\\n        if (msg.value > total) {\\n            refund = msg.value - total;\\n        }\\n        for (uint256 i = 0; i < addresses.length; ++i) {\\n            address to = addresses[i];\\n            if (to == address(0)) break;\\n            refund += _transferEthers(to, values[i]);\\n        }\\n        if (refund > 0) {\\n            payable(_msgSender()).transfer(refund);\\n        }\\n    }\\n\\n    function _transferring(\\n        address[] memory addresses,\\n        uint256[] memory values,\\n        address to,\\n        uint256 value\\n    ) private pure {\\n        uint256 idx;\\n        for (uint256 i = 0 ; i < addresses.length; i++) {\\n            if (addresses[i] == to) {\\n                idx = i;\\n                break;\\n            }\\n            if (addresses[i] == address(0)) {\\n                addresses[i] = to;\\n                idx = i;\\n                break;\\n            }\\n        }\\n        values[idx] += value;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"AccountName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royalty\",\"type\":\"uint256\"}],\"name\":\"BuyFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ContractOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Manager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hashed\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"on\",\"type\":\"bytes32\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"on\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royalty\",\"type\":\"uint256\"}],\"name\":\"MintFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"Symbol\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"keys\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"values\",\"type\":\"bytes32[]\"}],\"name\":\"TokenMeta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"namespace\",\"type\":\"bytes32\"}],\"name\":\"TokenNamespace\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"TokenPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"TokenRoyaltyHolder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"TokenURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"TokenURIBase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextPrice\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nextPrices\",\"type\":\"uint256[]\"}],\"name\":\"buyBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"buyFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"hashOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"migrateAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"on\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"on\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nextPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"mintBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"on\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nextPrices\",\"type\":\"uint256[]\"}],\"name\":\"mintBatchByManager\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"on\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextPrice\",\"type\":\"uint256\"}],\"name\":\"mintByManager\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nameOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"namespaceOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashed\",\"type\":\"bytes32\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"priceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"royaltyHolderOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"setAccountName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royalty\",\"type\":\"uint256\"}],\"name\":\"setBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"setContractOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"on\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royalty\",\"type\":\"uint256\"}],\"name\":\"setMintFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"to\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"keys\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"values\",\"type\":\"bytes32[]\"}],\"name\":\"setTokenMeta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"namespace\",\"type\":\"bytes\"}],\"name\":\"setTokenNamespace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"setTokenRoyaltyHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"setTokenURIBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashed\",\"type\":\"bytes32\"}],\"name\":\"tokenIdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"namespace\",\"type\":\"bytes\"}],\"name\":\"unsafeSetTokenNamespace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"valueOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"valueOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Webstela", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000039000e00965fdcad9492ed7e5545809196499caf", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}