{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@lambdalf-dev/ethereum-contracts/contracts/interfaces/IArrayErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IArrayErrors {\\r\\n  /**\\r\\n  * @dev Thrown when two related arrays have different lengths\\r\\n  */\\r\\n  error ARRAY_LENGTH_MISMATCH();\\r\\n}\\r\\n\"\r\n    },\r\n    \"@lambdalf-dev/ethereum-contracts/contracts/interfaces/IContractState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IContractState {\\r\\n  /**\\r\\n  * @dev Thrown when a function is called with the wrong contract state.\\r\\n  * \\r\\n  * @param currentState the current state of the contract\\r\\n  */\\r\\n  error ContractState_INCORRECT_STATE(uint8 currentState);\\r\\n  /**\\r\\n  * @dev Thrown when trying to set the contract state to an invalid value.\\r\\n  * \\r\\n  * @param invalidState the invalid contract state\\r\\n  */\\r\\n  error ContractState_INVALID_STATE(uint8 invalidState);\\r\\n\\r\\n  /**\\r\\n  * @dev Emitted when the sale state changes\\r\\n  * \\r\\n  * @param previousState the previous state of the contract\\r\\n  * @param newState the new state of the contract\\r\\n  */\\r\\n  event ContractStateChanged(uint8 indexed previousState, uint8 indexed newState);\\r\\n\\r\\n  /**\\r\\n  * @dev Returns the current contract state.\\r\\n  */\\r\\n  function getContractState() external view returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@lambdalf-dev/ethereum-contracts/contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n// import \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n* @dev Required interface of an ERC173 compliant contract, as defined in the\\r\\n* https://eips.ethereum.org/EIPS/eip-173[EIP].\\r\\n*/\\r\\ninterface IERC173 /* is IERC165 */ {\\r\\n  /**\\r\\n  * @dev This emits when ownership of a contract changes.\\r\\n  * \\r\\n  * @param previousOwner the previous contract owner\\r\\n  * @param newOwner the new contract owner\\r\\n  */\\r\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n  /**\\r\\n  * @notice Set the address of the new owner of the contract.\\r\\n  * @dev Set newOwner_ to address(0) to renounce any ownership.\\r\\n  */\\r\\n  function transferOwnership(address newOwner_) external; \\r\\n\\r\\n  /**\\r\\n  * @notice Returns the address of the owner.\\r\\n  */\\r\\n  function owner() external view returns(address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@lambdalf-dev/ethereum-contracts/contracts/interfaces/IERC173Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IERC173Errors {\\r\\n  /**\\r\\n  * @dev Thrown when `operator` is not the contract owner.\\r\\n  * \\r\\n  * @param operator address trying to use a function reserved to contract owner without authorization\\r\\n  */\\r\\n  error IERC173_NOT_OWNER(address operator);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@lambdalf-dev/ethereum-contracts/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n// import \\\"./IERC165.sol\\\";\\n\\n/**\\n* @title ERC-721 Non-Fungible Token Standard\\n* @dev See https://eips.ethereum.org/EIPS/eip-721\\n*  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\\n*/\\ninterface IERC721 /* is IERC165 */ {\\n  /**\\n  * @dev This emits when the approved address for an NFT is changed or reaffirmed.\\n  *   The zero address indicates there is no approved address.\\n  *   When a Transfer event emits, this also indicates that the approved address for that NFT (if any) is reset to none.\\n  * \\n  * @param owner address that owns the token\\n  * @param approved address that is allowed to manage the token\\n  * @param tokenId identifier of the token being approved\\n  */\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n  /**\\n  * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage all NFTs of the owner.\\n  * \\n  * @param owner address that owns the tokens\\n  * @param operator address that is allowed or not to manage the tokens\\n  * @param approved whether the operator is allowed or not\\n  */\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n  /**\\n  * @dev This emits when ownership of any NFT changes by any mechanism.\\n  *   This event emits when NFTs are created (`from` == 0) and destroyed (`to` == 0).\\n  *   Exception: during contract creation, any number of NFTs may be created and assigned without emitting Transfer.\\n  *   At the time of any transfer, the approved address for that NFT (if any) is reset to none.\\n  * \\n  * @param from address the token is being transferred from\\n  * @param to address the token is being transferred to\\n  * @param tokenId identifier of the token being transferred\\n  */\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n  /**\\n  * @notice Change or reaffirm the approved address for an NFT\\n  * @dev The zero address indicates there is no approved address.\\n  *   Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\\n  */\\n  function approve(address approved_, uint256 tokenId_) external;\\n  /**\\n  * @notice Transfers the ownership of an NFT from one address to another address\\n  * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\\n  *   Throws if `from_` is not the current owner.\\n  *   Throws if `to_` is the zero address.\\n  *   Throws if `tokenId_` is not a valid NFT.\\n  *   When transfer is complete, this function checks if `to_` is a smart contract (code size > 0).\\n  *   If so, it calls {onERC721Received} on `to_` and throws if the return value is not\\n  *   `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n  */\\n  function safeTransferFrom(address from_, address to_, uint256 tokenId_, bytes calldata data_) external;\\n  /**\\n  * @notice Transfers the ownership of an NFT from one address to another address\\n  * @dev This works identically to the other function with an extra data parameter,\\n  *   except this function just sets data to \\\"\\\".\\n  */\\n  function safeTransferFrom(address from_, address to_, uint256 tokenId_) external;\\n  /**\\n  * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of `msg.sender`'s assets.\\n  * @dev Emits the ApprovalForAll event. The contract MUST allow multiple operators per owner.\\n  */\\n  function setApprovalForAll(address operator_, bool approved_) external;\\n  /**\\n  * @notice Transfer ownership of an NFT.\\n  *   The caller is responsible to confirm that `to_` is capable of receiving nfts or\\n  *   else they may be permanently lost\\n  * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\\n  *   Throws if `from_` is not the current owner.\\n  *   Throws if `to_` is the zero address.\\n  *   Throws if `tokenId_` is not a valid NFT.\\n  */\\n  function transferFrom(address from_, address to_, uint256 tokenId_) external;\\n\\n  /**\\n  * @notice Count all NFTs assigned to an owner\\n  * @dev NFTs assigned to the zero address are considered invalid. Throws for queries about the zero address.\\n  */\\n  function balanceOf(address owner_) external view returns (uint256);\\n  /**\\n  * @notice Get the approved address for a single NFT\\n  * @dev Throws if `tokenId_` is not a valid NFT.\\n  */\\n  function getApproved(uint256 tokenId_) external view returns (address);\\n  /**\\n  * @notice Query if an address is an authorized operator for another address\\n  */\\n  function isApprovedForAll(address owner_, address operator_) external view returns (bool);\\n  /**\\n  * @notice Find the owner of an NFT\\n  * @dev NFTs assigned to zero address are considered invalid, and queries\\n  *  about them do throw.\\n  */\\n  function ownerOf(uint256 tokenId_) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@lambdalf-dev/ethereum-contracts/contracts/utils/ContractState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"../interfaces/IContractState.sol\\\";\\r\\n\\r\\nabstract contract ContractState is IContractState {\\r\\n  // Enum to represent the sale state, defaults to ``PAUSED``.\\r\\n  uint8 public constant PAUSED = 0;\\r\\n\\r\\n  // The current state of the contract\\r\\n  uint8 private _contractState;\\r\\n\\r\\n  // **************************************\\r\\n  // *****          MODIFIER          *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @dev Ensures that contract state is `expectedState_`.\\r\\n    * \\r\\n    * @param expectedState_ : the desirable contract state\\r\\n    */\\r\\n    modifier isState(uint8 expectedState_) {\\r\\n      if (_contractState != expectedState_) {\\r\\n        revert ContractState_INCORRECT_STATE(_contractState);\\r\\n      }\\r\\n      _;\\r\\n    }\\r\\n    /**\\r\\n    * @dev Ensures that contract state is not `unexpectedState_`.\\r\\n    * \\r\\n    * @param unexpectedState_ : the undesirable contract state\\r\\n    */\\r\\n    modifier isNotState(uint8 unexpectedState_) {\\r\\n      if (_contractState == unexpectedState_) {\\r\\n        revert ContractState_INCORRECT_STATE(_contractState);\\r\\n      }\\r\\n      _;\\r\\n    }\\r\\n  // **************************************\\r\\n\\r\\n  // **************************************\\r\\n  // *****          INTERNAL          *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @dev Internal function setting the contract state to `newState_`.\\r\\n    * \\r\\n    * Note: Contract state defaults to ``PAUSED``.\\r\\n    *   To maintain extendability, this value kept as uint8 instead of enum.\\r\\n    *   As a result, it is possible to set the state to an incorrect value.\\r\\n    *   To avoid issues, `newState_` should be validated before calling this function\\r\\n    */\\r\\n    function _setContractState(uint8 newState_) internal virtual {\\r\\n      uint8 _previousState_ = _contractState;\\r\\n      _contractState = newState_;\\r\\n      emit ContractStateChanged(_previousState_, newState_);\\r\\n    }\\r\\n  // **************************************\\r\\n\\r\\n  // **************************************\\r\\n  // *****            VIEW            *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @dev Returns the current contract state.\\r\\n    * \\r\\n    * @return uint8 : the current contract state\\r\\n    */\\r\\n    function getContractState() public virtual view override returns (uint8) {\\r\\n      return _contractState;\\r\\n    }\\r\\n  // **************************************\\r\\n}\\r\\n\"\r\n    },\r\n    \"@lambdalf-dev/ethereum-contracts/contracts/utils/ERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"../interfaces/IERC173.sol\\\";\\r\\nimport \\\"../interfaces/IERC173Errors.sol\\\";\\r\\n\\r\\n/**\\r\\n* @dev Contract module which provides a basic access control mechanism, where\\r\\n* there is an account (an owner) that can be granted exclusive access to\\r\\n* specific functions.\\r\\n*\\r\\n* By default, the owner account will be the one that deploys the contract. This\\r\\n* can later be changed with {transferOwnership}.\\r\\n*\\r\\n* This module is used through inheritance. It will make available the modifier\\r\\n* `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n* the owner.\\r\\n*/\\r\\nabstract contract ERC173 is IERC173, IERC173Errors {\\r\\n  // The owner of the contract\\r\\n  address private _owner;\\r\\n\\r\\n  // **************************************\\r\\n  // *****          MODIFIER          *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @dev Throws if called by any account other than the owner.\\r\\n    */\\r\\n    modifier onlyOwner() {\\r\\n      if (owner() != msg.sender) {\\r\\n        revert IERC173_NOT_OWNER(msg.sender);\\r\\n      }\\r\\n      _;\\r\\n    }\\r\\n  // **************************************\\r\\n\\r\\n  // **************************************\\r\\n  // *****          INTERNAL          *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @dev Sets the contract owner.\\r\\n    * \\r\\n    * Note: This function needs to be called in the contract constructor to initialize the contract owner, \\r\\n    * if it is not, then parts of the contract might be non functional\\r\\n    * \\r\\n    * @param owner_ : address that owns the contract\\r\\n    */\\r\\n    function _setOwner(address owner_) internal {\\r\\n      _owner = owner_;\\r\\n    }\\r\\n  // **************************************\\r\\n\\r\\n  // **************************************\\r\\n  // *****       CONTRACT OWNER       *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @dev Transfers ownership of the contract to `newOwner_`.\\r\\n    * \\r\\n    * @param newOwner_ : address of the new contract owner\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - Caller must be the contract owner.\\r\\n    */\\r\\n    function transferOwnership(address newOwner_) public virtual onlyOwner {\\r\\n      address _oldOwner_ = _owner;\\r\\n      _owner = newOwner_;\\r\\n      emit OwnershipTransferred(_oldOwner_, newOwner_);\\r\\n    }\\r\\n  // **************************************\\r\\n\\r\\n  // **************************************\\r\\n  // *****            VIEW            *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @dev Returns the address of the current contract owner.\\r\\n    * \\r\\n    * @return address : the current contract owner\\r\\n    */\\r\\n    function owner() public view virtual returns (address) {\\r\\n      return _owner;\\r\\n    }\\r\\n  // **************************************\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/NuCyberStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/**\\r\\n* Author: Lambdalf the White\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@lambdalf-dev/ethereum-contracts/contracts/interfaces/IArrayErrors.sol\\\";\\r\\nimport \\\"@lambdalf-dev/ethereum-contracts/contracts/utils/ContractState.sol\\\";\\r\\nimport \\\"@lambdalf-dev/ethereum-contracts/contracts/utils/ERC173.sol\\\";\\r\\nimport \\\"@lambdalf-dev/ethereum-contracts/contracts/interfaces/IERC721.sol\\\";\\r\\nimport { FxBaseRootTunnel } from \\\"fx-portal/contracts/tunnel/FxBaseRootTunnel.sol\\\";\\r\\n\\r\\n\\r\\ncontract NuCyberStaking is IArrayErrors, ContractState, ERC173, FxBaseRootTunnel {\\r\\n  // **************************************\\r\\n  // *****        CUSTOM TYPES        *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @dev A list of possible rarities for a token\\r\\n    */\\r\\n    enum Rarity {\\r\\n      NONE,\\r\\n      SMALL,\\r\\n      MEDIUM,\\r\\n      LARGE,\\r\\n      LUXURY,\\r\\n      PENTHOUSE\\r\\n    }\\r\\n    /**\\r\\n    * @dev A structure representing a signature proof to be decoded by the contract\\r\\n    */\\r\\n    struct Proof {\\r\\n      bytes32 r;\\r\\n      bytes32 s;\\r\\n      uint8   v;\\r\\n    }\\r\\n    /**\\r\\n    * @dev A structure representing a staked token\\r\\n    */\\r\\n    struct StakedToken {\\r\\n      uint256 tokenId;\\r\\n      address beneficiary;\\r\\n      uint128 timestamp;\\r\\n      // Rarity rarity;\\r\\n    }\\r\\n  // **************************************\\r\\n\\r\\n  // **************************************\\r\\n  // *****           ERRORS           *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @dev Thrown when user tries to stake a token with invalid rarity\\r\\n    * \\r\\n    * @param tokenId the token being staked\\r\\n    */\\r\\n    error NCS_INCORRECT_RARITY(uint256 tokenId);\\r\\n    /**\\r\\n    * @dev Thrown when user tries to unstake a token they don't own\\r\\n    * \\r\\n    * @param tokenId the token being unstaked\\r\\n    */\\r\\n    error NCS_TOKEN_NOT_OWNED(uint256 tokenId);\\r\\n    /**\\r\\n    * @dev Thrown when user tries to unstake a token that is not staked\\r\\n    * \\r\\n    * @param tokenId the token being unstaked\\r\\n    */\\r\\n    error NCS_TOKEN_NOT_STAKED(uint256 tokenId);\\r\\n    /**\\r\\n    * @dev Thrown when trying to stake while rewards are not set\\r\\n    */\\r\\n    error NCS_REWARDS_NOT_SET();\\r\\n  // **************************************\\r\\n\\r\\n  // **************************************\\r\\n  // *****           EVENTS           *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @dev Emitted when a user sets a beneficiary address\\r\\n    * \\r\\n    * @param tokenId the token being unstaked\\r\\n    * @param beneficiary the address benefitting from the token\\r\\n    */\\r\\n    event BenefitStarted(uint256 indexed tokenId, address indexed beneficiary);\\r\\n    /**\\r\\n    * @dev Emitted when a user sets a beneficiary address\\r\\n    * \\r\\n    * @param tokenId the token being unstaked\\r\\n    * @param beneficiary the address benefitting from the token\\r\\n    */\\r\\n    event BenefitEnded(uint256 indexed tokenId, address indexed beneficiary);\\r\\n  // **************************************\\r\\n\\r\\n  // **************************************\\r\\n  // *****    BYTECODE  VARIABLES     *****\\r\\n  // **************************************\\r\\n    uint8 public constant ACTIVE = 1;\\r\\n  // **************************************\\r\\n\\r\\n  // **************************************\\r\\n  // *****     STORAGE  VARIABLES     *****\\r\\n  // **************************************\\r\\n    IERC721 public nuCyber;\\r\\n    address private _adminSigner;\\r\\n    // TokenId mapped to rarity\\r\\n    mapping (uint256 => Rarity) public rarity;\\r\\n    // Wallet address mapped to list of token Ids\\r\\n    mapping (address => StakedToken[]) private _stakedTokens;\\r\\n    // Wallet address mapped to staking info\\r\\n    // mapping (address => StakingInfo) private _stakingInfo;\\r\\n    // Beneficiary wallet address mapped to list of token Ids\\r\\n    mapping (address => uint256[]) private _benefitTokens;\\r\\n    // Rarity mapped to reward rate\\r\\n    // mapping (Rarity => uint256) private _rewardRates;\\r\\n  // **************************************\\r\\n\\r\\n  constructor(address nucyberContractAddress_, address adminSigner_, address cpManager_, address fxRoot_)\\r\\n  FxBaseRootTunnel(cpManager_, fxRoot_) {\\r\\n    nuCyber = IERC721(nucyberContractAddress_);\\r\\n    _adminSigner = adminSigner_;\\r\\n    _setOwner(msg.sender);\\r\\n  }\\r\\n\\r\\n  // **************************************\\r\\n  // *****          INTERNAL          *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @dev Internal function returning the benefit balance of `account_`.\\r\\n    * \\r\\n    * @param account_ the beneficiary address\\r\\n    */\\r\\n    function _balanceOfBenefit(address account_) internal view returns (uint256) {\\r\\n      return _benefitTokens[account_].length;\\r\\n    }\\r\\n    /**\\r\\n    * @dev Internal function returning the staking balance of `account_`.\\r\\n    * \\r\\n    * @param account_ the beneficiary address\\r\\n    */\\r\\n    function _balanceOfStaked(address account_) internal view returns (uint256) {\\r\\n      return _stakedTokens[account_].length;\\r\\n    }\\r\\n    /**\\r\\n    * @dev Internal function that ends a benefit.\\r\\n    * \\r\\n    * @param beneficiary_ the beneficiary address\\r\\n    * @param tokenId_ the token being unstaked\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - Emits a {BenefitEnded} event\\r\\n    */\\r\\n    function _endBenefit(address beneficiary_, uint256 tokenId_) internal {\\r\\n      uint256 _last_ = _benefitTokens[beneficiary_].length;\\r\\n      uint256 _count_ = _last_;\\r\\n      bool _deleted_;\\r\\n      while(_count_ > 0) {\\r\\n        unchecked {\\r\\n          --_count_;\\r\\n        }\\r\\n        if (_benefitTokens[beneficiary_][_count_] == tokenId_) {\\r\\n          if (_count_ != _last_ - 1) {\\r\\n            _benefitTokens[beneficiary_][_count_] = _benefitTokens[beneficiary_][_last_ - 1];\\r\\n          }\\r\\n          _benefitTokens[beneficiary_].pop();\\r\\n          _deleted_ = true;\\r\\n        }\\r\\n      }\\r\\n      if(! _deleted_) {\\r\\n        revert NCS_TOKEN_NOT_OWNED(tokenId_);\\r\\n      }\\r\\n      emit BenefitEnded(tokenId_, beneficiary_);\\r\\n    }\\r\\n    /**\\r\\n    * @dev Internal function that returns a specific staked token and its index\\r\\n    * \\r\\n    * @param tokenOwner_ the token owner\\r\\n    * @param tokenId_ the token to find\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - `tokenOwner_` must own `tokenId_`\\r\\n    */\\r\\n    function _findToken(address tokenOwner_, uint256 tokenId_) internal view returns (StakedToken memory, uint256) {\\r\\n      if (rarity[tokenId_] == Rarity.NONE) {\\r\\n        revert NCS_TOKEN_NOT_STAKED(tokenId_);\\r\\n      }\\r\\n      uint256 _count_ = _stakedTokens[tokenOwner_].length;\\r\\n      while(_count_ > 0) {\\r\\n        unchecked {\\r\\n          --_count_;\\r\\n        }\\r\\n        if (_stakedTokens[tokenOwner_][_count_].tokenId == tokenId_) {\\r\\n          return (_stakedTokens[tokenOwner_][_count_], _count_);\\r\\n        }\\r\\n      }\\r\\n      revert NCS_TOKEN_NOT_OWNED(tokenId_);\\r\\n    }\\r\\n    /**\\r\\n    * @dev Internal function to process a message sent by the child contract on Polygon\\r\\n    * Note: In our situation, we do not expect to receive any message from the child contract.\\r\\n    * \\r\\n    * @param message the message sent by the child contract\\r\\n    */\\r\\n    function _processMessageFromChild(bytes memory message) internal override {\\r\\n      // We don't need a message from child\\r\\n    }\\r\\n    /**\\r\\n    * @dev Internal function to send a message to the child contract on Polygon\\r\\n    * \\r\\n    * @param sender_ the address staking or unstaking one or more token\\r\\n    * @param rarity_ the rarity of the token being staked or unstaked\\r\\n    * @param amount_ the number of token being staked or unstaked\\r\\n    * @param isStake_ whether the token are being staked or unstaked\\r\\n    */\\r\\n    function _sendMessage(address sender_, Rarity rarity_, uint16 amount_, bool isStake_) internal {\\r\\n      if (amount_ > 0) {\\r\\n        _sendMessageToChild(\\r\\n          abi.encode(sender_, rarity_, amount_, isStake_)\\r\\n        );\\r\\n      }\\r\\n    }\\r\\n    /**\\r\\n    * @dev Internal function that stakes `tokenId_` for `tokenOwner_`.\\r\\n    * \\r\\n    * @param tokenOwner_ the token owner\\r\\n    * @param tokenId_ the token being staked\\r\\n    * @param beneficiary_ an address that will benefit from the token being staked\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - `tokenOwner_` must own `tokenId_`\\r\\n    * - This contract must be allowed to transfer NuCyber tokens on behalf of `tokenOwner_`\\r\\n    * - Emits a {BenefitStarted} event if `beneficiary_` is not null\\r\\n    */\\r\\n    function _stakeToken(address tokenOwner_, uint256 tokenId_, address beneficiary_/*, Rarity rarity_*/) internal {\\r\\n      _stakedTokens[tokenOwner_].push(StakedToken(tokenId_, beneficiary_, uint128(block.timestamp)/*, rarity_*/));\\r\\n      if (beneficiary_ != address(0)) {\\r\\n        _benefitTokens[beneficiary_].push(tokenId_);\\r\\n        emit BenefitStarted(tokenId_, beneficiary_);\\r\\n      }\\r\\n      try nuCyber.transferFrom(tokenOwner_, address(this), tokenId_) {\\r\\n      }\\r\\n      catch Error(string memory reason) {\\r\\n        revert(reason);\\r\\n      }\\r\\n    }\\r\\n    /**\\r\\n    * @dev Internal function that unstakes `tokenId_` for `tokenOwner_`.\\r\\n    * \\r\\n    * @param tokenOwner_ the token owner\\r\\n    * @param tokenId_ the token being unstaked\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - `tokenOwner_` must own `tokenId_`\\r\\n    * - Emits a {BenefitEnded} event if `tokenId_` had a beneficiary\\r\\n    */\\r\\n    function _unstakeToken(address tokenOwner_, uint256 tokenId_) internal {\\r\\n      uint256 _last_ = _stakedTokens[tokenOwner_].length;\\r\\n      uint256 _count_ = _last_;\\r\\n      bool _deleted_;\\r\\n      while(_count_ > 0) {\\r\\n        unchecked {\\r\\n          --_count_;\\r\\n        }\\r\\n        if (_stakedTokens[tokenOwner_][_count_].tokenId == tokenId_) {\\r\\n          address _beneficiary_ = _stakedTokens[tokenOwner_][_count_].beneficiary;\\r\\n          if(_beneficiary_ != address(0)) {\\r\\n            _endBenefit(_beneficiary_, tokenId_);\\r\\n          }\\r\\n          if (_count_ != _last_ - 1) {\\r\\n            _stakedTokens[tokenOwner_][_count_] = _stakedTokens[tokenOwner_][_last_ - 1];\\r\\n          }\\r\\n          _stakedTokens[tokenOwner_].pop();\\r\\n          _deleted_ = true;\\r\\n        }\\r\\n      }\\r\\n      if(! _deleted_) {\\r\\n        revert NCS_TOKEN_NOT_OWNED(tokenId_);\\r\\n      }\\r\\n      try nuCyber.transferFrom(address(this), tokenOwner_, tokenId_) {\\r\\n      }\\r\\n      catch Error(string memory reason) {\\r\\n        revert(reason);\\r\\n      }\\r\\n    }\\r\\n    /**\\r\\n    * @dev Internal function to decode a signature and compare it with the `_adminSigner`.\\r\\n    * \\r\\n    * @param tokenId_ the identifier of the token\\r\\n    * @param rarityLevel_ the rarity level to validate\\r\\n    * @param proof_ the signature proof to validate whitelist allocation\\r\\n    * \\r\\n    * @return bool whether the signature is valid or not\\r\\n    */ \\r\\n    function _validateProof(uint256 tokenId_, uint8 rarityLevel_, Proof memory proof_) private view returns (bool) {\\r\\n      bytes32 _digest_ = keccak256(abi.encode(tokenId_, rarityLevel_));\\r\\n      address _signer_ = ecrecover(_digest_, proof_.v, proof_.r, proof_.s);\\r\\n      return _signer_ == _adminSigner;\\r\\n    }\\r\\n  // **************************************\\r\\n\\r\\n  // **************************************\\r\\n  // *****           PUBLIC           *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @notice Stakes a batch of NuCyber at once.\\r\\n    * \\r\\n    * @param tokenIds_ the tokens being staked\\r\\n    * @param beneficiaries_ a list of addresses that will benefit from the tokens being staked\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - Caller must own all of `tokenIds_`\\r\\n    * - Emits one or more {BenefitStarted} events if `beneficiaries_` is not null\\r\\n    * - This contract must be allowed to transfer NuCyber tokens on behalf of the caller\\r\\n    */\\r\\n    function bulkStake(\\r\\n      uint256[] memory tokenIds_,\\r\\n      address[] memory beneficiaries_,\\r\\n      Rarity[] memory rarities_,\\r\\n      Proof[] memory proofs_\\r\\n    ) public isState(ACTIVE) {\\r\\n      if (fxChildTunnel == address(0)) {\\r\\n        revert NCS_REWARDS_NOT_SET();\\r\\n      }\\r\\n      uint256 _len_ = tokenIds_.length;\\r\\n      if (beneficiaries_.length != _len_ ||\\r\\n          rarities_.length != _len_ ||\\r\\n          proofs_.length != _len_) {\\r\\n        revert ARRAY_LENGTH_MISMATCH();\\r\\n      }\\r\\n      uint16[] memory _amounts_ = new uint16[](uint8(Rarity.PENTHOUSE));\\r\\n      while (_len_ > 0) {\\r\\n        unchecked {\\r\\n          --_len_;\\r\\n        }\\r\\n        Rarity _knownRarity_ = rarity[tokenIds_[_len_]];\\r\\n        if (_knownRarity_ == Rarity.NONE) {\\r\\n          if (!_validateProof(tokenIds_[_len_], uint8(rarities_[_len_]), proofs_[_len_])) {\\r\\n            revert NCS_INCORRECT_RARITY(tokenIds_[_len_]);\\r\\n          }\\r\\n          rarity[tokenIds_[_len_]] = rarities_[_len_];\\r\\n          _knownRarity_ = rarities_[_len_];\\r\\n        }\\r\\n        unchecked {\\r\\n          ++_amounts_[uint8(_knownRarity_) - 1];\\r\\n        }\\r\\n        _stakeToken(msg.sender, tokenIds_[_len_], beneficiaries_[_len_]/*, rarities_[_len_]*/);\\r\\n      }\\r\\n      _sendMessage(msg.sender, Rarity.SMALL, _amounts_[uint8(Rarity.SMALL) - 1], true);\\r\\n      _sendMessage(msg.sender, Rarity.MEDIUM, _amounts_[uint8(Rarity.MEDIUM) - 1], true);\\r\\n      _sendMessage(msg.sender, Rarity.LARGE, _amounts_[uint8(Rarity.LARGE) - 1], true);\\r\\n      _sendMessage(msg.sender, Rarity.LUXURY, _amounts_[uint8(Rarity.LUXURY) - 1], true);\\r\\n      _sendMessage(msg.sender, Rarity.PENTHOUSE, _amounts_[uint8(Rarity.PENTHOUSE) - 1], true);\\r\\n    }\\r\\n    /**\\r\\n    * @notice Unstakes a batch of NuCyber at once.\\r\\n    * \\r\\n    * @param tokenIds_ the tokens being unstaked\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - Caller must own all of `tokenIds_`\\r\\n    * - Emits one or more {BenefitEnded} events if `tokenIds_` had beneficiaries\\r\\n    */\\r\\n    function bulkUnstake(uint256[] calldata tokenIds_) public {\\r\\n      uint256 _len_ = tokenIds_.length;\\r\\n      uint16[] memory _amounts_ = new uint16[](uint8(Rarity.PENTHOUSE));\\r\\n      while (_len_ > 0) {\\r\\n        unchecked {\\r\\n          --_len_;\\r\\n        }\\r\\n        Rarity _knownRarity_ = rarity[tokenIds_[_len_]];\\r\\n        if (_knownRarity_ == Rarity.NONE) {\\r\\n          revert NCS_TOKEN_NOT_STAKED(tokenIds_[_len_]);\\r\\n        }\\r\\n        unchecked {\\r\\n          ++_amounts_[uint8(_knownRarity_) - 1];\\r\\n        }\\r\\n        _unstakeToken(msg.sender, tokenIds_[_len_]);\\r\\n      }\\r\\n      _sendMessage(msg.sender, Rarity.SMALL, _amounts_[uint8(Rarity.SMALL) - 1], false);\\r\\n      _sendMessage(msg.sender, Rarity.MEDIUM, _amounts_[uint8(Rarity.MEDIUM) - 1], false);\\r\\n      _sendMessage(msg.sender, Rarity.LARGE, _amounts_[uint8(Rarity.LARGE) - 1], false);\\r\\n      _sendMessage(msg.sender, Rarity.LUXURY, _amounts_[uint8(Rarity.LUXURY) - 1], false);\\r\\n      _sendMessage(msg.sender, Rarity.PENTHOUSE, _amounts_[uint8(Rarity.PENTHOUSE) - 1], false);\\r\\n    }\\r\\n    /**\\r\\n    * @notice Stakes a NuCyber token.\\r\\n    * \\r\\n    * @param tokenId_ the token being staked\\r\\n    * @param beneficiary_ an address that will benefit from the token being staked\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - Caller must own `tokenId_`\\r\\n    * - Emits a {BenefitStarted} event if `beneficiary_` is not null\\r\\n    * - This contract must be allowed to transfer NuCyber tokens on behalf of the caller\\r\\n    */\\r\\n    function stake(uint256 tokenId_, address beneficiary_, Rarity rarity_, Proof calldata proof_)\\r\\n    public\\r\\n    isState(ACTIVE) {\\r\\n      if (fxChildTunnel == address(0)) {\\r\\n        revert NCS_REWARDS_NOT_SET();\\r\\n      }\\r\\n      Rarity _knownRarity_ = rarity[tokenId_];\\r\\n      if (_knownRarity_ == Rarity.NONE) {\\r\\n        if (!_validateProof(tokenId_, uint8(rarity_), proof_)) {\\r\\n          revert NCS_INCORRECT_RARITY(tokenId_);\\r\\n        }\\r\\n        rarity[tokenId_] = rarity_;\\r\\n        _knownRarity_ = rarity_;\\r\\n      }\\r\\n      _stakeToken(msg.sender, tokenId_, beneficiary_/*, _knownRarity_*/);\\r\\n      _sendMessage(msg.sender, _knownRarity_, 1, true);\\r\\n    }\\r\\n    /**\\r\\n    * @notice Unstakes a NuCyber token.\\r\\n    * \\r\\n    * @param tokenId_ the token being unstaked\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - Caller must own `tokenId_`\\r\\n    * - Emits a {BenefitEnded} event if `tokenId_` had a beneficiary\\r\\n    */\\r\\n    function unstake(uint256 tokenId_) public {\\r\\n      Rarity _knownRarity_ = rarity[tokenId_];\\r\\n      if (_knownRarity_ == Rarity.NONE) {\\r\\n        revert NCS_TOKEN_NOT_STAKED(tokenId_);\\r\\n      }\\r\\n      _unstakeToken(msg.sender, tokenId_);\\r\\n      _sendMessage(msg.sender, _knownRarity_, 1, false);\\r\\n    }\\r\\n    /**\\r\\n    * @notice Updates the beneficiary of a staked token.\\r\\n    * \\r\\n    * @param tokenId_ the staked token\\r\\n    * @param newBeneficiary_ the address that will benefit from the staked token\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - Caller must own `tokenId_`\\r\\n    * - Emits a {BenefitEnded} event if `tokenId_` had a beneficiary\\r\\n    * - Emits a {BenefitStarted} event if `newBeneficiary_` is not null\\r\\n    */\\r\\n    function updateBeneficiary(uint256 tokenId_, address newBeneficiary_) public {\\r\\n      (StakedToken memory _stakedToken_, uint256 _index_) = _findToken(msg.sender, tokenId_);\\r\\n      _stakedTokens[msg.sender][_index_].beneficiary = newBeneficiary_;\\r\\n      if (_stakedToken_.beneficiary != address(0)) {\\r\\n        _endBenefit(_stakedToken_.beneficiary, tokenId_);\\r\\n      }\\r\\n      if (newBeneficiary_ != address(0)) {\\r\\n        _benefitTokens[newBeneficiary_].push(tokenId_);\\r\\n        emit BenefitStarted(tokenId_, newBeneficiary_);\\r\\n      }\\r\\n    }\\r\\n  // **************************************\\r\\n\\r\\n  // **************************************\\r\\n  // *****       CONTRACT OWNER       *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @notice Clears the saved rarity for a given token\\r\\n    * \\r\\n    * @param tokenId_ the token being cleared\\r\\n    */\\r\\n    function clearRarity(uint256 tokenId_) external onlyOwner {\\r\\n      rarity[tokenId_] = Rarity.NONE;\\r\\n    }\\r\\n    /**\\r\\n    * @notice Sets the NuCyber contract address\\r\\n    * \\r\\n    * @param contractAddress_ the address of the NuCyber contract\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - Caller must be the contract owner\\r\\n    */\\r\\n    function setNuCyberContract(address contractAddress_) external onlyOwner {\\r\\n      nuCyber = IERC721(contractAddress_);\\r\\n    }\\r\\n    /**\\r\\n    * @notice Updates the contract state.\\r\\n    * \\r\\n    * @param newState_ the new sale state\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - Caller must be the contract owner.\\r\\n    * - `newState_` must be a valid state.\\r\\n    */\\r\\n    function setContractState(uint8 newState_) external onlyOwner {\\r\\n      if (newState_ > ACTIVE) {\\r\\n        revert ContractState_INVALID_STATE(newState_);\\r\\n      }\\r\\n      _setContractState(newState_);\\r\\n    }\\r\\n    /**\\r\\n    * @notice Updates the child contract on Polygon\\r\\n    * \\r\\n    * @param fxChildTunnel_ the new child contract on Polygon\\r\\n    * \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - Caller must be the contract owner.\\r\\n    */\\r\\n    function updateFxChildTunnel(address fxChildTunnel_) external onlyOwner {\\r\\n      fxChildTunnel = fxChildTunnel_;\\r\\n    }\\r\\n    /**\\r\\n    * @notice Updates the whitelist signer.\\r\\n    * \\r\\n    * @param newAdminSigner_ the new whitelist signer\\r\\n    *  \\r\\n    * Requirements:\\r\\n    * \\r\\n    * - Caller must be the contract owner.\\r\\n    */\\r\\n    function setWhitelist(address newAdminSigner_) external onlyOwner {\\r\\n      _adminSigner = newAdminSigner_;\\r\\n    }\\r\\n  // **************************************\\r\\n\\r\\n  // **************************************\\r\\n  // *****            VIEW            *****\\r\\n  // **************************************\\r\\n    /**\\r\\n    * @notice Returns the number oof NuCyber staked and owned by `tokenOwner_`.\\r\\n    * Note: We need this function for collab.land to successfully give out token ownership roles\\r\\n    * \\r\\n    * @param tokenOwner_ address owning tokens\\r\\n    */\\r\\n    function balanceOf(address tokenOwner_) public view returns (uint256) {\\r\\n      return nuCyber.balanceOf(tokenOwner_) + _balanceOfStaked(tokenOwner_) + _balanceOfBenefit(tokenOwner_);\\r\\n    }\\r\\n    /**\\r\\n    * @notice Returns the benefit balance of `account_`.\\r\\n    * \\r\\n    * @param account_ the address to check\\r\\n    */\\r\\n    function balanceOfBenefit(address account_) external view returns (uint256) {\\r\\n      return _balanceOfBenefit(account_);\\r\\n    }\\r\\n    /**\\r\\n    * @notice Returns the staking balance of `account_`.\\r\\n    * \\r\\n    * @param account_ the address to check\\r\\n    */\\r\\n    function balanceOfStaked(address account_) external view returns (uint256) {\\r\\n      return _balanceOfStaked(account_);\\r\\n    }\\r\\n    /**\\r\\n    * @notice Returns the list of tokens owned by `tokenOwner_`.\\r\\n    * \\r\\n    * @param tokenOwner_ address owning tokens\\r\\n    */\\r\\n    function stakedTokens(address tokenOwner_) public view returns (StakedToken[] memory) {\\r\\n      return _stakedTokens[tokenOwner_];\\r\\n    }\\r\\n  // **************************************\\r\\n}\\r\\n\"\r\n    },\r\n    \"fx-portal/contracts/lib/ExitPayloadReader.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport { RLPReader } from \\\"./RLPReader.sol\\\";\\n\\nlibrary ExitPayloadReader {\\n  using RLPReader for bytes;\\n  using RLPReader for RLPReader.RLPItem;\\n\\n  uint8 constant WORD_SIZE = 32;\\n\\n  struct ExitPayload {\\n    RLPReader.RLPItem[] data;\\n  }\\n\\n  struct Receipt {\\n    RLPReader.RLPItem[] data;\\n    bytes raw;\\n    uint256 logIndex;\\n  }\\n\\n  struct Log {\\n    RLPReader.RLPItem data;\\n    RLPReader.RLPItem[] list;\\n  }\\n\\n  struct LogTopics {\\n    RLPReader.RLPItem[] data;\\n  }\\n\\n  // copy paste of private copy() from RLPReader to avoid changing of existing contracts\\n  function copy(uint src, uint dest, uint len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        // left over bytes. Mask is used to remove unwanted bytes from the word\\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n  function toExitPayload(bytes memory data)\\n        internal\\n        pure\\n        returns (ExitPayload memory)\\n    {\\n        RLPReader.RLPItem[] memory payloadData = data\\n            .toRlpItem()\\n            .toList();\\n\\n        return ExitPayload(payloadData);\\n    }\\n\\n    function getHeaderNumber(ExitPayload memory payload) internal pure returns(uint256) {\\n      return payload.data[0].toUint();\\n    }\\n\\n    function getBlockProof(ExitPayload memory payload) internal pure returns(bytes memory) {\\n      return payload.data[1].toBytes();\\n    }\\n\\n    function getBlockNumber(ExitPayload memory payload) internal pure returns(uint256) {\\n      return payload.data[2].toUint();\\n    }\\n\\n    function getBlockTime(ExitPayload memory payload) internal pure returns(uint256) {\\n      return payload.data[3].toUint();\\n    }\\n\\n    function getTxRoot(ExitPayload memory payload) internal pure returns(bytes32) {\\n      return bytes32(payload.data[4].toUint());\\n    }\\n\\n    function getReceiptRoot(ExitPayload memory payload) internal pure returns(bytes32) {\\n      return bytes32(payload.data[5].toUint());\\n    }\\n\\n    function getReceipt(ExitPayload memory payload) internal pure returns(Receipt memory receipt) {\\n      receipt.raw = payload.data[6].toBytes();\\n      RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\\n\\n      if (receiptItem.isList()) {\\n          // legacy tx\\n          receipt.data = receiptItem.toList();\\n      } else {\\n          // pop first byte before parsting receipt\\n          bytes memory typedBytes = receipt.raw;\\n          bytes memory result = new bytes(typedBytes.length - 1);\\n          uint256 srcPtr;\\n          uint256 destPtr;\\n          assembly {\\n              srcPtr := add(33, typedBytes)\\n              destPtr := add(0x20, result)\\n          }\\n\\n          copy(srcPtr, destPtr, result.length);\\n          receipt.data = result.toRlpItem().toList();\\n      }\\n\\n      receipt.logIndex = getReceiptLogIndex(payload);\\n      return receipt;\\n    }\\n\\n    function getReceiptProof(ExitPayload memory payload) internal pure returns(bytes memory) {\\n      return payload.data[7].toBytes();\\n    }\\n\\n    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns(bytes memory) {\\n      return payload.data[8].toBytes();\\n    }\\n\\n    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns(uint256) {\\n      return payload.data[8].toUint();\\n    }\\n\\n    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns(uint256) {\\n      return payload.data[9].toUint();\\n    }\\n    \\n    // Receipt methods\\n    function toBytes(Receipt memory receipt) internal pure returns(bytes memory) {\\n        return receipt.raw;\\n    }\\n\\n    function getLog(Receipt memory receipt) internal pure returns(Log memory) {\\n        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];\\n        return Log(logData, logData.toList());\\n    }\\n\\n    // Log methods\\n    function getEmitter(Log memory log) internal pure returns(address) {\\n      return RLPReader.toAddress(log.list[0]);\\n    }\\n\\n    function getTopics(Log memory log) internal pure returns(LogTopics memory) {\\n        return LogTopics(log.list[1].toList());\\n    }\\n\\n    function getData(Log memory log) internal pure returns(bytes memory) {\\n        return log.list[2].toBytes();\\n    }\\n\\n    function toRlpBytes(Log memory log) internal pure returns(bytes memory) {\\n      return log.data.toRlpBytes();\\n    }\\n\\n    // LogTopics methods\\n    function getField(LogTopics memory topics, uint256 index) internal pure returns(RLPReader.RLPItem memory) {\\n      return topics.data[index];\\n    }\\n}\\n\"\r\n    },\r\n    \"fx-portal/contracts/lib/Merkle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Merkle {\\n    function checkMembership(\\n        bytes32 leaf,\\n        uint256 index,\\n        bytes32 rootHash,\\n        bytes memory proof\\n    ) internal pure returns (bool) {\\n        require(proof.length % 32 == 0, \\\"Invalid proof length\\\");\\n        uint256 proofHeight = proof.length / 32;\\n        // Proof of size n means, height of the tree is n+1.\\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\\n        require(index < 2 ** proofHeight, \\\"Leaf index is too big\\\");\\n\\n        bytes32 proofElement;\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 32; i <= proof.length; i += 32) {\\n            assembly {\\n                proofElement := mload(add(proof, i))\\n            }\\n\\n            if (index % 2 == 0) {\\n                computedHash = keccak256(\\n                    abi.encodePacked(computedHash, proofElement)\\n                );\\n            } else {\\n                computedHash = keccak256(\\n                    abi.encodePacked(proofElement, computedHash)\\n                );\\n            }\\n\\n            index = index / 2;\\n        }\\n        return computedHash == rootHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"fx-portal/contracts/lib/MerklePatriciaProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {RLPReader} from \\\"./RLPReader.sol\\\";\\n\\nlibrary MerklePatriciaProof {\\n    /*\\n     * @dev Verifies a merkle patricia proof.\\n     * @param value The terminating value in the trie.\\n     * @param encodedPath The path in the trie leading to value.\\n     * @param rlpParentNodes The rlp encoded stack of nodes.\\n     * @param root The root hash of the trie.\\n     * @return The boolean validity of the proof.\\n     */\\n    function verify(\\n        bytes memory value,\\n        bytes memory encodedPath,\\n        bytes memory rlpParentNodes,\\n        bytes32 root\\n    ) internal pure returns (bool) {\\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\\n        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\\n\\n        bytes memory currentNode;\\n        RLPReader.RLPItem[] memory currentNodeList;\\n\\n        bytes32 nodeKey = root;\\n        uint256 pathPtr = 0;\\n\\n        bytes memory path = _getNibbleArray(encodedPath);\\n        if (path.length == 0) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < parentNodes.length; i++) {\\n            if (pathPtr > path.length) {\\n                return false;\\n            }\\n\\n            currentNode = RLPReader.toRlpBytes(parentNodes[i]);\\n            if (nodeKey != keccak256(currentNode)) {\\n                return false;\\n            }\\n            currentNodeList = RLPReader.toList(parentNodes[i]);\\n\\n            if (currentNodeList.length == 17) {\\n                if (pathPtr == path.length) {\\n                    if (\\n                        keccak256(RLPReader.toBytes(currentNodeList[16])) ==\\n                        keccak256(value)\\n                    ) {\\n                        return true;\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n\\n                uint8 nextPathNibble = uint8(path[pathPtr]);\\n                if (nextPathNibble > 16) {\\n                    return false;\\n                }\\n                nodeKey = bytes32(\\n                    RLPReader.toUintStrict(currentNodeList[nextPathNibble])\\n                );\\n                pathPtr += 1;\\n            } else if (currentNodeList.length == 2) {\\n                uint256 traversed = _nibblesToTraverse(\\n                    RLPReader.toBytes(currentNodeList[0]),\\n                    path,\\n                    pathPtr\\n                );\\n                if (pathPtr + traversed == path.length) {\\n                    //leaf node\\n                    if (\\n                        keccak256(RLPReader.toBytes(currentNodeList[1])) ==\\n                        keccak256(value)\\n                    ) {\\n                        return true;\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n\\n                //extension node\\n                if (traversed == 0) {\\n                    return false;\\n                }\\n\\n                pathPtr += traversed;\\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    function _nibblesToTraverse(\\n        bytes memory encodedPartialPath,\\n        bytes memory path,\\n        uint256 pathPtr\\n    ) private pure returns (uint256) {\\n        uint256 len = 0;\\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\\n        // and slicedPath have elements that are each one hex character (1 nibble)\\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\\n        bytes memory slicedPath = new bytes(partialPath.length);\\n\\n        // pathPtr counts nibbles in path\\n        // partialPath.length is a number of nibbles\\n        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\\n            bytes1 pathNibble = path[i];\\n            slicedPath[i - pathPtr] = pathNibble;\\n        }\\n\\n        if (keccak256(partialPath) == keccak256(slicedPath)) {\\n            len = partialPath.length;\\n        } else {\\n            len = 0;\\n        }\\n        return len;\\n    }\\n\\n    // bytes b must be hp encoded\\n    function _getNibbleArray(bytes memory b)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory nibbles = \\\"\\\";\\n        if (b.length > 0) {\\n            uint8 offset;\\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\\n            if (hpNibble == 1 || hpNibble == 3) {\\n                nibbles = new bytes(b.length * 2 - 1);\\n                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\\n                nibbles[0] = oddNibble;\\n                offset = 1;\\n            } else {\\n                nibbles = new bytes(b.length * 2 - 2);\\n                offset = 0;\\n            }\\n\\n            for (uint256 i = offset; i < nibbles.length; i++) {\\n                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\\n            }\\n        }\\n        return nibbles;\\n    }\\n\\n    function _getNthNibbleOfBytes(uint256 n, bytes memory str)\\n        private\\n        pure\\n        returns (bytes1)\\n    {\\n        return\\n            bytes1(\\n                n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10\\n            );\\n    }\\n}\"\r\n    },\r\n    \"fx-portal/contracts/lib/RLPReader.sol\": {\r\n      \"content\": \"/*\\n* @author Hamdi Allam hamdi.allam97@gmail.com\\n* Please reach out with any questions or concerns\\n*/\\npragma solidity ^0.8.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START  = 0xb8;\\n    uint8 constant LIST_SHORT_START   = 0xc0;\\n    uint8 constant LIST_LONG_START    = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint len;\\n        uint memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item;   // Item that's being iterated over.\\n        uint nextPtr;   // Position of the next item in the list.\\n    }\\n\\n    /*\\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n    * @param self The iterator.\\n    * @return The next element in the iteration.\\n    */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint ptr = self.nextPtr;\\n        uint itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n    * @dev Returns true if the iteration has more elements.\\n    * @param self The iterator.\\n    * @return true if the iteration has more elements.\\n    */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n    * @param item RLP encoded bytes\\n    */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n    * @dev Create an iterator. Reverts if item is not a list.\\n    * @param self The RLP item.\\n    * @return An 'Iterator' over the item.\\n    */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n    * @param item RLP encoded bytes\\n    */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\\n        return item.len;\\n    }\\n\\n    /*\\n    * @param item RLP encoded bytes\\n    */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\\n        return item.len - _payloadOffset(item.memPtr);\\n    }\\n\\n    /*\\n    * @param item RLP encoded list in bytes\\n    */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint dataLen;\\n        for (uint i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr); \\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START)\\n            return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint, uint) {\\n        uint offset = _payloadOffset(item.memPtr);\\n        uint memPtr = item.memPtr + offset;\\n        uint len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint memPtr, uint len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n        \\n        uint ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint result;\\n        uint memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        return result == 0 ? false : true;\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        uint offset = _payloadOffset(item.memPtr);\\n        uint len = item.len - offset;\\n\\n        uint result;\\n        uint memPtr = item.memPtr + offset;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shfit to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint result;\\n        uint memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        uint offset = _payloadOffset(item.memPtr);\\n        uint len = item.len - offset; // data length\\n        bytes memory result = new bytes(len);\\n\\n        uint destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr + offset, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n    * Private Helpers\\n    */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint) {\\n        if (item.len == 0) return 0;\\n\\n        uint count = 0;\\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n           count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint memPtr) private pure returns (uint) {\\n        uint itemLen;\\n        uint byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START)\\n            itemLen = 1;\\n        \\n        else if (byte0 < STRING_LONG_START)\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n\\n        else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } \\n\\n        else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\\n        uint byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) \\n            return 0;\\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\\n            return 1;\\n        else if (byte0 < LIST_SHORT_START)  // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        else\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n    }\\n\\n    /*\\n    * @param src Pointer to source\\n    * @param dest Pointer to destination\\n    * @param len Amount of memory to copy from the source\\n    */\\n    function copy(uint src, uint dest, uint len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len == 0) return;\\n\\n        // left over bytes. Mask is used to remove unwanted bytes from the word\\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\\n\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"fx-portal/contracts/tunnel/FxBaseRootTunnel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\nimport {RLPReader} from \\\"../lib/RLPReader.sol\\\";\\nimport {MerklePatriciaProof} from \\\"../lib/MerklePatriciaProof.sol\\\";\\nimport {Merkle} from \\\"../lib/Merkle.sol\\\";\\nimport \\\"../lib/ExitPayloadReader.sol\\\";\\n\\n\\ninterface IFxStateSender {\\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\\n}\\n\\ncontract ICheckpointManager {\\n    struct HeaderBlock {\\n        bytes32 root;\\n        uint256 start;\\n        uint256 end;\\n        uint256 createdAt;\\n        address proposer;\\n    }\\n\\n    /**\\n     * @notice mapping of checkpoint header numbers to block details\\n     * @dev These checkpoints are submited by plasma contracts\\n     */\\n    mapping(uint256 => HeaderBlock) public headerBlocks;\\n}\\n\\nabstract contract FxBaseRootTunnel {\\n    using RLPReader for RLPReader.RLPItem;\\n    using Merkle for bytes32;\\n    using ExitPayloadReader for bytes;\\n    using ExitPayloadReader for ExitPayloadReader.ExitPayload;\\n    using ExitPayloadReader for ExitPayloadReader.Log;\\n    using ExitPayloadReader for ExitPayloadReader.LogTopics;\\n    using ExitPayloadReader for ExitPayloadReader.Receipt;\\n\\n    // keccak256(MessageSent(bytes))\\n    bytes32 public constant SEND_MESSAGE_EVENT_SIG = 0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\\n\\n    // state sender contract\\n    IFxStateSender public fxRoot;\\n    // root chain manager\\n    ICheckpointManager public checkpointManager;\\n    // child tunnel contract which receives and sends messages \\n    address public fxChildTunnel;\\n\\n    // storage to avoid duplicate exits\\n    mapping(bytes32 => bool) public processedExits;\\n\\n    constructor(address _checkpointManager, address _fxRoot) {\\n        checkpointManager = ICheckpointManager(_checkpointManager);\\n        fxRoot = IFxStateSender(_fxRoot);\\n    }\\n\\n    // set fxChildTunnel if not set already\\n    function setFxChildTunnel(address _fxChildTunnel) public {\\n        require(fxChildTunnel == address(0x0), \\\"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\\\");\\n        fxChildTunnel = _fxChildTunnel;\\n    }\\n\\n    /**\\n     * @notice Send bytes message to Child Tunnel\\n     * @param message bytes message that will be sent to Child Tunnel\\n     * some message examples -\\n     *   abi.encode(tokenId);\\n     *   abi.encode(tokenId, tokenMetadata);\\n     *   abi.encode(messageType, messageData);\\n     */\\n    function _sendMessageToChild(bytes memory message) internal {\\n        fxRoot.sendMessageToChild(fxChildTunnel, message);\\n    }\\n\\n    function _validateAndExtractMessage(bytes memory inputData) internal returns (bytes memory) {\\n        ExitPayloadReader.ExitPayload memory payload = inputData.toExitPayload();\\n\\n        bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();\\n        uint256 blockNumber = payload.getBlockNumber();\\n        // checking if exit has already been processed\\n        // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\\n        bytes32 exitHash = keccak256(\\n            abi.encodePacked(\\n                blockNumber,\\n                // first 2 nibbles are dropped while generating nibble array\\n                // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\\n                // so converting to nibble array and then hashing it\\n                MerklePatriciaProof._getNibbleArray(branchMaskBytes),\\n                payload.getReceiptLogIndex()\\n            )\\n        );\\n        require(\\n            processedExits[exitHash] == false,\\n            \\\"FxRootTunnel: EXIT_ALREADY_PROCESSED\\\"\\n        );\\n        processedExits[exitHash] = true;\\n\\n        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();\\n        ExitPayloadReader.Log memory log = receipt.getLog();\\n\\n        // check child tunnel\\n        require(fxChildTunnel == log.getEmitter(), \\\"FxRootTunnel: INVALID_FX_CHILD_TUNNEL\\\");\\n\\n        bytes32 receiptRoot = payload.getReceiptRoot();\\n        // verify receipt inclusion\\n        require(\\n            MerklePatriciaProof.verify(\\n                receipt.toBytes(), \\n                branchMaskBytes, \\n                payload.getReceiptProof(), \\n                receiptRoot\\n            ),\\n            \\\"FxRootTunnel: INVALID_RECEIPT_PROOF\\\"\\n        );\\n\\n        // verify checkpoint inclusion\\n        _checkBlockMembershipInCheckpoint(\\n            blockNumber,\\n            payload.getBlockTime(),\\n            payload.getTxRoot(),\\n            receiptRoot,\\n            payload.getHeaderNumber(),\\n            payload.getBlockProof()\\n        );\\n\\n        ExitPayloadReader.LogTopics memory topics = log.getTopics();\\n\\n        require(\\n            bytes32(topics.getField(0).toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig\\n            \\\"FxRootTunnel: INVALID_SIGNATURE\\\"\\n        );\\n\\n        // received message data\\n        (bytes memory message) = abi.decode(log.getData(), (bytes)); // event decodes params again, so decoding bytes to get message\\n        return message;\\n    }\\n\\n    function _checkBlockMembershipInCheckpoint(\\n        uint256 blockNumber,\\n        uint256 blockTime,\\n        bytes32 txRoot,\\n        bytes32 receiptRoot,\\n        uint256 headerNumber,\\n        bytes memory blockProof\\n    ) private view returns (uint256) {\\n        (\\n            bytes32 headerRoot,\\n            uint256 startBlock,\\n            ,\\n            uint256 createdAt,\\n\\n        ) = checkpointManager.headerBlocks(headerNumber);\\n\\n        require(\\n            keccak256(\\n                abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)\\n            )\\n                .checkMembership(\\n                blockNumber-startBlock,\\n                headerRoot,\\n                blockProof\\n            ),\\n            \\\"FxRootTunnel: INVALID_HEADER\\\"\\n        );\\n        return createdAt;\\n    }\\n\\n    /**\\n     * @notice receive message from  L2 to L1, validated by proof\\n     * @dev This function verifies if the transaction actually happened on child chain\\n     *\\n     * @param inputData RLP encoded data of the reference tx containing following list of fields\\n     *  0 - headerNumber - Checkpoint header block number containing the reference tx\\n     *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\\n     *  2 - blockNumber - Block number containing the reference tx on child chain\\n     *  3 - blockTime - Reference tx block time\\n     *  4 - txRoot - Transactions root of block\\n     *  5 - receiptRoot - Receipts root of block\\n     *  6 - receipt - Receipt of the reference transaction\\n     *  7 - receiptProof - Merkle proof of the reference receipt\\n     *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\\n     *  9 - receiptLogIndex - Log Index to read from the receipt\\n     */\\n    function receiveMessage(bytes memory inputData) public virtual {\\n        bytes memory message = _validateAndExtractMessage(inputData);\\n        _processMessageFromChild(message);\\n    }\\n\\n    /**\\n     * @notice Process message received from Child Tunnel\\n     * @dev function needs to be implemented to handle message as per requirement\\n     * This is called by onStateReceive function.\\n     * Since it is called via a system call, any event will not be emitted during its execution.\\n     * @param message bytes message that was sent from Child Tunnel\\n     */\\n    function _processMessageFromChild(bytes memory message) virtual internal;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": false,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nucyberContractAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adminSigner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cpManager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fxRoot_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ARRAY_LENGTH_MISMATCH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"currentState\",\"type\":\"uint8\"}],\"name\":\"ContractState_INCORRECT_STATE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"invalidState\",\"type\":\"uint8\"}],\"name\":\"ContractState_INVALID_STATE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"IERC173_NOT_OWNER\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NCS_INCORRECT_RARITY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NCS_REWARDS_NOT_SET\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NCS_TOKEN_NOT_OWNED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NCS_TOKEN_NOT_STAKED\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"BenefitEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"BenefitStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"previousState\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"ContractStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ACTIVE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSED\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SEND_MESSAGE_EVENT_SIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"balanceOfBenefit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"balanceOfStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"beneficiaries_\",\"type\":\"address[]\"},{\"internalType\":\"enum NuCyberStaking.Rarity[]\",\"name\":\"rarities_\",\"type\":\"uint8[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NuCyberStaking.Proof[]\",\"name\":\"proofs_\",\"type\":\"tuple[]\"}],\"name\":\"bulkStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"bulkUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpointManager\",\"outputs\":[{\"internalType\":\"contract ICheckpointManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"clearRarity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxChildTunnel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxRoot\",\"outputs\":[{\"internalType\":\"contract IFxStateSender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractState\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nuCyber\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"processedExits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rarity\",\"outputs\":[{\"internalType\":\"enum NuCyberStaking.Rarity\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"inputData\",\"type\":\"bytes\"}],\"name\":\"receiveMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newState_\",\"type\":\"uint8\"}],\"name\":\"setContractState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fxChildTunnel\",\"type\":\"address\"}],\"name\":\"setFxChildTunnel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress_\",\"type\":\"address\"}],\"name\":\"setNuCyberContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdminSigner_\",\"type\":\"address\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary_\",\"type\":\"address\"},{\"internalType\":\"enum NuCyberStaking.Rarity\",\"name\":\"rarity_\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NuCyberStaking.Proof\",\"name\":\"proof_\",\"type\":\"tuple\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner_\",\"type\":\"address\"}],\"name\":\"stakedTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"timestamp\",\"type\":\"uint128\"}],\"internalType\":\"struct NuCyberStaking.StakedToken[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newBeneficiary_\",\"type\":\"address\"}],\"name\":\"updateBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fxChildTunnel_\",\"type\":\"address\"}],\"name\":\"updateFxChildTunnel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NuCyberStaking", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000e5c7d9a18df4fdc12db723761a862845612917ba000000000000000000000000b8a7c4ac16e2d77e99f39db9ae9ee08d7711301c00000000000000000000000086e4dc95c7fbdbf52e33d563bbdb00823894c287000000000000000000000000fe5e5d361b2ad62c541bab87c45a0b9b018389a2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}