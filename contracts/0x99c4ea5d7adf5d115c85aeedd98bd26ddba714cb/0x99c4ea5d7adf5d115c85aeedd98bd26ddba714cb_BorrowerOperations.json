{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BorrowerOperations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./Interfaces/IBorrowerOperations.sol\\\";\\nimport \\\"./Interfaces/ICdpManager.sol\\\";\\nimport \\\"./Interfaces/ICdpManagerData.sol\\\";\\nimport \\\"./Interfaces/IEBTCToken.sol\\\";\\nimport \\\"./Interfaces/ICollSurplusPool.sol\\\";\\nimport \\\"./Interfaces/ISortedCdps.sol\\\";\\nimport \\\"./Dependencies/EbtcBase.sol\\\";\\nimport \\\"./Dependencies/ReentrancyGuard.sol\\\";\\nimport \\\"./Dependencies/Ownable.sol\\\";\\nimport \\\"./Dependencies/AuthNoOwner.sol\\\";\\nimport \\\"./Dependencies/ERC3156FlashLender.sol\\\";\\nimport \\\"./Dependencies/PermitNonce.sol\\\";\\n\\n/// @title BorrowerOperations is mainly in charge of all end user interactions like Cdp open, adjust, close etc\\n/// @notice End users could approve delegate via IPositionManagers for authorized actions on their behalf\\n/// @dev BorrowerOperations also allows ERC3156 compatible flashmint of eBTC token\\ncontract BorrowerOperations is\\n    EbtcBase,\\n    ReentrancyGuard,\\n    IBorrowerOperations,\\n    ERC3156FlashLender,\\n    AuthNoOwner,\\n    PermitNonce\\n{\\n    string public constant NAME = \\\"BorrowerOperations\\\";\\n\\n    // keccak256(\\\"permitPositionManagerApproval(address borrower,address positionManager,uint8 status,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant _PERMIT_POSITION_MANAGER_TYPEHASH =\\n        keccak256(\\n            \\\"PermitPositionManagerApproval(address borrower,address positionManager,uint8 status,uint256 nonce,uint256 deadline)\\\"\\n        );\\n\\n    // keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n    bytes32 private constant _TYPE_HASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    string internal constant _VERSION = \\\"1\\\";\\n\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n\\n    // --- Connected contract declarations ---\\n\\n    ICdpManager public immutable cdpManager;\\n\\n    ICollSurplusPool public immutable collSurplusPool;\\n\\n    address public immutable feeRecipientAddress;\\n\\n    IEBTCToken public immutable ebtcToken;\\n\\n    // A doubly linked list of Cdps, sorted by their collateral ratios\\n    ISortedCdps public immutable sortedCdps;\\n\\n    // Mapping of borrowers to approved position managers, by approval status: cdpOwner(borrower) -> positionManager -> PositionManagerApproval (None, OneTime, Persistent)\\n    mapping(address => mapping(address => PositionManagerApproval)) public positionManagers;\\n\\n    /* --- Variable container structs  ---\\n\\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\\n    \\\"CompilerError: Stack too deep\\\". */\\n\\n    struct AdjustCdpLocals {\\n        uint256 price;\\n        uint256 collSharesChange;\\n        uint256 netDebtChange;\\n        bool isCollIncrease;\\n        uint256 debt;\\n        uint256 collShares;\\n        uint256 oldICR;\\n        uint256 newICR;\\n        uint256 newTCR;\\n        uint256 newDebt;\\n        uint256 newCollShares;\\n        uint256 stake;\\n    }\\n\\n    struct OpenCdpLocals {\\n        uint256 price;\\n        uint256 debt;\\n        uint256 netStEthBalance;\\n        uint256 ICR;\\n        uint256 NICR;\\n        uint256 stake;\\n    }\\n\\n    struct MoveTokensParams {\\n        address user;\\n        uint256 collSharesChange;\\n        uint256 collAddUnderlying; // ONLY for isCollIncrease=true\\n        bool isCollIncrease;\\n        uint256 netDebtChange;\\n        bool isDebtIncrease;\\n    }\\n\\n    // --- Dependency setters ---\\n    constructor(\\n        address _cdpManagerAddress,\\n        address _activePoolAddress,\\n        address _collSurplusPoolAddress,\\n        address _priceFeedAddress,\\n        address _sortedCdpsAddress,\\n        address _ebtcTokenAddress,\\n        address _feeRecipientAddress,\\n        address _collTokenAddress\\n    ) EbtcBase(_activePoolAddress, _priceFeedAddress, _collTokenAddress) {\\n        cdpManager = ICdpManager(_cdpManagerAddress);\\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\\n        sortedCdps = ISortedCdps(_sortedCdpsAddress);\\n        ebtcToken = IEBTCToken(_ebtcTokenAddress);\\n        feeRecipientAddress = _feeRecipientAddress;\\n\\n        address _authorityAddress = address(AuthNoOwner(_cdpManagerAddress).authority());\\n        if (_authorityAddress != address(0)) {\\n            _initializeAuthority(_authorityAddress);\\n        }\\n\\n        bytes32 hashedName = keccak256(bytes(NAME));\\n        bytes32 hashedVersion = keccak256(bytes(_VERSION));\\n\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = _chainID();\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);\\n    }\\n\\n    /**\\n        @notice BorrowerOperations and CdpManager share reentrancy status by confirming the other's locked flag before beginning operation\\n        @dev This is an alternative to the more heavyweight solution of both being able to set the reentrancy flag on a 3rd contract.\\n        @dev Prevents multi-contract reentrancy between these two contracts\\n     */\\n    modifier nonReentrantSelfAndCdpM() {\\n        require(locked == OPEN, \\\"BorrowerOperations: Reentrancy in nonReentrant call\\\");\\n        require(\\n            ReentrancyGuard(address(cdpManager)).locked() == OPEN,\\n            \\\"CdpManager: Reentrancy in nonReentrant call\\\"\\n        );\\n\\n        locked = LOCKED;\\n\\n        _;\\n\\n        locked = OPEN;\\n    }\\n\\n    // --- Borrower Cdp Operations ---\\n\\n    /// @notice Function that creates a Cdp for the caller with the requested debt, and the stETH received as collateral.\\n    /// @notice Successful execution is conditional mainly on the resulting collateralization ratio which must exceed minimum requirement, e.g., MCR.\\n    /// @notice Upon Cdp open, a separate gas stipend (denominated in stETH) will be allocated for possible liquidation.\\n    /// @param _debt The expected debt for this new Cdp\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _stEthBalance The total stETH collateral amount deposited for the specified Cdp\\n    /// @return The CdpId for this newly created Cdp\\n    function openCdp(\\n        uint256 _debt,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint256 _stEthBalance\\n    ) external override nonReentrantSelfAndCdpM returns (bytes32) {\\n        return _openCdp(_debt, _upperHint, _lowerHint, _stEthBalance, msg.sender);\\n    }\\n\\n    /// @notice Function that creates a Cdp for the specified _borrower by caller with the requested debt, and the stETH received as collateral.\\n    /// @dev Caller will need approval from _borrower via IPositionManagers if they are different address\\n    /// @notice Successful execution is conditional mainly on the resulting collateralization ratio which must exceed minimum requirement, e.g., MCR.\\n    /// @notice Upon Cdp open, a separate gas stipend (denominated in stETH) will be allocated for possible liquidation.\\n    /// @param _debt The expected debt for this new Cdp\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _stEthBalance The total stETH collateral amount deposited for the specified Cdp\\n    /// @param _borrower The Cdp owner for this new Cdp.\\n    /// @return The CdpId for this newly created Cdp\\n    function openCdpFor(\\n        uint256 _debt,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint256 _stEthBalance,\\n        address _borrower\\n    ) external override nonReentrantSelfAndCdpM returns (bytes32) {\\n        return _openCdp(_debt, _upperHint, _lowerHint, _stEthBalance, _borrower);\\n    }\\n\\n    /// @notice Function that adds the received stETH to the specified Cdp.\\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\\n    /// @param _cdpId The CdpId on which this operation is operated\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _stEthBalanceIncrease The total stETH collateral amount deposited (added) for the specified Cdp\\n    function addColl(\\n        bytes32 _cdpId,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint256 _stEthBalanceIncrease\\n    ) external override nonReentrantSelfAndCdpM {\\n        _adjustCdpInternal(_cdpId, 0, 0, false, _upperHint, _lowerHint, _stEthBalanceIncrease);\\n    }\\n\\n    /// @notice Function that withdraws `_stEthBalanceDecrease` amount of collateral from the specified Cdp\\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\\n    /// @notice Successful execution is conditional on whether the withdrawal would bring down the ICR or TCR to the minimum requirement, e.g., MCR or CCR\\n    /// @param _cdpId The CdpId on which this operation is operated\\n    /// @param _stEthBalanceDecrease The total stETH collateral amount withdrawn (reduced) for the specified Cdp\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\n    function withdrawColl(\\n        bytes32 _cdpId,\\n        uint256 _stEthBalanceDecrease,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint\\n    ) external override nonReentrantSelfAndCdpM {\\n        _adjustCdpInternal(_cdpId, _stEthBalanceDecrease, 0, false, _upperHint, _lowerHint, 0);\\n    }\\n\\n    /// @notice Function that withdraws `_debt` amount of eBTC token from the specified Cdp, thus increasing its debt accounting\\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\\n    /// @notice Successful execution is conditional on whether the withdrawal would bring down the ICR or TCR to the minimum requirement, e.g., MCR or CCR\\n    /// @param _cdpId The CdpId on which this operation is operated\\n    /// @param _debt The total debt collateral amount increased for the specified Cdp\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\n    function withdrawDebt(\\n        bytes32 _cdpId,\\n        uint256 _debt,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint\\n    ) external override nonReentrantSelfAndCdpM {\\n        _adjustCdpInternal(_cdpId, 0, _debt, true, _upperHint, _lowerHint, 0);\\n    }\\n\\n    /// @notice Function that repays the received eBTC token to the specified Cdp, thus reducing its debt accounting.\\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\\n    /// @param _cdpId The CdpId on which this operation is operated\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _debt The total eBTC debt amount repaid for the specified Cdp\\n    function repayDebt(\\n        bytes32 _cdpId,\\n        uint256 _debt,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint\\n    ) external override nonReentrantSelfAndCdpM {\\n        _adjustCdpInternal(_cdpId, 0, _debt, false, _upperHint, _lowerHint, 0);\\n    }\\n\\n    /// @notice Function that allows various operations which might change both collateral and debt\\n    /// @notice like taking more risky position (withdraws eBTC token and reduces stETH collateral)\\n    /// @notice or holding more safer position (repays eBTC token) with the specified Cdp.\\n    /// @notice If end user want to add collateral and change debt at the same time, use adjustCdpWithColl() instead\\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\\n    /// @param _cdpId The CdpId on which this operation is operated\\n    /// @param _stEthBalanceDecrease The total stETH collateral amount withdrawn from the specified Cdp\\n    /// @param _debtChange The total eBTC debt amount withdrawn or repaid for the specified Cdp\\n    /// @param _isDebtIncrease The flag (true or false) to indicate whether this is a eBTC token withdrawal (debt increase) or a repayment (debt reduce)\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\n    function adjustCdp(\\n        bytes32 _cdpId,\\n        uint256 _stEthBalanceDecrease,\\n        uint256 _debtChange,\\n        bool _isDebtIncrease,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint\\n    ) external override nonReentrantSelfAndCdpM {\\n        _adjustCdpInternal(\\n            _cdpId,\\n            _stEthBalanceDecrease,\\n            _debtChange,\\n            _isDebtIncrease,\\n            _upperHint,\\n            _lowerHint,\\n            0\\n        );\\n    }\\n\\n    /// @notice Function that allows various operations which might change both collateral and debt\\n    /// @notice like taking more risky position (withdraws eBTC token and reduces stETH collateral)\\n    /// @notice or holding more safer position (repays eBTC token and adds stETH collateral) with the specified Cdp.\\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\\n    /// @param _cdpId The CdpId on which this operation is operated\\n    /// @param _stEthBalanceDecrease The total stETH collateral amount withdrawn from the specified Cdp\\n    /// @param _debtChange The total eBTC debt amount withdrawn or repaid for the specified Cdp\\n    /// @param _isDebtIncrease The flag (true or false) to indicate whether this is a eBTC token withdrawal (debt increase) or a repayment (debt reduce)\\n    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)\\n    /// @param _stEthBalanceIncrease The total stETH collateral amount deposited (added) for the specified Cdp\\n    function adjustCdpWithColl(\\n        bytes32 _cdpId,\\n        uint256 _stEthBalanceDecrease,\\n        uint256 _debtChange,\\n        bool _isDebtIncrease,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint256 _stEthBalanceIncrease\\n    ) external override nonReentrantSelfAndCdpM {\\n        _adjustCdpInternal(\\n            _cdpId,\\n            _stEthBalanceDecrease,\\n            _debtChange,\\n            _isDebtIncrease,\\n            _upperHint,\\n            _lowerHint,\\n            _stEthBalanceIncrease\\n        );\\n    }\\n\\n    /*\\n     * _adjustCdpInternal(): Alongside a debt change, this function can perform either\\n     * a collateral top-up or a collateral withdrawal.\\n     *\\n     * It therefore expects either a positive _stEthBalanceIncrease, or a positive _stEthBalanceDecrease argument.\\n     *\\n     * If both are positive, it will revert.\\n     */\\n    function _adjustCdpInternal(\\n        bytes32 _cdpId,\\n        uint256 _stEthBalanceDecrease,\\n        uint256 _debtChange,\\n        bool _isDebtIncrease,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint256 _stEthBalanceIncrease\\n    ) internal {\\n        // Confirm the operation is the borrower or approved position manager adjusting its own cdp\\n        address _borrower = sortedCdps.getOwnerAddress(_cdpId);\\n        _requireBorrowerOrPositionManagerAndUpdateManagerApproval(_borrower);\\n\\n        _requireCdpisActive(cdpManager, _cdpId);\\n\\n        cdpManager.syncAccounting(_cdpId);\\n\\n        AdjustCdpLocals memory vars;\\n\\n        vars.price = priceFeed.fetchPrice();\\n\\n        if (_isDebtIncrease) {\\n            _requireMinDebtChange(_debtChange);\\n        } else {\\n            _requireZeroOrMinAdjustment(_debtChange);\\n        }\\n\\n        _requireSingularCollChange(_stEthBalanceIncrease, _stEthBalanceDecrease);\\n        _requireNonZeroAdjustment(_stEthBalanceIncrease, _stEthBalanceDecrease, _debtChange);\\n        _requireZeroOrMinAdjustment(_stEthBalanceIncrease);\\n        _requireZeroOrMinAdjustment(_stEthBalanceDecrease);\\n        // min debt adjustment checked above\\n\\n        // Get the collSharesChange based on the collateral value transferred in the transaction\\n        (vars.collSharesChange, vars.isCollIncrease) = _getCollSharesChangeFromStEthChange(\\n            _stEthBalanceIncrease,\\n            _stEthBalanceDecrease\\n        );\\n\\n        vars.netDebtChange = _debtChange;\\n\\n        vars.debt = cdpManager.getCdpDebt(_cdpId);\\n        vars.collShares = cdpManager.getCdpCollShares(_cdpId);\\n\\n        // Get the cdp's old ICR before the adjustment, and what its new ICR will be after the adjustment\\n        uint256 _cdpStEthBalance = collateral.getPooledEthByShares(vars.collShares);\\n        require(\\n            _stEthBalanceDecrease <= _cdpStEthBalance,\\n            \\\"BorrowerOperations: Cannot withdraw greater stEthBalance than the value in Cdp\\\"\\n        );\\n        vars.oldICR = EbtcMath._computeCR(_cdpStEthBalance, vars.debt, vars.price);\\n        vars.newICR = _getNewICRFromCdpChange(\\n            vars.collShares,\\n            vars.debt,\\n            vars.collSharesChange,\\n            vars.isCollIncrease,\\n            vars.netDebtChange,\\n            _isDebtIncrease,\\n            vars.price\\n        );\\n\\n        // Check the adjustment satisfies all conditions for the current system mode\\n        bool isRecoveryMode = _checkRecoveryModeForTCR(_getCachedTCR(vars.price));\\n        _requireValidAdjustmentInCurrentMode(\\n            isRecoveryMode,\\n            _stEthBalanceDecrease,\\n            _isDebtIncrease,\\n            vars\\n        );\\n\\n        // When the adjustment is a debt repayment, check it's a valid amount, that the caller has enough EBTC, and that the resulting debt is >0\\n        if (!_isDebtIncrease && _debtChange > 0) {\\n            _requireValidDebtRepayment(vars.debt, vars.netDebtChange);\\n            _requireSufficientEbtcTokenBalance(msg.sender, vars.netDebtChange);\\n            _requireMinDebt(vars.debt - vars.netDebtChange);\\n        }\\n\\n        (vars.newCollShares, vars.newDebt) = _getNewCdpAmounts(\\n            vars.collShares,\\n            vars.debt,\\n            vars.collSharesChange,\\n            vars.isCollIncrease,\\n            vars.netDebtChange,\\n            _isDebtIncrease\\n        );\\n\\n        _requireMinDebt(vars.newDebt);\\n        _requireAtLeastMinNetStEthBalance(collateral.getPooledEthByShares(vars.newCollShares));\\n\\n        cdpManager.updateCdp(\\n            _cdpId,\\n            _borrower,\\n            vars.collShares,\\n            vars.debt,\\n            vars.newCollShares,\\n            vars.newDebt\\n        );\\n\\n        // Re-insert cdp in to the sorted list\\n        {\\n            uint256 newNICR = _getNewNominalICRFromCdpChange(vars, _isDebtIncrease);\\n            sortedCdps.reInsert(_cdpId, newNICR, _upperHint, _lowerHint);\\n        }\\n\\n        // CEI: Process token movements\\n        {\\n            MoveTokensParams memory _varMvTokens = MoveTokensParams(\\n                msg.sender,\\n                vars.collSharesChange,\\n                (vars.isCollIncrease ? _stEthBalanceIncrease : 0),\\n                vars.isCollIncrease,\\n                _debtChange,\\n                _isDebtIncrease\\n            );\\n            _processTokenMovesFromAdjustment(_varMvTokens);\\n        }\\n    }\\n\\n    function _openCdp(\\n        uint256 _debt,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint256 _stEthBalance,\\n        address _borrower\\n    ) internal returns (bytes32) {\\n        _requireMinDebt(_debt);\\n        _requireBorrowerOrPositionManagerAndUpdateManagerApproval(_borrower);\\n\\n        OpenCdpLocals memory vars;\\n\\n        // ICR is based on the net stEth balance, i.e. the specified stEth balance amount - fixed liquidator incentive gas comp.\\n        vars.netStEthBalance = _calcNetStEthBalance(_stEthBalance);\\n\\n        _requireAtLeastMinNetStEthBalance(vars.netStEthBalance);\\n\\n        // Update global pending index before any operations\\n        cdpManager.syncGlobalAccounting();\\n\\n        vars.price = priceFeed.fetchPrice();\\n        vars.debt = _debt;\\n\\n        // Sanity check\\n        require(vars.netStEthBalance > 0, \\\"BorrowerOperations: zero collateral for openCdp()!\\\");\\n\\n        uint256 _netCollAsShares = collateral.getSharesByPooledEth(vars.netStEthBalance);\\n        uint256 _liquidatorRewardShares = collateral.getSharesByPooledEth(LIQUIDATOR_REWARD);\\n\\n        // ICR is based on the net coll, i.e. the requested coll amount - fixed liquidator incentive gas comp.\\n        vars.ICR = EbtcMath._computeCR(vars.netStEthBalance, vars.debt, vars.price);\\n\\n        // NICR uses shares to normalize NICR across Cdps opened at different pooled ETH / shares ratios\\n        vars.NICR = EbtcMath._computeNominalCR(_netCollAsShares, vars.debt);\\n\\n        /**\\n            In recovery move, ICR must be greater than CCR\\n            CCR > MCR (125% vs 110%)\\n\\n            In normal mode, ICR must be greater thatn MCR\\n            Additionally, the new system TCR after the Cdps addition must be >CCR\\n        */\\n        bool isRecoveryMode = _checkRecoveryModeForTCR(_getCachedTCR(vars.price));\\n        uint256 newTCR = _getNewTCRFromCdpChange(\\n            vars.netStEthBalance,\\n            true,\\n            vars.debt,\\n            true,\\n            vars.price\\n        );\\n        if (isRecoveryMode) {\\n            _requireICRisNotBelowCCR(vars.ICR);\\n\\n            // == Grace Period == //\\n            // We are in RM, Edge case is Depositing Coll could exit RM\\n            // We check with newTCR\\n            if (newTCR < CCR) {\\n                // Notify RM\\n                cdpManager.notifyStartGracePeriod(newTCR);\\n            } else {\\n                // Notify Back to Normal Mode\\n                cdpManager.notifyEndGracePeriod(newTCR);\\n            }\\n        } else {\\n            _requireICRisNotBelowMCR(vars.ICR);\\n            _requireNewTCRisNotBelowCCR(newTCR);\\n\\n            // == Grace Period == //\\n            // We are not in RM, no edge case, we always stay above RM\\n            // Always Notify Back to Normal Mode\\n            cdpManager.notifyEndGracePeriod(newTCR);\\n        }\\n\\n        // Set the cdp struct's properties\\n        bytes32 _cdpId = sortedCdps.insert(_borrower, vars.NICR, _upperHint, _lowerHint);\\n\\n        // Collision check: collisions should never occur\\n        // Explicitly prevent it by checking for `nonExistent`\\n        _requireCdpIsNonExistent(_cdpId);\\n\\n        // Collateral is stored in shares form for normalization\\n        cdpManager.initializeCdp(\\n            _cdpId,\\n            vars.debt,\\n            _netCollAsShares,\\n            _liquidatorRewardShares,\\n            _borrower\\n        );\\n\\n        // CEI: Mint the full debt amount, in eBTC tokens, to the caller\\n        _withdrawDebt(msg.sender, _debt);\\n\\n        /**\\n            Note that only NET stEth balance (as shares) is considered part of the Cdp.\\n            The static liqudiation incentive is stored in the gas pool and can be considered a deposit / voucher to be returned upon Cdp close, to the closer.\\n            The close can happen from the borrower closing their own Cdp, a full liquidation, or a redemption.\\n        */\\n\\n        // CEI: Move the collateral and liquidator gas compensation to the Active Pool. Track only net collateral for TCR purposes.\\n        _activePoolAddColl(_stEthBalance, _netCollAsShares);\\n\\n        // Invariant check\\n        require(\\n            vars.netStEthBalance + LIQUIDATOR_REWARD == _stEthBalance,\\n            \\\"BorrowerOperations: deposited collateral mismatch!\\\"\\n        );\\n\\n        return _cdpId;\\n    }\\n\\n    /// @notice Function that allows the caller to repay all debt, withdraw collateral, and close the specified Cdp\\n    /// @notice Caller should have enough eBTC token to repay off the debt fully for specified Cdp\\n    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call\\n    /// @param _cdpId The CdpId on which this operation is operated\\n    function closeCdp(bytes32 _cdpId) external override {\\n        address _borrower = sortedCdps.getOwnerAddress(_cdpId);\\n        _requireBorrowerOrPositionManagerAndUpdateManagerApproval(_borrower);\\n\\n        _requireCdpisActive(cdpManager, _cdpId);\\n\\n        cdpManager.syncAccounting(_cdpId);\\n\\n        uint256 price = priceFeed.fetchPrice();\\n        _requireNotInRecoveryMode(_getCachedTCR(price));\\n\\n        uint256 collShares = cdpManager.getCdpCollShares(_cdpId);\\n        uint256 debt = cdpManager.getCdpDebt(_cdpId);\\n        uint256 liquidatorRewardShares = cdpManager.getCdpLiquidatorRewardShares(_cdpId);\\n\\n        _requireSufficientEbtcTokenBalance(msg.sender, debt);\\n\\n        uint256 newTCR = _getNewTCRFromCdpChange(\\n            collateral.getPooledEthByShares(collShares),\\n            false,\\n            debt,\\n            false,\\n            price\\n        );\\n        _requireNewTCRisNotBelowCCR(newTCR);\\n\\n        // == Grace Period == //\\n        // By definition we are not in RM, notify CDPManager to ensure \\\"Glass is on\\\"\\n        cdpManager.notifyEndGracePeriod(newTCR);\\n\\n        cdpManager.closeCdp(_cdpId, _borrower, debt, collShares);\\n\\n        // Burn the repaid EBTC from the user's balance\\n        _repayDebt(msg.sender, debt);\\n\\n        // CEI: Send the collateral and liquidator reward shares back to the user\\n        activePool.transferSystemCollSharesAndLiquidatorReward(\\n            msg.sender,\\n            collShares,\\n            liquidatorRewardShares\\n        );\\n    }\\n\\n    /// @notice Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\\n    /// @notice when a Cdp has been fully redeemed from and closed, or liquidated in Recovery Mode with a collateralization ratio higher enough (like over MCR)\\n    /// @notice the borrower is allowed to claim their stETH collateral surplus that remains in the system if any\\n    function claimSurplusCollShares() external override {\\n        // send ETH from CollSurplus Pool to owner\\n        collSurplusPool.claimSurplusCollShares(msg.sender);\\n    }\\n\\n    /// @notice Returns true if the borrower is allowing position manager to act on their behalf\\n    /// @return PositionManagerApproval (None/OneTime/Persistent) status for given _borrower and _positionManager\\n    /// @param _borrower The Cdp owner who use eBTC\\n    /// @param _positionManager The position manager address in question whether it gets valid approval from _borrower\\n    function getPositionManagerApproval(\\n        address _borrower,\\n        address _positionManager\\n    ) external view override returns (PositionManagerApproval) {\\n        return _getPositionManagerApproval(_borrower, _positionManager);\\n    }\\n\\n    function _getPositionManagerApproval(\\n        address _borrower,\\n        address _positionManager\\n    ) internal view returns (PositionManagerApproval) {\\n        return positionManagers[_borrower][_positionManager];\\n    }\\n\\n    /// @notice Approve an account (_positionManager) to take arbitrary actions on your Cdps.\\n    /// @notice Position managers with 'Persistent' status will be able to take actions indefinitely\\n    /// @notice Position managers with 'OneTIme' status will be able to take a single action on one Cdp. Approval will be automatically revoked after one Cdp-related action.\\n    /// @notice Similar to approving tokens, approving a position manager allows _stealing of all positions_ if given to a malicious account.\\n    /// @param _positionManager The position manager address which will get the specified approval from caller\\n    /// @param _approval PositionManagerApproval (None/OneTime/Persistent) status set to the specified _positionManager for caller's Cdp\\n    function setPositionManagerApproval(\\n        address _positionManager,\\n        PositionManagerApproval _approval\\n    ) external override {\\n        _setPositionManagerApproval(msg.sender, _positionManager, _approval);\\n    }\\n\\n    function _setPositionManagerApproval(\\n        address _borrower,\\n        address _positionManager,\\n        PositionManagerApproval _approval\\n    ) internal {\\n        positionManagers[_borrower][_positionManager] = _approval;\\n        emit PositionManagerApprovalSet(_borrower, _positionManager, _approval);\\n    }\\n\\n    /// @notice Revoke a position manager from taking further actions on your Cdps\\n    /// @notice Similar to approving tokens, approving a position manager allows _stealing of all positions_ if given to a malicious account.\\n    /// @param _positionManager The position manager address which will get all approval revoked by caller (a Cdp owner)\\n    function revokePositionManagerApproval(address _positionManager) external override {\\n        _setPositionManagerApproval(msg.sender, _positionManager, PositionManagerApproval.None);\\n    }\\n\\n    /// @notice Allows recipient of delegation to renounce it\\n    /// @param _borrower The Cdp owner address which will have all approval to the caller (a PositionManager) revoked.\\n    function renouncePositionManagerApproval(address _borrower) external override {\\n        _setPositionManagerApproval(_borrower, msg.sender, PositionManagerApproval.None);\\n    }\\n\\n    /// @notice This function returns the domain separator for current chain\\n    /// @return EIP712 compatible Domain definition\\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\\n        return domainSeparator();\\n    }\\n\\n    /// @notice This function returns the domain separator for current chain\\n    /// @return EIP712 compatible Domain definition\\n    function domainSeparator() public view override returns (bytes32) {\\n        if (_chainID() == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _chainID() private view returns (uint256) {\\n        return block.chainid;\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 name,\\n        bytes32 version\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, name, version, _chainID(), address(this)));\\n    }\\n\\n    /// @notice This function returns the version parameter for the EIP712 domain\\n    /// @return EIP712 compatible version parameter\\n    function version() external pure override returns (string memory) {\\n        return _VERSION;\\n    }\\n\\n    /// @notice This function returns hash of the fully encoded EIP712 message for the permitPositionManagerApproval.\\n    /// @return EIP712 compatible hash of Positon Manager permit\\n    function permitTypeHash() external pure override returns (bytes32) {\\n        return _PERMIT_POSITION_MANAGER_TYPEHASH;\\n    }\\n\\n    /// @notice This function set given _approval for specified _borrower and _positionManager\\n    /// @notice by verifying the validity of given deadline and signature parameters (v, r, s).\\n    /// @param _borrower The Cdp owner\\n    /// @param _positionManager The delegate to which _borrower want to grant approval\\n    /// @param _approval The PositionManagerApproval (None/OneTime/Persistent) status to be set\\n    /// @param _deadline The permit valid deadline\\n    /// @param v The v part of signature from _borrower\\n    /// @param r The r part of signature from _borrower\\n    /// @param s The s part of signature from _borrower\\n    function permitPositionManagerApproval(\\n        address _borrower,\\n        address _positionManager,\\n        PositionManagerApproval _approval,\\n        uint256 _deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(_deadline >= block.timestamp, \\\"BorrowerOperations: Position manager permit expired\\\");\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                domainSeparator(),\\n                keccak256(\\n                    abi.encode(\\n                        _PERMIT_POSITION_MANAGER_TYPEHASH,\\n                        _borrower,\\n                        _positionManager,\\n                        _approval,\\n                        _nonces[_borrower]++,\\n                        _deadline\\n                    )\\n                )\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(\\n            recoveredAddress != address(0) && recoveredAddress == _borrower,\\n            \\\"BorrowerOperations: Invalid signature\\\"\\n        );\\n\\n        _setPositionManagerApproval(_borrower, _positionManager, _approval);\\n    }\\n\\n    // --- Helper functions ---\\n\\n    function _getCollSharesChangeFromStEthChange(\\n        uint256 _collReceived,\\n        uint256 _requestedCollWithdrawal\\n    ) internal view returns (uint256 collSharesChange, bool isCollIncrease) {\\n        if (_collReceived != 0) {\\n            collSharesChange = collateral.getSharesByPooledEth(_collReceived);\\n            isCollIncrease = true;\\n        } else {\\n            collSharesChange = collateral.getSharesByPooledEth(_requestedCollWithdrawal);\\n        }\\n    }\\n\\n    /**\\n        @notice Process the token movements required by a Cdp adjustment.\\n        @notice Handles the cases of a debt increase / decrease, and/or a collateral increase / decrease.\\n     */\\n    function _processTokenMovesFromAdjustment(MoveTokensParams memory _varMvTokens) internal {\\n        // Debt increase: mint change value of new eBTC to user, increment ActivePool eBTC internal accounting\\n        if (_varMvTokens.isDebtIncrease) {\\n            _withdrawDebt(_varMvTokens.user, _varMvTokens.netDebtChange);\\n        } else {\\n            // Debt decrease: burn change value of eBTC from user, decrement ActivePool eBTC internal accounting\\n            _repayDebt(_varMvTokens.user, _varMvTokens.netDebtChange);\\n        }\\n\\n        if (_varMvTokens.isCollIncrease) {\\n            // Coll increase: send change value of stETH to Active Pool, increment ActivePool stETH internal accounting\\n            _activePoolAddColl(_varMvTokens.collAddUnderlying, _varMvTokens.collSharesChange);\\n        } else {\\n            // Coll decrease: send change value of stETH to user, decrement ActivePool stETH internal accounting\\n            activePool.transferSystemCollShares(_varMvTokens.user, _varMvTokens.collSharesChange);\\n        }\\n    }\\n\\n    /// @notice Send stETH to Active Pool and increase its recorded ETH balance\\n    /// @param _stEthBalance total balance of stETH to send, inclusive of coll and liquidatorRewardShares\\n    /// @param _sharesToTrack coll as shares (exclsuive of liquidator reward shares)\\n    /// @dev Liquidator reward shares are not considered as part of the system for CR purposes.\\n    /// @dev These number of liquidator shares associated with each Cdp are stored in the Cdp, while the actual tokens float in the active pool\\n    function _activePoolAddColl(uint256 _stEthBalance, uint256 _sharesToTrack) internal {\\n        // NOTE: No need for safe transfer if the collateral asset is standard. Make sure this is the case!\\n        collateral.transferFrom(msg.sender, address(activePool), _stEthBalance);\\n        activePool.increaseSystemCollShares(_sharesToTrack);\\n    }\\n\\n    /// @dev Mint specified debt tokens to account and change global debt accounting accordingly\\n    function _withdrawDebt(address _account, uint256 _debt) internal {\\n        activePool.increaseSystemDebt(_debt);\\n        ebtcToken.mint(_account, _debt);\\n    }\\n\\n    // Burn the specified amount of EBTC from _account and decreases the total active debt\\n    function _repayDebt(address _account, uint256 _debt) internal {\\n        activePool.decreaseSystemDebt(_debt);\\n        ebtcToken.burn(_account, _debt);\\n    }\\n\\n    // --- 'Require' wrapper functions ---\\n\\n    function _requireSingularCollChange(\\n        uint256 _stEthBalanceIncrease,\\n        uint256 _stEthBalanceDecrease\\n    ) internal pure {\\n        require(\\n            _stEthBalanceIncrease == 0 || _stEthBalanceDecrease == 0,\\n            \\\"BorrowerOperations: Cannot add and withdraw collateral in same operation\\\"\\n        );\\n    }\\n\\n    function _requireNonZeroAdjustment(\\n        uint256 _stEthBalanceIncrease,\\n        uint256 _debtChange,\\n        uint256 _stEthBalanceDecrease\\n    ) internal pure {\\n        require(\\n            _stEthBalanceIncrease > 0 || _stEthBalanceDecrease > 0 || _debtChange > 0,\\n            \\\"BorrowerOperations: There must be either a collateral or debt change\\\"\\n        );\\n    }\\n\\n    function _requireZeroOrMinAdjustment(uint256 _change) internal pure {\\n        require(\\n            _change == 0 || _change >= MIN_CHANGE,\\n            \\\"BorrowerOperations: Collateral or debt change must be zero or above min\\\"\\n        );\\n    }\\n\\n    function _requireCdpisActive(ICdpManager _cdpManager, bytes32 _cdpId) internal view {\\n        uint256 status = _cdpManager.getCdpStatus(_cdpId);\\n        require(status == 1, \\\"BorrowerOperations: Cdp does not exist or is closed\\\");\\n    }\\n\\n    function _requireCdpIsNonExistent(bytes32 _cdpId) internal view {\\n        uint status = cdpManager.getCdpStatus(_cdpId);\\n        require(status == 0, \\\"BorrowerOperations: Cdp is active or has been previously closed\\\");\\n    }\\n\\n    function _requireMinDebtChange(uint _debtChange) internal pure {\\n        require(\\n            _debtChange >= MIN_CHANGE,\\n            \\\"BorrowerOperations: Debt increase requires min debtChange\\\"\\n        );\\n    }\\n\\n    function _requireNotInRecoveryMode(uint256 _tcr) internal view {\\n        require(\\n            !_checkRecoveryModeForTCR(_tcr),\\n            \\\"BorrowerOperations: Operation not permitted during Recovery Mode\\\"\\n        );\\n    }\\n\\n    function _requireNoStEthBalanceDecrease(uint256 _stEthBalanceDecrease) internal pure {\\n        require(\\n            _stEthBalanceDecrease == 0,\\n            \\\"BorrowerOperations: Collateral withdrawal not permitted during Recovery Mode\\\"\\n        );\\n    }\\n\\n    function _requireValidAdjustmentInCurrentMode(\\n        bool _isRecoveryMode,\\n        uint256 _stEthBalanceDecrease,\\n        bool _isDebtIncrease,\\n        AdjustCdpLocals memory _vars\\n    ) internal {\\n        /*\\n         *In Recovery Mode, only allow:\\n         *\\n         * - Pure collateral top-up\\n         * - Pure debt repayment\\n         * - Collateral top-up with debt repayment\\n         * - A debt increase combined with a collateral top-up which makes the\\n         * ICR >= 150% and improves the ICR (and by extension improves the TCR).\\n         *\\n         * In Normal Mode, ensure:\\n         *\\n         * - The new ICR is above MCR\\n         * - The adjustment won't pull the TCR below CCR\\n         */\\n\\n        _vars.newTCR = _getNewTCRFromCdpChange(\\n            collateral.getPooledEthByShares(_vars.collSharesChange),\\n            _vars.isCollIncrease,\\n            _vars.netDebtChange,\\n            _isDebtIncrease,\\n            _vars.price\\n        );\\n\\n        if (_isRecoveryMode) {\\n            _requireNoStEthBalanceDecrease(_stEthBalanceDecrease);\\n            if (_isDebtIncrease) {\\n                _requireICRisNotBelowCCR(_vars.newICR);\\n                _requireNoDecreaseOfICR(_vars.newICR, _vars.oldICR);\\n            }\\n\\n            // == Grace Period == //\\n            // We are in RM, Edge case is Depositing Coll could exit RM\\n            // We check with newTCR\\n            if (_vars.newTCR < CCR) {\\n                // Notify RM\\n                cdpManager.notifyStartGracePeriod(_vars.newTCR);\\n            } else {\\n                // Notify Back to Normal Mode\\n                cdpManager.notifyEndGracePeriod(_vars.newTCR);\\n            }\\n        } else {\\n            // if Normal Mode\\n            _requireICRisNotBelowMCR(_vars.newICR);\\n            _requireNewTCRisNotBelowCCR(_vars.newTCR);\\n\\n            // == Grace Period == //\\n            // We are not in RM, no edge case, we always stay above RM\\n            // Always Notify Back to Normal Mode\\n            cdpManager.notifyEndGracePeriod(_vars.newTCR);\\n        }\\n    }\\n\\n    function _requireICRisNotBelowMCR(uint256 _newICR) internal pure {\\n        require(\\n            _newICR >= MCR,\\n            \\\"BorrowerOperations: An operation that would result in ICR < MCR is not permitted\\\"\\n        );\\n    }\\n\\n    function _requireICRisNotBelowCCR(uint256 _newICR) internal pure {\\n        require(_newICR >= CCR, \\\"BorrowerOperations: Operation must leave cdp with ICR >= CCR\\\");\\n    }\\n\\n    function _requireNoDecreaseOfICR(uint256 _newICR, uint256 _oldICR) internal pure {\\n        require(\\n            _newICR >= _oldICR,\\n            \\\"BorrowerOperations: Cannot decrease your Cdp's ICR in Recovery Mode\\\"\\n        );\\n    }\\n\\n    function _requireNewTCRisNotBelowCCR(uint256 _newTCR) internal pure {\\n        require(\\n            _newTCR >= CCR,\\n            \\\"BorrowerOperations: An operation that would result in TCR < CCR is not permitted\\\"\\n        );\\n    }\\n\\n    function _requireMinDebt(uint256 _debt) internal pure {\\n        require(_debt >= MIN_CHANGE, \\\"BorrowerOperations: Debt must be above min\\\");\\n    }\\n\\n    function _requireAtLeastMinNetStEthBalance(uint256 _stEthBalance) internal pure {\\n        require(\\n            _stEthBalance >= MIN_NET_STETH_BALANCE,\\n            \\\"BorrowerOperations: Cdp's net stEth balance must not fall below minimum\\\"\\n        );\\n    }\\n\\n    function _requireValidDebtRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {\\n        require(\\n            _debtRepayment <= _currentDebt,\\n            \\\"BorrowerOperations: Amount repaid must not be larger than the Cdp's debt\\\"\\n        );\\n    }\\n\\n    function _requireSufficientEbtcTokenBalance(\\n        address _account,\\n        uint256 _debtRepayment\\n    ) internal view {\\n        require(\\n            ebtcToken.balanceOf(_account) >= _debtRepayment,\\n            \\\"BorrowerOperations: Caller doesnt have enough eBTC to make repayment\\\"\\n        );\\n    }\\n\\n    function _requireBorrowerOrPositionManagerAndUpdateManagerApproval(address _borrower) internal {\\n        if (_borrower == msg.sender) {\\n            return; // Early return, no delegation\\n        }\\n\\n        PositionManagerApproval _approval = _getPositionManagerApproval(_borrower, msg.sender);\\n        // Must be an approved position manager at this point\\n        require(\\n            _approval != PositionManagerApproval.None,\\n            \\\"BorrowerOperations: Only borrower account or approved position manager can OpenCdp on borrower's behalf\\\"\\n        );\\n\\n        // Conditional Adjustment\\n        /// @dev If this is a position manager operation with a one-time approval, clear that approval\\n        /// @dev If the PositionManagerApproval was none, we should have failed with the check in _requireBorrowerOrPositionManagerAndUpdateManagerApproval\\n        if (_approval == PositionManagerApproval.OneTime) {\\n            _setPositionManagerApproval(_borrower, msg.sender, PositionManagerApproval.None);\\n        }\\n    }\\n\\n    // --- ICR and TCR getters ---\\n\\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\\n    function _getNewNominalICRFromCdpChange(\\n        AdjustCdpLocals memory vars,\\n        bool _isDebtIncrease\\n    ) internal pure returns (uint256) {\\n        (uint256 newCollShares, uint256 newDebt) = _getNewCdpAmounts(\\n            vars.collShares,\\n            vars.debt,\\n            vars.collSharesChange,\\n            vars.isCollIncrease,\\n            vars.netDebtChange,\\n            _isDebtIncrease\\n        );\\n\\n        uint256 newNICR = EbtcMath._computeNominalCR(newCollShares, newDebt);\\n        return newNICR;\\n    }\\n\\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\\n    function _getNewICRFromCdpChange(\\n        uint256 _collShares,\\n        uint256 _debt,\\n        uint256 _collSharesChange,\\n        bool _isCollIncrease,\\n        uint256 _debtChange,\\n        bool _isDebtIncrease,\\n        uint256 _price\\n    ) internal view returns (uint256) {\\n        (uint256 newCollShares, uint256 newDebt) = _getNewCdpAmounts(\\n            _collShares,\\n            _debt,\\n            _collSharesChange,\\n            _isCollIncrease,\\n            _debtChange,\\n            _isDebtIncrease\\n        );\\n\\n        uint256 newICR = EbtcMath._computeCR(\\n            collateral.getPooledEthByShares(newCollShares),\\n            newDebt,\\n            _price\\n        );\\n        return newICR;\\n    }\\n\\n    function _getNewCdpAmounts(\\n        uint256 _collShares,\\n        uint256 _debt,\\n        uint256 _collSharesChange,\\n        bool _isCollIncrease,\\n        uint256 _debtChange,\\n        bool _isDebtIncrease\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 newCollShares = _collShares;\\n        uint256 newDebt = _debt;\\n\\n        newCollShares = _isCollIncrease\\n            ? _collShares + _collSharesChange\\n            : _collShares - _collSharesChange;\\n        newDebt = _isDebtIncrease ? _debt + _debtChange : _debt - _debtChange;\\n\\n        return (newCollShares, newDebt);\\n    }\\n\\n    function _getNewTCRFromCdpChange(\\n        uint256 _stEthBalanceChange,\\n        bool _isCollIncrease,\\n        uint256 _debtChange,\\n        bool _isDebtIncrease,\\n        uint256 _price\\n    ) internal view returns (uint256) {\\n        uint256 _systemCollShares = getSystemCollShares();\\n        uint256 systemStEthBalance = collateral.getPooledEthByShares(_systemCollShares);\\n        uint256 systemDebt = _getSystemDebt();\\n\\n        systemStEthBalance = _isCollIncrease\\n            ? systemStEthBalance + _stEthBalanceChange\\n            : systemStEthBalance - _stEthBalanceChange;\\n        systemDebt = _isDebtIncrease ? systemDebt + _debtChange : systemDebt - _debtChange;\\n\\n        uint256 newTCR = EbtcMath._computeCR(systemStEthBalance, systemDebt, _price);\\n        return newTCR;\\n    }\\n\\n    // === Flash Loans === //\\n\\n    /// @notice Borrow assets with a flash loan\\n    /// @param receiver The address to receive the flash loan\\n    /// @param token The address of the token to loan\\n    /// @param amount The amount of tokens to loan\\n    /// @param data Additional data\\n    /// @return A boolean value indicating whether the operation was successful\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver,\\n        address token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external override returns (bool) {\\n        require(amount > 0, \\\"BorrowerOperations: 0 Amount\\\");\\n        uint256 fee = flashFee(token, amount); // NOTE: Check for `eBTCToken` is implicit here // NOTE: Pause check is here\\n        require(amount <= maxFlashLoan(token), \\\"BorrowerOperations: Too much\\\");\\n\\n        // Issue EBTC\\n        ebtcToken.mint(address(receiver), amount);\\n\\n        // Callback\\n        require(\\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == FLASH_SUCCESS_VALUE,\\n            \\\"IERC3156: Callback failed\\\"\\n        );\\n\\n        // Gas: Repay from user balance, so we don't trigger a new SSTORE\\n        // Safe to use transferFrom and unchecked as it's a standard token\\n        // Also saves gas\\n        // Send both fee and amount to FEE_RECIPIENT, to burn allowance per EIP-3156\\n        ebtcToken.transferFrom(address(receiver), feeRecipientAddress, fee + amount);\\n\\n        // Burn amount, from FEE_RECIPIENT\\n        ebtcToken.burn(feeRecipientAddress, amount);\\n\\n        emit FlashLoanSuccess(address(receiver), token, amount, fee);\\n\\n        return true;\\n    }\\n\\n    /// @notice Calculate the flash loan fee for a given token and amount loaned\\n    /// @param token The address of the token to calculate the fee for\\n    /// @param amount The amount of tokens to calculate the fee for\\n    /// @return The flashloan fee calcualted for given token and loan amount\\n    function flashFee(address token, uint256 amount) public view override returns (uint256) {\\n        require(token == address(ebtcToken), \\\"BorrowerOperations: EBTC Only\\\");\\n        require(!flashLoansPaused, \\\"BorrowerOperations: Flash Loans Paused\\\");\\n\\n        return (amount * feeBps) / MAX_BPS;\\n    }\\n\\n    /// @notice Get the maximum flash loan amount for a specific token\\n    /// @param token The address of the token to get the maximum flash loan amount for, exclusively used here for eBTC token\\n    /// @return The maximum available flashloan amount for the token, equals to `type(uint112).max`\\n    function maxFlashLoan(address token) public view override returns (uint256) {\\n        if (token != address(ebtcToken)) {\\n            return 0;\\n        }\\n\\n        if (flashLoansPaused) {\\n            return 0;\\n        }\\n\\n        return type(uint112).max;\\n    }\\n\\n    // === Governed Functions ==\\n\\n    /// @notice Sets new Fee for FlashLoans\\n    /// @param _newFee The new flashloan fee to be set\\n    function setFeeBps(uint256 _newFee) external requiresAuth {\\n        require(_newFee <= MAX_FEE_BPS, \\\"ERC3156FlashLender: _newFee should <= MAX_FEE_BPS\\\");\\n\\n        cdpManager.syncGlobalAccounting();\\n\\n        // set new flash fee\\n        uint256 _oldFee = feeBps;\\n        feeBps = uint16(_newFee);\\n        emit FlashFeeSet(msg.sender, _oldFee, _newFee);\\n    }\\n\\n    /// @notice Should Flashloans be paused?\\n    /// @param _paused The flag (true or false) whether flashloan will be paused\\n    function setFlashLoansPaused(bool _paused) external requiresAuth {\\n        cdpManager.syncGlobalAccounting();\\n\\n        flashLoansPaused = _paused;\\n        emit FlashLoansPaused(msg.sender, _paused);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/AuthNoOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.17;\\n\\nimport {Authority} from \\\"./Authority.sol\\\";\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Modified by BadgerDAO to remove owner\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ncontract AuthNoOwner {\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    Authority private _authority;\\n    bool private _authorityInitialized;\\n\\n    modifier requiresAuth() virtual {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"Auth: UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function authority() public view returns (Authority) {\\n        return _authority;\\n    }\\n\\n    function authorityInitialized() public view returns (bool) {\\n        return _authorityInitialized;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = _authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig));\\n    }\\n\\n    /// @notice Changed constructor to initialize to allow flexiblity of constructor vs initializer use\\n    /// @notice sets authorityInitiailzed flag to ensure only one use of\\n    function _initializeAuthority(address newAuthority) internal {\\n        require(address(_authority) == address(0), \\\"Auth: authority is non-zero\\\");\\n        require(!_authorityInitialized, \\\"Auth: authority already initialized\\\");\\n\\n        _authority = Authority(newAuthority);\\n        _authorityInitialized = true;\\n\\n        emit AuthorityUpdated(address(this), Authority(newAuthority));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/Authority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.17;\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(address user, address target, bytes4 functionSig) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/BaseMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ncontract BaseMath {\\n    uint256 public constant DECIMAL_PRECISION = 1e18;\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/EbtcBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./BaseMath.sol\\\";\\nimport \\\"./EbtcMath.sol\\\";\\nimport \\\"../Interfaces/IActivePool.sol\\\";\\nimport \\\"../Interfaces/IPriceFeed.sol\\\";\\nimport \\\"../Interfaces/IEbtcBase.sol\\\";\\nimport \\\"../Dependencies/ICollateralToken.sol\\\";\\n\\n/*\\n * Base contract for CdpManager, BorrowerOperations. Contains global system constants and\\n * common functions.\\n */\\ncontract EbtcBase is BaseMath, IEbtcBase {\\n    // Collateral Ratio applied for Liquidation Incentive\\n    // i.e., liquidator repay $1 worth of debt to get back $1.03 worth of collateral\\n    uint256 public constant LICR = 1030000000000000000; // 103%\\n\\n    // Minimum collateral ratio for individual cdps\\n    uint256 public constant MCR = 1100000000000000000; // 110%\\n\\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\\n    uint256 public constant CCR = 1250000000000000000; // 125%\\n\\n    // Amount of stETH collateral to be locked in active pool on opening cdps\\n    uint256 public constant LIQUIDATOR_REWARD = 2e17;\\n\\n    // Minimum amount of stETH collateral a CDP must have\\n    uint256 public constant MIN_NET_STETH_BALANCE = 2e18;\\n\\n    uint256 public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\\n\\n    uint256 public constant BORROWING_FEE_FLOOR = 0; // 0.5%\\n\\n    uint256 public constant STAKING_REWARD_SPLIT = 5_000; // taking 50% cut from staking reward\\n\\n    uint256 public constant MAX_REWARD_SPLIT = 10_000;\\n\\n    uint256 public constant MIN_CHANGE = 1000;\\n\\n    IActivePool public immutable activePool;\\n\\n    IPriceFeed public immutable override priceFeed;\\n\\n    // the only collateral token allowed in CDP\\n    ICollateralToken public immutable collateral;\\n\\n    /// @notice Initializes the contract with the provided addresses\\n    /// @param _activePoolAddress The address of the ActivePool contract\\n    /// @param _priceFeedAddress The address of the PriceFeed contract\\n    /// @param _collateralAddress The address of the CollateralToken contract\\n    constructor(address _activePoolAddress, address _priceFeedAddress, address _collateralAddress) {\\n        activePool = IActivePool(_activePoolAddress);\\n        priceFeed = IPriceFeed(_priceFeedAddress);\\n        collateral = ICollateralToken(_collateralAddress);\\n    }\\n\\n    // --- Gas compensation functions ---\\n\\n    function _calcNetStEthBalance(uint256 _stEthBalance) internal pure returns (uint256) {\\n        return _stEthBalance - LIQUIDATOR_REWARD;\\n    }\\n\\n    /// @notice Get the entire system collateral\\n    /// @notice Entire system collateral = collateral allocated to system in ActivePool, using it's internal accounting\\n    /// @dev Collateral tokens stored in ActivePool for liquidator rewards, fees, or coll in CollSurplusPool, are not included\\n    function getSystemCollShares() public view returns (uint256 entireSystemColl) {\\n        return (activePool.getSystemCollShares());\\n    }\\n\\n    /**\\n        @notice Get the entire system debt\\n        @notice Entire system collateral = collateral stored in ActivePool, using their internal accounting\\n     */\\n    function _getSystemDebt() internal view returns (uint256 entireSystemDebt) {\\n        return (activePool.getSystemDebt());\\n    }\\n\\n    function _getCachedTCR(uint256 _price) internal view returns (uint256 TCR) {\\n        (TCR, , ) = _getTCRWithSystemDebtAndCollShares(_price);\\n    }\\n\\n    function _getTCRWithSystemDebtAndCollShares(\\n        uint256 _price\\n    ) internal view returns (uint256 TCR, uint256 _coll, uint256 _debt) {\\n        uint256 systemCollShares = getSystemCollShares();\\n        uint256 systemDebt = _getSystemDebt();\\n\\n        uint256 _systemStEthBalance = collateral.getPooledEthByShares(systemCollShares);\\n        TCR = EbtcMath._computeCR(_systemStEthBalance, systemDebt, _price);\\n\\n        return (TCR, systemCollShares, systemDebt);\\n    }\\n\\n    function _checkRecoveryMode(uint256 _price) internal view returns (bool) {\\n        return _checkRecoveryModeForTCR(_getCachedTCR(_price));\\n    }\\n\\n    function _checkRecoveryModeForTCR(uint256 _tcr) internal view returns (bool) {\\n        return _tcr < CCR;\\n    }\\n\\n    function _requireUserAcceptsFee(\\n        uint256 _fee,\\n        uint256 _amount,\\n        uint256 _maxFeePercentage\\n    ) internal pure {\\n        uint256 feePercentage = (_fee * DECIMAL_PRECISION) / _amount;\\n        require(feePercentage <= _maxFeePercentage, \\\"Fee exceeded provided maximum\\\");\\n    }\\n\\n    // Convert debt denominated in ETH to debt denominated in BTC given that _price is ETH/BTC\\n    // _debt is denominated in ETH\\n    // _price is ETH/BTC\\n    function _convertDebtDenominationToBtc(\\n        uint256 _debt,\\n        uint256 _price\\n    ) internal pure returns (uint256) {\\n        return (_debt * _price) / DECIMAL_PRECISION;\\n    }\\n\\n    /// @dev return true if given ICR is qualified for liquidation compared to configured threshold\\n    /// @dev this function ONLY checks numbers not check grace period switch for Recovery Mode\\n    function _checkICRAgainstLiqThreshold(uint256 _icr, uint _tcr) internal view returns (bool) {\\n        // Either undercollateralized\\n        // OR, it's RM AND they meet the requirement\\n        // Swapped Requirement && RM to save gas\\n        return\\n            _checkICRAgainstMCR(_icr) ||\\n            (_checkICRAgainstTCR(_icr, _tcr) && _checkRecoveryModeForTCR(_tcr));\\n    }\\n\\n    /// @dev return true if given ICR is qualified for liquidation compared to MCR\\n    function _checkICRAgainstMCR(uint256 _icr) internal view returns (bool) {\\n        return _icr < MCR;\\n    }\\n\\n    /// @dev return true if given ICR is qualified for liquidation compared to TCR\\n    /// @dev typically used in Recovery Mode\\n    function _checkICRAgainstTCR(uint256 _icr, uint _tcr) internal view returns (bool) {\\n        /// @audit is _icr <= _tcr more dangerous for overal system safety?\\n        /// @audit Should we use _icr < CCR to allow any risky CDP being liquidated?\\n        return _icr <= _tcr;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/EbtcMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nlibrary EbtcMath {\\n    uint256 internal constant DECIMAL_PRECISION = 1e18;\\n    uint256 public constant MAX_TCR = type(uint256).max;\\n\\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\\n     *\\n     * - Making it \u201ctoo high\u201d could lead to overflows.\\n     * - Making it \u201ctoo low\u201d could lead to an ICR equal to zero, due to truncation from Solidity floor division.\\n     *\\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\\n     *\\n     */\\n    uint256 internal constant NICR_PRECISION = 1e20;\\n\\n    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        return (_a < _b) ? _a : _b;\\n    }\\n\\n    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        return (_a >= _b) ? _a : _b;\\n    }\\n\\n    /**\\n     * credit to OpenZeppelin\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"EbtcMath: downcast to uint128 will overflow\\\");\\n        return uint128(value);\\n    }\\n\\n    /*\\n     * Multiply two decimal numbers and use normal rounding rules:\\n     * -round product up if 19'th mantissa digit >= 5\\n     * -round product down if 19'th mantissa digit < 5\\n     *\\n     * Used only inside the exponentiation, _decPow().\\n     */\\n    function decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {\\n        uint256 prod_xy = x * y;\\n\\n        decProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;\\n    }\\n\\n    /*\\n     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\\n     *\\n     * Uses the efficient \\\"exponentiation by squaring\\\" algorithm. O(log(n)) complexity.\\n     *\\n     * Called by two functions that represent time in units of minutes:\\n     * 1) CdpManager._calcDecayedBaseRate\\n     * 2) CommunityIssuance._getCumulativeIssuanceFraction\\n     *\\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\\n     * \\\"minutes in 1000 years\\\": 60 * 24 * 365 * 1000\\n     *\\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\\n     * negligibly different from just passing the cap, since:\\n     *\\n     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\\n     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\\n     */\\n    function _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint256) {\\n        if (_minutes > 525600000) {\\n            _minutes = 525600000;\\n        } // cap to avoid overflow\\n\\n        if (_minutes == 0) {\\n            return DECIMAL_PRECISION;\\n        }\\n\\n        uint256 y = DECIMAL_PRECISION;\\n        uint256 x = _base;\\n        uint256 n = _minutes;\\n\\n        // Exponentiation-by-squaring\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                x = decMul(x, x);\\n                n = n / 2;\\n            } else {\\n                // if (n % 2 != 0)\\n                y = decMul(x, y);\\n                x = decMul(x, x);\\n                n = (n - 1) / 2;\\n            }\\n        }\\n\\n        return decMul(x, y);\\n    }\\n\\n    function _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        return (_a >= _b) ? (_a - _b) : (_b - _a);\\n    }\\n\\n    function _computeNominalCR(uint256 _collShares, uint256 _debt) internal pure returns (uint256) {\\n        if (_debt > 0) {\\n            return (_collShares * NICR_PRECISION) / _debt;\\n        }\\n        // Return the maximal value for uint256 if the Cdp has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else {\\n            // if (_debt == 0)\\n            return MAX_TCR;\\n        }\\n    }\\n\\n    /// @dev Compute collateralization ratio, given stETH balance, price, and debt balance\\n    function _computeCR(\\n        uint256 _stEthBalance,\\n        uint256 _debt,\\n        uint256 _price\\n    ) internal pure returns (uint256) {\\n        if (_debt > 0) {\\n            uint256 newCollRatio = (_stEthBalance * _price) / _debt;\\n\\n            return newCollRatio;\\n        }\\n        // Return the maximal value for uint256 if the Cdp has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else {\\n            // if (_debt == 0)\\n            return MAX_TCR;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/ERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../Interfaces/IERC3156FlashLender.sol\\\";\\nimport \\\"../Interfaces/IWETH.sol\\\";\\n\\nabstract contract ERC3156FlashLender is IERC3156FlashLender {\\n    uint256 public constant MAX_BPS = 10_000;\\n    uint256 public constant MAX_FEE_BPS = 1_000; // 10%\\n    bytes32 public constant FLASH_SUCCESS_VALUE = keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n\\n    // Functions to modify these variables must be included in impelemnting contracts if desired\\n    uint16 public feeBps = 3; // may be subject to future adjustments through protocol governance\\n    bool public flashLoansPaused;\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/ICollateralToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * Based on the stETH:\\n *  -   https://docs.lido.fi/contracts/lido#\\n */\\ninterface ICollateralToken is IERC20 {\\n    // Returns the amount of shares that corresponds to _ethAmount protocol-controlled Ether\\n    function getSharesByPooledEth(uint256 _ethAmount) external view returns (uint256);\\n\\n    // Returns the amount of Ether that corresponds to _sharesAmount token shares\\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\\n\\n    // Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256);\\n\\n    // Returns the amount of shares owned by _account\\n    function sharesOf(address _account) external view returns (uint256);\\n\\n    // Returns authorized oracle address\\n    function getOracle() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/ICollateralTokenOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * Based on the stETH:\\n *  -   https://docs.lido.fi/contracts/lido#\\n */\\ninterface ICollateralTokenOracle {\\n    // Return beacon specification data.\\n    function getBeaconSpec()\\n        external\\n        view\\n        returns (\\n            uint64 epochsPerFrame,\\n            uint64 slotsPerEpoch,\\n            uint64 secondsPerSlot,\\n            uint64 genesisTime\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * Based on the OpenZeppelin IER20 interface:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\\n *\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one's\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n *\\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\\n */\\ninterface IERC2612 {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     *\\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to\\n     * a value in the near future. The deadline argument can be set to uint256(-1) to\\n     * create Permits that effectively never expire.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function version() external view returns (string memory);\\n\\n    function permitTypeHash() external view returns (bytes32);\\n\\n    function domainSeparator() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/PermitNonce.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\nimport \\\"../Interfaces/IPermitNonce.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides a mapping from address to nonce (uint256) used for permit signature\\n */\\ncontract PermitNonce is IPermitNonce {\\n    mapping(address => uint256) internal _nonces;\\n\\n    /// @dev Increase current nonce for msg.sender by one.\\n    /// @notice This function could be used to invalidate any signed permit out there\\n    function increasePermitNonce() external returns (uint256) {\\n        return ++_nonces[msg.sender];\\n    }\\n\\n    /// @dev Return current nonce for msg.sender fOR EIP-2612 compatibility\\n    function nonces(address owner) external view virtual returns (uint256) {\\n        return _nonces[owner];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.17;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 internal constant OPEN = 1;\\n    uint256 internal constant LOCKED = 2;\\n\\n    uint256 public locked = OPEN;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == OPEN, \\\"ReentrancyGuard: Reentrancy in nonReentrant call\\\");\\n\\n        locked = LOCKED;\\n\\n        _;\\n\\n        locked = OPEN;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IActivePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IPool.sol\\\";\\nimport \\\"./ITwapWeightedObserver.sol\\\";\\n\\ninterface IActivePool is IPool, ITwapWeightedObserver {\\n    // --- Events ---\\n    event ActivePoolEBTCDebtUpdated(uint256 _EBTCDebt);\\n    event SystemCollSharesUpdated(uint256 _coll);\\n    event FeeRecipientClaimableCollSharesIncreased(uint256 _coll, uint256 _fee);\\n    event FeeRecipientClaimableCollSharesDecreased(uint256 _coll, uint256 _fee);\\n    event FlashLoanSuccess(\\n        address indexed _receiver,\\n        address indexed _token,\\n        uint256 _amount,\\n        uint256 _fee\\n    );\\n    event SweepTokenSuccess(address indexed _token, uint256 _amount, address indexed _recipient);\\n\\n    // --- Functions ---\\n    function transferSystemCollShares(address _account, uint256 _amount) external;\\n\\n    function increaseSystemCollShares(uint256 _value) external;\\n\\n    function transferSystemCollSharesAndLiquidatorReward(\\n        address _account,\\n        uint256 _shares,\\n        uint256 _liquidatorRewardShares\\n    ) external;\\n\\n    function allocateSystemCollSharesToFeeRecipient(uint256 _shares) external;\\n\\n    function claimFeeRecipientCollShares(uint256 _shares) external;\\n\\n    function feeRecipientAddress() external view returns (address);\\n\\n    function getFeeRecipientClaimableCollShares() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IBaseTwapWeightedObserver.sol\": {\r\n      \"content\": \"// SPDX-License Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IBaseTwapWeightedObserver {\\n    // NOTE: Packing manually is cheaper, but this is simpler to understand and follow\\n    struct PackedData {\\n        // Slot 0\\n        // Seconds in a year: 3.154e+7\\n        /// @dev Accumulator value recorded for TWAP Observer until last update\\n        uint128 observerCumuVal; // 3.154e+7 * 80 * 100e27 = 2.5232e+38 | log_2(100e27 * 3.154e+7 * 80) = 127.568522171\\n        /// @dev Accumulator for TWAP globally\\n        uint128 accumulator; // 3.154e+7 * 80 * 100e27 = 2.5232e+38 | log_2(100e27 * 3.154e+7 * 80) = 127.568522171\\n        // NOTE: We can further compress this slot but we will not be able to use only one (see u72 impl)\\n        /// So what's the point of making the code more complex?\\n\\n        // Slot 1\\n        /// @dev last update timestamp for TWAP Observer\\n        uint64 lastObserved; // Thousands of Years, if we use relative time we can use u32 | Relative to deploy time (as immutable)\\n        /// @dev last update timestamp for TWAP global track(spot) value\\n        uint64 lastAccrued; // Thousands of years\\n        // Expect eBTC debt to never surpass 100e27, which is 100 BILLION eBTC\\n        // log_2(100e27) = 96.3359147517 | log_2(100e27 / 1e18) = 36.5412090438\\n        // We could use a u64\\n        /// @dev average value since last observe\\n        uint128 lastObservedAverage;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IBorrowerOperations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\nimport \\\"./IPositionManagers.sol\\\";\\n\\n// Common interface for the Cdp Manager.\\ninterface IBorrowerOperations is IPositionManagers {\\n    // --- Events ---\\n\\n    event FeeRecipientAddressChanged(address indexed _feeRecipientAddress);\\n    event FlashLoanSuccess(\\n        address indexed _receiver,\\n        address indexed _token,\\n        uint256 _amount,\\n        uint256 _fee\\n    );\\n\\n    // --- Functions ---\\n\\n    function openCdp(\\n        uint256 _EBTCAmount,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint256 _stEthBalance\\n    ) external returns (bytes32);\\n\\n    function openCdpFor(\\n        uint _EBTCAmount,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint _collAmount,\\n        address _borrower\\n    ) external returns (bytes32);\\n\\n    function addColl(\\n        bytes32 _cdpId,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint256 _stEthBalanceIncrease\\n    ) external;\\n\\n    function withdrawColl(\\n        bytes32 _cdpId,\\n        uint256 _stEthBalanceDecrease,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint\\n    ) external;\\n\\n    function withdrawDebt(\\n        bytes32 _cdpId,\\n        uint256 _amount,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint\\n    ) external;\\n\\n    function repayDebt(\\n        bytes32 _cdpId,\\n        uint256 _amount,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint\\n    ) external;\\n\\n    function closeCdp(bytes32 _cdpId) external;\\n\\n    function adjustCdp(\\n        bytes32 _cdpId,\\n        uint256 _stEthBalanceDecrease,\\n        uint256 _debtChange,\\n        bool isDebtIncrease,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint\\n    ) external;\\n\\n    function adjustCdpWithColl(\\n        bytes32 _cdpId,\\n        uint256 _stEthBalanceDecrease,\\n        uint256 _debtChange,\\n        bool isDebtIncrease,\\n        bytes32 _upperHint,\\n        bytes32 _lowerHint,\\n        uint256 _stEthBalanceIncrease\\n    ) external;\\n\\n    function claimSurplusCollShares() external;\\n\\n    function feeRecipientAddress() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ICdpManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IEbtcBase.sol\\\";\\nimport \\\"./ICdpManagerData.sol\\\";\\n\\n// Common interface for the Cdp Manager.\\ninterface ICdpManager is IEbtcBase, ICdpManagerData {\\n    // --- Functions ---\\n    function liquidate(bytes32 _cdpId) external;\\n\\n    function partiallyLiquidate(\\n        bytes32 _cdpId,\\n        uint256 _partialAmount,\\n        bytes32 _upperPartialHint,\\n        bytes32 _lowerPartialHint\\n    ) external;\\n\\n    function batchLiquidateCdps(bytes32[] calldata _cdpArray) external;\\n\\n    function redeemCollateral(\\n        uint256 _EBTCAmount,\\n        bytes32 _firstRedemptionHint,\\n        bytes32 _upperPartialRedemptionHint,\\n        bytes32 _lowerPartialRedemptionHint,\\n        uint256 _partialRedemptionHintNICR,\\n        uint256 _maxIterations,\\n        uint256 _maxFee\\n    ) external;\\n\\n    function updateStakeAndTotalStakes(bytes32 _cdpId) external returns (uint256);\\n\\n    function syncAccounting(bytes32 _cdpId) external;\\n\\n    function closeCdp(bytes32 _cdpId, address _borrower, uint256 _debt, uint256 _coll) external;\\n\\n    function getRedemptionRate() external view returns (uint256);\\n\\n    function getRedemptionRateWithDecay() external view returns (uint256);\\n\\n    function getRedemptionFeeWithDecay(uint256 _stETHToRedeem) external view returns (uint256);\\n\\n    function getCdpStatus(bytes32 _cdpId) external view returns (uint256);\\n\\n    function getCdpStake(bytes32 _cdpId) external view returns (uint256);\\n\\n    function getCdpDebt(bytes32 _cdpId) external view returns (uint256);\\n\\n    function getCdpCollShares(bytes32 _cdpId) external view returns (uint256);\\n\\n    function getCdpLiquidatorRewardShares(bytes32 _cdpId) external view returns (uint);\\n\\n    function initializeCdp(\\n        bytes32 _cdpId,\\n        uint256 _debt,\\n        uint256 _coll,\\n        uint256 _liquidatorRewardShares,\\n        address _borrower\\n    ) external;\\n\\n    function updateCdp(\\n        bytes32 _cdpId,\\n        address _borrower,\\n        uint256 _coll,\\n        uint256 _debt,\\n        uint256 _newColl,\\n        uint256 _newDebt\\n    ) external;\\n\\n    function getCachedTCR(uint256 _price) external view returns (uint256);\\n\\n    function checkRecoveryMode(uint256 _price) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ICdpManagerData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./ICollSurplusPool.sol\\\";\\nimport \\\"./IEBTCToken.sol\\\";\\nimport \\\"./ISortedCdps.sol\\\";\\nimport \\\"./IActivePool.sol\\\";\\nimport \\\"./IRecoveryModeGracePeriod.sol\\\";\\nimport \\\"../Dependencies/ICollateralTokenOracle.sol\\\";\\n\\n// Common interface for the Cdp Manager.\\ninterface ICdpManagerData is IRecoveryModeGracePeriod {\\n    // --- Events ---\\n\\n    event StakingRewardSplitSet(uint256 _stakingRewardSplit);\\n    event RedemptionFeeFloorSet(uint256 _redemptionFeeFloor);\\n    event MinuteDecayFactorSet(uint256 _minuteDecayFactor);\\n    event BetaSet(uint256 _beta);\\n    event RedemptionsPaused(bool _paused);\\n\\n    event Liquidation(uint256 _liquidatedDebt, uint256 _liquidatedColl, uint256 _liqReward);\\n    event Redemption(\\n        uint256 _debtToRedeemExpected,\\n        uint256 _debtToRedeemActual,\\n        uint256 _collSharesSent,\\n        uint256 _feeCollShares,\\n        address indexed _redeemer\\n    );\\n    event CdpUpdated(\\n        bytes32 indexed _cdpId,\\n        address indexed _borrower,\\n        address indexed _executor,\\n        uint256 _oldDebt,\\n        uint256 _oldCollShares,\\n        uint256 _debt,\\n        uint256 _collShares,\\n        uint256 _stake,\\n        CdpOperation _operation\\n    );\\n    event CdpLiquidated(\\n        bytes32 indexed _cdpId,\\n        address indexed _borrower,\\n        uint _debt,\\n        uint _collShares,\\n        CdpOperation _operation,\\n        address indexed _liquidator,\\n        uint _premiumToLiquidator\\n    );\\n    event CdpPartiallyLiquidated(\\n        bytes32 indexed _cdpId,\\n        address indexed _borrower,\\n        uint256 _debt,\\n        uint256 _collShares,\\n        CdpOperation operation,\\n        address indexed _liquidator,\\n        uint _premiumToLiquidator\\n    );\\n    event BaseRateUpdated(uint256 _baseRate);\\n    event LastRedemptionTimestampUpdated(uint256 _lastFeeOpTime);\\n    event TotalStakesUpdated(uint256 _newTotalStakes);\\n    event SystemSnapshotsUpdated(uint256 _totalStakesSnapshot, uint256 _totalCollateralSnapshot);\\n    event SystemDebtRedistributionIndexUpdated(uint256 _systemDebtRedistributionIndex);\\n    event CdpDebtRedistributionIndexUpdated(bytes32 _cdpId, uint256 _cdpDebtRedistributionIndex);\\n    event CdpArrayIndexUpdated(bytes32 _cdpId, uint256 _newIndex);\\n    event StEthIndexUpdated(uint256 _oldIndex, uint256 _newIndex, uint256 _updTimestamp);\\n    event CollateralFeePerUnitUpdated(uint256 _oldPerUnit, uint256 _newPerUnit, uint256 _feeTaken);\\n    event CdpFeeSplitApplied(\\n        bytes32 _cdpId,\\n        uint256 _oldPerUnitCdp,\\n        uint256 _newPerUnitCdp,\\n        uint256 _collReduced,\\n        uint256 _collLeft\\n    );\\n\\n    enum CdpOperation {\\n        openCdp,\\n        closeCdp,\\n        adjustCdp,\\n        syncAccounting,\\n        liquidateInNormalMode,\\n        liquidateInRecoveryMode,\\n        redeemCollateral,\\n        partiallyLiquidate\\n    }\\n\\n    enum Status {\\n        nonExistent,\\n        active,\\n        closedByOwner,\\n        closedByLiquidation,\\n        closedByRedemption\\n    }\\n\\n    // Store the necessary data for a cdp\\n    struct Cdp {\\n        uint256 debt;\\n        uint256 coll;\\n        uint256 stake;\\n        uint128 liquidatorRewardShares;\\n        Status status;\\n    }\\n\\n    /*\\n     * --- Variable container structs for liquidations ---\\n     *\\n     * These structs are used to hold, return and assign variables inside the liquidation functions,\\n     * in order to avoid the error: \\\"CompilerError: Stack too deep\\\".\\n     **/\\n\\n    struct CdpDebtAndCollShares {\\n        uint256 debt;\\n        uint256 collShares;\\n    }\\n\\n    struct LiquidationLocals {\\n        bytes32 cdpId;\\n        uint256 partialAmount; // used only for partial liquidation, default 0 means full liquidation\\n        uint256 price;\\n        uint256 ICR;\\n        bytes32 upperPartialHint;\\n        bytes32 lowerPartialHint;\\n        bool recoveryModeAtStart;\\n        uint256 TCR;\\n        uint256 totalSurplusCollShares;\\n        uint256 totalCollSharesToSend;\\n        uint256 totalDebtToBurn;\\n        uint256 totalDebtToRedistribute;\\n        uint256 totalLiquidatorRewardCollShares;\\n    }\\n\\n    struct LiquidationRecoveryModeLocals {\\n        uint256 entireSystemDebt;\\n        uint256 entireSystemColl;\\n        uint256 totalDebtToBurn;\\n        uint256 totalCollSharesToSend;\\n        uint256 totalSurplusCollShares;\\n        bytes32 cdpId;\\n        uint256 price;\\n        uint256 ICR;\\n        uint256 totalDebtToRedistribute;\\n        uint256 totalLiquidatorRewardCollShares;\\n    }\\n\\n    struct LocalVariables_OuterLiquidationFunction {\\n        uint256 price;\\n        bool recoveryModeAtStart;\\n        uint256 liquidatedDebt;\\n        uint256 liquidatedColl;\\n    }\\n\\n    struct LocalVariables_LiquidationSequence {\\n        uint256 i;\\n        uint256 ICR;\\n        bytes32 cdpId;\\n        bool backToNormalMode;\\n        uint256 entireSystemDebt;\\n        uint256 entireSystemColl;\\n        uint256 price;\\n        uint256 TCR;\\n    }\\n\\n    struct SingleRedemptionInputs {\\n        bytes32 cdpId;\\n        uint256 maxEBTCamount;\\n        uint256 price;\\n        bytes32 upperPartialRedemptionHint;\\n        bytes32 lowerPartialRedemptionHint;\\n        uint256 partialRedemptionHintNICR;\\n    }\\n\\n    struct LiquidationValues {\\n        uint256 entireCdpDebt;\\n        uint256 debtToBurn;\\n        uint256 totalCollToSendToLiquidator;\\n        uint256 debtToRedistribute;\\n        uint256 collSurplus;\\n        uint256 liquidatorCollSharesReward;\\n    }\\n\\n    struct LiquidationTotals {\\n        uint256 totalDebtInSequence;\\n        uint256 totalDebtToBurn;\\n        uint256 totalCollToSendToLiquidator;\\n        uint256 totalDebtToRedistribute;\\n        uint256 totalCollSurplus;\\n        uint256 totalCollReward;\\n    }\\n\\n    // --- Variable container structs for redemptions ---\\n\\n    struct RedemptionTotals {\\n        uint256 remainingDebtToRedeem;\\n        uint256 debtToRedeem;\\n        uint256 collSharesDrawn;\\n        uint256 totalCollSharesSurplus;\\n        uint256 feeCollShares;\\n        uint256 collSharesToRedeemer;\\n        uint256 decayedBaseRate;\\n        uint256 price;\\n        uint256 systemDebtAtStart;\\n        uint256 twapSystemDebtAtStart;\\n        uint256 systemCollSharesAtStart;\\n        uint256 tcrAtStart;\\n    }\\n\\n    struct SingleRedemptionValues {\\n        uint256 debtToRedeem;\\n        uint256 collSharesDrawn;\\n        uint256 collSurplus;\\n        uint256 liquidatorRewardShares;\\n        bool cancelledPartial;\\n        bool fullRedemption;\\n        uint256 newPartialNICR;\\n    }\\n\\n    function getActiveCdpsCount() external view returns (uint256);\\n\\n    function totalStakes() external view returns (uint256);\\n\\n    function ebtcToken() external view returns (IEBTCToken);\\n\\n    function systemStEthFeePerUnitIndex() external view returns (uint256);\\n\\n    function systemStEthFeePerUnitIndexError() external view returns (uint256);\\n\\n    function stEthIndex() external view returns (uint256);\\n\\n    function calcFeeUponStakingReward(\\n        uint256 _newIndex,\\n        uint256 _prevIndex\\n    ) external view returns (uint256, uint256, uint256);\\n\\n    function syncGlobalAccounting() external; // Accrues StEthFeeSplit without influencing Grace Period\\n\\n    function syncGlobalAccountingAndGracePeriod() external; // Accrues StEthFeeSplit and influences Grace Period\\n\\n    function getAccumulatedFeeSplitApplied(\\n        bytes32 _cdpId,\\n        uint256 _systemStEthFeePerUnitIndex\\n    ) external view returns (uint256, uint256);\\n\\n    function getCachedNominalICR(bytes32 _cdpId) external view returns (uint256);\\n\\n    function getCachedICR(bytes32 _cdpId, uint256 _price) external view returns (uint256);\\n\\n    function getSyncedCdpDebt(bytes32 _cdpId) external view returns (uint256);\\n\\n    function getSyncedCdpCollShares(bytes32 _cdpId) external view returns (uint256);\\n\\n    function getSyncedICR(bytes32 _cdpId, uint256 _price) external view returns (uint256);\\n\\n    function getSyncedTCR(uint256 _price) external view returns (uint256);\\n\\n    function getSyncedSystemCollShares() external view returns (uint256);\\n\\n    function getSyncedNominalICR(bytes32 _cdpId) external view returns (uint256);\\n\\n    function getPendingRedistributedDebt(bytes32 _cdpId) external view returns (uint256);\\n\\n    function hasPendingRedistributedDebt(bytes32 _cdpId) external view returns (bool);\\n\\n    function getSyncedDebtAndCollShares(\\n        bytes32 _cdpId\\n    ) external view returns (uint256 debt, uint256 collShares);\\n\\n    function canLiquidateRecoveryMode(uint256 icr, uint256 tcr) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ICollSurplusPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface ICollSurplusPool {\\n    // --- Events ---\\n\\n    event SurplusCollSharesAdded(\\n        bytes32 indexed _cdpId,\\n        address indexed _account,\\n        uint256 _claimableSurplusCollShares,\\n        uint256 _surplusCollSharesAddedFromCollateral,\\n        uint256 _surplusCollSharesAddedFromLiquidatorReward\\n    );\\n    event CollSharesTransferred(address indexed _to, uint256 _amount);\\n\\n    event SweepTokenSuccess(address indexed _token, uint256 _amount, address indexed _recipient);\\n\\n    // --- Contract setters ---\\n\\n    function getTotalSurplusCollShares() external view returns (uint256);\\n\\n    function getSurplusCollShares(address _account) external view returns (uint256);\\n\\n    function increaseSurplusCollShares(\\n        bytes32 _cdpId,\\n        address _account,\\n        uint256 _collateralShares,\\n        uint256 _liquidatorRewardShares\\n    ) external;\\n\\n    function claimSurplusCollShares(address _account) external;\\n\\n    function increaseTotalSurplusCollShares(uint256 _value) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IEbtcBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IPriceFeed.sol\\\";\\n\\ninterface IEbtcBase {\\n    function priceFeed() external view returns (IPriceFeed);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IEBTCToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../Dependencies/IERC20.sol\\\";\\nimport \\\"../Dependencies/IERC2612.sol\\\";\\n\\ninterface IEBTCToken is IERC20, IERC2612 {\\n    // --- Functions ---\\n\\n    function mint(address _account, uint256 _amount) external;\\n\\n    function burn(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IERC3156FlashBorrower {\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\ninterface IERC3156FlashLender {\\n    event FlashFeeSet(address indexed _setter, uint256 _oldFee, uint256 _newFee);\\n    event MaxFlashFeeSet(address indexed _setter, uint256 _oldMaxFee, uint256 _newMaxFee);\\n    event FlashLoansPaused(address indexed _setter, bool _paused);\\n\\n    /// @dev The amount of currency available to be lent.\\n    /// @param token The loan currency.\\n    /// @return The amount of `token` that can be borrowed.\\n    function maxFlashLoan(address token) external view returns (uint256);\\n\\n    /// @dev The fee to be charged for a given loan.\\n    /// @param token The loan currency.\\n    /// @param amount The amount of tokens lent.\\n    /// @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n    function flashFee(address token, uint256 amount) external view returns (uint256);\\n\\n    /// @dev Initiate a flash loan.\\n    /// @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\n    /// @param token The loan currency.\\n    /// @param amount The amount of tokens lent.\\n    /// @param data Arbitrary data structure, intended to contain user-defined parameters.\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver,\\n        address token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPermitNonce.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IPermitNonce {\\n    // --- Functions ---\\n    function increasePermitNonce() external returns (uint256);\\n\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n// Common interface for the Pools.\\ninterface IPool {\\n    // --- Events ---\\n\\n    event ETHBalanceUpdated(uint256 _newBalance);\\n    event EBTCBalanceUpdated(uint256 _newBalance);\\n    event CollSharesTransferred(address indexed _to, uint256 _amount);\\n\\n    // --- Functions ---\\n\\n    function getSystemCollShares() external view returns (uint256);\\n\\n    function getSystemDebt() external view returns (uint256);\\n\\n    function increaseSystemDebt(uint256 _amount) external;\\n\\n    function decreaseSystemDebt(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPositionManagers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IPositionManagers {\\n    enum PositionManagerApproval {\\n        None,\\n        OneTime,\\n        Persistent\\n    }\\n\\n    event PositionManagerApprovalSet(\\n        address indexed _borrower,\\n        address indexed _positionManager,\\n        PositionManagerApproval _approval\\n    );\\n\\n    function getPositionManagerApproval(\\n        address _borrower,\\n        address _positionManager\\n    ) external view returns (PositionManagerApproval);\\n\\n    function setPositionManagerApproval(\\n        address _positionManager,\\n        PositionManagerApproval _approval\\n    ) external;\\n\\n    function revokePositionManagerApproval(address _positionManager) external;\\n\\n    function renouncePositionManagerApproval(address _borrower) external;\\n\\n    function permitPositionManagerApproval(\\n        address _borrower,\\n        address _positionManager,\\n        PositionManagerApproval _approval,\\n        uint _deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function version() external view returns (string memory);\\n\\n    function permitTypeHash() external view returns (bytes32);\\n\\n    function domainSeparator() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IPriceFeed {\\n    // --- Events ---\\n    event LastGoodPriceUpdated(uint256 _lastGoodPrice);\\n    event PriceFeedStatusChanged(Status newStatus);\\n    event FallbackCallerChanged(\\n        address indexed _oldFallbackCaller,\\n        address indexed _newFallbackCaller\\n    );\\n    event UnhealthyFallbackCaller(address indexed _fallbackCaller, uint256 timestamp);\\n    event CollateralFeedSourceUpdated(address indexed stEthFeed);\\n\\n    // --- Structs ---\\n\\n    struct ChainlinkResponse {\\n        uint80 roundEthBtcId;\\n        uint80 roundStEthEthId;\\n        uint256 answer;\\n        uint256 timestampEthBtc;\\n        uint256 timestampStEthEth;\\n        bool success;\\n    }\\n\\n    struct FallbackResponse {\\n        uint256 answer;\\n        uint256 timestamp;\\n        bool success;\\n    }\\n\\n    // --- Enum ---\\n\\n    enum Status {\\n        chainlinkWorking,\\n        usingFallbackChainlinkUntrusted,\\n        bothOraclesUntrusted,\\n        usingFallbackChainlinkFrozen,\\n        usingChainlinkFallbackUntrusted\\n    }\\n\\n    // --- Function ---\\n    function fetchPrice() external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IRecoveryModeGracePeriod.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Interface for State Updates that can trigger RM Liquidations\\ninterface IRecoveryModeGracePeriod {\\n    event TCRNotified(uint256 TCR); /// NOTE: Mostly for debugging to ensure synch\\n\\n    // NOTE: Ts is implicit in events (it's added by GETH)\\n    event GracePeriodStart();\\n    event GracePeriodEnd();\\n    event GracePeriodDurationSet(uint256 _recoveryModeGracePeriodDuration);\\n\\n    function notifyStartGracePeriod(uint256 tcr) external;\\n\\n    function notifyEndGracePeriod(uint256 tcr) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ISortedCdps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n// Common interface for the SortedCdps Doubly Linked List.\\ninterface ISortedCdps {\\n    // --- Events ---\\n\\n    event NodeAdded(bytes32 _id, uint _NICR);\\n    event NodeRemoved(bytes32 _id);\\n\\n    // --- Functions ---\\n\\n    function remove(bytes32 _id) external;\\n\\n    function batchRemove(bytes32[] memory _ids) external;\\n\\n    function reInsert(bytes32 _id, uint256 _newICR, bytes32 _prevId, bytes32 _nextId) external;\\n\\n    function contains(bytes32 _id) external view returns (bool);\\n\\n    function isFull() external view returns (bool);\\n\\n    function isEmpty() external view returns (bool);\\n\\n    function getSize() external view returns (uint256);\\n\\n    function getMaxSize() external view returns (uint256);\\n\\n    function getFirst() external view returns (bytes32);\\n\\n    function getLast() external view returns (bytes32);\\n\\n    function getNext(bytes32 _id) external view returns (bytes32);\\n\\n    function getPrev(bytes32 _id) external view returns (bytes32);\\n\\n    function validInsertPosition(\\n        uint256 _ICR,\\n        bytes32 _prevId,\\n        bytes32 _nextId\\n    ) external view returns (bool);\\n\\n    function findInsertPosition(\\n        uint256 _ICR,\\n        bytes32 _prevId,\\n        bytes32 _nextId\\n    ) external view returns (bytes32, bytes32);\\n\\n    function insert(\\n        address owner,\\n        uint256 _ICR,\\n        bytes32 _prevId,\\n        bytes32 _nextId\\n    ) external returns (bytes32);\\n\\n    function getOwnerAddress(bytes32 _id) external pure returns (address);\\n\\n    function nonExistId() external view returns (bytes32);\\n\\n    function cdpCountOf(address owner) external view returns (uint256);\\n\\n    function getCdpCountOf(\\n        address owner,\\n        bytes32 startNodeId,\\n        uint maxNodes\\n    ) external view returns (uint256, bytes32);\\n\\n    function getCdpsOf(address owner) external view returns (bytes32[] memory);\\n\\n    function getAllCdpsOf(\\n        address owner,\\n        bytes32 startNodeId,\\n        uint maxNodes\\n    ) external view returns (bytes32[] memory, uint256, bytes32);\\n\\n    function cdpOfOwnerByIndex(address owner, uint256 index) external view returns (bytes32);\\n\\n    function cdpOfOwnerByIdx(\\n        address owner,\\n        uint256 index,\\n        bytes32 startNodeId,\\n        uint maxNodes\\n    ) external view returns (bytes32, bool);\\n\\n    function toCdpId(\\n        address owner,\\n        uint256 blockHeight,\\n        uint256 nonce\\n    ) external pure returns (bytes32);\\n\\n    function nextCdpNonce() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ITwapWeightedObserver.sol\": {\r\n      \"content\": \"// SPDX-License Identifier: MIT\\npragma solidity 0.8.17;\\nimport {IBaseTwapWeightedObserver} from \\\"./IBaseTwapWeightedObserver.sol\\\";\\n\\ninterface ITwapWeightedObserver is IBaseTwapWeightedObserver {\\n    event TwapDisabled();\\n\\n    function PERIOD() external view returns (uint256);\\n\\n    function valueToTrack() external view returns (uint128);\\n\\n    function timeToAccrue() external view returns (uint64);\\n\\n    function getLatestAccumulator() external view returns (uint128);\\n\\n    function observe() external returns (uint256);\\n\\n    function update() external;\\n\\n    function twapDisabled() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cdpManagerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_activePoolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collSurplusPoolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeedAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sortedCdpsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ebtcTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeRecipientAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collTokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_feeRecipientAddress\",\"type\":\"address\"}],\"name\":\"FeeRecipientAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_setter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"FlashFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"FlashLoanSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_setter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"FlashLoansPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_setter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_oldMaxFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newMaxFee\",\"type\":\"uint256\"}],\"name\":\"MaxFlashFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum IPositionManagers.PositionManagerApproval\",\"name\":\"_approval\",\"type\":\"uint8\"}],\"name\":\"PositionManagerApprovalSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BORROWING_FEE_FLOOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMAL_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FLASH_SUCCESS_VALUE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LICR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDATOR_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_REWARD_SPLIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_CHANGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_NET_STETH_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENT_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKING_REWARD_SPLIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activePool\",\"outputs\":[{\"internalType\":\"contract IActivePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_stEthBalanceIncrease\",\"type\":\"uint256\"}],\"name\":\"addColl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_stEthBalanceDecrease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtChange\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isDebtIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"}],\"name\":\"adjustCdp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_stEthBalanceDecrease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtChange\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isDebtIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_stEthBalanceIncrease\",\"type\":\"uint256\"}],\"name\":\"adjustCdpWithColl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authorityInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cdpManager\",\"outputs\":[{\"internalType\":\"contract ICdpManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimSurplusCollShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"}],\"name\":\"closeCdp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collSurplusPool\",\"outputs\":[{\"internalType\":\"contract ICollSurplusPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"contract ICollateralToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ebtcToken\",\"outputs\":[{\"internalType\":\"contract IEBTCToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBps\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipientAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"flashFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC3156FlashBorrower\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashLoansPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"}],\"name\":\"getPositionManagerApproval\",\"outputs\":[{\"internalType\":\"enum IPositionManagers.PositionManagerApproval\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSystemCollShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"entireSystemColl\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"increasePermitNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"maxFlashLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_stEthBalance\",\"type\":\"uint256\"}],\"name\":\"openCdp\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_stEthBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"openCdpFor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"enum IPositionManagers.PositionManagerApproval\",\"name\":\"_approval\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permitPositionManagerApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permitTypeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"positionManagers\",\"outputs\":[{\"internalType\":\"enum IPositionManagers.PositionManagerApproval\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"renouncePositionManagerApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"}],\"name\":\"repayDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"}],\"name\":\"revokePositionManagerApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"setFeeBps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setFlashLoansPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"enum IPositionManagers.PositionManagerApproval\",\"name\":\"_approval\",\"type\":\"uint8\"}],\"name\":\"setPositionManagerApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortedCdps\",\"outputs\":[{\"internalType\":\"contract ISortedCdps\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_stEthBalanceDecrease\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"}],\"name\":\"withdrawColl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cdpId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_upperHint\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_lowerHint\",\"type\":\"bytes32\"}],\"name\":\"withdrawDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BorrowerOperations", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003c672ee8e13cde7617923658138b111e157c89970000000000000000000000001e3bf0965dca89cd057d63c0cd65a37acf920590000000000000000000000000596efaf17dfb3fd2cae7543ffa399f6e31658e4d0000000000000000000000004039ca03ce49021655c9b7c52ab817d42db7325e0000000000000000000000006cb99cf839c5ad3c24431c85da5fdb7c7ab66d97000000000000000000000000ead18fd27caa1cff909b5f2bd26ac9a46a6ab1b50000000000000000000000002ceb95d4a67bf771f1165659df3d11d8871e906f000000000000000000000000ae7ab96520de3a18e5e111b5eaab095312d7fe84", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}