{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/common/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ncontract EIP712 {\\n    // --- Public fields ---\\n\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n\\n    // --- Constructor ---\\n\\n    constructor(bytes memory name, bytes memory version) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(\\\"\\n                    \\\"string name,\\\"\\n                    \\\"string version,\\\"\\n                    \\\"uint256 chainId,\\\"\\n                    \\\"address verifyingContract\\\"\\n                    \\\")\\\"\\n                ),\\n                keccak256(name),\\n                keccak256(version),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    // --- Internal methods ---\\n\\n    function getEIP712Hash(\\n        bytes32 structHash\\n    ) internal view returns (bytes32 eip712Hash) {\\n        eip712Hash = keccak256(\\n            abi.encodePacked(hex\\\"1901\\\", DOMAIN_SEPARATOR, structHash)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/SignatureVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {IEIP1271} from \\\"../interfaces/IEIP1271.sol\\\";\\n\\ncontract SignatureVerifier {\\n    // --- Errors ---\\n\\n    error InvalidSignature();\\n\\n    // --- Internal methods ---\\n\\n    function verifySignature(\\n        address signer,\\n        bytes32 eip712Hash,\\n        bytes calldata signature\\n    ) internal view {\\n        if (signer.code.length == 0) {\\n            (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\\n\\n            address actualSigner = ecrecover(eip712Hash, v, r, s);\\n            if (actualSigner == address(0) || actualSigner != signer) {\\n                revert InvalidSignature();\\n            }\\n        } else {\\n            if (\\n                IEIP1271(signer).isValidSignature(eip712Hash, signature) !=\\n                IEIP1271.isValidSignature.selector\\n            ) {\\n                revert InvalidSignature();\\n            }\\n        }\\n    }\\n\\n    function splitSignature(\\n        bytes calldata signature\\n    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\\n        uint256 length = signature.length;\\n        if (length == 65) {\\n            assembly {\\n                r := calldataload(signature.offset)\\n                s := calldataload(add(signature.offset, 0x20))\\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\\n            }\\n        } else if (length == 64) {\\n            assembly {\\n                r := calldataload(signature.offset)\\n                let vs := calldataload(add(signature.offset, 0x20))\\n                s := and(\\n                    vs,\\n                    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n                )\\n                v := add(shr(255, vs), 27)\\n            }\\n        } else {\\n            revert InvalidSignature();\\n        }\\n\\n        if (\\n            uint256(s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) {\\n            revert InvalidSignature();\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            revert InvalidSignature();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CrossChainEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {EIP712} from \\\"./common/EIP712.sol\\\";\\nimport {SignatureVerifier} from \\\"./common/SignatureVerifier.sol\\\";\\n\\ncontract CrossChainEscrow is EIP712, SignatureVerifier {\\n    // --- Structs ---\\n\\n    struct Request {\\n        bool isCollectionRequest;\\n        address maker;\\n        address solver;\\n        address token;\\n        uint256 tokenId;\\n        uint256 amount;\\n        uint256 price;\\n        address recipient;\\n        uint256 chainId;\\n        uint256 deadline;\\n        uint256 salt;\\n    }\\n\\n    struct RequestStatus {\\n        bool isExecuted;\\n    }\\n\\n    struct Withdraw {\\n        address solver;\\n        address user;\\n        uint256 amount;\\n        uint256 deadline;\\n        uint256 salt;\\n    }\\n\\n    struct WithdrawStatus {\\n        bool isExecuted;\\n    }\\n\\n    // --- Events ---\\n\\n    event Deposited(address user, address solver, uint256 amount);\\n\\n    event RequestExecuted(bytes32 requestHash);\\n    event WithdrawExecuted(\\n        bytes32 withdrawHash,\\n        address user,\\n        address solver,\\n        uint256 amount\\n    );\\n\\n    // --- Errors ---\\n\\n    error RequestIsExecuted();\\n    error RequestIsExpired();\\n\\n    error WithdrawIsExecuted();\\n    error WithdrawIsExpired();\\n\\n    error Unauthorized();\\n    error UnsuccessfulCall();\\n\\n    // --- Fields ---\\n\\n    bytes32 public immutable REQUEST_TYPEHASH;\\n    bytes32 public immutable WITHDRAW_TYPEHASH;\\n\\n    // Keep track of the user's deposited balance per solver\\n    mapping(address => mapping(address => uint256)) public perSolverBalance;\\n\\n    // Keep track of request and withdraw statuses\\n    mapping(bytes32 => RequestStatus) public requestStatus;\\n    mapping(bytes32 => WithdrawStatus) public withdrawStatus;\\n\\n    // --- Constructor ---\\n\\n    constructor() EIP712(\\\"CrossChainEscrow\\\", \\\"1\\\") {\\n        REQUEST_TYPEHASH = keccak256(\\n            abi.encodePacked(\\n                \\\"Request(\\\",\\n                \\\"bool isCollectionRequest,\\\",\\n                \\\"address maker,\\\",\\n                \\\"address solver,\\\",\\n                \\\"address token,\\\",\\n                \\\"uint256 tokenId,\\\",\\n                \\\"uint256 amount,\\\",\\n                \\\"uint256 price,\\\",\\n                \\\"address recipient,\\\",\\n                \\\"uint256 chainId,\\\",\\n                \\\"uint256 deadline,\\\",\\n                \\\"uint256 salt\\\"\\n                \\\")\\\"\\n            )\\n        );\\n\\n        WITHDRAW_TYPEHASH = keccak256(\\n            abi.encodePacked(\\n                \\\"Withdraw(\\\",\\n                \\\"address solver,\\\",\\n                \\\"address user,\\\",\\n                \\\"uint256 amount,\\\",\\n                \\\"uint256 deadline,\\\",\\n                \\\"uint256 salt\\\",\\n                \\\")\\\"\\n            )\\n        );\\n    }\\n\\n    // --- Public methods ---\\n\\n    function deposit(address solver) external payable {\\n        perSolverBalance[msg.sender][solver] += msg.value;\\n\\n        emit Deposited(msg.sender, solver, msg.value);\\n    }\\n\\n    function executeWithdraw(\\n        Withdraw calldata withdraw,\\n        bytes calldata signature\\n    ) external {\\n        address solver = withdraw.solver;\\n        address user = withdraw.user;\\n        uint256 amount = withdraw.amount;\\n\\n        if (msg.sender != user) {\\n            revert Unauthorized();\\n        }\\n\\n        if (withdraw.deadline < block.timestamp) {\\n            revert WithdrawIsExpired();\\n        }\\n\\n        bytes32 withdrawHash = getWithdrawHash(withdraw);\\n        bytes32 eip712Hash = getEIP712Hash(withdrawHash);\\n        verifySignature(solver, eip712Hash, signature);\\n\\n        WithdrawStatus memory status = withdrawStatus[withdrawHash];\\n        if (status.isExecuted) {\\n            revert WithdrawIsExecuted();\\n        }\\n\\n        withdrawStatus[withdrawHash].isExecuted = true;\\n\\n        perSolverBalance[user][solver] -= amount;\\n        send(user, amount);\\n\\n        emit WithdrawExecuted(withdrawHash, user, solver, amount);\\n    }\\n\\n    // --- Solver methods ---\\n\\n    function executeRequest(\\n        Request calldata request,\\n        bytes calldata signature\\n    ) external {\\n        address solver = request.solver;\\n        address maker = request.maker;\\n        uint256 price = request.price;\\n\\n        if (msg.sender != solver) {\\n            revert Unauthorized();\\n        }\\n\\n        if (request.deadline < block.timestamp) {\\n            revert RequestIsExpired();\\n        }\\n\\n        bytes32 requestHash = getRequestHash(request);\\n        bytes32 eip712Hash = getEIP712Hash(requestHash);\\n        verifySignature(maker, eip712Hash, signature);\\n\\n        RequestStatus memory status = requestStatus[requestHash];\\n        if (status.isExecuted) {\\n            revert RequestIsExecuted();\\n        }\\n\\n        requestStatus[requestHash].isExecuted = true;\\n\\n        perSolverBalance[maker][solver] -= price;\\n        send(solver, price);\\n\\n        emit RequestExecuted(requestHash);\\n    }\\n\\n    // --- View methods ---\\n\\n    function getRequestHash(\\n        Request calldata request\\n    ) public view returns (bytes32 requestHash) {\\n        requestHash = keccak256(\\n            abi.encode(\\n                REQUEST_TYPEHASH,\\n                request.isCollectionRequest,\\n                request.maker,\\n                request.solver,\\n                request.token,\\n                request.tokenId,\\n                request.amount,\\n                request.price,\\n                request.recipient,\\n                request.chainId,\\n                request.deadline,\\n                request.salt\\n            )\\n        );\\n    }\\n\\n    function getWithdrawHash(\\n        Withdraw calldata withdraw\\n    ) public view returns (bytes32 withdrawHash) {\\n        withdrawHash = keccak256(\\n            abi.encode(\\n                WITHDRAW_TYPEHASH,\\n                withdraw.solver,\\n                withdraw.user,\\n                withdraw.amount,\\n                withdraw.deadline,\\n                withdraw.salt\\n            )\\n        );\\n    }\\n\\n    // --- Internal methods ---\\n\\n    function send(address to, uint256 amount) internal {\\n        (bool result, ) = to.call{value: amount}(\\\"\\\");\\n        if (!result) {\\n            revert UnsuccessfulCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEIP1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IEIP1271 {\\n    function isValidSignature(\\n        bytes32 eip712Hash,\\n        bytes calldata signature\\n    ) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequestIsExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequestIsExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsuccessfulCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawIsExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawIsExpired\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestHash\",\"type\":\"bytes32\"}],\"name\":\"RequestExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"withdrawHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawExecuted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REQUEST_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WITHDRAW_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCollectionRequest\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct CrossChainEscrow.Request\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"executeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct CrossChainEscrow.Withdraw\",\"name\":\"withdraw\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"executeWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCollectionRequest\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct CrossChainEscrow.Request\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"getRequestHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct CrossChainEscrow.Withdraw\",\"name\":\"withdraw\",\"type\":\"tuple\"}],\"name\":\"getWithdrawHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"withdrawHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"perSolverBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requestStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExecuted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExecuted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CrossChainEscrow", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}