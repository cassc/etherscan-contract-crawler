{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC5267.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\\n\\npragma solidity ^0.8.20;\\n\\ninterface IERC5267 {\\n    /**\\n     * @dev MAY be emitted to signal that the domain could have changed.\\n     */\\n    event EIP712DomainChanged();\\n\\n    /**\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\n     * signature.\\n     */\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Proxy} from \\\"../Proxy.sol\\\";\\nimport {ERC1967Utils} from \\\"./ERC1967Utils.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an\\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - If `data` is empty, `msg.value` must be zero.\\n     */\\n    constructor(address implementation, bytes memory _data) payable {\\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return ERC1967Utils.getImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\\n     * function and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEthVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IVaultAdmin} from './IVaultAdmin.sol';\\nimport {IVaultVersion} from './IVaultVersion.sol';\\nimport {IVaultFee} from './IVaultFee.sol';\\nimport {IVaultState} from './IVaultState.sol';\\nimport {IVaultValidators} from './IVaultValidators.sol';\\nimport {IVaultEnterExit} from './IVaultEnterExit.sol';\\nimport {IVaultOsToken} from './IVaultOsToken.sol';\\nimport {IVaultMev} from './IVaultMev.sol';\\nimport {IVaultEthStaking} from './IVaultEthStaking.sol';\\nimport {IMulticall} from './IMulticall.sol';\\n\\n/**\\n * @title IEthVault\\n * @author StakeWise\\n * @notice Defines the interface for the EthVault contract\\n */\\ninterface IEthVault is\\n  IVaultAdmin,\\n  IVaultVersion,\\n  IVaultFee,\\n  IVaultState,\\n  IVaultValidators,\\n  IVaultEnterExit,\\n  IVaultOsToken,\\n  IVaultMev,\\n  IVaultEthStaking,\\n  IMulticall\\n{\\n  /**\\n   * @dev Struct for initializing the EthVault contract\\n   * @param capacity The Vault stops accepting deposits after exceeding the capacity\\n   * @param feePercent The fee percent that is charged by the Vault\\n   * @param metadataIpfsHash The IPFS hash of the Vault's metadata file\\n   */\\n  struct EthVaultInitParams {\\n    uint256 capacity;\\n    uint16 feePercent;\\n    string metadataIpfsHash;\\n  }\\n\\n  /**\\n   * @notice Initializes the EthVault contract. Must transfer security deposit together with a call.\\n   * @param params The encoded parameters for initializing the EthVault contract\\n   */\\n  function initialize(bytes calldata params) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEthVaultFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\n/**\\n * @title IEthVaultFactory\\n * @author StakeWise\\n * @notice Defines the interface for the ETH Vault Factory contract\\n */\\ninterface IEthVaultFactory {\\n  /**\\n   * @notice Event emitted on a Vault creation\\n   * @param admin The address of the Vault admin\\n   * @param vault The address of the created Vault\\n   * @param ownMevEscrow The address of the own MEV escrow contract. Zero address if shared MEV escrow is used.\\n   * @param params The encoded parameters for initializing the Vault contract\\n   */\\n  event VaultCreated(\\n    address indexed admin,\\n    address indexed vault,\\n    address ownMevEscrow,\\n    bytes params\\n  );\\n\\n  /**\\n   * @notice The address of the Vault implementation contract used for proxy creation\\n   * @return The address of the Vault implementation contract\\n   */\\n  function implementation() external view returns (address);\\n\\n  /**\\n   * @notice The address of the own MEV escrow contract used for Vault creation\\n   * @return The address of the MEV escrow contract\\n   */\\n  function ownMevEscrow() external view returns (address);\\n\\n  /**\\n   * @notice The address of the Vault admin used for Vault creation\\n   * @return The address of the Vault admin\\n   */\\n  function vaultAdmin() external view returns (address);\\n\\n  /**\\n   * @notice Create Vault. Must transfer security deposit together with a call.\\n   * @param params The encoded parameters for initializing the Vault contract\\n   * @param isOwnMevEscrow Whether to deploy own escrow contract or connect to a smoothing pool for priority fees and MEV rewards\\n   * @return vault The address of the created Vault\\n   */\\n  function createVault(\\n    bytes calldata params,\\n    bool isOwnMevEscrow\\n  ) external payable returns (address vault);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKeeperOracles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IERC5267} from '@openzeppelin/contracts/interfaces/IERC5267.sol';\\n\\n/**\\n * @title IKeeperOracles\\n * @author StakeWise\\n * @notice Defines the interface for the KeeperOracles contract\\n */\\ninterface IKeeperOracles is IERC5267 {\\n  /**\\n   * @notice Event emitted on the oracle addition\\n   * @param oracle The address of the added oracle\\n   */\\n  event OracleAdded(address indexed oracle);\\n\\n  /**\\n   * @notice Event emitted on the oracle removal\\n   * @param oracle The address of the removed oracle\\n   */\\n  event OracleRemoved(address indexed oracle);\\n\\n  /**\\n   * @notice Event emitted on oracles config update\\n   * @param configIpfsHash The IPFS hash of the new config\\n   */\\n  event ConfigUpdated(string configIpfsHash);\\n\\n  /**\\n   * @notice Function for verifying whether oracle is registered or not\\n   * @param oracle The address of the oracle to check\\n   * @return `true` for the registered oracle, `false` otherwise\\n   */\\n  function isOracle(address oracle) external view returns (bool);\\n\\n  /**\\n   * @notice Total Oracles\\n   * @return The total number of oracles registered\\n   */\\n  function totalOracles() external view returns (uint256);\\n\\n  /**\\n   * @notice Function for adding oracle to the set\\n   * @param oracle The address of the oracle to add\\n   */\\n  function addOracle(address oracle) external;\\n\\n  /**\\n   * @notice Function for removing oracle from the set\\n   * @param oracle The address of the oracle to remove\\n   */\\n  function removeOracle(address oracle) external;\\n\\n  /**\\n   * @notice Function for updating the config IPFS hash\\n   * @param configIpfsHash The new config IPFS hash\\n   */\\n  function updateConfig(string calldata configIpfsHash) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKeeperRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IKeeperOracles} from './IKeeperOracles.sol';\\n\\n/**\\n * @title IKeeperRewards\\n * @author StakeWise\\n * @notice Defines the interface for the Keeper contract rewards\\n */\\ninterface IKeeperRewards is IKeeperOracles {\\n  /**\\n   * @notice Event emitted on rewards update\\n   * @param caller The address of the function caller\\n   * @param rewardsRoot The new rewards merkle tree root\\n   * @param avgRewardPerSecond The new average reward per second\\n   * @param updateTimestamp The update timestamp used for rewards calculation\\n   * @param nonce The nonce used for verifying signatures\\n   * @param rewardsIpfsHash The new rewards IPFS hash\\n   */\\n  event RewardsUpdated(\\n    address indexed caller,\\n    bytes32 indexed rewardsRoot,\\n    uint256 avgRewardPerSecond,\\n    uint64 updateTimestamp,\\n    uint64 nonce,\\n    string rewardsIpfsHash\\n  );\\n\\n  /**\\n   * @notice Event emitted on Vault harvest\\n   * @param vault The address of the Vault\\n   * @param rewardsRoot The rewards merkle tree root\\n   * @param totalAssetsDelta The Vault total assets delta since last sync. Can be negative in case of penalty/slashing.\\n   * @param unlockedMevDelta The Vault execution reward that can be withdrawn from shared MEV escrow. Only used by shared MEV Vaults.\\n   */\\n  event Harvested(\\n    address indexed vault,\\n    bytes32 indexed rewardsRoot,\\n    int256 totalAssetsDelta,\\n    uint256 unlockedMevDelta\\n  );\\n\\n  /**\\n   * @notice Event emitted on rewards min oracles number update\\n   * @param oracles The new minimum number of oracles required to update rewards\\n   */\\n  event RewardsMinOraclesUpdated(uint256 oracles);\\n\\n  /**\\n   * @notice A struct containing the last synced Vault's cumulative reward\\n   * @param assets The Vault cumulative reward earned since the start. Can be negative in case of penalty/slashing.\\n   * @param nonce The nonce of the last sync\\n   */\\n  struct Reward {\\n    int192 assets;\\n    uint64 nonce;\\n  }\\n\\n  /**\\n   * @notice A struct containing the last unlocked Vault's cumulative execution reward that can be withdrawn from shared MEV escrow. Only used by shared MEV Vaults.\\n   * @param assets The shared MEV Vault's cumulative execution reward that can be withdrawn\\n   * @param nonce The nonce of the last sync\\n   */\\n  struct UnlockedMevReward {\\n    uint192 assets;\\n    uint64 nonce;\\n  }\\n\\n  /**\\n   * @notice A struct containing parameters for rewards update\\n   * @param rewardsRoot The new rewards merkle root\\n   * @param avgRewardPerSecond The new average reward per second\\n   * @param updateTimestamp The update timestamp used for rewards calculation\\n   * @param rewardsIpfsHash The new IPFS hash with all the Vaults' rewards for the new root\\n   * @param signatures The concatenation of the Oracles' signatures\\n   */\\n  struct RewardsUpdateParams {\\n    bytes32 rewardsRoot;\\n    uint256 avgRewardPerSecond;\\n    uint64 updateTimestamp;\\n    string rewardsIpfsHash;\\n    bytes signatures;\\n  }\\n\\n  /**\\n   * @notice A struct containing parameters for harvesting rewards. Can only be called by Vault.\\n   * @param rewardsRoot The rewards merkle root\\n   * @param reward The Vault cumulative reward earned since the start. Can be negative in case of penalty/slashing.\\n   * @param unlockedMevReward The Vault cumulative execution reward that can be withdrawn from shared MEV escrow. Only used by shared MEV Vaults.\\n   * @param proof The proof to verify that Vault's reward is correct\\n   */\\n  struct HarvestParams {\\n    bytes32 rewardsRoot;\\n    int160 reward;\\n    uint160 unlockedMevReward;\\n    bytes32[] proof;\\n  }\\n\\n  /**\\n   * @notice Previous Rewards Root\\n   * @return The previous merkle tree root of the rewards accumulated by the Vaults\\n   */\\n  function prevRewardsRoot() external view returns (bytes32);\\n\\n  /**\\n   * @notice Rewards Root\\n   * @return The latest merkle tree root of the rewards accumulated by the Vaults\\n   */\\n  function rewardsRoot() external view returns (bytes32);\\n\\n  /**\\n   * @notice Rewards Nonce\\n   * @return The nonce used for updating rewards merkle tree root\\n   */\\n  function rewardsNonce() external view returns (uint64);\\n\\n  /**\\n   * @notice The last rewards update\\n   * @return The timestamp of the last rewards update\\n   */\\n  function lastRewardsTimestamp() external view returns (uint64);\\n\\n  /**\\n   * @notice The minimum number of oracles required to update rewards\\n   * @return The minimum number of oracles\\n   */\\n  function rewardsMinOracles() external view returns (uint256);\\n\\n  /**\\n   * @notice The rewards delay\\n   * @return The delay in seconds between rewards updates\\n   */\\n  function rewardsDelay() external view returns (uint256);\\n\\n  /**\\n   * @notice Get last synced Vault cumulative reward\\n   * @param vault The address of the Vault\\n   * @return assets The last synced reward assets\\n   * @return nonce The last synced reward nonce\\n   */\\n  function rewards(address vault) external view returns (int192 assets, uint64 nonce);\\n\\n  /**\\n   * @notice Get last unlocked shared MEV Vault cumulative reward\\n   * @param vault The address of the Vault\\n   * @return assets The last synced reward assets\\n   * @return nonce The last synced reward nonce\\n   */\\n  function unlockedMevRewards(address vault) external view returns (uint192 assets, uint64 nonce);\\n\\n  /**\\n   * @notice Checks whether Vault must be harvested\\n   * @param vault The address of the Vault\\n   * @return `true` if the Vault requires harvesting, `false` otherwise\\n   */\\n  function isHarvestRequired(address vault) external view returns (bool);\\n\\n  /**\\n   * @notice Checks whether the Vault can be harvested\\n   * @param vault The address of the Vault\\n   * @return `true` if Vault can be harvested, `false` otherwise\\n   */\\n  function canHarvest(address vault) external view returns (bool);\\n\\n  /**\\n   * @notice Checks whether rewards can be updated\\n   * @return `true` if rewards can be updated, `false` otherwise\\n   */\\n  function canUpdateRewards() external view returns (bool);\\n\\n  /**\\n   * @notice Checks whether the Vault has registered validators\\n   * @param vault The address of the Vault\\n   * @return `true` if Vault is collateralized, `false` otherwise\\n   */\\n  function isCollateralized(address vault) external view returns (bool);\\n\\n  /**\\n   * @notice Update rewards data\\n   * @param params The struct containing rewards update parameters\\n   */\\n  function updateRewards(RewardsUpdateParams calldata params) external;\\n\\n  /**\\n   * @notice Harvest rewards. Can be called only by Vault.\\n   * @param params The struct containing rewards harvesting parameters\\n   * @return totalAssetsDelta The total reward/penalty accumulated by the Vault since the last sync\\n   * @return unlockedMevDelta The Vault execution reward that can be withdrawn from shared MEV escrow. Only used by shared MEV Vaults.\\n   * @return harvested `true` when the rewards were harvested, `false` otherwise\\n   */\\n  function harvest(\\n    HarvestParams calldata params\\n  ) external returns (int256 totalAssetsDelta, uint256 unlockedMevDelta, bool harvested);\\n\\n  /**\\n   * @notice Set min number of oracles for confirming rewards update. Can only be called by the owner.\\n   * @param _rewardsMinOracles The new min number of oracles for confirming rewards update\\n   */\\n  function setRewardsMinOracles(uint256 _rewardsMinOracles) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKeeperValidators.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IKeeperRewards} from './IKeeperRewards.sol';\\nimport {IKeeperOracles} from './IKeeperOracles.sol';\\n\\n/**\\n * @title IKeeperValidators\\n * @author StakeWise\\n * @notice Defines the interface for the Keeper validators\\n */\\ninterface IKeeperValidators is IKeeperOracles, IKeeperRewards {\\n  /**\\n   * @notice Event emitted on validators approval\\n   * @param vault The address of the Vault\\n   * @param exitSignaturesIpfsHash The IPFS hash with the validators' exit signatures\\n   */\\n  event ValidatorsApproval(address indexed vault, string exitSignaturesIpfsHash);\\n\\n  /**\\n   * @notice Event emitted on exit signatures update\\n   * @param caller The address of the function caller\\n   * @param vault The address of the Vault\\n   * @param nonce The nonce used for verifying Oracles' signatures\\n   * @param exitSignaturesIpfsHash The IPFS hash with the validators' exit signatures\\n   */\\n  event ExitSignaturesUpdated(\\n    address indexed caller,\\n    address indexed vault,\\n    uint256 nonce,\\n    string exitSignaturesIpfsHash\\n  );\\n\\n  /**\\n   * @notice Event emitted on validators min oracles number update\\n   * @param oracles The new minimum number of oracles required to approve validators\\n   */\\n  event ValidatorsMinOraclesUpdated(uint256 oracles);\\n\\n  /**\\n   * @notice Get nonce for the next vault exit signatures update\\n   * @param vault The address of the Vault to get the nonce for\\n   * @return The nonce of the Vault for updating signatures\\n   */\\n  function exitSignaturesNonces(address vault) external view returns (uint256);\\n\\n  /**\\n   * @notice Struct for approving registration of one or more validators\\n   * @param validatorsRegistryRoot The deposit data root used to verify that oracles approved validators\\n   * @param deadline The deadline for submitting the approval\\n   * @param validators The concatenation of the validators' public key, signature and deposit data root\\n   * @param signatures The concatenation of Oracles' signatures\\n   * @param exitSignaturesIpfsHash The IPFS hash with the validators' exit signatures\\n   */\\n  struct ApprovalParams {\\n    bytes32 validatorsRegistryRoot;\\n    uint256 deadline;\\n    bytes validators;\\n    bytes signatures;\\n    string exitSignaturesIpfsHash;\\n  }\\n\\n  /**\\n   * @notice The minimum number of oracles required to update validators\\n   * @return The minimum number of oracles\\n   */\\n  function validatorsMinOracles() external view returns (uint256);\\n\\n  /**\\n   * @notice Function for approving validators registration\\n   * @param params The parameters for approving validators registration\\n   */\\n  function approveValidators(ApprovalParams calldata params) external;\\n\\n  /**\\n   * @notice Function for updating exit signatures for every hard fork\\n   * @param vault The address of the Vault to update signatures for\\n   * @param deadline The deadline for submitting signatures update\\n   * @param exitSignaturesIpfsHash The IPFS hash with the validators' exit signatures\\n   * @param oraclesSignatures The concatenation of Oracles' signatures\\n   */\\n  function updateExitSignatures(\\n    address vault,\\n    uint256 deadline,\\n    string calldata exitSignaturesIpfsHash,\\n    bytes calldata oraclesSignatures\\n  ) external;\\n\\n  /**\\n   * @notice Function for updating validators min oracles number\\n   * @param _validatorsMinOracles The new minimum number of oracles required to approve validators\\n   */\\n  function setValidatorsMinOracles(uint256 _validatorsMinOracles) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity =0.8.22;\\n\\n/**\\n * @title Multicall\\n * @author Uniswap\\n * @notice Adopted from https://github.com/Uniswap/v3-periphery/blob/1d69caf0d6c8cfeae9acd1f34ead30018d6e6400/contracts/base/Multicall.sol\\n * @notice Enables calling multiple methods in a single call to the contract\\n */\\ninterface IMulticall {\\n  /**\\n   * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n   * @param data The encoded function data for each of the calls to make to this contract\\n   * @return results The results from each of the calls passed in via data\\n   */\\n  function multicall(bytes[] calldata data) external returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOwnMevEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\n/**\\n * @title IOwnMevEscrow\\n * @author StakeWise\\n * @notice Defines the interface for the OwnMevEscrow contract\\n */\\ninterface IOwnMevEscrow {\\n  /**\\n   * @notice Event emitted on received MEV\\n   * @param assets The amount of MEV assets received\\n   */\\n  event MevReceived(uint256 assets);\\n\\n  /**\\n   * @notice Event emitted on harvest\\n   * @param assets The amount of assets withdrawn\\n   */\\n  event Harvested(uint256 assets);\\n\\n  /**\\n   * @notice Vault address\\n   * @return The address of the vault that owns the escrow\\n   */\\n  function vault() external view returns (address payable);\\n\\n  /**\\n   * @notice Withdraws MEV accumulated in the escrow. Can be called only by the Vault.\\n   * @dev IMPORTANT: because control is transferred to the Vault, care must be\\n   *    taken to not create reentrancy vulnerabilities. The Vault must follow the checks-effects-interactions pattern:\\n   *    https://docs.soliditylang.org/en/v0.8.22/security-considerations.html#use-the-checks-effects-interactions-pattern\\n   * @return assets The amount of assets withdrawn\\n   */\\n  function harvest() external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\n/**\\n * @title IVaultState\\n * @author StakeWise\\n * @notice Defines the interface for the VaultAdmin contract\\n */\\ninterface IVaultAdmin {\\n  /**\\n   * @notice Event emitted on metadata ipfs hash update\\n   * @param caller The address of the function caller\\n   * @param metadataIpfsHash The new metadata IPFS hash\\n   */\\n  event MetadataUpdated(address indexed caller, string metadataIpfsHash);\\n\\n  /**\\n   * @notice The Vault admin\\n   * @return The address of the Vault admin\\n   */\\n  function admin() external view returns (address);\\n\\n  /**\\n   * @notice Function for updating the metadata IPFS hash. Can only be called by Vault admin.\\n   * @param metadataIpfsHash The new metadata IPFS hash\\n   */\\n  function setMetadata(string calldata metadataIpfsHash) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultEnterExit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IVaultState} from './IVaultState.sol';\\n\\n/**\\n * @title IVaultEnterExit\\n * @author StakeWise\\n * @notice Defines the interface for the VaultEnterExit contract\\n */\\ninterface IVaultEnterExit is IVaultState {\\n  /**\\n   * @notice Event emitted on deposit\\n   * @param caller The address that called the deposit function\\n   * @param receiver The address that received the shares\\n   * @param assets The number of assets deposited by the caller\\n   * @param shares The number of shares received\\n   * @param referrer The address of the referrer\\n   */\\n  event Deposited(\\n    address indexed caller,\\n    address indexed receiver,\\n    uint256 assets,\\n    uint256 shares,\\n    address referrer\\n  );\\n\\n  /**\\n   * @notice Event emitted on redeem\\n   * @param owner The address that owns the shares\\n   * @param receiver The address that received withdrawn assets\\n   * @param assets The total number of withdrawn assets\\n   * @param shares The total number of withdrawn shares\\n   */\\n  event Redeemed(address indexed owner, address indexed receiver, uint256 assets, uint256 shares);\\n\\n  /**\\n   * @notice Event emitted on shares added to the exit queue\\n   * @param owner The address that owns the shares\\n   * @param receiver The address that will receive withdrawn assets\\n   * @param positionTicket The exit queue ticket that was assigned to the position\\n   * @param shares The number of shares that queued for the exit\\n   */\\n  event ExitQueueEntered(\\n    address indexed owner,\\n    address indexed receiver,\\n    uint256 positionTicket,\\n    uint256 shares\\n  );\\n\\n  /**\\n   * @notice Event emitted on claim of the exited assets\\n   * @param receiver The address that has received withdrawn assets\\n   * @param prevPositionTicket The exit queue ticket received after the `enterExitQueue` call\\n   * @param newPositionTicket The new exit queue ticket in case not all the shares were withdrawn. Otherwise 0.\\n   * @param withdrawnAssets The total number of assets withdrawn\\n   */\\n  event ExitedAssetsClaimed(\\n    address indexed receiver,\\n    uint256 prevPositionTicket,\\n    uint256 newPositionTicket,\\n    uint256 withdrawnAssets\\n  );\\n\\n  /**\\n   * @notice Locks shares to the exit queue. The shares continue earning rewards until they will be burned by the Vault.\\n   * @param shares The number of shares to lock\\n   * @param receiver The address that will receive assets upon withdrawal\\n   * @return positionTicket The position ticket of the exit queue\\n   */\\n  function enterExitQueue(\\n    uint256 shares,\\n    address receiver\\n  ) external returns (uint256 positionTicket);\\n\\n  /**\\n   * @notice Get the exit queue index to claim exited assets from\\n   * @param positionTicket The exit queue position ticket to get the index for\\n   * @return The exit queue index that should be used to claim exited assets.\\n   *         Returns -1 in case such index does not exist.\\n   */\\n  function getExitQueueIndex(uint256 positionTicket) external view returns (int256);\\n\\n  /**\\n   * @notice Calculates the number of shares and assets that can be claimed from the exit queue.\\n   * @param receiver The address that will receive assets upon withdrawal\\n   * @param positionTicket The exit queue ticket received after the `enterExitQueue` call\\n   * @param timestamp The timestamp when the shares entered the exit queue\\n   * @param exitQueueIndex The exit queue index at which the shares were burned. It can be looked up by calling `getExitQueueIndex`.\\n   * @return leftShares The number of shares that are still in the queue\\n   * @return claimedShares The number of claimed shares\\n   * @return claimedAssets The number of claimed assets\\n   */\\n  function calculateExitedAssets(\\n    address receiver,\\n    uint256 positionTicket,\\n    uint256 timestamp,\\n    uint256 exitQueueIndex\\n  ) external view returns (uint256 leftShares, uint256 claimedShares, uint256 claimedAssets);\\n\\n  /**\\n   * @notice Claims assets that were withdrawn by the Vault. It can be called only after the `enterExitQueue` call by the `receiver`.\\n   * @param positionTicket The exit queue ticket received after the `enterExitQueue` call\\n   * @param timestamp The timestamp when the shares entered the exit queue\\n   * @param exitQueueIndex The exit queue index at which the shares were burned. It can be looked up by calling `getExitQueueIndex`.\\n   * @return newPositionTicket The new exit queue ticket in case not all the shares were burned. Otherwise 0.\\n   * @return claimedShares The number of shares claimed\\n   * @return claimedAssets The number of assets claimed\\n   */\\n  function claimExitedAssets(\\n    uint256 positionTicket,\\n    uint256 timestamp,\\n    uint256 exitQueueIndex\\n  ) external returns (uint256 newPositionTicket, uint256 claimedShares, uint256 claimedAssets);\\n\\n  /**\\n   * @notice Redeems assets from the Vault by utilising what has not been staked yet. Can only be called when vault is not collateralized.\\n   * @param shares The number of shares to burn\\n   * @param receiver The address that will receive assets\\n   * @return assets The number of assets withdrawn\\n   */\\n  function redeem(uint256 shares, address receiver) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultEthStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IVaultState} from './IVaultState.sol';\\nimport {IVaultValidators} from './IVaultValidators.sol';\\nimport {IVaultEnterExit} from './IVaultEnterExit.sol';\\nimport {IKeeperRewards} from './IKeeperRewards.sol';\\nimport {IVaultMev} from './IVaultMev.sol';\\n\\n/**\\n * @title IVaultEthStaking\\n * @author StakeWise\\n * @notice Defines the interface for the VaultEthStaking contract\\n */\\ninterface IVaultEthStaking is IVaultState, IVaultValidators, IVaultEnterExit, IVaultMev {\\n  /**\\n   * @notice Deposit ETH to the Vault\\n   * @param receiver The address that will receive Vault's shares\\n   * @param referrer The address of the referrer. Set to zero address if not used.\\n   * @return shares The number of shares minted\\n   */\\n  function deposit(address receiver, address referrer) external payable returns (uint256 shares);\\n\\n  /**\\n   * @notice Used by MEV escrow to transfer ETH.\\n   */\\n  function receiveFromMevEscrow() external payable;\\n\\n  /**\\n   * @notice Updates Vault state and deposits ETH to the Vault\\n   * @param receiver The address that will receive Vault's shares\\n   * @param referrer The address of the referrer. Set to zero address if not used.\\n   * @param harvestParams The parameters for harvesting Keeper rewards\\n   * @return shares The number of shares minted\\n   */\\n  function updateStateAndDeposit(\\n    address receiver,\\n    address referrer,\\n    IKeeperRewards.HarvestParams calldata harvestParams\\n  ) external payable returns (uint256 shares);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IVaultAdmin} from './IVaultAdmin.sol';\\n\\n/**\\n * @title IVaultFee\\n * @author StakeWise\\n * @notice Defines the interface for the VaultFee contract\\n */\\ninterface IVaultFee is IVaultAdmin {\\n  /**\\n   * @notice Event emitted on fee recipient update\\n   * @param caller The address of the function caller\\n   * @param feeRecipient The address of the new fee recipient\\n   */\\n  event FeeRecipientUpdated(address indexed caller, address indexed feeRecipient);\\n\\n  /**\\n   * @notice The Vault's fee recipient\\n   * @return The address of the Vault's fee recipient\\n   */\\n  function feeRecipient() external view returns (address);\\n\\n  /**\\n   * @notice The Vault's fee percent in BPS\\n   * @return The fee percent applied by the Vault on the rewards\\n   */\\n  function feePercent() external view returns (uint16);\\n\\n  /**\\n   * @notice Function for updating the fee recipient address. Can only be called by the admin.\\n   * @param _feeRecipient The address of the new fee recipient\\n   */\\n  function setFeeRecipient(address _feeRecipient) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultMev.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IVaultState} from './IVaultState.sol';\\n\\n/**\\n * @title IVaultMev\\n * @author StakeWise\\n * @notice Common interface for the VaultMev contracts\\n */\\ninterface IVaultMev is IVaultState {\\n  /**\\n   * @notice The contract that accumulates MEV rewards\\n   * @return The MEV escrow contract address\\n   */\\n  function mevEscrow() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultOsToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IVaultState} from './IVaultState.sol';\\nimport {IVaultEnterExit} from './IVaultEnterExit.sol';\\n\\n/**\\n * @title IVaultOsToken\\n * @author StakeWise\\n * @notice Defines the interface for the VaultOsToken contract\\n */\\ninterface IVaultOsToken is IVaultState, IVaultEnterExit {\\n  /**\\n   * @notice Event emitted on minting osToken\\n   * @param caller The address of the function caller\\n   * @param receiver The address of the osToken receiver\\n   * @param assets The amount of minted assets\\n   * @param shares The amount of minted shares\\n   * @param referrer The address of the referrer\\n   */\\n  event OsTokenMinted(\\n    address indexed caller,\\n    address receiver,\\n    uint256 assets,\\n    uint256 shares,\\n    address referrer\\n  );\\n\\n  /**\\n   * @notice Event emitted on burning OsToken\\n   * @param caller The address of the function caller\\n   * @param assets The amount of burned assets\\n   * @param shares The amount of burned shares\\n   */\\n  event OsTokenBurned(address indexed caller, uint256 assets, uint256 shares);\\n\\n  /**\\n   * @notice Event emitted on osToken position liquidation\\n   * @param caller The address of the function caller\\n   * @param user The address of the user liquidated\\n   * @param receiver The address of the receiver of the liquidated assets\\n   * @param osTokenShares The amount of osToken shares to liquidate\\n   * @param shares The amount of vault shares burned\\n   * @param receivedAssets The amount of assets received\\n   */\\n  event OsTokenLiquidated(\\n    address indexed caller,\\n    address indexed user,\\n    address receiver,\\n    uint256 osTokenShares,\\n    uint256 shares,\\n    uint256 receivedAssets\\n  );\\n\\n  /**\\n   * @notice Event emitted on osToken position redemption\\n   * @param caller The address of the function caller\\n   * @param user The address of the position owner to redeem from\\n   * @param receiver The address of the receiver of the redeemed assets\\n   * @param osTokenShares The amount of osToken shares to redeem\\n   * @param shares The amount of vault shares burned\\n   * @param assets The amount of assets received\\n   */\\n  event OsTokenRedeemed(\\n    address indexed caller,\\n    address indexed user,\\n    address receiver,\\n    uint256 osTokenShares,\\n    uint256 shares,\\n    uint256 assets\\n  );\\n\\n  /**\\n   * @notice Struct of osToken position\\n   * @param shares The total number of minted osToken shares. Will increase based on the treasury fee.\\n   * @param cumulativeFeePerShare The cumulative fee per share\\n   */\\n  struct OsTokenPosition {\\n    uint128 shares;\\n    uint128 cumulativeFeePerShare;\\n  }\\n\\n  /**\\n   * @notice Get total amount of minted osToken shares\\n   * @param user The address of the user\\n   * @return shares The number of minted osToken shares\\n   */\\n  function osTokenPositions(address user) external view returns (uint128 shares);\\n\\n  /**\\n   * @notice Mints OsToken shares\\n   * @param receiver The address that will receive the minted OsToken shares\\n   * @param osTokenShares The number of OsToken shares to mint to the receiver\\n   * @param referrer The address of the referrer\\n   * @return assets The number of assets minted to the receiver\\n   */\\n  function mintOsToken(\\n    address receiver,\\n    uint256 osTokenShares,\\n    address referrer\\n  ) external returns (uint256 assets);\\n\\n  /**\\n   * @notice Burns osToken shares\\n   * @param osTokenShares The number of shares to burn\\n   * @return assets The number of assets burned\\n   */\\n  function burnOsToken(uint128 osTokenShares) external returns (uint256 assets);\\n\\n  /**\\n   * @notice Liquidates a user position and returns the number of received assets.\\n   *         Can only be called when health factor is below 1.\\n   * @param osTokenShares The number of shares to cover\\n   * @param owner The address of the position owner to liquidate\\n   * @param receiver The address of the receiver of the liquidated assets\\n   */\\n  function liquidateOsToken(uint256 osTokenShares, address owner, address receiver) external;\\n\\n  /**\\n   * @notice Redeems osToken shares for assets. Can only be called when health factor is above redeemFromHealthFactor.\\n   * @param osTokenShares The number of osToken shares to redeem\\n   * @param owner The address of the position owner to redeem from\\n   * @param receiver The address of the receiver of the redeemed assets\\n   */\\n  function redeemOsToken(uint256 osTokenShares, address owner, address receiver) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultsRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\n/**\\n * @title IVaultsRegistry\\n * @author StakeWise\\n * @notice Defines the interface for the VaultsRegistry\\n */\\ninterface IVaultsRegistry {\\n  /**\\n   * @notice Event emitted on a Vault addition\\n   * @param caller The address that has added the Vault\\n   * @param vault The address of the added Vault\\n   */\\n  event VaultAdded(address indexed caller, address indexed vault);\\n\\n  /**\\n   * @notice Event emitted on adding Vault implementation contract\\n   * @param impl The address of the new implementation contract\\n   */\\n  event VaultImplAdded(address indexed impl);\\n\\n  /**\\n   * @notice Event emitted on removing Vault implementation contract\\n   * @param impl The address of the removed implementation contract\\n   */\\n  event VaultImplRemoved(address indexed impl);\\n\\n  /**\\n   * @notice Event emitted on whitelisting the factory\\n   * @param factory The address of the whitelisted factory\\n   */\\n  event FactoryAdded(address indexed factory);\\n\\n  /**\\n   * @notice Event emitted on removing the factory from the whitelist\\n   * @param factory The address of the factory removed from the whitelist\\n   */\\n  event FactoryRemoved(address indexed factory);\\n\\n  /**\\n   * @notice Registered Vaults\\n   * @param vault The address of the vault to check whether it is registered\\n   * @return `true` for the registered Vault, `false` otherwise\\n   */\\n  function vaults(address vault) external view returns (bool);\\n\\n  /**\\n   * @notice Registered Vault implementations\\n   * @param impl The address of the vault implementation\\n   * @return `true` for the registered implementation, `false` otherwise\\n   */\\n  function vaultImpls(address impl) external view returns (bool);\\n\\n  /**\\n   * @notice Registered Factories\\n   * @param factory The address of the factory to check whether it is whitelisted\\n   * @return `true` for the whitelisted Factory, `false` otherwise\\n   */\\n  function factories(address factory) external view returns (bool);\\n\\n  /**\\n   * @notice Function for adding Vault to the registry. Can only be called by the whitelisted Factory.\\n   * @param vault The address of the Vault to add\\n   */\\n  function addVault(address vault) external;\\n\\n  /**\\n   * @notice Function for adding Vault implementation contract\\n   * @param newImpl The address of the new implementation contract\\n   */\\n  function addVaultImpl(address newImpl) external;\\n\\n  /**\\n   * @notice Function for removing Vault implementation contract\\n   * @param impl The address of the removed implementation contract\\n   */\\n  function removeVaultImpl(address impl) external;\\n\\n  /**\\n   * @notice Function for adding the factory to the whitelist\\n   * @param factory The address of the factory to add to the whitelist\\n   */\\n  function addFactory(address factory) external;\\n\\n  /**\\n   * @notice Function for removing the factory from the whitelist\\n   * @param factory The address of the factory to remove from the whitelist\\n   */\\n  function removeFactory(address factory) external;\\n\\n  /**\\n   * @notice Function for initializing the registry. Can only be called once during the deployment.\\n   * @param _owner The address of the owner of the contract\\n   */\\n  function initialize(address _owner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IKeeperRewards} from './IKeeperRewards.sol';\\nimport {IVaultFee} from './IVaultFee.sol';\\n\\n/**\\n * @title IVaultState\\n * @author StakeWise\\n * @notice Defines the interface for the VaultState contract\\n */\\ninterface IVaultState is IVaultFee {\\n  /**\\n   * @notice Event emitted on checkpoint creation\\n   * @param shares The number of burned shares\\n   * @param assets The amount of exited assets\\n   */\\n  event CheckpointCreated(uint256 shares, uint256 assets);\\n\\n  /**\\n   * @notice Event emitted on minting fee recipient shares\\n   * @param receiver The address of the fee recipient\\n   * @param shares The number of minted shares\\n   * @param assets The amount of minted assets\\n   */\\n  event FeeSharesMinted(address receiver, uint256 shares, uint256 assets);\\n\\n  /**\\n   * @notice Total assets in the Vault\\n   * @return The total amount of the underlying asset that is \\\"managed\\\" by Vault\\n   */\\n  function totalAssets() external view returns (uint256);\\n\\n  /**\\n   * @notice Function for retrieving total shares\\n   * @return The amount of shares in existence\\n   */\\n  function totalShares() external view returns (uint256);\\n\\n  /**\\n   * @notice The Vault's capacity\\n   * @return The amount after which the Vault stops accepting deposits\\n   */\\n  function capacity() external view returns (uint256);\\n\\n  /**\\n   * @notice Total assets available in the Vault. They can be staked or withdrawn.\\n   * @return The total amount of withdrawable assets\\n   */\\n  function withdrawableAssets() external view returns (uint256);\\n\\n  /**\\n   * @notice Queued Shares\\n   * @return The total number of shares queued for exit\\n   */\\n  function queuedShares() external view returns (uint128);\\n\\n  /**\\n   * @notice Returns the number of shares held by an account\\n   * @param account The account for which to look up the number of shares it has, i.e. its balance\\n   * @return The number of shares held by the account\\n   */\\n  function getShares(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice Converts shares to assets\\n   * @param assets The amount of assets to convert to shares\\n   * @return shares The amount of shares that the Vault would exchange for the amount of assets provided\\n   */\\n  function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n  /**\\n   * @notice Converts assets to shares\\n   * @param shares The amount of shares to convert to assets\\n   * @return assets The amount of assets that the Vault would exchange for the amount of shares provided\\n   */\\n  function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n  /**\\n   * @notice Check whether state update is required\\n   * @return `true` if state update is required, `false` otherwise\\n   */\\n  function isStateUpdateRequired() external view returns (bool);\\n\\n  /**\\n   * @notice Updates the total amount of assets in the Vault and its exit queue\\n   * @param harvestParams The parameters for harvesting Keeper rewards\\n   */\\n  function updateState(IKeeperRewards.HarvestParams calldata harvestParams) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultValidators.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IKeeperValidators} from './IKeeperValidators.sol';\\nimport {IVaultAdmin} from './IVaultAdmin.sol';\\nimport {IVaultState} from './IVaultState.sol';\\n\\n/**\\n * @title IVaultValidators\\n * @author StakeWise\\n * @notice Defines the interface for VaultValidators contract\\n */\\ninterface IVaultValidators is IVaultAdmin, IVaultState {\\n  /**\\n   * @notice Event emitted on validator registration\\n   * @param publicKey The public key of the validator that was registered\\n   */\\n  event ValidatorRegistered(bytes publicKey);\\n\\n  /**\\n   * @notice Event emitted on keys manager address update\\n   * @param caller The address of the function caller\\n   * @param keysManager The address of the new keys manager\\n   */\\n  event KeysManagerUpdated(address indexed caller, address indexed keysManager);\\n\\n  /**\\n   * @notice Event emitted on validators merkle tree root update\\n   * @param caller The address of the function caller\\n   * @param validatorsRoot The new validators merkle tree root\\n   */\\n  event ValidatorsRootUpdated(address indexed caller, bytes32 indexed validatorsRoot);\\n\\n  /**\\n   * @notice The Vault keys manager address\\n   * @return The address that can update validators merkle tree root\\n   */\\n  function keysManager() external view returns (address);\\n\\n  /**\\n   * @notice The Vault validators root\\n   * @return The merkle tree root to use for verifying validators deposit data\\n   */\\n  function validatorsRoot() external view returns (bytes32);\\n\\n  /**\\n   * @notice The Vault validator index\\n   * @return The index of the next validator to be registered in the current deposit data file\\n   */\\n  function validatorIndex() external view returns (uint256);\\n\\n  /**\\n   * @notice Function for registering single validator\\n   * @param keeperParams The parameters for getting approval from Keeper oracles\\n   * @param proof The proof used to verify that the validator is part of the validators merkle tree\\n   */\\n  function registerValidator(\\n    IKeeperValidators.ApprovalParams calldata keeperParams,\\n    bytes32[] calldata proof\\n  ) external;\\n\\n  /**\\n   * @notice Function for registering multiple validators\\n   * @param keeperParams The parameters for getting approval from Keeper oracles\\n   * @param indexes The indexes of the leaves for the merkle tree multi proof verification\\n   * @param proofFlags The multi proof flags for the merkle tree verification\\n   * @param proof The proof used for the merkle tree verification\\n   */\\n  function registerValidators(\\n    IKeeperValidators.ApprovalParams calldata keeperParams,\\n    uint256[] calldata indexes,\\n    bool[] calldata proofFlags,\\n    bytes32[] calldata proof\\n  ) external;\\n\\n  /**\\n   * @notice Function for updating the keys manager. Can only be called by the admin.\\n   * @param _keysManager The new keys manager address\\n   */\\n  function setKeysManager(address _keysManager) external;\\n\\n  /**\\n   * @notice Function for updating the validators merkle tree root. Can only be called by the keys manager.\\n   * @param _validatorsRoot The new validators merkle tree root\\n   */\\n  function setValidatorsRoot(bytes32 _validatorsRoot) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IERC1822Proxiable} from '@openzeppelin/contracts/interfaces/draft-IERC1822.sol';\\nimport {IVaultAdmin} from './IVaultAdmin.sol';\\n\\n/**\\n * @title IVaultVersion\\n * @author StakeWise\\n * @notice Defines the interface for VaultVersion contract\\n */\\ninterface IVaultVersion is IERC1822Proxiable, IVaultAdmin {\\n  /**\\n   * @notice Vault Unique Identifier\\n   * @return The unique identifier of the Vault\\n   */\\n  function vaultId() external pure returns (bytes32);\\n\\n  /**\\n   * @notice Version\\n   * @return The version of the Vault implementation contract\\n   */\\n  function version() external pure returns (uint8);\\n\\n  /**\\n   * @notice Implementation\\n   * @return The address of the Vault implementation contract\\n   */\\n  function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\n/**\\n * @title Errors\\n * @author StakeWise\\n * @notice Contains all the custom errors\\n */\\nlibrary Errors {\\n  error AccessDenied();\\n  error InvalidShares();\\n  error InvalidAssets();\\n  error ZeroAddress();\\n  error InsufficientAssets();\\n  error CapacityExceeded();\\n  error InvalidCapacity();\\n  error InvalidSecurityDeposit();\\n  error InvalidFeeRecipient();\\n  error InvalidFeePercent();\\n  error NotHarvested();\\n  error NotCollateralized();\\n  error Collateralized();\\n  error InvalidProof();\\n  error LowLtv();\\n  error RedemptionExceeded();\\n  error InvalidPosition();\\n  error InvalidLtv();\\n  error InvalidHealthFactor();\\n  error InvalidReceivedAssets();\\n  error InvalidTokenMeta();\\n  error UpgradeFailed();\\n  error InvalidValidator();\\n  error InvalidValidators();\\n  error WhitelistAlreadyUpdated();\\n  error DeadlineExpired();\\n  error PermitInvalidSigner();\\n  error InvalidValidatorsRegistryRoot();\\n  error InvalidVault();\\n  error AlreadyAdded();\\n  error AlreadyRemoved();\\n  error InvalidOracles();\\n  error NotEnoughSignatures();\\n  error InvalidOracle();\\n  error TooEarlyUpdate();\\n  error InvalidAvgRewardPerSecond();\\n  error InvalidRewardsRoot();\\n  error HarvestFailed();\\n  error InvalidRedeemFromLtvPercent();\\n  error InvalidLiqThresholdPercent();\\n  error InvalidLiqBonusPercent();\\n  error InvalidLtvPercent();\\n  error InvalidCheckpointIndex();\\n  error InvalidCheckpointValue();\\n  error MaxOraclesExceeded();\\n  error ClaimTooEarly();\\n}\\n\"\r\n    },\r\n    \"contracts/vaults/ethereum/EthVaultFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {ERC1967Proxy} from '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol';\\nimport {IEthVaultFactory} from '../../interfaces/IEthVaultFactory.sol';\\nimport {IEthVault} from '../../interfaces/IEthVault.sol';\\nimport {IVaultsRegistry} from '../../interfaces/IVaultsRegistry.sol';\\nimport {OwnMevEscrow} from './mev/OwnMevEscrow.sol';\\n\\n/**\\n * @title EthVaultFactory\\n * @author StakeWise\\n * @notice Factory for deploying Ethereum staking Vaults\\n */\\ncontract EthVaultFactory is IEthVaultFactory {\\n  IVaultsRegistry internal immutable _vaultsRegistry;\\n\\n  /// @inheritdoc IEthVaultFactory\\n  address public immutable override implementation;\\n\\n  /// @inheritdoc IEthVaultFactory\\n  address public override ownMevEscrow;\\n\\n  /// @inheritdoc IEthVaultFactory\\n  address public override vaultAdmin;\\n\\n  /**\\n   * @dev Constructor\\n   * @param _implementation The implementation address of Vault\\n   * @param vaultsRegistry The address of the VaultsRegistry contract\\n   */\\n  constructor(address _implementation, IVaultsRegistry vaultsRegistry) {\\n    implementation = _implementation;\\n    _vaultsRegistry = vaultsRegistry;\\n  }\\n\\n  /// @inheritdoc IEthVaultFactory\\n  function createVault(\\n    bytes calldata params,\\n    bool isOwnMevEscrow\\n  ) external payable override returns (address vault) {\\n    // create vault\\n    vault = address(new ERC1967Proxy(implementation, ''));\\n\\n    // create MEV escrow contract if needed\\n    address _mevEscrow;\\n    if (isOwnMevEscrow) {\\n      _mevEscrow = address(new OwnMevEscrow(vault));\\n      // set MEV escrow contract so that it can be initialized in the Vault\\n      ownMevEscrow = _mevEscrow;\\n    }\\n\\n    // set admin so that it can be initialized in the Vault\\n    vaultAdmin = msg.sender;\\n\\n    // initialize Vault\\n    IEthVault(vault).initialize{value: msg.value}(params);\\n\\n    // cleanup MEV escrow contract\\n    if (isOwnMevEscrow) delete ownMevEscrow;\\n\\n    // cleanup admin\\n    delete vaultAdmin;\\n\\n    // add vault to the registry\\n    _vaultsRegistry.addVault(vault);\\n\\n    // emit event\\n    emit VaultCreated(msg.sender, vault, _mevEscrow, params);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/vaults/ethereum/mev/OwnMevEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IOwnMevEscrow} from '../../../interfaces/IOwnMevEscrow.sol';\\nimport {IVaultEthStaking} from '../../../interfaces/IVaultEthStaking.sol';\\nimport {Errors} from '../../../libraries/Errors.sol';\\n\\n/**\\n * @title OwnMevEscrow\\n * @author StakeWise\\n * @notice Accumulates received MEV. The escrow is owned by the Vault.\\n */\\ncontract OwnMevEscrow is IOwnMevEscrow {\\n  address payable public immutable override vault;\\n\\n  /// @dev Constructor\\n  constructor(address _vault) {\\n    vault = payable(_vault);\\n  }\\n\\n  /// @inheritdoc IOwnMevEscrow\\n  function harvest() external returns (uint256 assets) {\\n    if (msg.sender != vault) revert Errors.HarvestFailed();\\n\\n    assets = address(this).balance;\\n    if (assets == 0) return 0;\\n\\n    emit Harvested(assets);\\n    // slither-disable-next-line arbitrary-send-eth\\n    IVaultEthStaking(msg.sender).receiveFromMevEscrow{value: assets}();\\n  }\\n\\n  /**\\n   * @dev Function for receiving MEV\\n   */\\n  receive() external payable {\\n    emit MevReceived(msg.value);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"contract IVaultsRegistry\",\"name\":\"vaultsRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ownMevEscrow\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"VaultCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"isOwnMevEscrow\",\"type\":\"bool\"}],\"name\":\"createVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownMevEscrow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EthVaultFactory", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ba0b5ba961b108bff8d761a256e9763a4fccff230000000000000000000000003a0008a588772446f6e656133c2d5029cc4fc20e", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}