{"SourceCode": "pragma solidity ^0.4.19;\r\n\r\n/* Interface for ERC20 Tokens */\r\ncontract Token {\r\n    bytes32 public standard;\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    uint8 public decimals;\r\n    bool public allowTransactions;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\n// The DMEX base Contract\r\ncontract Exchange {\r\n    function assert(bool assertion) {\r\n        if (!assertion) throw;\r\n    }\r\n\r\n    // Safe Multiply Function - prevents integer overflow \r\n    function safeMul(uint a, uint b) returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    // Safe Subtraction Function - prevents integer overflow \r\n    function safeSub(uint a, uint b) returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    // Safe Addition Function - prevents integer overflow \r\n    function safeAdd(uint a, uint b) returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    address public owner; // holds the address of the contract owner\r\n    mapping (address => bool) public admins; // mapping of admin addresses\r\n    mapping (address => bool) public futuresContracts; // mapping of connected futures contracts\r\n    mapping (address => uint256) public futuresContractsAddedBlock; // mapping of connected futures contracts and connection block numbers\r\n    event SetFuturesContract(address futuresContract, bool isFuturesContract);\r\n\r\n    // Event fired when the owner of the contract is changed\r\n    event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // Allows only the owner of the contract to execute the function\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // Changes the owner of the contract\r\n    function setOwner(address newOwner) onlyOwner {\r\n        SetOwner(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    // Owner getter function\r\n    function getOwner() returns (address out) {\r\n        return owner;\r\n    }\r\n\r\n    // Adds or disables an admin account\r\n    function setAdmin(address admin, bool isAdmin) onlyOwner {\r\n        admins[admin] = isAdmin;\r\n    }\r\n\r\n\r\n    // Adds or disables a futuresContract address\r\n    function setFuturesContract(address futuresContract, bool isFuturesContract) onlyOwner {\r\n        futuresContracts[futuresContract] = isFuturesContract;\r\n        if (fistFuturesContract == address(0))\r\n        {\r\n            fistFuturesContract = futuresContract;\r\n        }\r\n        futuresContractsAddedBlock[futuresContract] = block.number;\r\n        emit SetFuturesContract(futuresContract, isFuturesContract);\r\n    }\r\n\r\n    // Allows for admins only to call the function\r\n    modifier onlyAdmin {\r\n        if (msg.sender != owner && !admins[msg.sender]) throw;\r\n        _;\r\n    }\r\n\r\n    // Allows for futures contracts only to call the function\r\n    modifier onlyFuturesContract {\r\n        if (!futuresContracts[msg.sender]) throw;\r\n        _;\r\n    }\r\n\r\n    function() external {\r\n        throw;\r\n    }\r\n\r\n    //mapping (address => mapping (address => uint256)) public tokens; // mapping of token addresses to mapping of balances  // tokens[token][user]\r\n    //mapping (address => mapping (address => uint256)) public reserve; // mapping of token addresses to mapping of reserved balances  // reserve[token][user]\r\n    mapping (address => mapping (address => uint256)) public balances; // mapping of token addresses to mapping of balances and reserve (bitwise compressed) // balances[token][user]\r\n\r\n    mapping (address => uint256) public lastActiveTransaction; // mapping of user addresses to last transaction block\r\n    mapping (bytes32 => uint256) public orderFills; // mapping of orders to filled qunatity\r\n    \r\n    mapping (address => mapping (address => bool)) public userAllowedFuturesContracts; // mapping of allowed futures smart contracts per user\r\n    mapping (address => uint256) public userFirstDeposits; // mapping of user addresses and block number of first deposit\r\n\r\n    address public feeAccount; // the account that receives the trading fees\r\n    address public EtmTokenAddress; // the address of the EtherMium token\r\n    address public fistFuturesContract; // 0x if there are no futures contracts set yet\r\n\r\n    uint256 public inactivityReleasePeriod; // period in blocks before a user can use the withdraw() function\r\n    mapping (bytes32 => bool) public withdrawn; // mapping of withdraw requests, makes sure the same withdrawal is not executed twice\r\n    uint256 public makerFee; // maker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\r\n    uint256 public takerFee; // taker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\r\n\r\n    enum Errors {\r\n        INVLID_PRICE,           // Order prices don't match\r\n        INVLID_SIGNATURE,       // Signature is invalid\r\n        TOKENS_DONT_MATCH,      // Maker/taker tokens don't match\r\n        ORDER_ALREADY_FILLED,   // Order was already filled\r\n        GAS_TOO_HIGH            // Too high gas fee\r\n    }\r\n\r\n    // Trade event fired when a trade is executed\r\n    event Trade(\r\n        address takerTokenBuy, uint256 takerAmountBuy,\r\n        address takerTokenSell, uint256 takerAmountSell,\r\n        address maker, address indexed taker,\r\n        uint256 makerFee, uint256 takerFee,\r\n        uint256 makerAmountTaken, uint256 takerAmountTaken,\r\n        bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash\r\n    );\r\n\r\n    // Deposit event fired when a deposit took place\r\n    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);\r\n\r\n    // Withdraw event fired when a withdrawal was executed\r\n    event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance, uint256 withdrawFee);\r\n    event WithdrawTo(address indexed token, address indexed to, address indexed from, uint256 amount, uint256 balance, uint256 withdrawFee);\r\n\r\n    // Fee change event\r\n    event FeeChange(uint256 indexed makerFee, uint256 indexed takerFee);\r\n\r\n    // Allow futuresContract \r\n    event AllowFuturesContract(address futuresContract, address user);\r\n\r\n\r\n    // Log event, logs errors in contract execution (used for debugging)\r\n    event LogError(uint8 indexed errorId, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\r\n    event LogUint(uint8 id, uint256 value);\r\n    event LogBool(uint8 id, bool value);\r\n    event LogAddress(uint8 id, address value);\r\n\r\n    // Change inactivity release period event\r\n    event InactivityReleasePeriodChange(uint256 value);\r\n\r\n    // Order cancelation event\r\n    event CancelOrder(\r\n        bytes32 indexed cancelHash,\r\n        bytes32 indexed orderHash,\r\n        address indexed user,\r\n        address tokenSell,\r\n        uint256 amountSell,\r\n        uint256 cancelFee\r\n    );\r\n\r\n    // Sets the inactivity period before a user can withdraw funds manually\r\n    function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {\r\n        if (expiry > 1000000) throw;\r\n        inactivityReleasePeriod = expiry;\r\n\r\n        emit InactivityReleasePeriodChange(expiry);\r\n        return true;\r\n    }\r\n\r\n    // Constructor function, initializes the contract and sets the core variables\r\n    function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 inactivityReleasePeriod_) {\r\n        owner = msg.sender;\r\n        feeAccount = feeAccount_;\r\n        inactivityReleasePeriod = inactivityReleasePeriod_;\r\n        makerFee = makerFee_;\r\n        takerFee = takerFee_;\r\n    }\r\n\r\n    // Changes the fees\r\n    function setFees(uint256 makerFee_, uint256 takerFee_) onlyOwner {\r\n        require(makerFee_ < 10 finney && takerFee_ < 10 finney); // The fees cannot be set higher then 1%\r\n        makerFee = makerFee_;\r\n        takerFee = takerFee_;\r\n\r\n        emit FeeChange(makerFee, takerFee);\r\n    }\r\n\r\n    \r\n\r\n\r\n\r\n    function updateBalanceAndReserve (address token, address user, uint256 balance, uint256 reserve) private\r\n    {\r\n        uint256 character = uint256(balance);\r\n        character |= reserve<<128;\r\n\r\n        balances[token][user] = character;\r\n    }\r\n\r\n    function updateBalance (address token, address user, uint256 balance) private returns (bool)\r\n    {\r\n        uint256 character = uint256(balance);\r\n        character |= getReserve(token, user)<<128;\r\n\r\n        balances[token][user] = character;\r\n        return true;\r\n    }\r\n\r\n    function updateReserve (address token, address user, uint256 reserve) private\r\n    {\r\n        uint256 character = uint256(balanceOf(token, user));\r\n        character |= reserve<<128;\r\n\r\n        balances[token][user] = character;\r\n    }\r\n\r\n    function decodeBalanceAndReserve (address token, address user) returns (uint256[2])\r\n    {\r\n        uint256 character = balances[token][user];\r\n        uint256 balance = uint256(uint128(character));\r\n        uint256 reserve = uint256(uint128(character>>128));\r\n\r\n        return [balance, reserve];\r\n    }\r\n\r\n    function futuresContractAllowed (address futuresContract, address user) returns (bool)\r\n    {\r\n        if (fistFuturesContract == futuresContract) return true;\r\n        if (userAllowedFuturesContracts[user][futuresContract] == true) return true;\r\n        if (futuresContractsAddedBlock[futuresContract] < userFirstDeposits[user]) return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    // Returns the balance of a specific token for a specific user\r\n    function balanceOf(address token, address user) view returns (uint256) {\r\n        //return tokens[token][user];\r\n        return decodeBalanceAndReserve(token, user)[0];\r\n    }\r\n\r\n    // Returns the reserved amound of token for user\r\n    function getReserve(address token, address user) public view returns (uint256) { \r\n        //return reserve[token][user];  \r\n        return decodeBalanceAndReserve(token, user)[1];\r\n    }\r\n\r\n    // Sets reserved amount for specific token and user (can only be called by futures contract)\r\n    function setReserve(address token, address user, uint256 amount) onlyFuturesContract returns (bool success) { \r\n        if (!futuresContractAllowed(msg.sender, user)) throw;\r\n        if (availableBalanceOf(token, user) < amount) throw; \r\n        updateReserve(token, user, amount);\r\n        return true; \r\n    }\r\n\r\n    // Updates user balance (only can be used by futures contract)\r\n    function setBalance(address token, address user, uint256 amount) onlyFuturesContract returns (bool success)     {\r\n        if (!futuresContractAllowed(msg.sender, user)) throw;\r\n        updateBalance(token, user, amount);\r\n        return true;\r\n        \r\n    }\r\n\r\n    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) onlyFuturesContract returns (bool)\r\n    {\r\n        if (!futuresContractAllowed(msg.sender, user)) throw;\r\n        updateBalanceAndReserve(token, user, safeSub(balanceOf(token, user), subBalance), safeAdd(getReserve(token, user), addReserve));\r\n    }\r\n\r\n    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) onlyFuturesContract returns (bool)\r\n    {\r\n        if (!futuresContractAllowed(msg.sender, user)) throw;\r\n        updateBalanceAndReserve(token, user, safeAdd(balanceOf(token, user), addBalance), safeSub(getReserve(token, user), subReserve));\r\n    }\r\n\r\n    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) onlyFuturesContract returns (bool)\r\n    {\r\n        if (!futuresContractAllowed(msg.sender, user)) throw;\r\n        updateBalanceAndReserve(token, user, safeSub(balanceOf(token, user), subBalance), safeSub(getReserve(token, user), subReserve));\r\n    }\r\n\r\n    // Returns the available balance of a specific token for a specific user\r\n    function availableBalanceOf(address token, address user) view returns (uint256) {\r\n        return safeSub(balanceOf(token, user), getReserve(token, user));\r\n    }\r\n\r\n    // Returns the inactivity release perios\r\n    function getInactivityReleasePeriod() view returns (uint256)\r\n    {\r\n        return inactivityReleasePeriod;\r\n    }\r\n\r\n    // Increases the user balance\r\n    function addBalance(address token, address user, uint256 amount) private\r\n    {\r\n        updateBalance(token, user, safeAdd(balanceOf(token, user), amount));\r\n    }\r\n\r\n    // Decreases user balance\r\n    function subBalance(address token, address user, uint256 amount) private\r\n    {\r\n        if (availableBalanceOf(token, user) < amount) throw; \r\n        updateBalance(token, user, safeSub(balanceOf(token, user), amount));\r\n    }\r\n\r\n\r\n    // Deposit ETH to contract\r\n    function deposit() payable {\r\n        //tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value); // adds the deposited amount to user balance\r\n        addBalance(address(0), msg.sender, msg.value); // adds the deposited amount to user balance\r\n        if (userFirstDeposits[msg.sender] == 0) userFirstDeposits[msg.sender] = block.number;\r\n        lastActiveTransaction[msg.sender] = block.number; // sets the last activity block for the user\r\n        emit Deposit(address(0), msg.sender, msg.value, balanceOf(address(0), msg.sender)); // fires the deposit event\r\n    }\r\n\r\n    // Deposit token to contract\r\n    function depositToken(address token, uint128 amount) {\r\n        //tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount); // adds the deposited amount to user balance\r\n        //if (amount != uint128(amount) || safeAdd(amount, balanceOf(token, msg.sender)) != uint128(amount)) throw;\r\n        addBalance(token, msg.sender, amount); // adds the deposited amount to user balance\r\n\r\n        if (userFirstDeposits[msg.sender] == 0) userFirstDeposits[msg.sender] = block.number;\r\n        lastActiveTransaction[msg.sender] = block.number; // sets the last activity block for the user\r\n        if (!Token(token).transferFrom(msg.sender, this, amount)) throw; // attempts to transfer the token to this contract, if fails throws an error\r\n        emit Deposit(token, msg.sender, amount, balanceOf(token, msg.sender)); // fires the deposit event\r\n    }\r\n\r\n    function withdraw(address token, uint256 amount) returns (bool success) {\r\n        //if (safeSub(block.number, lastActiveTransaction[msg.sender]) < inactivityReleasePeriod) throw; // checks if the inactivity period has passed\r\n        //if (tokens[token][msg.sender] < amount) throw; // checks that user has enough balance\r\n        if (availableBalanceOf(token, msg.sender) < amount) throw;\r\n\r\n        //tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount); \r\n        subBalance(token, msg.sender, amount); // subtracts the withdrawed amount from user balance\r\n\r\n        if (token == address(0)) { // checks if withdrawal is a token or ETH, ETH has address 0x00000... \r\n            if (!msg.sender.send(amount)) throw; // send ETH\r\n        } else {\r\n            if (!Token(token).transfer(msg.sender, amount)) throw; // Send token\r\n        }\r\n        emit Withdraw(token, msg.sender, amount, balanceOf(token, msg.sender), 0); // fires the Withdraw event\r\n    }\r\n\r\n    function userAllowFuturesContract(address futuresContract)\r\n    {\r\n        if (!futuresContracts[futuresContract]) throw;\r\n        userAllowedFuturesContracts[msg.sender][futuresContract] = true;\r\n\r\n        emit AllowFuturesContract(futuresContract, msg.sender);\r\n    }\r\n\r\n    function allowFuturesContractForUser(address futuresContract, address user, uint8 v, bytes32 r, bytes32 s) onlyAdmin\r\n    {\r\n        if (!futuresContracts[futuresContract]) throw;\r\n        bytes32 hash = keccak256(this, futuresContract); \r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) != user) throw; // checks that the provided signature is valid\r\n        userAllowedFuturesContracts[user][futuresContract] = true;\r\n\r\n        emit AllowFuturesContract(futuresContract, user);\r\n    }\r\n\r\n    function allowFuturesContractForUserByFuturesContract(address user, uint8 v, bytes32 r, bytes32 s) onlyFuturesContract returns (bool)\r\n    {\r\n        if (!futuresContracts[msg.sender]) return false;\r\n        bytes32 hash = keccak256(this, msg.sender); \r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) != user) return false; // checks that the provided signature is valid\r\n        userAllowedFuturesContracts[user][msg.sender] = true;\r\n\r\n        emit AllowFuturesContract(msg.sender, user);\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n\r\n    // Withdrawal function used by the server to execute withdrawals\r\n    function adminWithdraw(\r\n        address token, // the address of the token to be withdrawn\r\n        uint256 amount, // the amount to be withdrawn\r\n        address user, // address of the user\r\n        uint256 nonce, // nonce to make the request unique\r\n        uint8 v, // part of user signature\r\n        bytes32 r, // part of user signature\r\n        bytes32 s, // part of user signature\r\n        uint256 feeWithdrawal // the transaction gas fee that will be deducted from the user balance\r\n    ) onlyAdmin returns (bool success) {\r\n        bytes32 hash = keccak256(this, token, amount, user, nonce); // creates the hash for the withdrawal request\r\n        if (withdrawn[hash]) throw; // checks if the withdrawal was already executed, if true, throws an error\r\n        withdrawn[hash] = true; // sets the withdrawal as executed\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) != user) throw; // checks that the provided signature is valid\r\n        if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney; // checks that the gas fee is not higher than 0.05 ETH\r\n\r\n\r\n        //if (tokens[token][user] < amount) throw; // checks that user has enough balance\r\n        if (availableBalanceOf(token, user) < amount) throw; // checks that user has enough balance\r\n\r\n        //tokens[token][user] = safeSub(tokens[token][user], amount); // subtracts the withdrawal amount from the user balance\r\n        subBalance(token, user, amount); // subtracts the withdrawal amount from the user balance\r\n\r\n        //tokens[address(0)][user] = safeSub(tokens[address(0x0)][user], feeWithdrawal); // subtracts the gas fee from the user ETH balance\r\n        subBalance(address(0), user, feeWithdrawal); // subtracts the gas fee from the user ETH balance\r\n\r\n        //tokens[address(0)][feeAccount] = safeAdd(tokens[address(0)][feeAccount], feeWithdrawal); // moves the gas fee to the feeAccount\r\n        addBalance(address(0), feeAccount, feeWithdrawal); // moves the gas fee to the feeAccount\r\n\r\n        if (token == address(0)) { // checks if the withdrawal is in ETH or Tokens\r\n            if (!user.send(amount)) throw; // sends ETH\r\n        } else {\r\n            if (!Token(token).transfer(user, amount)) throw; // sends tokens\r\n        }\r\n        lastActiveTransaction[user] = block.number; // sets last user activity block\r\n        emit Withdraw(token, user, amount, balanceOf(token, user), feeWithdrawal); // fires the withdraw event\r\n    }\r\n\r\n    function batchAdminWithdraw(\r\n        address[] token, // the address of the token to be withdrawn\r\n        uint256[] amount, // the amount to be withdrawn\r\n        address[] user, // address of the user\r\n        uint256[] nonce, // nonce to make the request unique\r\n        uint8[] v, // part of user signature\r\n        bytes32[] r, // part of user signature\r\n        bytes32[] s, // part of user signature\r\n        uint256[] feeWithdrawal // the transaction gas fee that will be deducted from the user balance\r\n    ) onlyAdmin \r\n    {\r\n        for (uint i = 0; i < amount.length; i++) {\r\n            adminWithdraw(\r\n                token[i],\r\n                amount[i],\r\n                user[i],\r\n                nonce[i],\r\n                v[i],\r\n                r[i],\r\n                s[i],\r\n                feeWithdrawal[i]\r\n            );\r\n        }\r\n    }\r\n\r\n \r\n\r\n    function getMakerTakerBalances(address token, address maker, address taker) view returns (uint256[4])\r\n    {\r\n        return [\r\n            balanceOf(token, maker),\r\n            balanceOf(token, taker),\r\n            getReserve(token, maker),\r\n            getReserve(token, taker)\r\n        ];\r\n    }\r\n\r\n    \r\n\r\n    // Structure that holds order values, used inside the trade() function\r\n    struct OrderPair {\r\n        uint256 makerAmountBuy;     // amount being bought by the maker\r\n        uint256 makerAmountSell;    // amount being sold by the maker\r\n        uint256 makerNonce;         // maker order nonce, makes the order unique\r\n        uint256 takerAmountBuy;     // amount being bought by the taker\r\n        uint256 takerAmountSell;    // amount being sold by the taker\r\n        uint256 takerNonce;         // taker order nonce\r\n        uint256 takerGasFee;        // taker gas fee, taker pays the gas\r\n        uint256 takerIsBuying;      // true/false taker is the buyer\r\n\r\n        address makerTokenBuy;      // token bought by the maker\r\n        address makerTokenSell;     // token sold by the maker\r\n        address maker;              // address of the maker\r\n        address takerTokenBuy;      // token bought by the taker\r\n        address takerTokenSell;     // token sold by the taker\r\n        address taker;              // address of the taker\r\n\r\n        bytes32 makerOrderHash;     // hash of the maker order\r\n        bytes32 takerOrderHash;     // has of the taker order\r\n    }\r\n\r\n    // Structure that holds trade values, used inside the trade() function\r\n    struct TradeValues {\r\n        uint256 qty;                // amount to be trade\r\n        uint256 invQty;             // amount to be traded in the opposite token\r\n        uint256 makerAmountTaken;   // final amount taken by the maker\r\n        uint256 takerAmountTaken;   // final amount taken by the taker\r\n    }\r\n\r\n    // Trades balances between user accounts\r\n    function trade(\r\n        uint8[2] v,\r\n        bytes32[4] rs,\r\n        uint256[8] tradeValues,\r\n        address[6] tradeAddresses\r\n    ) onlyAdmin returns (uint filledTakerTokenAmount)\r\n    {\r\n\r\n        /* tradeValues\r\n          [0] makerAmountBuy\r\n          [1] makerAmountSell\r\n          [2] makerNonce\r\n          [3] takerAmountBuy\r\n          [4] takerAmountSell\r\n          [5] takerNonce\r\n          [6] takerGasFee\r\n          [7] takerIsBuying\r\n\r\n          tradeAddresses\r\n          [0] makerTokenBuy\r\n          [1] makerTokenSell\r\n          [2] maker\r\n          [3] takerTokenBuy\r\n          [4] takerTokenSell\r\n          [5] taker\r\n        */\r\n\r\n        OrderPair memory t  = OrderPair({\r\n            makerAmountBuy  : tradeValues[0],\r\n            makerAmountSell : tradeValues[1],\r\n            makerNonce      : tradeValues[2],\r\n            takerAmountBuy  : tradeValues[3],\r\n            takerAmountSell : tradeValues[4],\r\n            takerNonce      : tradeValues[5],\r\n            takerGasFee     : tradeValues[6],\r\n            takerIsBuying   : tradeValues[7],\r\n\r\n            makerTokenBuy   : tradeAddresses[0],\r\n            makerTokenSell  : tradeAddresses[1],\r\n            maker           : tradeAddresses[2],\r\n            takerTokenBuy   : tradeAddresses[3],\r\n            takerTokenSell  : tradeAddresses[4],\r\n            taker           : tradeAddresses[5],\r\n\r\n            //                                tokenBuy           amountBuy       tokenSell          amountSell      nonce           user\r\n            makerOrderHash  : keccak256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeAddresses[2]),\r\n            takerOrderHash  : keccak256(this, tradeAddresses[3], tradeValues[3], tradeAddresses[4], tradeValues[4], tradeValues[5], tradeAddresses[5])\r\n        });\r\n\r\n        // Checks the signature for the maker order\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", t.makerOrderHash), v[0], rs[0], rs[1]) != t.maker)\r\n        {\r\n            emit LogError(uint8(Errors.INVLID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n       \r\n       // Checks the signature for the taker order\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", t.takerOrderHash), v[1], rs[2], rs[3]) != t.taker)\r\n        {\r\n            emit LogError(uint8(Errors.INVLID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n\r\n\r\n        // Checks that orders trade the right tokens\r\n        if (t.makerTokenBuy != t.takerTokenSell || t.makerTokenSell != t.takerTokenBuy)\r\n        {\r\n            emit LogError(uint8(Errors.TOKENS_DONT_MATCH), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        } // tokens don't match\r\n\r\n\r\n        // Cheks that gas fee is not higher than 10%\r\n        if (t.takerGasFee > 100 finney)\r\n        {\r\n            emit LogError(uint8(Errors.GAS_TOO_HIGH), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        } // takerGasFee too high\r\n\r\n\r\n        // Checks that the prices match.\r\n        // Taker always pays the maker price. This part checks that the taker price is as good or better than the maker price\r\n        if (!(\r\n        (t.takerIsBuying == 0 && safeMul(t.makerAmountSell, 1 ether) / t.makerAmountBuy >= safeMul(t.takerAmountBuy, 1 ether) / t.takerAmountSell)\r\n        ||\r\n        (t.takerIsBuying > 0 && safeMul(t.makerAmountBuy, 1 ether) / t.makerAmountSell <= safeMul(t.takerAmountSell, 1 ether) / t.takerAmountBuy)\r\n        ))\r\n        {\r\n            emit LogError(uint8(Errors.INVLID_PRICE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; // prices don't match\r\n        }\r\n\r\n        // Initializing trade values structure\r\n        TradeValues memory tv = TradeValues({\r\n            qty                 : 0,\r\n            invQty              : 0,\r\n            makerAmountTaken    : 0,\r\n            takerAmountTaken    : 0\r\n        });\r\n        \r\n        // maker buy, taker sell\r\n        if (t.takerIsBuying == 0)\r\n        {\r\n            // traded quantity is the smallest quantity between the maker and the taker, takes into account amounts already filled on the orders\r\n            tv.qty = min(safeSub(t.makerAmountBuy, orderFills[t.makerOrderHash]), safeSub(t.takerAmountSell, safeMul(orderFills[t.takerOrderHash], t.takerAmountSell) / t.takerAmountBuy));\r\n            if (tv.qty == 0)\r\n            {\r\n                // order was already filled\r\n                emit LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\r\n                return 0;\r\n            }\r\n\r\n            // the traded quantity in opposite token terms\r\n            tv.invQty = safeMul(tv.qty, t.makerAmountSell) / t.makerAmountBuy;\r\n\r\n           \r\n            // take fee from Token balance\r\n            tv.makerAmountTaken                         = safeSub(tv.qty, safeMul(tv.qty, makerFee) / (1 ether));                                       // net amount received by maker, excludes maker fee\r\n            //tokens[t.makerTokenBuy][feeAccount]         = safeAdd(tokens[t.makerTokenBuy][feeAccount],      safeMul(tv.qty, makerFee) / (1 ether));     // add maker fee to feeAccount\r\n            addBalance(t.makerTokenBuy, feeAccount, safeMul(tv.qty, makerFee) / (1 ether)); // add maker fee to feeAccount\r\n        \r\n\r\n        \r\n            // take fee from Token balance\r\n            tv.takerAmountTaken                         = safeSub(safeSub(tv.invQty, safeMul(tv.invQty, takerFee) / (1 ether)), safeMul(tv.invQty, t.takerGasFee) / (1 ether));                             // amount taken from taker minus taker fee\r\n            //tokens[t.takerTokenBuy][feeAccount]         = safeAdd(tokens[t.takerTokenBuy][feeAccount], safeAdd(safeMul(tv.invQty, takerFee) / (1 ether), safeMul(tv.invQty, t.takerGasFee) / (1 ether)));   // add taker fee to feeAccount\r\n            addBalance(t.takerTokenBuy, feeAccount, safeAdd(safeMul(tv.invQty, takerFee) / (1 ether), safeMul(tv.invQty, t.takerGasFee) / (1 ether))); // add taker fee to feeAccount\r\n\r\n\r\n            //tokens[t.makerTokenSell][t.maker]           = safeSub(tokens[t.makerTokenSell][t.maker],           tv.invQty);                              // subtract sold token amount from maker balance\r\n            subBalance(t.makerTokenSell, t.maker, tv.invQty); // subtract sold token amount from maker balance\r\n\r\n            //tokens[t.makerTokenBuy][t.maker]            = safeAdd(tokens[t.makerTokenBuy][t.maker],            tv.makerAmountTaken);                    // add bought token amount to maker\r\n            addBalance(t.makerTokenBuy, t.maker, tv.makerAmountTaken); // add bought token amount to maker\r\n\r\n            //tokens[t.makerTokenBuy][tv.makerReferrer]   = safeAdd(tokens[t.makerTokenBuy][tv.makerReferrer],   safeMul(tv.qty,    makerAffiliateFee) / (1 ether)); // add affiliate commission to maker affiliate balance\r\n\r\n\r\n            //tokens[t.takerTokenSell][t.taker]           = safeSub(tokens[t.takerTokenSell][t.taker],           tv.qty);                                 // subtract the sold token amount from taker\r\n            subBalance(t.takerTokenSell, t.taker, tv.qty); // subtract the sold token amount from taker\r\n\r\n            //tokens[t.takerTokenBuy][t.taker]            = safeAdd(tokens[t.takerTokenBuy][t.taker],            tv.takerAmountTaken);                    // amount received by taker, excludes taker fee\r\n            //tokens[t.takerTokenBuy][tv.takerReferrer]   = safeAdd(tokens[t.takerTokenBuy][tv.takerReferrer],   safeMul(tv.invQty, takerAffiliateFee) / (1 ether)); // add affiliate commission to taker affiliate balance\r\n            addBalance(t.takerTokenBuy, t.taker, tv.takerAmountTaken); // amount received by taker, excludes taker fee\r\n        \r\n            orderFills[t.makerOrderHash]                = safeAdd(orderFills[t.makerOrderHash], tv.qty);                                                // increase the maker order filled amount\r\n            orderFills[t.takerOrderHash]                = safeAdd(orderFills[t.takerOrderHash], safeMul(tv.qty, t.takerAmountBuy) / t.takerAmountSell); // increase the taker order filled amount\r\n            lastActiveTransaction[t.maker]              = block.number; // set last activity block number for maker\r\n            lastActiveTransaction[t.taker]              = block.number; // set last activity block number for taker\r\n\r\n            // fire Trade event\r\n            emit Trade(\r\n                t.takerTokenBuy, tv.qty,\r\n                t.takerTokenSell, tv.invQty,\r\n                t.maker, t.taker,\r\n                makerFee, takerFee,\r\n                tv.makerAmountTaken , tv.takerAmountTaken,\r\n                t.makerOrderHash, t.takerOrderHash\r\n            );\r\n            return tv.qty;\r\n        }\r\n        // maker sell, taker buy\r\n        else\r\n        {\r\n            // traded quantity is the smallest quantity between the maker and the taker, takes into account amounts already filled on the orders\r\n            tv.qty = min(safeSub(t.makerAmountSell,  safeMul(orderFills[t.makerOrderHash], t.makerAmountSell) / t.makerAmountBuy), safeSub(t.takerAmountBuy, orderFills[t.takerOrderHash]));\r\n            if (tv.qty == 0)\r\n            {\r\n                // order was already filled\r\n                emit LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\r\n                return 0;\r\n            }            \r\n\r\n            // the traded quantity in opposite token terms\r\n            tv.invQty = safeMul(tv.qty, t.makerAmountBuy) / t.makerAmountSell;\r\n            \r\n           \r\n            // take fee from ETH balance\r\n            tv.makerAmountTaken                         = safeSub(tv.invQty, safeMul(tv.invQty, makerFee) / (1 ether));                                 // net amount received by maker, excludes maker fee\r\n            //tokens[t.makerTokenBuy][feeAccount]         = safeAdd(tokens[t.makerTokenBuy][feeAccount],      safeMul(tv.invQty, makerFee) / (1 ether));  // add maker fee to feeAccount\r\n            addBalance(t.makerTokenBuy, feeAccount, safeMul(tv.invQty, makerFee) / (1 ether)); // add maker fee to feeAccount\r\n     \r\n\r\n            // process fees for taker\r\n            \r\n            // take fee from ETH balance\r\n            tv.takerAmountTaken                         = safeSub(safeSub(tv.qty, safeMul(tv.qty, takerFee) / (1 ether)), safeMul(tv.qty, t.takerGasFee) / (1 ether));                                  // amount taken from taker minus taker fee\r\n            //tokens[t.takerTokenBuy][feeAccount]         = safeAdd(tokens[t.takerTokenBuy][feeAccount], safeAdd(safeMul(tv.qty, takerFee) / (1 ether), safeMul(tv.qty, t.takerGasFee) / (1 ether)));     // add taker fee to feeAccount\r\n            addBalance(t.takerTokenBuy, feeAccount, safeAdd(safeMul(tv.qty, takerFee) / (1 ether), safeMul(tv.qty, t.takerGasFee) / (1 ether))); // add taker fee to feeAccount\r\n\r\n\r\n\r\n            //tokens[t.makerTokenSell][t.maker]           = safeSub(tokens[t.makerTokenSell][t.maker],           tv.qty); // subtract sold token amount from maker balance\r\n            subBalance(t.makerTokenSell, t.maker, tv.qty); // subtract sold token amount from maker balance\r\n\r\n            //tv.makerAmountTaken                         = safeSub(tv.invQty, safeMul(tv.invQty, makerFee) / (1 ether));   // net amount received by maker, excludes maker fee\r\n            //tokens[t.makerTokenBuy][t.maker]            = safeAdd(tokens[t.makerTokenBuy][t.maker],            tv.makerAmountTaken); // add bought token amount to maker\r\n            addBalance(t.makerTokenBuy, t.maker, tv.makerAmountTaken); // add bought token amount to maker\r\n\r\n            //tokens[t.makerTokenBuy][tv.makerReferrer]   = safeAdd(tokens[t.makerTokenBuy][tv.makerReferrer],   safeMul(tv.invQty, makerAffiliateFee) / (1 ether)); // add affiliate commission to maker affiliate balance\r\n\r\n            //tokens[t.takerTokenSell][t.taker]           = safeSub(tokens[t.takerTokenSell][t.taker],           tv.invQty); // subtract the sold token amount from taker\r\n            subBalance(t.takerTokenSell, t.taker, tv.invQty);\r\n\r\n            //tv.takerAmountTaken                         = safeSub(safeSub(tv.qty,    safeMul(tv.qty, takerFee) / (1 ether)), safeMul(tv.qty, t.takerGasFee) / (1 ether)); // amount taken from taker minus taker fee\r\n            //tokens[t.takerTokenBuy][t.taker]            = safeAdd(tokens[t.takerTokenBuy][t.taker],            tv.takerAmountTaken); // amount received by taker, excludes taker fee\r\n            addBalance(t.takerTokenBuy, t.taker, tv.takerAmountTaken); // amount received by taker, excludes taker fee\r\n\r\n            //tokens[t.takerTokenBuy][tv.takerReferrer]   = safeAdd(tokens[t.takerTokenBuy][tv.takerReferrer],   safeMul(tv.qty,    takerAffiliateFee) / (1 ether)); // add affiliate commission to taker affiliate balance\r\n\r\n            //tokens[t.makerTokenBuy][feeAccount]     = safeAdd(tokens[t.makerTokenBuy][feeAccount],      safeMul(tv.invQty, safeSub(makerFee, makerAffiliateFee)) / (1 ether)); // add maker fee excluding affiliate commission to feeAccount\r\n            //tokens[t.takerTokenBuy][feeAccount]     = safeAdd(tokens[t.takerTokenBuy][feeAccount],      safeAdd(safeMul(tv.qty,    safeSub(takerFee, takerAffiliateFee)) / (1 ether), safeMul(tv.qty, t.takerGasFee) / (1 ether))); // add taker fee excluding affiliate commission to feeAccount\r\n\r\n            orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.invQty); // increase the maker order filled amount\r\n            orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], tv.qty);  // increase the taker order filled amount\r\n            lastActiveTransaction[t.maker]          = block.number; // set last activity block number for maker\r\n            lastActiveTransaction[t.taker]          = block.number; // set last activity block number for taker\r\n\r\n            // fire Trade event\r\n            emit Trade(\r\n                t.takerTokenBuy, tv.qty,\r\n                t.takerTokenSell, tv.invQty,\r\n                t.maker, t.taker,\r\n                makerFee, takerFee,\r\n                tv.makerAmountTaken , tv.takerAmountTaken,\r\n                t.makerOrderHash, t.takerOrderHash\r\n            );\r\n            return tv.qty;\r\n        }\r\n    }\r\n\r\n\r\n    // Executes multiple trades in one transaction, saves gas fees\r\n    function batchOrderTrade(\r\n        uint8[2][] v,\r\n        bytes32[4][] rs,\r\n        uint256[8][] tradeValues,\r\n        address[6][] tradeAddresses\r\n    ) onlyAdmin\r\n    {\r\n        for (uint i = 0; i < tradeAddresses.length; i++) {\r\n            trade(\r\n                v[i],\r\n                rs[i],\r\n                tradeValues[i],\r\n                tradeAddresses[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    // Cancels order by setting amount filled to toal order amount\r\n    function cancelOrder(\r\n\t\t/*\r\n\t\t[0] orderV\r\n\t\t[1] cancelV\r\n\t\t*/\r\n\t    uint8[2] v,\r\n\r\n\t\t/*\r\n\t\t[0] orderR\r\n\t\t[1] orderS\r\n\t\t[2] cancelR\r\n\t\t[3] cancelS\r\n\t\t*/\r\n\t    bytes32[4] rs,\r\n\r\n\t\t/*\r\n\t\t[0] orderAmountBuy\r\n\t\t[1] orderAmountSell\r\n\t\t[2] orderNonce\r\n\t\t[3] cancelNonce\r\n\t\t[4] cancelFee\r\n\t\t*/\r\n\t\tuint256[5] cancelValues,\r\n\r\n\t\t/*\r\n\t\t[0] orderTokenBuy\r\n\t\t[1] orderTokenSell\r\n\t\t[2] orderUser\r\n\t\t[3] cancelUser\r\n\t\t*/\r\n\t\taddress[4] cancelAddresses\r\n    ) onlyAdmin {\r\n        // Order values should be valid and signed by order owner\r\n        bytes32 orderHash = keccak256(\r\n\t        this, cancelAddresses[0], cancelValues[0], cancelAddresses[1],\r\n\t        cancelValues[1], cancelValues[2], cancelAddresses[2]\r\n        );\r\n        require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", orderHash), v[0], rs[0], rs[1]) == cancelAddresses[2]);\r\n\r\n        // Cancel action should be signed by order owner\r\n        bytes32 cancelHash = keccak256(this, orderHash, cancelAddresses[3], cancelValues[3]);\r\n        require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", cancelHash), v[1], rs[2], rs[3]) == cancelAddresses[3]);\r\n\r\n        // Order owner should be the same as cancel's initiator\r\n        require(cancelAddresses[2] == cancelAddresses[3]);\r\n\r\n        // Do not allow to cancel already canceled or filled orders\r\n        require(orderFills[orderHash] != cancelValues[0]);\r\n\r\n        // Cancel gas fee cannot exceed 0.05 ETh\r\n        if (cancelValues[4] > 50 finney) {\r\n            cancelValues[4] = 50 finney;\r\n        }\r\n\r\n        // Take cancel fee\r\n        // This operation throws an error if fee amount is greater than the user balance\r\n        //tokens[address(0)][cancelAddresses[3]] = safeSub(tokens[address(0)][cancelAddresses[3]], cancelValues[4]);\r\n        subBalance(address(0), cancelAddresses[3], cancelValues[4]);\r\n\r\n        // Cancel order by setting amount filled to total order value, i.e. making the order filled\r\n        orderFills[orderHash] = cancelValues[0];\r\n\r\n        // Fire cancel order event\r\n        emit CancelOrder(cancelHash, orderHash, cancelAddresses[3], cancelAddresses[1], cancelValues[1], cancelValues[4]);\r\n    }\r\n\r\n    // Returns the smaller of two values\r\n    function min(uint a, uint b) private pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"futuresContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assertion\",\"type\":\"bool\"}],\"name\":\"assert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"makerFee_\",\"type\":\"uint256\"},{\"name\":\"takerFee_\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"subBalance\",\"type\":\"uint256\"},{\"name\":\"addReserve\",\"type\":\"uint256\"}],\"name\":\"subBalanceAddReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"address\"},{\"name\":\"isFuturesContract\",\"type\":\"bool\"}],\"name\":\"setFuturesContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"feeWithdrawal\",\"type\":\"uint256\"}],\"name\":\"adminWithdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastActiveTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"availableBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"futuresContractAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EtmTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setReserve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"takerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"subBalance\",\"type\":\"uint256\"},{\"name\":\"subReserve\",\"type\":\"uint256\"}],\"name\":\"subBalanceSubReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"addBalance\",\"type\":\"uint256\"},{\"name\":\"subReserve\",\"type\":\"uint256\"}],\"name\":\"addBalanceSubReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"allowFuturesContractForUserByFuturesContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"},{\"name\":\"user\",\"type\":\"address[]\"},{\"name\":\"nonce\",\"type\":\"uint256[]\"},{\"name\":\"v\",\"type\":\"uint8[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"},{\"name\":\"feeWithdrawal\",\"type\":\"uint256[]\"}],\"name\":\"batchAdminWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2][]\"},{\"name\":\"rs\",\"type\":\"bytes32[4][]\"},{\"name\":\"tradeValues\",\"type\":\"uint256[8][]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[6][]\"}],\"name\":\"batchOrderTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"rs\",\"type\":\"bytes32[4]\"},{\"name\":\"cancelValues\",\"type\":\"uint256[5]\"},{\"name\":\"cancelAddresses\",\"type\":\"address[4]\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"out\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"taker\",\"type\":\"address\"}],\"name\":\"getMakerTakerBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"address\"}],\"name\":\"userAllowFuturesContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInactivityReleasePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userFirstDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBalance\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"decodeBalanceAndReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"allowFuturesContractForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"rs\",\"type\":\"bytes32[4]\"},{\"name\":\"tradeValues\",\"type\":\"uint256[8]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[6]\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"filledTakerTokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"setInactivityReleasePeriod\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"futuresContractsAddedBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inactivityReleasePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userAllowedFuturesContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"makerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fistFuturesContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"feeAccount_\",\"type\":\"address\"},{\"name\":\"makerFee_\",\"type\":\"uint256\"},{\"name\":\"takerFee_\",\"type\":\"uint256\"},{\"name\":\"inactivityReleasePeriod_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"futuresContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isFuturesContract\",\"type\":\"bool\"}],\"name\":\"SetFuturesContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"takerTokenBuy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"takerAmountBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerTokenSell\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"takerAmountSell\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"makerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"makerAmountTaken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerAmountTaken\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"makerOrderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"takerOrderHash\",\"type\":\"bytes32\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawFee\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawFee\",\"type\":\"uint256\"}],\"name\":\"WithdrawTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"makerFee\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"takerFee\",\"type\":\"uint256\"}],\"name\":\"FeeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"futuresContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AllowFuturesContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"errorId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"makerOrderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"takerOrderHash\",\"type\":\"bytes32\"}],\"name\":\"LogError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogUint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"LogBool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"address\"}],\"name\":\"LogAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InactivityReleasePeriodChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"cancelHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenSell\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountSell\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cancelFee\",\"type\":\"uint256\"}],\"name\":\"CancelOrder\",\"type\":\"event\"}]", "ContractName": "Exchange", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000095445852148540acb6fcb9e39856d15f1c416381000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000071afd498d000000000000000000000000000000000000000000000000000000000000000186a0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://b42279176a72eb9a503ec3b6d4d6ee61fc2d34eb3b635990563f17e57f53a5ac"}