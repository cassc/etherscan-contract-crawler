{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IMintable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface IMintable {\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function mint(address mintReceiver, uint256 amount) external;\\n    function totalSupply() external returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/MintTranche.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./interfaces/IMintable.sol\\\";\\nimport {MerkleProofLib} from \\\"./utils/MerkleProofLib.sol\\\";\\n\\ncontract MintTranche {\\n    address payable public owner;\\n    IMintable public mintable;\\n\\n    bytes32 public root;\\n    bool whitelistActive;\\n\\n    uint256 public trancheRemaining;\\n    uint256 public trancheEnd;\\n\\n    uint256 public mintPrice = 0.123 ether;\\n\\n    mapping(address => uint256) public hasMinted;\\n\\n    event TrancheCreated(uint amount, uint end);\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Not Owner\\\");\\n        _;\\n    }\\n\\n    function changeOwner(address payable _owner) external onlyOwner() {\\n        owner = _owner;\\n    }\\n\\n    function setMintable(IMintable _mintable) external onlyOwner() {\\n        require(address(mintable) == address(0) && address(_mintable) != address(0));\\n\\n        mintable = _mintable;\\n    }\\n\\n    function setRoot(bytes32 _root) external onlyOwner() {\\n        root = _root;\\n    }\\n\\n    function setWhitelist(bool _active) external onlyOwner(){\\n        whitelistActive = _active;\\n    }\\n\\n    constructor() payable {\\n        owner = payable(msg.sender);\\n    }\\n\\n    function createTranche(uint256 trancheAmount, uint256 endTime) public onlyOwner() {\\n        require(address(mintable) != address(0));\\n        \\n        trancheRemaining = trancheAmount;\\n        trancheEnd = endTime;\\n\\n        emit TrancheCreated(trancheAmount, endTime);\\n    }\\n\\n    function mint(uint256 amount, bytes32[] memory proof) payable public {\\n        require(block.timestamp < trancheEnd, 'Tranche not active');\\n        require(trancheRemaining >= amount, 'Not enough remaining in current tranche');\\n        require(msg.value == mintPrice * amount, 'wrong price');\\n        require(hasMinted[msg.sender] + amount <= 2, 'Mint limit 2');\\n\\n        if (whitelistActive) {\\n            bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(msg.sender))));\\n            require(MerkleProofLib.verify(proof, root, leaf), \\\"Invalid proof\\\");\\n        }\\n\\n        hasMinted[msg.sender] += amount;\\n        mintable.mint(address(msg.sender), amount);\\n\\n        trancheRemaining = trancheRemaining - amount;\\n    }\\n\\n    function withdraw() external onlyOwner() {\\n        (bool success, ) = owner.call{ value: address(this).balance }(\\\"\\\");\\n        require(success, \\\"Transfer failed.\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/MerkleProofLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)\\nlibrary MerkleProofLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*            MERKLE PROOF VERIFICATION OPERATIONS            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\\n        internal\\n        pure\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(proof) {\\n                // Initialize `offset` to the offset of `proof` elements in memory.\\n                let offset := add(proof, 0x20)\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                let end := add(offset, shl(5, mload(proof)))\\n                // Iterate over proof elements to compute root hash.\\n                for {} 1 {} {\\n                    // Slot of `leaf` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(leaf, mload(offset)))\\n                    // Store elements to hash contiguously in scratch space.\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\n                    mstore(scratch, leaf)\\n                    mstore(xor(scratch, 0x20), mload(offset))\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\n                    leaf := keccak256(0x00, 0x40)\\n                    offset := add(offset, 0x20)\\n                    if iszero(lt(offset, end)) { break }\\n                }\\n            }\\n            isValid := eq(leaf, root)\\n        }\\n    }\\n\\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\\n        internal\\n        pure\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if proof.length {\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                let end := add(proof.offset, shl(5, proof.length))\\n                // Initialize `offset` to the offset of `proof` in the calldata.\\n                let offset := proof.offset\\n                // Iterate over proof elements to compute root hash.\\n                for {} 1 {} {\\n                    // Slot of `leaf` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\\n                    // Store elements to hash contiguously in scratch space.\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\n                    mstore(scratch, leaf)\\n                    mstore(xor(scratch, 0x20), calldataload(offset))\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\n                    leaf := keccak256(0x00, 0x40)\\n                    offset := add(offset, 0x20)\\n                    if iszero(lt(offset, end)) { break }\\n                }\\n            }\\n            isValid := eq(leaf, root)\\n        }\\n    }\\n\\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\\n    /// given `proof` and `flags`.\\n    function verifyMultiProof(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32[] memory leaves,\\n        bool[] memory flags\\n    ) internal pure returns (bool isValid) {\\n        // Rebuilds the root by consuming and producing values on a queue.\\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\\n        // After the process, the last element on the queue is verified\\n        // to be equal to the `root`.\\n        //\\n        // The `flags` array denotes whether the sibling\\n        // should be popped from the queue (`flag == true`), or\\n        // should be popped from the `proof` (`flag == false`).\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cache the lengths of the arrays.\\n            let leavesLength := mload(leaves)\\n            let proofLength := mload(proof)\\n            let flagsLength := mload(flags)\\n\\n            // Advance the pointers of the arrays to point to the data.\\n            leaves := add(0x20, leaves)\\n            proof := add(0x20, proof)\\n            flags := add(0x20, flags)\\n\\n            // If the number of flags is correct.\\n            for {} eq(add(leavesLength, proofLength), add(flagsLength, 1)) {} {\\n                // For the case where `proof.length + leaves.length == 1`.\\n                if iszero(flagsLength) {\\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\\n                    isValid := eq(mload(xor(leaves, mul(xor(proof, leaves), proofLength))), root)\\n                    break\\n                }\\n\\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\\n                let proofEnd := mul(iszero(iszero(flagsLength)), add(proof, shl(5, proofLength)))\\n                // We can use the free memory space for the queue.\\n                // We don't need to allocate, since the queue is temporary.\\n                let hashesFront := mload(0x40)\\n                // Copy the leaves into the hashes.\\n                // Sometimes, a little memory expansion costs less than branching.\\n                // Should cost less, even with a high free memory offset of 0x7d00.\\n                leavesLength := shl(5, leavesLength)\\n                for { let i := 0 } iszero(eq(i, leavesLength)) { i := add(i, 0x20) } {\\n                    mstore(add(hashesFront, i), mload(add(leaves, i)))\\n                }\\n                // Compute the back of the hashes.\\n                let hashesBack := add(hashesFront, leavesLength)\\n                // This is the end of the memory for the queue.\\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\\n                flagsLength := add(hashesBack, shl(5, flagsLength))\\n\\n                for {} 1 {} {\\n                    // Pop from `hashes`.\\n                    let a := mload(hashesFront)\\n                    // Pop from `hashes`.\\n                    let b := mload(add(hashesFront, 0x20))\\n                    hashesFront := add(hashesFront, 0x40)\\n\\n                    // If the flag is false, load the next proof,\\n                    // else, pops from the queue.\\n                    if iszero(mload(flags)) {\\n                        // Loads the next proof.\\n                        b := mload(proof)\\n                        proof := add(proof, 0x20)\\n                        // Unpop from `hashes`.\\n                        hashesFront := sub(hashesFront, 0x20)\\n                    }\\n\\n                    // Advance to the next flag.\\n                    flags := add(flags, 0x20)\\n\\n                    // Slot of `a` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(a, b))\\n                    // Hash the scratch space and push the result onto the queue.\\n                    mstore(scratch, a)\\n                    mstore(xor(scratch, 0x20), b)\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\n                    hashesBack := add(hashesBack, 0x20)\\n                    if iszero(lt(hashesBack, flagsLength)) { break }\\n                }\\n                isValid :=\\n                    and(\\n                        // Checks if the last value in the queue is same as the root.\\n                        eq(mload(sub(hashesBack, 0x20)), root),\\n                        // And whether all the proofs are used, if required (i.e. `proofEnd != 0`).\\n                        or(iszero(proofEnd), eq(proofEnd, proof))\\n                    )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\\n    /// given `proof` and `flags`.\\n    function verifyMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32[] calldata leaves,\\n        bool[] calldata flags\\n    ) internal pure returns (bool isValid) {\\n        // Rebuilds the root by consuming and producing values on a queue.\\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\\n        // After the process, the last element on the queue is verified\\n        // to be equal to the `root`.\\n        //\\n        // The `flags` array denotes whether the sibling\\n        // should be popped from the queue (`flag == true`), or\\n        // should be popped from the `proof` (`flag == false`).\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the number of flags is correct.\\n            for {} eq(add(leaves.length, proof.length), add(flags.length, 1)) {} {\\n                // For the case where `proof.length + leaves.length == 1`.\\n                if iszero(flags.length) {\\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\\n                    // forgefmt: disable-next-item\\n                    isValid := eq(\\n                        calldataload(\\n                            xor(leaves.offset, mul(xor(proof.offset, leaves.offset), proof.length))\\n                        ),\\n                        root\\n                    )\\n                    break\\n                }\\n\\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\\n                let proofEnd :=\\n                    mul(iszero(iszero(flags.length)), add(proof.offset, shl(5, proof.length)))\\n                // We can use the free memory space for the queue.\\n                // We don't need to allocate, since the queue is temporary.\\n                let hashesFront := mload(0x40)\\n                // Copy the leaves into the hashes.\\n                // Sometimes, a little memory expansion costs less than branching.\\n                // Should cost less, even with a high free memory offset of 0x7d00.\\n                calldatacopy(hashesFront, leaves.offset, shl(5, leaves.length))\\n                // Compute the back of the hashes.\\n                let hashesBack := add(hashesFront, shl(5, leaves.length))\\n                // This is the end of the memory for the queue.\\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\\n                flags.length := add(hashesBack, shl(5, flags.length))\\n\\n                // We don't need to make a copy of `proof.offset` or `flags.offset`,\\n                // as they are pass-by-value (this trick may not always save gas).\\n\\n                for {} 1 {} {\\n                    // Pop from `hashes`.\\n                    let a := mload(hashesFront)\\n                    // Pop from `hashes`.\\n                    let b := mload(add(hashesFront, 0x20))\\n                    hashesFront := add(hashesFront, 0x40)\\n\\n                    // If the flag is false, load the next proof,\\n                    // else, pops from the queue.\\n                    if iszero(calldataload(flags.offset)) {\\n                        // Loads the next proof.\\n                        b := calldataload(proof.offset)\\n                        proof.offset := add(proof.offset, 0x20)\\n                        // Unpop from `hashes`.\\n                        hashesFront := sub(hashesFront, 0x20)\\n                    }\\n\\n                    // Advance to the next flag offset.\\n                    flags.offset := add(flags.offset, 0x20)\\n\\n                    // Slot of `a` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(a, b))\\n                    // Hash the scratch space and push the result onto the queue.\\n                    mstore(scratch, a)\\n                    mstore(xor(scratch, 0x20), b)\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\n                    hashesBack := add(hashesBack, 0x20)\\n                    if iszero(lt(hashesBack, flags.length)) { break }\\n                }\\n                isValid :=\\n                    and(\\n                        // Checks if the last value in the queue is same as the root.\\n                        eq(mload(sub(hashesBack, 0x20)), root),\\n                        // And whether all the proofs are used, if required (i.e. `proofEnd != 0`).\\n                        or(iszero(proofEnd), eq(proofEnd, proof.offset))\\n                    )\\n                break\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes32 array.\\n    function emptyProof() internal pure returns (bytes32[] calldata proof) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            proof.length := 0\\n        }\\n    }\\n\\n    /// @dev Returns an empty calldata bytes32 array.\\n    function emptyLeaves() internal pure returns (bytes32[] calldata leaves) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            leaves.length := 0\\n        }\\n    }\\n\\n    /// @dev Returns an empty calldata bool array.\\n    function emptyFlags() internal pure returns (bool[] calldata flags) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            flags.length := 0\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"TrancheCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"trancheAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"createTranche\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintable\",\"outputs\":[{\"internalType\":\"contract IMintable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMintable\",\"name\":\"_mintable\",\"type\":\"address\"}],\"name\":\"setMintable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"setRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trancheEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trancheRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MintTranche", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}