{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/IERC5267.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\\n\\npragma solidity ^0.8.20;\\n\\ninterface IERC5267 {\\n    /**\\n     * @dev MAY be emitted to signal that the domain could have changed.\\n     */\\n    event EIP712DomainChanged();\\n\\n    /**\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\n     * signature.\\n     */\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n */\\nlibrary Clones {\\n    /**\\n     * @dev A clone instance deployment failed.\\n     */\\n    error ERC1167FailedCreateClone();\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKeeperOracles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.20;\\n\\nimport {IERC5267} from '@openzeppelin/contracts/interfaces/IERC5267.sol';\\n\\n/**\\n * @title IKeeperOracles\\n * @author StakeWise\\n * @notice Defines the interface for the KeeperOracles contract\\n */\\ninterface IKeeperOracles is IERC5267 {\\n  /**\\n   * @notice Event emitted on the oracle addition\\n   * @param oracle The address of the added oracle\\n   */\\n  event OracleAdded(address indexed oracle);\\n\\n  /**\\n   * @notice Event emitted on the oracle removal\\n   * @param oracle The address of the removed oracle\\n   */\\n  event OracleRemoved(address indexed oracle);\\n\\n  /**\\n   * @notice Event emitted on oracles config update\\n   * @param configIpfsHash The IPFS hash of the new config\\n   */\\n  event ConfigUpdated(string configIpfsHash);\\n\\n  /**\\n   * @notice Function for verifying whether oracle is registered or not\\n   * @param oracle The address of the oracle to check\\n   * @return `true` for the registered oracle, `false` otherwise\\n   */\\n  function isOracle(address oracle) external view returns (bool);\\n\\n  /**\\n   * @notice Total Oracles\\n   * @return The total number of oracles registered\\n   */\\n  function totalOracles() external view returns (uint256);\\n\\n  /**\\n   * @notice Function for adding oracle to the set\\n   * @param oracle The address of the oracle to add\\n   */\\n  function addOracle(address oracle) external;\\n\\n  /**\\n   * @notice Function for removing oracle from the set\\n   * @param oracle The address of the oracle to remove\\n   */\\n  function removeOracle(address oracle) external;\\n\\n  /**\\n   * @notice Function for updating the config IPFS hash\\n   * @param configIpfsHash The new config IPFS hash\\n   */\\n  function updateConfig(string calldata configIpfsHash) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKeeperRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.20;\\n\\nimport {IKeeperOracles} from './IKeeperOracles.sol';\\n\\n/**\\n * @title IKeeperRewards\\n * @author StakeWise\\n * @notice Defines the interface for the Keeper contract rewards\\n */\\ninterface IKeeperRewards is IKeeperOracles {\\n  /**\\n   * @notice Event emitted on rewards update\\n   * @param caller The address of the function caller\\n   * @param rewardsRoot The new rewards merkle tree root\\n   * @param avgRewardPerSecond The new average reward per second\\n   * @param updateTimestamp The update timestamp used for rewards calculation\\n   * @param nonce The nonce used for verifying signatures\\n   * @param rewardsIpfsHash The new rewards IPFS hash\\n   */\\n  event RewardsUpdated(\\n    address indexed caller,\\n    bytes32 indexed rewardsRoot,\\n    uint256 avgRewardPerSecond,\\n    uint64 updateTimestamp,\\n    uint64 nonce,\\n    string rewardsIpfsHash\\n  );\\n\\n  /**\\n   * @notice Event emitted on Vault harvest\\n   * @param vault The address of the Vault\\n   * @param rewardsRoot The rewards merkle tree root\\n   * @param totalAssetsDelta The Vault total assets delta since last sync. Can be negative in case of penalty/slashing.\\n   * @param unlockedMevDelta The Vault execution reward that can be withdrawn from shared MEV escrow. Only used by shared MEV Vaults.\\n   */\\n  event Harvested(\\n    address indexed vault,\\n    bytes32 indexed rewardsRoot,\\n    int256 totalAssetsDelta,\\n    uint256 unlockedMevDelta\\n  );\\n\\n  /**\\n   * @notice Event emitted on rewards min oracles number update\\n   * @param oracles The new minimum number of oracles required to update rewards\\n   */\\n  event RewardsMinOraclesUpdated(uint256 oracles);\\n\\n  /**\\n   * @notice A struct containing the last synced Vault's cumulative reward\\n   * @param assets The Vault cumulative reward earned since the start. Can be negative in case of penalty/slashing.\\n   * @param nonce The nonce of the last sync\\n   */\\n  struct Reward {\\n    int192 assets;\\n    uint64 nonce;\\n  }\\n\\n  /**\\n   * @notice A struct containing the last unlocked Vault's cumulative execution reward that can be withdrawn from shared MEV escrow. Only used by shared MEV Vaults.\\n   * @param assets The shared MEV Vault's cumulative execution reward that can be withdrawn\\n   * @param nonce The nonce of the last sync\\n   */\\n  struct UnlockedMevReward {\\n    uint192 assets;\\n    uint64 nonce;\\n  }\\n\\n  /**\\n   * @notice A struct containing parameters for rewards update\\n   * @param rewardsRoot The new rewards merkle root\\n   * @param avgRewardPerSecond The new average reward per second\\n   * @param updateTimestamp The update timestamp used for rewards calculation\\n   * @param rewardsIpfsHash The new IPFS hash with all the Vaults' rewards for the new root\\n   * @param signatures The concatenation of the Oracles' signatures\\n   */\\n  struct RewardsUpdateParams {\\n    bytes32 rewardsRoot;\\n    uint256 avgRewardPerSecond;\\n    uint64 updateTimestamp;\\n    string rewardsIpfsHash;\\n    bytes signatures;\\n  }\\n\\n  /**\\n   * @notice A struct containing parameters for harvesting rewards. Can only be called by Vault.\\n   * @param rewardsRoot The rewards merkle root\\n   * @param reward The Vault cumulative reward earned since the start. Can be negative in case of penalty/slashing.\\n   * @param unlockedMevReward The Vault cumulative execution reward that can be withdrawn from shared MEV escrow. Only used by shared MEV Vaults.\\n   * @param proof The proof to verify that Vault's reward is correct\\n   */\\n  struct HarvestParams {\\n    bytes32 rewardsRoot;\\n    int160 reward;\\n    uint160 unlockedMevReward;\\n    bytes32[] proof;\\n  }\\n\\n  /**\\n   * @notice Previous Rewards Root\\n   * @return The previous merkle tree root of the rewards accumulated by the Vaults\\n   */\\n  function prevRewardsRoot() external view returns (bytes32);\\n\\n  /**\\n   * @notice Rewards Root\\n   * @return The latest merkle tree root of the rewards accumulated by the Vaults\\n   */\\n  function rewardsRoot() external view returns (bytes32);\\n\\n  /**\\n   * @notice Rewards Nonce\\n   * @return The nonce used for updating rewards merkle tree root\\n   */\\n  function rewardsNonce() external view returns (uint64);\\n\\n  /**\\n   * @notice The last rewards update\\n   * @return The timestamp of the last rewards update\\n   */\\n  function lastRewardsTimestamp() external view returns (uint64);\\n\\n  /**\\n   * @notice The minimum number of oracles required to update rewards\\n   * @return The minimum number of oracles\\n   */\\n  function rewardsMinOracles() external view returns (uint256);\\n\\n  /**\\n   * @notice The rewards delay\\n   * @return The delay in seconds between rewards updates\\n   */\\n  function rewardsDelay() external view returns (uint256);\\n\\n  /**\\n   * @notice Get last synced Vault cumulative reward\\n   * @param vault The address of the Vault\\n   * @return assets The last synced reward assets\\n   * @return nonce The last synced reward nonce\\n   */\\n  function rewards(address vault) external view returns (int192 assets, uint64 nonce);\\n\\n  /**\\n   * @notice Get last unlocked shared MEV Vault cumulative reward\\n   * @param vault The address of the Vault\\n   * @return assets The last synced reward assets\\n   * @return nonce The last synced reward nonce\\n   */\\n  function unlockedMevRewards(address vault) external view returns (uint192 assets, uint64 nonce);\\n\\n  /**\\n   * @notice Checks whether Vault must be harvested\\n   * @param vault The address of the Vault\\n   * @return `true` if the Vault requires harvesting, `false` otherwise\\n   */\\n  function isHarvestRequired(address vault) external view returns (bool);\\n\\n  /**\\n   * @notice Checks whether the Vault can be harvested\\n   * @param vault The address of the Vault\\n   * @return `true` if Vault can be harvested, `false` otherwise\\n   */\\n  function canHarvest(address vault) external view returns (bool);\\n\\n  /**\\n   * @notice Checks whether rewards can be updated\\n   * @return `true` if rewards can be updated, `false` otherwise\\n   */\\n  function canUpdateRewards() external view returns (bool);\\n\\n  /**\\n   * @notice Checks whether the Vault has registered validators\\n   * @param vault The address of the Vault\\n   * @return `true` if Vault is collateralized, `false` otherwise\\n   */\\n  function isCollateralized(address vault) external view returns (bool);\\n\\n  /**\\n   * @notice Update rewards data\\n   * @param params The struct containing rewards update parameters\\n   */\\n  function updateRewards(RewardsUpdateParams calldata params) external;\\n\\n  /**\\n   * @notice Harvest rewards. Can be called only by Vault.\\n   * @param params The struct containing rewards harvesting parameters\\n   * @return totalAssetsDelta The total reward/penalty accumulated by the Vault since the last sync\\n   * @return unlockedMevDelta The Vault execution reward that can be withdrawn from shared MEV escrow. Only used by shared MEV Vaults.\\n   * @return harvested `true` when the rewards were harvested, `false` otherwise\\n   */\\n  function harvest(\\n    HarvestParams calldata params\\n  ) external returns (int256 totalAssetsDelta, uint256 unlockedMevDelta, bool harvested);\\n\\n  /**\\n   * @notice Set min number of oracles for confirming rewards update. Can only be called by the owner.\\n   * @param _rewardsMinOracles The new min number of oracles for confirming rewards update\\n   */\\n  function setRewardsMinOracles(uint256 _rewardsMinOracles) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity =0.8.20;\\n\\n/**\\n * @title Multicall\\n * @author Uniswap\\n * @notice Adopted from https://github.com/Uniswap/v3-periphery/blob/1d69caf0d6c8cfeae9acd1f34ead30018d6e6400/contracts/base/Multicall.sol\\n * @notice Enables calling multiple methods in a single call to the contract\\n */\\ninterface IMulticall {\\n  /**\\n   * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n   * @param data The encoded function data for each of the calls to make to this contract\\n   * @return results The results from each of the calls passed in via data\\n   */\\n  function multicall(bytes[] calldata data) external returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewardSplitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.20;\\n\\nimport {IMulticall} from './IMulticall.sol';\\nimport {IKeeperRewards} from './IKeeperRewards.sol';\\n\\n/**\\n * @title IRewardSplitter\\n * @author StakeWise\\n * @notice Defines the interface for the RewardSplitter contract\\n */\\ninterface IRewardSplitter is IMulticall {\\n  // Custom errors\\n  error NotHarvested();\\n  error InvalidAccount();\\n  error InvalidAmount();\\n\\n  /**\\n   * @notice Structure for storing information about share holder\\n   * @param shares The amount of shares the account has\\n   * @param rewardPerShare The last synced reward per share\\n   */\\n  struct ShareHolder {\\n    uint128 shares;\\n    uint128 rewardPerShare;\\n  }\\n\\n  /**\\n   * @notice Event emitted when the number of shares is increased for an account\\n   * @param account The address of the account for which the shares were increased\\n   * @param amount The amount of shares that were added\\n   */\\n  event SharesIncreased(address indexed account, uint256 amount);\\n\\n  /**\\n   * @notice Event emitted when the number of shares is decreased for an account\\n   * @param account The address of the account for which the shares were decreased\\n   * @param amount The amount of shares that were deducted\\n   */\\n  event SharesDecreased(address indexed account, uint256 amount);\\n\\n  /**\\n   * @notice Event emitted when the rewards are synced from the vault.\\n   * @param totalRewards The new total amount of rewards\\n   * @param rewardPerShare The new reward per share\\n   */\\n  event RewardsSynced(uint256 totalRewards, uint256 rewardPerShare);\\n\\n  /**\\n   * @notice Event emitted when the rewards are withdrawn from the splitter\\n   * @param account The address of the account for which the rewards were withdrawn\\n   * @param amount The amount of rewards that were withdrawn\\n   */\\n  event RewardsWithdrawn(address indexed account, uint256 amount);\\n\\n  /**\\n   * @notice The vault to which the RewardSplitter is connected\\n   * @return The address of the vault\\n   */\\n  function vault() external returns (address);\\n\\n  /**\\n   * @notice The total number of shares in the splitter\\n   * @return The total number of shares\\n   */\\n  function totalShares() external returns (uint256);\\n\\n  /**\\n   * @notice Initializes the RewardSplitter contract\\n   * @param owner The address of the owner of the RewardSplitter contract\\n   * @param _vault The address of the vault to which the RewardSplitter will be connected\\n   */\\n  function initialize(address owner, address _vault) external;\\n\\n  /**\\n   * @notice Retrieves the amount of splitter shares for the given account.\\n             The shares are used to calculate the amount of rewards the account is entitled to.\\n   * @param account The address of the account to get shares for\\n   */\\n  function sharesOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice Retrieves the amount of rewards the account is entitled to.\\n             The rewards are calculated based on the amount of shares the account has.\\n             Note, rewards must be synced using the `syncRewards` function.\\n   * @param account The address of the account to get rewards for\\n   */\\n  function rewardsOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice Checks whether new rewards can be synced from the vault.\\n   * @return True if new rewards can be synced, false otherwise\\n   */\\n  function canSyncRewards() external view returns (bool);\\n\\n  /**\\n   * @notice Increases the amount of shares for the given account. Can only be called by the owner.\\n   * @param account The address of the account to increase shares for\\n   * @param amount The amount of shares to add\\n   */\\n  function increaseShares(address account, uint128 amount) external;\\n\\n  /**\\n   * @notice Decreases the amount of shares for the given account. Can only be called by the owner.\\n   * @param account The address of the account to decrease shares for\\n   * @param amount The amount of shares to deduct\\n   */\\n  function decreaseShares(address account, uint128 amount) external;\\n\\n  /**\\n   * @notice Updates the vault state. Can be used in multicall to update state, sync rewards and withdraw them.\\n   * @param harvestParams The harvest params to use for updating the vault state\\n   */\\n  function updateVaultState(IKeeperRewards.HarvestParams calldata harvestParams) external;\\n\\n  /**\\n   * @notice Transfers the vault tokens to the given account. Can only be called for the vault with ERC-20 token.\\n   * @param rewards The amount of vault tokens to transfer\\n   * @param receiver The address of the account to transfer tokens to\\n   */\\n  function claimVaultTokens(uint256 rewards, address receiver) external;\\n\\n  /**\\n   * @notice Sends the rewards to the exit queue\\n   * @param rewards The amount of rewards to send to the exit queue\\n   * @param receiver The address that will claim exited assets\\n   * @return positionTicket The position ticket of the exit queue\\n   */\\n  function enterExitQueue(\\n    uint256 rewards,\\n    address receiver\\n  ) external returns (uint256 positionTicket);\\n\\n  /**\\n   * @notice Redeems available assets from the vault\\n   * @param rewards The amount of rewards to redeem\\n   * @param receiver The address that will receive the redeemed assets\\n   * @return assets The amount of assets that were redeemed\\n   */\\n  function redeem(uint256 rewards, address receiver) external returns (uint256 assets);\\n\\n  /**\\n   * @notice Syncs the rewards from the vault to the splitter. The vault state must be up-to-date.\\n   */\\n  function syncRewards() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewardSplitterFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.20;\\n\\n/**\\n * @title IRewardSplitterFactory\\n * @author StakeWise\\n * @notice Defines the interface for the RewardSplitterFactory contract\\n */\\ninterface IRewardSplitterFactory {\\n  /**\\n   * @notice Event emitted on a RewardSplitter creation\\n   * @param owner The address of the RewardSplitter owner\\n   * @param vault The address of the connected vault\\n   * @param rewardSplitter The address of the created RewardSplitter\\n   */\\n  event RewardSplitterCreated(address owner, address vault, address rewardSplitter);\\n\\n  /**\\n   * @notice The address of the RewardSplitter implementation contract used for proxy creation\\n   * @return The address of the RewardSplitter proxy contract\\n   */\\n  function implementation() external view returns (address);\\n\\n  /**\\n   * @notice Creates RewardSplitter contract proxy\\n   * @param vault The address of the vault to which the RewardSplitter will be connected\\n   * @return rewardSplitter The address of the created RewardSplitter contract\\n   */\\n  function createRewardSplitter(address vault) external returns (address rewardSplitter);\\n}\\n\"\r\n    },\r\n    \"contracts/misc/RewardSplitterFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.20;\\n\\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\\nimport {IRewardSplitter} from '../interfaces/IRewardSplitter.sol';\\nimport {IRewardSplitterFactory} from '../interfaces/IRewardSplitterFactory.sol';\\n\\n/**\\n * @title RewardSplitterFactory\\n * @author StakeWise\\n * @notice Factory for deploying the RewardSplitter contract\\n */\\ncontract RewardSplitterFactory is IRewardSplitterFactory {\\n  /// @inheritdoc IRewardSplitterFactory\\n  address public immutable override implementation;\\n\\n  /**\\n   * @dev Constructor\\n   * @param _implementation The implementation address of RewardSplitter\\n   */\\n  constructor(address _implementation) {\\n    implementation = _implementation;\\n  }\\n\\n  /// @inheritdoc IRewardSplitterFactory\\n  function createRewardSplitter(address vault) external override returns (address rewardSplitter) {\\n    // deploy and initialize reward splitter\\n    rewardSplitter = Clones.clone(implementation);\\n    IRewardSplitter(rewardSplitter).initialize(msg.sender, vault);\\n\\n    // emit event\\n    emit RewardSplitterCreated(msg.sender, vault, rewardSplitter);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ERC1167FailedCreateClone\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardSplitter\",\"type\":\"address\"}],\"name\":\"RewardSplitterCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"createRewardSplitter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"rewardSplitter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RewardSplitterFactory", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000067561ca10e0c03600fc78bb7ba19ec32886aca9b", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}