{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n * .----------------.  .----------------.  .----------------.  .----------------.  .----------------. \r\n * | .--------------. || .--------------. || .--------------. || .--------------. || .--------------. |\r\n * | |  ____  ____  | || |  _________   | || |   _____      | || |     _____    | || |  ____  ____  | |\r\n * | | |_   ||   _| | || | |_   ___  |  | || |  |_   _|     | || |    |_   _|   | || | |_  _||_  _| | |\r\n * | |   | |__| |   | || |   | |_  \\_|  | || |    | |       | || |      | |     | || |   \\ \\  / /   | |\r\n * | |   |  __  |   | || |   |  _|  _   | || |    | |   _   | || |      | |     | || |    > `' <    | |\r\n * | |  _| |  | |_  | || |  _| |___/ |  | || |   _| |__/ |  | || |     _| |_    | || |  _/ /'`\\ \\_  | |\r\n * | | |____||____| | || | |_________|  | || |  |________|  | || |    |_____|   | || | |____||____| | |\r\n * | |              | || |              | || |              | || |              | || |              | |\r\n * | '--------------' || '--------------' || '--------------' || '--------------' || '--------------' |\r\n *  '----------------'  '----------------'  '----------------'  '----------------'  '----------------' '\r\n * \r\n *\r\n * 10/18/2023\r\n **/\r\n\r\npragma solidity ^0.8.17;\r\n\r\n// File contracts/ln/interface/ILowLevelMessager.sol\r\n// License-Identifier: MIT\r\n\r\ninterface ILowLevelMessageSender {\r\n    function registerRemoteReceiver(uint256 remoteChainId, address remoteBridge) external;\r\n    function sendMessage(uint256 remoteChainId, bytes memory message, bytes memory params) external payable;\r\n}\r\n\r\ninterface ILowLevelMessageReceiver {\r\n    function registerRemoteSender(uint256 remoteChainId, address remoteBridge) external;\r\n    function recvMessage(address remoteSender, address localReceiver, bytes memory payload) external;\r\n}\r\n\r\n// File contracts/ln/base/LnAccessController.sol\r\n// License-Identifier: MIT\r\n\r\n/// @title LnAccessController\r\n/// @notice LnAccessController is a contract to control the access permission \r\n/// @dev See https://github.com/helix-bridge/contracts/tree/master/helix-contract\r\ncontract LnAccessController {\r\n    address public dao;\r\n    address public operator;\r\n\r\n    mapping(address=>bool) public callerWhiteList;\r\n\r\n    modifier onlyDao() {\r\n        require(msg.sender == dao, \"!dao\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operator, \"!operator\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhiteListCaller() {\r\n        require(callerWhiteList[msg.sender], \"caller not in white list\");\r\n        _;\r\n    }\r\n\r\n    function _initialize(address _dao) internal {\r\n        dao = _dao;\r\n        operator = _dao;\r\n    }\r\n\r\n    function setOperator(address _operator) onlyDao external {\r\n        operator = _operator;\r\n    }\r\n\r\n    function authoriseAppCaller(address appAddress, bool enable) onlyDao external {\r\n        callerWhiteList[appAddress] = enable;\r\n    }\r\n\r\n    function transferOwnership(address _dao) onlyDao external {\r\n        dao = _dao;\r\n    }\r\n}\r\n\r\n// File @arbitrum/nitro-contracts/src/bridge/IOwnable.sol@v1.0.1\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/nitro/blob/master/LICENSE\r\n// License-Identifier: BUSL-1.1\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.4.21 <0.9.0;\r\n\r\ninterface IOwnable {\r\n    function owner() external view returns (address);\r\n}\r\n\r\n// File @arbitrum/nitro-contracts/src/bridge/IBridge.sol@v1.0.1\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/nitro/blob/master/LICENSE\r\n// License-Identifier: BUSL-1.1\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.6.9 <0.9.0;\r\n\r\ninterface IBridge {\r\n    event MessageDelivered(\r\n        uint256 indexed messageIndex,\r\n        bytes32 indexed beforeInboxAcc,\r\n        address inbox,\r\n        uint8 kind,\r\n        address sender,\r\n        bytes32 messageDataHash,\r\n        uint256 baseFeeL1,\r\n        uint64 timestamp\r\n    );\r\n\r\n    event BridgeCallTriggered(\r\n        address indexed outbox,\r\n        address indexed to,\r\n        uint256 value,\r\n        bytes data\r\n    );\r\n\r\n    event InboxToggle(address indexed inbox, bool enabled);\r\n\r\n    event OutboxToggle(address indexed outbox, bool enabled);\r\n\r\n    event SequencerInboxUpdated(address newSequencerInbox);\r\n\r\n    function allowedDelayedInboxList(uint256) external returns (address);\r\n\r\n    function allowedOutboxList(uint256) external returns (address);\r\n\r\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\r\n    function delayedInboxAccs(uint256) external view returns (bytes32);\r\n\r\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\r\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\r\n\r\n    function rollup() external view returns (IOwnable);\r\n\r\n    function sequencerInbox() external view returns (address);\r\n\r\n    function activeOutbox() external view returns (address);\r\n\r\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\r\n\r\n    function allowedOutboxes(address outbox) external view returns (bool);\r\n\r\n    function sequencerReportedSubMessageCount() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Enqueue a message in the delayed inbox accumulator.\r\n     *      These messages are later sequenced in the SequencerInbox, either\r\n     *      by the sequencer as part of a normal batch, or by force inclusion.\r\n     */\r\n    function enqueueDelayedMessage(\r\n        uint8 kind,\r\n        address sender,\r\n        bytes32 messageDataHash\r\n    ) external payable returns (uint256);\r\n\r\n    function executeCall(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bool success, bytes memory returnData);\r\n\r\n    function delayedMessageCount() external view returns (uint256);\r\n\r\n    function sequencerMessageCount() external view returns (uint256);\r\n\r\n    // ---------- onlySequencerInbox functions ----------\r\n\r\n    function enqueueSequencerMessage(\r\n        bytes32 dataHash,\r\n        uint256 afterDelayedMessagesRead,\r\n        uint256 prevMessageCount,\r\n        uint256 newMessageCount\r\n    )\r\n        external\r\n        returns (\r\n            uint256 seqMessageIndex,\r\n            bytes32 beforeAcc,\r\n            bytes32 delayedAcc,\r\n            bytes32 acc\r\n        );\r\n\r\n    /**\r\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\r\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\r\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\r\n     *      every delayed inbox or every sequencer inbox call.\r\n     */\r\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\r\n        external\r\n        returns (uint256 msgNum);\r\n\r\n    // ---------- onlyRollupOrOwner functions ----------\r\n\r\n    function setSequencerInbox(address _sequencerInbox) external;\r\n\r\n    function setDelayedInbox(address inbox, bool enabled) external;\r\n\r\n    function setOutbox(address inbox, bool enabled) external;\r\n\r\n    // ---------- initializer ----------\r\n\r\n    function initialize(IOwnable rollup_) external;\r\n}\r\n\r\n// File @arbitrum/nitro-contracts/src/bridge/IDelayedMessageProvider.sol@v1.0.1\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/nitro/blob/master/LICENSE\r\n// License-Identifier: BUSL-1.1\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.6.9 <0.9.0;\r\n\r\ninterface IDelayedMessageProvider {\r\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\r\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\r\n\r\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\r\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\r\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\r\n}\r\n\r\n// File @arbitrum/nitro-contracts/src/libraries/IGasRefunder.sol@v1.0.1\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/nitro/blob/master/LICENSE\r\n// License-Identifier: BUSL-1.1\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.6.9 <0.9.0;\r\n\r\ninterface IGasRefunder {\r\n    function onGasSpent(\r\n        address payable spender,\r\n        uint256 gasUsed,\r\n        uint256 calldataSize\r\n    ) external returns (bool success);\r\n}\r\n\r\nabstract contract GasRefundEnabled {\r\n    /// @dev this refunds the sender for execution costs of the tx\r\n    /// calldata costs are only refunded if `msg.sender == tx.origin` to guarantee the value refunded relates to charging\r\n    /// for the `tx.input`. this avoids a possible attack where you generate large calldata from a contract and get over-refunded\r\n    modifier refundsGas(IGasRefunder gasRefunder) {\r\n        uint256 startGasLeft = gasleft();\r\n        _;\r\n        if (address(gasRefunder) != address(0)) {\r\n            uint256 calldataSize;\r\n            assembly {\r\n                calldataSize := calldatasize()\r\n            }\r\n            uint256 calldataWords = (calldataSize + 31) / 32;\r\n            // account for the CALLDATACOPY cost of the proxy contract, including the memory expansion cost\r\n            startGasLeft += calldataWords * 6 + (calldataWords**2) / 512;\r\n            // if triggered in a contract call, the spender may be overrefunded by appending dummy data to the call\r\n            // so we check if it is a top level call, which would mean the sender paid calldata as part of tx.input\r\n            // solhint-disable-next-line avoid-tx-origin\r\n            if (msg.sender != tx.origin) {\r\n                // We can't be sure if this calldata came from the top level tx,\r\n                // so to be safe we tell the gas refunder there was no calldata.\r\n                calldataSize = 0;\r\n            }\r\n            gasRefunder.onGasSpent(payable(msg.sender), startGasLeft - gasleft(), calldataSize);\r\n        }\r\n    }\r\n}\r\n\r\n// File @arbitrum/nitro-contracts/src/bridge/ISequencerInbox.sol@v1.0.1\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/nitro/blob/master/LICENSE\r\n// License-Identifier: BUSL-1.1\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.6.9 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\ninterface ISequencerInbox is IDelayedMessageProvider {\r\n    struct MaxTimeVariation {\r\n        uint256 delayBlocks;\r\n        uint256 futureBlocks;\r\n        uint256 delaySeconds;\r\n        uint256 futureSeconds;\r\n    }\r\n\r\n    struct TimeBounds {\r\n        uint64 minTimestamp;\r\n        uint64 maxTimestamp;\r\n        uint64 minBlockNumber;\r\n        uint64 maxBlockNumber;\r\n    }\r\n\r\n    enum BatchDataLocation {\r\n        TxInput,\r\n        SeparateBatchEvent,\r\n        NoData\r\n    }\r\n\r\n    event SequencerBatchDelivered(\r\n        uint256 indexed batchSequenceNumber,\r\n        bytes32 indexed beforeAcc,\r\n        bytes32 indexed afterAcc,\r\n        bytes32 delayedAcc,\r\n        uint256 afterDelayedMessagesRead,\r\n        TimeBounds timeBounds,\r\n        BatchDataLocation dataLocation\r\n    );\r\n\r\n    event OwnerFunctionCalled(uint256 indexed id);\r\n\r\n    /// @dev a separate event that emits batch data when this isn't easily accessible in the tx.input\r\n    event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data);\r\n\r\n    /// @dev a valid keyset was added\r\n    event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes);\r\n\r\n    /// @dev a keyset was invalidated\r\n    event InvalidateKeyset(bytes32 indexed keysetHash);\r\n\r\n    function totalDelayedMessagesRead() external view returns (uint256);\r\n\r\n    function bridge() external view returns (IBridge);\r\n\r\n    /// @dev The size of the batch header\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function HEADER_LENGTH() external view returns (uint256);\r\n\r\n    /// @dev If the first batch data byte after the header has this bit set,\r\n    ///      the sequencer inbox has authenticated the data. Currently not used.\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DATA_AUTHENTICATED_FLAG() external view returns (bytes1);\r\n\r\n    function rollup() external view returns (IOwnable);\r\n\r\n    function isBatchPoster(address) external view returns (bool);\r\n\r\n    struct DasKeySetInfo {\r\n        bool isValidKeyset;\r\n        uint64 creationBlock;\r\n    }\r\n\r\n    // https://github.com/ethereum/solidity/issues/11826\r\n    // function maxTimeVariation() external view returns (MaxTimeVariation calldata);\r\n    // function dasKeySetInfo(bytes32) external view returns (DasKeySetInfo calldata);\r\n\r\n    /// @notice Remove force inclusion delay after a L1 chainId fork\r\n    function removeDelayAfterFork() external;\r\n\r\n    /// @notice Force messages from the delayed inbox to be included in the chain\r\n    ///         Callable by any address, but message can only be force-included after maxTimeVariation.delayBlocks and\r\n    ///         maxTimeVariation.delaySeconds has elapsed. As part of normal behaviour the sequencer will include these\r\n    ///         messages so it's only necessary to call this if the sequencer is down, or not including any delayed messages.\r\n    /// @param _totalDelayedMessagesRead The total number of messages to read up to\r\n    /// @param kind The kind of the last message to be included\r\n    /// @param l1BlockAndTime The l1 block and the l1 timestamp of the last message to be included\r\n    /// @param baseFeeL1 The l1 gas price of the last message to be included\r\n    /// @param sender The sender of the last message to be included\r\n    /// @param messageDataHash The messageDataHash of the last message to be included\r\n    function forceInclusion(\r\n        uint256 _totalDelayedMessagesRead,\r\n        uint8 kind,\r\n        uint64[2] calldata l1BlockAndTime,\r\n        uint256 baseFeeL1,\r\n        address sender,\r\n        bytes32 messageDataHash\r\n    ) external;\r\n\r\n    function inboxAccs(uint256 index) external view returns (bytes32);\r\n\r\n    function batchCount() external view returns (uint256);\r\n\r\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool);\r\n\r\n    /// @notice the creation block is intended to still be available after a keyset is deleted\r\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256);\r\n\r\n    // ---------- BatchPoster functions ----------\r\n\r\n    function addSequencerL2BatchFromOrigin(\r\n        uint256 sequenceNumber,\r\n        bytes calldata data,\r\n        uint256 afterDelayedMessagesRead,\r\n        IGasRefunder gasRefunder\r\n    ) external;\r\n\r\n    function addSequencerL2Batch(\r\n        uint256 sequenceNumber,\r\n        bytes calldata data,\r\n        uint256 afterDelayedMessagesRead,\r\n        IGasRefunder gasRefunder,\r\n        uint256 prevMessageCount,\r\n        uint256 newMessageCount\r\n    ) external;\r\n\r\n    // ---------- onlyRollupOrOwner functions ----------\r\n\r\n    /**\r\n     * @notice Set max delay for sequencer inbox\r\n     * @param maxTimeVariation_ the maximum time variation parameters\r\n     */\r\n    function setMaxTimeVariation(MaxTimeVariation memory maxTimeVariation_) external;\r\n\r\n    /**\r\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\r\n     * @param addr the address\r\n     * @param isBatchPoster_ if the specified address should be authorized as a batch poster\r\n     */\r\n    function setIsBatchPoster(address addr, bool isBatchPoster_) external;\r\n\r\n    /**\r\n     * @notice Makes Data Availability Service keyset valid\r\n     * @param keysetBytes bytes of the serialized keyset\r\n     */\r\n    function setValidKeyset(bytes calldata keysetBytes) external;\r\n\r\n    /**\r\n     * @notice Invalidates a Data Availability Service keyset\r\n     * @param ksHash hash of the keyset\r\n     */\r\n    function invalidateKeysetHash(bytes32 ksHash) external;\r\n\r\n    // ---------- initializer ----------\r\n\r\n    function initialize(IBridge bridge_, MaxTimeVariation calldata maxTimeVariation_) external;\r\n}\r\n\r\n// File @arbitrum/nitro-contracts/src/bridge/IInbox.sol@v1.0.1\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/nitro/blob/master/LICENSE\r\n// License-Identifier: BUSL-1.1\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.6.9 <0.9.0;\r\n\r\n\r\n\r\ninterface IInbox is IDelayedMessageProvider {\r\n    function bridge() external view returns (IBridge);\r\n\r\n    function sequencerInbox() external view returns (ISequencerInbox);\r\n\r\n    /**\r\n     * @notice Send a generic L2 message to the chain\r\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\r\n     *      This method will be disabled upon L1 fork to prevent replay attacks on L2\r\n     * @param messageData Data of the message being sent\r\n     */\r\n    function sendL2MessageFromOrigin(bytes calldata messageData) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Send a generic L2 message to the chain\r\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\r\n     *      This method will be disabled upon L1 fork to prevent replay attacks on L2\r\n     * @param messageData Data of the message being sent\r\n     */\r\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\r\n\r\n    function sendL1FundedUnsignedTransaction(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        uint256 nonce,\r\n        address to,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    function sendL1FundedContractTransaction(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        address to,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    function sendUnsignedTransaction(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        uint256 nonce,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (uint256);\r\n\r\n    function sendContractTransaction(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev This method can only be called upon L1 fork and will not alias the caller\r\n     *      This method will revert if not called from origin\r\n     */\r\n    function sendL1FundedUnsignedTransactionToFork(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        uint256 nonce,\r\n        address to,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    /**\r\n     * @dev This method can only be called upon L1 fork and will not alias the caller\r\n     *      This method will revert if not called from origin\r\n     */\r\n    function sendUnsignedTransactionToFork(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        uint256 nonce,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Send a message to initiate L2 withdrawal\r\n     * @dev This method can only be called upon L1 fork and will not alias the caller\r\n     *      This method will revert if not called from origin\r\n     */\r\n    function sendWithdrawEthToFork(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        uint256 nonce,\r\n        uint256 value,\r\n        address withdrawTo\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Get the L1 fee for submitting a retryable\r\n     * @dev This fee can be paid by funds already in the L2 aliased address or by the current message value\r\n     * @dev This formula may change in the future, to future proof your code query this method instead of inlining!!\r\n     * @param dataLength The length of the retryable's calldata, in bytes\r\n     * @param baseFee The block basefee when the retryable is included in the chain, if 0 current block.basefee will be used\r\n     */\r\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Deposit eth from L1 to L2 to address of the sender if sender is an EOA, and to its aliased address if the sender is a contract\r\n     * @dev This does not trigger the fallback function when receiving in the L2 side.\r\n     *      Look into retryable tickets if you are interested in this functionality.\r\n     * @dev This function should not be called inside contract constructors\r\n     */\r\n    function depositEth() external payable returns (uint256);\r\n\r\n    /**\r\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\r\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\r\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\r\n     * @param to destination L2 contract address\r\n     * @param l2CallValue call value for retryable L2 message\r\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\r\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\r\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\r\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\r\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\r\n     * @param data ABI encoded data of L2 message\r\n     * @return unique message number of the retryable transaction\r\n     */\r\n    function createRetryableTicket(\r\n        address to,\r\n        uint256 l2CallValue,\r\n        uint256 maxSubmissionCost,\r\n        address excessFeeRefundAddress,\r\n        address callValueRefundAddress,\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    /**\r\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\r\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed funds\r\n     * come from the deposit alone, rather than falling back on the user's L2 balance\r\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\r\n     * createRetryableTicket method is the recommended standard.\r\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\r\n     * @param to destination L2 contract address\r\n     * @param l2CallValue call value for retryable L2 message\r\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\r\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\r\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\r\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\r\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\r\n     * @param data ABI encoded data of L2 message\r\n     * @return unique message number of the retryable transaction\r\n     */\r\n    function unsafeCreateRetryableTicket(\r\n        address to,\r\n        uint256 l2CallValue,\r\n        uint256 maxSubmissionCost,\r\n        address excessFeeRefundAddress,\r\n        address callValueRefundAddress,\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    // ---------- onlyRollupOrOwner functions ----------\r\n\r\n    /// @notice pauses all inbox functionality\r\n    function pause() external;\r\n\r\n    /// @notice unpauses all inbox functionality\r\n    function unpause() external;\r\n\r\n    // ---------- initializer ----------\r\n\r\n    /**\r\n     * @dev function to be called one time during the inbox upgrade process\r\n     *      this is used to fix the storage slots\r\n     */\r\n    function postUpgradeInit(IBridge _bridge) external;\r\n\r\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox) external;\r\n}\r\n\r\n// File contracts/ln/messager/Eth2ArbSendService.sol\r\n// License-Identifier: MIT\r\n\r\n\r\n\r\n// from ethereum to arbitrum messager\r\ncontract Eth2ArbSendService is ILowLevelMessageSender, LnAccessController {\r\n    uint256 immutable public REMOTE_CHAINID;\r\n    IInbox public inbox;\r\n    address public remoteMessager;\r\n    mapping(address=>address) public appPairs;\r\n\r\n    constructor(address _dao, address _inbox, uint256 _remoteChainId) {\r\n        _initialize(_dao);\r\n        inbox = IInbox(_inbox);\r\n        REMOTE_CHAINID = _remoteChainId;\r\n    }\r\n\r\n    function setRemoteMessager(address _remoteMessager) onlyDao external {\r\n        remoteMessager = _remoteMessager;\r\n    }\r\n\r\n    function registerRemoteReceiver(uint256 _remoteChainId, address _remoteBridge) onlyWhiteListCaller external {\r\n        require(_remoteChainId == REMOTE_CHAINID, \"invalid remote chainId\");\r\n        appPairs[msg.sender] = _remoteBridge;\r\n    }\r\n\r\n    function sendMessage(uint256 _remoteChainId, bytes memory _message, bytes memory _params) onlyWhiteListCaller external payable {\r\n        require(_remoteChainId == REMOTE_CHAINID, \"invalid remote chainId\");\r\n        address remoteAppAddress = appPairs[msg.sender];\r\n        require(remoteAppAddress != address(0), \"app not registered\");\r\n\r\n        (uint256 maxSubmissionCost, uint256 l2GasPrice, uint256 l2GasLimit, address refunder) = abi.decode(_params, (uint256, uint256, uint256, address));\r\n\r\n        bytes memory remoteReceiveCall = abi.encodeWithSelector(\r\n            ILowLevelMessageReceiver.recvMessage.selector,\r\n            msg.sender,\r\n            remoteAppAddress,\r\n            _message\r\n        );\r\n        inbox.createRetryableTicket{value: msg.value}(\r\n            remoteMessager,\r\n            0,\r\n            maxSubmissionCost,\r\n            refunder,\r\n            refunder,\r\n            l2GasLimit,\r\n            l2GasPrice,\r\n            remoteReceiveCall\r\n        );\r\n    }\r\n\r\n    function fee(\r\n        uint256 _callSize,\r\n        uint256 _l1GasPrice,\r\n        uint256 _l2GasPrice,\r\n        uint256 _l2GasLimit,\r\n        uint256 _percentIncrease\r\n    ) external view returns(uint256, uint256) {\r\n        uint256 submissionFee = inbox.calculateRetryableSubmissionFee(_callSize, _l1GasPrice);\r\n        uint256 scaleSubmissionFee = submissionFee + submissionFee * _percentIncrease / 100;\r\n        return (scaleSubmissionFee, scaleSubmissionFee + _l2GasPrice * _l2GasLimit);\r\n    }\r\n\r\n    function encodeParams(\r\n        uint256 _maxSubmissionCost,\r\n        uint256 _l2GasPrice,\r\n        uint256 _l2GasLimit,\r\n        address _refunder\r\n    ) external pure returns(bytes memory) {\r\n        return abi.encode(_maxSubmissionCost, _l2GasPrice, _l2GasLimit, _refunder);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dao\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_inbox\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_remoteChainId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"REMOTE_CHAINID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"appPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"appAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"authoriseAppCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"callerWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dao\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2GasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2GasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_refunder\",\"type\":\"address\"}],\"name\":\"encodeParams\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_callSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l1GasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2GasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2GasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentIncrease\",\"type\":\"uint256\"}],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inbox\",\"outputs\":[{\"internalType\":\"contract IInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_remoteChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_remoteBridge\",\"type\":\"address\"}],\"name\":\"registerRemoteReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remoteMessager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_remoteChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_remoteMessager\",\"type\":\"address\"}],\"name\":\"setRemoteMessager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dao\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Eth2ArbSendService", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000088a39b052d477cfde47600a7c9950a441ce61cb40000000000000000000000004dbd4fc535ac27206064b68ffcf827b0a60bab3f000000000000000000000000000000000000000000000000000000000000a4b1", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c464af2d60ffc8584555ae34f652c4e524452f5355d61bc89de0bbb12089522d"}