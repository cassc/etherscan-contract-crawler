{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/VRFV2WrapperInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFV2WrapperInterface {\\n  /**\\n   * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only\\n   * be relied option within the same transaction that the request was made.\\n   */\\n  function lastRequestId() external view returns (uint256);\\n\\n  /**\\n   * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current\\n   * @notice block.\\n   *\\n   * @dev This function relies on the transaction gas price which is not automatically set during\\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\\n   *\\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\\n   */\\n  function calculateRequestPrice(uint32 _callbackGasLimit) external view returns (uint256);\\n\\n  /**\\n   * @notice Estimates the price of a VRF request with a specific gas limit and gas price.\\n   *\\n   * @dev This is a convenience function that can be called in simulation to better understand\\n   * @dev pricing.\\n   *\\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\\n   */\\n  function estimateRequestPrice(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./interfaces/VRFV2WrapperInterface.sol\\\";\\n\\n/** *******************************************************************************\\n * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper\\n * ********************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Create VRF V2 requests without the need for subscription management. Rather than creating\\n * @dev and funding a VRF V2 subscription, a user can use this wrapper to create one off requests,\\n * @dev paying up front rather than at fulfillment.\\n *\\n * @dev Since the price is determined using the gas price of the request transaction rather than\\n * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas\\n * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFV2WrapperConsumerBase. The consumer must be funded\\n * @dev with enough LINK to make the request, otherwise requests will revert. To request randomness,\\n * @dev call the 'requestRandomness' function with the desired VRF parameters. This function handles\\n * @dev paying for the request based on the current pricing.\\n *\\n * @dev Consumers must implement the fullfillRandomWords function, which will be called during\\n * @dev fulfillment with the randomness result.\\n */\\nabstract contract VRFV2WrapperConsumerBase {\\n  LinkTokenInterface internal immutable LINK;\\n  VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;\\n\\n  /**\\n   * @param _link is the address of LinkToken\\n   * @param _vrfV2Wrapper is the address of the VRFV2Wrapper contract\\n   */\\n  constructor(address _link, address _vrfV2Wrapper) {\\n    LINK = LinkTokenInterface(_link);\\n    VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);\\n  }\\n\\n  /**\\n   * @dev Requests randomness from the VRF V2 wrapper.\\n   *\\n   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's\\n   *        fulfillRandomWords function.\\n   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\\n   *        request. A higher number of confirmations increases security by reducing the likelihood\\n   *        that a chain re-org changes a published randomness outcome.\\n   * @param _numWords is the number of random words to request.\\n   *\\n   * @return requestId is the VRF V2 request ID of the newly created randomness request.\\n   */\\n  function requestRandomness(\\n    uint32 _callbackGasLimit,\\n    uint16 _requestConfirmations,\\n    uint32 _numWords\\n  ) internal returns (uint256 requestId) {\\n    LINK.transferAndCall(\\n      address(VRF_V2_WRAPPER),\\n      VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),\\n      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)\\n    );\\n    return VRF_V2_WRAPPER.lastRequestId();\\n  }\\n\\n  /**\\n   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\\n   * @notice implement it.\\n   *\\n   * @param _requestId is the VRF V2 request ID.\\n   * @param _randomWords is the randomness result.\\n   */\\n  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;\\n\\n  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\\n    require(msg.sender == address(VRF_V2_WRAPPER), \\\"only VRF V2 wrapper can fulfill\\\");\\n    fulfillRandomWords(_requestId, _randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Auction.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/**\\n * @title Auction\\n * @author @brougkr\\n * @notice A Smart Contract To Facilitate Ascending Auctions (With Ascending Reserve Floor) For Multiple NFTs (Or Whatever Else You Want To Sell) \\n */\\npragma solidity 0.8.19;\\nimport { DelegateCashEnabled } from \\\"./DelegateCashEnabled.sol\\\";\\nimport { ReentrancyGuard } from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\ncontract Auction is DelegateCashEnabled, ReentrancyGuard, Ownable\\n{\\n    struct Bid\\n    {\\n        uint ETHValue;  // [0] -> ETH Value Of Bid\\n        uint Timestamp; // [1] -> Unix Timestamp Of Bid Confirmation\\n        address Bidder; // [2] -> Wallet Address Of Bidder\\n        address Vault;  // [3] -> Wallet Address Of Vault (optional `delegate.cash` support)\\n        bool Refunded;   // [4] -> If Bidder Refunded ETH From Bid\\n        bool Winner;    // [5] -> If Bidder Is A Winner Of The Auction\\n    }\\n\\n    struct Params\\n    {\\n        bool Active;           // [0] -> Is The Auction Active \\n        bool ManualSwitch;     // [1] -> Override For Lowest Valid Bid (For Manual Switching)\\n        uint UnixStartTime;    // [2] -> Unix Start Time Of Auction\\n        uint UnixEndTime;      // [3] -> Unix End Time Of Auction\\n        uint LowestValidBid;   // [4] -> Reserve Price Of Auction (minimum bid)\\n        uint GlobalUniqueBids; // [5] -> Total Global Unique Bids In The Auction\\n        uint MinBIPSIncrease;  // [6] -> Minimum BIPS (%) Increase On Each Subsequent Bid After 50 Unique Bids \\n    }\\n\\n    /*-----------------------------\\n     * STATE VARIABLES & MAPPINGS *\\n    ------------------------------*/\\n\\n    Params public AuctionParams;\\n    mapping(uint=>Bid) public Bids;\\n    mapping(address=>uint[]) public UserBidIndexes;\\n    address private constant _BRT_MULTISIG = 0x0BC56e3c1397e4570069e89C07936A5c6020e3BE;\\n\\n    /*---------\\n     * EVENTS *\\n    ----------*/\\n\\n    event NewBidComplete(uint MessageValue, uint Unixtimestamp, address Bidder, address Vault);\\n    event BidToppedUp(uint MessageValue, uint Unixtimestamp, address Bidder, uint[] BidIndexes);\\n    event BidReclaimFailed(uint BidIndex);\\n\\n    /*--------------\\n     * CONSTRUCTOR *\\n    ---------------*/\\n\\n    constructor() \\n    { \\n        AuctionParams.MinBIPSIncrease = 105; // 5% Increase On Each Subsequent Bid After 50 Unique Bids\\n        AuctionParams.UnixEndTime = block.timestamp + 10080 minutes; // ends auction 1 week after starting\\n        AuctionParams.LowestValidBid = 0.1 ether; // starts auction at 0.1 ETH\\n        AuctionParams.Active = true; // activates auction\\n    }\\n\\n    /*-----------------\\n     * USER FUNCTIONS *\\n    ------------------*/\\n\\n    /**\\n     * @dev Submits A New Bid To The Auction\\n     */\\n    function NewBid(address Vault) external payable nonReentrant\\n    {\\n        require(tx.origin == msg.sender, \\\"Auction: EOA Only, Use `delegate.cash` For Wallet Delegation\\\"); // Requires `msg.sender` Is A Valid EOA\\n        require(AuctionParams.Active, \\\"Auction: Auction Is Paused\\\"); // Requires The Auction Is Active\\n        require(block.timestamp >= AuctionParams.UnixStartTime, \\\"Auction: Auction Has Not Started\\\"); // Requires The Auction Has Started\\n        require(block.timestamp < AuctionParams.UnixEndTime, \\\"Auction: Auction Has Concluded\\\"); // Requires The Auction Has Not Ended\\n        if(Vault != address(0)) { if(!DelegateCash.checkDelegateForAll(msg.sender, Vault)) { Vault = address(0); } } // `delegate.cash` Integration\\n        uint NewMinimumBid; // Declares New Minimum Bid Variable\\n        if(AuctionParams.ManualSwitch) { NewMinimumBid = AuctionParams.LowestValidBid; } // If Manual Switch Is Active, Use The Manual Lowest Valid\\n        else { NewMinimumBid = _ViewMinimumValidBidV2(); } // Auto-Calculates The Required Reserve Price For The Bid (+5%)\\n        require(msg.value >= NewMinimumBid, \\\"Auction: Bid Amount Must Be >= 1.05% * Current Floor Reserve Price\\\"); // Requires Min Bid\\n        AuctionParams.LowestValidBid = NewMinimumBid; // Updates Reserve Price\\n        if((AuctionParams.UnixEndTime - block.timestamp) < 5 minutes) { AuctionParams.UnixEndTime = block.timestamp + 5 minutes; } // Extend Auction 5 Minutes\\n        Bids[AuctionParams.GlobalUniqueBids] = Bid(msg.value, block.timestamp, msg.sender, Vault, false, false); // Registers New Bid\\n        UserBidIndexes[msg.sender].push(AuctionParams.GlobalUniqueBids); // Appends Bid Index To User's Bid Indexes\\n        AuctionParams.GlobalUniqueBids = AuctionParams.GlobalUniqueBids + 1; // Increments Global Unique Bids\\n        emit NewBidComplete(msg.value, block.timestamp, msg.sender, Vault); // Emits Bid Event\\n    }\\n\\n    /**\\n     * @dev Tops Up Bid(s) With Additional ETH\\n     */\\n    function IncreaseBid(uint[] calldata BidIndexes, uint[] calldata Amounts) external payable nonReentrant\\n    {\\n        require(tx.origin == msg.sender, \\\"Auction: EOA Only, Use `delegate.cash` For Wallet Delegation\\\"); // Requires `msg.sender` Is A Valid EOA\\n        require(AuctionParams.Active, \\\"Auction: Auction Is Paused\\\"); // Requires The Auction Is Active\\n        require(BidIndexes.length == Amounts.length, \\\"Auction: BidIndexes And Amounts Array Length Mismatch\\\"); // Requires BidIndexes And Amounts Length Match\\n        require(block.timestamp >= AuctionParams.UnixStartTime, \\\"Auction: Auction Has Not Started\\\"); // Requires The Auction Has Started\\n        require(block.timestamp < AuctionParams.UnixEndTime, \\\"Auction: Auction Has Concluded\\\"); // Requires The Auction Has Not Ended\\n        require(BidIndexes.length > 0, \\\"Auction: User Has No Bids To Top Up\\\"); // Requires User Has Bids To Top Up\\n        uint NewMinimumBid; // Declares New Minimum Bid Variable\\n        if(AuctionParams.ManualSwitch) { NewMinimumBid = AuctionParams.LowestValidBid; } // If Manual Switch Is Active, Use The Lowest Valid Bid\\n        else { NewMinimumBid = _ViewMinimumValidBidV2(); } // Auto-Calculates The Required Reserve Price For The Bid (+5%)\\n        uint Delta = NewMinimumBid - AuctionParams.LowestValidBid; \\n        uint Total;\\n        for(uint x; x < BidIndexes.length; x++)\\n        { \\n            Total += Amounts[x];\\n            require(msg.sender == Bids[BidIndexes[x]].Bidder, \\\"Auction: `msg.sender` Is Not The Bidder Of Provided Bid Index\\\");\\n            require(Bids[BidIndexes[x]].ETHValue + Amounts[x] >= NewMinimumBid, \\\"Auction: Bid Amount Must Be At Least 5% More Than The Current Floor Price\\\");\\n            require(Amounts[x] >= Delta, \\\"Auction: Top Up ETH Value Must Be >= MinimumBid - Lowest Valid Bid\\\");\\n            Bids[BidIndexes[x]].ETHValue += Amounts[x];\\n            Bids[BidIndexes[x]].Timestamp = block.timestamp;\\n        }\\n        require(msg.value == Total, \\\"Auction: Must Send Exact ETH Value To Top Up Bids\\\");\\n        if((AuctionParams.UnixEndTime - block.timestamp) < 5 minutes) { AuctionParams.UnixEndTime = block.timestamp + 5 minutes; } // Extend Auction 5 Min\\n        emit BidToppedUp(msg.value, block.timestamp, msg.sender, BidIndexes);\\n    }\\n\\n    /**\\n     * @dev Returns All ETH Bids Sent By `User` If Auction Has Not Ended & `User` Has Bids Before 1hr Auction End Time\\n     */\\n    function ReclaimETH() external nonReentrant\\n    {\\n        require(tx.origin == msg.sender, \\\"Auction: EOA Only, Use `delegate.cash` For Wallet Delegation\\\"); // Requires `msg.sender` Is A Valid EOA\\n        require(block.timestamp < AuctionParams.UnixEndTime, \\\"Auction: Auction Has Concluded\\\"); // Requires The Auction Has Not Ended\\n        require(AuctionParams.Active, \\\"Auction: Auction Is Paused\\\"); // Requires The Auction Is Active\\n        uint[] memory BidIndexes = UserBidIndexes[msg.sender];\\n        require(BidIndexes.length > 0, \\\"Auction: User Has No Bids To Reclaim\\\");\\n        for(uint x; x < UserBidIndexes[msg.sender].length; x++) \\n        { \\n            if(!Bids[BidIndexes[x]].Refunded && !Bids[BidIndexes[x]].Winner) // Ensures Bid Has Not Been Refunded And Is A Valid Bid\\n            {\\n                if(Bids[BidIndexes[x]].ETHValue < AuctionParams.LowestValidBid) // Ensures Bid Is Not A Currently Valid Bid\\n                {\\n                    Bids[BidIndexes[x]].Refunded = true;\\n                    (bool Success, ) = Bids[BidIndexes[x]].Bidder.call { value: Bids[BidIndexes[x]].ETHValue }(\\\"\\\");\\n                    if(!Success) { emit BidReclaimFailed(BidIndexes[x]); }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*----------------------\\n     * ONLYOWNER FUNCTIONS *\\n    -----------------------*/\\n\\n    /**\\n     * @dev Seeds The Floor ETH Value For New Bids & Bid Topups\\n     */\\n    function ___SeedFloorReserve(uint WEIValue) external onlyOwner { AuctionParams.LowestValidBid = WEIValue; }\\n\\n    /**\\n     * @dev Flips The Manual Auction LowestValidBid Boolean Value\\n     */\\n    function ___FlipManualSwitch() external onlyOwner { AuctionParams.ManualSwitch = !AuctionParams.ManualSwitch; }\\n\\n    /**\\n     * @dev Sets Winners\\n     */\\n    function ___SetWinners(uint[] calldata Indexes) external onlyOwner\\n    {\\n        for(uint x; x < Indexes.length; x++)\\n        {\\n            require(!Bids[Indexes[x]].Winner, \\\"Auction: Bid Is Already A Winner\\\");\\n            require(!Bids[Indexes[x]].Refunded, \\\"Auction: Bid Is Already Refunded\\\");\\n            Bids[Indexes[x]].Winner = true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Refunds All Unclaimed Bids & Sends Remaining ETH To Multisig\\n     */\\n    function ___InitiateRefundsAndProceeds() external onlyOwner \\n    { \\n        for(uint x; x < AuctionParams.GlobalUniqueBids; x++)\\n        {\\n            if(!Bids[x].Refunded && !Bids[x].Winner) // If Bid Is Not Refunded & Is Not A Winning Bid, Refund ETH\\n            {\\n                Bids[x].Refunded = true;\\n                (bool Refund, ) = Bids[x].Bidder.call { value: Bids[x].ETHValue }(\\\"\\\");\\n                if(!Refund) { emit BidReclaimFailed(x); }\\n            }\\n        }\\n        (bool MultisigWithdraw, ) = _BRT_MULTISIG.call{ value: address(this).balance }(\\\"\\\");\\n        require(MultisigWithdraw, \\\"Auction: Failed To Send ETH To Multisig, Use Failsafe Withdraw\\\");\\n    }\\n\\n    /**\\n     * @dev Flips The Auction Pause State\\n     */\\n    function ___FlipAuctionState() external onlyOwner { AuctionParams.Active = !AuctionParams.Active; }\\n\\n    /**\\n     * @dev Withdraws All Ether From The Contract\\n     */\\n    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\\n\\n    /**\\n     * @dev Withdraws Ether From Contract To Address With An Amount\\n     */\\n    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\\n    {\\n        require(Amount > 0 && Amount <= address(this).balance, \\\"Invalid Amount\\\");\\n        (bool Success, ) = Recipient.call{value: Amount}(\\\"\\\");\\n        require(Success, \\\"Unable to Withdraw, Recipient May Have Reverted\\\");\\n    }\\n\\n    /*--------------------------\\n     * EXTERNAL VIEW FUNCTIONS *\\n    ---------------------------*/\\n\\n    /**\\n     * @dev Returns WEI Value Of Refunds & Proceeds\\n     */\\n    function ViewRefundsAndProceeds() external view returns (uint, uint)\\n    {\\n        uint Refunds;\\n        uint Proceeds;\\n        for(uint x; x < AuctionParams.GlobalUniqueBids; x++) \\n        { \\n            if(!Bids[x].Refunded && !Bids[x].Winner) { Refunds += Bids[x].ETHValue; } \\n            else if (Bids[x].Winner) { Proceeds += Bids[x].ETHValue; }\\n        }\\n        return (Refunds, Proceeds);\\n    }\\n\\n    /**\\n     * @dev View Function For Frontend\\n     */\\n    function ViewFrontend() external view returns (Params memory, uint[] memory)\\n    {\\n        uint[] memory _Leaderboard = new uint[](AuctionParams.GlobalUniqueBids);\\n        for(uint x; x < AuctionParams.GlobalUniqueBids; x++) { _Leaderboard[x] = Bids[x].ETHValue; }\\n        return (AuctionParams, _InsertionSort(_Leaderboard));\\n    }\\n\\n    /**\\n     * @dev Returns The Sorted Bid Leaderboard With Original Bid Indexes As A 2D-Array\\n     */\\n    function ViewLeaderboardWithIndexes() external view returns (uint[][] memory) { return _InsertionSortBidIndexes(); }\\n\\n    /**\\n     * @dev Returns Auction Parameters\\n     */\\n    function ViewAuctionParams() external view returns (Params memory) { return AuctionParams; }\\n\\n    /**\\n     * @dev Returns Ascending Order Of Highest Unique ETH Bids \\n     * note: you should sort off-chain to calculate leaderboard as best practice\\n     * note: if you have a more elegant implementation hmu\\n     */\\n    function ViewLeaderboard() external view returns (uint[] memory)\\n    {\\n        uint[] memory _Leaderboard = new uint[](AuctionParams.GlobalUniqueBids);\\n        for(uint x; x < AuctionParams.GlobalUniqueBids; x++) { _Leaderboard[x] = Bids[x].ETHValue; }\\n        return _InsertionSort(_Leaderboard);\\n    }\\n\\n    /**\\n     * @dev Returns A Individual 'Bid' Struct Corresponding To Input Index\\n     */\\n    function ViewBid(uint Index) external view returns (Bid memory) { return Bids[Index]; }\\n\\n    /**\\n     * @dev Returns A 'Bid' Struct Array Corresponding To Input Indexes\\n     */\\n    function ViewBids(uint[] calldata Indexes) external view returns(Bid[] memory) \\n    {\\n        Bid[] memory _Bids = new Bid[](Indexes.length);\\n        for(uint x; x < Indexes.length; x++) { _Bids[x] = Bids[Indexes[x]]; }\\n        return _Bids;\\n    }\\n\\n    /**\\n     * @dev Returns A 'Bid' Struct Array Of All Unique Bids In The Auction\\n     * note: this will throw `out of gas` after 1648~ unique bids because block gas limit is 30M, use `ViewBids()` with indexes after 1648~ unique bids\\n     */\\n    function ViewAllUniqueBids() external view returns(Bid[] memory)\\n    {\\n        uint GlobalUniqueBids = AuctionParams.GlobalUniqueBids;\\n        Bid[] memory _Bids = new Bid[](GlobalUniqueBids);\\n        for(uint x; x < GlobalUniqueBids; x++) { _Bids[x] = Bids[x]; }\\n        return _Bids;\\n    }\\n\\n    /**\\n     * @dev Returns A `Bid` Struct Array Of All Unique Bids In The Auction Submitted By `Wallet`\\n     */\\n    function ViewWalletBids(address Wallet) external view returns(Bid[] memory)\\n    {\\n        uint[] memory _Indexes = UserBidIndexes[Wallet];\\n        Bid[] memory _Bids = new Bid[](_Indexes.length);\\n        for(uint x; x < _Indexes.length; x++) { _Bids[x] = Bids[_Indexes[x]]; }\\n        return _Bids;\\n    }\\n\\n    /**\\n     * @dev Returns An Array Of `Wallet` Submitted Bid Indexes\\n     */\\n    function ViewUserBidIndexes(address Wallet) external view returns(uint[] memory) { return UserBidIndexes[Wallet]; }\\n\\n    /**\\n     * @dev Returns Minimum Valid Bid For The Auction (less gas efficient)\\n     */\\n    function ViewMinimumValidBidV1() external view returns (uint) { return _ViewMinimumValidBidV1(); }\\n\\n    /**\\n     * @dev Returns Minimum Valid Bid For The Auction (more gas efficient)\\n     */\\n    function ViewMinimumValidBidV2() external view returns (uint) { return _ViewMinimumValidBidV2(); }\\n    \\n    /**\\n     * @dev Returns Minimum Valid Bid For The Auction\\n     */\\n    function ViewMinimumValidBidV3() external view returns (uint) { return _ViewMinimumValidBidV3(); }\\n\\n    /*--------------------------\\n     * INTERNAL VIEW FUNCTIONS *\\n    ---------------------------*/\\n\\n    /**\\n     * @dev Returns The Minimum Valid Bid That Can Be Submitted To The Auction After 50 Bids Have Been Reached (50th Lowest Bid * 1.05)\\n     * note: uses the complex 2d insertion sort algorithm to sort the bids and their indexes\\n     */\\n    function _ViewMinimumValidBidV1() internal view returns (uint)\\n    {\\n        if(AuctionParams.GlobalUniqueBids < 50) { return ((AuctionParams.LowestValidBid * AuctionParams.MinBIPSIncrease) / 100); }\\n        else\\n        {\\n            uint[][] memory BidsAndIndexes = _InsertionSortBidIndexes();\\n            uint IndexOfMinimumBid = AuctionParams.GlobalUniqueBids - 50; // Index Of 50th Largest Bid\\n            uint LowestValidBid = BidsAndIndexes[IndexOfMinimumBid][0];\\n            return ((LowestValidBid * AuctionParams.MinBIPSIncrease) / 100);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns The Minimum Valid Bid That Can Be Submitted To The Auction After 50 Bids Have Been Reached (50th Lowest Bid * 1.05)\\n     * note: uses the basic insertion sort algorithm to sort only the eth bid values, this is more gas efficient than sorting the entire struct array of bids\\n     */\\n    function _ViewMinimumValidBidV2() internal view returns (uint)\\n    {\\n        if(AuctionParams.GlobalUniqueBids < 50) { return ((AuctionParams.LowestValidBid * AuctionParams.MinBIPSIncrease) / 100); }\\n        else\\n        {\\n            uint[] memory _Leaderboard = new uint[](AuctionParams.GlobalUniqueBids);\\n            uint IndexOfMinimumBid = AuctionParams.GlobalUniqueBids - 50; // Index Of 50th Largest Bid\\n            for(uint x; x < AuctionParams.GlobalUniqueBids; x++) { _Leaderboard[x] = Bids[x].ETHValue; }\\n            return ((_InsertionSort(_Leaderboard)[IndexOfMinimumBid] * AuctionParams.MinBIPSIncrease) / 100);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns The Minimum Valid Bid That Has Been Submitted To The Auction Or ((LVB * BIPS) / 100) If < Than 50 Unique Bids\\n     */\\n    function _ViewMinimumValidBidV3() internal view returns (uint MinimumBid)\\n    {\\n        if(AuctionParams.GlobalUniqueBids > 50)\\n        {       \\n            uint NewMin = AuctionParams.LowestValidBid; \\n            uint Curr = 10000 ether;\\n            for(uint x; x < AuctionParams.GlobalUniqueBids; x++) \\n            { \\n                if(Bids[x].ETHValue <= NewMin && !Bids[x].Refunded && !Bids[x].Winner && Bids[x].ETHValue < Curr) { Curr = Bids[x].ETHValue; }\\n            }\\n            return ((Curr * AuctionParams.MinBIPSIncrease) / 100);\\n        }\\n        else { return (AuctionParams.LowestValidBid * AuctionParams.MinBIPSIncrease) / 100; }\\n    }\\n\\n    /**\\n     * @dev Returns A Sorted List Of Integers\\n     * note: you should (in general) not sort large things in solidity (as of 0.8~) because it is very gas inefficient, this is just for demonstration purposes\\n     */\\n    function _InsertionSort(uint[] memory Array) internal pure returns (uint[] memory)\\n    {\\n        for(uint x; x < Array.length; x++)\\n         {\\n            uint key = Array[x];\\n            uint y = x;\\n            while(y > 0 && Array[y-1] > key) \\n            {\\n                Array[y] = Array[y-1];\\n                y--;\\n            }\\n            Array[y] = key;\\n        }\\n        return Array;\\n    }\\n\\n    /**\\n     * @dev Returns A Sorted List Of ETH Bids @ '[n][0]' And The Indexes Of The Original Bids @ '[n][1]'\\n     * note: insertion sort O(n^2) seemed like best approach because english auction bids increase as auction progresses, otherwise quicksort prob better O(nlogn)\\n     * note: because block gas limit is 30M, this will `out-of-gas` dependant on how much sorting needs done if you have a more eloquent way of doing this hmu\\n     * note: you should (in general) not sort large things in solidity (as of 0.8~) because it is very gas inefficient, this is just for demonstration purposes\\n     */\\n    function _InsertionSortBidIndexes() internal view returns (uint[][] memory)\\n    {\\n        uint[][] memory BidsAndIndexes = new uint[][](AuctionParams.GlobalUniqueBids);\\n        for(uint x; x < BidsAndIndexes.length; x++) \\n        {\\n            BidsAndIndexes[x] = new uint[](2);       // Init Sub-Array\\n            BidsAndIndexes[x][0] = Bids[x].ETHValue; // Assign [x][0] -> ETHValue\\n            BidsAndIndexes[x][1] = x;                // Assign [x][1] -> Original Index\\n        }\\n        for(uint i; i < BidsAndIndexes.length; i++)\\n        {\\n            uint ETHValue = BidsAndIndexes[i][0];   // Preserve ETHValue\\n            uint OGBidIndex = BidsAndIndexes[i][1]; // Preserve OGBidIndex\\n            uint j = i;\\n            while(j > 0 && BidsAndIndexes[j-1][0] > ETHValue)\\n            {\\n                BidsAndIndexes[j][0] = BidsAndIndexes[j-1][0]; // Move Larger Element To The Right\\n                BidsAndIndexes[j][1] = BidsAndIndexes[j-1][1]; // Move OG Index\\n                j--;\\n            }\\n            BidsAndIndexes[j][0] = ETHValue;   // Insert ETHValue In Correct Location\\n            BidsAndIndexes[j][1] = OGBidIndex; // Insert OGBidIndex In Correct Location\\n        }\\n        return BidsAndIndexes;\\n    }\\n}\"\r\n    },\r\n    \"contracts/BatchReader.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/**\\n * @dev: @brougkr\\n */\\npragma solidity 0.8.19;\\ncontract BatchReader\\n{\\n    struct CityInfo\\n    {\\n        string Name;\\n        address NFT;\\n        uint StartingIndex;\\n    }\\n    mapping(uint=>CityInfo) public CityInformation;\\n    constructor()\\n    {\\n        CityInformation[0] = CityInfo('CryptoGalacticans', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 0);\\n        CityInformation[1] = CityInfo('CryptoVenetians', 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, 95000000);\\n        CityInformation[2] = CityInfo('CryptoNewYorkers', 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, 189000000);\\n        CityInformation[3] = CityInfo('CryptoBerliners', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 3000000);\\n        CityInformation[4] = CityInfo('CryptoLondoners', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 4000000);\\n        CityInformation[5] = CityInfo('CryptoMexas', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 5000000);\\n        CityInformation[6] = CityInfo('CryptoTokyites', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 6000000);\\n        CityInformation[7] = CityInfo('City #8', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 7000000);\\n        CityInformation[8] = CityInfo('City #9', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 8000000);\\n        CityInformation[9] = CityInfo('City #10', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 9000000);\\n    }\\n\\n    /**\\n     * @dev Returns An Array Of A Specific CryptoCitizen City Owners\\n     */\\n    function ReadCitizenCityOwners(uint CityIndex) external view returns (address[] memory)\\n    {\\n        address NFTAddress = CityInformation[CityIndex].NFT;\\n        uint Counter;\\n        IERC721 _NFT = IERC721(NFTAddress);\\n        address[] memory Owners = new address[](1000);\\n        uint Start = CityInformation[CityIndex].StartingIndex;\\n        uint Range = Start + 1000;\\n        for(Start; Start < Range; Start++)\\n        {\\n            try _NFT.ownerOf(Start) returns (address Owner) \\n            { \\n                Owners[Counter] = Owner; \\n                Counter++;\\n            }\\n            catch \\n            { \\n                Counter++;\\n                continue; \\n            }\\n        }\\n        return Owners;\\n    }\\n}\\n\\ninterface IERC721 { function ownerOf(uint TokenID) external view returns (address); }\"\r\n    },\r\n    \"contracts/BatchReaderNew.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/**\\n * @dev: @brougkr\\n */\\npragma solidity 0.8.19;\\ncontract BatchReaderNew \\n{\\n    /**\\n     * @dev Returns A Wallet's Owned NFTs (If ArtBlocks, Then ProjectIDs Are Required, Else Input 0 For ProjectIDs & It Will Start @ TokenID 0)\\n     */\\n    function readNFTsOwnedTokenIDs (\\n        address Wallet,\\n        address[] calldata NFTs,\\n        uint[] calldata ProjectIDs, // If ArtBlocks\\n        uint Range\\n    ) public view returns(uint[][] memory) {\\n        uint[][] memory OwnedIDs = new uint[][](ProjectIDs.length);\\n        for(uint x; x < ProjectIDs.length; x++)\\n        {\\n            IERC721 NFT = IERC721(NFTs[x]);\\n            uint[] memory temp = new uint[](Range);\\n            uint _TokenID = ProjectIDs[x] * 1000000;\\n            uint _Range = _TokenID + Range;\\n            uint NumOwnedTokens;\\n            for(_TokenID; _TokenID < _Range; _TokenID++)\\n            {\\n                try NFT.ownerOf(_TokenID) returns (address _Owner)\\n                {\\n                    if(_Owner == Wallet)\\n                    {\\n                        temp[NumOwnedTokens] = _TokenID;\\n                        NumOwnedTokens++;\\n                    }\\n                } catch { }\\n            }\\n            uint[] memory FormattedOwnedIDs = new uint[](NumOwnedTokens);\\n            for(uint z; z < NumOwnedTokens; z++) { FormattedOwnedIDs[z] = temp[z]; }\\n            OwnedIDs[x] = FormattedOwnedIDs;\\n        }\\n        return OwnedIDs;\\n    }\\n}\\n\\ninterface IERC721 { function ownerOf(uint256 tokenId) external view returns (address owner); }\"\r\n    },\r\n    \"contracts/DelegateCashEnabled.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/**\\n * @title DelegateCashEnabled\\n * @author @brougkr\\n * @notice For Easily Integrating `delegate.cash`\\n */\\npragma solidity 0.8.19;\\nabstract contract DelegateCashEnabled\\n{\\n    address private constant _DN = 0x00000000000076A84feF008CDAbe6409d2FE638B;\\n    IDelegation public constant DelegateCash = IDelegation(_DN);\\n}\\n\\ninterface IDelegation\\n{\\n    /**\\n     * @dev Checks If A Vault Has Delegated To The Delegate\\n     */\\n    function checkDelegateForAll(address delegate, address vault) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/DutchMarketplace.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/**\\n * @dev: @brougkr\\n */\\npragma solidity 0.8.19;\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { ReentrancyGuard } from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport { MerkleProof } from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport { IMP } from \\\"./IMP.sol\\\";\\nimport { LaunchpadEnabled } from \\\"./LaunchpadEnabled.sol\\\";\\ncontract DutchMarketplace is Ownable, ReentrancyGuard, LaunchpadEnabled\\n{\\n    struct Sale\\n    {\\n        string _Name;                     // [0] -> _Name\\n        uint _ProjectIDMintPass;          // [1] -> _ProjectIDMintPass\\n        uint _ProjectIDArtBlocks;         // [2] -> _ProjectIDArtBlocks\\n        uint _PriceStart;                 // [3] -> _PriceStart\\n        uint _PriceEnd;                   // [4] -> _PriceEnd\\n        uint _MaxAmtPerPurchase;          // [5] -> _MaxAmtPerPurchase\\n        uint _MaximumAvailableForSale;    // [6] -> _MaximumAvailableForSale\\n        uint _StartingBlockUnixTimestamp; // [7] -> _StartingBlockUnixTimestamp\\n        uint _SecondsBetweenPriceDecay;   // [8] -> _SecondsBetweenPriceDecay\\n        uint _SaleStrip;                  // [9] -> _SaleStrip note: For MintPack Sales, This Is The Default Amount Of Tokens To Mint Per Purchase Per Amount \\n    }\\n\\n    struct InternalSale\\n    {\\n        address _NFT;           // [0] -> _NFT\\n        address _Operator;      // [1] _Operator (Wallet That NFT Is Pulling From)\\n        uint _CurrentIndex;     // [2] _CurrentIndex (If Simple Sale Type, This Is The Next Token Index To Iterate Upon)\\n        uint _Type;             // [3] _SaleType (0 = Factory MintPass, 1 = Bespoke MintPass, 2 = transferFrom(), 3 = purchaseTo(), 4 = MintPack transferFrom())\\n        bool _ActivePublic;     // [4] -> _ActivePublic\\n        bool _ActiveBrightList; // [5] -> _ActiveBrightList \\n        bool _ActiveDiscount;   // [6] -> _ActiveDiscount\\n        bool _ActiveRespend;    // [7] -> _ActiveRespend\\n    }\\n\\n    struct SaleParam\\n    {\\n        bytes32[] _Roots;        // [0] -> _Roots (Merkle Roots For BrightList)\\n        bytes32[] _RootsAmounts; // [1] -> _RootsAmounts (Merkle Roots For BrightList Amounts)\\n        uint[] _DiscountAmounts; // [2] -> _DiscountAmounts (Discount Amounts For Each Discount Priority Tier)\\n    }\\n\\n    struct MiscSale\\n    {\\n        uint _AmountSold;         // [0] -> _AmountSold\\n        uint _UniqueSales;        // [1] -> _UniqueSales\\n        uint _FinalClearingPrice; // [2] -> _FinalClearingPrice\\n        uint _CurrentRefundIndex; // [3] -> _CurrentRefundIndex\\n    }\\n\\n    struct Order\\n    {\\n        address _Purchaser;       // [0] _Purchaser\\n        uint _PurchaseValue;      // [1] _PurchaseValue\\n        uint _PurchaseAmount;     // [2] _PurchaseAmount\\n        uint _Priority;           // [3] _BrightList Priority Status note: (0 Is Highest Priority)\\n        bool _BrightListPurchase; // [4] _BrightListPurchase\\n        bool _Claimed;            // [5] _Claimed\\n    }\\n\\n    struct _UserSaleInformation\\n    {\\n        uint[] _UserOrderIndexes;        // [0] -> _UserOrderIndexes        | The Indexes Of The User's Orders\\n        uint[] _AmountPurchasedPriority; // [1] -> _AmountPurchasedPriority | The Amount Of Tokens Purchased By The User For The Provided Priority\\n        uint _PurchasedAmount;           // [2] -> _PurchaseAmount          | The Amount Of Tokens Purchased By The User\\n        uint _RemainingPurchaseAmount;   // [3] -> _RemainingPurchaseAmount | The Amount Of Tokens Remaining To Be Purchased Specifically For The User\\n        uint _ClaimIndex;                // [4] -> _ClaimIndex              | If ETH-Claims Are Enabled, This Is The User's Current Claim Index\\n        uint _AmountRemaining;           // [5] -> _AmountRemaining         | The Amount Of Tokens Remaining To Be Sold\\n        uint _CurrentPrice;              // [6] -> _MintPassCurrentPrice    | The Current Price Of The Token To Be Sold\\n        uint _Priority;                  // [7] -> _Priority For BrightList | The User's Priority For The BrightList | note: (0 Is Highest Priority) \\n        uint _Credit;                    // [8] -> _Credit                  | The Amount Of Credit / Rebate Owed To The User (Without Discount) \\n        bool _BrightListEligible;        // [9] -> _BrightListEligible      | If The User Is Eligible For The BrightList\\n        bool _MaxAmountVerified;         // [10] -> _MaxAmountVerified      | If The User Passed MaxAmount Correctly\\n        bool _ActiveRespend;             // [11] -> _ActiveRespend          | If Purchase Credit Is Able To Be Used\\n        bool _Active;                    // [12] -> _Active                 | If The Sale Is Active\\n    }\\n\\n    struct Info\\n    {\\n        uint _CurrentPrice;            // [0] -> _CurrentPrice\\n        uint _MaximumAvailableForSale; // [1] -> _MaximumAvailableForSale\\n        uint _AmountRemaining;         // [2] -> _AmountRemaining\\n        bool _Active;                  // [3] -> _Active\\n    }\\n\\n    /*------------------\\n     * STATE VARIABLES *\\n    -------------------*/\\n\\n    uint public _TOTAL_UNIQUE_SALES_DUTCH;                                               // Total Unique Dutch Sales\\n    uint private constant _DEFAULT_PRIORITY = 69420;                                     // Default Priority Value \ud83d\ude09              \\n    address private constant _DN = 0x00000000000076A84feF008CDAbe6409d2FE638B;           // `delegate.cash` Delegation Registry \\n    address private constant _BRT_MULTISIG = 0x0BC56e3c1397e4570069e89C07936A5c6020e3BE; // `sales.brightmoments.eth`\\n    \\n    /*-----------\\n     * MAPPINGS *\\n    ------------*/\\n\\n    mapping(uint=>Sale) public Sales;                                                   // [SaleIndex] => Sale\\n    mapping(uint=>MiscSale) public SaleState;                                           // [SaleIndex] => MiscSale\\n    mapping(uint=>InternalSale) public SalesInternal;                                   // [SaleIndex] => InternalSale\\n    mapping(uint=>Order[]) public Orders;                                               // [SaleIndex][UniqueSaleIndex] => Order\\n    mapping(uint=>mapping(address=>_UserSaleInformation)) public UserInfo;              // [SaleIndex][Wallet] => UserInfo\\n    mapping(uint=>SaleParam) private SaleParams;                                        // [SaleIndex] => SaleParam\\n    mapping(address=>bool) public Admin;                                                // [Wallet] => IsAdmin\\n    mapping(address=>uint) public NFTAddressToSaleIndex;                                // [NFT Address] => SaleIndex\\n    mapping(uint=>mapping(address=>mapping(uint=>uint))) public PriorityPurchaseAmount; // [SaleIndex][Wallet][Priority] => Purchased Amount For Priority Level\\n\\n    /*---------\\n     * EVENTS *\\n    ----------*/\\n\\n    event Purchased(uint SaleIndex, address Purchaser, uint Amount, uint PurchaseValue, uint NewAmountSold, bool BrightList, uint Priority, uint AppliedCredit);\\n    event Refunded(uint Value);\\n    event OrderRefundFailed(uint SaleIndex, uint OrderIndex);\\n    event SaleStarted(uint SaleIndex);\\n    event RefundClaimed(uint SaleIndex, uint OrderIndex);\\n\\n    constructor() \\n    { \\n        Admin[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true;  // `operator.brightmoments.eth`\\n        Admin[msg.sender] = true;\\n    }\\n\\n    /*---------------------\\n     * EXTERNAL FUNCTIONS *\\n    ----------------------*/\\n\\n    /**\\n     * @dev Purchases NFTs\\n     * note: IF YOU PURCHASE THROUGH THE CONTRACT WITHOUT THE FRONTEND YOU WILL NOT BE ELIGIBLE FOR A DISCOUNT REBATE, REQUIRES A MERKLE PROOF\\n     * note: `msg.value` Must Be Sufficient To Purchase NFTs @ The Current Price Of The Dutch Auction\\n     * @param SaleIndex        | The Sale Index\\n     * @param Amount           | The Amount Of NFTs To Purchase\\n     * @param MaxAmount        | Optional Maximum Brightlist Purchase Per Wallet Limiter\\n     * @param Vault            | Vault (optional delegate.cash) (if opt-out, use address(0) or `` for this value)\\n     * @param ProofEligibility | Merkle Proof For Priority Discount Eligibility\\n     * @param ProofAmount      | Merkle Proof For Maximum Purchase Amount\\n     * note: @param ProofEligibility Input --> [0x0] <-- For Empty Proof\\n     * note: @param ProofAmount - Input --> [0x0] <-- For Empty Proof\\n     */\\n    function Purchase (\\n        uint SaleIndex, \\n        uint Amount, \\n        uint MaxAmount, \\n        address Vault, \\n        bytes32[] calldata ProofEligibility, \\n        bytes32[] calldata ProofAmount\\n    ) external payable nonReentrant { \\n        require(tx.origin == msg.sender, \\\"DutchMarketplace: EOA Only, Use `delegate.cash` For Wallet Delegation\\\");\\n        InternalSale memory _IS = SalesInternal[SaleIndex];\\n        require(block.timestamp >= Sales[SaleIndex]._StartingBlockUnixTimestamp, \\\"DutchMarketplace: Sale Not Started\\\");\\n        require(_IS._ActivePublic || _IS._ActiveBrightList, \\\"DutchMarketplace: Sale Not Active\\\");\\n        address Recipient = msg.sender;\\n        uint OrderIndex = SaleState[SaleIndex]._UniqueSales;\\n        if(Vault != address(0)) { if(IDelegationRegistry(_DN).checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } } \\n        require(Recipient != address(0), \\\"DutchMarketplace: Invalid Recipient\\\");\\n        if(SaleState[SaleIndex]._AmountSold + Amount > Sales[SaleIndex]._MaximumAvailableForSale)\\n        {\\n            Amount = Sales[SaleIndex]._MaximumAvailableForSale - SaleState[SaleIndex]._AmountSold;\\n        }\\n        uint NewAmountSold = SaleState[SaleIndex]._AmountSold + Amount;\\n        require(NewAmountSold <= Sales[SaleIndex]._MaximumAvailableForSale, \\\"DutchMarketplace: Sold Out\\\");\\n        uint Priority = _DEFAULT_PRIORITY;\\n        bool BrightListEligible;\\n        if(_IS._ActiveBrightList)\\n        {\\n            (BrightListEligible, Priority) = ViewBrightListStatus(SaleIndex, Recipient, ProofEligibility);\\n            if(BrightListEligible)\\n            {\\n                uint UserPriorityPurchasedAmount = PriorityPurchaseAmount[SaleIndex][Recipient][Priority];\\n                bytes32 _RootHash = SaleParams[SaleIndex]._RootsAmounts[Priority];\\n                require(__VerifyAmount(Recipient, MaxAmount, _RootHash, ProofAmount), \\\"DutchMarketplace: Invalid Max Amount Merkle Proof For Provided Merkle Priority\\\");\\n                require(UserPriorityPurchasedAmount + Amount <= MaxAmount, \\\"DutchMarketplace: User Has Purchased All Allocation For Provided Merkle Priority\\\");\\n                PriorityPurchaseAmount[SaleIndex][Recipient][Priority] += Amount;\\n            }\\n        }\\n        require(Amount > 0 && Amount <= Sales[SaleIndex]._MaxAmtPerPurchase, \\\"DutchMarketplace: Incorrect Desired Purchase Amount\\\");\\n        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);\\n        uint PurchaseValue = CurrentPrice * Amount;\\n        uint AppliedCredit;\\n        if(_IS._ActiveRespend) { AppliedCredit = __ActiveRespend(SaleIndex, CurrentPrice, PurchaseValue, msg.sender); } // AppliedCredit Is Capped @ Purchase Value\\n        uint TotalETHContributed = msg.value + AppliedCredit;\\n        require(TotalETHContributed >= PurchaseValue, \\\"DutchMarketplace: Incorrect ETH Amount Sent\\\");\\n        if(TotalETHContributed > PurchaseValue && msg.value > 0) { __Refund(msg.sender, TotalETHContributed - PurchaseValue); }\\n        Orders[SaleIndex].push(Order(msg.sender, PurchaseValue, Amount, Priority, BrightListEligible, false));\\n        UserInfo[SaleIndex][msg.sender]._UserOrderIndexes.push(OrderIndex);\\n        UserInfo[SaleIndex][msg.sender]._PurchasedAmount = UserInfo[SaleIndex][msg.sender]._PurchasedAmount + Amount;\\n        SaleState[SaleIndex]._UniqueSales = OrderIndex + 1;\\n        SaleState[SaleIndex]._AmountSold = NewAmountSold;\\n        require(SaleState[SaleIndex]._AmountSold <= Sales[SaleIndex]._MaximumAvailableForSale, \\\"DutchMarketplace: Overflow\\\");\\n        if(SaleState[SaleIndex]._AmountSold == Sales[SaleIndex]._MaximumAvailableForSale)\\n        { \\n            SaleState[SaleIndex]._FinalClearingPrice = CurrentPrice; \\n            __EndSale(SaleIndex);\\n        }\\n        if(_IS._Type == 0) { IERC721(_IS._NFT)._MintToFactory(Sales[SaleIndex]._ProjectIDMintPass, msg.sender, Amount); } // Factory MintPass Direct Mint\\n        else if (_IS._Type == 1) { IERC721(_IS._NFT)._MintToBespoke(msg.sender, Amount); } // MintPass Mint To Bespoke\\n        else if (_IS._Type == 2) { IERC721(_IS._NFT)._MintToFactoryPack(Sales[SaleIndex]._ProjectIDMintPass, msg.sender, Amount); } // Factory MintPack Direct Mint\\n        else if (_IS._Type == 3) // transferFrom() Sale Implementation (NFTs Already Minted)\\n        {\\n            for(uint x; x < Amount; x++)\\n            {\\n                IERC721(_IS._NFT).transferFrom(\\n                    _IS._Operator,        // `from`\\n                    msg.sender,           // `to`\\n                    _IS._CurrentIndex + x // `tokenID`\\n                );\\n            }\\n            SalesInternal[SaleIndex]._CurrentIndex = _IS._CurrentIndex + Amount;\\n        }\\n        else if (_IS._Type == 4) // purchaseTo() Sale Implementation\\n        {\\n            uint ProjectID = Sales[SaleIndex]._ProjectIDArtBlocks;\\n            for(uint x; x < Amount; x++)\\n            {\\n                IERC721(_IS._NFT).purchaseTo(\\n                    msg.sender, // `to`\\n                    ProjectID   // `projectID`\\n                );\\n            }\\n        }\\n        else if (_IS._Type == 5) \\n        {\\n            uint _SaleStrip = Sales[SaleIndex]._SaleStrip;\\n            uint _Start = _IS._CurrentIndex;\\n            for(uint x; x < Amount; x++)\\n            {\\n                for(uint y; y < _SaleStrip; y++)\\n                {\\n                    IERC721(_IS._NFT).transferFrom(\\n                        _IS._Operator, // `from`\\n                        msg.sender,    // `to`\\n                        _Start + y     // `tokenID`\\n                    );\\n                }\\n                _Start += _SaleStrip;\\n            }\\n            SalesInternal[SaleIndex]._CurrentIndex = _IS._CurrentIndex + (_SaleStrip * Amount);\\n        }\\n        else { revert(\\\"DutchMarketplace: Incorrect Sale Configuration\\\"); }\\n        emit Purchased(SaleIndex, Recipient, Amount, PurchaseValue, NewAmountSold, BrightListEligible, Priority, AppliedCredit);\\n    }\\n\\n    /*------------------\\n     * ADMIN FUNCTIONS *\\n    -------------------*/\\n\\n    /**\\n     * @dev Starts A Sale\\n     * note: Returns SaleIndex\\n     * note: The True Discount Amount Is 100 - _Sale._DiscountAmount\\n     * note: Ex. _DiscountAmount = 75 = 25% Discount\\n     */\\n    function __StartSale(\\n        Sale memory _Sale,\\n        InternalSale memory _InternalSale,\\n        bytes32[] calldata RootsPriority,\\n        bytes32[] calldata RootsAmounts,\\n        uint[] calldata DiscountAmounts\\n    ) external onlyAdmin returns (uint) {\\n        NFTAddressToSaleIndex[_InternalSale._NFT] = _TOTAL_UNIQUE_SALES_DUTCH;\\n        Sales[_TOTAL_UNIQUE_SALES_DUTCH] = _Sale;\\n        SalesInternal[_TOTAL_UNIQUE_SALES_DUTCH] = _InternalSale;\\n        SaleParams[_TOTAL_UNIQUE_SALES_DUTCH] = SaleParam(RootsPriority, RootsAmounts, DiscountAmounts);\\n        require(\\n            _InternalSale._Type == 0 // Factory MintPass Direct Mint (most gas efficient)\\n            ||\\n            _InternalSale._Type == 1 // Bespoke MintPass Direct Mint (most gas efficient)\\n            ||\\n            _InternalSale._Type == 2 // Factory MintPack Direct Mint (most gas efficient)\\n            ||\\n            _InternalSale._Type == 3 // transferFrom() Sale (NFTs Already Minted) (not gas efficient)\\n            ||\\n            _InternalSale._Type == 4 // purchaseTo() Sale (ArtBlocks Or Custom Mint Pass) (not gas efficient)\\n            ||\\n            _InternalSale._Type == 5 // transferFrom() MintPack Sale (NFTs Already Minted) (not gas efficient)\\n            , \\\"DutchMarketplace: Invalid Sale Type\\\"\\n        );\\n        require(RootsPriority.length == DiscountAmounts.length, \\\"DutchMarketplace: Invalid Merkle Root Length\\\");\\n        for(uint x; x < SaleParams[_TOTAL_UNIQUE_SALES_DUTCH]._DiscountAmounts.length; x++)\\n        {\\n            require(DiscountAmounts[x] <= 100, \\\"DutchMarketplace: Invalid Discount Amount\\\");\\n        }\\n        require(Sales[_TOTAL_UNIQUE_SALES_DUTCH]._PriceStart >= Sales[_TOTAL_UNIQUE_SALES_DUTCH]._PriceEnd, \\\"DutchMarketplace: Invalid Start And End Prices\\\");\\n        emit SaleStarted(_TOTAL_UNIQUE_SALES_DUTCH);\\n        _TOTAL_UNIQUE_SALES_DUTCH++;\\n        return (_TOTAL_UNIQUE_SALES_DUTCH - 1);\\n    }\\n\\n    /**\\n     * @dev Initiates Withdraw Of Refunds & Sale Proceeds\\n     * note: This Is Only After The Sale Has Completed\\n     */\\n    function __InitiateRefundsAndProceeds(uint SaleIndex) external nonReentrant onlyAdmin \\n    {\\n        bool _TxConfirmed;\\n        uint _Proceeds;\\n        uint _Refund;\\n        require(SaleState[SaleIndex]._FinalClearingPrice > 0, \\\"DutchMarketplace: Final Clearing Price Not Seeded\\\");\\n        uint[] memory DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;\\n        for(uint OrderIndex = SaleState[SaleIndex]._CurrentRefundIndex; OrderIndex < SaleState[SaleIndex]._UniqueSales; OrderIndex++)\\n        {\\n            Order memory _Order = Orders[SaleIndex][OrderIndex];\\n            if(!_Order._Claimed)\\n            {\\n                if(!_Order._BrightListPurchase) // No BrightList\\n                {\\n                    _Refund = _Order._PurchaseValue - (SaleState[SaleIndex]._FinalClearingPrice * _Order._PurchaseAmount);\\n                    _Proceeds += _Order._PurchaseValue - _Refund;\\n                    if(_Refund > 0) { (_TxConfirmed,) = _Order._Purchaser.call{ value: _Refund }(\\\"\\\"); }\\n                }\\n                else // BrightList\\n                {\\n                    _Refund = _Order._PurchaseValue - \\n                    (\\n                        ((SaleState[SaleIndex]._FinalClearingPrice * DiscountAmounts[_Order._Priority]) / 100)\\n                        * \\n                        _Order._PurchaseAmount\\n                    );\\n                    _Proceeds += _Order._PurchaseValue - _Refund;\\n                    if(_Refund > 0) { (_TxConfirmed,) = _Order._Purchaser.call{ value: _Refund }(\\\"\\\"); }\\n                }\\n                if(!_TxConfirmed) { emit OrderRefundFailed(SaleIndex, OrderIndex); }\\n                Orders[SaleIndex][OrderIndex]._Claimed = true;\\n            }\\n        }\\n        (_TxConfirmed,) = _BRT_MULTISIG.call{ value: _Proceeds }(\\\"\\\"); \\n        require(_TxConfirmed, \\\"DutchMarketplace: Multisig Refund Failed, Use Failsafe Withdraw And Manually Process\\\");\\n        SaleState[SaleIndex]._CurrentRefundIndex = SaleState[SaleIndex]._UniqueSales; // Resets Refund Index\\n    }\\n\\n    /*--------------*/\\n    /*  ONLY OWNER  */\\n    /*--------------*/\\n\\n    /**\\n     * @dev Modifies The Sale Starting Token Index\\n     * note: If `Simple` Sale, Then This Is The Current TokenID Being Transferred In The Sale\\n     */\\n    function ___ModifySaleStartingTokenIndex(uint SaleIndex, uint StartingTokenID) external onlyOwner\\n    {\\n        SalesInternal[SaleIndex]._CurrentIndex = StartingTokenID;\\n    }\\n\\n    /**\\n     * @dev Modifies The Sale Name\\n     */\\n    function ___ModifySaleName(uint SaleIndex, string calldata Name) external onlyOwner\\n    {\\n        Sales[SaleIndex]._Name = Name;\\n    }\\n\\n    /**\\n     * @dev Modifies The ArtBlocks Sale ProjectID (if applicable)\\n     */\\n    function ___ModifySaleProjectID(uint SaleIndex, uint ProjectID) external onlyOwner\\n    {\\n        Sales[SaleIndex]._ProjectIDMintPass = ProjectID;\\n    }\\n\\n    /**\\n     * @dev Modifies The Starting Price\\n     */\\n    function ___ModifyPriceStart(uint SaleIndex, uint PriceStart) external onlyOwner\\n    {\\n        Sales[SaleIndex]._PriceStart = PriceStart;\\n    }\\n\\n    /**\\n     * @dev Modifies The Ending Price\\n     */\\n    function ___ModifyPriceEnd(uint SaleIndex, uint PriceEnd) external onlyOwner\\n    {\\n        Sales[SaleIndex]._PriceEnd = PriceEnd;\\n    }\\n\\n    /**\\n     * @dev Modifies The Per-Wallet-Limiter\\n     */\\n    function ___ModifyMaxAmtPerPurchase(uint SaleIndex, uint MaxAmtPerPurchase) external onlyOwner\\n    {\\n        Sales[SaleIndex]._MaxAmtPerPurchase = MaxAmtPerPurchase;\\n    }\\n\\n    /**\\n     * @dev Modifies The Maximum NFTs For Sale\\n     */\\n    function ___ModifyMaxForSale(uint SaleIndex, uint AmountForSale) external onlyOwner\\n    {\\n        Sales[SaleIndex]._MaximumAvailableForSale = AmountForSale;\\n    }\\n\\n    /**\\n     * @dev Modifies The Starting Unix Timestamp\\n     */\\n    function ___ModifyTimestampStart(uint SaleIndex, uint Timestamp) external onlyOwner\\n    {\\n        Sales[SaleIndex]._StartingBlockUnixTimestamp = Timestamp;\\n    }\\n\\n    /**\\n     * @dev Modifies The Price Decay (Input In Seconds)\\n     */\\n    function ___ModifyPriceDecay(uint SaleIndex, uint PriceDecayInSeconds) external onlyOwner\\n    {\\n        Sales[SaleIndex]._SecondsBetweenPriceDecay = PriceDecayInSeconds;\\n    }\\n\\n    /**\\n     * @dev Modifies The Sale Discount Amount\\n     * note: Ex. The True Discount Amount = 100 - `DiscountAmount`\\n     * note: Ex. `DiscountAmount` = 75 | 100 - `DiscountAmount` = 25% Discount\\n     */\\n    function ___ModifySaleDiscountAmount(uint SaleIndex, uint[] calldata DiscountAmounts) external onlyOwner\\n    {\\n        for(uint x; x < DiscountAmounts.length; x++)\\n        {\\n            require(DiscountAmounts[x] <= 100, \\\"DutchMarketplace: Invalid Discount Amount\\\");\\n            SaleParams[SaleIndex]._DiscountAmounts[x] = DiscountAmounts[x];\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifies The NFT Address Of A Sale\\n     */\\n    function ___ModifySaleNFTAddress(uint SaleIndex, address NFT) external onlyOwner\\n    {\\n        SalesInternal[SaleIndex]._NFT = NFT;\\n    }\\n\\n    /**\\n     * @dev Modifies The Final Clearing Price Of A Sale\\n     */\\n    function ___ModifySaleClearingPrice(uint SaleIndex, uint ClearingPrice) external onlyOwner\\n    {\\n        SaleState[SaleIndex]._FinalClearingPrice = ClearingPrice;\\n    }\\n\\n    /**\\n     * @dev Modifies The Public Active Sale State\\n     */\\n    function ___ModifySaleStatePublic(uint SaleIndex, bool State) external onlyOwner\\n    {\\n        SalesInternal[SaleIndex]._ActivePublic = State;\\n    }\\n\\n    /**\\n     * @dev Modifies The BrightList Active Sale State\\n     */\\n    function ___ModifySaleStateBrightList(uint SaleIndex, bool State) external onlyOwner\\n    {\\n        SalesInternal[SaleIndex]._ActiveBrightList = State;\\n    }\\n\\n    /**\\n     * @dev Modifies The State Of ETH Claims\\n     * note: onlyOwner: This Enables Users To Claim ETH Rebate Pending In The Contract Before The Sale Concludes\\n     */\\n    function ___ModifySaleETHClaimsEnabled(uint SaleIndex, bool State) external onlyOwner\\n    {\\n        SalesInternal[SaleIndex]._ActiveRespend = State;\\n    }\\n\\n    /**\\n     * @dev onlyOwner: Modifies The Merkle Root(s) For Amounts\\n     */\\n    function ___ModifySaleRootAmounts(uint SaleIndex, bytes32[] calldata RootsAmounts) external onlyOwner\\n    {\\n        SaleParams[SaleIndex]._RootsAmounts = RootsAmounts;\\n    }\\n\\n    /**\\n     * @dev onlyOwner: Modifies The Merkle Root(s) For Eligibility\\n     */\\n    function ___ModifySaleRootEligibility(uint SaleIndex, bytes32[] calldata Roots) external onlyOwner\\n    {\\n        SaleParams[SaleIndex]._Roots = Roots;\\n    }\\n\\n    /**\\n     * @dev Modifies The Sale Root(s) For Merkle Eligibility & Amounts\\n     */\\n    function ___ModifySaleRoots(uint SaleIndex, bytes32[] calldata RootsEligibility, bytes32[] calldata RootsAmounts) external onlyOwner\\n    {\\n        SaleParams[SaleIndex]._Roots = RootsEligibility;\\n        SaleParams[SaleIndex]._RootsAmounts = RootsAmounts;\\n    }\\n\\n    /**\\n     * @dev onlyOwner: Modifies Sale\\n     */\\n    function ___ModifySale(uint SaleIndex, Sale memory _Sale) external onlyOwner { Sales[SaleIndex] = _Sale; }\\n\\n    /**\\n     * @dev Modifies The Sale Operator\\n     */\\n    function ___ModifySaleOperator(uint SaleIndex, address Operator) external onlyOwner { SalesInternal[SaleIndex]._Operator = Operator; }\\n\\n    /**\\n     * @dev onlyOwner: Grants Admin Role\\n     */\\n    function ___AdminGrant(address _Admin) external onlyOwner { Admin[_Admin] = true; }\\n\\n    /**\\n     * @dev onlyOwner: Removes Admin Role\\n     */\\n    function ___AdminRemove(address _Admin) external onlyOwner { Admin[_Admin] = false; }\\n\\n    /**\\n     * @dev onlyOwner: Withdraws All Ether From The Contract\\n     */\\n    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\\n\\n    /**\\n     * @dev onlyOwner: Withdraws Ether From Contract To Address With An Amount\\n     */\\n    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\\n    {\\n        require(Amount > 0 && Amount <= address(this).balance, \\\"Invalid Amount\\\");\\n        (bool Success, ) = Recipient.call{value: Amount}(\\\"\\\");\\n        require(Success, \\\"Unable to Withdraw, Recipient May Have Reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Withdraws ERC721s From Contract\\n     */\\n    function ___WithdrawERC721(address Contract, address Recipient, uint[] calldata TokenIDs) external onlyOwner \\n    { \\n        for(uint TokenID; TokenID < TokenIDs.length;)\\n        {\\n            IERC721(Contract).transferFrom(address(this), Recipient, TokenIDs[TokenID]);\\n            unchecked { TokenID++; }\\n        }\\n    }\\n\\n    /*-----------------\\n     * VIEW FUNCTIONS *\\n    ------------------*/\\n\\n    /**\\n     * @dev Returns Sale Information For A Given Wallet At `SaleIndex`\\n     * @param SaleIndex        | The Sale Index\\n     * @param Wallet           | The Currently Connected Wallet\\n     * @param MaxAmount        | The Max Amount Of Tokens The User Can Purchase\\n     * @param Vault            | The Vault Address\\n     * @param ProofEligibility | The Proof For The BrightList\\n     * @param ProofAmount      | The Proof For The MaxAmount\\n     */\\n    function ViewWalletSaleInformation (\\n        uint SaleIndex,\\n        address Wallet,\\n        uint MaxAmount,\\n        address Vault,\\n        bytes32[] calldata ProofEligibility,\\n        bytes32[] calldata ProofAmount\\n    ) public view returns ( _UserSaleInformation memory ) {\\n        uint[] memory PriorityPurchaseAmounts = new uint[](SaleParams[SaleIndex]._Roots.length);\\n        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);\\n        uint PurchasableAmount;\\n        uint Priority;\\n        bool Verified;\\n        bool VerifiedAmount;\\n        bool Active = SalesInternal[SaleIndex]._ActiveBrightList || SalesInternal[SaleIndex]._ActivePublic;\\n        bool ActiveRespend = SalesInternal[SaleIndex]._ActiveRespend;\\n        uint Credit = ViewPendingCredit(SaleIndex, Wallet);\\n        uint UserPurchasedAmount = UserInfo[SaleIndex][Wallet]._PurchasedAmount;\\n        if(Vault != address(0)) { if(IDelegationRegistry(_DN).checkDelegateForAll(Wallet, Vault)) { Wallet = Vault; } }\\n        for(uint x; x < SaleParams[SaleIndex]._Roots.length; x++) \\n        { \\n            PriorityPurchaseAmounts[x] = PriorityPurchaseAmount[SaleIndex][Wallet][x]; \\n        }\\n        if(MaxAmount < UserPurchasedAmount) { MaxAmount = UserPurchasedAmount; }\\n        PurchasableAmount = MaxAmount - UserPurchasedAmount;\\n        (Verified, Priority) = ViewBrightListStatus(SaleIndex, Wallet, ProofEligibility);\\n        if(Verified) { VerifiedAmount = __VerifyAmount(Wallet, MaxAmount, SaleParams[SaleIndex]._RootsAmounts[Priority], ProofAmount); }\\n        return (\\n            _UserSaleInformation (\\n                UserInfo[SaleIndex][Wallet]._UserOrderIndexes,                                // The User's Order Indexes\\n                PriorityPurchaseAmounts,                                                      // The User's Purchase Amounts Corresponding To Priority \\n                UserPurchasedAmount,                                                          // The User's Total Purchase Amount For `SaleIndex`\\n                PurchasableAmount,                                                            // The User's Purchasable Amount                          \\n                UserInfo[SaleIndex][Wallet]._ClaimIndex,                                      // The User's Claim Index\\n                Sales[SaleIndex]._MaximumAvailableForSale - SaleState[SaleIndex]._AmountSold, // The Remaining Amount Available For Sale\\n                CurrentPrice,                                                                 // The Current Price Of A Sale\\n                Priority,                                                                     // The Priority The User Is Eligible For\\n                Credit,                                                                       // The User's Pending Credit Available To Use Towards Next Purchase\\n                Verified,                                                                     // If The User Is Eligible For BrightList\\n                VerifiedAmount,                                                               // If The User Is Eligible For The MaxAmount\\n                ActiveRespend,                                                                // If ActiveRespend Credit Is Active\\n                Active                                                                        // If The Sale Is Active\\n            )\\n        );\\n    }\\n    \\n    /**\\n     * @dev Batch Returns Multiple Sale Informations For A User\\n     */\\n    function ViewWalletSaleInformations (\\n        uint[] calldata SaleIndexes, \\n        address Wallet, \\n        uint[] calldata MaxAmounts, \\n        address Vault, \\n        bytes32[][] calldata ProofEligibilities, \\n        bytes32[][] calldata ProofAmounts\\n    ) public view returns(_UserSaleInformation[] memory) {\\n        require(\\n            SaleIndexes.length == MaxAmounts.length \\n            && \\n            MaxAmounts.length == ProofEligibilities.length \\n            && \\n            ProofEligibilities.length == ProofAmounts.length, \\n            \\\"DutchMarketplace: Array Lengths Must Match\\\"\\n        );\\n        _UserSaleInformation[] memory _UserSaleInformations = new _UserSaleInformation[](SaleIndexes.length);\\n        for(uint x; x < SaleIndexes.length; x++)\\n        {\\n            _UserSaleInformations[x] = ViewWalletSaleInformation (\\n                SaleIndexes[x],\\n                Wallet,\\n                MaxAmounts[x],\\n                Vault,\\n                ProofEligibilities[x],\\n                ProofAmounts[x]\\n            );\\n        }\\n        return _UserSaleInformations;\\n    }\\n\\n    /**\\n     * @dev Returns All Orders Of `SaleIndex` Within A Range `StartingIndex` & `EndingIndex` Inclusive\\n     */\\n    function ViewOrders(uint SaleIndex) external view returns (Order[] memory) { return Orders[SaleIndex]; }\\n\\n    /**\\n     * @dev Returns All Orders Of `SaleIndex` Within A Range `StartingIndex` & `EndingIndex` Inclusive\\n     */\\n    function ViewOrdersInRange(uint SaleIndex, uint StartingIndex, uint EndingIndex) external view returns (Order[] memory) \\n    { \\n        uint Range = EndingIndex - StartingIndex;\\n        Order[] memory _Orders = new Order[](Range);\\n        for(uint x; x < Range; x++) { _Orders[x] = Orders[SaleIndex][StartingIndex+x]; }\\n        return _Orders; \\n    }\\n\\n    /**\\n     * @dev Returns A [][] Of All Orders On Multiple SaleIndexes Within A Range `StartingIndex` & `EndingIndex` Inclusive\\n     */\\n    function ViewAllOrders(uint[] calldata SaleIndexes, uint StartingIndex, uint EndingIndex) external view returns (Order[][] memory)\\n    {\\n        Order[][] memory __Orders = new Order[][](EndingIndex-StartingIndex);\\n        for(uint SaleIndex; SaleIndex <= SaleIndexes.length; SaleIndex++) { __Orders[SaleIndex] = Orders[SaleIndex]; }\\n        return __Orders;\\n    }\\n\\n    /**\\n     * @dev Returns Sale Index By NFT Contract Address\\n     */\\n    function ViewSaleIndexByNFTAddress(address NFT) public view returns (uint)\\n    {\\n        uint SaleIndex = NFTAddressToSaleIndex[NFT];\\n        if(SaleIndex != 0) { return SaleIndex; }\\n        return 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; // type(uint).max\\n    }\\n\\n    /**\\n     * @dev Returns an [] Of Sale States\\n     */\\n    function ViewSaleStates(uint[] calldata SaleIndexes) public view returns (Sale[] memory, Info[] memory)\\n    {\\n        Sale[] memory _Sales = new Sale[](SaleIndexes.length);\\n        Info[] memory _Infos = new Info[](SaleIndexes.length);\\n        bool Active;\\n        for(uint x; x < SaleIndexes.length; x++) \\n        { \\n            Active = SalesInternal[SaleIndexes[x]]._ActivePublic || SalesInternal[SaleIndexes[x]]._ActiveBrightList;\\n            _Sales[x] = Sales[SaleIndexes[x]]; \\n            _Infos[x] = Info(\\n                __ViewCurrentPrice(SaleIndexes[x]),\\n                Sales[SaleIndexes[x]]._MaximumAvailableForSale,\\n                Sales[SaleIndexes[x]]._MaximumAvailableForSale - SaleState[SaleIndexes[x]]._AmountSold,\\n                Active\\n            );\\n        }\\n        return (_Sales, _Infos);\\n    }\\n\\n    /**\\n     * @dev Returns The Current Pending Credit / Rebate Of A User (With No Discount) Until The Sale Has Concluded.\\n     * note: When The Final Clearing Price Is Seeded, This Function Switches To Show The User's Final Rebate (With Discounts If Eligible)\\n     */\\n    function ViewPendingCredit(uint SaleIndex, address Wallet) public view returns (uint)\\n    {\\n        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);\\n        uint TotalCredit;\\n        uint FinalClearingPrice = SaleState[SaleIndex]._FinalClearingPrice;\\n        uint[] memory _UserOrderIndexes = UserInfo[SaleIndex][Wallet]._UserOrderIndexes;\\n        uint[] memory _DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;\\n        for(uint ClaimIndex; ClaimIndex < _UserOrderIndexes.length; ClaimIndex++)\\n        {\\n            Order memory _Order = Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]];\\n            if(FinalClearingPrice > 0 && _Order._BrightListPurchase) \\n            {\\n                TotalCredit += _Order._PurchaseValue - \\n                (\\n                    ((SaleState[SaleIndex]._FinalClearingPrice * _DiscountAmounts[_Order._Priority]) / 100)\\n                    * \\n                    _Order._PurchaseAmount\\n                );\\n            }\\n            else { TotalCredit += (_Order._PurchaseValue - (_Order._PurchaseAmount * CurrentPrice)); }\\n        }\\n        return TotalCredit;\\n    }\\n\\n    /**\\n     * @dev Returns An [] Of Internal Sale States\\n     */\\n    function ViewInternalSaleStates(uint[] calldata SaleIndexes) public view returns (InternalSale[] memory)\\n    {\\n        InternalSale[] memory _InternalSales = new InternalSale[](SaleIndexes.length);\\n        for(uint x; x < SaleIndexes.length; x++) { _InternalSales[x] = SalesInternal[SaleIndexes[x]]; }\\n        return _InternalSales;\\n    }\\n\\n    /**\\n     * @dev Returns All Order Information Including Addresses And Corresponding Refund Amounts\\n     */\\n    function ViewAllOrderRefunds(uint SaleIndex) public view returns (address[] memory, uint[] memory)\\n    {\\n        address[] memory Addresses = new address[](SaleState[SaleIndex]._UniqueSales);\\n        uint[] memory Refunds = new uint[](SaleState[SaleIndex]._UniqueSales);\\n        uint[] memory DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;\\n        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);\\n        Order memory _Order;\\n        for(uint OrderIndex; OrderIndex < SaleState[SaleIndex]._UniqueSales; OrderIndex++)\\n        {\\n            _Order = Orders[SaleIndex][OrderIndex];\\n            if(_Order._BrightListPurchase)\\n            {\\n                Refunds[OrderIndex] = _Order._PurchaseValue - (\\n                    ((SaleState[SaleIndex]._FinalClearingPrice * DiscountAmounts[_Order._Priority]) / 100) * _Order._PurchaseAmount\\n                );\\n            }\\n            else { Refunds[OrderIndex] = _Order._PurchaseValue - (CurrentPrice * _Order._PurchaseAmount); }\\n            Addresses[OrderIndex] = _Order._Purchaser;\\n        }\\n        return(Addresses, Refunds);\\n    }\\n\\n    /**\\n     * @dev Returns A User's Sale Stats Including Total Amount Purchased, Total Amount Spent, And Total Amount Rebated\\n     * note: This Function Will Only Return Wallet Stats For A Sale That Has Concluded\\n     * note: `NUM_ORDERS` Is The Final Cumulative Order Count Of `Wallet`\\n     * note: `NUM_PURCHASED` Is The Total Number Of NFTs Purchased At `SaleIndex` By `Wallet`\\n     * note: `FINAL_ETH_SPENT` Is The Cumulative Expended ETH Value From `Wallet` At The Conclusion Of The Sale Based On The Final Clearing Price Of The Dutch Auction\\n     * note: `FINAL_ETH_REBATE` Is The Cumulative Unspent ETH That Is Rebated To `Wallet` At The Conclusion Of The Sale Based On The Final Clearing Price Of The Dutch Auction\\n     * note: ETH Values Are Returned In WEI\\n     * note: This Function Was A Request From The Keith Who Loves Vapes\\n     */\\n    function ViewSaleStats(uint SaleIndex, address Wallet) public view returns (uint NUM_ORDERS, uint NUM_PURCHASED, uint FINAL_ETH_SPENT, uint FINAL_ETH_REBATE)\\n    {\\n        require(SaleState[SaleIndex]._FinalClearingPrice > 0, \\\"Sale Not Concluded\\\");\\n        uint CurrentPrice = __ViewCurrentPrice(SaleIndex);\\n        uint FinalRebate;\\n        uint Spent;\\n        uint NumPurchased;\\n        uint OrderRebate;\\n        uint FinalClearingPrice = SaleState[SaleIndex]._FinalClearingPrice; // Retrieves The Final Clearing Price\\n        uint[] memory _UserOrderIndexes = UserInfo[SaleIndex][Wallet]._UserOrderIndexes; // Retrieves The User's Purchase Order Indexes\\n        uint NumOrders = _UserOrderIndexes.length;\\n        uint[] memory _DiscountAmounts = SaleParams[SaleIndex]._DiscountAmounts;\\n        for(uint ClaimIndex; ClaimIndex < _UserOrderIndexes.length; ClaimIndex++)\\n        {\\n            Order memory _Order = Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]];\\n            if(FinalClearingPrice > 0 && _Order._BrightListPurchase) // brightlist priority discount\\n            {\\n                OrderRebate = _Order._PurchaseValue - \\n                (\\n                    ((SaleState[SaleIndex]._FinalClearingPrice * _DiscountAmounts[_Order._Priority]) / 100)\\n                    * \\n                    _Order._PurchaseAmount\\n                );\\n            }\\n            else { OrderRebate = (_Order._PurchaseValue - (_Order._PurchaseAmount * CurrentPrice));  } // no discount\\n            FinalRebate += OrderRebate;\\n            Spent += (_Order._PurchaseValue - OrderRebate);\\n            NumPurchased += _Order._PurchaseAmount;\\n        }\\n        return (NumOrders, NumPurchased, Spent, FinalRebate);\\n    }\\n\\n    /**\\n     * @dev Returns All State Parameters Of A Sale\\n     */\\n    function ViewAllSaleInformation(uint SaleIndex) public view returns (Sale memory, InternalSale memory, MiscSale memory, SaleParam memory, uint Price) \\n    {\\n        return ( Sales[SaleIndex], SalesInternal[SaleIndex], SaleState[SaleIndex], SaleParams[SaleIndex], __ViewCurrentPrice(SaleIndex) );\\n    }\\n\\n    /**\\n     * @dev Returns If User Is On BrightList\\n     * note: Returns BrightList Status & Best Priority Index\\n     */\\n    function ViewBrightListStatus(uint SaleIndex, address Recipient, bytes32[] calldata Proof) public view returns (bool, uint)\\n    {\\n        bool Verified;\\n        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));\\n        for(uint PriorityIndex; PriorityIndex < SaleParams[SaleIndex]._Roots.length; PriorityIndex++) \\n        { \\n            Verified = MerkleProof.verify(Proof, SaleParams[SaleIndex]._Roots[PriorityIndex], Leaf); \\n            if(Verified) { return (true, PriorityIndex); }\\n        }\\n        return (false, _DEFAULT_PRIORITY);\\n    }\\n\\n    /*---------------------\\n     * INTERNAL FUNCTIONS *\\n    ----------------------*/\\n\\n    /**\\n     * @dev Verifies Maximum Purchase Amount Being Passed Is Valid\\n     */\\n    function __VerifyAmount(address _Wallet, uint _Amount, bytes32 _Root, bytes32[] calldata _Proof) internal pure returns (bool)\\n    {\\n        bytes32 _Leaf = (keccak256(abi.encodePacked(_Wallet, _Amount)));\\n        return MerkleProof.verify(_Proof, _Root, _Leaf);\\n    }\\n\\n    /**\\n     * @dev Returns Current Dutch Price For Sale Index\\n     */\\n    function __ViewCurrentPrice(uint SaleIndex) internal view returns (uint Price)\\n    {\\n        if(block.timestamp <= Sales[SaleIndex]._StartingBlockUnixTimestamp) { return Sales[SaleIndex]._PriceStart; }  // Sale Not Started\\n        if(SaleState[SaleIndex]._FinalClearingPrice > 0) { return SaleState[SaleIndex]._FinalClearingPrice; } // Sale Finished\\n        uint CurrentPrice = Sales[SaleIndex]._PriceStart; // Initiates Current Price\\n        uint SecondsElapsed = block.timestamp - Sales[SaleIndex]._StartingBlockUnixTimestamp; // Unix Seconds Elapsed At Current Query Timestamp\\n        CurrentPrice >>= SecondsElapsed / Sales[SaleIndex]._SecondsBetweenPriceDecay; // Div/2 For Each Half Life Iterated Upon\\n        CurrentPrice -= (CurrentPrice * (SecondsElapsed % Sales[SaleIndex]._SecondsBetweenPriceDecay)) / Sales[SaleIndex]._SecondsBetweenPriceDecay / 2;\\n        if(CurrentPrice <= Sales[SaleIndex]._PriceEnd) { return Sales[SaleIndex]._PriceEnd; } // Sale Ended At Resting Band\\n        return CurrentPrice; // Sale Currently Active\\n    }\\n\\n    /**\\n     * @dev Ends A Sale\\n     */\\n    function __EndSale(uint SaleIndex) internal \\n    { \\n        SalesInternal[SaleIndex]._ActivePublic = false; \\n        SalesInternal[SaleIndex]._ActiveBrightList = false;\\n    }\\n\\n    /**\\n     * @dev Refunds `Recipient` ETH Amount `Value`\\n     */\\n    function __Refund(address Recipient, uint Value) internal\\n    {\\n        (bool Confirmed,) = Recipient.call{value: Value}(\\\"\\\"); \\n        require(Confirmed, \\\"DutchMarketplace: Refund Failed\\\");\\n        emit Refunded(Value);\\n    }\\n\\n    /**\\n     * @dev Uses ETH Unspent By A User's Previous Purchase Orders Towards A New Purchase Order\\n     */\\n    function __ActiveRespend(uint SaleIndex, uint CurrentPrice, uint PurchaseValue, address Recipient) internal returns (uint)\\n    {\\n        uint TotalCredit;\\n        uint PotentialCredit;\\n        uint[] memory _UserOrderIndexes = UserInfo[SaleIndex][Recipient]._UserOrderIndexes;\\n        for(uint ClaimIndex; ClaimIndex < _UserOrderIndexes.length; ClaimIndex++)\\n        {\\n            Order memory _Order = Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]];\\n            require(Recipient == _Order._Purchaser, \\\"DutchMarketplace: Invalid State\\\");\\n            if(TotalCredit == PurchaseValue) { return TotalCredit; } // Returns Sufficient Credit For Entire Purchase Order\\n            else\\n            {\\n                PotentialCredit = _Order._PurchaseValue - (_Order._PurchaseAmount * CurrentPrice); \\n                if(PotentialCredit + TotalCredit > PurchaseValue) { PotentialCredit = PurchaseValue - TotalCredit; } // Only Pull As Much Credit As Needed\\n                Orders[SaleIndex][_UserOrderIndexes[ClaimIndex]]._PurchaseValue = _Order._PurchaseValue - PotentialCredit;\\n                TotalCredit += PotentialCredit;\\n            }\\n        }\\n        return TotalCredit; // Returns The Total Amount Of Credit Available\\n    }\\n\\n    /*------------------\\n     * ACCESS MODIFIER *\\n    -------------------*/\\n\\n    modifier onlyAdmin\\n    {\\n        require(Admin[msg.sender] || msg.sender == _LAUNCHPAD || msg.sender == owner());\\n        _;\\n    }\\n}\\n\\ninterface IERC20 { function approve(address From, address To, uint Amount) external; }\\n\\ninterface IERC721 \\n{ \\n    /**\\n     * @dev MintPass Factory Direct Mint\\n     */\\n    function _MintToFactory(uint ProjectID, address To, uint Amount) external;\\n\\n    /**\\n     * @dev MintPass Factory Mint Pack Direct Mint\\n     */\\n    function _MintToFactoryPack(uint ProjectID, address To, uint Amount) external;\\n\\n    /**\\n     * @dev MintPass Factory Mint Pack Direct Mint For Bespoke Mint Passes\\n     */\\n    function _MintToBespoke(address To, uint Amount) external;\\n\\n    /**\\n     * @dev Standard ERC721 Transfer\\n     */\\n    function transferFrom(address From, address To, uint TokenID) external; \\n\\n    /**\\n     * @dev ArtBlocks purchaseTo() Function\\n     */\\n    function purchaseTo(address _to, uint _projectID) external payable returns (uint _tokenId);\\n}\\ninterface IDelegationRegistry\\n{\\n    /**\\n     * @dev Checks If A Vault Has Delegated To The Delegate\\n     */\\n    function checkDelegateForAll(address delegate, address delegator) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v3.3.0\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\\nimport '@openzeppelin/contracts/utils/Address.sol';\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension. Built to optimize for lower gas during batch mints.\\n *\\n * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).\\n *\\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n *\\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is Context, ERC165, IERC721A {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // The tokenId of the next token to be minted.\\n    uint256 internal _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 internal _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.\\n    mapping(uint256 => TokenOwnership) internal _ownerships;\\n\\n    // Mapping owner address to address data\\n    mapping(address => AddressData) private _addressData;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    /**\\n     * To change the starting tokenId, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than _currentIndex - _startTokenId() times\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view returns (uint256) {\\n        // Counter underflow is impossible as _currentIndex does not decrement,\\n        // and it is initialized to _startTokenId()\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return uint256(_addressData[owner].balance);\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return uint256(_addressData[owner].numberMinted);\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return uint256(_addressData[owner].numberBurned);\\n    }\\n\\n    /**\\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return _addressData[owner].aux;\\n    }\\n\\n    /**\\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal {\\n        _addressData[owner].aux = aux;\\n    }\\n\\n    /**\\n     * Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr) if (curr < _currentIndex) {\\n                TokenOwnership memory ownership = _ownerships[curr];\\n                if (!ownership.burned) {\\n                    if (ownership.addr != address(0)) {\\n                        return ownership;\\n                    }\\n                    // Invariant:\\n                    // There will always be an ownership that has an address and is not burned\\n                    // before an ownership that does not have an address and is not burned.\\n                    // Hence, curr will not underflow.\\n                    while (true) {\\n                        curr--;\\n                        ownership = _ownerships[curr];\\n                        if (ownership.addr != address(0)) {\\n                            return ownership;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _ownershipOf(tokenId).addr;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public override {\\n        address owner = ERC721A.ownerOf(tokenId);\\n        if (to == owner) revert ApprovalToCurrentOwner();\\n\\n        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {\\n            revert ApprovalCallerNotOwnerNorApproved();\\n        }\\n\\n        _approve(to, tokenId, owner);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        if (operator == _msgSender()) revert ApproveToCaller();\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n            revert TransferToNonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     *   {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\\n        unchecked {\\n            _addressData[to].balance += uint64(quantity);\\n            _addressData[to].numberMinted += uint64(quantity);\\n\\n            _ownerships[startTokenId].addr = to;\\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\\n\\n            uint256 updatedIndex = startTokenId;\\n            uint256 end = updatedIndex + quantity;\\n\\n            if (to.isContract()) {\\n                do {\\n                    emit Transfer(address(0), to, updatedIndex);\\n                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (updatedIndex < end);\\n                // Reentrancy protection\\n                if (_currentIndex != startTokenId) revert();\\n            } else {\\n                do {\\n                    emit Transfer(address(0), to, updatedIndex++);\\n                } while (updatedIndex < end);\\n            }\\n            _currentIndex = updatedIndex;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 quantity) internal {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\\n        unchecked {\\n            _addressData[to].balance += uint64(quantity);\\n            _addressData[to].numberMinted += uint64(quantity);\\n\\n            _ownerships[startTokenId].addr = to;\\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\\n\\n            uint256 updatedIndex = startTokenId;\\n            uint256 end = updatedIndex + quantity;\\n\\n            do {\\n                emit Transfer(address(0), to, updatedIndex++);\\n            } while (updatedIndex < end);\\n\\n            _currentIndex = updatedIndex;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) private {\\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\\n\\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\\n\\n        bool isApprovedOrOwner = (_msgSender() == from ||\\n            isApprovedForAll(from, _msgSender()) ||\\n            getApproved(tokenId) == _msgSender());\\n\\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId, from);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            _addressData[from].balance -= 1;\\n            _addressData[to].balance += 1;\\n\\n            TokenOwnership storage currSlot = _ownerships[tokenId];\\n            currSlot.addr = to;\\n            currSlot.startTimestamp = uint64(block.timestamp);\\n\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\n            uint256 nextTokenId = tokenId + 1;\\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\\n            if (nextSlot.addr == address(0)) {\\n                // This will suffice for checking _exists(nextTokenId),\\n                // as a burned slot cannot contain the zero address.\\n                if (nextTokenId != _currentIndex) {\\n                    nextSlot.addr = from;\\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\\n\\n        address from = prevOwnership.addr;\\n\\n        if (approvalCheck) {\\n            bool isApprovedOrOwner = (_msgSender() == from ||\\n                isApprovedForAll(from, _msgSender()) ||\\n                getApproved(tokenId) == _msgSender());\\n\\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId, from);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            AddressData storage addressData = _addressData[from];\\n            addressData.balance -= 1;\\n            addressData.numberBurned += 1;\\n\\n            // Keep track of who burned the token, and the timestamp of burning.\\n            TokenOwnership storage currSlot = _ownerships[tokenId];\\n            currSlot.addr = from;\\n            currSlot.startTimestamp = uint64(block.timestamp);\\n            currSlot.burned = true;\\n\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\n            uint256 nextTokenId = tokenId + 1;\\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\\n            if (nextSlot.addr == address(0)) {\\n                // This will suffice for checking _exists(nextTokenId),\\n                // as a burned slot cannot contain the zero address.\\n                if (nextTokenId != _currentIndex) {\\n                    nextSlot.addr = from;\\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(\\n        address to,\\n        uint256 tokenId,\\n        address owner\\n    ) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n            return retval == IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\\n     * minting.\\n     * And also called after one token has been burned.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/ERC721AO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721AO Contracts v3.3.0\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\\nimport '@openzeppelin/contracts/utils/Address.sol';\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension. Built to optimize for lower gas during batch mints.\\n *\\n * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).\\n *\\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n *\\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721AO is Context, ERC165, IERC721A {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // The tokenId of the next token to be minted.\\n    uint256 internal _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 internal _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.\\n    mapping(uint256 => TokenOwnership) internal _ownerships;\\n\\n    // Mapping owner address to address data\\n    mapping(address => AddressData) private _addressData;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    /**\\n     * To change the starting tokenId, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than _currentIndex - _startTokenId() times\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view returns (uint256) {\\n        // Counter underflow is impossible as _currentIndex does not decrement,\\n        // and it is initialized to _startTokenId()\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return uint256(_addressData[owner].balance);\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return uint256(_addressData[owner].numberMinted);\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return uint256(_addressData[owner].numberBurned);\\n    }\\n\\n    /**\\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return _addressData[owner].aux;\\n    }\\n\\n    /**\\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal {\\n        _addressData[owner].aux = aux;\\n    }\\n\\n    /**\\n     * Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr) if (curr < _currentIndex) {\\n                TokenOwnership memory ownership = _ownerships[curr];\\n                if (!ownership.burned) {\\n                    if (ownership.addr != address(0)) {\\n                        return ownership;\\n                    }\\n                    // Invariant:\\n                    // There will always be an ownership that has an address and is not burned\\n                    // before an ownership that does not have an address and is not burned.\\n                    // Hence, curr will not underflow.\\n                    while (true) {\\n                        curr--;\\n                        ownership = _ownerships[curr];\\n                        if (ownership.addr != address(0)) {\\n                            return ownership;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _ownershipOf(tokenId).addr;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721AO.ownerOf(tokenId);\\n        if (to == owner) revert ApprovalToCurrentOwner();\\n\\n        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {\\n            revert ApprovalCallerNotOwnerNorApproved();\\n        }\\n\\n        _approve(to, tokenId, owner);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        if (operator == _msgSender()) revert ApproveToCaller();\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n            revert TransferToNonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     *   {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\\n        unchecked {\\n            _addressData[to].balance += uint64(quantity);\\n            _addressData[to].numberMinted += uint64(quantity);\\n\\n            _ownerships[startTokenId].addr = to;\\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\\n\\n            uint256 updatedIndex = startTokenId;\\n            uint256 end = updatedIndex + quantity;\\n\\n            if (to.isContract()) {\\n                do {\\n                    emit Transfer(address(0), to, updatedIndex);\\n                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (updatedIndex < end);\\n                // Reentrancy protection\\n                if (_currentIndex != startTokenId) revert();\\n            } else {\\n                do {\\n                    emit Transfer(address(0), to, updatedIndex++);\\n                } while (updatedIndex < end);\\n            }\\n            _currentIndex = updatedIndex;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 quantity) internal {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\\n        unchecked {\\n            _addressData[to].balance += uint64(quantity);\\n            _addressData[to].numberMinted += uint64(quantity);\\n\\n            _ownerships[startTokenId].addr = to;\\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\\n\\n            uint256 updatedIndex = startTokenId;\\n            uint256 end = updatedIndex + quantity;\\n\\n            do {\\n                emit Transfer(address(0), to, updatedIndex++);\\n            } while (updatedIndex < end);\\n\\n            _currentIndex = updatedIndex;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) private {\\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\\n\\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\\n\\n        bool isApprovedOrOwner = (_msgSender() == from ||\\n            isApprovedForAll(from, _msgSender()) ||\\n            getApproved(tokenId) == _msgSender());\\n\\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId, from);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            _addressData[from].balance -= 1;\\n            _addressData[to].balance += 1;\\n\\n            TokenOwnership storage currSlot = _ownerships[tokenId];\\n            currSlot.addr = to;\\n            currSlot.startTimestamp = uint64(block.timestamp);\\n\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\n            uint256 nextTokenId = tokenId + 1;\\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\\n            if (nextSlot.addr == address(0)) {\\n                // This will suffice for checking _exists(nextTokenId),\\n                // as a burned slot cannot contain the zero address.\\n                if (nextTokenId != _currentIndex) {\\n                    nextSlot.addr = from;\\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\\n\\n        address from = prevOwnership.addr;\\n\\n        if (approvalCheck) {\\n            bool isApprovedOrOwner = (_msgSender() == from ||\\n                isApprovedForAll(from, _msgSender()) ||\\n                getApproved(tokenId) == _msgSender());\\n\\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId, from);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            AddressData storage addressData = _addressData[from];\\n            addressData.balance -= 1;\\n            addressData.numberBurned += 1;\\n\\n            // Keep track of who burned the token, and the timestamp of burning.\\n            TokenOwnership storage currSlot = _ownerships[tokenId];\\n            currSlot.addr = from;\\n            currSlot.startTimestamp = uint64(block.timestamp);\\n            currSlot.burned = true;\\n\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\n            uint256 nextTokenId = tokenId + 1;\\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\\n            if (nextSlot.addr == address(0)) {\\n                // This will suffice for checking _exists(nextTokenId),\\n                // as a burned slot cannot contain the zero address.\\n                if (nextTokenId != _currentIndex) {\\n                    nextSlot.addr = from;\\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(\\n        address to,\\n        uint256 tokenId,\\n        address owner\\n    ) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n            return retval == IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\\n     * minting.\\n     * And also called after one token has been burned.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/ERC721MP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v3.3.0\\n// Creator: Chiru Labs\\n// forked for this impl\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721MP.sol';\\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\\nimport '@openzeppelin/contracts/utils/Address.sol';\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension. Built to optimize for lower gas during batch mints.\\n *\\n * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).\\n *\\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n *\\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721MP is Context, ERC165, IERC721MP {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // CryptoCitizenLiveMint Contract\\n    mapping(address=>bool) public _WhitelistedSender;\\n\\n    bool _ArtistsRevealedIDs;\\n    bool _ArtistRevealedNames;\\n\\n    // The tokenId of the next token to be minted.\\n    uint256 internal _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 internal _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.\\n    mapping(uint256 => TokenOwnership) internal _ownerships;\\n\\n    // Mapping owner address to address data\\n    mapping(address => AddressData) private _addressData;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    /**\\n     * To change the starting tokenId, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than _currentIndex - _startTokenId() times\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view returns (uint256) {\\n        // Counter underflow is impossible as _currentIndex does not decrement,\\n        // and it is initialized to _startTokenId()\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return uint256(_addressData[owner].balance);\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return uint256(_addressData[owner].numberMinted);\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return uint256(_addressData[owner].numberBurned);\\n    }\\n\\n    /**\\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return _addressData[owner].aux;\\n    }\\n\\n    /**\\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal {\\n        _addressData[owner].aux = aux;\\n    }\\n\\n    /**\\n     * Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr) if (curr < _currentIndex) {\\n                TokenOwnership memory ownership = _ownerships[curr];\\n                if (!ownership.burned) {\\n                    if (ownership.addr != address(0)) {\\n                        return ownership;\\n                    }\\n                    // Invariant:\\n                    // There will always be an ownership that has an address and is not burned\\n                    // before an ownership that does not have an address and is not burned.\\n                    // Hence, curr will not underflow.\\n                    while (true) {\\n                        curr--;\\n                        ownership = _ownerships[curr];\\n                        if (ownership.addr != address(0)) {\\n                            return ownership;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _ownershipOf(tokenId).addr;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) { return ''; }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public override {\\n        address owner = ERC721MP.ownerOf(tokenId);\\n        if (to == owner) revert ApprovalToCurrentOwner();\\n\\n        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {\\n            revert ApprovalCallerNotOwnerNorApproved();\\n        }\\n\\n        _approve(to, tokenId, owner);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        if (operator == _msgSender()) revert ApproveToCaller();\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     * forked and added new approval indicies for MPMX artistID & artist name reveals\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n            revert TransferToNonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 quantity) internal {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\\n        unchecked {\\n            _addressData[to].balance += uint64(quantity);\\n            _addressData[to].numberMinted += uint64(quantity);\\n\\n            _ownerships[startTokenId].addr = to;\\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\\n\\n            uint256 updatedIndex = startTokenId;\\n            uint256 end = updatedIndex + quantity;\\n\\n            do {\\n                emit Transfer(address(0), to, updatedIndex++);\\n            } while (updatedIndex < end);\\n\\n            _currentIndex = updatedIndex;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) private {\\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\\n        bool isApprovedOrOwner = (\\n            _msgSender() == from \\n            ||\\n            isApprovedForAll(from, _msgSender()) \\n            ||\\n            getApproved(tokenId) == _msgSender()\\n        );\\n\\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId, from);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            _addressData[from].balance -= 1;\\n            _addressData[to].balance += 1;\\n\\n            TokenOwnership storage currSlot = _ownerships[tokenId];\\n            currSlot.addr = to;\\n            currSlot.startTimestamp = uint64(block.timestamp);\\n\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\n            uint256 nextTokenId = tokenId + 1;\\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\\n            if (nextSlot.addr == address(0)) {\\n                // This will suffice for checking _exists(nextTokenId),\\n                // as a burned slot cannot contain the zero address.\\n                if (nextTokenId != _currentIndex) {\\n                    nextSlot.addr = from;\\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\\n\\n        address from = prevOwnership.addr;\\n\\n        if (approvalCheck) {\\n            bool isApprovedOrOwner = (\\n                _msgSender() == from \\n                ||\\n                isApprovedForAll(from, _msgSender()) \\n                ||\\n                getApproved(tokenId) == _msgSender()\\n                ||\\n                _WhitelistedSender[tx.origin]\\n            );\\n\\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId, from);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            AddressData storage addressData = _addressData[from];\\n            addressData.balance -= 1;\\n            addressData.numberBurned += 1;\\n\\n            // Keep track of who burned the token, and the timestamp of burning.\\n            TokenOwnership storage currSlot = _ownerships[tokenId];\\n            currSlot.addr = from;\\n            currSlot.startTimestamp = uint64(block.timestamp);\\n            currSlot.burned = true;\\n\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\n            uint256 nextTokenId = tokenId + 1;\\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\\n            if (nextSlot.addr == address(0)) {\\n                // This will suffice for checking _exists(nextTokenId),\\n                // as a burned slot cannot contain the zero address.\\n                if (nextTokenId != _currentIndex) {\\n                    nextSlot.addr = from;\\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(\\n        address to,\\n        uint256 tokenId,\\n        address owner\\n    ) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n            return retval == IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\\n     * minting.\\n     * And also called after one token has been burned.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/ERC721MPF.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v3.3.0\\n// Creator: Chiru Labs\\n// forked for this impl\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721MP.sol';\\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\\nimport '@openzeppelin/contracts/utils/Address.sol';\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension. Built to optimize for lower gas during batch mints.\\n *\\n * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).\\n *\\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n *\\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721MPF is Context, ERC165, IERC721MP {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    mapping(address => bool) public _WhitelistedSender;\\n    mapping(uint => uint) public _ProjectInvocations;\\n    mapping(uint => uint) public _MaxSupply;\\n    mapping(uint => bool) public _Active;\\n    uint256 private constant ONE_MILLION = 1000000;\\n\\n    // The tokenId of the next token to be minted.\\n    uint256 internal _TOTAL_MINTED;\\n\\n    // The number of tokens burned.\\n    uint256 internal _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.\\n    mapping(uint256 => TokenOwnership) internal _ownerships;\\n\\n    // Mapping owner address to address data\\n    mapping(address => AddressData) private _addressData;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than _TOTAL_MINTED - _startTokenId() times\\n        unchecked {\\n            return _TOTAL_MINTED - _burnCounter;\\n        }\\n    }\\n\\n    /**\\n     * Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view returns (uint256) {\\n        // Counter underflow is impossible as _TOTAL_MINTED does not decrement,\\n        // and it is initialized to _startTokenId()\\n        unchecked {\\n            return _TOTAL_MINTED;\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return uint256(_addressData[owner].balance);\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return uint256(_addressData[owner].numberMinted);\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return uint256(_addressData[owner].numberBurned);\\n    }\\n\\n    /**\\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return _addressData[owner].aux;\\n    }\\n\\n    /**\\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal {\\n        _addressData[owner].aux = aux;\\n    }\\n\\n    /**\\n     * Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            TokenOwnership memory ownership = _ownerships[curr];\\n            if (!ownership.burned) {\\n                if (ownership.addr != address(0)) {\\n                    return ownership;\\n                }\\n                // Invariant:\\n                // There will always be an ownership that has an address and is not burned\\n                // before an ownership that does not have an address and is not burned.\\n                // Hence, curr will not underflow.\\n                while (true) {\\n                    curr--;\\n                    ownership = _ownerships[curr];\\n                    if (ownership.addr != address(0)) {\\n                        return ownership;\\n                    }\\n                }\\n            }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _ownershipOf(tokenId).addr;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI(tokenId);\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI(uint256 tokenId) internal view virtual returns (string memory) { return ''; }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721MPF.ownerOf(tokenId);\\n        if (to == owner) revert ApprovalToCurrentOwner();\\n\\n        if (_msgSender() != owner) if(!isApprovedForAll(owner, _msgSender())) {\\n            revert ApprovalCallerNotOwnerNorApproved();\\n        }\\n\\n        _approve(to, tokenId, owner);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        if (operator == _msgSender()) revert ApproveToCaller();\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     * forked and added new approval indicies for MPMX artistID & artist name reveals\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n        if (to.isContract()) if(!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n            revert TransferToNonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _ownerships[tokenId].addr != address(0) && !_ownerships[tokenId].burned;\\n    }\\n\\n    /**\\n     * @dev Returns The Number Of Project Invocations\\n     */\\n    function ReadProjectInvocations(uint projectID) public view returns (uint) { return _ProjectInvocations[projectID]; }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(uint projectID, address to, uint256 quantity) internal {\\n        require(_ProjectInvocations[projectID] + quantity <= _MaxSupply[projectID], \\\"ERC721MPF: Minting Exceeds Project Limit\\\");\\n        require(_Active[projectID], \\\"ERC721MPF: Project Not Active\\\");\\n        uint256 startTokenId = (projectID * ONE_MILLION) + _ProjectInvocations[projectID];\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\n        // updatedIndex overflows if _TOTAL_MINTED + quantity > 1.2e77 (2**256) - 1\\n        unchecked {\\n            _addressData[to].balance += uint64(quantity);\\n            _addressData[to].numberMinted += uint64(quantity);\\n\\n            _ownerships[startTokenId].addr = to;\\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\\n\\n            uint256 updatedIndex = startTokenId;\\n            uint256 end = updatedIndex + quantity;\\n\\n            do { emit Transfer(address(0), to, updatedIndex++); } while (updatedIndex < end);\\n\\n            _TOTAL_MINTED += quantity;\\n        }\\n        _ProjectInvocations[projectID] += quantity; \\n        if(_MaxSupply[projectID] == _ProjectInvocations[projectID]) \\n        { \\n            _Active[projectID] = false; // Auto-Disables Minting After Max Supply Is Reached   \\n        } \\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) private {\\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\\n        bool isApprovedOrOwner = (\\n            _msgSender() == from \\n            ||\\n            isApprovedForAll(from, _msgSender()) \\n            ||\\n            getApproved(tokenId) == _msgSender()\\n        );\\n\\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId, from);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            _addressData[from].balance -= 1;\\n            _addressData[to].balance += 1;\\n\\n            TokenOwnership storage currSlot = _ownerships[tokenId];\\n            currSlot.addr = to;\\n            currSlot.startTimestamp = uint64(block.timestamp);\\n\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\n            uint256 nextTokenId = tokenId + 1;\\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\\n            if (nextSlot.addr == address(0)) {\\n                // This will suffice for checking _exists(nextTokenId),\\n                // as a burned slot cannot contain the zero address.\\n                if (nextTokenId != _TOTAL_MINTED) {\\n                    nextSlot.addr = from;\\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        TokenOwnership memory prevOwnership = _ownershipOf(tokenId);\\n\\n        address from = prevOwnership.addr;\\n\\n        if (approvalCheck) {\\n            bool isApprovedOrOwner = (\\n                _msgSender() == from \\n                ||\\n                isApprovedForAll(from, _msgSender()) \\n                ||\\n                getApproved(tokenId) == _msgSender()\\n            );\\n\\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId, from);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            AddressData storage addressData = _addressData[from];\\n            addressData.balance -= 1;\\n            addressData.numberBurned += 1;\\n\\n            // Keep track of who burned the token, and the timestamp of burning.\\n            TokenOwnership storage currSlot = _ownerships[tokenId];\\n            currSlot.addr = from;\\n            currSlot.startTimestamp = uint64(block.timestamp);\\n            currSlot.burned = true;\\n\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\n            uint256 nextTokenId = tokenId + 1;\\n            TokenOwnership storage nextSlot = _ownerships[nextTokenId];\\n            if (nextSlot.addr == address(0)) {\\n                // This will suffice for checking _exists(nextTokenId),\\n                // as a burned slot cannot contain the zero address.\\n                if (nextTokenId != _TOTAL_MINTED) {\\n                    nextSlot.addr = from;\\n                    nextSlot.startTimestamp = prevOwnership.startTimestamp;\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _TOTAL_MINTED times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(\\n        address to,\\n        uint256 tokenId,\\n        address owner\\n    ) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n            return retval == IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\\n     * minting.\\n     * And also called after one token has been burned.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/FactoryBRT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/**\\n * @dev: @brougkr\\n */\\npragma solidity 0.8.19;\\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\ncontract FactoryBRT is ERC20, Ownable\\n{\\n    bytes32 private constant _AUTHORIZED = keccak256(\\\"AUTHORIZED\\\");\\n    mapping(address=>bytes32) public Role;\\n    constructor() ERC20(\\\"BRTMP\\\", \\\"BRTMP\\\") \\n    {\\n        // _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700); // Transfers Ownership To `operator.brightmoments.eth`\\n    }\\n\\n    /**\\n     * @dev Mints ERC-20\\n     */\\n    function ___Mint(address Recipient, uint Amount) external onlyOwner { _mint(Recipient, Amount); }\\n\\n    /**\\n     * @dev Authorizes A Contract\\n     */\\n    function ____AuthorizeContract(address Contract) external onlyOwner { Role[Contract] = _AUTHORIZED; }\\n\\n    /**\\n     * @dev Deauthorizes A Contract\\n     */\\n    function ____DeauthorizeContract(address Contract) external onlyOwner { Role[Contract] = 0x0; }\\n\\n    /**\\n     * @dev Allocates An `Amount` Of ERC-20 To `Recipient`\\n     */\\n    function __Allocate(uint Amount) external onlyAuthorized { _mint(msg.sender, Amount * 1 ether); }\\n\\n    /**\\n     * @dev Access Modifier For Authorized Contracts\\n     */\\n    modifier onlyAuthorized() \\n    {\\n        require(Role[msg.sender] == _AUTHORIZED, \\\"BRTMP: `msg.sender` Not Authorized\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/IBRT.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/**\\n * @dev: @brougkr\\n */\\npragma solidity ^0.8.19;\\ninterface IBRT { function ModifyRewardRates(uint[] calldata RewardIndexes, uint[] calldata RewardRates) external; }\"\r\n    },\r\n    \"contracts/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v3.3.0\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\\n\\n/**\\n * @dev Interface of an ERC721A compliant contract.\\n */\\ninterface IERC721A is IERC721, IERC721Metadata {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * The caller cannot approve to their own address.\\n     */\\n    error ApproveToCaller();\\n\\n    /**\\n     * The caller cannot approve to the current owner.\\n     */\\n    error ApprovalToCurrentOwner();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n    }\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct AddressData {\\n        // Realistically, 2**64-1 is more than enough.\\n        uint64 balance;\\n        // Keeps track of mint count with minimal overhead for tokenomics.\\n        uint64 numberMinted;\\n        // Keeps track of burn count with minimal overhead for tokenomics.\\n        uint64 numberBurned;\\n        // For miscellaneous variable(s) pertaining to the address\\n        // (e.g. number of whitelist mint slots used).\\n        // If there are multiple variables, please pack them into a uint64.\\n        uint64 aux;\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     * \\n     * Burned tokens are calculated here, use `_totalMinted()` if you want to count just minted tokens.\\n     */\\n    function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/IERC721MP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721MP Contracts v3.3.0\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\\n\\n/**\\n * @dev Interface of an ERC721MP compliant contract.\\n */\\ninterface IERC721MP is IERC721, IERC721Metadata {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * The caller cannot approve to their own address.\\n     */\\n    error ApproveToCaller();\\n\\n    /**\\n     * The caller cannot approve to the current owner.\\n     */\\n    error ApprovalToCurrentOwner();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n    }\\n\\n    // Compiler will pack this into a single 256bit word.\\n    struct AddressData {\\n        // Realistically, 2**64-1 is more than enough.\\n        uint64 balance;\\n        // Keeps track of mint count with minimal overhead for tokenomics.\\n        uint64 numberMinted;\\n        // Keeps track of burn count with minimal overhead for tokenomics.\\n        uint64 numberBurned;\\n        // For miscellaneous variable(s) pertaining to the address\\n        // (e.g. number of whitelist mint slots used).\\n        // If there are multiple variables, please pack them into a uint64.\\n        uint64 aux;\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     * \\n     * Burned tokens are calculated here, use `_totalMinted()` if you want to count just minted tokens.\\n     */\\n    function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/IGT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/**\\n * @dev @brougkr\\n */\\npragma solidity 0.8.19;\\ninterface IGT \\n{ \\n    /**\\n     * @dev { Golden Token Burn }\\n     */\\n    function _LiveMintBurn(uint TicketID) external returns (address Recipient); \\n}\"\r\n    },\r\n    \"contracts/ILaunchpad.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/**\\n * Launchpad Registry Interface\\n * @author @brougkr\\n */\\npragma solidity 0.8.19;\\ninterface ILaunchpad \\n{ \\n    /**\\n     * @dev Returns Next ProjectID From ArtBlocks Contract\\n     */\\n    function ViewNextABProjectID() external view returns(uint);\\n\\n    /**\\n     * @dev Returns Launchpad Registry Address\\n     */\\n    function ViewAddressLaunchpadRegistry() external view returns(address);\\n\\n    /**\\n     * @dev Returns Marketplace Address\\n     */\\n    function ViewAddressMarketplace() external view returns(address);\\n\\n    /**\\n     * @dev Returns LiveMint Address\\n     */\\n    function ViewAddressLiveMint() external view returns (address);\\n\\n    /**\\n     * @dev Returns Mint Pass Factory Address\\n     */\\n    function ViewAddressMintPassFactory() external view returns (address);\\n}\\n\\n/**\\n * @dev Launchpad Registry Interface\\n */\\ninterface ILaunchpadRegistry \\n{ \\n    function __NewMintPassURI(uint MintPassProjectID, string memory NewURI) external; \\n    function ViewBaseURIMintPass(uint MintPassProjectID) external view returns (string memory);\\n}\"\r\n    },\r\n    \"contracts/IMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/**\\n * @title IMinter Minter Interface\\n * @author @brougkr\\n */\\npragma solidity ^0.8.19;\\ninterface IMinter \\n{ \\n    function purchase(uint256 _projectId) payable external returns (uint tokenID); // Custom\\n    function purchaseTo(address _to, uint _projectId) payable external returns (uint tokenID); // ArtBlocks Standard Minter\\n    function purchaseTo(address _to) external returns (uint tokenID); // Custom\\n    function purchaseTo(address _to, uint _projectId, address _ownedNFTAddress, uint _ownedNFTTokenID) payable external returns (uint tokenID); // ArtBlocks PolyMinter\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n    function _MintToFactory(uint ProjectID, address To, uint Amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IMP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/**\\n * @dev @brougkr\\n */\\npragma solidity 0.8.19;\\ninterface IMP \\n{ \\n    /**\\n     * @dev { For Instances Where Golden Token Or Artists Have A Bespoke Mint Pass Contract }\\n     */\\n    function _LiveMintBurn(uint TicketID) external returns (address Recipient, uint ArtistID); \\n}\"\r\n    },\r\n    \"contracts/IOS.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\nabstract contract IOS {\\n    bool public OPERATOR_FILTER_ENABLED = true;\\n    function __ChangeOperatorFilterState(bool State) external virtual;\\n}\"\r\n    },\r\n    \"contracts/Launchpad.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/** \\n * @dev @brougkr\\n * - Launchpad is an interface to easily create NFT projects on ETH. \\n * - Optionally Includes Integration And Deployment With Live-Rebate Respsend & Discount Dutch Marketplace, LiveMint, MintPass Factory, ArtBlocks Flex, Core, Poly Minters\\n * - It Interacts With The Following Contracts Optionally, Depending On Your Project Needs:\\n * - { 1 } - { Marketplace }\\n * - { 2 } - { LiveMint }\\n * - { 3 } - { ArtBlocks Core Engine / Flex / Polyptych }\\n * - { 4 } - { Minted Works Factory }\\n * - { 5 } - { MintPass Factory }\\n*/\\npragma solidity 0.8.19;\\ncontract Launchpad \\n{   \\n    struct StateParameters \\n    {\\n        bool _Active;\\n        address _DutchMarketplace;\\n        address _BasicMarketplace;\\n        address _LiveMint;\\n        address _ArtBlocksCore;\\n        address _ArtBlocksFlex;\\n        address _FactoryMintedWorks;\\n        address _FactoryMintPass;\\n        address _PolyMinter;\\n        address _LaunchpadRegistry;\\n        address _Owner; \\n    }\\n\\n    StateParameters public Params = StateParameters (\\n        true,                                       // _Active\\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _DutchMarketplace\\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _BasicMarketplace\\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _LiveMint\\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _ArtBlocksCoreEngine\\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _ArtBlocksCoreFlex\\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _FactoryMintPass\\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _FactoryMintedWorks\\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _PolyMinter\\n        0xe745243b82ebC46E5c23d9B1B968612c65d45f3d, // _LaunchpadRegistry\\n        msg.sender\\n    );\\n\\n    mapping(address=>bool) public Admin;            // [Wallet] => Is Admin\\n    mapping(address=>uint) public OperatorCooldown; // [Wallet] => Unix Timestamp Of When Cooldown Ends\\n    mapping(address=>bool) public Operator;         // [Wallet] => Is Operator\\n    mapping(address=>bool) public Whitelisted;      // [Contract] => Is Whitelisted\\n\\n    event ProjectInvoked(uint Index);\\n    event ProjectModified(uint Index);\\n    event LiveMintEnabled(uint Index);\\n\\n    constructor() \\n    { \\n        Params._Owner = msg.sender; \\n        Admin[0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266] = true;\\n        Admin[0x38E27a59d3cffB945aC8d41b7c398618354c08F6] = true;\\n    }\\n    \\n    /**\\n     * @dev Enables Live Minting For A Project\\n     */\\n    function EnableLiveMinting(uint LaunchpadProjectID) external onlyAdmin\\n    {\\n        require(Params._Active, \\\"Launchpad | Not Active\\\");\\n        uint ArtBlocksProjectID = ILaunchpadRegistry(Params._LaunchpadRegistry).ViewArtBlocksProjectID(LaunchpadProjectID);\\n        IMinter(Params._ArtBlocksCore).updateProjectArtistAddress(ArtBlocksProjectID, Params._LiveMint);\\n        emit LiveMintEnabled(LaunchpadProjectID);\\n    }\\n\\n    /**\\n     * @dev Starts An ArtBlocks Project\\n     */\\n    function InitArtBlocksEngineProject(\\n        IMintPass.Params memory ParamsMintPass,       // Mint Pass Parameters\\n        IMinter.ParamsArtBlocks memory ParamsMint,    // Minted Work Parameters\\n        IMarketplace.Sale memory ParamsSale,          // Marketplace Sale Parameters\\n        IMarketplace.State memory ParamsSaleInternal, // Marketplace Sale State Parameters\\n        bytes32[] calldata RootsPriority,\\n        bytes32[] calldata RootsAmounts,\\n        uint[] calldata DiscountAmounts\\n    ) external onlyOperator {\\n        require(Params._Active, \\\"Launchpad | Not Active\\\");\\n        uint ArtBlocksProjectID = 69420;\\n        // uint ArtBlocksProjectID = ArtBlocksCore(ParamsMint._ArtBlocksCore).nextProjectId();\\n        // IMinter(ParamsMint._ArtBlocksCore).addProject(ParamsMint._Name, ParamsMint._ArtistAddress, 0);\\n        // IMinter(ParamsMint._ArtBlocksCore).toggleProjectIsActive(ArtBlocksProjectID);\\n        uint MintPassProjectID = IMintPass(Params._FactoryMintPass).__InitMintPass(ParamsMintPass);\\n        uint MarketplaceSaleID = IMarketplace(Params._DutchMarketplace).__StartSale(ParamsSale, ParamsSaleInternal, RootsPriority, RootsAmounts, DiscountAmounts);\\n        uint LowerBound = MintPassProjectID * 1000000;\\n        uint Upperbound = LowerBound + ParamsMintPass._MaxSupply;\\n        uint LiveMintArtistID = ILiveMint(Params._LiveMint).__InitLiveMint(\\n            ILiveMint.Params(\\n                Params._FactoryMintPass, \\n                ParamsMint._ArtBlocksCore, \\n                address(0), \\n                ParamsMintPass._MaxSupply, \\n                MintPassProjectID,\\n                ArtBlocksProjectID,\\n                LowerBound,\\n                Upperbound\\n            )\\n        );\\n        uint LaunchpadRegistryIndex = ILaunchpadRegistry(Params._LaunchpadRegistry).__NewProject(ILaunchpadRegistry.Project(\\n            ParamsMint._Name,            // _Name\\n            true,                        // _Active\\n            true,                        // _ArtBlocks\\n            ArtBlocksProjectID,          // _ArtBlocksProjectID\\n            LiveMintArtistID,            // _LiveMintArtistID\\n            ParamsMintPass._MaxSupply,   // _MaxSupply\\n            ParamsMintPass._MintPacks,   // _MintPacks\\n            ParamsMintPass._ArtistIDs,   // _NumArtistIDs\\n            MarketplaceSaleID,           // _DutchMarketplaceSaleID\\n            \\\"ArtBlocks\\\",                 // _MetadataMintedWork\\n            ParamsMintPass._MetadataURI, // _MetadataMintPass\\n            Params._FactoryMintPass,     // _MintPassAddress\\n            ParamsMint._ArtBlocksCore    // _MintedWorkAddress\\n        ));\\n        emit ProjectInvoked(LaunchpadRegistryIndex);\\n    }\\n\\n    /**\\n     * @dev Starts A Sale And Optionally Instantiates New MintPass Factory Project\\n     */\\n    function InitSaleDutch (       \\n        IMintPass.Params memory ParamsMintPass,       // Mint Pass Parameters\\n        IMarketplace.Sale memory ParamsSale,          // Marketplace Parameters\\n        IMarketplace.State memory ParamsSaleInternal, // Marketplace Parameters Cont.\\n        bytes32[] calldata RootsPriority,             // Merkle Roots Eligibility\\n        bytes32[] calldata RootsAmounts,              // Merkle Root Amounts\\n        uint[] calldata DiscountAmounts               // Discount Amounts\\n    ) external onlyOperator {\\n        if(ParamsSaleInternal._NFT == Params._FactoryMintPass)\\n        {\\n            uint MintPassProjectID = IMintPass(Params._FactoryMintPass).__InitMintPass(ParamsMintPass);\\n            ParamsSale._ProjectIDMintPass = MintPassProjectID;\\n        }\\n        IMarketplace(Params._DutchMarketplace).__StartSale(ParamsSale, ParamsSaleInternal, RootsPriority, RootsAmounts, DiscountAmounts);\\n    }\\n\\n    /**\\n     * @dev Starts A Fixed Price Sale And Optionally Instantiates New MintPass Factory Project\\n     */\\n    function InitSaleFixedPrice(\\n        IMarketplace.FixedPriceSale memory ParamsSale, // FixedPriceSale\\n        IMintPass.Params memory ParamsMintPass         // Mint Pass Parameters\\n    ) external onlyOperator {\\n        if(ParamsSale._NFT == Params._FactoryMintPass)\\n        {\\n            uint MintPassProjectID = IMintPass(Params._FactoryMintPass).__InitMintPass(ParamsMintPass);\\n            ParamsSale._ProjectIDMintPass = MintPassProjectID;\\n        } \\n        IMarketplace(Params._BasicMarketplace).__StartSale(ParamsSale);\\n    }\\n\\n    /**\\n     * @dev Returns Next ProjectID From ArtBlocks Contract\\n     */\\n    function ViewNextABProjectID() public view returns ( uint ) { return ArtBlocksCore(Params._ArtBlocksCore).nextProjectId(); }\\n\\n    /**\\n     * @dev Returns Launchpad Registry Address\\n     */\\n    function ViewAddressLaunchpadRegistry() public view returns(address) { return Params._LaunchpadRegistry; }\\n\\n    /**\\n     * @dev Returns Marketplace Address\\n     */\\n    function ViewAddressMarketplace() public view returns ( address ) { return Params._DutchMarketplace; }\\n\\n    /**\\n     * @dev Returns LiveMint Address\\n     */\\n    function ViewAddressLiveMint() public view returns ( address ) { return Params._LiveMint; }\\n\\n    /**\\n     * @dev Returns Mint Pass Factory Address\\n     */\\n    function ViewAddressMintPassFactory() public view returns ( address ) { return Params._FactoryMintPass; }\\n\\n    /**\\n     * @dev Returns Owner Address\\n     */\\n    function ViewOwner() public view returns ( address ) { return Params._Owner; }\\n\\n    /**\\n     * @dev Changes The BaseURI For a Mint Pass Project\\n     * note: `MintPassProjectID` Is The Project ID From The MintPass Factory Contract\\n     */\\n    function _NewBaseURIMintPass(uint MintPassProjectID, string calldata BaseURI) external onlyAdmin \\n    {\\n        IMintPass(Params._FactoryMintPass).__NewBaseURI(MintPassProjectID, BaseURI);\\n        ILaunchpadRegistry(Params._LaunchpadRegistry).__NewMintPassURI(MintPassProjectID, BaseURI);\\n    }\\n\\n    /**\\n     * @dev Adds An Operator\\n     */\\n    function _OperatorAdd(address Wallet) external onlyAdmin { Operator[Wallet] = true; }\\n\\n    /**\\n     * @dev Removes An Operator\\n     */\\n    function _OperatorRemove(address Wallet) external onlyAdmin { Operator[Wallet] = false; }\\n\\n    /**\\n     * @dev Authorizes Contract\\n     */\\n    function __AuthorizeContract(address Contract, bool State) external onlyOwner { Whitelisted[Contract] = State; }\\n\\n    /**\\n     * @dev Adds An Admin\\n     */\\n    function __AdminAdd(address Wallet) external onlyOwner { Admin[Wallet] = true; }\\n\\n    /**\\n     * @dev Removes An Admin\\n     */\\n    function __AdminRemove(address Wallet) external onlyOwner { Admin[Wallet] = false; }\\n\\n    /**\\n     * @dev Toggles The Contract State\\n     */\\n    function __ActiveToggle() external onlyOwner { Params._Active = !Params._Active; }\\n    \\n    /**\\n     * @dev Changes ArtBlocks Core Address\\n     */\\n    function __ChangeArtBlocksCore(address NewAddress) external onlyOwner { Params._ArtBlocksCore = NewAddress; }\\n\\n    /**\\n     * @dev Changes Marketplace Address\\n     */\\n    function __ChangeMarketplace(address NewAddress) external onlyOwner { Params._DutchMarketplace = NewAddress; }\\n\\n    /**\\n     * @dev Changes LiveMint Address\\n     */\\n    function __ChangeLiveMint(address NewAddress) external onlyOwner { Params._LiveMint = NewAddress; }\\n\\n    /**\\n     * @dev Changes Mint Pass Factory Address\\n     */\\n    function __ChangeFactoryMintPass(address NewAddress) external onlyOwner { Params._FactoryMintPass = NewAddress; }\\n    \\n    /**\\n     * @dev Changes Minted Works Factory Address\\n     */\\n    function __ChangeFactoryMintedWorks(address NewAddress) external onlyOwner { Params._FactoryMintedWorks = NewAddress; }\\n\\n    /**\\n     * @dev Changes Basic Marketplace Address\\n     */\\n    function __ChangeBasicMarketplace(address NewAddress) external onlyOwner { Params._BasicMarketplace = NewAddress; }\\n\\n    /**\\n     * @dev Upgrades The Basic Marketplace's Active Launchpad Address\\n     */\\n    function __UpgradeBasicMarketplace(address NewAddress) external onlyOwner { ICustom(Params._BasicMarketplace)._____NewLaunchpadAddress(NewAddress); }\\n\\n    /**\\n     * @dev Upgrades The Marketplace's Active Launchpad Address\\n     */\\n    function __UpgradeDutchMarketplace(address NewAddress) external onlyOwner { ICustom(Params._DutchMarketplace)._____NewLaunchpadAddress(NewAddress); }\\n\\n    /**\\n     * @dev Upgrades The LiveMint's Active Launchpad Address\\n     */\\n    function __UpgradeLiveMint(address NewAddress) external onlyOwner { ICustom(Params._LiveMint)._____NewLaunchpadAddress(NewAddress); }\\n\\n    /**\\n     * @dev Upgrades The Minted Works Factory's Active Launchpad Address\\n     */\\n    function __UpgradeFactoryMintedWorks(address NewAddress) external onlyOwner { ICustom(Params._FactoryMintedWorks)._____NewLaunchpadAddress(NewAddress); }\\n\\n    /**\\n     * @dev Upgrades The Mint Pass Factory's Active Launchpad Address\\n     */\\n    function __UpgradeFactoryMintPass(address NewAddress) external onlyOwner { ICustom(Params._FactoryMintPass)._____NewLaunchpadAddress(NewAddress); }\\n\\n    /**\\n     * @dev Upgrades The Launchpad Registry's Active Launchpad Address\\n     */\\n    function __UpgradeLaunchpadRegistry(address NewAddress) external onlyOwner { ICustom(Params._LaunchpadRegistry)._____NewLaunchpadAddress(NewAddress); }\\n\\n    /**\\n     * @dev Initiates Upgrade Of The Launchpad\\n     */\\n    function __UpgradeAll(address NewLaunchpadAddress) external onlyOwner\\n    {\\n        ICustom(Params._DutchMarketplace)._____NewLaunchpadAddress(NewLaunchpadAddress);\\n        ICustom(Params._LiveMint)._____NewLaunchpadAddress(NewLaunchpadAddress);\\n        ICustom(Params._FactoryMintedWorks)._____NewLaunchpadAddress(NewLaunchpadAddress);\\n        ICustom(Params._FactoryMintPass)._____NewLaunchpadAddress(NewLaunchpadAddress);\\n        ICustom(Params._LaunchpadRegistry)._____NewLaunchpadAddress(NewLaunchpadAddress);\\n    }\\n\\n    /**\\n     * @dev Instantiates A New State\\n     */\\n    function __NewState(StateParameters memory _State) external onlyOwner { Params = _State; }\\n\\n    /**\\n     * @dev Executes Arbitrary Transaction(s)\\n     */\\n    function __InitTransaction(address[] memory Targets, uint[] memory Values, bytes[] memory Datas) external onlyOwner\\n    {\\n        for (uint x; x < Targets.length; x++) \\n        {\\n            (bool success,) = Targets[x].call{value:(Values[x])}(Datas[x]);\\n            require(success, \\\"i have failed u anakin\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers Ownership Of The Contract\\n     */\\n    function __TransferOwnership(address NewOwner) external onlyOwner { Params._Owner = NewOwner; }\\n\\n    /**\\n     * @dev Operator Access Control\\n     */\\n    modifier onlyOperator\\n    {\\n        if(Operator[msg.sender])\\n        {\\n            require(OperatorCooldown[msg.sender] >= block.timestamp, \\\"Launchpad | onlyOperator | Operator Cooldown Not Reached\\\");\\n            OperatorCooldown[msg.sender] = block.timestamp + 24 hours;\\n        }\\n        else { require(Admin[msg.sender] || msg.sender == Params._Owner, \\\"Launchpad | onlyOperator | `msg.sender` Is Not Admin Or Owner Or Operator\\\"); }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Admin Access Control\\n     */\\n    modifier onlyAdmin\\n    {\\n        require(Admin[msg.sender] || msg.sender == Params._Owner, \\\"Launchpad | onlyAdmin | `msg.sender` Is Not Admin Or Owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev onlyOwner Access Control\\n     */\\n    modifier onlyOwner\\n    {\\n        require(msg.sender == Params._Owner, \\\"Launchpad | onlyOwner | `msg.sender` Is Not Owner\\\");\\n        _;\\n    }\\n}\\n\\n/**\\n * @dev Interface For The Live Mint Smart Contract\\n */\\ninterface ILiveMint\\n{\\n    struct Params\\n    {\\n        address _MintPass;        // [0] -> _MintPass\\n        address _Minter;          // [1] -> _Minter\\n        address _PolyptychSource; // [2] -> _PolyptychSource\\n        uint _MaxSupply;          // [3] -> _MaxSupply\\n        uint _MintPassProjectID;  // [4] -> _MintPassProjectID\\n        uint _ArtBlocksProjectID; // [5] -> _ArtBlocksProjectID \\n        uint _PolyStart;          // [6] -> _PolyStart\\n        uint _PolyEnd;            // [7] -> _PolyEnd\\n    }\\n\\n    /**\\n     * @dev Initializes Live Mint & Returns LiveMintProjectID\\n     */\\n    function __InitLiveMint ( Params memory ) external returns ( uint );\\n}\\n\\n/**\\n * @dev Interface For The Marketplace Smart Contract\\n */\\ninterface IMarketplace \\n{ \\n    struct Sale\\n    {\\n        string _Name;                     // [0] -> _Name\\n        uint _ProjectIDMintPass;          // [1] -> _ProjectIDMintPass\\n        uint _ProjectIDArtBlocks;         // [2] -> _ProjectIDArtBlocks\\n        uint _PriceStart;                 // [3] -> _PriceStart\\n        uint _PriceEnd;                   // [4] -> _PriceEnd\\n        uint _MaxAmtPerPurchase;          // [5] -> _MaxAmtPerPurchase\\n        uint _MaximumAvailableForSale;    // [6] -> _MaximumAvailableForSale\\n        uint _StartingBlockUnixTimestamp; // [7] -> _StartingBlockUnixTimestamp\\n        uint _SecondsBetweenPriceDecay;   // [8] -> _SecondsBetweenPriceDecay\\n        uint _SaleStrip;                  // [9] -> _SaleStrip note: For Traditional MintPack transferFrom() Sales \\n    }\\n\\n    struct State\\n    {\\n        address _NFT;           // [0] -> _NFT\\n        address _Operator;      // [1] _Operator (Wallet That NFT Is Pulling From)\\n        uint _CurrentIndex;     // [2] _CurrentIndex (If Simple Sale Type, This Is The Next Token Index To Iterate Upon)\\n        uint _Type;             // [3] _SaleType (0 = Simple, 1 = TransferFrom, 2 = PurchaseTo, 3 = MintPack)\\n        bool _ActivePublic;     // [4] -> _ActivePublic\\n        bool _ActiveBrightList; // [5] -> _ActiveBrightList \\n        bool _Discount;         // [6] -> _Discount\\n        bool _ActiveRespend;    // [7] -> _ActiveRespend\\n    }\\n\\n    struct FixedPriceSale\\n    {\\n        uint _Price;             // [0] -> _Price\\n        uint _ProjectIDMintPass; // [1] -> _ProjectIDMintPass\\n        uint _Type;              // [2] -> _Type\\n        uint _ABProjectID;       // [3] -> _ABProjectID\\n        uint _AmountSold;        // [4] -> _AmountSold\\n        uint _AmountForSale;     // [5] -> _AmountForSale\\n        address _NFT;            // [6] -> _NFT\\n        bytes32 _Root;           // [7] -> _Root\\n    }\\n\\n    /**\\n     * @dev Starts A Sale On The BasicMarketplace Contract\\n     */\\n    function __StartSale(FixedPriceSale memory) external;\\n\\n    /**\\n     * @dev Initiates A New Sale On The DutchMarketplace Contract\\n     * Returns MarketplaceSaleID\\n     */\\n    function __StartSale (\\n        Sale memory _Sale, \\n        State memory _State, \\n        bytes32[] calldata RootsPrioriy, \\n        bytes32[] calldata RootsAmounts, \\n        uint[] calldata DiscountAmounts\\n    ) external returns ( uint );\\n}\\n\\n/**\\n * @dev Interface For Mint Pass Factory\\n */\\ninterface IMintPass\\n{\\n    struct Params\\n    {\\n        uint _MaxSupply;\\n        uint _MintPacks;\\n        uint _ArtistIDs;\\n        uint _ArtBlocksProjectID;\\n        uint _Reserve;\\n        string _MetadataURI;\\n    }\\n\\n    /**\\n     * @dev Creates A New Mint Pass Project & Returns MintPassProjectID\\n     */\\n    function __InitMintPass ( Params memory ) external returns ( uint _MintPassID );\\n\\n    /**\\n     * @dev Updates The Base URI For A Mint Pass Project\\n     */\\n    function __NewBaseURI ( uint MintPassProjectID, string calldata BaseURI ) external;\\n}\\n\\n/**\\n * @dev Interface For Minted Works, Either ArtBlocks or Non-ArtBlocks\\n */\\ninterface IMinter \\n{ \\n    /**\\n     * @dev Paramters For Custom Minted Work\\n     */\\n    struct ParamsCustom\\n    {\\n        string _Name;\\n        string _Symbol;\\n        string _MetadataMintedWork;\\n    }\\n\\n    /**\\n     * @dev Paramters For Minted Work\\n     */\\n    struct ParamsArtBlocks\\n    {\\n        string _Name;\\n        address _ArtistAddress;\\n        address _ArtBlocksCore;\\n    }\\n\\n    /**\\n     * @dev ArtBlocks Add Project\\n     */\\n    function addProject ( string calldata Name, address ArtistAddress, uint PricePerTokenInWei ) external;\\n\\n    /**\\n     * @dev ArtBlocks Toggle Project Active\\n     */\\n    function toggleProjectIsActive( uint ProjectID ) external;\\n\\n    /**\\n     * @dev Custom Add Project\\n     */\\n    function __addProject( ParamsCustom memory ) external;\\n\\n    /**\\n     * @dev Updates Project Artist Address\\n     */\\n    function updateProjectArtistAddress ( uint ProjectID, address ArtistAddress ) external;\\n\\n    /**\\n     * @dev Updates Project Currency Info\\n     */\\n    function updateProjectCurrencyInfo ( uint ProjectID, string memory CurrencySymbol, address ERC20 ) external;\\n}\\n\\n/**\\n * @dev Interface For The Launchpad Registry\\n */\\ninterface ILaunchpadRegistry\\n{\\n    struct Project\\n    {\\n        string _Name;\\n        bool _Active;\\n        bool _ArtBlocks;\\n        uint _ArtBlocksProjectID;\\n        uint _LiveMintArtistID;\\n        uint _MaxSupply;\\n        uint _MintPacks;\\n        uint _NumArtistIDs;\\n        uint _DutchMarketplaceSaleID;\\n        string _MetadataMintPass;\\n        string _MetadataMintedWork;\\n        address _MintPassAddress;\\n        address _MintedWorkAddress;\\n    }\\n\\n    /**\\n     * @dev Adds A New Project To The Launchpad Registry\\n     */\\n    function __NewProject ( Project memory ) external returns (uint);\\n\\n    /**\\n     * @dev Updates The Mint Pass URI For A Project \\n     */\\n    function __NewMintPassURI ( uint MintPassProjectID, string calldata URI ) external;\\n    \\n    /**\\n     * @dev Returns ArtBlocksProjectID Of LaunchpadProjectID\\n     */\\n    function ViewArtBlocksProjectID ( uint ProjectID ) external view returns ( uint );\\n}\\n\\n/**\\n * @dev Interface To Upgrade The Launchpad Contract\\n */\\ninterface ICustom { function _____NewLaunchpadAddress ( address NewAddress ) external; }\\n\\n/**\\n * @dev Abstract Contract To Recieve The Next ProjectID From ArtBlocks\\n */\\nabstract contract ArtBlocksCore { uint public nextProjectId; }\"\r\n    },\r\n    \"contracts/LaunchpadEnabled.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/**\\n * @dev @brougkr\\n */\\npragma solidity 0.8.19;\\nabstract contract LaunchpadEnabled\\n{\\n    /**\\n     * @dev The Launchpad Address\\n     */\\n    address public _LAUNCHPAD = 0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700;\\n\\n    /**\\n     * @dev Updates The Launchpad Address From Launchpad (batch upgrade)\\n     */ \\n    function _____NewLaunchpadAddress(address NewAddress) external onlyLaunchpad { _LAUNCHPAD = NewAddress; }\\n\\n    /**\\n     * @dev Access Control Needed For A Contract To Be Able To Use The Launchpad\\n    */\\n    modifier onlyLaunchpad()\\n    {\\n        require(_LAUNCHPAD == msg.sender, \\\"onlyLaunchpad: Caller Is Not Launchpad\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/LaunchpadRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/** \\n * @dev @brougkr\\n * The Launchpad Registry Contains Information About All Projects That Have Been Created Through The Launchpad Contract\\n */\\npragma solidity 0.8.19;\\ncontract LaunchpadRegistry\\n{   \\n    struct Project\\n    {\\n        string _Name;\\n        bool _Active;\\n        bool _ArtBlocks;\\n        uint _ArtBlocksProjectID;\\n        uint _LiveMintArtistID;\\n        uint _MaxSupply;\\n        uint _MintPacks;\\n        uint _NumArtistIDs;\\n        uint _MarketplaceSaleID;\\n        string _MetadataMintedWork;\\n        string _MetadataMintPass;\\n        address _MintPassAddress;\\n        address _MintedWorkAddress;\\n    }\\n\\n    uint public UniqueProjectsInvoked;\\n    bytes32 private constant _AUTHORIZED = keccak256(\\\"AUTHORIZED\\\");\\n    bytes32 private constant _ADMIN = keccak256(\\\"ADMIN\\\");\\n    bytes32 private constant _OWNER = keccak256(\\\"OWNER\\\");\\n    mapping(uint=>Project) public Projects;\\n    mapping(address=>bytes32) public Role;\\n\\n    event NewProjectInvoked(uint ProjectID);\\n    event OwnershipTransferred(address OldOwner, address NewOwner);\\n\\n    constructor() \\n    { \\n        Role[0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937] = _ADMIN; // brightmoments.eth\\n        Role[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = _ADMIN; // phil.brightmoments.eth\\n        Role[0x38E27a59d3cffB945aC8d41b7c398618354c08F6] = _ADMIN; // gitpancake.brightmoments.eth\\n        Role[msg.sender] = _OWNER;\\n    }\\n\\n    /**\\n     * @dev Initializes A New Project Into The Launchpad Registry\\n     */\\n    function __NewProject(Project memory _Project) external onlyAuthorized returns (uint)\\n    {\\n        Projects[UniqueProjectsInvoked] = _Project;\\n        emit NewProjectInvoked(UniqueProjectsInvoked);\\n        UniqueProjectsInvoked++;\\n        return (UniqueProjectsInvoked - 1);\\n    }\\n\\n    /**\\n     * @dev Updates The BaseURI For A Project\\n     */\\n    function __NewMintPassURI(uint ProjectID, string memory URI) external onlyAuthorized { Projects[ProjectID]._MetadataMintedWork = URI; }\\n\\n    /**\\n     * @dev Updates The Minted Work Address\\n     */\\n    function ___NewMintedWorkURI(uint ProjectID, string calldata URI) external onlyAdmin { Projects[ProjectID]._MetadataMintedWork = URI; }\\n\\n    /**\\n     * @dev Updates The Minted Pass Metadata URI\\n     */\\n    function ___NewMintPassURI(uint ProjectID, string calldata URI) external onlyAdmin { Projects[ProjectID]._MetadataMintPass = URI; }\\n\\n    /**\\n     * @dev Adds An Admin\\n     */\\n    function ____AdminAdd(address Wallet) external onlyOwner { Role[Wallet] = _ADMIN; }\\n\\n    /**\\n     * @dev Removes An Admin\\n     */\\n    function ____AdminRemove(address Wallet) external onlyOwner { Role[Wallet] = 0x0; }\\n\\n    /**\\n     * @dev Authorizes A Contract Address\\n     */\\n    function ____AuthorizeContract(address ContractAddress) external onlyOwner { Role[ContractAddress] = _AUTHORIZED; }\\n\\n    /**\\n     * @dev Deauthorizes A Contract Address\\n     */\\n    function ____DeauthorizeContract(address ContractAddress) external onlyOwner { Role[ContractAddress] = 0x0; }\\n\\n    /**\\n     * @dev Transfers Ownership Of The Contract\\n     */\\n    function ____TransferOwnership(address NewOwner) external onlyOwner \\n    { \\n        Role[msg.sender] = 0x0;\\n        Role[NewOwner] = _OWNER; \\n        emit OwnershipTransferred(msg.sender, NewOwner);\\n    }\\n\\n    /**\\n     * @dev Views A Project\\n     */\\n    function ViewProject(uint ProjectID) public view returns(Project memory) { return Projects[ProjectID]; }\\n\\n    /**\\n     * @dev Returns An Array Of Projects\\n     */\\n    function ViewProjects(uint[] calldata Indexes) public view returns(Project[] memory) \\n    { \\n        Project[] memory _Projects = new Project[](Indexes.length);\\n        for(uint x; x < Indexes.length; x++) { _Projects[x] = Projects[Indexes[x]]; }\\n        return _Projects;\\n    }\\n\\n    /**\\n     * @dev Views Projects Within A Range (StartingIndex, EndingIndex) Inclusive\\n     */\\n    function ViewProjectsInRange(uint StartingIndex, uint EndingIndex) public view returns(Project[] memory) \\n    { \\n        Project[] memory _Projects = new Project[](EndingIndex - StartingIndex);\\n        for(uint x; x < EndingIndex - StartingIndex; x++) { _Projects[x] = Projects[StartingIndex + x]; }\\n        return _Projects;\\n    }\\n\\n    /**\\n     * @dev Returns Active Projects\\n     */\\n    function ViewActiveProjects() public view returns(Project[] memory) \\n    { \\n        uint Found;\\n        uint[] memory ProjectIDs = new uint[](UniqueProjectsInvoked);\\n        for(uint x; x < UniqueProjectsInvoked; x++)\\n        {\\n            if(Projects[x]._Active)\\n            {\\n                ProjectIDs[Found] = x;\\n                Found++;\\n            }\\n        }\\n        Project[] memory _ProjectIDs = new Project[](Found);\\n        for(uint y; y < Found; y++)\\n        {\\n            _ProjectIDs[y] = Projects[ProjectIDs[y]];\\n        }\\n        return _ProjectIDs;\\n    }\\n\\n    /**\\n     * @dev Returns The Associated ArtBlocks ProjectID Of A Launchpad Project (if applicable)\\n     * note: Returns Max Integer If The Launchpad ProjectID Is Not Associated With An ArtBlocks Project\\n     */\\n    function ViewArtBlocksProjectID(uint LaunchpadProjectID) public view returns(uint) \\n    { \\n        return Projects[LaunchpadProjectID]._ArtBlocksProjectID; \\n    }\\n\\n    /**\\n     * @dev Returns The Minted Work BaseURI For A Project\\n     */\\n    function ViewBaseURIMintedWork(uint ProjectID) public view returns(string memory) \\n    { \\n        return Projects[ProjectID]._MetadataMintedWork; \\n    }\\n    \\n    /**\\n     * @dev Returns The Mint Pass BaseURI For A Project\\n     */\\n    function ViewBaseURIMintPass(uint ProjectID) public view returns(string memory) \\n    { \\n        return Projects[ProjectID]._MetadataMintPass; \\n    }\\n\\n    /**\\n     * @dev Admin Access Modifier\\n     */\\n    modifier onlyAuthorized\\n    {\\n        require(Role[msg.sender] == _AUTHORIZED, \\\"Registry: `msg.sender` Is Not Authorized\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Admin Access Modifier\\n     */\\n    modifier onlyAdmin\\n    {\\n        require(Role[msg.sender] == _ADMIN || Role[msg.sender] == _OWNER, \\\"Registry: `msg.sender` Is Not Admin Or Owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Owner Access Modifier\\n     */\\n    modifier onlyOwner\\n    {\\n        require(Role[msg.sender] == _OWNER, \\\"Registry: `msg.sender` Is Not Owner\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/LiveMintBuenosAires.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/**\\n * @dev: @brougkr\\n */\\npragma solidity 0.8.19;\\nimport { IERC721 } from \\\"@openzeppelin/contracts/interfaces/IERC721.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { ReentrancyGuard } from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport { MerkleProof } from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport { IMinter } from \\\"./IMinter.sol\\\";\\nimport { IMP } from \\\"./IMP.sol\\\";\\nimport { IGT } from \\\"./IGT.sol\\\";\\nimport { LaunchpadEnabled } from \\\"./LaunchpadEnabled.sol\\\";\\ncontract LiveMintBuenosAires is Ownable, ReentrancyGuard, LaunchpadEnabled\\n{  \\n    struct City\\n    {\\n        string _Name;         // _Name\\n        uint _QRCurrentIndex; // _QRCurrentIndex (Should be Always Be 333 + (333 * (City# % 6))\\n        address _ERC20;       // _ERC20  \\n        bytes32 _Root;        // _Root\\n    }\\n\\n    struct Artist\\n    {\\n        address _MintPass;        // _MintPass\\n        address _Minter;          // _Minter\\n        address _PolyptychSource; // _PolyptychSource\\n        uint _MaxSupply;          // _MaxSupply\\n        uint _MintPassProjectID;  // _MintPassProjectID\\n        uint _ArtBlocksProjectID; // _ArtBlocksProjectID \\n        uint _PolyStart;          // _PolyStart\\n        uint _PolyEnd;            // _PolyEnd\\n    }\\n\\n    struct User\\n    {\\n        bool _Eligible;   // _Eligible\\n        uint _Allocation; // _Allocation\\n    }\\n\\n    /*-------------------*/\\n    /*  STATE VARIABLES  */\\n    /*-------------------*/\\n\\n    bytes32 private constant _AUTHORIZED = keccak256(\\\"AUTHORIZED\\\");                        // Authorized Role\\n    bytes32 private constant _MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");                      // Minter Role\\n    address private constant _DN = 0x00000000000076A84feF008CDAbe6409d2FE638B;             // delegate.cash Delegation Registry\\n    address private constant _GOLDEN_TOKEN = 0x985e1932FFd2aA4bC9cE611DFe12816A248cD2cE;   // Golden Token Address\\n    address private constant _CITIZEN_MINTER = 0xDd06d8483868Cd0C5E69C24eEaA2A5F2bEaFd42b; // ArtBlocks Minter Contract\\n    address private constant _BRT_MULTISIG = 0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937;   // BRT Multisig\\n    address public _Pindar;                                                                // Pindar Van Arman's Custom Minter Contract\\n    uint public _CurrentCityIndex = 6;                                                     // Current City Index\\n    uint public _UniqueArtistsInvoked;                                                     // Unique Artists Invoked\\n\\n    /*-------------------*/\\n    /*     MAPPINGS      */\\n    /*-------------------*/\\n    \\n    mapping(uint => Artist) public Artists;                              // [ArtistID] => Artist\\n    mapping(uint => City) public Cities;                                 // [CityIndex] => City Struct\\n    mapping(uint => mapping(address => bool)) public _QRRedeemed;        // [CityIndex][Wallet] => If User Has Redeemed QR\\n    mapping(uint => mapping(address => uint)) public _QRAllocation;      // [CityIndex][Wallet] => Wallet's QR Code Allocation\\n    mapping(uint => mapping(uint => address)) public _BrightListCitizen; // [CityIndex][TicketID] => Address Of CryptoCitizen Minting Recipient \\n    mapping(uint => mapping(uint => address)) public _BrightListArtist;  // [ArtistID][TicketID] => Address Of Artist NFT Recipient\\n    mapping(uint => mapping(uint => string)) public _DataArtists;        // [ArtistID][TicketID] => Artist Data\\n    mapping(uint => mapping(uint => string)) public _DataCitizens;       // [CityIndex][TicketID] => Data For Golden Token Checkins\\n    mapping(uint => mapping(uint => uint)) public _MintedTokenIDCitizen; // [CityIndex][TicketID] => MintedTokenID\\n    mapping(uint => mapping(uint => uint)) public _MintedTokenIDArtist;  // [ArtistID][TicketID] => MintedTokenID\\n    mapping(uint => mapping(uint => bool)) public _MintedArtist;         // [ArtistID][TicketID] => If Minted\\n    mapping(uint => mapping(uint => bool)) public _MintedCitizen;        // [CityIndex][TicketID] => If Golden Ticket ID Has Minted Or Not\\n    mapping(uint => mapping(uint => uint)) public _ArtBlocksProjectID;   // [ArtistID][TicketID] => ArtBlocksProjectID\\n    mapping(address => bytes32) public Role;                             // [Wallet] => BRT Minter Role\\n    mapping(uint => uint) public AmountRemaining;                        // [ArtistID] => Mints Remaining\\n\\n    /*-------------------*/\\n    /*      EVENTS       */\\n    /*-------------------*/\\n\\n    /**\\n     * @dev Emitted When `Redeemer` IRL-mints CryptoCitizen Corresponding To Their Redeemed `TicketID`.\\n     **/\\n    event LiveMintComplete(address Redeemer, uint TicketID, uint TokenID, string Data);\\n\\n    /**\\n     * @dev Emitted When `Redeemer` IRL-mints A Artist NFT Corresponding To Their Redeemed `TicketID`.\\n     */\\n    event LiveMintCompleteArtist(address Recipient, uint ArtistID, uint TicketID, uint MintedWorkTokenID);\\n\\n    /**\\n     * @dev Emitted When `Redeemer` Redeems Golden Token Corresponding To `TicketID` \\n     **/\\n    event QRRedeemed(address Redeemer, uint TicketID, string Data, string Type);\\n\\n    /**\\n     * @dev Emitted When A Contract Is Authorized\\n     */\\n    event AuthorizedContract(address NewAddress);\\n\\n    /**\\n     * @dev Emitted When A Contract Is Deauthorized\\n     */\\n    event DeauthorizedContract(address NewAddress);\\n\\n    /*-------------------*/\\n    /*    CONSTRUCTOR    */\\n    /*-------------------*/\\n\\n    constructor()\\n    { \\n        Cities[0]._Name = \\\"CryptoGalacticans\\\";  \\n        Cities[1]._Name = \\\"CryptoVenetians\\\";    \\n        Cities[2]._Name = \\\"CryptoNewYorkers\\\";   \\n        Cities[3]._Name = \\\"CryptoBerliners\\\";    \\n        Cities[4]._Name = \\\"CryptoLondoners\\\";    \\n        Cities[5]._Name = \\\"CryptoMexas\\\";        \\n        Cities[6]._Name = \\\"CryptoTokyites\\\";     \\n        Cities[6]._QRCurrentIndex = 333;\\n        Cities[6]._Root = 0x255b8b82ee0d1823cdc3cf859efacfee1111414bacab649a7e8bea9cd48a0ed3;\\n        Cities[7]._Name = \\\"CryptoCitizen City #8\\\"; \\n        Cities[7]._QRCurrentIndex = 666;\\n        Cities[8]._Name = \\\"CryptoCitizen City #9\\\";\\n        Cities[8] ._QRCurrentIndex = 999;\\n        Cities[9]._Name = \\\"CryptoCitizen City #10\\\";\\n        Cities[10]._QRCurrentIndex = 1332; \\n        Role[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = _AUTHORIZED;  // `operator.brightmoments.eth`\\n        Role[0x1A0a3E3AE390a0710f8A6d00587082273eA8F6C9] = _MINTER_ROLE; // BRT Minter #1\\n        Role[0x4d8013b0c264034CBf22De9DF33e22f58D52F207] = _MINTER_ROLE; // BRT Minter #2\\n        Role[0x4D9A8CF2fE52b8D49C7F7EAA87b2886c2bCB4160] = _MINTER_ROLE; // BRT Minter #3\\n        Role[0x124fd966A0D83aA020D3C54AE2c9f4800b46F460] = _MINTER_ROLE; // BRT Minter #4\\n        Role[0x100469feA90Ac1Fe1073E1B2b5c020A8413635c4] = _MINTER_ROLE; // BRT Minter #5\\n        Role[0x756De4236373fd17652b377315954ca327412bBA] = _MINTER_ROLE; // BRT Minter #6\\n        Role[0xc5Dfba6ef7803665C1BDE478B51Bd7eB257A2Cb9] = _MINTER_ROLE; // BRT Minter #7\\n        Role[0xFBF32b29Bcf8fEe32d43a4Bfd3e7249daec457C0] = _MINTER_ROLE; // BRT Minter #8\\n        Role[0xF2A15A83DEE7f03C70936449037d65a1C100FF27] = _MINTER_ROLE; // BRT Minter #9\\n        Role[0x1D2BAB965a4bB72f177Cd641C7BacF3d8257230D] = _MINTER_ROLE; // BRT Minter #10\\n        Role[0x2e51E8b950D72BDf003b58E357C2BA28FB77c7fB] = _MINTER_ROLE; // BRT Minter #11\\n        Role[0x8a7186dECb91Da854090be8226222eA42c5eeCb6] = _MINTER_ROLE; // BRT Minter #12\\n    }\\n\\n    /*---------------------*/\\n    /*    QR REDEMPTION    */\\n    /*---------------------*/\\n\\n    /**\\n     * @dev Redeems Spot For IRL Minting\\n     */\\n    function RedeemQR(string[] calldata Data, string[] calldata Type, bytes32[] calldata Proof, address Vault, uint Amount) external nonReentrant \\n    {        \\n        address Recipient = msg.sender;\\n        if(Vault != address(0)) { if(IDelegationRegistry(_DN).checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } } \\n        require(readQREligibility(Recipient, Proof), \\\"LiveMint: User Is Not Eligible To Redeem QR\\\");\\n        if(_QRAllocation[_CurrentCityIndex][Recipient] == 0) // User Is Able To Redeem Explicitly 1 QR Code\\n        {\\n            require(!_QRRedeemed[_CurrentCityIndex][Recipient], \\\"LiveMint: User Has Already Redeemed\\\");\\n            _DataCitizens[_CurrentCityIndex][Cities[_CurrentCityIndex]._QRCurrentIndex] = Data[0];\\n            _BrightListCitizen[_CurrentCityIndex][Cities[_CurrentCityIndex]._QRCurrentIndex] = Recipient;\\n            emit QRRedeemed(Recipient, Cities[_CurrentCityIndex]._QRCurrentIndex, Data[0], Type[0]);\\n            Cities[_CurrentCityIndex]._QRCurrentIndex++; \\n        }\\n        else // User Is Able To Redeem More Than 1 QR Code Because Their QRAllocation > 0\\n        {\\n            require(Amount <= _QRAllocation[_CurrentCityIndex][Recipient], \\\"LiveMint: Amount Must Be Less Than Or Equal To QRAllocation\\\");\\n            uint _CurrentQR = Cities[_CurrentCityIndex]._QRCurrentIndex;\\n            uint _Limit = Amount + _CurrentQR;\\n            uint _Counter;\\n            _QRAllocation[_CurrentCityIndex][Recipient] -= Amount;\\n            Cities[_CurrentCityIndex]._QRCurrentIndex = _Limit;\\n            for(_CurrentQR; _CurrentQR < _Limit; _CurrentQR++)\\n            {\\n                _DataCitizens[_CurrentCityIndex][_CurrentQR] = Data[_Counter];\\n                _BrightListCitizen[_CurrentCityIndex][_CurrentQR] = Recipient;\\n                emit QRRedeemed(Recipient, _CurrentQR, Data[_Counter], Type[_Counter]);\\n                _Counter++;\\n            }\\n        }\\n        _QRRedeemed[_CurrentCityIndex][Recipient] = true;\\n    }\\n\\n    /*--------------------*/\\n    /*    LIVE MINTING    */\\n    /*--------------------*/\\n\\n    /**\\n     * @dev Batch Mints Verified Users On The Brightlist CryptoCitizens\\n     * note: { For CryptoCitizen Cities }\\n     */\\n    function _LiveMintCitizen(uint[] calldata TicketIDs) external onlyMinter\\n    {\\n        address Recipient;\\n        uint MintedWorkTokenID;\\n        for(uint TicketID; TicketID < TicketIDs.length; TicketID++)\\n        {\\n            require(!_MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]], \\\"LiveMint: Golden Token Already Minted\\\");\\n            if(_BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketID]] != address(0))\\n            {\\n                Recipient = _BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketID]];\\n            }\\n            else if (TicketIDs[TicketID] <= 333) { Recipient = IGT(_GOLDEN_TOKEN)._LiveMintBurn(TicketIDs[TicketID]); }\\n            else { revert(\\\"LiveMint: Invalid TicketID\\\"); }\\n            require(Recipient != address(0), \\\"LiveMint: Invalid Recipient\\\");\\n            _MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]] = true;\\n            MintedWorkTokenID = IMinter(_CITIZEN_MINTER).purchaseTo(Recipient, _CurrentCityIndex);\\n            _MintedTokenIDCitizen[_CurrentCityIndex][TicketIDs[TicketID]] = MintedWorkTokenID;\\n            emit LiveMintComplete(Recipient, TicketIDs[TicketID], MintedWorkTokenID, _DataCitizens[_CurrentCityIndex][TicketIDs[TicketID]]); \\n        }\\n    }\\n\\n    /**\\n     * @dev Burns Artist Mint Pass In Exchange For The Minted Work\\n     * note: { For Instances Where Multiple Artists Share The Same Mint Pass & Return (Recipient, ArtBlocksProjectID) }\\n     */\\n    function _LiveMintArtist(uint ArtistID, uint[] calldata TicketIDs) external onlyMinter\\n    {\\n        address Recipient;\\n        address MintPass = Artists[ArtistID]._MintPass;\\n        address Minter = Artists[ArtistID]._Minter;\\n        uint ArtBlocksProjectID;\\n        uint MintedWorkTokenID;\\n        uint TicketID;\\n        require(AmountRemaining[ArtistID] > 0, \\\"LiveMint: ArtistID Mint Limit Reached\\\");\\n        require(TicketIDs.length <= AmountRemaining[ArtistID], \\\"LiveMint: TicketID Length Exceeds ArtistID Mint Limit\\\");\\n        AmountRemaining[ArtistID] = AmountRemaining[ArtistID] - TicketIDs.length;\\n        for(uint x; x < TicketIDs.length; x++)\\n        {\\n            TicketID = TicketIDs[x];\\n            require(!_MintedArtist[ArtistID][TicketID], \\\"LiveMint: Artist Mint Pass Already Minted\\\");\\n            _MintedArtist[ArtistID][TicketID] = true;\\n            (Recipient, ArtBlocksProjectID) = IMP(MintPass)._LiveMintBurn(TicketID);\\n            if(ArtBlocksProjectID == 100) { MintedWorkTokenID = IMinter(_Pindar).purchaseTo(Recipient); } // Pindar Custom Contract \\n            else { MintedWorkTokenID = IMinter(Minter).purchaseTo(Recipient, ArtBlocksProjectID); } // Pre-Defined Minter Contract\\n            _MintedTokenIDArtist[ArtistID][TicketID] = MintedWorkTokenID;\\n            emit LiveMintCompleteArtist(Recipient, ArtistID, TicketID, MintedWorkTokenID);\\n        }\\n    }\\n\\n    /**\\n     * @dev Burns Artist Mint Pass In Exchange For The Minted Work\\n     * note: { For Instances Where Multiple Artists Share The Same Mint Pass & Return (Recipient, ArtBlocksProjectID) }\\n     */\\n    function _LiveMintArtistBatch(uint[] calldata ArtistIDs, uint[][] calldata TicketIDs) external onlyMinter\\n    {\\n        address Recipient;\\n        address MintPass;\\n        address Minter;\\n        uint ArtBlocksProjectID;\\n        uint MintedWorkTokenID;\\n        uint TicketID;\\n        uint ActiveArtistID;\\n        for(uint ArtistIDIndex; ArtistIDIndex < ArtistIDs.length; ArtistIDIndex++)\\n        {\\n            ActiveArtistID = ArtistIDs[ArtistIDIndex];\\n            MintPass = Artists[ActiveArtistID]._MintPass;\\n            Minter = Artists[ActiveArtistID]._Minter;\\n            for(uint TicketIDIndex; TicketIDIndex < TicketIDs[ArtistIDIndex].length; TicketIDIndex++)\\n            {\\n                TicketID = TicketIDs[ArtistIDIndex][TicketIDIndex];\\n                require(!_MintedArtist[ActiveArtistID][TicketID], \\\"LiveMint: Artist Mint Pass Already Minted\\\");\\n                _MintedArtist[ActiveArtistID][TicketID] = true;\\n                (Recipient, ArtBlocksProjectID) = IMP(MintPass)._LiveMintBurn(TicketID);\\n                if(ArtBlocksProjectID == 100) { MintedWorkTokenID = IMinter(_Pindar).purchaseTo(Recipient); }\\n                else { MintedWorkTokenID = IMinter(Minter).purchaseTo(Recipient, ArtBlocksProjectID); }\\n                _MintedTokenIDArtist[ActiveArtistID][TicketID] = MintedWorkTokenID;\\n                emit LiveMintCompleteArtist(Recipient, ActiveArtistID, TicketID, MintedWorkTokenID);\\n            }\\n        }\\n    }\\n\\n    /*-------------------*/\\n    /*  OWNER FUNCTIONS  */\\n    /*-------------------*/\\n\\n    /**\\n     * @dev Grants Address BRT Minter Role\\n     **/\\n    function __AddMinter(address Minter) external onlyOwner { Role[Minter] = _MINTER_ROLE; }\\n    \\n    /**\\n     * @dev Deactivates Address From BRT Minter Role\\n     **/\\n    function __RemoveMinter(address Minter) external onlyOwner { Role[Minter] = 0x0; }\\n\\n    /**\\n     * @dev Changes Mint Pass Address For Artist LiveMints\\n     */\\n    function __ChangeMintPass(uint ProjectID, address Contract) external onlyOwner { Artists[ProjectID]._MintPass = Contract; }\\n\\n    /**\\n     * @dev Changes Merkle Root For Citizen LiveMints\\n     */\\n    function __ChangeRootCitizen(bytes32 NewRoot) external onlyOwner { Cities[_CurrentCityIndex]._Root = NewRoot; }\\n\\n    /**\\n     * @dev Overwrites QR Allocation\\n     */\\n    function __QRAllocationsOverwrite(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner\\n    {\\n        require(Addresses.length == Amounts.length, \\\"LiveMint: Input Arrays Must Match\\\");\\n        for(uint x; x < Addresses.length; x++) { _QRAllocation[_CurrentCityIndex][Addresses[x]] = Amounts[x]; }\\n    }\\n\\n    /**\\n     * @dev Increments QR Allocations\\n     */\\n    function __QRAllocationsIncrement(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner\\n    {\\n        require(Addresses.length == Amounts.length, \\\"LiveMint: Input Arrays Must Match\\\");\\n        for(uint x; x < Addresses.length; x++) { _QRAllocation[_CurrentCityIndex][Addresses[x]] += Amounts[x]; }\\n    }\\n\\n    /**\\n     * @dev Mints To Multisig\\n     */\\n    function __QRAllocationsSetNoShow(uint[] calldata TicketIDs) external onlyOwner\\n    {\\n        for(uint TicketIndex; TicketIndex < TicketIDs.length; TicketIndex++)\\n        {\\n            require(!_MintedCitizen[_CurrentCityIndex][TicketIDs[TicketIndex]], \\\"LiveMint: Ticket ID Already Minted\\\");\\n            _BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketIndex]] = _BRT_MULTISIG;\\n        }\\n    }\\n\\n    /**\\n     * @dev Changes QR Current Index\\n     */\\n    function __ChangeQRIndex(uint NewIndex) external onlyOwner { Cities[_CurrentCityIndex]._QRCurrentIndex = NewIndex; }\\n\\n    /**\\n     * @dev Changes Pindar's Minter Address\\n     */\\n    function __ChangePindarAddress(address NewAddress) external onlyOwner { _Pindar = NewAddress; }\\n\\n    /**\\n     * @dev Batch Approves BRT For Purchasing\\n     */\\n    function __BatchApproveERC20(address[] calldata ERC20s, address[] calldata Operators) external onlyOwner\\n    {\\n        require(ERC20s.length == Operators.length, \\\"LiveMint: Arrays Must Be Equal Length\\\");\\n        for(uint x; x < ERC20s.length; x++) { IERC20(ERC20s[x]).approve(Operators[x], 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); }\\n    }\\n\\n    /**\\n     * @dev Instantiates New City\\n     * note: CityIndex Always Corresponds To ArtBlocks ProjectID\\n     */\\n    function __NewCity (\\n        string calldata Name,\\n        uint CityIndex,\\n        uint QRIndex,\\n        address ERC20\\n    ) external onlyOwner {\\n        Cities[CityIndex] = City(\\n            Name,\\n            QRIndex,\\n            ERC20,\\n            0x6942069420694206942069420694206942069420694206942069420694206942\\n        );\\n    }\\n\\n    /**\\n     * @dev Overrides An Artist\\n     */\\n    function __OverrideArtist(uint ArtistID, Artist memory NewArtist) external onlyOwner { Artists[ArtistID] = NewArtist; }\\n\\n    /**\\n     * @dev Instantiates A New City\\n     */\\n    function __NewCityStruct(uint CityIndex, City memory NewCity) external onlyOwner { Cities[CityIndex] = NewCity; }\\n\\n    /**\\n     * @dev Returns An Artist Struct\\n     */\\n    function __NewArtistStruct(uint ArtistID, Artist memory NewArtist) external onlyOwner { Artists[ArtistID] = NewArtist; }\\n\\n    /**\\n     * @dev Changes The Minter Address For An Artist\\n     */\\n    function __NewArtistMinter(uint ArtistID, address Minter) external onlyOwner { Artists[ArtistID]._Minter = Minter; }\\n\\n    /**\\n     * @dev Withdraws Any Ether Mistakenly Sent to Contract to Multisig\\n     **/\\n    function __WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\\n\\n    /**\\n     * @dev Withdraws ERC20 Tokens to Multisig\\n     **/\\n    function __WithdrawERC20(address TokenAddress) external onlyOwner \\n    { \\n        IERC20 erc20Token = IERC20(TokenAddress);\\n        uint balance = erc20Token.balanceOf(address(this));\\n        require(balance > 0, \\\"LiveMint: 0 ERC20 Balance At `TokenAddress`\\\");\\n        erc20Token.transfer(msg.sender, balance);\\n    }\\n\\n    /**\\n     * @dev Withdraws Any NFT Mistakenly Sent To This Contract.\\n     */\\n    function __WithdrawERC721(address ContractAddress, address Recipient, uint TokenID) external onlyOwner\\n    {\\n        IERC721(ContractAddress).transferFrom(address(this), Recipient, TokenID);\\n    }\\n\\n    /**\\n     * @dev Authorizes A Contract To Mint\\n     */\\n    function ____AuthorizeContract(address NewAddress) external onlyOwner \\n    { \\n        Role[NewAddress] = _AUTHORIZED; \\n        emit AuthorizedContract(NewAddress);\\n    }\\n\\n    /**\\n     * @dev Deauthorizes A Contract From Minting\\n     */\\n    function ___DeauthorizeContract(address NewAddress) external onlyOwner \\n    { \\n        Role[NewAddress] = 0x0; \\n        emit DeauthorizedContract(NewAddress);\\n    }\\n    \\n    /*-------------------*/\\n    /*    PUBLIC VIEW    */\\n    /*-------------------*/\\n\\n    /**\\n     * @dev Returns A User's QR Allocation Amount, Or 0 If Not Eligible\\n     */\\n    function readEligibility(address Recipient, bytes32[] memory Proof) public view returns(uint)\\n    {\\n        bool Eligible = readQREligibility(Recipient, Proof);\\n        if(!Eligible) { return 0; }\\n        else if(Eligible && _QRAllocation[_CurrentCityIndex][Recipient] > 0) { return _QRAllocation[_CurrentCityIndex][Recipient]; }\\n        else if(Eligible) { return 1; }\\n        else { return 0; }\\n    }\\n\\n    /**\\n     * @dev Returns If User Is Eligible To Redeem QR Code\\n     */\\n    function readQREligibility(address Recipient, bytes32[] memory Proof) public view returns(bool)\\n    {\\n        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));\\n        bool BrightListEligible = MerkleProof.verify(Proof, Cities[_CurrentCityIndex]._Root, Leaf);\\n        if(\\n            (BrightListEligible && !_QRRedeemed[_CurrentCityIndex][Recipient])\\n            || \\n            (BrightListEligible && _QRAllocation[_CurrentCityIndex][Recipient] > 0)\\n            \\n        ) { return true; }\\n        else { return false; }\\n    }\\n\\n    /**\\n     * @dev Returns An Array Of Unminted Golden Tokens\\n     */\\n    function readCitizenUnmintedTicketIDs() public view returns(uint[] memory)\\n    {\\n        uint[] memory UnmintedTokenIDs = new uint[](1000);\\n        uint Counter;\\n        uint CityIDBuffer = _CurrentCityIndex % 6 * 333;\\n        uint _TokenID;\\n        for(uint TokenID; TokenID < 1000; TokenID++)\\n        {\\n            _TokenID = TokenID + CityIDBuffer;\\n            if\\n            (\\n                !_MintedCitizen[_CurrentCityIndex][_TokenID]\\n                &&\\n                _BrightListCitizen[_CurrentCityIndex][_TokenID] != address(0)\\n            ) \\n            { \\n                UnmintedTokenIDs[Counter] = _TokenID; \\n                Counter++;\\n            }\\n        }\\n        uint[] memory FormattedUnMintedTokenIDs = new uint[](Counter);\\n        uint Found;\\n        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)\\n        {\\n            if(UnmintedTokenIDs[FormattedTokenID] != 0 || (UnmintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))\\n            {\\n                FormattedUnMintedTokenIDs[Found] = UnmintedTokenIDs[FormattedTokenID];\\n                Found++;\\n            }\\n        }\\n        return FormattedUnMintedTokenIDs;\\n    }\\n\\n    /**\\n     * @dev Returns An Array Of Unminted Golden Tokens\\n     */\\n    function readCitizenMintedTicketIDs(uint CityID) public view returns(uint[] memory)\\n    {\\n        uint[] memory MintedTokenIDs = new uint[](1000);\\n        uint Counter;\\n        uint CityIDBuffer = (CityID % 6) * 333;\\n        uint _TicketID;\\n        for(uint TicketID; TicketID < 1000; TicketID++)\\n        {\\n            _TicketID = TicketID + CityIDBuffer;\\n            if(_MintedCitizen[CityID][_TicketID]) \\n            { \\n                MintedTokenIDs[Counter] = _TicketID; \\n                Counter++;\\n            }\\n        }\\n        uint[] memory FormattedMintedTokenIDs = new uint[](Counter);\\n        uint Found;\\n        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)\\n        {\\n            if(MintedTokenIDs[FormattedTokenID] != 0 || (MintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))\\n            {\\n                FormattedMintedTokenIDs[Found] = MintedTokenIDs[FormattedTokenID];\\n                Found++;\\n            }\\n        }\\n        return FormattedMintedTokenIDs;\\n    }\\n\\n    /**\\n     * @dev Returns A 2d Array Of Checked In & Unminted TicketIDs Awaiting A Mint\\n     */\\n    function readCitizenCheckedInTicketIDs() public view returns(uint[] memory TokenIDs)\\n    {\\n        uint[] memory _TokenIDs = new uint[](1000);\\n        uint CityIDBuffer = (_CurrentCityIndex % 6) * 333;\\n        uint _TicketID;\\n        uint Counter;\\n        for(uint TicketID; TicketID < 1000; TicketID++)\\n        {\\n            _TicketID = TicketID + CityIDBuffer;\\n            if(\\n                !_MintedCitizen[_CurrentCityIndex][_TicketID]\\n                &&\\n                _BrightListCitizen[_CurrentCityIndex][_TicketID] != address(0)\\n            ) \\n            { \\n                _TokenIDs[Counter] = _TicketID; \\n                Counter++;\\n            }\\n        }\\n        uint[] memory FormattedCheckedInTickets = new uint[](Counter);\\n        uint Found;\\n        for(uint x; x < Counter; x++)\\n        {\\n            if(_TokenIDs[x] != 0 || (_TokenIDs[x] == 0 && x == 0))\\n            {\\n                FormattedCheckedInTickets[Found] = _TokenIDs[x];\\n                Found++;\\n            }\\n        }\\n        return FormattedCheckedInTickets;\\n    }\\n\\n    /**\\n     * @dev Returns A 2d Array Of Minted ArtistIDs\\n     */\\n    function readArtistUnmintedTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)\\n    {\\n        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);\\n        uint Index;\\n        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)\\n        {\\n            address _Mintpass = Artists[ArtistID]._MintPass;\\n            uint[] memory UnmintedArtistTokenIDs = new uint[](Range);\\n            uint Counter;\\n            for(uint TokenID; TokenID < Range; TokenID++)\\n            {\\n                bool TicketIDBurned;\\n                try IERC721(_Mintpass).ownerOf(TokenID) { } // checks if token is burned\\n                catch { TicketIDBurned = true; }\\n                if(\\n                    !_MintedArtist[ArtistIDs[ArtistID]][TokenID]\\n                    &&\\n                    (\\n                        _BrightListArtist[ArtistIDs[ArtistID]][TokenID] != address(0)\\n                        ||\\n                        TicketIDBurned == false\\n                    )\\n                ) \\n                { \\n                    UnmintedArtistTokenIDs[Counter] = TokenID; \\n                    Counter++;\\n                }\\n            }\\n            uint[] memory FormattedUnMintedArtistIDs = new uint[](Counter);\\n            uint Found;\\n            for(uint x; x < Counter; x++)\\n            {\\n                if(UnmintedArtistTokenIDs[x] != 0 || (UnmintedArtistTokenIDs[x] == 0 && x == 0))\\n                {\\n                    FormattedUnMintedArtistIDs[Found] = UnmintedArtistTokenIDs[x];\\n                    Found++;\\n                }\\n            }\\n            _TokenIDs[Index] = FormattedUnMintedArtistIDs;\\n            Index++;\\n        }\\n        return (_TokenIDs);\\n    }\\n\\n    /**\\n     * @dev Returns A 2d Array Of Minted ArtistIDs\\n     */\\n    function readArtistMintedTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)\\n    {\\n        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);\\n        uint Index;\\n        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)\\n        {\\n            uint[] memory MintedTokenIDs = new uint[](Range);\\n            uint Counter;\\n            for(uint TokenID; TokenID < Range; TokenID++)\\n            {\\n                if(_MintedArtist[ArtistIDs[ArtistID]][TokenID])\\n                { \\n                    MintedTokenIDs[Counter] = TokenID; \\n                    Counter++;\\n                }\\n            }\\n            uint[] memory FormattedMintedTokenIDs = new uint[](Counter);\\n            uint Found;\\n            for(uint x; x < Counter; x++)\\n            {\\n                if(MintedTokenIDs[x] != 0 || (MintedTokenIDs[x] == 0 && x == 0))\\n                {\\n                    FormattedMintedTokenIDs[Found] = MintedTokenIDs[x];\\n                    Found++;\\n                }\\n            }\\n            _TokenIDs[Index] = FormattedMintedTokenIDs;\\n            Index++;\\n        }\\n        return (_TokenIDs);\\n    }\\n\\n    /**\\n     * @dev Returns Original Recipients Of CryptoCitizens\\n     */\\n    function readCitizenBrightList(uint CityIndex) public view returns(address[] memory Recipients)\\n    {\\n        address[] memory _Recipients = new address[](1000);\\n        uint Start = (CityIndex % 6) * 333;\\n        for(uint x; x < 1000; x++) { _Recipients[x] = _BrightListCitizen[CityIndex][Start+x]; }\\n        return _Recipients;\\n    }\\n\\n    /**\\n     * @dev Returns Original Recipient Of Artist NFTs\\n     */\\n    function readArtistBrightList(uint ArtistID, uint Range) public view returns(address[] memory Recipients)\\n    {\\n        address[] memory _Recipients = new address[](Range);\\n        for(uint x; x < Range; x++) { _Recipients[x] = _BrightListArtist[ArtistID][x]; }\\n        return _Recipients;    \\n    }\\n\\n    /**\\n     * @dev Returns The City Struct At Index Of `CityIndex`\\n     */\\n    function readCitizenCity(uint CityIndex) public view returns(City memory) { return Cities[CityIndex]; }\\n\\n    /**\\n     * @dev Returns The Artist Struct At Index Of `ArtistID`\\n     */\\n    function readArtist(uint ArtistID) public view returns(Artist memory) { return Artists[ArtistID]; }\\n\\n    /**\\n     * @dev Returns A Minted Work TokenID Corresponding To The Input Artist TicketID \\n     */\\n    function readArtistMintedTokenID(uint ArtistID, uint TicketID) external view returns (uint)\\n    {\\n        if(!_MintedArtist[ArtistID][TicketID]) { return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; }\\n        else { return _MintedTokenIDArtist[ArtistID][TicketID]; }\\n    }\\n\\n    /**\\n     * @dev Returns A Minted Citizen TokenID Corresponding To Input TicketID\\n     */\\n    function readCitizenMintedTokenID(uint CityIndex, uint TicketID) external view returns(uint)\\n    {\\n        if(!_MintedCitizen[CityIndex][TicketID]) { return type(uint).max; }\\n        else { return _MintedTokenIDCitizen[CityIndex][TicketID]; }  \\n    }\\n    \\n    /*-------------------------*/\\n    /*        LAUNCHPAD        */\\n    /*-------------------------*/\\n\\n    /**\\n     * @dev Initializes A LiveMint Artist\\n     */\\n    function __InitLiveMint(Artist memory _Params) external onlyAdmin returns (uint)\\n    {\\n        AmountRemaining[_UniqueArtistsInvoked] = _Params._MaxSupply;\\n        Artists[_UniqueArtistsInvoked] = _Params;\\n        _UniqueArtistsInvoked++;\\n        return _UniqueArtistsInvoked - 1;\\n    }\\n\\n    /*-------------------------*/\\n    /*     ACCESS MODIFIERS    */\\n    /*-------------------------*/\\n\\n    /**\\n     * @dev Access Modifier That Allows Only BrightListed BRT Minters\\n     **/\\n    modifier onlyMinter() \\n    {\\n        require(Role[msg.sender] == _MINTER_ROLE, \\\"LiveMint | onlyMinter | Caller Is Not Approved BRT Minter\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Access Modifier That Allows Only Authorized Contracts\\n     */\\n    modifier onlyAdmin()\\n    {\\n        require(Role[msg.sender] == _AUTHORIZED || msg.sender == _LAUNCHPAD || msg.sender == owner(), \\\"LiveMint | onlyAdmin | Caller Is Not Approved Admin\\\");\\n        _;\\n    }\\n}\\ninterface IDelegationRegistry\\n{\\n    /**\\n     * @dev Checks If A Vault Has Delegated To The Delegate\\n     */\\n    function checkDelegateForAll(address delegate, address delegator) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/LiveMintEnabled.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/**\\n * @title LiveMintEnabled\\n * @dev @brougkr\\n * note: This Contract Is Used To Enable LiveMint To Purchase Tokens From Your Contract\\n * note: This Contract Should Be Imported and Included In The `is` Portion Of The Contract Declaration, ex. `contract NFT is Ownable, LiveMintEnabled`\\n * note: You Can Copy Or Modify The Example Functions Below To Implement The Two Functions In Your Contract\\n */\\npragma solidity 0.8.19;\\nabstract contract LiveMintEnabled\\n{\\n    /**\\n     * @dev LiveMint purchaseTo\\n     * note: Should Be Implemented With onlyLiveMint Access Modifier\\n     * note: Should Return The TokenID Being Transferred To The Recipient\\n     */\\n    function purchaseTo(address Recipient) external virtual returns (uint tokenID);\\n\\n    // purchaseTo() EXAMPLE: \\n    // Here Is An Example Of The Function Implemented In An Standard ERC721 Contract (you can copy paste the function below into your contract)\\n    // function purchaseTo(address Recipient) override virtual external onlyLiveMint returns (uint tokenID) \\n    // {\\n    //     _mint(Recipient, 1);\\n    //     return (totalSupply() - 1);\\n    // }\\n\\n    /**\\n     * @dev ChangeLiveMintAddress Changes The LiveMint Address | note: Should Be Implemented To Include onlyOwner Or Similar Access Modifier\\n     */\\n    function _ChangeLiveMintAddress(address LiveMintAddress) external virtual;\\n\\n    // _ChangeLiveMintAddress EXAMPLE: \\n    // Here Is An Example Of The Function Implemented In An Standard ERC721 Contract (you can copy paste the function below into your contract)\\n    // function _ChangeLiveMintAddress(address LiveMintAddress) override virtual external onlyOwner { _LIVE_MINT_ADDRESS = LiveMintAddress; }\\n\\n    /**\\n     * @dev LiveMint Address\\n     */\\n    address public _LIVE_MINT_ADDRESS = 0x76375092724A9cE835d117106E0F374E85EFa42B; \\n\\n    /**\\n     * @dev Access Modifier For LiveMint\\n     */\\n    modifier onlyLiveMint\\n    {\\n        require(msg.sender == _LIVE_MINT_ADDRESS, \\\"onlyLiveMint: msg.sender Is Not The LiveMint Contract\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/LiveMintTokyo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/**\\n * @dev: @brougkr\\n */\\npragma solidity 0.8.19;\\nimport { IERC721 } from \\\"@openzeppelin/contracts/interfaces/IERC721.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { ReentrancyGuard } from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport { MerkleProof } from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport { IMinter } from \\\"./IMinter.sol\\\";\\nimport { IMP } from \\\"./IMP.sol\\\";\\nimport { IGT } from \\\"./IGT.sol\\\";\\nimport { LaunchpadEnabled } from \\\"./LaunchpadEnabled.sol\\\";\\ncontract LiveMintTokyo is Ownable, ReentrancyGuard, LaunchpadEnabled\\n{  \\n    struct City\\n    {\\n        string _Name;         // _Name\\n        uint _QRCurrentIndex; // _QRCurrentIndex (Should be Always Be 333 + (333 * (City# % 6))\\n        address _ERC20;       // _ERC20 \\n        bytes32 _Root;        // _Root\\n    }\\n\\n    struct Artist\\n    {\\n        address _MintPass;        // _MintPass\\n        address _Minter;          // _Minter\\n        address _PolyptychSource; // _PolyptychSource\\n        uint _MaxSupply;          // _MaxSupply\\n        uint _MintPassProjectID;  // _MintPassProjectID\\n        uint _ArtBlocksProjectID; // _ArtBlocksProjectID \\n        uint _PolyStart;          // _PolyStart\\n        uint _PolyEnd;            // _PolyEnd\\n    }\\n\\n    struct User\\n    {\\n        bool _Eligible;   // _Eligible\\n        uint _Allocation; // _Allocation\\n    }\\n\\n    /*-------------------*/\\n    /*  STATE VARIABLES  */\\n    /*-------------------*/\\n\\n    bytes32 private constant _AUTHORIZED = keccak256(\\\"AUTHORIZED\\\");                        // Authorized Role\\n    bytes32 private constant _MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");                      // Minter Role\\n    address private constant _DN = 0x00000000000076A84feF008CDAbe6409d2FE638B;             // delegate.cash Delegation Registry\\n    address private constant _GOLDEN_TOKEN = 0x985e1932FFd2aA4bC9cE611DFe12816A248cD2cE;   // Golden Token Address\\n    address private constant _CITIZEN_MINTER = 0xDd06d8483868Cd0C5E69C24eEaA2A5F2bEaFd42b; // ArtBlocks Minter Contract\\n    address private constant _BRT_MULTISIG = 0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937;   // BRT Multisig\\n    address public _Pindar;                                                                // Pindar Van Arman's Custom Minter Contract\\n    uint public _CurrentCityIndex = 6;                                                     // Current City Index\\n    uint public _UniqueArtistsInvoked;                                                     // Unique Artists Invoked\\n\\n    /*-------------------*/\\n    /*     MAPPINGS      */\\n    /*-------------------*/\\n    \\n    mapping(uint => Artist) public Artists;                              // [ArtistID] => Artist\\n    mapping(uint => City) public Cities;                                 // [CityIndex] => City Struct\\n    mapping(uint => mapping(address => bool)) public _QRRedeemed;        // [CityIndex][Wallet] => If User Has Redeemed QR\\n    mapping(uint => mapping(address => uint)) public _QRAllocation;      // [CityIndex][Wallet] => Wallet's QR Code Allocation\\n    mapping(uint => mapping(uint => address)) public _BrightListCitizen; // [CityIndex][TicketID] => Address Of CryptoCitizen Minting Recipient \\n    mapping(uint => mapping(uint => address)) public _BrightListArtist;  // [ArtistID][TicketID] => Address Of Artist NFT Recipient\\n    mapping(uint => mapping(uint => string)) public _DataArtists;        // [ArtistID][TicketID] => Artist Data\\n    mapping(uint => mapping(uint => string)) public _DataCitizens;       // [CityIndex][TicketID] => Data For Golden Token Checkins\\n    mapping(uint => mapping(uint => uint)) public _MintedTokenIDCitizen; // [CityIndex][TicketID] => MintedTokenID\\n    mapping(uint => mapping(uint => uint)) public _MintedTokenIDArtist;  // [ArtistID][TicketID] => MintedTokenID\\n    mapping(uint => mapping(uint => bool)) public _MintedArtist;         // [ArtistID][TicketID] => If Minted\\n    mapping(uint => mapping(uint => bool)) public _MintedCitizen;        // [CityIndex][TicketID] => If Golden Ticket ID Has Minted Or Not\\n    mapping(uint => mapping(uint => uint)) public _ArtBlocksProjectID;   // [ArtistID][TicketID] => ArtBlocksProjectID\\n    mapping(address => bytes32) public Role;                             // [Wallet] => BRT Minter Role\\n    mapping(uint => uint) public AmountRemaining;                        // [ArtistID] => Mints Remaining\\n\\n    /*-------------------*/\\n    /*      EVENTS       */\\n    /*-------------------*/\\n\\n    /**\\n     * @dev Emitted When `Redeemer` IRL-mints CryptoCitizen Corresponding To Their Redeemed `TicketID`.\\n     **/\\n    event LiveMintComplete(address Redeemer, uint TicketID, uint TokenID, string Data);\\n\\n    /**\\n     * @dev Emitted When `Redeemer` IRL-mints A Artist NFT Corresponding To Their Redeemed `TicketID`.\\n     */\\n    event LiveMintCompleteArtist(address Recipient, uint ArtistID, uint TicketID, uint MintedWorkTokenID);\\n\\n    /**\\n     * @dev Emitted When `Redeemer` Redeems Golden Token Corresponding To `TicketID` \\n     **/\\n    event QRRedeemed(address Redeemer, uint TicketID, string Data, string Type);\\n\\n    /**\\n     * @dev Emitted When A Contract Is Authorized\\n     */\\n    event AuthorizedContract(address NewAddress);\\n\\n    /**\\n     * @dev Emitted When A Contract Is Deauthorized\\n     */\\n    event DeauthorizedContract(address NewAddress);\\n\\n    /*-------------------*/\\n    /*    CONSTRUCTOR    */\\n    /*-------------------*/\\n\\n    constructor()\\n    { \\n        Cities[0]._Name = \\\"CryptoGalacticans\\\";  \\n        Cities[1]._Name = \\\"CryptoVenetians\\\";    \\n        Cities[2]._Name = \\\"CryptoNewYorkers\\\";   \\n        Cities[3]._Name = \\\"CryptoBerliners\\\";    \\n        Cities[4]._Name = \\\"CryptoLondoners\\\";    \\n        Cities[5]._Name = \\\"CryptoMexas\\\";        \\n        Cities[6]._Name = \\\"CryptoTokyites\\\";     \\n        Cities[6]._QRCurrentIndex = 333;\\n        Cities[6]._Root = 0x255b8b82ee0d1823cdc3cf859efacfee1111414bacab649a7e8bea9cd48a0ed3;\\n        Cities[7]._Name = \\\"CryptoCitizen City #8\\\"; \\n        Cities[7]._QRCurrentIndex = 666;\\n        Cities[8]._Name = \\\"CryptoCitizen City #9\\\";\\n        Cities[8] ._QRCurrentIndex = 999;\\n        Cities[9]._Name = \\\"CryptoCitizen City #10\\\";\\n        Cities[10]._QRCurrentIndex = 1332; \\n        Role[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = _AUTHORIZED;  // `operator.brightmoments.eth`\\n        Role[0x1A0a3E3AE390a0710f8A6d00587082273eA8F6C9] = _MINTER_ROLE; // BRT Minter #1\\n        Role[0x4d8013b0c264034CBf22De9DF33e22f58D52F207] = _MINTER_ROLE; // BRT Minter #2\\n        Role[0x4D9A8CF2fE52b8D49C7F7EAA87b2886c2bCB4160] = _MINTER_ROLE; // BRT Minter #3\\n        Role[0x124fd966A0D83aA020D3C54AE2c9f4800b46F460] = _MINTER_ROLE; // BRT Minter #4\\n        Role[0x100469feA90Ac1Fe1073E1B2b5c020A8413635c4] = _MINTER_ROLE; // BRT Minter #5\\n        Role[0x756De4236373fd17652b377315954ca327412bBA] = _MINTER_ROLE; // BRT Minter #6\\n        Role[0xc5Dfba6ef7803665C1BDE478B51Bd7eB257A2Cb9] = _MINTER_ROLE; // BRT Minter #7\\n        Role[0xFBF32b29Bcf8fEe32d43a4Bfd3e7249daec457C0] = _MINTER_ROLE; // BRT Minter #8\\n        Role[0xF2A15A83DEE7f03C70936449037d65a1C100FF27] = _MINTER_ROLE; // BRT Minter #9\\n        Role[0x1D2BAB965a4bB72f177Cd641C7BacF3d8257230D] = _MINTER_ROLE; // BRT Minter #10\\n        Role[0x2e51E8b950D72BDf003b58E357C2BA28FB77c7fB] = _MINTER_ROLE; // BRT Minter #11\\n        Role[0x8a7186dECb91Da854090be8226222eA42c5eeCb6] = _MINTER_ROLE; // BRT Minter #12\\n    }\\n\\n    /*---------------------*/\\n    /*    QR REDEMPTION    */\\n    /*---------------------*/\\n\\n    /**\\n     * @dev Redeems Spot For IRL Minting\\n     */\\n    function RedeemQR(string[] calldata Data, string[] calldata Type, bytes32[] calldata Proof, address Vault, uint Amount) external nonReentrant \\n    {        \\n        address Recipient = msg.sender;\\n        if(Vault != address(0)) { if(IDelegationRegistry(_DN).checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } } \\n        require(readQREligibility(Recipient, Proof), \\\"LiveMint: User Is Not Eligible To Redeem QR\\\");\\n        if(_QRAllocation[_CurrentCityIndex][Recipient] == 0) // User Is Able To Redeem Explicitly 1 QR Code\\n        {\\n            require(!_QRRedeemed[_CurrentCityIndex][Recipient], \\\"LiveMint: User Has Already Redeemed\\\");\\n            _DataCitizens[_CurrentCityIndex][Cities[_CurrentCityIndex]._QRCurrentIndex] = Data[0];\\n            _BrightListCitizen[_CurrentCityIndex][Cities[_CurrentCityIndex]._QRCurrentIndex] = Recipient;\\n            emit QRRedeemed(Recipient, Cities[_CurrentCityIndex]._QRCurrentIndex, Data[0], Type[0]);\\n            Cities[_CurrentCityIndex]._QRCurrentIndex++; \\n        }\\n        else // User Is Able To Redeem More Than 1 QR Code Because Their QRAllocation > 0\\n        {\\n            require(Amount <= _QRAllocation[_CurrentCityIndex][Recipient], \\\"LiveMint: Amount Must Be Less Than Or Equal To QRAllocation\\\");\\n            uint _CurrentQR = Cities[_CurrentCityIndex]._QRCurrentIndex;\\n            uint _Limit = Amount + _CurrentQR;\\n            uint _Counter;\\n            _QRAllocation[_CurrentCityIndex][Recipient] -= Amount;\\n            Cities[_CurrentCityIndex]._QRCurrentIndex = _Limit;\\n            for(_CurrentQR; _CurrentQR < _Limit; _CurrentQR++)\\n            {\\n                _DataCitizens[_CurrentCityIndex][_CurrentQR] = Data[_Counter];\\n                _BrightListCitizen[_CurrentCityIndex][_CurrentQR] = Recipient;\\n                emit QRRedeemed(Recipient, _CurrentQR, Data[_Counter], Type[_Counter]);\\n                _Counter++;\\n            }\\n        }\\n        _QRRedeemed[_CurrentCityIndex][Recipient] = true;\\n    }\\n\\n    /*--------------------*/\\n    /*    LIVE MINTING    */\\n    /*--------------------*/\\n\\n    /**\\n     * @dev Batch Mints Verified Users On The Brightlist CryptoCitizens\\n     * note: { For CryptoCitizen Cities }\\n     */\\n    function _LiveMintCitizen(uint[] calldata TicketIDs) external onlyMinter\\n    {\\n        address Recipient;\\n        uint MintedWorkTokenID;\\n        for(uint TicketID; TicketID < TicketIDs.length; TicketID++)\\n        {\\n            require(!_MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]], \\\"LiveMint: Golden Token Already Minted\\\");\\n            if(_BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketID]] != address(0))\\n            {\\n                Recipient = _BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketID]];\\n            }\\n            else if (TicketIDs[TicketID] <= 333) { Recipient = IGT(_GOLDEN_TOKEN)._LiveMintBurn(TicketIDs[TicketID]); }\\n            else { revert(\\\"LiveMint: Invalid TicketID\\\"); }\\n            require(Recipient != address(0), \\\"LiveMint: Invalid Recipient\\\");\\n            _MintedCitizen[_CurrentCityIndex][TicketIDs[TicketID]] = true;\\n            MintedWorkTokenID = IMinter(_CITIZEN_MINTER).purchaseTo(Recipient, _CurrentCityIndex);\\n            _MintedTokenIDCitizen[_CurrentCityIndex][TicketIDs[TicketID]] = MintedWorkTokenID;\\n            emit LiveMintComplete(Recipient, TicketIDs[TicketID], MintedWorkTokenID, _DataCitizens[_CurrentCityIndex][TicketIDs[TicketID]]); \\n        }\\n    }\\n\\n    /**\\n     * @dev Burns Artist Mint Pass In Exchange For The Minted Work\\n     * note: { For Instances Where Multiple Artists Share The Same Mint Pass & Return (Recipient, ArtBlocksProjectID) }\\n     */\\n    function _LiveMintArtist(uint ArtistID, uint[] calldata TicketIDs) external onlyMinter\\n    {\\n        address Recipient;\\n        address MintPass = Artists[ArtistID]._MintPass;\\n        address Minter = Artists[ArtistID]._Minter;\\n        uint ArtBlocksProjectID;\\n        uint MintedWorkTokenID;\\n        uint TicketID;\\n        require(AmountRemaining[ArtistID] > 0, \\\"LiveMint: ArtistID Mint Limit Reached\\\");\\n        require(TicketIDs.length <= AmountRemaining[ArtistID], \\\"LiveMint: TicketID Length Exceeds ArtistID Mint Limit\\\");\\n        AmountRemaining[ArtistID] = AmountRemaining[ArtistID] - TicketIDs.length;\\n        for(uint x; x < TicketIDs.length; x++)\\n        {\\n            TicketID = TicketIDs[x];\\n            require(!_MintedArtist[ArtistID][TicketID], \\\"LiveMint: Artist Mint Pass Already Minted\\\");\\n            _MintedArtist[ArtistID][TicketID] = true;\\n            (Recipient, ArtBlocksProjectID) = IMP(MintPass)._LiveMintBurn(TicketID);\\n            if(ArtBlocksProjectID == 100) { MintedWorkTokenID = IMinter(_Pindar).purchaseTo(Recipient); } // Pindar Custom Contract \\n            else { MintedWorkTokenID = IMinter(Minter).purchaseTo(Recipient, ArtBlocksProjectID); } // Pre-Defined Minter Contract\\n            _MintedTokenIDArtist[ArtistID][TicketID] = MintedWorkTokenID;\\n            emit LiveMintCompleteArtist(Recipient, ArtistID, TicketID, MintedWorkTokenID);\\n        }\\n    }\\n\\n    /**\\n     * @dev Burns Artist Mint Pass In Exchange For The Minted Work\\n     * note: { For Instances Where Multiple Artists Share The Same Mint Pass & Return (Recipient, ArtBlocksProjectID) }\\n     */\\n    function _LiveMintArtistBatch(uint[] calldata ArtistIDs, uint[][] calldata TicketIDs) external onlyMinter\\n    {\\n        address Recipient;\\n        address MintPass;\\n        address Minter;\\n        uint ArtBlocksProjectID;\\n        uint MintedWorkTokenID;\\n        uint TicketID;\\n        uint ActiveArtistID;\\n        for(uint ArtistIDIndex; ArtistIDIndex < ArtistIDs.length; ArtistIDIndex++)\\n        {\\n            ActiveArtistID = ArtistIDs[ArtistIDIndex];\\n            MintPass = Artists[ActiveArtistID]._MintPass;\\n            Minter = Artists[ActiveArtistID]._Minter;\\n            for(uint TicketIDIndex; TicketIDIndex < TicketIDs[ArtistIDIndex].length; TicketIDIndex++)\\n            {\\n                TicketID = TicketIDs[ArtistIDIndex][TicketIDIndex];\\n                require(!_MintedArtist[ActiveArtistID][TicketID], \\\"LiveMint: Artist Mint Pass Already Minted\\\");\\n                _MintedArtist[ActiveArtistID][TicketID] = true;\\n                (Recipient, ArtBlocksProjectID) = IMP(MintPass)._LiveMintBurn(TicketID);\\n                if(ArtBlocksProjectID == 100) { MintedWorkTokenID = IMinter(_Pindar).purchaseTo(Recipient); }\\n                else { MintedWorkTokenID = IMinter(Minter).purchaseTo(Recipient, ArtBlocksProjectID); }\\n                _MintedTokenIDArtist[ActiveArtistID][TicketID] = MintedWorkTokenID;\\n                emit LiveMintCompleteArtist(Recipient, ActiveArtistID, TicketID, MintedWorkTokenID);\\n            }\\n        }\\n    }\\n\\n    /*-------------------*/\\n    /*  OWNER FUNCTIONS  */\\n    /*-------------------*/\\n\\n    /**\\n     * @dev Grants Address BRT Minter Role\\n     **/\\n    function __AddMinter(address Minter) external onlyOwner { Role[Minter] = _MINTER_ROLE; }\\n    \\n    /**\\n     * @dev Deactivates Address From BRT Minter Role\\n     **/\\n    function __RemoveMinter(address Minter) external onlyOwner { Role[Minter] = 0x0; }\\n\\n    /**\\n     * @dev Changes Mint Pass Address For Artist LiveMints\\n     */\\n    function __ChangeMintPass(uint ProjectID, address Contract) external onlyOwner { Artists[ProjectID]._MintPass = Contract; }\\n\\n    /**\\n     * @dev Changes Merkle Root For Citizen LiveMints\\n     */\\n    function __ChangeRootCitizen(bytes32 NewRoot) external onlyOwner { Cities[_CurrentCityIndex]._Root = NewRoot; }\\n\\n    /**\\n     * @dev Overwrites QR Allocation\\n     */\\n    function __QRAllocationsOverwrite(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner\\n    {\\n        require(Addresses.length == Amounts.length, \\\"LiveMint: Input Arrays Must Match\\\");\\n        for(uint x; x < Addresses.length; x++) { _QRAllocation[_CurrentCityIndex][Addresses[x]] = Amounts[x]; }\\n    }\\n\\n    /**\\n     * @dev Increments QR Allocations\\n     */\\n    function __QRAllocationsIncrement(address[] calldata Addresses, uint[] calldata Amounts) external onlyOwner\\n    {\\n        require(Addresses.length == Amounts.length, \\\"LiveMint: Input Arrays Must Match\\\");\\n        for(uint x; x < Addresses.length; x++) { _QRAllocation[_CurrentCityIndex][Addresses[x]] += Amounts[x]; }\\n    }\\n\\n    /**\\n     * @dev Mints To Multisig\\n     */\\n    function __QRAllocationsSetNoShow(uint[] calldata TicketIDs) external onlyOwner\\n    {\\n        for(uint TicketIndex; TicketIndex < TicketIDs.length; TicketIndex++)\\n        {\\n            require(!_MintedCitizen[_CurrentCityIndex][TicketIDs[TicketIndex]], \\\"LiveMint: Ticket ID Already Minted\\\");\\n            _BrightListCitizen[_CurrentCityIndex][TicketIDs[TicketIndex]] = _BRT_MULTISIG;\\n        }\\n    }\\n\\n    /**\\n     * @dev Changes QR Current Index\\n     */\\n    function __ChangeQRIndex(uint NewIndex) external onlyOwner { Cities[_CurrentCityIndex]._QRCurrentIndex = NewIndex; }\\n\\n    /**\\n     * @dev Changes Pindar's Minter Address\\n     */\\n    function __ChangePindarAddress(address NewAddress) external onlyOwner { _Pindar = NewAddress; }\\n\\n    /**\\n     * @dev Batch Approves BRT For Purchasing\\n     */\\n    function __BatchApproveERC20(address[] calldata ERC20s, address[] calldata Operators) external onlyOwner\\n    {\\n        require(ERC20s.length == Operators.length, \\\"LiveMint: Arrays Must Be Equal Length\\\");\\n        for(uint x; x < ERC20s.length; x++) { IERC20(ERC20s[x]).approve(Operators[x], 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); }\\n    }\\n\\n    /**\\n     * @dev Instantiates New City\\n     * note: CityIndex Always Corresponds To ArtBlocks ProjectID\\n     */\\n    function __NewCity (\\n        string calldata Name,\\n        uint CityIndex,\\n        uint QRIndex,\\n        address ERC20\\n    ) external onlyOwner {\\n        Cities[CityIndex] = City(\\n            Name,\\n            QRIndex,\\n            ERC20,\\n            0x6942069420694206942069420694206942069420694206942069420694206942\\n        );\\n    }\\n\\n    /**\\n     * @dev Overrides An Artist\\n     */\\n    function __OverrideArtist(uint ArtistID, Artist memory NewArtist) external onlyOwner { Artists[ArtistID] = NewArtist; }\\n\\n    /**\\n     * @dev Instantiates A New City\\n     */\\n    function __NewCityStruct(uint CityIndex, City memory NewCity) external onlyOwner { Cities[CityIndex] = NewCity; }\\n\\n    /**\\n     * @dev Returns An Artist Struct\\n     */\\n    function __NewArtistStruct(uint ArtistID, Artist memory NewArtist) external onlyOwner { Artists[ArtistID] = NewArtist; }\\n\\n    /**\\n     * @dev Changes The Minter Address For An Artist\\n     */\\n    function __NewArtistMinter(uint ArtistID, address Minter) external onlyOwner { Artists[ArtistID]._Minter = Minter; }\\n\\n    /**\\n     * @dev Withdraws Any Ether Mistakenly Sent to Contract to Multisig\\n     **/\\n    function __WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\\n\\n    /**\\n     * @dev Withdraws ERC20 Tokens to Multisig\\n     **/\\n    function __WithdrawERC20(address TokenAddress) external onlyOwner \\n    { \\n        IERC20 erc20Token = IERC20(TokenAddress);\\n        uint balance = erc20Token.balanceOf(address(this));\\n        require(balance > 0, \\\"LiveMint: 0 ERC20 Balance At `TokenAddress`\\\");\\n        erc20Token.transfer(msg.sender, balance);\\n    }\\n\\n    /**\\n     * @dev Withdraws Any NFT Mistakenly Sent To This Contract.\\n     */\\n    function __WithdrawERC721(address ContractAddress, address Recipient, uint TokenID) external onlyOwner\\n    {\\n        IERC721(ContractAddress).transferFrom(address(this), Recipient, TokenID);\\n    }\\n\\n    /**\\n     * @dev Authorizes A Contract To Mint\\n     */\\n    function ____AuthorizeContract(address NewAddress) external onlyOwner \\n    { \\n        Role[NewAddress] = _AUTHORIZED; \\n        emit AuthorizedContract(NewAddress);\\n    }\\n\\n    /**\\n     * @dev Deauthorizes A Contract From Minting\\n     */\\n    function ___DeauthorizeContract(address NewAddress) external onlyOwner \\n    { \\n        Role[NewAddress] = 0x0; \\n        emit DeauthorizedContract(NewAddress);\\n    }\\n    \\n    /*-------------------*/\\n    /*    PUBLIC VIEW    */\\n    /*-------------------*/\\n\\n    /**\\n     * @dev Returns A User's QR Allocation Amount, Or 0 If Not Eligible\\n     */\\n    function readEligibility(address Recipient, bytes32[] memory Proof) public view returns(uint)\\n    {\\n        bool Eligible = readQREligibility(Recipient, Proof);\\n        if(!Eligible) { return 0; }\\n        else if(Eligible && _QRAllocation[_CurrentCityIndex][Recipient] > 0) { return _QRAllocation[_CurrentCityIndex][Recipient]; }\\n        else if(Eligible) { return 1; }\\n        else { return 0; }\\n    }\\n\\n    /**\\n     * @dev Returns If User Is Eligible To Redeem QR Code\\n     */\\n    function readQREligibility(address Recipient, bytes32[] memory Proof) public view returns(bool)\\n    {\\n        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));\\n        bool BrightListEligible = MerkleProof.verify(Proof, Cities[_CurrentCityIndex]._Root, Leaf);\\n        if(\\n            (BrightListEligible && !_QRRedeemed[_CurrentCityIndex][Recipient])\\n            || \\n            (BrightListEligible && _QRAllocation[_CurrentCityIndex][Recipient] > 0)\\n            \\n        ) { return true; }\\n        else { return false; }\\n    }\\n\\n    /**\\n     * @dev Returns An Array Of Unminted Golden Tokens\\n     */\\n    function readCitizenUnmintedTicketIDs() public view returns(uint[] memory)\\n    {\\n        uint[] memory UnmintedTokenIDs = new uint[](1000);\\n        uint Counter;\\n        uint CityIDBuffer = _CurrentCityIndex % 6 * 333;\\n        uint _TokenID;\\n        for(uint TokenID; TokenID < 1000; TokenID++)\\n        {\\n            _TokenID = TokenID + CityIDBuffer;\\n            if\\n            (\\n                !_MintedCitizen[_CurrentCityIndex][_TokenID]\\n                &&\\n                _BrightListCitizen[_CurrentCityIndex][_TokenID] != address(0)\\n            ) \\n            { \\n                UnmintedTokenIDs[Counter] = _TokenID; \\n                Counter++;\\n            }\\n        }\\n        uint[] memory FormattedUnMintedTokenIDs = new uint[](Counter);\\n        uint Found;\\n        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)\\n        {\\n            if(UnmintedTokenIDs[FormattedTokenID] != 0 || (UnmintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))\\n            {\\n                FormattedUnMintedTokenIDs[Found] = UnmintedTokenIDs[FormattedTokenID];\\n                Found++;\\n            }\\n        }\\n        return FormattedUnMintedTokenIDs;\\n    }\\n\\n    /**\\n     * @dev Returns An Array Of Unminted Golden Tokens\\n     */\\n    function readCitizenMintedTicketIDs(uint CityID) public view returns(uint[] memory)\\n    {\\n        uint[] memory MintedTokenIDs = new uint[](1000);\\n        uint Counter;\\n        uint CityIDBuffer = (CityID % 6) * 333;\\n        uint _TicketID;\\n        for(uint TicketID; TicketID < 1000; TicketID++)\\n        {\\n            _TicketID = TicketID + CityIDBuffer;\\n            if(_MintedCitizen[CityID][_TicketID]) \\n            { \\n                MintedTokenIDs[Counter] = _TicketID; \\n                Counter++;\\n            }\\n        }\\n        uint[] memory FormattedMintedTokenIDs = new uint[](Counter);\\n        uint Found;\\n        for(uint FormattedTokenID; FormattedTokenID < Counter; FormattedTokenID++)\\n        {\\n            if(MintedTokenIDs[FormattedTokenID] != 0 || (MintedTokenIDs[FormattedTokenID] == 0 && FormattedTokenID == 0))\\n            {\\n                FormattedMintedTokenIDs[Found] = MintedTokenIDs[FormattedTokenID];\\n                Found++;\\n            }\\n        }\\n        return FormattedMintedTokenIDs;\\n    }\\n\\n    /**\\n     * @dev Returns A 2d Array Of Checked In & Unminted TicketIDs Awaiting A Mint\\n     */\\n    function readCitizenCheckedInTicketIDs() public view returns(uint[] memory TokenIDs)\\n    {\\n        uint[] memory _TokenIDs = new uint[](1000);\\n        uint CityIDBuffer = (_CurrentCityIndex % 6) * 333;\\n        uint _TicketID;\\n        uint Counter;\\n        for(uint TicketID; TicketID < 1000; TicketID++)\\n        {\\n            _TicketID = TicketID + CityIDBuffer;\\n            if(\\n                !_MintedCitizen[_CurrentCityIndex][_TicketID]\\n                &&\\n                _BrightListCitizen[_CurrentCityIndex][_TicketID] != address(0)\\n            ) \\n            { \\n                _TokenIDs[Counter] = _TicketID; \\n                Counter++;\\n            }\\n        }\\n        uint[] memory FormattedCheckedInTickets = new uint[](Counter);\\n        uint Found;\\n        for(uint x; x < Counter; x++)\\n        {\\n            if(_TokenIDs[x] != 0 || (_TokenIDs[x] == 0 && x == 0))\\n            {\\n                FormattedCheckedInTickets[Found] = _TokenIDs[x];\\n                Found++;\\n            }\\n        }\\n        return FormattedCheckedInTickets;\\n    }\\n\\n    /**\\n     * @dev Returns A 2d Array Of Minted ArtistIDs\\n     */\\n    function readArtistUnmintedTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)\\n    {\\n        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);\\n        uint Index;\\n        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)\\n        {\\n            address _Mintpass = Artists[ArtistID]._MintPass;\\n            uint[] memory UnmintedArtistTokenIDs = new uint[](Range);\\n            uint Counter;\\n            for(uint TokenID; TokenID < Range; TokenID++)\\n            {\\n                bool TicketIDBurned;\\n                try IERC721(_Mintpass).ownerOf(TokenID) { } // checks if token is burned\\n                catch { TicketIDBurned = true; }\\n                if(\\n                    !_MintedArtist[ArtistIDs[ArtistID]][TokenID]\\n                    &&\\n                    (\\n                        _BrightListArtist[ArtistIDs[ArtistID]][TokenID] != address(0)\\n                        ||\\n                        TicketIDBurned == false\\n                    )\\n                ) \\n                { \\n                    UnmintedArtistTokenIDs[Counter] = TokenID; \\n                    Counter++;\\n                }\\n            }\\n            uint[] memory FormattedUnMintedArtistIDs = new uint[](Counter);\\n            uint Found;\\n            for(uint x; x < Counter; x++)\\n            {\\n                if(UnmintedArtistTokenIDs[x] != 0 || (UnmintedArtistTokenIDs[x] == 0 && x == 0))\\n                {\\n                    FormattedUnMintedArtistIDs[Found] = UnmintedArtistTokenIDs[x];\\n                    Found++;\\n                }\\n            }\\n            _TokenIDs[Index] = FormattedUnMintedArtistIDs;\\n            Index++;\\n        }\\n        return (_TokenIDs);\\n    }\\n\\n    /**\\n     * @dev Returns A 2d Array Of Minted ArtistIDs\\n     */\\n    function readArtistMintedTicketIDs(uint[] calldata ArtistIDs, uint Range) public view returns(uint[][] memory TokenIDs)\\n    {\\n        uint[][] memory _TokenIDs = new uint[][](ArtistIDs.length);\\n        uint Index;\\n        for(uint ArtistID; ArtistID < ArtistIDs.length; ArtistID++)\\n        {\\n            uint[] memory MintedTokenIDs = new uint[](Range);\\n            uint Counter;\\n            for(uint TokenID; TokenID < Range; TokenID++)\\n            {\\n                if(_MintedArtist[ArtistIDs[ArtistID]][TokenID])\\n                { \\n                    MintedTokenIDs[Counter] = TokenID; \\n                    Counter++;\\n                }\\n            }\\n            uint[] memory FormattedMintedTokenIDs = new uint[](Counter);\\n            uint Found;\\n            for(uint x; x < Counter; x++)\\n            {\\n                if(MintedTokenIDs[x] != 0 || (MintedTokenIDs[x] == 0 && x == 0))\\n                {\\n                    FormattedMintedTokenIDs[Found] = MintedTokenIDs[x];\\n                    Found++;\\n                }\\n            }\\n            _TokenIDs[Index] = FormattedMintedTokenIDs;\\n            Index++;\\n        }\\n        return (_TokenIDs);\\n    }\\n\\n    /**\\n     * @dev Returns Original Recipients Of CryptoCitizens\\n     */\\n    function readCitizenBrightList(uint CityIndex) public view returns(address[] memory Recipients)\\n    {\\n        address[] memory _Recipients = new address[](1000);\\n        uint Start = (CityIndex % 6) * 333;\\n        for(uint x; x < 1000; x++) { _Recipients[x] = _BrightListCitizen[CityIndex][Start+x]; }\\n        return _Recipients;\\n    }\\n\\n    /**\\n     * @dev Returns Original Recipient Of Artist NFTs\\n     */\\n    function readArtistBrightList(uint ArtistID, uint Range) public view returns(address[] memory Recipients)\\n    {\\n        address[] memory _Recipients = new address[](Range);\\n        for(uint x; x < Range; x++) { _Recipients[x] = _BrightListArtist[ArtistID][x]; }\\n        return _Recipients;    \\n    }\\n\\n    /**\\n     * @dev Returns The City Struct At Index Of `CityIndex`\\n     */\\n    function readCitizenCity(uint CityIndex) public view returns(City memory) { return Cities[CityIndex]; }\\n\\n    /**\\n     * @dev Returns The Artist Struct At Index Of `ArtistID`\\n     */\\n    function readArtist(uint ArtistID) public view returns(Artist memory) { return Artists[ArtistID]; }\\n\\n    /**\\n     * @dev Returns A Minted Work TokenID Corresponding To The Input Artist TicketID \\n     */\\n    function readArtistMintedTokenID(uint ArtistID, uint TicketID) external view returns (uint)\\n    {\\n        if(!_MintedArtist[ArtistID][TicketID]) { return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; }\\n        else { return _MintedTokenIDArtist[ArtistID][TicketID]; }\\n    }\\n\\n    /**\\n     * @dev Returns A Minted Citizen TokenID Corresponding To Input TicketID\\n     */\\n    function readCitizenMintedTokenID(uint CityIndex, uint TicketID) external view returns(uint)\\n    {\\n        if(!_MintedCitizen[CityIndex][TicketID]) { return type(uint).max; }\\n        else { return _MintedTokenIDCitizen[CityIndex][TicketID]; }  \\n    }\\n    \\n    /*-------------------------*/\\n    /*        LAUNCHPAD        */\\n    /*-------------------------*/\\n\\n    /**\\n     * @dev Initializes A LiveMint Artist\\n     */\\n    function __InitLiveMint(Artist memory _Params) external onlyAdmin returns (uint)\\n    {\\n        AmountRemaining[_UniqueArtistsInvoked] = _Params._MaxSupply;\\n        Artists[_UniqueArtistsInvoked] = _Params;\\n        _UniqueArtistsInvoked++;\\n        return _UniqueArtistsInvoked - 1;\\n    }\\n\\n    /*-------------------------*/\\n    /*     ACCESS MODIFIERS    */\\n    /*-------------------------*/\\n\\n    /**\\n     * @dev Access Modifier That Allows Only BrightListed BRT Minters\\n     **/\\n    modifier onlyMinter() \\n    {\\n        require(Role[msg.sender] == _MINTER_ROLE, \\\"LiveMint | onlyMinter | Caller Is Not Approved BRT Minter\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Access Modifier That Allows Only Authorized Contracts\\n     */\\n    modifier onlyAdmin()\\n    {\\n        require(Role[msg.sender] == _AUTHORIZED || msg.sender == _LAUNCHPAD || msg.sender == owner(), \\\"LiveMint | onlyAdmin | Caller Is Not Approved Admin\\\");\\n        _;\\n    }\\n}\\ninterface IDelegationRegistry\\n{\\n    /**\\n     * @dev Checks If A Vault Has Delegated To The Delegate\\n     */\\n    function checkDelegateForAll(address delegate, address delegator) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/Marketplace.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/**\\n * @dev: @brougkr\\n */\\npragma solidity 0.8.19;\\nimport { ReentrancyGuard } from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport { MerkleProof } from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { IMinter } from \\\"./IMinter.sol\\\";\\nimport { DelegateCashEnabled } from \\\"./DelegateCashEnabled.sol\\\";\\ncontract Marketplace is Ownable, ReentrancyGuard, DelegateCashEnabled\\n{\\n    struct PresaleSale \\n    {\\n        address _Operator;\\n        address _NFT;\\n        uint _MaxForSale;\\n        uint _MaxPerPurchase;\\n        uint _PricePresale;\\n        uint _PricePublic;\\n        uint _TimestampEndFullSet;\\n        uint _TimestampEndCitizen;\\n        uint _TimestampSaleStart;\\n        uint _Type;\\n        uint _ProjectID;\\n    }\\n\\n    struct InternalPresaleSale\\n    {\\n        bool _Active;\\n        uint _AmountSold;\\n        uint _GlobalPurchasesFullSet;\\n        uint _GlobalPurchasesCitizen;\\n        uint _GlobalPurchasesPublic;\\n        uint _CurrentTokenIndex;\\n        uint _AmountSoldFullSet;\\n        uint _AmountSoldCitizen;\\n        uint _AmountSoldPublic;\\n    }\\n\\n    struct InternalPresaleSaleRoots\\n    {\\n        bytes32 _RootEligibilityFullSet;\\n        bytes32 _RootEligibilityCitizen;\\n        bytes32 _RootAmountFullSet;\\n        bytes32 _RootAmountCitizen;\\n    }\\n\\n    struct InternalWalletInfo    \\n    {\\n        uint _AmountPurchasedFullSetWindow;\\n        uint _AmountPurchasedCitizenWindow;\\n        uint _AmountPurchasedWallet;\\n    }\\n\\n    struct WalletSaleInfo\\n    {\\n        uint _PricePresale;\\n        uint _PricePublic;\\n        uint _AmountSold;\\n        uint _MintPassesAvailable;\\n        uint _MintPassesRemaining;\\n        uint _TimestampEndFullSet;\\n        uint _TimestampEndCitizen;\\n        uint _TimestampSaleStart;\\n        uint _AmountPurchasableFullSet;\\n        uint _AmountPurchasableCitizen;\\n        uint _AmountPurchasedFullSetWindow;\\n        uint _AmountPurchasedCitizenWindow;\\n        uint _GlobalPurchasesFullSet;\\n        uint _GlobalPurchasesCitizen;\\n        uint _GlobalPurchasesPublic;\\n        uint _AmountPurchasedWallet;\\n        bool _EligibleFullSet;\\n        bool _EligibleCitizen;\\n        bool _ValidMaxAmountFullSet;\\n        bool _ValidMaxAmountCitizen;\\n    }\\n\\n    struct Sale\\n    {\\n        uint _Price;\\n        uint _MintPassProjectID;\\n        uint _Type;\\n        uint _ABProjectID;\\n        uint _AmountForSale;\\n        uint _TimestampStart;\\n        address _NFT;\\n        bytes32 _Root;\\n    }\\n\\n    struct FixedPriceSaleInfo\\n    {\\n        uint _Price;\\n        uint _AmountForSale;\\n        uint _AmountSold;\\n        uint _TimestampStart;\\n        uint _Priority;\\n        bool _BrightlistEligible;\\n        bytes32 _Root;\\n    }\\n\\n    struct SaleInfo\\n    {\\n        uint _PricePresale;\\n        uint _PricePublic;\\n        uint _AmountSold;\\n        uint _MintPassesAvailable;\\n        uint _MintPassesRemaining;\\n        uint _TimestampEndFullSet;\\n        uint _TimestampEndCitizen;\\n        uint _TimestampSaleStart;\\n        uint _GlobalPurchasesFullSet;\\n        uint _GlobalPurchasesCitizen;\\n        uint _GlobalPurchasesPublic;\\n    }\\n\\n    /*------------------\\n     * STATE VARIABLES *\\n    -------------------*/\\n\\n    uint public _TOTAL_UNIQUE_SALES; // Total Unique Presale Sales                \\n    address private constant _BRT_MULTISIG = 0x0BC56e3c1397e4570069e89C07936A5c6020e3BE; // `sales.brightmoments.eth`\\n    \\n    /*-----------\\n     * MAPPINGS *\\n    ------------*/\\n\\n    mapping(uint=>Sale) public FixedPriceSales;\\n    mapping(uint=>uint) public AmountSold;\\n    mapping(uint=>uint[]) public DiscountAmounts;\\n    mapping(address=>bool) public Admin;  \\n    mapping(uint=>PresaleSale) public PresaleSales;                           \\n    mapping(uint=>InternalPresaleSale) public PresaleSalesInternal;            \\n    mapping(uint=>InternalPresaleSaleRoots) public InternalRoots;              \\n    mapping(uint=>mapping(address=>InternalWalletInfo)) public InternalSaleWalletInfo;\\n\\n    event PurchasedPresale(uint SaleIndex, address Purchaser, uint DesiredAmount, uint MessageValue, bool PresaleEnded);    \\n    event SaleStarted(uint SaleIndex);\\n    event Refunded(address Refundee, uint Amount);\\n    event Purchased(uint SaleIndex, address Purchaser, uint Amount);\\n    event Fullset();\\n    event Citizen();\\n    event Public();\\n\\n    constructor() \\n    { \\n        Admin[msg.sender] = true; \\n        Admin[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true;\\n        Admin[0x90D98d5A1fD21B7cEa4D5c18341607ed1a8345c0] = true;\\n        Admin[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = true;\\n        _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700);\\n    }\\n\\n    /*---------------------\\n     * EXTERNAL FUNCTIONS *\\n    ----------------------*/\\n\\n    /**\\n     * @dev Presale Purchase\\n     */\\n    function PurchasePresale (\\n        uint SaleIndex,                // Index Of Sale\\n        uint DesiredAmount,            // Desired Purchase Amount\\n        uint MaxAmount,                // Maximum Purchase Allocation Per Wallet\\n        address Vault,                 // Delegate.Cash Delegation Registry\\n        bytes32[] calldata Proof,      // MerkleProof For Eligibility\\n        bytes32[] calldata ProofAmount // MerkleProof For MaxAmount\\n    ) external payable nonReentrant {\\n        require(tx.origin == msg.sender, \\\"Marketplace: EOA Only\\\");\\n        require(block.timestamp >= PresaleSales[SaleIndex]._TimestampSaleStart, \\\"Marketplace: Sale Not Started\\\");\\n        address Recipient = msg.sender;\\n        if(Vault != address(0)) { if(DelegateCash.checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } }\\n        InternalPresaleSale memory _InternalPresaleSale = PresaleSalesInternal[SaleIndex];\\n        PresaleSale memory _PresaleSale = PresaleSales[SaleIndex];\\n        bool PresaleEnded;\\n        uint _Price;\\n        uint _MaxPerPurchase = _PresaleSale._MaxPerPurchase;\\n        if(_InternalPresaleSale._AmountSold + DesiredAmount > _PresaleSale._MaxForSale) \\n        { \\n            DesiredAmount = _PresaleSale._MaxForSale - _InternalPresaleSale._AmountSold; // Partial Fill\\n        } \\n        if(block.timestamp <= _PresaleSale._TimestampEndCitizen) // Presale\\n        {\\n            if(block.timestamp <= _PresaleSale._TimestampEndFullSet) // Full Set Window\\n            { \\n                require ( // Eligible For Full Set Window\\n                    VerifyBrightList(Recipient, InternalRoots[SaleIndex]._RootEligibilityFullSet, Proof), \\n                    \\\"Full Set Window: Not Eligible For Presale Window Or Block Pending, Please Try Again In A Few Seconds...\\\"\\n                ); \\n                require(VerifyAmount(Recipient, MaxAmount, InternalRoots[SaleIndex]._RootAmountFullSet, ProofAmount), \\\"Invalid Full Set Amount Proof\\\");\\n                require(InternalSaleWalletInfo[SaleIndex][Recipient]._AmountPurchasedWallet + DesiredAmount <= MaxAmount, \\\"All Full Set Allocation Used\\\");\\n                InternalSaleWalletInfo[SaleIndex][Recipient]._AmountPurchasedFullSetWindow += DesiredAmount;\\n                PresaleSalesInternal[SaleIndex]._GlobalPurchasesFullSet += DesiredAmount;\\n                emit Fullset();\\n            }\\n            else // Citizen Window\\n            { \\n                require ( // Eligible For Citizen Window\\n                    VerifyBrightList(Recipient, InternalRoots[SaleIndex]._RootEligibilityCitizen, Proof), \\n                    \\\"Citizen Window: Not Eligible For Presale Window Or Block Pending, Please Try Again In A Few Seconds...\\\"\\n                ); \\n                require(VerifyAmount(Recipient, MaxAmount, InternalRoots[SaleIndex]._RootAmountCitizen, ProofAmount), \\\"Invalid Citizen Amount Proof\\\");\\n                require(InternalSaleWalletInfo[SaleIndex][Recipient]._AmountPurchasedCitizenWindow + DesiredAmount <= MaxAmount, \\\"All Citizen Allocation Used\\\");\\n                InternalSaleWalletInfo[SaleIndex][Recipient]._AmountPurchasedWallet += DesiredAmount;\\n                PresaleSalesInternal[SaleIndex]._GlobalPurchasesCitizen += DesiredAmount;\\n                emit Citizen();\\n            } \\n            _Price = _PresaleSale._PricePresale * DesiredAmount;\\n        }\\n        else // Public Sale\\n        { \\n            _Price = _PresaleSale._PricePublic * DesiredAmount;\\n            PresaleSalesInternal[SaleIndex]._GlobalPurchasesPublic += DesiredAmount;\\n            PresaleEnded = true; \\n            emit Public();\\n        }\\n        require(DesiredAmount <= _MaxPerPurchase, \\\"Invalid Desired Purchase Amount. Must Be <= Max Purchase Limit\\\"); // Purchase Limiter\\n        require(_InternalPresaleSale._AmountSold + DesiredAmount <= _PresaleSale._MaxForSale, \\\"Sale Ended\\\"); // Sale End State\\n        require(DesiredAmount > 0 && _Price > 0, \\\"Sale Ended\\\"); // Sale End State\\n        require(msg.value >= _Price, \\\"Invalid ETH Amount\\\"); // Ensures ETH Amount Sent Is Correct\\n        if(msg.value > _Price) { __Refund(msg.sender, msg.value - _Price); } // Refunds The Difference\\n        if(_PresaleSale._Type == 0) { IMinter(_PresaleSale._NFT)._MintToFactory(0, msg.sender, DesiredAmount); }\\n        else if (_PresaleSale._Type == 1) \\n        { \\n            for(uint x; x < DesiredAmount; x++) { IMinter(_PresaleSale._NFT).purchaseTo(msg.sender, _PresaleSale._ProjectID); }\\n        }\\n        PresaleSalesInternal[SaleIndex]._AmountSold += DesiredAmount;\\n        PresaleSalesInternal[SaleIndex]._CurrentTokenIndex += DesiredAmount;\\n        InternalSaleWalletInfo[SaleIndex][Recipient]._AmountPurchasedWallet += DesiredAmount;\\n        emit PurchasedPresale(SaleIndex, Recipient, DesiredAmount, msg.value, PresaleEnded);\\n    }\\n\\n    /**\\n     * @dev Fixed Price Purchase\\n     */\\n    function PurchaseFixedPrice(uint SaleIndex, uint Amount, bytes32[] calldata Proof) external payable nonReentrant\\n    {\\n        require(tx.origin == msg.sender, \\\"Marketplace: EOA Only\\\");\\n        require(block.timestamp >= FixedPriceSales[SaleIndex]._TimestampStart, \\\"Marketplace: Sale Not Started\\\");\\n        (bool Brightlist, uint Priority) = VerifyBrightListWithPriority(SaleIndex, msg.sender, FixedPriceSales[SaleIndex]._Root, Proof);\\n        if(Brightlist)  \\n        {\\n            require (\\n                msg.value \\n                == \\n                (((FixedPriceSales[SaleIndex]._Price * Amount) * DiscountAmounts[SaleIndex][Priority] ) / 100), \\n                \\\"Marketplace: Incorrect ETH Amount Sent\\\"\\n            );\\n        }\\n        else { require(msg.value == FixedPriceSales[SaleIndex]._Price * Amount, \\\"Marketplace: Incorrect ETH Amount Sent\\\"); }\\n        require(AmountSold[SaleIndex] + Amount <= FixedPriceSales[SaleIndex]._AmountForSale, \\\"Marketplace: Not Enough NFTs Left For Sale\\\");\\n        AmountSold[SaleIndex] = AmountSold[SaleIndex] + Amount;\\n        if(FixedPriceSales[SaleIndex]._Type == 0) // Factory MintPass Direct Mint\\n        { \\n            IMinter(FixedPriceSales[SaleIndex]._NFT)._MintToFactory(FixedPriceSales[SaleIndex]._MintPassProjectID, msg.sender, Amount); \\n        }\\n        else // ArtBlocks Style purchaseTo() Mint\\n        { \\n            uint ProjectID = FixedPriceSales[SaleIndex]._ABProjectID;\\n            for(uint x; x < Amount; x++) { IMinter(FixedPriceSales[SaleIndex]._NFT).purchaseTo(msg.sender, ProjectID); }\\n        } \\n        emit Purchased(SaleIndex, msg.sender, Amount);\\n    }\\n\\n    /*------------------\\n     * ADMIN FUNCTIONS *\\n    -------------------*/\\n\\n    /**\\n     * @dev Instantiates A New Presale Sale\\n     */\\n    function __StartPresaleSale (\\n        PresaleSale memory _Sale,\\n        InternalPresaleSaleRoots memory _Roots\\n    ) external onlyAdmin { \\n        PresaleSales[_TOTAL_UNIQUE_SALES] = _Sale; \\n        PresaleSalesInternal[_TOTAL_UNIQUE_SALES]._Active = true;\\n        InternalRoots[_TOTAL_UNIQUE_SALES] = _Roots;\\n        emit SaleStarted(_TOTAL_UNIQUE_SALES);\\n        _TOTAL_UNIQUE_SALES++;\\n    }\\n\\n    /**\\n     * @dev Overwrites A Presale Sale\\n     */\\n    function __OverwritePresaleSale(uint SaleIndex, PresaleSale memory _Sale) external onlyAdmin { PresaleSales[SaleIndex] = _Sale; }\\n    \\n    /**\\n     * @dev Changes The Presale Sale Type\\n     */\\n    function __ChangePresaleType(uint SaleIndex, uint Type) external onlyAdmin\\n    {\\n        PresaleSales[SaleIndex]._Type = Type;\\n    }\\n\\n    /**\\n     * @dev Changes Presale ArtBlocks ProjectID\\n     */\\n    function __ChangePresaleProjectID(uint SaleIndex, uint ProjectID) external onlyAdmin\\n    {\\n        PresaleSales[SaleIndex]._ProjectID = ProjectID;\\n    }\\n\\n    /**\\n     * @dev Changes Presale Times\\n     */\\n    function __ChangePresaleTimes (\\n        uint SaleIndex,\\n        uint TimestampSaleStart,\\n        uint TimestampFullSetEnd,\\n        uint TimestampCitizenEnd\\n    ) external onlyAdmin {\\n        PresaleSales[SaleIndex]._TimestampSaleStart = TimestampSaleStart;\\n        PresaleSales[SaleIndex]._TimestampEndFullSet = TimestampFullSetEnd;\\n        PresaleSales[SaleIndex]._TimestampEndCitizen = TimestampCitizenEnd;\\n    }\\n\\n    /**\\n     * @dev Changes All Presale Roots\\n     */\\n    function __ChangePresaleRootsAll (\\n        uint SaleIndex,\\n        bytes32 RootEligibilityFullSet,\\n        bytes32 RootAmountsFullSet,\\n        bytes32 RootEligibilityCitizen,\\n        bytes32 RootAmountsCitizen\\n    ) external onlyAdmin { \\n        InternalRoots[SaleIndex]._RootEligibilityFullSet = RootEligibilityFullSet;\\n        InternalRoots[SaleIndex]._RootEligibilityCitizen = RootEligibilityCitizen;\\n        InternalRoots[SaleIndex]._RootAmountFullSet = RootAmountsFullSet;\\n        InternalRoots[SaleIndex]._RootAmountCitizen = RootAmountsCitizen;\\n    }\\n\\n    /**\\n     * @dev Changes The Presale Roots For Merkle Eligibility\\n     */\\n    function __ChangePresaleRootsEligibility (\\n        uint SaleIndex, \\n        bytes32 RootCitizen,\\n        bytes32 RootFullSet\\n    ) external onlyAdmin {\\n        InternalRoots[SaleIndex]._RootEligibilityCitizen = RootCitizen;\\n        InternalRoots[SaleIndex]._RootEligibilityFullSet = RootFullSet;\\n    }\\n\\n    /**\\n     * @dev Changes The Presale Roots For Merkle Amounts\\n     */\\n    function __ChangePresaleRootsAmounts (\\n        uint SaleIndex,\\n        bytes32 RootCitizen,\\n        bytes32 RootFullSet\\n    ) external onlyAdmin {\\n        InternalRoots[SaleIndex]._RootAmountCitizen = RootCitizen;\\n        InternalRoots[SaleIndex]._RootAmountFullSet = RootFullSet;\\n    }\\n\\n    /**\\n     * @dev Changes Presale Sale Max For Sale\\n     */\\n    function __ChangePresaleSaleMaxForSale(uint SaleIndex, uint MaxForSale) external onlyAdmin \\n    {   \\n        require(PresaleSalesInternal[SaleIndex]._Active, \\\"Marketplace: Sale Not Active\\\");\\n        PresaleSales[SaleIndex]._MaxForSale = MaxForSale; \\n    }\\n\\n    /**\\n     * @dev Change Presale Sale Max Per Purchase\\n     */\\n    function __ChangePresaleSaleMaxPerPurchase(uint SaleIndex, uint MaxPerPurchase) external onlyAdmin \\n    {   \\n        require(PresaleSalesInternal[SaleIndex]._Active, \\\"Marketplace: Sale Not Active\\\");\\n        PresaleSales[SaleIndex]._MaxPerPurchase = MaxPerPurchase; \\n    }\\n\\n    /**\\n     * @dev Changes Presale Sale Mint Pass Price\\n     */\\n    function __ChangePresaleSalePresalePrice(uint SaleIndex, uint Price) external onlyAdmin \\n    {   \\n        require(PresaleSalesInternal[SaleIndex]._Active, \\\"Marketplace: Sale Not Active\\\");\\n        PresaleSales[SaleIndex]._PricePresale = Price; \\n    }\\n\\n    /**\\n     * @dev Changes Presale Sale Public Price\\n     */\\n    function __ChangePresaleSalePublicPrice(uint SaleIndex, uint Price) external onlyAdmin \\n    {   \\n        require(PresaleSalesInternal[SaleIndex]._Active, \\\"Marketplace: Sale Not Active\\\");\\n        PresaleSales[SaleIndex]._PricePublic = Price; \\n    }\\n\\n    /**\\n     * @dev Changes Timestamp End Full Set\\n     */\\n    function __ChangePresaleSaleEndFullSet(uint SaleIndex, uint Timestamp) external onlyAdmin \\n    {   \\n        require(PresaleSalesInternal[SaleIndex]._Active, \\\"Marketplace: Sale Not Active\\\");\\n        PresaleSales[SaleIndex]._TimestampEndFullSet = Timestamp; \\n    }\\n\\n    /**\\n     * @dev Changes Timestamp End Citizen\\n     */\\n    function __ChangePresaleSaleEndCitizen(uint SaleIndex, uint Timestamp) external onlyAdmin\\n    {\\n        require(PresaleSalesInternal[SaleIndex]._Active, \\\"Marketplace: Sale Not Active\\\");\\n        PresaleSales[SaleIndex]._TimestampEndCitizen = Timestamp; \\n    }\\n\\n    /**\\n     * @dev Changes Timestamp Sale Start\\n     */\\n    function __ChangePresaleSaleStart(uint SaleIndex, uint Timestamp) external onlyAdmin\\n    {\\n        require(PresaleSalesInternal[SaleIndex]._Active, \\\"Marketplace: Sale Not Active\\\");\\n        PresaleSales[SaleIndex]._TimestampSaleStart = Timestamp; \\n    }\\n\\n    /**\\n     * @dev Changes Presale Sale Full Set Root\\n     */\\n    function __ChangePresaleSaleRootFullSet(uint SaleIndex, bytes32 RootFullSet) external onlyAdmin \\n    { \\n        InternalRoots[SaleIndex]._RootEligibilityFullSet = RootFullSet; \\n    }\\n\\n    /**\\n     * @dev Changes Presale Sale Citizen Root\\n     */\\n    function __ChangePresaleSaleRootCitizen(uint SaleIndex, bytes32 RootCitizen) external onlyAdmin\\n    {\\n        InternalRoots[SaleIndex]._RootAmountCitizen = RootCitizen; \\n    }\\n\\n    /**\\n     * @dev Initializes A Sale Via A Struct\\n     */\\n    function __StartFixedPriceSale (\\n        uint SaleIndex, \\n        Sale memory _Sale, \\n        uint[] calldata Discounts\\n    ) external onlyAdmin { \\n        FixedPriceSales[SaleIndex] = _Sale; \\n        DiscountAmounts[SaleIndex] = Discounts;\\n    }\\n\\n    /**\\n     * @dev Changes Presale Sale Discount Amounts (IN BIPS)\\n     */\\n    function __ChangeFixedPriceDiscountAmounts(uint SaleIndex, uint[] calldata Discounts) external onlyAdmin\\n    {\\n        DiscountAmounts[SaleIndex] = Discounts;\\n    }\\n\\n    /**\\n     * @dev Changes The NFT Address Of A Sale\\n     */\\n    function __ChangeFixedPriceNFTAddress(uint SaleIndex, address NewAddress) external onlyAdmin { FixedPriceSales[SaleIndex]._NFT = NewAddress; }\\n\\n    /**\\n     * @dev Changes The Price Of A Sale\\n     */\\n    function __ChangeFixedPrice(uint SaleIndex, uint Price) external onlyAdmin { FixedPriceSales[SaleIndex]._Price = Price; }\\n\\n    /**\\n     * @dev Changes The MintPass ProjectID\\n     */\\n    function __ChangeFixedPriceMintPassProjectID(uint SaleIndex, uint MintPassProjectID) external onlyAdmin \\n    { \\n        FixedPriceSales[SaleIndex]._MintPassProjectID = MintPassProjectID; \\n    }\\n\\n    /**\\n     * @dev Changes The ArtBlocks ProjectID\\n     */\\n    function __ChangeFixedPriceABProjectID(uint SaleIndex, uint ABProjectID) external onlyAdmin { FixedPriceSales[SaleIndex]._ABProjectID = ABProjectID; }\\n\\n    /**\\n     * @dev Changes The Amount Of NFTs For Sale\\n     */\\n    function __ChangeFixedPriceAmountForSale(uint SaleIndex, uint AmountForSale) external onlyAdmin { FixedPriceSales[SaleIndex]._AmountForSale = AmountForSale; }\\n\\n    /**\\n     * @dev Changes The Type Of A Sale\\n     */\\n    function __ChangeFixedPriceType(uint SaleIndex, uint Type) external onlyAdmin { FixedPriceSales[SaleIndex]._Type = Type; }\\n\\n    /*--------------*/\\n    /*  ONLY OWNER  */\\n    /*--------------*/\\n\\n    /**\\n     * @dev onlyOwner: Grants Admin Role\\n     */\\n    function ___AdminGrant(address _Admin) external onlyOwner { Admin[_Admin] = true; }\\n\\n    /**\\n     * @dev onlyOwner: Removes Admin Role\\n     */\\n    function ___AdminRemove(address _Admin) external onlyOwner { Admin[_Admin] = false; }\\n\\n    /**\\n     * @dev onlyOwner: Withdraws All Ether From The Contract\\n     */\\n    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\\n\\n    /**\\n     * @dev onlyOwner: Withdraws Ether From Contract To Address With An Amount\\n     */\\n    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\\n    {\\n        require(Amount > 0 && Amount <= address(this).balance, \\\"Invalid Amount\\\");\\n        (bool Success, ) = Recipient.call{value: Amount}(\\\"\\\");\\n        require(Success, \\\"Unable to Withdraw, Recipient May Have Reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Withdraws ETH To Multisig\\n     */\\n    function ___WithdrawETHToMultisig() external onlyOwner \\n    {\\n        (bool success,) = _BRT_MULTISIG.call { value: address(this).balance }(\\\"\\\"); \\n        require(success, \\\"Marketplace: ETH Withdraw Failed\\\"); \\n    }\\n\\n    /**\\n     * @dev Withdraws ERC721s From Contract\\n     */\\n    function ___WithdrawERC721(address Contract, address Recipient, uint[] calldata TokenIDs) external onlyOwner \\n    { \\n        for(uint TokenID; TokenID < TokenIDs.length;)\\n        {\\n            IERC721(Contract).transferFrom(address(this), Recipient, TokenIDs[TokenID]);\\n            unchecked { TokenID++; }\\n        }\\n    }\\n\\n    /*-----------------\\n     * VIEW FUNCTIONS *\\n    ------------------*/\\n\\n    /**\\n     * @dev Verifies Brightlist For Presale\\n     */\\n    function VerifyBrightList(address _Wallet, bytes32 _Root, bytes32[] calldata _Proof) public pure returns(bool)\\n    {\\n        bytes32 _Leaf = keccak256(abi.encodePacked(_Wallet));\\n        return MerkleProof.verify(_Proof, _Root, _Leaf);\\n    }\\n\\n    /**\\n     * @dev Verifies Brightlist For Presale Fixed Price Sale\\n     */\\n    function VerifyBrightListWithPriority(uint SaleIndex, address _Wallet, bytes32 _Root, bytes32[] calldata _Proof) public view returns (bool, uint)\\n    {\\n        bytes32 _Leaf = keccak256(abi.encodePacked(_Wallet));\\n        for(uint x; x < DiscountAmounts[SaleIndex].length; x++) { if(MerkleProof.verify(_Proof, _Root, _Leaf)) { return (true, x); } }\\n        return (false, 69420);\\n    }\\n\\n    /**\\n     * @dev Verifies Maximum Purchase Amount Being Passed Is Valid\\n     */\\n    function VerifyAmount(address _Wallet, uint _Amount, bytes32 _Root, bytes32[] calldata _Proof) public pure returns(bool)\\n    {\\n        bytes32 _Leaf = (keccak256(abi.encodePacked(_Wallet, _Amount)));\\n        return MerkleProof.verify(_Proof, _Root, _Leaf);\\n    }\\n\\n    /**\\n     * @dev Refunds `Recipient` ETH Amount `Value`\\n     */\\n    function __Refund(address Recipient, uint Value) internal\\n    {\\n        (bool Confirmed,) = Recipient.call{value: Value}(\\\"\\\"); \\n        require(Confirmed, \\\"Marketplace: Refund failed\\\");\\n        emit Refunded(Recipient, Value);\\n    }\\n\\n    /**\\n     * @dev Returns Sale Information for Presale Sale\\n     */\\n    function SaleInformation(uint SaleIndex) public view returns (SaleInfo memory) \\n    {\\n        PresaleSale memory _Sale = PresaleSales[SaleIndex];\\n        InternalPresaleSale memory _SaleInternal = PresaleSalesInternal[SaleIndex];\\n        uint AmountRemaining = _Sale._MaxForSale - PresaleSalesInternal[SaleIndex]._AmountSold;\\n        return SaleInfo (\\n            _Sale._PricePresale,\\n            _Sale._PricePublic,\\n            _SaleInternal._AmountSold,\\n            _Sale._MaxForSale,\\n            AmountRemaining,\\n            _Sale._TimestampEndFullSet,\\n            _Sale._TimestampEndCitizen,\\n            _Sale._TimestampSaleStart,\\n            _SaleInternal._GlobalPurchasesFullSet,\\n            _SaleInternal._GlobalPurchasesCitizen,\\n            _SaleInternal._GlobalPurchasesPublic\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns A Wallet's Sale Information For A Presale Sale\\n     */\\n    function WalletSaleInformation (\\n        uint SaleIndex,\\n        address Wallet,\\n        uint MaxAmountFullSet,\\n        uint MaxAmountCitizen,\\n        bytes32[] calldata FullsetProof, \\n        bytes32[] calldata CitizenProof,\\n        bytes32[] calldata ProofAmountFullSet,\\n        bytes32[] calldata ProofAmountCitizen\\n    ) public view returns (WalletSaleInfo memory) {\\n        uint AmountPurchaseableFullset;\\n        uint AmountPurchaseableCitizen;\\n        PresaleSale memory _Sale = PresaleSales[SaleIndex];\\n        InternalPresaleSale memory _SaleInternal = PresaleSalesInternal[SaleIndex];\\n        InternalWalletInfo memory _WalletInfo = InternalSaleWalletInfo[SaleIndex][Wallet];\\n        if(_WalletInfo._AmountPurchasedFullSetWindow >= MaxAmountFullSet) { AmountPurchaseableFullset = 0; }\\n        else { AmountPurchaseableFullset = MaxAmountFullSet - _WalletInfo._AmountPurchasedFullSetWindow; }\\n        if(_WalletInfo._AmountPurchasedCitizenWindow >= MaxAmountCitizen) { AmountPurchaseableCitizen = 0; }\\n        else { AmountPurchaseableCitizen = MaxAmountCitizen - _WalletInfo._AmountPurchasedCitizenWindow; }\\n        return WalletSaleInfo (\\n            _Sale._PricePresale, // _PricePresale\\n            _Sale._PricePublic, // _PricePublic\\n            _SaleInternal._AmountSold, // _AmountSold\\n            _Sale._MaxForSale, // _MintPassesAvailable\\n            _Sale._MaxForSale - _SaleInternal._AmountSold, // _MintPassesRemaining\\n            _Sale._TimestampEndFullSet, // _TimestampEndFullSet\\n            _Sale._TimestampEndCitizen, // _TimestampEndCitizen\\n            _Sale._TimestampSaleStart, // _TimestampSaleStart\\n            AmountPurchaseableFullset, // _AmountPurchasableFullSet\\n            AmountPurchaseableCitizen, // _AmountPurchasableCitizen\\n            _WalletInfo._AmountPurchasedFullSetWindow, // _AmountPurchasedFullSetWindow\\n            _WalletInfo._AmountPurchasedCitizenWindow, // _AmountPurchasedCitizenWindow\\n            _SaleInternal._GlobalPurchasesFullSet, // _GlobalPurchasesFullSet\\n            _SaleInternal._GlobalPurchasesCitizen, // _GlobalPurchasesCitizen\\n            _SaleInternal._GlobalPurchasesPublic, // _GlobalPurchasesPublic\\n            _WalletInfo._AmountPurchasedWallet, // _AmountPurchasedWallet\\n            VerifyBrightList(Wallet, InternalRoots[SaleIndex]._RootEligibilityFullSet, FullsetProof), // _EligibleFullSet\\n            VerifyBrightList(Wallet, InternalRoots[SaleIndex]._RootEligibilityCitizen, CitizenProof), // _EligibleCitizen\\n            VerifyAmount(Wallet, MaxAmountFullSet, InternalRoots[SaleIndex]._RootAmountFullSet, ProofAmountFullSet), // _ValidMaxAmountFullSet\\n            VerifyAmount(Wallet, MaxAmountCitizen, InternalRoots[SaleIndex]._RootAmountCitizen, ProofAmountCitizen) // _ValidMaxAmountCitizen\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns The Sale Info For A Fixed Price Sale\\n     */\\n    function ViewFixedPriceSaleInfo (\\n        uint SaleIndex,\\n        address Wallet,\\n        bytes32[] calldata Proof\\n    ) public view returns (FixedPriceSaleInfo memory) {\\n        uint Price = FixedPriceSales[SaleIndex]._Price;\\n        uint AmountForSale = FixedPriceSales[SaleIndex]._AmountForSale;\\n        uint AmountSoldFixed = AmountSold[SaleIndex];\\n        uint TimestampStart = FixedPriceSales[SaleIndex]._TimestampStart;\\n        (bool Eligible, uint Priority) = VerifyBrightListWithPriority(SaleIndex, Wallet, FixedPriceSales[SaleIndex]._Root, Proof);\\n        bytes32 Root = FixedPriceSales[SaleIndex]._Root;\\n        return FixedPriceSaleInfo(Price, AmountForSale, AmountSoldFixed, TimestampStart, Priority, Eligible, Root);\\n    }\\n\\n    /*-----------\\n     * MODIFIER *\\n    ------------*/\\n\\n    modifier onlyAdmin\\n    {\\n        require(Admin[msg.sender]);\\n        _;\\n    }\\n}\\n\\ninterface IERC20 { function approve(address From, address To, uint Amount) external; }\\ninterface IERC721 { function transferFrom(address From, address To, uint TokenID) external; }\"\r\n    },\r\n    \"contracts/MarketplaceEnabled.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/**\\n * @title MarketplaceEnabled\\n * @dev @brougkr\\n * note: This Contract Is Used To Enable DutchMarketplace To Purchase Tokens From Your Contract\\n * note: This Contract Should Be Imported and Included In The `is` Portion Of The Contract Declaration, ex. `contract NFT is Ownable, MarketplaceEnabled`\\n * note: You Can Copy Or Modify The Example Functions Below To Implement The Two Functions In Your Contract Required By MarketplaceEnabled\\n */\\npragma solidity 0.8.19;\\nabstract contract MarketplaceEnabled\\n{\\n    /**\\n     * @dev Marketplace Mint\\n     * note: Should Be Implemented With onlyMarketplace Access Modifier\\n     * note: Should Return The TokenID Being Transferred To The Recipient\\n     */\\n    function _MintToFactory(uint ProjectID, address Recipient, uint Amount) external virtual;\\n    // EXAMPLE:\\n    // function _MintToFactory(uint ProjectID, address Recipient, uint Amount) override virtual external onlyMarketplace\\n    // {\\n    //     require(totalSupply() + Amount <= 100, \\\"MP: Max Supply Reached\\\");\\n    //     _mint(Recipient, Amount); \\n    // }\\n\\n    /**\\n     * @dev ChangeMarketplaceAddress Changes The Marketplace Address | note: Should Be Implemented To Include onlyOwner Or Similar Access Modifier\\n     */\\n    function __ChangeMarketplaceAddress(address NewAddress) external virtual;\\n    // EXAMPLE: \\n    // function __ChangeMarketplaceAddress(address NewAddress) override virtual external onlyOwner { _MARKETPLACE = NewAddress; }\\n\\n    /**\\n     * @dev Marketplace Address\\n     */\\n    address public _MARKETPLACE_ADDRESS = 0x3725a379F90BeB320101453A0C75196C40749571; // GOERLI\\n    // address _MARKETPLACE_ADDRESS = 0x295f593B7A162B68b4353444cA622209492bCA2E; // MAINNET\\n\\n    /**\\n     * @dev Access Modifier For Marketplace\\n     */\\n    modifier onlyMarketplace\\n    {\\n        require(msg.sender == _MARKETPLACE_ADDRESS, \\\"onlyMarketplace: `msg.sender` Is Not The Marketplace Contract\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/MerkleClaimer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/**\\n * @dev: @brougkr\\n */\\npragma solidity 0.8.19;\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {MerkleProof} from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport {IMinter} from \\\"./IMinter.sol\\\";\\nimport {IMP} from \\\"./IMP.sol\\\";\\ncontract MerkleClaimer is Ownable, ReentrancyGuard\\n{\\n    /*-------------------*/\\n    /*      STRUCT       */\\n    /*-------------------*/\\n\\n    struct User\\n    {\\n        bool[] RegularClaim;\\n        uint _UserPurchasedAmount;\\n    }\\n\\n    struct Claim\\n    {\\n        string _Name;\\n        address _NFT; \\n        address _Operator; \\n        address _BurnNFT; \\n        uint _ClaimCost; \\n        uint _ProjectID; \\n        uint _ClaimableAmount; \\n        uint _AmountClaimed; \\n        bytes32 _Root; \\n    }\\n\\n    address private constant _BURN_ADDRESS = 0xcff43A597911a9457071d89d2b2AC3D5b1862b86;\\n    address private constant _DR = 0x00000000000076A84feF008CDAbe6409d2FE638B;\\n\\n    /*-------------------*/\\n    /*     MAPPINGS      */\\n    /*-------------------*/\\n\\n    mapping(uint=>Claim) public Claims;                               // [ClaimIndex] => Claim\\n    mapping(uint=>mapping(uint=>bool)) public ClaimedTokenID;         // [ClaimIndex][TokenID] => Minted\\n    mapping(uint=>mapping(address=>uint)) public UserPurchasedAmount; // [ClaimIndex][Wallet] => Total Purchased Amount\\n    \\n    /*-------------------*/\\n    /*      EVENTS       */\\n    /*-------------------*/\\n\\n    event TokensClaimed(address Redeemer, uint[] TokenIDs);\\n    event TokensClaimedAndBurned(address Redeemer, uint[] ClaimTokenIDs, uint[] BurnTokenIDs);\\n    event TokensClaimedPurchaseTo(address Redeemer, uint ProjectID, uint Amount);\\n\\n    /*-------------------*/\\n    /*    CONSTRUCTOR    */\\n    /*-------------------*/\\n\\n    constructor() \\n    { \\n        Claims[0] = Claim( \\n            'GTMX | Citizen',                           // [0] -> _Name\\n            0xa7923530DE01B7019688a6CB0ff5f5388185200f, // [1] -> _NFT\\n            0x93F01412C062C99C6ef105b1BAd93800B5635479, // [2] -> _Operator\\n            0x7581e6E514bac22B6303e92A5eAa4bfF3167142D, // [3] -> _BurnNFT\\n            0,                                          // [4] -> _ClaimCost\\n            0,                                          // [5] -> _ProjectID\\n            10,                                         // [6] -> _ClaimableAmount\\n            0,                                          // [7] -> _AmountClaimed\\n            0x80ed4a6987e367e9b9a580b9eea7c9f4459c5e64f69b43d72adc3ef29e519ef5 // [8] -> _Root\\n        );\\n        Claims[1] = Claim(\\n            'Spongenuity',                              // [0] -> _Name               \\n            0x7c3Ea2b7B3beFA1115aB51c09F0C9f245C500B18, // [1] -> _NFT\\n            0x5A9C8Ab74D4d42525Be6501140C4c77006fa0c18, // [2] -> _Operator\\n            address(0),                                 // [3] -> _BurnNFT\\n            0,                                          // [4] -> _ClaimCost\\n            0,                                          // [5] -> _ProjectID\\n            100,                                        // [6] -> _ClaimableAmount\\n            0,                                          // [7] -> _AmountClaimed\\n            0x9605a751aedb82194538399866198355d24c9ab5fc8e1c923078b54c818f9013 // [8] -> _Root\\n        );\\n        Claims[2] = Claim( \\n            'MPTK Option | MPTK',\\n            0xA636d716024fAf7Db5876DD817859984f00E7AEF, // [0] -> _NFT\\n            0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700, // [1] -> _Operator\\n            0x140D6adB981c8a0781326214f3c8154D2F01b6ac, // [2] -> _BurnNFT\\n            211959783913565000,                         // [3] -> _ClaimCost\\n            0,                                          // [4] -> _ProjectID\\n            100,                                        // [5] -> _ClaimableAmount\\n            0,                                          // [6] -> _AmountClaimed\\n            0x82b9b7a8cb49eeef9375e423cf350974c42f2a2da238b9fd59e5cd092ff6c9c8 // [8] -> _Root\\n        );\\n        Claims[3] = Claim(\\n            'AIR | March 2023 | Intricada | Camille Roux',\\n            0x7b9a45E278b5B374bb2d96C65665d4360C97BF01, // [0] -> _NFT\\n            address(0),                                 // [1] -> _Operator\\n            address(0),                                 // [2] -> _BurnNFT\\n            0,                                          // [3] -> _ClaimCost\\n            37,                                         // [4] -> _ProjectID\\n            6000,                                       // [5] -> _ClaimableAmount\\n            0,                                          // [6] -> _AmountClaimed\\n            0x49078eeb447ca042a99c4aa849693be36de6549fb9914d6581b49c6cd3aadff2 // [8] -> _Root\\n        );\\n        _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700); // `operator.brightmoments.eth`\\n    }\\n\\n    /*----------------------*/\\n    /*  EXTERNAL FUNCTIONS  */\\n    /*----------------------*/\\n\\n    /**\\n     * @dev Claims TokenID(s) With Merkle\\n     * note: transferFrom Implementation For NFT Transfer\\n     */\\n    function MerkleClaim (\\n        uint ClaimIndex,\\n        uint[] calldata TokenIDs,\\n        bytes32[][] calldata Proof,\\n        address Vault\\n    ) external payable nonReentrant {\\n        require(msg.value == (Claims[ClaimIndex]._ClaimCost * TokenIDs.length), \\\"Claimer: Invalid Message Value Sent\\\");\\n        require(Proof.length > 0 && TokenIDs.length > 0, \\\"Claimer: Invalid Input\\\");\\n        require(Proof.length == TokenIDs.length, \\\"Claimer: Arrays Must Match\\\");\\n        address Recipient = msg.sender;\\n        if(Vault != address(0)) { if(IDelegationRegistry(_DR).checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } } \\n        bool[] memory Eligibles = ReadEligibilityMerkleClaim(ClaimIndex, Recipient, TokenIDs, Proof);\\n        for(uint Index; Index < TokenIDs.length; Index++)\\n        {\\n            require(Eligibles[Index], \\\"Claimer: Invalid Merkle\\\");\\n            require(!ClaimedTokenID[ClaimIndex][TokenIDs[Index]], \\\"Claimer: NFT TokenID Already Claimed\\\");\\n            ClaimedTokenID[ClaimIndex][TokenIDs[Index]] = true;\\n            IERC721(Claims[ClaimIndex]._NFT).transferFrom(Claims[ClaimIndex]._Operator, msg.sender, TokenIDs[Index]);\\n        }\\n        emit TokensClaimed(msg.sender, TokenIDs);\\n    }\\n\\n    /**\\n     * @dev Claims TokenID(s) With Merkle\\n     * note: purchaseTo Implementation For NFT Transfer\\n     */\\n    function MerkleClaimPurchaseTo (\\n        uint ClaimIndex,\\n        uint DesiredAmount,\\n        uint MaxAmount,\\n        bytes32[] calldata Proof,\\n        address Vault\\n    ) external payable nonReentrant {\\n        address Recipient = msg.sender;\\n        if(Vault != address(0)) { if(IDelegationRegistry(_DR).checkDelegateForAll(msg.sender, Vault)) { Recipient = Vault; } } \\n        require(ReadEligibilityMerkleAmount(ClaimIndex, Recipient, MaxAmount, Proof), \\\"Claimer: Invalid Merkle\\\");\\n        require(msg.value == (Claims[ClaimIndex]._ClaimCost * DesiredAmount), \\\"Claimer: Invalid Message Value Sent\\\");\\n        require(DesiredAmount > 0 && UserPurchasedAmount[ClaimIndex][Recipient] + DesiredAmount <= MaxAmount, \\\"Claimer: Invalid DesiredAmount\\\");\\n        require(Claims[ClaimIndex]._ClaimableAmount >= Claims[ClaimIndex]._AmountClaimed + DesiredAmount, \\\"Claimer: Too Many\\\");\\n        UserPurchasedAmount[ClaimIndex][Recipient] += DesiredAmount;\\n        Claims[ClaimIndex]._AmountClaimed += DesiredAmount;\\n        for(uint Index; Index < DesiredAmount; Index++) { IMinter(Claims[ClaimIndex]._NFT).purchaseTo(msg.sender, Claims[ClaimIndex]._ProjectID); }\\n        emit TokensClaimedPurchaseTo(msg.sender, Claims[ClaimIndex]._ProjectID, DesiredAmount);\\n    }\\n\\n    /**\\n     * @dev Claims TokenID(s) With Merkle\\n     * note: This Is For 1:1 Mapping Burn To Redeem. Ex. Burn (NFT A TokenID 1) for (NFT B TokenID 90069420)\\n     * note: transferFrom Implementation For NFT Burn & Transfer\\n     */\\n    function MerkleClaimAndBurn (\\n        uint ClaimIndex,\\n        uint[] calldata BurnTokenIDs,\\n        uint[] calldata ClaimTokenIDs,\\n        bytes32[][] calldata Proof\\n    ) external payable nonReentrant {\\n        require(msg.value == (Claims[ClaimIndex]._ClaimCost * ClaimTokenIDs.length), \\\"Claimer: Invalid Message Value Sent\\\");\\n        require(Proof.length > 0 && BurnTokenIDs.length > 0 && ClaimTokenIDs.length > 0, \\\"Claimer: Invalid Input\\\");\\n        require(BurnTokenIDs.length == ClaimTokenIDs.length && ClaimTokenIDs.length == Proof.length, \\\"Claimer: Arrays Must Match\\\");\\n        bool[] memory Eligibles = ReadEligibilityMerkleClaimAndBurn(ClaimIndex, BurnTokenIDs, ClaimTokenIDs, Proof);\\n        for(uint Index; Index < BurnTokenIDs.length; Index++)\\n        {\\n            require(IERC721(Claims[ClaimIndex]._BurnNFT).ownerOf(BurnTokenIDs[Index]) == msg.sender, \\\"Claimer: User Does Not Own Input TokenID\\\");\\n            IERC721(Claims[ClaimIndex]._BurnNFT).transferFrom(msg.sender, _BURN_ADDRESS, BurnTokenIDs[Index]);\\n            require(Eligibles[Index], \\\"Claimer: Invalid Merkle\\\");\\n            require(!ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]], \\\"Claimer: NFT Already Claimed\\\");\\n            ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]] = true;\\n            IERC721(Claims[ClaimIndex]._NFT).transferFrom(Claims[ClaimIndex]._Operator, msg.sender, ClaimTokenIDs[Index]);\\n        }\\n        emit TokensClaimedAndBurned(msg.sender, ClaimTokenIDs, BurnTokenIDs);\\n    }\\n\\n    /**\\n     * @dev Claims TokenID(s) With Merkle\\n     * note: This Is For 1:1 Mapping Burn To Redeem. Ex. Burn (NFT A TokenID 1) for (NFT B TokenID 90069420)\\n     * note: transferFrom Implementation For NFT Burn & Transfer\\n     */\\n    function MerkleClaimAndBurnLive (\\n        uint ClaimIndex,\\n        uint[] calldata BurnTokenIDs,\\n        uint[] calldata ClaimTokenIDs,\\n        bytes32[][] calldata Proof\\n    ) external payable nonReentrant {\\n        require(msg.value == (Claims[ClaimIndex]._ClaimCost * ClaimTokenIDs.length), \\\"Claimer: Invalid Message Value Sent\\\");\\n        require(Proof.length > 0 && BurnTokenIDs.length > 0 && ClaimTokenIDs.length > 0, \\\"Claimer: Invalid Input\\\");\\n        require(BurnTokenIDs.length == ClaimTokenIDs.length && ClaimTokenIDs.length == Proof.length, \\\"Claimer: Arrays Must Match\\\"); \\n        bool[] memory Eligibles = ReadEligibilityMerkleClaimAndBurn(ClaimIndex, BurnTokenIDs, ClaimTokenIDs, Proof);\\n        for(uint Index; Index < BurnTokenIDs.length; Index++)\\n        {\\n            require(IERC721(Claims[ClaimIndex]._BurnNFT).ownerOf(BurnTokenIDs[Index]) == msg.sender, \\\"Claimer: User Does Not Own Input TokenID\\\");\\n            require(Eligibles[Index], \\\"Claimer: Invalid Merkle\\\");\\n            IMP(Claims[ClaimIndex]._BurnNFT)._LiveMintBurn(BurnTokenIDs[Index]);\\n            require(!ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]], \\\"Claimer: NFT Already Claimed\\\");\\n            ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]] = true;\\n            IERC721(Claims[ClaimIndex]._NFT).transferFrom(Claims[ClaimIndex]._Operator, msg.sender, ClaimTokenIDs[Index]);\\n        }\\n        emit TokensClaimedAndBurned(msg.sender, ClaimTokenIDs, BurnTokenIDs);\\n    }\\n\\n    /*-------------------*/\\n    /*  OWNER FUNCTIONS  */\\n    /*-------------------*/\\n\\n    /**\\n     * @dev Approves ERC20 Address For Claim\\n     */\\n    function __ApproveERC20(uint ClaimIndex, address ERC20) external onlyOwner \\n    { \\n        IERC20(ERC20).approve(Claims[ClaimIndex]._NFT, type(uint).max); \\n    }\\n\\n    /**\\n     * @dev Starts A New Claim\\n     */\\n    function __NewClaim(\\n        uint ClaimIndex,\\n        string calldata Name,\\n        address NFT,\\n        address Operator,\\n        address BurnNFT,\\n        uint ClaimCost,\\n        uint ProjectID,\\n        uint PurchaseableAmount,\\n        bytes32 Root\\n    ) external onlyOwner {\\n        Claims[ClaimIndex] = Claim(\\n            Name,\\n            NFT,\\n            Operator,\\n            BurnNFT,\\n            ClaimCost,\\n            ProjectID,\\n            PurchaseableAmount,\\n            0,\\n            Root\\n        );\\n    }\\n\\n    \\n    /**\\n     * @dev Changes NFT\\n     */\\n    function __ChangeNFT(uint ClaimIndex, address NFT) external onlyOwner { Claims[ClaimIndex]._NFT = NFT; }\\n\\n    /**\\n     * @dev Changes Operator\\n     */\\n    function __ChangeOperator(uint ClaimIndex, address Operator) external onlyOwner { Claims[ClaimIndex]._Operator = Operator; }\\n\\n    /**\\n     * @dev Changes BurnNFT\\n     */\\n    function __ChangeBurnNFT(uint ClaimIndex, address BurnNFT) external onlyOwner { Claims[ClaimIndex]._BurnNFT = BurnNFT; }\\n\\n    /**\\n     * @dev Changes ClaimCost\\n     */\\n    function __ChangeClaimCost(uint ClaimIndex, uint ClaimCost) external onlyOwner { Claims[ClaimIndex]._ClaimCost = ClaimCost; }\\n\\n    /**\\n     * @dev Changes ProjectID\\n     */\\n    function __ChangeProjectID(uint ClaimIndex, uint ProjectID) external onlyOwner { Claims[ClaimIndex]._ProjectID = ProjectID; }\\n    \\n    /**\\n     * @dev Changes PurchaseableAmount\\n     */\\n    function __ChangePurchaseableAmount(uint ClaimIndex, uint PurchaseableAmount) external onlyOwner { Claims[ClaimIndex]._ClaimableAmount = PurchaseableAmount; }\\n\\n    /**\\n     * @dev Changes Root\\n     */\\n    function __ChangeRoot(uint ClaimIndex, bytes32 Root) external onlyOwner { Claims[ClaimIndex]._Root = Root; }\\n\\n    /**\\n     * @dev Withdraws All Ether From The Contract\\n     */\\n    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\\n\\n    /**\\n     * @dev Withdraws Ether From Contract To Address With An Amount\\n     */\\n    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\\n    {\\n        require(Amount > 0 && Amount <= address(this).balance, \\\"Claimer: Invalid Amount\\\");\\n        (bool Success, ) = Recipient.call{value: Amount}(\\\"\\\");\\n        require(Success, \\\"Claimer: Unable to Withdraw, Recipient May Have Reverted\\\");\\n    }\\n\\n    /*------------------*/\\n    /*  VIEW FUNCTIONS  */\\n    /*------------------*/\\n\\n    /**\\n     * @dev Returns A Wallet's Merkle Eligibility\\n     */\\n    function ReadEligibilityMerkleClaim (\\n        uint ClaimIndex,\\n        address Wallet,\\n        uint[] calldata TokenIDs,\\n        bytes32[][] calldata Proof\\n    ) public view returns (bool[] memory) {\\n        bool[] memory Eligibles = new bool[](TokenIDs.length);\\n        for(uint Index; Index < TokenIDs.length; Index++)\\n        {\\n            bytes32 Leaf = keccak256(abi.encodePacked(Wallet, TokenIDs[Index]));\\n            if(!ClaimedTokenID[ClaimIndex][TokenIDs[Index]]) { Eligibles[Index] = MerkleProof.verify(Proof[Index], Claims[ClaimIndex]._Root, Leaf); }\\n        }\\n        return Eligibles;\\n    }\\n\\n    /**\\n     * @dev Returns A Wallet's Merkle Eligibility\\n     */\\n    function ReadEligibilityMerkleClaimAndBurn (\\n        uint ClaimIndex,\\n        uint[] calldata BurnTokenIDs, \\n        uint[] calldata ClaimTokenIDs,\\n        bytes32[][] calldata Proof\\n    ) public view returns (bool[] memory) {\\n        bool[] memory Eligibles = new bool[](BurnTokenIDs.length);\\n        for(uint Index; Index < BurnTokenIDs.length; Index++)\\n        {\\n            bytes32 Leaf = keccak256(abi.encodePacked(BurnTokenIDs[Index], ClaimTokenIDs[Index]));\\n            if(!ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]]) { Eligibles[Index] = MerkleProof.verify(Proof[Index], Claims[ClaimIndex]._Root, Leaf); }\\n        }\\n        return Eligibles;\\n    }\\n\\n    /**\\n     * @dev Returns A Wallet's Merkle Eligibility\\n     * note: For Claims Where There Is A Derived Max Amount Per Wallet\\n     */\\n    function ReadEligibilityMerkleAmount (\\n        uint ClaimIndex,\\n        address Wallet,\\n        uint MaxAmount,\\n        bytes32[] calldata Proof\\n    ) public view returns (bool) {\\n        bytes32 Leaf = keccak256(abi.encodePacked(Wallet, MaxAmount));\\n        return MerkleProof.verify(Proof, Claims[ClaimIndex]._Root, Leaf);\\n    }\\n\\n    /**\\n     * @dev Returns Merkle Eligibilities\\n     */\\n    function ReadEligibility (\\n        uint ClaimIndex,\\n        address Wallet,\\n        uint[] calldata TokenIDs,\\n        bytes32[][] calldata Proofs\\n    ) public view returns (User memory) {\\n        return User (\\n            ReadEligibilityMerkleClaim(ClaimIndex, Wallet, TokenIDs, Proofs),\\n            UserPurchasedAmount[ClaimIndex][Wallet]\\n        );\\n    }\\n}\\n\\ninterface IDelegationRegistry\\n{\\n    /**\\n     * @dev Checks If A Vault Has Delegated To The Delegate\\n     */\\n    function checkDelegateForAll(address delegate, address delegator) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/MintPassFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\nimport { DefaultOperatorFilterer } from \\\"operator-filter-registry/src/DefaultOperatorFilterer.sol\\\";\\nimport { ERC721MPF } from \\\"./ERC721MPF.sol\\\";\\nimport { ILaunchpad , ILaunchpadRegistry } from \\\"./ILaunchpad.sol\\\";\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { LaunchpadEnabled } from \\\"./LaunchpadEnabled.sol\\\";\\nimport { IOS } from \\\"./IOS.sol\\\";\\ncontract MintPassFactory is Ownable, ERC721MPF, DefaultOperatorFilterer, LaunchpadEnabled, IOS\\n{\\n    struct MintPass\\n    {\\n        uint _MaxSupply;          // _MaxSupply\\n        uint _MintPacks;          // _MintPacks\\n        uint _ArtistIDs;          // _ArtistIDs\\n        uint _ArtBlocksProjectID; // _ArtBlocksProjectID note: For Cases Where Mint Pass ProjectID 1:1 With ProjectIDs\\n        uint _ReserveAmount;      // _Reserve\\n        string _MetadataURI;      // _MetadataURI\\n    }\\n\\n    uint public _TotalUniqueProjects;  // Total Projects Invoked\\n    address public _Multisig; // test\\n    uint private constant _ONE_MILLY = 1000000;\\n    uint private constant _DEFAULT = type(uint).max; // max integer\\n\\n    mapping(uint=>MintPass) public MintPasses;\\n    mapping(uint=>uint) public ArtistIDs;\\n    mapping(address=>bool) public Authorized;\\n    mapping(uint=>uint[]) public MintPackIndexes;\\n    \\n    event MintPassProjectCreated(uint MintPassProjectID);\\n    event AuthorizedContract(address ContractAddress);\\n    event DeauthorizedContract(address ContractAddress);\\n\\n    /**\\n     * @dev Mint Pass Factory Constructor\\n     */\\n    constructor() ERC721MPF(\\\"Bright Moments Mint Pass | MPBRT\\\", \\\"MPBRT\\\") \\n    { \\n        Authorized[msg.sender] = true; \\n        _Multisig = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Returns All Mint Pack Indexes\\n     */\\n    function ReadMintPackIndexes(uint MintPassProjectID) public view returns (uint[] memory) { return MintPackIndexes[MintPassProjectID]; }\\n\\n    /**\\n     * @dev Direct Mint Function\\n     */\\n    function _MintToFactory(uint MintPassProjectID, address Recipient, uint Amount) external onlyAuthorized\\n    {\\n        require(_Active[MintPassProjectID], \\\"MintPassFactory: ProjectID: `MintPassProjectID` Is Not Active\\\");\\n        _mint(MintPassProjectID, Recipient, Amount);\\n    }\\n\\n    /**\\n     * @dev Direct Mint To Factory Pack\\n     */\\n    function _MintToFactoryPack(uint MintPassProjectID, address Recipient, uint Amount) external onlyAuthorized\\n    {\\n        require(_Active[MintPassProjectID], \\\"MintPassFactory: ProjectID: `MintPassProjectID` Is Not Active\\\");\\n        uint NumArtists = MintPasses[MintPassProjectID]._ArtistIDs;\\n        uint NumToMint = NumArtists * Amount;\\n        uint StartingTokenID = ReadProjectInvocations(MintPassProjectID);\\n        _mint(MintPassProjectID, Recipient, NumToMint);\\n        for(uint x; x < Amount; x++) { MintPackIndexes[MintPassProjectID].push(StartingTokenID + (NumArtists * x)); }\\n    }\\n\\n    /**\\n     * @dev LiveMint Redeems Mint Pass If Not Already Burned & Sends Minted Work To Owner's Wallet\\n     */\\n    function _LiveMintBurn(uint TokenID) external onlyAuthorized returns (address _Recipient, uint _ArtistID)\\n    {\\n        address Recipient = IERC721(address(this)).ownerOf(TokenID);\\n        require(Recipient != address(0), \\\"MPMX: Invalid Recipient\\\");\\n        _burn(TokenID, false);\\n        uint MintPassProjectID = TokenID % _ONE_MILLY;\\n        if(MintPasses[MintPassProjectID]._ArtBlocksProjectID == _DEFAULT) { return (Recipient, ArtistIDs[TokenID]); }\\n        else { return (Recipient, MintPasses[MintPassProjectID]._ArtBlocksProjectID); }\\n    }\\n\\n    /**\\n     * @dev Initializes A New Mint Pass\\n     */\\n    function __InitMintPass(MintPass memory _MintPass) external onlyAuthorized returns (uint MintPassProjectID)\\n    {   \\n        _Active[_TotalUniqueProjects] = true;\\n        require(_MintPass._ArtistIDs * _MintPass._MintPacks <= _MintPass._MaxSupply, \\\"MintPassFactory: Invalid Mint Pass Parameters\\\");\\n        _MaxSupply[_TotalUniqueProjects] = _MintPass._MaxSupply; // Internal Max Supply\\n        MintPasses[_TotalUniqueProjects] = _MintPass;            // Struct Assignment\\n        MintPasses[_TotalUniqueProjects]._MetadataURI = _MintPass._MetadataURI;\\n        if(_MintPass._ReserveAmount > 0)\\n        { \\n            _mint(\\n                _TotalUniqueProjects,    // MintPassProjectID\\n                _Multisig,               // Multisig\\n                _MintPass._ReserveAmount // Reserve Amount\\n            );\\n        }\\n        emit MintPassProjectCreated(_TotalUniqueProjects);\\n        _TotalUniqueProjects++;\\n        return (_TotalUniqueProjects - 1);\\n    }\\n\\n    /**\\n     * @dev Updates The BaseURI For A Project\\n     */\\n    function __NewBaseURI(uint MintPassProjectID, string memory NewURI) external onlyAuthorized \\n    { \\n        require(_Active[MintPassProjectID], \\\"MintPassFactory: Mint Pass Is Not Active\\\");\\n        MintPasses[MintPassProjectID]._MetadataURI = NewURI; \\n    }\\n\\n    /**\\n     * @dev Overrides The Operator Filter Active State\\n     */\\n    function __ChangeOperatorFilterState(bool State) external override onlyOwner { OPERATOR_FILTER_ENABLED = State; }\\n\\n    /**\\n     * @dev Overrides The Launchpad Registry Address\\n     */\\n    function __NewLaunchpadAddress(address NewAddress) external onlyAuthorized { _LAUNCHPAD = NewAddress; }\\n\\n    /**\\n     * @dev Authorizes A Contract To Mint\\n     */\\n    function ____AuthorizeContract(address NewAddress) external onlyOwner \\n    { \\n        Authorized[NewAddress] = true; \\n        emit AuthorizedContract(NewAddress);\\n    }\\n\\n    /**\\n     * @dev Deauthorizes A Contract From Minting\\n     */\\n    function ___DeauthorizeContract(address NewAddress) external onlyOwner \\n    { \\n        Authorized[NewAddress] = false; \\n        emit DeauthorizedContract(NewAddress);\\n    }\\n\\n    /**\\n     * @dev Overrides The Active State For A MintPassProjectID\\n     */\\n    function ____OverrideActiveState(uint MintPassProjectID, bool State) external onlyOwner { _Active[MintPassProjectID] = State; }\\n\\n    /**\\n     * @dev Overrides The Max Supply For A MintPassProjectID\\n     */\\n    function ____OverrideMaxSupply(uint MintPassProjectID, uint NewMaxSupply) external onlyOwner \\n    { \\n        _MaxSupply[MintPassProjectID] = NewMaxSupply; \\n        MintPasses[MintPassProjectID]._MaxSupply = NewMaxSupply;\\n    }\\n\\n    /**\\n     * @dev Owner Burn Function\\n     */\\n    function ____OverrideBurn(uint[] calldata TokenIDs) external onlyOwner\\n    {\\n        for(uint x; x < TokenIDs.length; x++) { _burn(TokenIDs[x], false); }\\n    }\\n\\n    /**\\n     * @dev Mints To Owner\\n     */\\n    function ___OverrideMint(uint MintPassProjectID, uint Amount) external onlyOwner\\n    {\\n        require(_Active[MintPassProjectID], \\\"MintPassFactory: Mint Pass Is Not Active\\\");\\n        _mint(MintPassProjectID, msg.sender, Amount);\\n    }\\n\\n    /**\\n     * @dev Returns A MintPassProjectID From A TokenID\\n     */\\n    function ViewProjectID(uint TokenID) public pure returns (uint) { return (TokenID - (TokenID % 1000000)) / 1000000; }\\n\\n    /**\\n     * @dev Returns The totalSupply() For A Specific MintPass ProjectID\\n     */\\n    function totalSupplyOfMintPassProject(uint[] calldata MintPassProjectIDs) external view returns (uint[] memory)\\n    {\\n        uint[] memory Supplies = new uint[](MintPassProjectIDs.length);\\n        for(uint x; x < MintPassProjectIDs.length; x++)\\n        {\\n            uint MaxSupply = MintPasses[MintPassProjectIDs[x]]._MaxSupply; \\n            uint Start = MintPassProjectIDs[x] * _ONE_MILLY;\\n            uint Range = Start + MaxSupply;\\n            uint Supply;\\n            for(Start; Start < Range; Start++) { if(_ownerships[Start].addr != address(0)) { Supply += 1; } }\\n        }\\n        return Supplies;\\n    }\\n\\n    /**\\n     * @dev Returns The totalSupply() For A Specific MintPass ProjectID\\n     */\\n    function totalSupplyOfMintPassProjectID(uint MintPassProjectID) external view returns (uint)\\n    {\\n            uint MaxSupply = MintPasses[MintPassProjectID]._MaxSupply; \\n            uint Start = MintPassProjectID * _ONE_MILLY;\\n            uint Range = Start + MaxSupply;\\n            uint Supply;\\n            for(Start; Start < Range; Start++) \\n            { \\n                if(_ownerships[Start].addr != address(0) || !_ownerships[Start].burned) { Supply += 1; } \\n            }\\n    \\n        return Supply;\\n    }\\n\\n    /**\\n     * @dev Returns Base URI Of Desired TokenID\\n     */\\n    function _baseURI(uint TokenID) internal view virtual override returns (string memory) \\n    { \\n        uint MintPassProjectID = ViewProjectID(TokenID);\\n        return MintPasses[MintPassProjectID]._MetadataURI;\\n        // return ILaunchpadRegistry(ILaunchpad(_LAUNCHPAD).ViewAddressLaunchpadRegistry()).ViewBaseURIMintPass(MintPassProjectID);\\n    }\\n\\n    /*---------------------\\n     * OVERRIDE FUNCTIONS *\\n    ----------------------*/\\n\\n    function setApprovalForAll(\\n        address operator, \\n        bool approved\\n    ) public override onlyAllowedOperatorApproval(operator) { super.setApprovalForAll(operator, approved); }\\n\\n    function approve(\\n        address operator, \\n        uint256 tokenId\\n    ) public override onlyAllowedOperatorApproval(operator) { super.approve(operator, tokenId); }\\n\\n    function transferFrom(\\n        address from, \\n        address to, \\n        uint256 tokenId\\n    ) public override onlyAllowedOperator(from) { super.transferFrom(from, to, tokenId); }\\n\\n    function safeTransferFrom(\\n        address from, \\n        address to, \\n        uint256 tokenId\\n    ) public override onlyAllowedOperator(from) { super.safeTransferFrom(from, to, tokenId); }\\n\\n    function safeTransferFrom(\\n        address from, \\n        address to, \\n        uint256 tokenId, \\n        bytes memory data\\n    ) public override onlyAllowedOperator(from) { super.safeTransferFrom(from, to, tokenId, data); }\\n\\n    /**\\n     * @dev Access Modifier For External Smart Contracts\\n     * note: This Is A Custom Access Modifier That Is Used To Restrict Access To Only Authorized Contracts\\n     */\\n    modifier onlyAuthorized()\\n    {\\n        if(msg.sender != owner()) \\n        { \\n            require(Authorized[msg.sender], \\\"MintPassFactory: Sender Is Not Authorized Contract\\\"); \\n        }\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/MPTM.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/**\\n * @dev: @brougkr\\n */\\npragma solidity 0.8.19;\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport { ERC721AO } from \\\"./ERC721AO.sol\\\";\\nimport { DefaultOperatorFilterer } from \\\"operator-filter-registry/src/DefaultOperatorFilterer.sol\\\";\\nimport { IOS } from \\\"./IOS.sol\\\";\\nimport { MarketplaceEnabled } from \\\"./MarketplaceEnabled.sol\\\";\\ncontract MPTM is Ownable, ERC721AO, DefaultOperatorFilterer, MarketplaceEnabled\\n{\\n    uint public _CurrentSeedIndex;\\n    uint public _ArtBlocksProjectID = 16;\\n    uint public _TOTAL_SUPPLY = 100;\\n    string public baseURI = \\\"ipfs://QmXzsJ9UVN5uQ9Sibuf7jKge2KpXxjLyhBLwU7YBVFrM8n/\\\";\\n    address public _LIVE_MINT = 0x1668f841ed817f5622a8480136B8c9CA1Fd09E6c;\\n\\n    constructor() ERC721AO(\\\"Mint Pass Totem | Beer Vangeer x Bright Moments | MPTM\\\", \\\"MPTM\\\") \\n    { \\n        // _mint(0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937, 5);\\n        // _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700); // `operator.brightmoments.eth`\\n    }\\n\\n    /**\\n     * @dev Factory Mint\\n     */\\n    function _MintToFactory(uint ProjectID, address Recipient, uint Amount) override virtual external onlyMarketplace\\n    {\\n        require(totalSupply() + Amount <= _TOTAL_SUPPLY, \\\"MP: Max Supply Reached\\\");\\n        _mint(Recipient, Amount); \\n    }\\n\\n    /**\\n     * @dev Changes The Total Supply\\n     */\\n    function __ChangeTotalSupply(uint NewSupply) external onlyOwner { _TOTAL_SUPPLY = NewSupply; }\\n\\n    /**\\n     * @dev Changes The Marketplace Address\\n     */\\n    function __ChangeMarketplaceAddress(address NewAddress) override virtual external onlyOwner { _MARKETPLACE_ADDRESS = NewAddress; }\\n\\n    /**\\n     * @dev Changes ArtBlocks ProjectID Returned From LiveMint\\n     */\\n    function __ChangeArtBlocksProjectID(uint NewArtistID) external onlyOwner { _ArtBlocksProjectID = NewArtistID; }\\n\\n    /**\\n     * @dev Executes Arbitrary Transaction(s)\\n     */\\n    function ___Execute(address[] memory Targets, uint[] memory Values, bytes[] memory Datas) external onlyOwner\\n    {\\n        for (uint x; x < Targets.length; x++) \\n        {\\n            (bool success,) = Targets[x].call{value:(Values[x])}(Datas[x]);\\n            require(success, \\\"i have failed u anakin\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Instantiates New LiveMint Address\\n     */\\n    function ___NewLiveMintAddress(address NewAddress) external onlyOwner { _LIVE_MINT = NewAddress; }\\n\\n    /**\\n     * @dev Changes The BaseURI For JSON Metadata \\n     */\\n    function ___NewBaseURI(string calldata NewURI) external onlyOwner { baseURI = NewURI; }\\n\\n    /**\\n     * @dev Burns Golden Token(s)\\n     */\\n    function ___OwnerBurn(uint[] calldata TokenIDs) external onlyOwner { for(uint x; x < TokenIDs.length; x++){ _burn(TokenIDs[x], false); } }\\n\\n    /**\\n     * @dev Withdraws All Ether From The Contract\\n     */\\n    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }\\n\\n    /**\\n     * @dev Withdraws Ether From Contract To Address With An Amount\\n     */\\n    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner\\n    {\\n        require(Amount > 0 && Amount <= address(this).balance, \\\"Invalid Amount\\\");\\n        (bool Success, ) = Recipient.call{value: Amount}(\\\"\\\");\\n        require(Success, \\\"Unable to Withdraw, Recipient May Have Reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Withdraws ERC20 Tokens\\n     **/\\n    function __WithdrawERC20(address TokenAddress) external onlyOwner \\n    { \\n        IERC20 erc20Token = IERC20(TokenAddress);\\n        uint balance = erc20Token.balanceOf(address(this));\\n        require(balance > 0, \\\"0 ERC20 Balance At `TokenAddress`\\\");\\n        erc20Token.transfer(msg.sender, balance);\\n    }\\n\\n    /**\\n     * @dev Withdraws ERC721(s) Mistakenly Sent To Contract, From The Contract\\n     */\\n    function ___WithdrawERC721(address Contract, address Recipient, uint[] calldata TokenIDs) external onlyOwner \\n    { \\n        for(uint TokenID; TokenID < TokenIDs.length; TokenID++)\\n        {\\n            IERC721(Contract).transferFrom(address(this), Recipient, TokenIDs[TokenID]);\\n        }\\n    }\\n    \\n    /**\\n     * @dev Returns Base URI\\n     */\\n    function _baseURI() internal view virtual override returns (string memory) { return baseURI; }\\n\\n    /*---------------------\\n     * OVERRIDE FUNCTIONS *\\n    ----------------------*/\\n\\n    function setApprovalForAll(\\n        address operator, \\n        bool approved\\n    ) public override onlyAllowedOperatorApproval(operator) { super.setApprovalForAll(operator, approved); }\\n\\n    function approve(\\n        address operator, \\n        uint256 tokenId\\n    ) public override onlyAllowedOperatorApproval(operator) { super.approve(operator, tokenId); }\\n\\n    function transferFrom(\\n        address from, \\n        address to, \\n        uint256 tokenId\\n    ) public override onlyAllowedOperator(from) { super.transferFrom(from, to, tokenId); }\\n\\n    function safeTransferFrom(\\n        address from, \\n        address to, \\n        uint256 tokenId\\n    ) public override onlyAllowedOperator(from) { super.safeTransferFrom(from, to, tokenId); }\\n\\n    function safeTransferFrom(\\n        address from, \\n        address to, \\n        uint256 tokenId, \\n        bytes memory data\\n    ) public override onlyAllowedOperator(from) { super.safeTransferFrom(from, to, tokenId, data); }\\n\\n    /*--------------------\\n     * LIVEMINT FUNCTION *\\n    ---------------------*/\\n\\n    /**\\n     * @dev LiveMint Redeems Golden Token If Not Already Burned & Sends Minted Work To Owner's Wallet\\n     */\\n    function _LiveMintBurn(uint TokenID) external returns (address _Recipient, uint _ArtistID)\\n    {\\n        require(msg.sender == _LIVE_MINT, \\\"MP: Sender Is Not Live Mint\\\");\\n        address Recipient = IERC721(address(this)).ownerOf(TokenID);\\n        require(Recipient != address(0), \\\"MP: Invalid Recipient\\\");\\n        _burn(TokenID, false);\\n        return (Recipient, _ArtBlocksProjectID);\\n    }\\n}\"\r\n    },\r\n    \"contracts/RandomCollectorSelector.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/\\n/**\\n * @dev: @brougkr\\n */\\npragma solidity 0.8.19;\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {VRFV2WrapperConsumerBase} from \\\"@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol\\\";\\ncontract RandomCollectorSelector is Ownable, VRFV2WrapperConsumerBase\\n{    \\n    struct RequestStatus \\n    {\\n        uint paid;   // amount paid in link\\n        bool fulfilled; // whether the request has been successfully fulfilled\\n        uint[] randomWords; // random results\\n    }\\n\\n    struct RCSParams\\n    {\\n        string Name;\\n        string IPFSHash;\\n        uint NumWinners;\\n        uint SnapshotEntries;\\n    }\\n\\n    mapping(uint => RCSParams) public RCSInfo;\\n    mapping(address => bool) public Admin;            // [Wallet] -> Is Admin\\n    mapping(uint => RequestStatus) public s_requests; // [RequestID] => `requestStatus`\\n    uint[] public _RandomResults;                                                 \\n    uint[] public requestIds;               // Array of request IDs\\n    uint32 public numWords = 1;             // Number of random words to request from Chainlink VRF\\n    uint16 public requestConfirmations = 1; // Number of confirmations to wait for before updating the request status\\n    uint public lastRequestId;              // Last request ID\\n    bool public _VRF;                       // VRF Status\\n    bool public _VRFResponseStatus;         // VRF Response Status\\n    uint public _CurrentRCSIndex;           // Current RCS Index\\n\\n    event RCSComplete(string _Name, uint _CurrentRCSIndex, uint _NumWinners, uint _SnapshotEntries, string _IPFSHash);\\n    event RequestSent(uint requestId, uint32 numWords);\\n    event RequestFulfilled(uint requestId, uint[] randomWords, uint payment);\\n    event Winners(uint VRFRandomness, uint[] WinningIndexes);\\n\\n    constructor() VRFV2WrapperConsumerBase(0x5947BB275c521040051D82396192181b413227A3, 0x721DFbc5Cfe53d32ab00A9bdFa605d3b8E1f3f42)\\n    {\\n        Admin[msg.sender] = true; // deployer.brightmoments.eth\\n        Admin[0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937] = true; // brightmoments.eth\\n        Admin[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true; // operator.brightmoments.eth\\n        Admin[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = true; // phil.brightmoments.eth\\n        Admin[0x91594b5E5d74FCCB3f71674eE74C5F4D44f333D5] = true; // gitpancake.brightmoments.eth\\n        Admin[0x65d674F2220Fa844c1e390AAf6739eC07519146E] = true; // irina.brightmoments.eth\\n    } \\n\\n    /*-----------------\\n     * VIEW FUNCTIONS *\\n    ------------------*/\\n\\n    /**\\n     * @dev Step 1: Request Random Number From Chainlink VRF\\n     */\\n    function VRFRandomSeed(uint32 CallbackGasLimit) external onlyAdmin returns (uint256 requestId)\\n    {\\n        require(!_VRF, \\\"Please Run RCS After This Function\\\");\\n        _VRF = true;\\n        requestId = requestRandomness(\\n            CallbackGasLimit,\\n            requestConfirmations,\\n            numWords\\n        );\\n        s_requests[requestId] = RequestStatus({\\n            paid: VRF_V2_WRAPPER.calculateRequestPrice(CallbackGasLimit),\\n            randomWords: new uint256[](0),\\n            fulfilled: false\\n        });\\n        requestIds.push(requestId);\\n        lastRequestId = requestId;\\n        emit RequestSent(requestId, numWords);\\n        return requestId;\\n    }\\n\\n    /**\\n     * @dev Step 2: Emits Chainlink VRF Random Winners\\n     */\\n    function RCS(\\n        string memory _Name,\\n        string memory _IPFSHash, \\n        uint _NumWinners, \\n        uint _SnapshotEntries\\n    ) external onlyAdmin {\\n        require(_VRFResponseStatus, \\\"Must Wait Until VRF Random Seed Has Been Returned\\\"); \\n        RCSInfo[_CurrentRCSIndex] = RCSParams({\\n            Name: _Name,\\n            IPFSHash: _IPFSHash,\\n            NumWinners: _NumWinners,\\n            SnapshotEntries: _SnapshotEntries\\n        });\\n        generateWinners(_NumWinners, _CurrentRCSIndex, _SnapshotEntries);\\n        _CurrentRCSIndex++;\\n        _VRFResponseStatus = false;\\n        _VRF = false;\\n        emit RCSComplete(_Name, _CurrentRCSIndex, _NumWinners, _SnapshotEntries, _IPFSHash);\\n    }\\n\\n    /*----------------\\n     * VRF FUNCTIONS *\\n    -----------------*/\\n    event Value(uint);\\n    /**\\n     * @dev Generates Winners From VRF Random Seed\\n     */\\n    function generateWinners(uint numWinners, uint drawId, uint snapshotEntries) private\\n    {\\n        uint[] memory WinningIndexes = new uint[](numWinners);\\n        for(uint x; x < numWinners; x++) \\n        {\\n            WinningIndexes[x] = (uint(keccak256(abi.encode(_RandomResults[drawId], x))) % snapshotEntries) + 1;\\n        }\\n        emit Winners(_RandomResults[drawId], WinningIndexes);\\n    }\\n\\n    /**\\n     * @dev Withdraws ERC20 From Contract\\n     */\\n    function __WithdrawERC20(address ERC20) external onlyOwner\\n    {\\n        IERC20 token = IERC20(ERC20);\\n        token.transfer(msg.sender, token.balanceOf(address(this)));\\n    }\\n\\n    /**\\n     * @dev VRF Callback Function\\n     */\\n    function fulfillRandomWords(uint _requestId, uint[] memory _randomWords) internal override \\n    {\\n        require(s_requests[_requestId].paid > 0, \\\"request not found\\\");\\n        _VRFResponseStatus = true;\\n        s_requests[_requestId].fulfilled = true;\\n        s_requests[_requestId].randomWords = _randomWords;\\n        _RandomResults.push(_randomWords[0]);\\n        emit RequestFulfilled(_requestId, _randomWords, s_requests[_requestId].paid);\\n    }\\n\\n    modifier onlyAdmin\\n    {\\n        require(Admin[msg.sender], \\\"onlyAdmin: Message Sender Is Not BRT Admin\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"operator-filter-registry/src/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\nimport {CANONICAL_CORI_SUBSCRIPTION} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  DefaultOperatorFilterer\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\n * @dev    Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor() OperatorFilterer(CANONICAL_CORI_SUBSCRIPTION, true) {}\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    /**\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\n     *         true if supplied registrant address is not registered.\\n     */\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n\\n    /**\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\n     */\\n    function register(address registrant) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\n     */\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n\\n    /**\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\n     *         address without subscribing.\\n     */\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\n     */\\n    function unregister(address addr) external;\\n\\n    /**\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\n     */\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\n     */\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n\\n    /**\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\n     */\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n\\n    /**\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\n     */\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n\\n    /**\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\n     *         subscription if present.\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\n     *         used.\\n     */\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n\\n    /**\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\n     */\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n\\n    /**\\n     * @notice Get the subscription address of a given registrant, if any.\\n     */\\n    function subscriptionOf(address addr) external returns (address registrant);\\n\\n    /**\\n     * @notice Get the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscribers(address registrant) external returns (address[] memory);\\n\\n    /**\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\n     */\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n\\n    /**\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\n     */\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n\\n    /**\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\n     */\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n\\n    /**\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\n     */\\n    function filteredOperators(address addr) external returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n\\n    /**\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n\\n    /**\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\n     *         its subscription.\\n     *         Note that order is not guaranteed as updates are made.\\n     */\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if an address has registered\\n     */\\n    function isRegistered(address addr) external returns (bool);\\n\\n    /**\\n     * @dev Convenience method to compute the code hash of an arbitrary contract\\n     */\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\naddress constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\\naddress constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\\n\"\r\n    },\r\n    \"operator-filter-registry/src/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\nimport {CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS} from \\\"./lib/Constants.sol\\\";\\n/**\\n * @title  OperatorFilterer\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\n *         registrant's entries in the OperatorFilterRegistry.\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\n *         Please note that if your token contract does not provide an owner with EIP-173, it must provide\\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\\n *         will be locked to the options set during construction.\\n */\\n\\nabstract contract OperatorFilterer {\\n    /// @dev Emitted when an operator is not allowed.\\n    error OperatorNotAllowed(address operator);\\n\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\n        IOperatorFilterRegistry(CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS);\\n\\n    /// @dev The constructor that is called when the contract is being deployed.\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\n        // order for the modifier to filter addresses.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (subscribe) {\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\n            } else {\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\n                } else {\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator approval is allowed.\\n     */\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        _checkFilterOperator(operator);\\n        _;\\n    }\\n\\n    /**\\n     * @dev A helper function to check if an operator is allowed.\\n     */\\n    function _checkFilterOperator(address operator) internal view virtual {\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Citizen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Fullset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Public\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Purchaser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"Purchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Purchaser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"DesiredAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"MessageValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"PresaleEnded\",\"type\":\"bool\"}],\"name\":\"PurchasedPresale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Refundee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"SaleStarted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Admin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"AmountSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DelegateCash\",\"outputs\":[{\"internalType\":\"contract IDelegation\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"DiscountAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"FixedPriceSales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_Price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MintPassProjectID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ABProjectID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountForSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampStart\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_Root\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"InternalRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_RootEligibilityFullSet\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_RootEligibilityCitizen\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_RootAmountFullSet\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_RootAmountCitizen\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"InternalSaleWalletInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_AmountPurchasedFullSetWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountPurchasedCitizenWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountPurchasedWallet\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PresaleSales\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_Operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_MaxForSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MaxPerPurchase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_PricePresale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_PricePublic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampEndFullSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampEndCitizen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampSaleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ProjectID\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PresaleSalesInternal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_Active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_AmountSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GlobalPurchasesFullSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GlobalPurchasesCitizen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GlobalPurchasesPublic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_CurrentTokenIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountSoldFullSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountSoldCitizen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountSoldPublic\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"Proof\",\"type\":\"bytes32[]\"}],\"name\":\"PurchaseFixedPrice\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DesiredAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Vault\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"Proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"ProofAmount\",\"type\":\"bytes32[]\"}],\"name\":\"PurchasePresale\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"}],\"name\":\"SaleInformation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_PricePresale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_PricePublic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MintPassesAvailable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MintPassesRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampEndFullSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampEndCitizen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampSaleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GlobalPurchasesFullSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GlobalPurchasesCitizen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GlobalPurchasesPublic\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.SaleInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_Wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_Amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_Root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_Proof\",\"type\":\"bytes32[]\"}],\"name\":\"VerifyAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_Wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_Root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_Proof\",\"type\":\"bytes32[]\"}],\"name\":\"VerifyBrightList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_Wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_Root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_Proof\",\"type\":\"bytes32[]\"}],\"name\":\"VerifyBrightListWithPriority\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"Proof\",\"type\":\"bytes32[]\"}],\"name\":\"ViewFixedPriceSaleInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_Price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountForSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Priority\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_BrightlistEligible\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"_Root\",\"type\":\"bytes32\"}],\"internalType\":\"struct Marketplace.FixedPriceSaleInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"MaxAmountFullSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxAmountCitizen\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"FullsetProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"CitizenProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"ProofAmountFullSet\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"ProofAmountCitizen\",\"type\":\"bytes32[]\"}],\"name\":\"WalletSaleInformation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_PricePresale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_PricePublic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MintPassesAvailable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MintPassesRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampEndFullSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampEndCitizen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampSaleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountPurchasableFullSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountPurchasableCitizen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountPurchasedFullSetWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountPurchasedCitizenWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GlobalPurchasesFullSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GlobalPurchasesCitizen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_GlobalPurchasesPublic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountPurchasedWallet\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_EligibleFullSet\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_EligibleCitizen\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_ValidMaxAmountFullSet\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_ValidMaxAmountCitizen\",\"type\":\"bool\"}],\"internalType\":\"struct Marketplace.WalletSaleInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TOTAL_UNIQUE_SALES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Price\",\"type\":\"uint256\"}],\"name\":\"__ChangeFixedPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ABProjectID\",\"type\":\"uint256\"}],\"name\":\"__ChangeFixedPriceABProjectID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AmountForSale\",\"type\":\"uint256\"}],\"name\":\"__ChangeFixedPriceAmountForSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"Discounts\",\"type\":\"uint256[]\"}],\"name\":\"__ChangeFixedPriceDiscountAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MintPassProjectID\",\"type\":\"uint256\"}],\"name\":\"__ChangeFixedPriceMintPassProjectID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"NewAddress\",\"type\":\"address\"}],\"name\":\"__ChangeFixedPriceNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Type\",\"type\":\"uint256\"}],\"name\":\"__ChangeFixedPriceType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ProjectID\",\"type\":\"uint256\"}],\"name\":\"__ChangePresaleProjectID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"RootEligibilityFullSet\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"RootAmountsFullSet\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"RootEligibilityCitizen\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"RootAmountsCitizen\",\"type\":\"bytes32\"}],\"name\":\"__ChangePresaleRootsAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"RootCitizen\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"RootFullSet\",\"type\":\"bytes32\"}],\"name\":\"__ChangePresaleRootsAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"RootCitizen\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"RootFullSet\",\"type\":\"bytes32\"}],\"name\":\"__ChangePresaleRootsEligibility\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Timestamp\",\"type\":\"uint256\"}],\"name\":\"__ChangePresaleSaleEndCitizen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Timestamp\",\"type\":\"uint256\"}],\"name\":\"__ChangePresaleSaleEndFullSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxForSale\",\"type\":\"uint256\"}],\"name\":\"__ChangePresaleSaleMaxForSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxPerPurchase\",\"type\":\"uint256\"}],\"name\":\"__ChangePresaleSaleMaxPerPurchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Price\",\"type\":\"uint256\"}],\"name\":\"__ChangePresaleSalePresalePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Price\",\"type\":\"uint256\"}],\"name\":\"__ChangePresaleSalePublicPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"RootCitizen\",\"type\":\"bytes32\"}],\"name\":\"__ChangePresaleSaleRootCitizen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"RootFullSet\",\"type\":\"bytes32\"}],\"name\":\"__ChangePresaleSaleRootFullSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Timestamp\",\"type\":\"uint256\"}],\"name\":\"__ChangePresaleSaleStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TimestampSaleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TimestampFullSetEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TimestampCitizenEnd\",\"type\":\"uint256\"}],\"name\":\"__ChangePresaleTimes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Type\",\"type\":\"uint256\"}],\"name\":\"__ChangePresaleType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"_Operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_MaxForSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MaxPerPurchase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_PricePresale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_PricePublic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampEndFullSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampEndCitizen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampSaleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ProjectID\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.PresaleSale\",\"name\":\"_Sale\",\"type\":\"tuple\"}],\"name\":\"__OverwritePresaleSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SaleIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_Price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MintPassProjectID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ABProjectID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_AmountForSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampStart\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_Root\",\"type\":\"bytes32\"}],\"internalType\":\"struct Marketplace.Sale\",\"name\":\"_Sale\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"Discounts\",\"type\":\"uint256[]\"}],\"name\":\"__StartFixedPriceSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"_Operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFT\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_MaxForSale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MaxPerPurchase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_PricePresale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_PricePublic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampEndFullSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampEndCitizen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TimestampSaleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ProjectID\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.PresaleSale\",\"name\":\"_Sale\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"_RootEligibilityFullSet\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_RootEligibilityCitizen\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_RootAmountFullSet\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_RootAmountCitizen\",\"type\":\"bytes32\"}],\"internalType\":\"struct Marketplace.InternalPresaleSaleRoots\",\"name\":\"_Roots\",\"type\":\"tuple\"}],\"name\":\"__StartPresaleSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_Admin\",\"type\":\"address\"}],\"name\":\"___AdminGrant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_Admin\",\"type\":\"address\"}],\"name\":\"___AdminRemove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"Recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"TokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"___WithdrawERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"___WithdrawETHToMultisig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"___WithdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"Recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"___WithdrawEtherToAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Marketplace", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}