{"SourceCode": "# @version 0.2.7\r\n\"\"\"\r\n@title Curve Fee Distribution\r\n@author Curve Finance\r\n@license MIT\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface VotingEscrow:\r\n    def user_point_epoch(addr: address) -> uint256: view\r\n    def epoch() -> uint256: view\r\n    def user_point_history(addr: address, loc: uint256) -> Point: view\r\n    def point_history(loc: uint256) -> Point: view\r\n    def checkpoint(): nonpayable\r\n\r\n\r\nevent CommitAdmin:\r\n    admin: address\r\n\r\nevent ApplyAdmin:\r\n    admin: address\r\n\r\nevent ToggleAllowCheckpointToken:\r\n    toggle_flag: bool\r\n\r\nevent CheckpointToken:\r\n    time: uint256\r\n    tokens: uint256\r\n\r\nevent Claimed:\r\n    recipient: indexed(address)\r\n    amount: uint256\r\n    claim_epoch: uint256\r\n    max_epoch: uint256\r\n\r\n\r\nstruct Point:\r\n    bias: int128\r\n    slope: int128  # - dweight / dt\r\n    ts: uint256\r\n    blk: uint256  # block\r\n\r\n\r\nWEEK: constant(uint256) = 7 * 86400\r\nTOKEN_CHECKPOINT_DEADLINE: constant(uint256) = 86400\r\n\r\nstart_time: public(uint256)\r\ntime_cursor: public(uint256)\r\ntime_cursor_of: public(HashMap[address, uint256])\r\nuser_epoch_of: public(HashMap[address, uint256])\r\n\r\nlast_token_time: public(uint256)\r\ntokens_per_week: public(uint256[1000000000000000])\r\n\r\nvoting_escrow: public(address)\r\ntoken: public(address)\r\ntotal_received: public(uint256)\r\ntoken_last_balance: public(uint256)\r\n\r\nve_supply: public(uint256[1000000000000000])  # VE total supply at week bounds\r\n\r\nadmin: public(address)\r\nfuture_admin: public(address)\r\ncan_checkpoint_token: public(bool)\r\nemergency_return: public(address)\r\nis_killed: public(bool)\r\n\r\n\r\n@external\r\ndef __init__(\r\n    _voting_escrow: address,\r\n    _start_time: uint256,\r\n    _token: address,\r\n    _admin: address,\r\n    _emergency_return: address\r\n):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _voting_escrow VotingEscrow contract address\r\n    @param _start_time Epoch time for fee distribution to start\r\n    @param _token Fee token address (3CRV)\r\n    @param _admin Admin address\r\n    @param _emergency_return Address to transfer `_token` balance to\r\n                             if this contract is killed\r\n    \"\"\"\r\n    t: uint256 = _start_time / WEEK * WEEK\r\n    self.start_time = t\r\n    self.last_token_time = t\r\n    self.time_cursor = t\r\n    self.token = _token\r\n    self.voting_escrow = _voting_escrow\r\n    self.admin = _admin\r\n    self.emergency_return = _emergency_return\r\n\r\n\r\n@internal\r\ndef _checkpoint_token():\r\n    token_balance: uint256 = ERC20(self.token).balanceOf(self)\r\n    to_distribute: uint256 = token_balance - self.token_last_balance\r\n    self.token_last_balance = token_balance\r\n\r\n    t: uint256 = self.last_token_time\r\n    since_last: uint256 = block.timestamp - t\r\n    self.last_token_time = block.timestamp\r\n    this_week: uint256 = t / WEEK * WEEK\r\n    next_week: uint256 = 0\r\n\r\n    for i in range(20):\r\n        next_week = this_week + WEEK\r\n        if block.timestamp < next_week:\r\n            if since_last == 0 and block.timestamp == t:\r\n                self.tokens_per_week[this_week] += to_distribute\r\n            else:\r\n                self.tokens_per_week[this_week] += to_distribute * (block.timestamp - t) / since_last\r\n            break\r\n        else:\r\n            if since_last == 0 and next_week == t:\r\n                self.tokens_per_week[this_week] += to_distribute\r\n            else:\r\n                self.tokens_per_week[this_week] += to_distribute * (next_week - t) / since_last\r\n        t = next_week\r\n        this_week = next_week\r\n\r\n    log CheckpointToken(block.timestamp, to_distribute)\r\n\r\n\r\n@external\r\ndef checkpoint_token():\r\n    \"\"\"\r\n    @notice Update the token checkpoint\r\n    @dev Calculates the total number of tokens to be distributed in a given week.\r\n         During setup for the initial distribution this function is only callable\r\n         by the contract owner. Beyond initial distro, it can be enabled for anyone\r\n         to call.\r\n    \"\"\"\r\n    assert (msg.sender == self.admin) or\\\r\n           (self.can_checkpoint_token and (block.timestamp > self.last_token_time + TOKEN_CHECKPOINT_DEADLINE))\r\n    self._checkpoint_token()\r\n\r\n\r\n@internal\r\ndef _find_timestamp_epoch(ve: address, _timestamp: uint256) -> uint256:\r\n    _min: uint256 = 0\r\n    _max: uint256 = VotingEscrow(ve).epoch()\r\n    for i in range(128):\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 2) / 2\r\n        pt: Point = VotingEscrow(ve).point_history(_mid)\r\n        if pt.ts <= _timestamp:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n    return _min\r\n\r\n\r\n@view\r\n@internal\r\ndef _find_timestamp_user_epoch(ve: address, user: address, _timestamp: uint256, max_user_epoch: uint256) -> uint256:\r\n    _min: uint256 = 0\r\n    _max: uint256 = max_user_epoch\r\n    for i in range(128):\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 2) / 2\r\n        pt: Point = VotingEscrow(ve).user_point_history(user, _mid)\r\n        if pt.ts <= _timestamp:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n    return _min\r\n\r\n\r\n@view\r\n@external\r\ndef ve_for_at(_user: address, _timestamp: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the veCRV balance for `_user` at `_timestamp`\r\n    @param _user Address to query balance for\r\n    @param _timestamp Epoch time\r\n    @return uint256 veCRV balance\r\n    \"\"\"\r\n    ve: address = self.voting_escrow\r\n    max_user_epoch: uint256 = VotingEscrow(ve).user_point_epoch(_user)\r\n    epoch: uint256 = self._find_timestamp_user_epoch(ve, _user, _timestamp, max_user_epoch)\r\n    pt: Point = VotingEscrow(ve).user_point_history(_user, epoch)\r\n    return convert(max(pt.bias - pt.slope * convert(_timestamp - pt.ts, int128), 0), uint256)\r\n\r\n\r\n@internal\r\ndef _checkpoint_total_supply():\r\n    ve: address = self.voting_escrow\r\n    t: uint256 = self.time_cursor\r\n    rounded_timestamp: uint256 = block.timestamp / WEEK * WEEK\r\n    VotingEscrow(ve).checkpoint()\r\n\r\n    for i in range(20):\r\n        if t > rounded_timestamp:\r\n            break\r\n        else:\r\n            epoch: uint256 = self._find_timestamp_epoch(ve, t)\r\n            pt: Point = VotingEscrow(ve).point_history(epoch)\r\n            dt: int128 = 0\r\n            if t > pt.ts:\r\n                # If the point is at 0 epoch, it can actually be earlier than the first deposit\r\n                # Then make dt 0\r\n                dt = convert(t - pt.ts, int128)\r\n            self.ve_supply[t] = convert(max(pt.bias - pt.slope * dt, 0), uint256)\r\n        t += WEEK\r\n\r\n    self.time_cursor = t\r\n\r\n\r\n@external\r\ndef checkpoint_total_supply():\r\n    \"\"\"\r\n    @notice Update the veCRV total supply checkpoint\r\n    @dev The checkpoint is also updated by the first claimant each\r\n         new epoch week. This function may be called independently\r\n         of a claim, to reduce claiming gas costs.\r\n    \"\"\"\r\n    self._checkpoint_total_supply()\r\n\r\n\r\n@internal\r\ndef _claim(addr: address, ve: address, _last_token_time: uint256) -> uint256:\r\n    # Minimal user_epoch is 0 (if user had no point)\r\n    user_epoch: uint256 = 0\r\n    to_distribute: uint256 = 0\r\n\r\n    max_user_epoch: uint256 = VotingEscrow(ve).user_point_epoch(addr)\r\n    _start_time: uint256 = self.start_time\r\n\r\n    if max_user_epoch == 0:\r\n        # No lock = no fees\r\n        return 0\r\n\r\n    week_cursor: uint256 = self.time_cursor_of[addr]\r\n    if week_cursor == 0:\r\n        # Need to do the initial binary search\r\n        user_epoch = self._find_timestamp_user_epoch(ve, addr, _start_time, max_user_epoch)\r\n    else:\r\n        user_epoch = self.user_epoch_of[addr]\r\n\r\n    if user_epoch == 0:\r\n        user_epoch = 1\r\n\r\n    user_point: Point = VotingEscrow(ve).user_point_history(addr, user_epoch)\r\n\r\n    if week_cursor == 0:\r\n        week_cursor = (user_point.ts + WEEK - 1) / WEEK * WEEK\r\n\r\n    if week_cursor >= _last_token_time:\r\n        return 0\r\n\r\n    if week_cursor < _start_time:\r\n        week_cursor = _start_time\r\n    old_user_point: Point = empty(Point)\r\n\r\n    # Iterate over weeks\r\n    for i in range(50):\r\n        if week_cursor >= _last_token_time:\r\n            break\r\n\r\n        if week_cursor >= user_point.ts and user_epoch <= max_user_epoch:\r\n            user_epoch += 1\r\n            old_user_point = user_point\r\n            if user_epoch > max_user_epoch:\r\n                user_point = empty(Point)\r\n            else:\r\n                user_point = VotingEscrow(ve).user_point_history(addr, user_epoch)\r\n\r\n        else:\r\n            # Calc\r\n            # + i * 2 is for rounding errors\r\n            dt: int128 = convert(week_cursor - old_user_point.ts, int128)\r\n            balance_of: uint256 = convert(max(old_user_point.bias - dt * old_user_point.slope, 0), uint256)\r\n            if balance_of == 0 and user_epoch > max_user_epoch:\r\n                break\r\n            if balance_of > 0:\r\n                to_distribute += balance_of * self.tokens_per_week[week_cursor] / self.ve_supply[week_cursor]\r\n\r\n            week_cursor += WEEK\r\n\r\n    user_epoch = min(max_user_epoch, user_epoch - 1)\r\n    self.user_epoch_of[addr] = user_epoch\r\n    self.time_cursor_of[addr] = week_cursor\r\n\r\n    log Claimed(addr, to_distribute, user_epoch, max_user_epoch)\r\n\r\n    return to_distribute\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef claim(_addr: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Claim fees for `_addr`\r\n    @dev Each call to claim look at a maximum of 50 user veCRV points.\r\n         For accounts with many veCRV related actions, this function\r\n         may need to be called more than once to claim all available\r\n         fees. In the `Claimed` event that fires, if `claim_epoch` is\r\n         less than `max_epoch`, the account may claim again.\r\n    @param _addr Address to claim fees for\r\n    @return uint256 Amount of fees claimed in the call\r\n    \"\"\"\r\n    assert not self.is_killed\r\n\r\n    if block.timestamp >= self.time_cursor:\r\n        self._checkpoint_total_supply()\r\n\r\n    last_token_time: uint256 = self.last_token_time\r\n\r\n    if self.can_checkpoint_token and (block.timestamp > last_token_time + TOKEN_CHECKPOINT_DEADLINE):\r\n        self._checkpoint_token()\r\n        last_token_time = block.timestamp\r\n\r\n    last_token_time = last_token_time / WEEK * WEEK\r\n\r\n    amount: uint256 = self._claim(_addr, self.voting_escrow, last_token_time)\r\n    if amount != 0:\r\n        token: address = self.token\r\n        assert ERC20(token).transfer(_addr, amount)\r\n        self.token_last_balance -= amount\r\n\r\n    return amount\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef claim_many(_receivers: address[20]) -> bool:\r\n    \"\"\"\r\n    @notice Make multiple fee claims in a single call\r\n    @dev Used to claim for many accounts at once, or to make\r\n         multiple claims for the same address when that address\r\n         has significant veCRV history\r\n    @param _receivers List of addresses to claim for. Claiming\r\n                      terminates at the first `ZERO_ADDRESS`.\r\n    @return bool success\r\n    \"\"\"\r\n    assert not self.is_killed\r\n\r\n    if block.timestamp >= self.time_cursor:\r\n        self._checkpoint_total_supply()\r\n\r\n    last_token_time: uint256 = self.last_token_time\r\n\r\n    if self.can_checkpoint_token and (block.timestamp > last_token_time + TOKEN_CHECKPOINT_DEADLINE):\r\n        self._checkpoint_token()\r\n        last_token_time = block.timestamp\r\n\r\n    last_token_time = last_token_time / WEEK * WEEK\r\n    voting_escrow: address = self.voting_escrow\r\n    token: address = self.token\r\n    total: uint256 = 0\r\n\r\n    for addr in _receivers:\r\n        if addr == ZERO_ADDRESS:\r\n            break\r\n\r\n        amount: uint256 = self._claim(addr, voting_escrow, last_token_time)\r\n        if amount != 0:\r\n            assert ERC20(token).transfer(addr, amount)\r\n            total += amount\r\n\r\n    if total != 0:\r\n        self.token_last_balance -= total\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef burn(_coin: address) -> bool:\r\n    \"\"\"\r\n    @notice Receive 3CRV into the contract and trigger a token checkpoint\r\n    @param _coin Address of the coin being received (must be 3CRV)\r\n    @return bool success\r\n    \"\"\"\r\n    assert _coin == self.token\r\n    assert not self.is_killed\r\n\r\n    amount: uint256 = ERC20(_coin).balanceOf(msg.sender)\r\n    if amount != 0:\r\n        ERC20(_coin).transferFrom(msg.sender, self, amount)\r\n        if self.can_checkpoint_token and (block.timestamp > self.last_token_time + TOKEN_CHECKPOINT_DEADLINE):\r\n            self._checkpoint_token()\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef commit_admin(_addr: address):\r\n    \"\"\"\r\n    @notice Commit transfer of ownership\r\n    @param _addr New admin address\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: access denied\r\n    self.future_admin = _addr\r\n    log CommitAdmin(_addr)\r\n\r\n\r\n@external\r\ndef apply_admin():\r\n    \"\"\"\r\n    @notice Apply transfer of ownership\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    assert self.future_admin != ZERO_ADDRESS\r\n    future_admin: address = self.future_admin\r\n    self.admin = future_admin\r\n    log ApplyAdmin(future_admin)\r\n\r\n\r\n@external\r\ndef toggle_allow_checkpoint_token():\r\n    \"\"\"\r\n    @notice Toggle permission for checkpointing by any account\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    flag: bool = not self.can_checkpoint_token\r\n    self.can_checkpoint_token = flag\r\n    log ToggleAllowCheckpointToken(flag)\r\n\r\n\r\n@external\r\ndef kill_me():\r\n    \"\"\"\r\n    @notice Kill the contract\r\n    @dev Killing transfers the entire 3CRV balance to the emergency return address\r\n         and blocks the ability to claim or burn. The contract cannot be unkilled.\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n\r\n    self.is_killed = True\r\n\r\n    token: address = self.token\r\n    assert ERC20(token).transfer(self.emergency_return, ERC20(token).balanceOf(self))\r\n\r\n\r\n@external\r\ndef recover_balance(_coin: address) -> bool:\r\n    \"\"\"\r\n    @notice Recover ERC20 tokens from this contract\r\n    @dev Tokens are sent to the emergency return address.\r\n    @param _coin Token address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    assert _coin != self.token\r\n\r\n    amount: uint256 = ERC20(_coin).balanceOf(self)\r\n    response: Bytes[32] = raw_call(\r\n        _coin,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(self.emergency_return, bytes32),\r\n            convert(amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    return True", "ABI": "[{\"name\":\"CommitAdmin\",\"inputs\":[{\"type\":\"address\",\"name\":\"admin\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyAdmin\",\"inputs\":[{\"type\":\"address\",\"name\":\"admin\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ToggleAllowCheckpointToken\",\"inputs\":[{\"type\":\"bool\",\"name\":\"toggle_flag\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CheckpointToken\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"time\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"tokens\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Claimed\",\"inputs\":[{\"type\":\"address\",\"name\":\"recipient\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"claim_epoch\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"max_epoch\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_voting_escrow\"},{\"type\":\"uint256\",\"name\":\"_start_time\"},{\"type\":\"address\",\"name\":\"_token\"},{\"type\":\"address\",\"name\":\"_admin\"},{\"type\":\"address\",\"name\":\"_emergency_return\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"checkpoint_token\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":820723},{\"name\":\"ve_for_at\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_user\"},{\"type\":\"uint256\",\"name\":\"_timestamp\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":249417},{\"name\":\"checkpoint_total_supply\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":10592405},{\"name\":\"claim\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"claim\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_addr\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"claim_many\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address[20]\",\"name\":\"_receivers\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":26281905},{\"name\":\"burn\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_coin\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":823450},{\"name\":\"commit_admin\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_addr\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37898},{\"name\":\"apply_admin\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":39534},{\"name\":\"toggle_allow_checkpoint_token\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38673},{\"name\":\"kill_me\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":39587},{\"name\":\"recover_balance\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_coin\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":7778},{\"name\":\"start_time\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1541},{\"name\":\"time_cursor\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1571},{\"name\":\"time_cursor_of\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1816},{\"name\":\"user_epoch_of\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1846},{\"name\":\"last_token_time\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1661},{\"name\":\"tokens_per_week\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1800},{\"name\":\"voting_escrow\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1721},{\"name\":\"token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1751},{\"name\":\"total_received\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1781},{\"name\":\"token_last_balance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1811},{\"name\":\"ve_supply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1950},{\"name\":\"admin\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1871},{\"name\":\"future_admin\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1901},{\"name\":\"can_checkpoint_token\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1931},{\"name\":\"emergency_return\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1961},{\"name\":\"is_killed\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1991}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.2.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000005f3b5dfeb7b28cdbd7faba78963ee202a494e2a2000000000000000000000000000000000000000000000000000000005f62a7000000000000000000000000006c3f90f043a72fa612cbac8115ee7e52bde6e49000000000000000000000000040907540d8a6c65c637785e8f8b742ae6b0b996800000000000000000000000000669df67e4827fcc0e48a1838a8d5ab79281909", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}