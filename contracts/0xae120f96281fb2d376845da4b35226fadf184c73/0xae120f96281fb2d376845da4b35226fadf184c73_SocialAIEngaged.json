{"SourceCode": "pragma solidity 0.8.18;\r\n// SPDX-License-Identifier: MIT\r\n\r\n/*\r\n\r\nThe social engagement revolution.\r\nPersonal XP, buybacks, LP burns, lotteries, airdrops, and much more! \r\nTelegram: https://t.me/SocialAIPortal\r\nWebsite: https://www.socialai.finance/\r\n\r\n*/\r\n\r\nlibrary TransferHelper {\r\n\r\n    // To make sure the correct transfers if called and reverts are caught in \"success\"\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n}\r\n \r\ninterface IUniswapRouter {\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n        ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function factory() external pure returns (address);\r\n}\r\n\r\ninterface IUniswapFactory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IERC20 {\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address holder, address spender) external view returns(uint256);\r\n}\r\n\r\ncontract SocialAIEngaged {\r\n\r\n    struct Project {\r\n        uint256 project_id;\r\n        address token;\r\n        address owner;\r\n        uint256 eth_balance;\r\n        uint256 tokens_reserved;\r\n        bool active;\r\n    }\r\n    \r\n    address public DAPP_controller; // wallet used to sign automatic DAPP interactions\r\n    address public sai_fee_wallet;\r\n    address public gas_wallet;\r\n\r\n    mapping(uint => address) public allowed_token;\r\n    mapping(uint => Project) public projects;\r\n\r\n\r\n    address private constant UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address private constant ZERO = 0x0000000000000000000000000000000000000000;\r\n    IUniswapRouter private constant uniswapRouter = IUniswapRouter(UNISWAP_ROUTER_ADDRESS);\r\n\r\n\r\n    uint256 public sai_reserved;\r\n    uint256 public gas_reserved;\r\n    uint256 public send_gas_at = 0.05 ether;\r\n\r\n    bool public safety_enabled = true;\r\n\r\n\r\n    // Access control \r\n    constructor() {\r\n        DAPP_controller = msg.sender;\r\n        gas_wallet = msg.sender;\r\n        sai_fee_wallet = msg.sender;\r\n    }\r\n\r\n    modifier only_DAPP() {\r\n        require(msg.sender == DAPP_controller, \"Caller not DAPP\"); _;\r\n    }\r\n\r\n    // BASIC CONTRACT CONTROL\r\n    function DAPP_set_DAPP_controller(address new_controller) external only_DAPP {\r\n        DAPP_controller = new_controller;\r\n    }\r\n\r\n    function DAPP_set_gas_wallet(address new_gas_wallet) external only_DAPP {\r\n        gas_wallet = new_gas_wallet;\r\n    }\r\n\r\n    function DAPP_set_sai_fee_wallet(address new_fee_wallet) external only_DAPP {\r\n        sai_fee_wallet = new_fee_wallet;\r\n    }\r\n\r\n    function DAPP_withdraw_sai_fee() external only_DAPP {\r\n        payable(sai_fee_wallet).transfer(sai_reserved);\r\n        sai_reserved = 0;\r\n    }\r\n\r\n    function DAPP_manual_withdraw_gas_fee() external only_DAPP {\r\n        payable(gas_wallet).transfer(gas_reserved);\r\n        gas_reserved = 0;\r\n    }\r\n\r\n    function DAPP_set_send_threshold(uint new_threshold) external only_DAPP {\r\n        send_gas_at = new_threshold;\r\n    }\r\n\r\n    // INTERNAL HELPERS\r\n    function _swap_eth_for_tokens(address token, uint256 ethAmount, address to) internal returns (uint tokensBought) {\r\n        // Define the token to swap and the path to swap it\r\n        address[] memory path = new address[](2);\r\n        path[0] = uniswapRouter.WETH();\r\n        path[1] = token;\r\n\r\n        // Swap the ETH for the token, and check how much we gained \r\n        uint balBefore = IERC20(token).balanceOf(address(this));\r\n        uniswapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(0, path, to, block.timestamp+1);\r\n        tokensBought = IERC20(token).balanceOf(address(this)) - balBefore;\r\n    }\r\n\r\n    function _charge_fee(uint project_id, uint256 amount, uint256 sai_fee, uint256 gas_fee_of_prev_tx, bool is_eth) internal {\r\n        // Is this a valid project\r\n        require(projects[project_id].active, \"Not active\");\r\n\r\n        // Check for enough balance\r\n        uint256 total_eth = 0;\r\n\r\n        if (is_eth) {\r\n            // The fee equal the total amount of ETH + fees\r\n            total_eth = amount + sai_fee + gas_fee_of_prev_tx;\r\n\r\n        } else {\r\n            // Check if the token address is set otherwise tokens cannot be reserved\r\n            require(projects[project_id].token != address(0), \"Token not set\");\r\n\r\n            // In case of a token, we have to charge ETH seperately\r\n            total_eth = sai_fee + gas_fee_of_prev_tx;\r\n            \r\n            // Check for enough tokens\r\n            uint token_balance = IERC20(projects[project_id].token).balanceOf(address(this));\r\n            uint tokens_available = token_balance - projects[project_id].tokens_reserved;\r\n            require(amount <= tokens_available, \"TOKEN: not enough avaiable\");\r\n            \r\n            // Reserve the tokens\r\n            projects[project_id].tokens_reserved += amount;\r\n        }\r\n        \r\n        // Check for enough ETH and reduce balance\r\n        require(total_eth <= projects[project_id].eth_balance, \"ETH: Not enough balance\");\r\n        projects[project_id].eth_balance -= total_eth;\r\n\r\n        // Update the fee reserved for the SAI ecosystem\r\n        sai_reserved += sai_fee;\r\n        gas_reserved += gas_fee_of_prev_tx;\r\n\r\n        // Should we send ETH\r\n        if (gas_reserved >= send_gas_at) {\r\n            payable(DAPP_controller).transfer(gas_reserved);\r\n            gas_reserved = 0;\r\n        }        \r\n    }\r\n\r\n    function _check_merkle_tree(bytes32 airdrop_hash, bytes32[] memory _witnesses, uint256 path) internal view returns(bool) {\r\n        bytes32 merkleRoot = merkle_root_hash[airdrop_hash];  \r\n        require(merkleRoot != bytes32(0), \"No merkle airdrop\");  \r\n        bytes32 node = keccak256(abi.encodePacked(uint8(0x00), msg.sender));\r\n        for (uint16 i = 0; i < _witnesses.length; i++) {\r\n            if ((path & 0x01) == 1) {\r\n                node = keccak256(abi.encodePacked(uint8(0x01), _witnesses[i], node));\r\n            } else {\r\n                node = keccak256(abi.encodePacked(uint8(0x01), node, _witnesses[i]));\r\n            }\r\n            path /= 2;\r\n        }\r\n        return node == merkleRoot;\r\n    }\r\n\r\n    function _finalize_airdrop(bytes32 airdrop_hash, uint project_id) internal {\r\n        Airdrop memory current_drop = airdrops[airdrop_hash];\r\n        uint refund = current_drop.drops_left * current_drop.amount;\r\n        if (current_drop.is_eth) {\r\n            projects[project_id].eth_balance += refund;\r\n        } else {\r\n            // can reset the reserved tokens\r\n            projects[project_id].tokens_reserved -= refund;\r\n        }\r\n        delete airdrops[airdrop_hash];\r\n    }\r\n\r\n    function _charge_just_gas(uint project_id, uint gas_fee) internal {\r\n        require(gas_fee <= projects[project_id].eth_balance, \"Cant cover gas\");\r\n        projects[project_id].eth_balance -= gas_fee;\r\n    }\r\n\r\n    // PROJECT CREATION\r\n    function DAPP_set_verified_token(uint project_id, address token, uint gas_prev_tx) external only_DAPP {\r\n        _charge_just_gas(project_id, gas_prev_tx);\r\n        projects[project_id].token = token;\r\n        IERC20(token).approve(UNISWAP_ROUTER_ADDRESS, 2**256 - 1); // approve on router so we don't have to do this later\r\n    }\r\n\r\n    function DAPP_create_SAI_engaged_project(uint project_id, address wallet, address token) external only_DAPP {\r\n        require(projects[project_id].owner == address(0), \"Already exists\");\r\n    \r\n        // Create the project struct\r\n        Project memory p = Project(project_id, token, wallet, 0, 0, true);\r\n        projects[project_id] = p;\r\n        \r\n        // Approve if token address is given \r\n         if (token != address(0)) {\r\n            IERC20(token).approve(UNISWAP_ROUTER_ADDRESS, 2**256 - 1);\r\n        }\r\n    }\r\n\r\n    // EXTERNAL PROJECT INTERACTIONS\r\n    function deposit_eth_to_project(uint project_id) external payable {\r\n        require(msg.value > 0, \"No ETH\");\r\n        require(projects[project_id].active, \"Not active\");\r\n        projects[project_id].eth_balance += msg.value;\r\n    }\r\n\r\n    function deposit_tokens_to_project(address token, uint256 token_amount) external {\r\n        // requires token approval first \r\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), token_amount);\r\n    }\r\n\r\n    function change_project_owner(uint project_id, address new_owner) external {\r\n        require(msg.sender == projects[project_id].owner, \"Sender != owner\");\r\n        projects[project_id].owner = new_owner;\r\n    }\r\n\r\n    // AUTOMATIC GROUP REWARDS\r\n    function DAPP_buyback_and_burn(uint project_id, uint256 amount, uint256 sai_fee, uint256 gas_prev_tx) external only_DAPP {\r\n        // Check whether this tx can be executed and adjust the projects balance\r\n        _charge_fee(project_id, amount, sai_fee, gas_prev_tx, true);\r\n        address token = projects[project_id].token;\r\n        require(token != address(0), \"Token not set\");\r\n        _swap_eth_for_tokens(token, amount, DEAD); \r\n    }\r\n    \r\n    function DAPP_add_lp_and_burn(uint project_id, uint amount, uint256 sai_fee, uint256 gas_prev_tx) external only_DAPP  {\r\n        _charge_fee(project_id, amount, sai_fee, gas_prev_tx, true); \r\n        // Use half of the ETH to buy tokens \r\n        address token = projects[project_id].token;\r\n        require(token != address(0), \"Token not set\");\r\n        uint256 tokensOut = _swap_eth_for_tokens(token, amount/2, address(this));        \r\n        // Add the tokens to the pool \r\n        uniswapRouter.addLiquidityETH{value: amount/2}(token, tokensOut, 0, 0, DEAD, block.timestamp);\r\n    }\r\n\r\n    // PERSONAL - LOTTERIES\r\n\r\n    mapping(bytes32 => uint256) public lottery_amount;\r\n    mapping(bytes32 => bool)    public lottery_is_eth;\r\n\r\n    function DAPP_award_lottery(uint project_id, uint lottery_id, address[] memory winners, uint[] memory amounts, uint gas_prev_tx) external only_DAPP {\r\n        require(winners.length == amounts.length, \"Length winners != amounts\");\r\n        bytes32 lottery_hash = keccak256(abi.encodePacked(project_id, lottery_id));\r\n\r\n        // Just charge the gas for awards, sai fee was paid upon creation\r\n        _charge_just_gas(project_id, gas_prev_tx);\r\n\r\n        bool is_eth = lottery_is_eth[lottery_hash];\r\n        uint tot_awarded = 0;\r\n        \r\n        for (uint i=0; i<winners.length; i++) {\r\n            uint amount = amounts[i]; // Amounts can be different for different winners \r\n            tot_awarded += amount;\r\n\r\n            // Check if we need to send ETH or tokens\r\n            address winner = winners[i];\r\n            if (is_eth) {\r\n                payable(winner).transfer(amount);\r\n            } else {\r\n                TransferHelper.safeTransfer(projects[project_id].token, winner, amount);\r\n            }\r\n        }\r\n\r\n        // Make sure not more is spent than initially allocated\r\n        uint256 tot_reserved = lottery_amount[lottery_hash];\r\n        require(tot_reserved > 0, \"Lottery does not exist/is over\");\r\n        require(tot_awarded <= tot_reserved, \"Spent more than reserved\");\r\n\r\n        // If something is left refund \r\n        if (is_eth) {\r\n            uint256 refund_amount = tot_reserved - tot_awarded;\r\n            projects[project_id].eth_balance += refund_amount;\r\n        } else {\r\n            // Nothing is reserved anymore, regardless of what was awarded\r\n            projects[project_id].tokens_reserved -= tot_reserved;\r\n        }\r\n\r\n        // Lottery is over so reset amount hash, whether it is ETH does \r\n        // not matter cause it will be reset anyway for new lotteries\r\n        lottery_amount[lottery_hash] = 0 ;\r\n    }\r\n\r\n    function DAPP_create_lottery(uint project_id, uint lottery_id, uint tot_amount, bool is_eth, uint sai_fee, uint gas_prev_tx) external only_DAPP {\r\n        _charge_fee(project_id, tot_amount, sai_fee, gas_prev_tx, is_eth); // Will automatically reserve the tokens + check if active\r\n        require(tot_amount > 0, \"Lottery amount cannot be 0\");\r\n        bytes32 lottery_hash = keccak256(abi.encodePacked(project_id, lottery_id));\r\n        require(lottery_amount[lottery_hash] == 0, \"Lottery ongoing\");\r\n        lottery_amount[lottery_hash] = tot_amount;\r\n        lottery_is_eth[lottery_hash] = is_eth;\r\n    }\r\n\r\n    // PERSONAL - AIRDROPS\r\n    struct Airdrop {\r\n        uint amount;\r\n        uint expires_at;\r\n        bool is_eth;\r\n        bool is_active;\r\n        uint total_drops;\r\n        uint drops_left;\r\n    }\r\n\r\n    mapping(bytes32 => Airdrop) airdrops; // hash project id and airdrop id\r\n    mapping(bytes32 => bool) airdrop_claimed;\r\n    mapping(bytes32 => bytes32) merkle_root_hash; // Only applicable to merkle root airdrops\r\n    \r\n    function DAPP_create_airdrop(uint project_id, uint airdrop_id, uint airdrop_amount, uint number_of_airdrops, bytes32 merkle_root,\r\n     uint expire_stamp, bool is_eth, uint sai_fee, uint gas_prev_tx) external only_DAPP {\r\n        // Check how much ETH/tokens in total would be needed for the airdrop\r\n        uint tot_amount = airdrop_amount * number_of_airdrops;\r\n\r\n         // Reserve/subtract balance to pre reserve\r\n        _charge_fee(project_id, tot_amount, sai_fee, gas_prev_tx, is_eth);\r\n\r\n         // Get the hash and check if this exists already\r\n        bytes32 airdrop_hash = keccak256(abi.encodePacked(project_id, airdrop_id));\r\n        require(airdrops[airdrop_hash].is_active == false, \"Already there\");\r\n\r\n        // Allocate the airdrop struct\r\n        Airdrop memory drop = Airdrop(airdrop_amount, expire_stamp, is_eth, true, number_of_airdrops, number_of_airdrops);\r\n        airdrops[airdrop_hash] = drop;\r\n\r\n        // In case a merkle root is given, we use that \r\n        if (merkle_root != bytes32(0)) {\r\n            merkle_root_hash[airdrop_hash] = merkle_root;\r\n        }\r\n    }\r\n \r\n    function DAPP_extend_airdrop(uint project_id, uint airdrop_id, uint new_expire_stamp, uint gas_prev_tx) external only_DAPP {\r\n        _charge_just_gas(project_id, gas_prev_tx);\r\n        bytes32 airdrop_hash = keccak256(abi.encodePacked(project_id, airdrop_id));\r\n        airdrops[airdrop_hash].expires_at = new_expire_stamp;\r\n    }\r\n    \r\n    function DAPP_update_merkle_airdrop(uint project_id, uint airdrop_id, bytes32 new_merkle_root, uint gas_prev_tx) external only_DAPP {\r\n        _charge_just_gas(project_id, gas_prev_tx);\r\n        bytes32 airdrop_hash = keccak256(abi.encodePacked(project_id, airdrop_id));\r\n\r\n        // Check if this was a merkle in the first place\r\n        require(merkle_root_hash[airdrop_hash] != bytes32(0), \"AIRDROP: not a merkle\");\r\n\r\n        // Update the root and reactivate\r\n        merkle_root_hash[airdrop_hash] = new_merkle_root;\r\n        airdrops[airdrop_hash].is_active = true; // usually we will temp disable the airdrop to prevent frontruns (unless send in private txns)\r\n    }\r\n\r\n    function DAPP_distribute_bulk_airdrop(uint project_id, uint airdrop_id, address[] memory receivers, uint gas_prev_tx) external  only_DAPP {\r\n        _charge_just_gas(project_id, gas_prev_tx);\r\n\r\n        bytes32 airdrop_hash = keccak256(abi.encodePacked(project_id, airdrop_id));\r\n\r\n        Airdrop memory current_drop = airdrops[airdrop_hash];\r\n        \r\n        // Verify if this is actually an airdrop meant to be distributes manually\r\n        require(merkle_root_hash[airdrop_hash] == bytes32(0), \"AIRDROP: This is not a bulk drop\");\r\n        require(current_drop.is_active, \"AIRDROP: Inactive\");\r\n\r\n        // Since we do this every 24 hours we sometimes might distribute after ending a drop\r\n        // as extra safety, we only allow distributing up to 2 days after but not after this \r\n        // anymore\r\n        require(block.timestamp <= current_drop.expires_at + 2 days, \"Distribute expired\");\r\n\r\n        uint airdrop_amount = current_drop.amount;\r\n        address token = projects[project_id].token;\r\n\r\n        // Transfer to tokens to receivers\r\n        uint dropped = 0;\r\n        for (uint i = 0; i < receivers.length; i++) {\r\n            address receiver = receivers[i];\r\n\r\n            // Send out the tokens or eth \r\n            if (current_drop.is_eth) {\r\n                payable(receiver).transfer(airdrop_amount);\r\n            } else {\r\n                TransferHelper.safeTransfer(token, receiver, airdrop_amount);\r\n            }\r\n            \r\n            // Keep check of drop count to make sure not more is dropped than intended\r\n            dropped += 1;\r\n        }\r\n\r\n        require(dropped <= current_drop.drops_left, \"No drops left!\");\r\n        airdrops[airdrop_hash].drops_left -= dropped;\r\n\r\n        // Update reserved tokens (if applicable)\r\n        if (!current_drop.is_eth) {\r\n            projects[project_id].tokens_reserved -= (dropped * current_drop.amount);\r\n        }\r\n        \r\n        // auto-finalize\r\n        if (airdrops[airdrop_hash].drops_left  == 0) {\r\n            _finalize_airdrop(airdrop_hash, project_id);\r\n        }\r\n    }\r\n\r\n    function claim_airdrop(uint256 path, bytes32[] memory witness, uint project_id, uint256 airdrop_id) external {\r\n        bytes32 sender_hash = keccak256(abi.encodePacked(msg.sender, project_id, airdrop_id));\r\n        bytes32 airdrop_hash = keccak256(abi.encodePacked(project_id, airdrop_id));\r\n        \r\n        Airdrop memory current_drop = airdrops[airdrop_hash];\r\n\r\n        require(!airdrop_claimed[sender_hash],                          \"CLAIM: Already claimed\");\r\n        require(_check_merkle_tree(airdrop_hash, witness, path),        \"CLAIM: Not whitelisted\");\r\n        require(current_drop.is_active,                                 \"CLAIM: Airdrop inactive\"); // Frontrun safety by first deactivating\r\n        require(block.timestamp <= current_drop.expires_at + 2 days,    \"CLAIM: Drop Expired!\");    // Whitelist gets updated every 24 hours as well, so allow some slack\r\n\r\n        airdrop_claimed[sender_hash] = true;\r\n        \r\n        require(airdrops[airdrop_hash].drops_left >= 1, \"CLAIM: no drops left\");\r\n        airdrops[airdrop_hash].drops_left -= 1;\r\n\r\n        if (current_drop.is_eth) {\r\n           payable(msg.sender).transfer(current_drop.amount);\r\n        } else {\r\n            TransferHelper.safeTransfer(projects[project_id].token, msg.sender, current_drop.amount);\r\n            projects[project_id].tokens_reserved -= current_drop.amount;\r\n        }\r\n\r\n        // auto-finalize\r\n        if (airdrops[airdrop_hash].drops_left  == 0) {\r\n            _finalize_airdrop(airdrop_hash, project_id);\r\n        }\r\n    }\r\n\r\n    function DAPP_finalize_airdrop(uint project_id, uint airdrop_id) external only_DAPP {\r\n        bytes32 airdrop_hash = keccak256(abi.encodePacked(project_id, airdrop_id));\r\n        \r\n        // Check if this can be called yet\r\n        if (airdrops[airdrop_hash].drops_left > 0) {\r\n           require(block.timestamp >= airdrops[airdrop_hash].expires_at + 2 days, \"Cant refund yet\");\r\n        }\r\n\r\n        _finalize_airdrop(airdrop_hash, project_id);\r\n    }\r\n\r\n    // We need to adjust airdrop when we update the merkle-root to prevent front running to be in two batches\r\n    // we can skip this when the update txs are submitted on private RPC\r\n    function DAPP_temp_disable_airdrop(uint project_id, uint airdrop_id, bool status) public only_DAPP {\r\n        bytes32 airdrop_hash = keccak256(abi.encodePacked(project_id, airdrop_id));\r\n        airdrops[airdrop_hash].is_active = status;\r\n    }\r\n    \r\n    // TERMINATORS\r\n    // While terminate will kill the project it's possible to withdraw everything that is currently\r\n    // not reserved for a lottery ot airdrop. However, this will cause issues with the bounties\r\n    // and hence should be executed  by the DAPP after deleting active bounties\r\n    function DAPP_withdraw_partial(uint project_id, uint gas_fee_of_prev_tx) external only_DAPP {\r\n        Project memory project = projects[project_id];\r\n        require(project.active, \"Non existent\");\r\n\r\n        // ETH side\r\n        require(gas_fee_of_prev_tx <= project.eth_balance, \"Cant cover gas refund\");\r\n        uint eth_to_refund = project.eth_balance - gas_fee_of_prev_tx;\r\n        if (eth_to_refund > 0) {\r\n            projects[project_id].eth_balance = 0; \r\n            gas_reserved += gas_fee_of_prev_tx;\r\n            payable(project.owner).transfer(eth_to_refund);\r\n        }\r\n\r\n        // Token side, note the difference is that only non reserved tokens are send\r\n        if (project.token != address(0)) {\r\n            \r\n            // All tokens in the contract\r\n            uint total_tokens = IERC20(project.token).balanceOf(address(this));\r\n\r\n            // Unreserved tokens\r\n            uint tokens_to_refund = total_tokens - project.tokens_reserved;\r\n            if (tokens_to_refund > 0) {\r\n                TransferHelper.safeTransfer(project.token, project.owner, tokens_to_refund);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    // Note this will send as much as we can, this includes tokens reserved for lotteries or airdrops\r\n    // rendering those invalid. There will be no additional checks if this ETH still exists when awarding\r\n    // hence this only should be used when the DAPP erased every record for this project prior to calling\r\n    function DAPP_terminate_project(uint project_id, uint gas_fee_of_prev_tx) external only_DAPP {\r\n        Project memory project = projects[project_id];\r\n        require(project.active, \"Non existent\");\r\n        \r\n        // ETH side\r\n        require(gas_fee_of_prev_tx <= project.eth_balance, \"Cant cover gas refund\");\r\n        uint eth_to_refund = project.eth_balance - gas_fee_of_prev_tx;\r\n        if (eth_to_refund > 0) {\r\n            project.eth_balance = 0; \r\n            gas_reserved += gas_fee_of_prev_tx;\r\n            payable(project.owner).transfer(eth_to_refund);\r\n        }\r\n     \r\n        // Token side \r\n        if (project.token != address(0)) {\r\n            // All tokens in the contract\r\n            uint tokens_to_refund = IERC20(project.token).balanceOf(address(this));\r\n            if (tokens_to_refund > 0) {\r\n                TransferHelper.safeTransfer(project.token, project.owner, tokens_to_refund);\r\n            }\r\n        }\r\n\r\n        // Remove project, this will invalidate current bounties\r\n         delete projects[project_id];\r\n\r\n    }\r\n\r\n    function DAPP_withdraw_all_eth() external only_DAPP {\r\n        require(safety_enabled, \"Can't use this anymore\");\r\n        payable(DAPP_controller).transfer(address(this).balance);\r\n    }\r\n\r\n    function DAPP_send_token(address token, uint amount) external only_DAPP {\r\n        require(safety_enabled, \"Can't use this anymore\");\r\n        TransferHelper.safeTransfer(token, DAPP_controller, amount);\r\n    }\r\n\r\n    // Only call this when sure contract is functioning as expected\r\n    // this will remove the possibility to send out ETH and tokens\r\n    // in case it would get stuck\r\n    function DAPP_permanantely_revoke_safety() external only_DAPP {\r\n        safety_enabled = false;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    // BASE - some info view functions\r\n    function project_token_balance(uint project_id) public view returns(uint) {\r\n        address token = projects[project_id].token;\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    function burned_tokens(uint project_id) external view returns(uint) {\r\n        return IERC20(projects[project_id].token).balanceOf(DEAD);\r\n    }\r\n\r\n    function get_pair(uint project_id) public view returns(address) {\r\n        address tokenA = projects[project_id].token; \r\n        address tokenB = uniswapRouter.WETH();\r\n        address pairTokens =  IUniswapFactory(uniswapRouter.factory()).getPair(tokenA, tokenB);\r\n        return pairTokens;\r\n    }\r\n\r\n    function burned_lp(uint project_id) external view returns(uint) {\r\n        address pairTokens = get_pair(project_id);\r\n        return IERC20(pairTokens).balanceOf(DEAD);\r\n    }\r\n\r\n    function check_token_balance(uint project_id, address wallet) external view returns(uint) {\r\n        return IERC20(projects[project_id].token).balanceOf(wallet);\r\n    }\r\n\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sai_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas_prev_tx\",\"type\":\"uint256\"}],\"name\":\"DAPP_add_lp_and_burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lottery_id\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gas_prev_tx\",\"type\":\"uint256\"}],\"name\":\"DAPP_award_lottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sai_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas_prev_tx\",\"type\":\"uint256\"}],\"name\":\"DAPP_buyback_and_burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAPP_controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"DAPP_create_SAI_engaged_project\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrop_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrop_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number_of_airdrops\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkle_root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expire_stamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"is_eth\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"sai_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas_prev_tx\",\"type\":\"uint256\"}],\"name\":\"DAPP_create_airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lottery_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tot_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"is_eth\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"sai_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas_prev_tx\",\"type\":\"uint256\"}],\"name\":\"DAPP_create_lottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrop_id\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"gas_prev_tx\",\"type\":\"uint256\"}],\"name\":\"DAPP_distribute_bulk_airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrop_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_expire_stamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas_prev_tx\",\"type\":\"uint256\"}],\"name\":\"DAPP_extend_airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrop_id\",\"type\":\"uint256\"}],\"name\":\"DAPP_finalize_airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAPP_manual_withdraw_gas_fee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAPP_permanantely_revoke_safety\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DAPP_send_token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_controller\",\"type\":\"address\"}],\"name\":\"DAPP_set_DAPP_controller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_gas_wallet\",\"type\":\"address\"}],\"name\":\"DAPP_set_gas_wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_fee_wallet\",\"type\":\"address\"}],\"name\":\"DAPP_set_sai_fee_wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_threshold\",\"type\":\"uint256\"}],\"name\":\"DAPP_set_send_threshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gas_prev_tx\",\"type\":\"uint256\"}],\"name\":\"DAPP_set_verified_token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrop_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"DAPP_temp_disable_airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas_fee_of_prev_tx\",\"type\":\"uint256\"}],\"name\":\"DAPP_terminate_project\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrop_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"new_merkle_root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"gas_prev_tx\",\"type\":\"uint256\"}],\"name\":\"DAPP_update_merkle_airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAPP_withdraw_all_eth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas_fee_of_prev_tx\",\"type\":\"uint256\"}],\"name\":\"DAPP_withdraw_partial\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAPP_withdraw_sai_fee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowed_token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"}],\"name\":\"burned_lp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"}],\"name\":\"burned_tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"change_project_owner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"check_token_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"path\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"witness\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrop_id\",\"type\":\"uint256\"}],\"name\":\"claim_airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"}],\"name\":\"deposit_eth_to_project\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"token_amount\",\"type\":\"uint256\"}],\"name\":\"deposit_tokens_to_project\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gas_reserved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gas_wallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"}],\"name\":\"get_pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lottery_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lottery_is_eth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"}],\"name\":\"project_token_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projects\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"project_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eth_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens_reserved\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safety_enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sai_fee_wallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sai_reserved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"send_gas_at\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SocialAIEngaged", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://176e0ae1b9162fd9b7599d523a18a4e2bb0dab4c63e50fd1bdb115cad16547aa"}