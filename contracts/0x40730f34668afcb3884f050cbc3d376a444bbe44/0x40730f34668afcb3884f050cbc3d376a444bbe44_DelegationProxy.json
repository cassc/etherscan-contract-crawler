{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// File contracts/lib/IERC20.sol\r\npragma solidity 0.7.3;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/lib/Ownable.sol\r\npragma solidity 0.7.3;\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/lib/DelegationProxy.sol\r\npragma solidity 0.7.3;\r\n\r\ninterface StakingNFT {\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n  function ownerOf(uint256 tokenId) external view returns (address owner);\r\n  function approve(address to, uint256 tokenId) external;\r\n  function getApproved(uint256 tokenId) external view returns (address operator);\r\n  function setApprovalForAll(address operator, bool _approved) external;\r\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n  function transferFrom(address from, address to, uint256 tokenId) external;\r\n  function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n  function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) external;\r\n}\r\n\r\ninterface ValidatorShare {\r\n  function buyVoucher(uint256, uint256) external;\r\n  function withdrawRewards() external;\r\n  function sellVoucher(uint256, uint256) external;\r\n  function unstakeClaimTokens() external;\r\n  function getLiquidRewards(address user) external view returns (uint256);\r\n}\r\n\r\ninterface ValidatorShare_New {\r\n  function buyVoucher(uint256, uint256) external returns(uint256);\r\n  function withdrawRewards() external;\r\n  function sellVoucher(uint256, uint256) external;\r\n  function unstakeClaimTokens() external;\r\n  function sellVoucher_new(uint256, uint256) external;\r\n  function unstakeClaimTokens_new(uint256) external;\r\n}\r\n\r\ninterface IStakeManager {\r\n  function getValidatorContract(uint256 validatorId) external view returns (address);\r\n  function token() external view returns (IERC20);\r\n  function NFTContract() external view returns (StakingNFT);\r\n}\r\n\r\ncontract DelegationProxy is Ownable {\r\n  uint256[] public validatorsList;\r\n  mapping(uint256 => bool) public validatorsLookup;\r\n\r\n  IStakeManager public stakeManager;\r\n\r\n  constructor(IStakeManager _stakeManager) {\r\n    require(_stakeManager != IStakeManager(0x0));\r\n\r\n    stakeManager = _stakeManager;\r\n  }\r\n\r\n  function getLiquidRewards(uint256 validatorId) public view returns(uint256) {\r\n    ValidatorShare delegationContract = ValidatorShare(stakeManager.getValidatorContract(validatorId));\r\n    require(delegationContract != ValidatorShare(0x0));\r\n\r\n    return delegationContract.getLiquidRewards(address(this));\r\n  }\r\n\r\n  function withdrawTokens(address tokenAddress, uint256 amount) public onlyOwner {\r\n    IERC20(tokenAddress).transfer(owner(), amount);\r\n  }\r\n\r\n  function delegate(uint256[] memory validators, uint256[] memory amount, uint256 totalAmount) public onlyOwner {\r\n    require(validators.length == amount.length);\r\n    \r\n    IERC20 token = stakeManager.token();\r\n    token.approve(address(stakeManager), totalAmount);\r\n    \r\n    for (uint256 i = 0; i < validators.length; ++i) {\r\n      uint256 validatorId = validators[i];\r\n\r\n      if (!validatorsLookup[validatorId]) {\r\n        validatorsLookup[validatorId] = true;\r\n        validatorsList.push(validatorId);\r\n      }\r\n\r\n      ValidatorShare delegationContract = ValidatorShare(stakeManager.getValidatorContract(validatorId));\r\n      require(delegationContract != ValidatorShare(0x0));\r\n\r\n      // buy voucher\r\n      delegationContract.buyVoucher(amount[i], 0);\r\n    }\r\n  }\r\n\r\n  function delegate_new(uint256[] memory validators, uint256[] memory amount, uint256 totalAmount) public onlyOwner {\r\n    require(validators.length == amount.length);\r\n    \r\n    IERC20 token = stakeManager.token();\r\n    token.approve(address(stakeManager), totalAmount);\r\n    \r\n    for (uint256 i = 0; i < validators.length; ++i) {\r\n      uint256 validatorId = validators[i];\r\n\r\n      if (!validatorsLookup[validatorId]) {\r\n        validatorsLookup[validatorId] = true;\r\n        validatorsList.push(validatorId);\r\n      }\r\n\r\n      ValidatorShare_New delegationContract = ValidatorShare_New(stakeManager.getValidatorContract(validatorId));\r\n      require(delegationContract != ValidatorShare_New(0x0));\r\n\r\n      // buy voucher\r\n      delegationContract.buyVoucher(amount[i], 0);\r\n    }\r\n  }\r\n\r\n  function transferRewards(uint256[] memory validators) public onlyOwner {\r\n    IERC20 token = stakeManager.token();\r\n    StakingNFT nft = stakeManager.NFTContract();\r\n\r\n    uint256 tokenBalanceBefore = token.balanceOf(address(this));\r\n\r\n    for (uint256 i = 0; i < validators.length; ++i) {\r\n      uint256 validatorId = validators[i];\r\n      \r\n      ValidatorShare delegationContract = ValidatorShare(stakeManager.getValidatorContract(validatorId));\r\n      require(delegationContract != ValidatorShare(0x0));\r\n\r\n      delegationContract.withdrawRewards();\r\n\r\n      uint256 rewards = token.balanceOf(address(this)) - tokenBalanceBefore;\r\n      token.transfer(nft.ownerOf(validatorId), rewards);\r\n    }\r\n  }\r\n\r\n  function collectRewards(uint256[] memory validators) public onlyOwner {\r\n    for (uint256 i = 0; i < validators.length; ++i) {\r\n      uint256 validatorId = validators[i];\r\n      \r\n      ValidatorShare delegationContract = ValidatorShare(stakeManager.getValidatorContract(validatorId));\r\n      require(delegationContract != ValidatorShare(0x0));\r\n\r\n      delegationContract.withdrawRewards();\r\n    }\r\n  }\r\n\r\n  function sellVoucher(uint256 validatorId, uint256 claimAmount, uint256 maximumSharesToBurn) public onlyOwner {\r\n    ValidatorShare delegationContract = ValidatorShare(stakeManager.getValidatorContract(validatorId));\r\n    require(delegationContract != ValidatorShare(0x0));\r\n\r\n    delegationContract.sellVoucher(claimAmount, maximumSharesToBurn);\r\n  }\r\n\r\n  function sellVoucher_new(uint256 validatorId, uint256 claimAmount, uint256 maximumSharesToBurn) public onlyOwner {\r\n    ValidatorShare_New delegationContract = ValidatorShare_New(stakeManager.getValidatorContract(validatorId));\r\n    require(delegationContract != ValidatorShare_New(0x0));\r\n\r\n    delegationContract.sellVoucher_new(claimAmount, maximumSharesToBurn);\r\n  }\r\n\r\n  function unstakeClaimTokens(uint256 validatorId) public onlyOwner {\r\n    ValidatorShare delegationContract = ValidatorShare(stakeManager.getValidatorContract(validatorId));\r\n    require(delegationContract != ValidatorShare(0x0));\r\n\r\n    delegationContract.unstakeClaimTokens();\r\n  }\r\n\r\n  function unstakeClaimTokens_new(uint256 validatorId, uint256 unbondNonce) public onlyOwner {\r\n    ValidatorShare_New delegationContract = ValidatorShare_New(stakeManager.getValidatorContract(validatorId));\r\n    require(delegationContract != ValidatorShare_New(0x0));\r\n\r\n    delegationContract.unstakeClaimTokens_new(unbondNonce);\r\n  }\r\n\r\n  function callAny(address target, bytes memory data) public onlyOwner {\r\n    (bool success, ) = target.call(data); /* bytes memory returnData */\r\n    require(success, \"Call failed\");\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IStakeManager\",\"name\":\"_stakeManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callAny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"validators\",\"type\":\"uint256[]\"}],\"name\":\"collectRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"validators\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"validators\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"delegate_new\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"getLiquidRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumSharesToBurn\",\"type\":\"uint256\"}],\"name\":\"sellVoucher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumSharesToBurn\",\"type\":\"uint256\"}],\"name\":\"sellVoucher_new\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeManager\",\"outputs\":[{\"internalType\":\"contract IStakeManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"validators\",\"type\":\"uint256[]\"}],\"name\":\"transferRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"}],\"name\":\"unstakeClaimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unbondNonce\",\"type\":\"uint256\"}],\"name\":\"unstakeClaimTokens_new\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validatorsList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validatorsLookup\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DelegationProxy", "CompilerVersion": "v0.7.3+commit.9bfce1f6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000005e3ef299fddf15eaa0432e6e66473ace8c13d908", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bf774793574604348731725830a9f54a70b3727e62594e6462c3de8dc74c69d0"}