{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    int256 private constant _INT256_MIN = -2**255;\\n\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, 'SM4E');\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = sub(x, y, 'SM12');\\n    }\\n\\n    function sub(\\n        uint256 x,\\n        uint256 y,\\n        string memory message\\n    ) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, message);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, 'SM2A');\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, 'SM43');\\n        return a / b;\\n    }\\n\\n    function ceil_div(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = div(a, b);\\n        if (a != mul(b, c)) {\\n            return add(c, 1);\\n        }\\n    }\\n\\n    function toUint32(uint256 n) internal pure returns (uint32) {\\n        require(n <= type(uint32).max, 'SM50');\\n        return uint32(n);\\n    }\\n\\n    function toUint64(uint256 n) internal pure returns (uint64) {\\n        require(n <= type(uint64).max, 'SM54');\\n        return uint64(n);\\n    }\\n\\n    function toUint112(uint256 n) internal pure returns (uint112) {\\n        require(n <= type(uint112).max, 'SM51');\\n        return uint112(n);\\n    }\\n\\n    function toInt256(uint256 unsigned) internal pure returns (int256 signed) {\\n        require(unsigned <= uint256(type(int256).max), 'SM34');\\n        signed = int256(unsigned);\\n    }\\n\\n    // int256\\n\\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), 'SM4D');\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), 'SM11');\\n    }\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), 'SM29');\\n\\n        c = a * b;\\n        require(c / a == b, 'SM29');\\n    }\\n\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, 'SM43');\\n        require(!(b == -1 && a == _INT256_MIN), 'SM42');\\n\\n        return a / b;\\n    }\\n\\n    function neg_floor_div(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = div(a, b);\\n        if ((a < 0 && b > 0) || (a >= 0 && b < 0)) {\\n            if (a != mul(b, c)) {\\n                c = sub(c, 1);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TokenShares.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../interfaces/IWETH.sol';\\nimport './SafeMath.sol';\\nimport './TransferHelper.sol';\\n\\n\\nlibrary TokenShares {\\n    using SafeMath for uint256;\\n    using TransferHelper for address;\\n\\n    uint256 private constant PRECISION = 10**18;\\n    uint256 private constant TOLERANCE = 10**18 + 10**16;\\n    uint256 private constant TOTAL_SHARES_PRECISION = 10**18;\\n\\n    event UnwrapFailed(address to, uint256 amount);\\n\\n    // represents wrapped native currency (WETH or WMATIC)\\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; \\n\\n    struct Data {\\n        mapping(address => uint256) totalShares;\\n    }\\n\\n    function sharesToAmount(\\n        Data storage data,\\n        address token,\\n        uint256 share,\\n        uint256 amountLimit,\\n        address refundTo\\n    ) external returns (uint256) {\\n        if (share == 0) {\\n            return 0;\\n        }\\n        if (token == WETH_ADDRESS || isNonRebasing(token)) {\\n            return share;\\n        }\\n\\n        uint256 totalTokenShares = data.totalShares[token];\\n        require(totalTokenShares >= share, 'TS3A');\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        uint256 value = balance.mul(share).div(totalTokenShares);\\n        data.totalShares[token] = totalTokenShares.sub(share);\\n\\n        if (amountLimit > 0) {\\n            uint256 amountLimitWithTolerance = amountLimit.mul(TOLERANCE).div(PRECISION);\\n            if (value > amountLimitWithTolerance) {\\n                TransferHelper.safeTransfer(token, refundTo, value.sub(amountLimitWithTolerance));\\n                return amountLimitWithTolerance;\\n            }\\n        }\\n\\n        return value;\\n    }\\n\\n    function amountToShares(\\n        Data storage data,\\n        address token,\\n        uint256 amount,\\n        bool wrap\\n    ) external returns (uint256) {\\n        if (amount == 0) {\\n            return 0;\\n        }\\n        if (token == WETH_ADDRESS) {\\n            if (wrap) {\\n                require(msg.value >= amount, 'TS03');\\n                IWETH(token).deposit{ value: amount }();\\n            } else {\\n                token.safeTransferFrom(msg.sender, address(this), amount);\\n            }\\n            return amount;\\n        } else if (isNonRebasing(token)) {\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\n            return amount;\\n        } else {\\n            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\\n\\n            return amountToSharesHelper(data, token, balanceBefore, balanceAfter);\\n        }\\n    }\\n\\n    function amountToSharesWithoutTransfer(\\n        Data storage data,\\n        address token,\\n        uint256 amount,\\n        bool wrap\\n    ) external returns (uint256) {\\n        if (token == WETH_ADDRESS) {\\n            if (wrap) {\\n                // require(msg.value >= amount, 'TS03'); // Duplicate check in TwapRelayer.sell\\n                IWETH(token).deposit{ value: amount }();\\n            }\\n            return amount;\\n        } else if (isNonRebasing(token)) {\\n            return amount;\\n        } else {\\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\\n            uint256 balanceBefore = balanceAfter.sub(amount);\\n            return amountToSharesHelper(data, token, balanceBefore, balanceAfter);\\n        }\\n    }\\n\\n    function amountToSharesHelper(\\n        Data storage data,\\n        address token,\\n        uint256 balanceBefore,\\n        uint256 balanceAfter\\n    ) internal returns (uint256) {\\n        uint256 totalTokenShares = data.totalShares[token];\\n        require(balanceBefore > 0 || totalTokenShares == 0, 'TS30');\\n        require(balanceAfter > balanceBefore, 'TS2C');\\n\\n        if (balanceBefore > 0) {\\n            if (totalTokenShares == 0) {\\n                totalTokenShares = balanceBefore.mul(TOTAL_SHARES_PRECISION);\\n            }\\n            uint256 newShares = totalTokenShares.mul(balanceAfter).div(balanceBefore);\\n            require(balanceAfter < type(uint256).max.div(newShares), 'TS73'); // to prevent overflow at execution\\n            data.totalShares[token] = newShares;\\n            return newShares - totalTokenShares;\\n        } else {\\n            totalTokenShares = balanceAfter.mul(TOTAL_SHARES_PRECISION);\\n            require(totalTokenShares < type(uint256).max.div(totalTokenShares), 'TS73'); // to prevent overflow at execution\\n            data.totalShares[token] = totalTokenShares;\\n            return totalTokenShares;\\n        }\\n    }\\n\\n    function onUnwrapFailed(address to, uint256 amount) external {\\n        emit UnwrapFailed(to, amount);\\n        IWETH(WETH_ADDRESS).deposit{ value: amount }();\\n        TransferHelper.safeTransfer(WETH_ADDRESS, to, amount);\\n    }\\n\\n    \\n    // constant mapping for nonRebasingToken\\n    function isNonRebasing(address token) internal pure returns (bool) {\\n        if (token == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) return true;\\n        if (token == 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48) return true;\\n        if (token == 0xdAC17F958D2ee523a2206206994597C13D831ec7) return true;\\n        if (token == 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599) return true;\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\n\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH4B');\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH05');\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH0E');\\n    }\\n\\n    function safeTransferETH(\\n        address to,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) internal {\\n        (bool success, ) = to.call{ value: value, gas: gasLimit }('');\\n        require(success, 'TH3F');\\n    }\\n\\n    function transferETH(\\n        address to,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) internal returns (bool success) {\\n        (success, ) = to.call{ value: value, gas: gasLimit }('');\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnwrapFailed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TokenShares", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}