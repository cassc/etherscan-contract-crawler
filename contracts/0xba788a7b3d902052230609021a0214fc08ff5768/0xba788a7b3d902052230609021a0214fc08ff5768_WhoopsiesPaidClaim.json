{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"WhoopsiesPaidClaim.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/// @title ERC721 Implementation of Whoopsies v2 Collection\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\nimport {IERC721} from \\\"./interfaces/IERC721.sol\\\";\\r\\nimport {IWhoopsiesV2} from \\\"./interfaces/IWhoopsiesV2.sol\\\";\\r\\nimport {Ownable} from \\\"./solady/Ownable.sol\\\";\\r\\n\\r\\n/// @custom:security-contact captainunknown7@gmail.com\\r\\ncontract WhoopsiesPaidClaim is Ownable {\\r\\n    address constant whoopsiesv1 = 0x565AbC3FEaa3bC3820B83620f4BbF16B5c4D47a3;\\r\\n    address constant whoopsiesv2 = 0x646Eb9B8E6bED62c0e46b67f3EfdEF926Fb9D621;\\r\\n    uint96 public claimPriceFlatFee;\\r\\n    uint96 public claimPricePerTokenFee;\\r\\n    bool public isClaimable;\\r\\n\\r\\n    error InsufficientPayment();\\r\\n    error ClaimsNotOpen();\\r\\n\\r\\n    constructor() {\\r\\n        isClaimable = false;\\r\\n        _initializeOwner(msg.sender);\\r\\n    }\\r\\n\\r\\n    function claimV2NFTs(uint256[] calldata requestedTokenIds) public payable {\\r\\n        if(!isClaimable) revert ClaimsNotOpen();\\r\\n        unchecked {\\r\\n            if(msg.value < (claimPriceFlatFee + (claimPricePerTokenFee * requestedTokenIds.length))) revert InsufficientPayment();    \\r\\n        }\\r\\n\\r\\n        // Transfer v1 tokens to contract for claim\\r\\n        for (uint256 i; i < requestedTokenIds.length;) {\\r\\n            IERC721(whoopsiesv1).transferFrom(msg.sender, address(this), requestedTokenIds[i]);\\r\\n            unchecked {\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Claim v2\\r\\n        IWhoopsiesV2(whoopsiesv2).toggleV2ClaimActive();\\r\\n        IWhoopsiesV2(whoopsiesv2).claimV2NFTs(requestedTokenIds);\\r\\n        IWhoopsiesV2(whoopsiesv2).toggleV2ClaimActive();\\r\\n\\r\\n        // Send v2 to caller\\r\\n        for (uint256 i; i < requestedTokenIds.length;) {\\r\\n            IERC721(whoopsiesv2).transferFrom(address(this), msg.sender, requestedTokenIds[i]);\\r\\n            unchecked {\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function toggleIsClaimable() public onlyOwner {\\r\\n        isClaimable = !isClaimable;\\r\\n    }\\r\\n\\r\\n    function setClaimPrice(uint96 newClaimFlatFee, uint96 newClaimPerTokenFee) public onlyOwner {\\r\\n        claimPriceFlatFee = newClaimFlatFee;\\r\\n        claimPricePerTokenFee = newClaimPerTokenFee;\\r\\n    }\\r\\n\\r\\n    function reclaimWhoopsiesOwnership() public onlyOwner {\\r\\n        Ownable(whoopsiesv2).transferOwnership(msg.sender);\\r\\n    }\\r\\n\\r\\n    function withdrawETH() public payable onlyOwner {\\r\\n        payable(msg.sender).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function onERC721Received(address, address, uint256, bytes calldata) external view returns(bytes4) {\\r\\n        if(msg.sender == whoopsiesv2) return 0x150b7a02;\\r\\n        return 0x00000000;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"solady/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Simple single owner authorization mixin.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\r\\n///\\r\\n/// @dev Note:\\r\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\r\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\r\\n///\\r\\n/// While the ownable portion follows\\r\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\r\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\r\\nabstract contract Ownable {\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                       CUSTOM ERRORS                        */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The caller is not authorized to call the function.\\r\\n    error Unauthorized();\\r\\n\\r\\n    /// @dev The `newOwner` cannot be the zero address.\\r\\n    error NewOwnerIsZeroAddress();\\r\\n\\r\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\r\\n    error NoHandoverRequest();\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                           EVENTS                           */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\r\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\r\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\r\\n    /// despite it not being as lightweight as a single argument event.\\r\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\r\\n\\r\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\r\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\r\\n\\r\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\r\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\r\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\r\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\r\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\r\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\r\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\r\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                          STORAGE                           */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\r\\n    /// It is intentionally chosen to be a high value\\r\\n    /// to avoid collision with lower slots.\\r\\n    /// The choice of manual storage layout is to enable compatibility\\r\\n    /// with both regular and upgradeable contracts.\\r\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\r\\n\\r\\n    /// The ownership handover slot of `newOwner` is given by:\\r\\n    /// ```\\r\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\r\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\r\\n    /// ```\\r\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\r\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                     INTERNAL FUNCTIONS                     */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Initializes the owner directly without authorization guard.\\r\\n    /// This function must be called upon initialization,\\r\\n    /// regardless of whether the contract is upgradeable or not.\\r\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\r\\n    /// and to save gas in case the initial owner is not the caller.\\r\\n    /// For performance reasons, this function will not check if there\\r\\n    /// is an existing owner.\\r\\n    function _initializeOwner(address newOwner) internal virtual {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Clean the upper 96 bits.\\r\\n            newOwner := shr(96, shl(96, newOwner))\\r\\n            // Store the new value.\\r\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\r\\n            // Emit the {OwnershipTransferred} event.\\r\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets the owner directly without authorization guard.\\r\\n    function _setOwner(address newOwner) internal virtual {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\r\\n            // Clean the upper 96 bits.\\r\\n            newOwner := shr(96, shl(96, newOwner))\\r\\n            // Emit the {OwnershipTransferred} event.\\r\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\r\\n            // Store the new value.\\r\\n            sstore(ownerSlot, newOwner)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Throws if the sender is not the owner.\\r\\n    function _checkOwner() internal view virtual {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // If the caller is not the stored owner, revert.\\r\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\r\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\r\\n    /// Override to return a different value if needed.\\r\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\r\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\r\\n        return 48 * 3600;\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\r\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if iszero(shl(96, newOwner)) {\\r\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n        _setOwner(newOwner);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows the owner to renounce their ownership.\\r\\n    function renounceOwnership() public payable virtual onlyOwner {\\r\\n        _setOwner(address(0));\\r\\n    }\\r\\n\\r\\n    /// @dev Request a two-step ownership handover to the caller.\\r\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\r\\n    function requestOwnershipHandover() public payable virtual {\\r\\n        unchecked {\\r\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                // Compute and set the handover slot to `expires`.\\r\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\r\\n                mstore(0x00, caller())\\r\\n                sstore(keccak256(0x0c, 0x20), expires)\\r\\n                // Emit the {OwnershipHandoverRequested} event.\\r\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\r\\n    function cancelOwnershipHandover() public payable virtual {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Compute and set the handover slot to 0.\\r\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\r\\n            mstore(0x00, caller())\\r\\n            sstore(keccak256(0x0c, 0x20), 0)\\r\\n            // Emit the {OwnershipHandoverCanceled} event.\\r\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\r\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\r\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Compute and set the handover slot to 0.\\r\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\r\\n            mstore(0x00, pendingOwner)\\r\\n            let handoverSlot := keccak256(0x0c, 0x20)\\r\\n            // If the handover does not exist, or has expired.\\r\\n            if gt(timestamp(), sload(handoverSlot)) {\\r\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            // Set the handover slot to 0.\\r\\n            sstore(handoverSlot, 0)\\r\\n        }\\r\\n        _setOwner(pendingOwner);\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   PUBLIC READ FUNCTIONS                    */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns the owner of the contract.\\r\\n    function owner() public view virtual returns (address result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := sload(not(_OWNER_SLOT_NOT))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\r\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Compute the handover slot.\\r\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\r\\n            mstore(0x00, pendingOwner)\\r\\n            // Load the handover slot.\\r\\n            result := sload(keccak256(0x0c, 0x20))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                         MODIFIERS                          */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Marks a function as only callable by the owner.\\r\\n    modifier onlyOwner() virtual {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"interfaces/IWhoopsiesV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/// @title ERC721 Implementation of Whoopsies v2 Collection\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\n/// @custom:security-contact captainunknown7@gmail.com\\r\\ninterface IWhoopsiesV2 {\\r\\n    function claimV2NFTs(uint256[] calldata requestedTokenIds) external;\\r\\n    function toggleV2ClaimActive() external;\\r\\n}\"\r\n    },\r\n    \"interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC721 compliant contract.\\r\\n */\\r\\ninterface IERC721 {\\r\\n    /**\\r\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n     */\\r\\n    event Transfer(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 indexed tokenId\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed approved,\\r\\n        uint256 indexed tokenId\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\r\\n     */\\r\\n    event ApprovalForAll(\\r\\n        address indexed owner,\\r\\n        address indexed operator,\\r\\n        bool approved\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of tokens in ``owner``'s account.\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\r\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\r\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(\\r\\n        uint256 tokenId\\r\\n    ) external view returns (address operator);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}\\r\\n     */\\r\\n    function isApprovedForAll(\\r\\n        address owner,\\r\\n        address operator\\r\\n    ) external view returns (bool);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ClaimsNotOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientPayment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPriceFlatFee\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPricePerTokenFee\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"requestedTokenIds\",\"type\":\"uint256[]\"}],\"name\":\"claimV2NFTs\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isClaimable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reclaimWhoopsiesOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"newClaimFlatFee\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"newClaimPerTokenFee\",\"type\":\"uint96\"}],\"name\":\"setClaimPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleIsClaimable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "WhoopsiesPaidClaim", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}