{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IORChallengeSpv.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IORChallengeSpv {\\n    struct VerifyInfoSlot {\\n        address account; // Contract address\\n        bytes32 key;\\n        uint value;\\n    }\\n\\n    struct VerifyInfo {\\n        uint[] data;\\n        VerifyInfoSlot[] slots;\\n    }\\n\\n    function verifyChallenge(\\n        bytes calldata proof,\\n        bytes32[2] calldata spvBlockHashs,\\n        bytes32 verifyInfoHash\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IORMakerDeposit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {IORChallengeSpv} from \\\"./IORChallengeSpv.sol\\\";\\nimport {BridgeLib} from \\\"../library/BridgeLib.sol\\\";\\nimport {RuleLib} from \\\"../library/RuleLib.sol\\\";\\n\\ninterface IORMakerDeposit {\\n    struct ChallengeInfo {\\n        uint sourceTxFrom; // From of the source tx. Uint to support other networks\\n        uint64 sourceTxTime; // Timestamp of the source tx\\n        address challenger; // Challenger\\n        address freezeToken; // Freeze token on L1\\n        uint64 challengeUserRatio; // Manager's _challengeUserRatio\\n        uint freezeAmount0; // Owner's freeze amount\\n        uint freezeAmount1; // Challenger's freeze amount\\n        uint64 challengeTime; // Time of challenge\\n        uint64 abortTime; // Time of abort caused by checkChallenge\\n        uint64 verifiedTime0; // Time of verifyChallengeSource. Greater than 0 means verification passed\\n        uint64 verifiedTime1; // Time of verifyChallengeDest. Greater than 0 means verification passed\\n        bytes32 verifiedDataHash0; // Data's hash of verifyChallengeSource\\n    }\\n\\n    event ColumnArrayUpdated(\\n        address indexed impl,\\n        bytes32 columnArrayHash,\\n        address[] dealers,\\n        address[] ebcs,\\n        uint64[] chainIds\\n    );\\n    event SpvUpdated(address indexed impl, uint64 chainId, address spv);\\n    event ResponseMakersUpdated(address indexed impl, uint[] responseMakers);\\n    event RulesRootUpdated(address indexed impl, address ebc, RuleLib.RootWithVersion rootWithVersion);\\n    event ChallengeInfoUpdated(bytes32 indexed challengeId, ChallengeInfo challengeInfo);\\n\\n    function initialize(address owner_) external;\\n\\n    function owner() external view returns (address);\\n\\n    function mdcFactory() external view returns (address);\\n\\n    function columnArrayHash() external view returns (bytes32);\\n\\n    function updateColumnArray(\\n        uint64 enableTime,\\n        address[] calldata dealers,\\n        address[] calldata ebcs,\\n        uint64[] calldata chainIds\\n    ) external;\\n\\n    function spv(uint64 chainId) external view returns (address);\\n\\n    function updateSpvs(uint64 enableTime, address[] calldata spvs, uint64[] calldata chainIds) external;\\n\\n    function responseMakersHash() external view returns (bytes32);\\n\\n    function updateResponseMakers(uint64 enableTime, bytes[] calldata responseMakerSignatures) external;\\n\\n    function freezeAssets(address token) external view returns (uint);\\n\\n    function deposit(address token, uint amount) external payable;\\n\\n    function withdraw(address token, uint amount) external;\\n\\n    function rulesRoot(address ebc) external view returns (RuleLib.RootWithVersion memory);\\n\\n    function updateRulesRoot(\\n        uint64 enableTime,\\n        address ebc,\\n        RuleLib.Rule[] calldata rules,\\n        RuleLib.RootWithVersion calldata rootWithVersion,\\n        uint64[] calldata sourceChainIds,\\n        uint[] calldata pledgeAmounts\\n    ) external payable;\\n\\n    function updateRulesRootERC20(\\n        uint64 enableTime,\\n        address ebc,\\n        RuleLib.Rule[] calldata rules,\\n        RuleLib.RootWithVersion calldata rootWithVersion,\\n        uint64[] calldata sourceChainIds,\\n        uint[] calldata pledgeAmounts,\\n        address token\\n    ) external;\\n\\n    // function challenge(\\n    //     uint64 sourceChainId,\\n    //     bytes32 sourceTxHash,\\n    //     uint64 sourceTxTime,\\n    //     address freezeToken,\\n    //     uint freezeAmount1\\n    // ) external payable;\\n\\n    // function checkChallenge(uint64 sourceChainId, bytes32 sourceTxHash, uint[] calldata verifiedData0) external;\\n\\n    // function verifyChallengeSource(\\n    //     address spvAddress,\\n    //     bytes calldata proof,\\n    //     bytes32[2] calldata spvBlockHashs,\\n    //     IORChallengeSpv.VerifyInfo calldata verifyInfo,\\n    //     bytes calldata rawDatas\\n    // ) external;\\n\\n    // function verifyChallengeDest(\\n    //     address spvAddress,\\n    //     bytes calldata proof,\\n    //     bytes32[2] calldata spvBlockHashs,\\n    //     IORChallengeSpv.VerifyInfo calldata verifyInfo,\\n    //     uint[] calldata verifiedData0,\\n    //     bytes calldata rawDatas\\n    // ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IORManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {BridgeLib} from \\\"../library/BridgeLib.sol\\\";\\n\\ninterface IORManager {\\n    event ChainInfoUpdated(uint64 indexed id, BridgeLib.ChainInfo chainInfo);\\n    event ChainTokenUpdated(uint64 indexed id, BridgeLib.TokenInfo tokenInfo);\\n    event EbcsUpdated(address[] ebcs, bool[] statuses);\\n    event SubmitterFeeUpdated(address submitter);\\n    event ProtocolFeeUpdated(uint64 protocolFee);\\n    event MinChallengeRatioUpdated(uint64 minChallengeRatio);\\n    event ChallengeUserRatioUpdated(uint64 challengeUserRatio);\\n    event FeeChallengeSecondUpdated(uint64 feeChallengeSecond);\\n    event FeeTakeOnChallengeSecondUpdated(uint64 feeTakeOnChallengeSecond);\\n    event MaxMDCLimitUpdated(uint64 maxMDCLimit);\\n    event ExtraTransferContractsUpdated(uint64[] chainIds, uint[] extraTransferContracts);\\n\\n    function registerChains(uint64 enableTime, BridgeLib.ChainInfo[] calldata chains_) external;\\n\\n    function updateChainSpvs(uint64 enableTime, uint64 id, address[] calldata spvs, uint[] calldata indexs) external;\\n\\n    function getChainInfo(uint64 id) external view returns (BridgeLib.ChainInfo memory);\\n\\n    function updateChainTokens(\\n        uint64 enableTime,\\n        uint64[] memory ids,\\n        BridgeLib.TokenInfo[] calldata tokenInfos\\n    ) external;\\n\\n    function getChainTokenInfo(uint64 id, uint token) external view returns (BridgeLib.TokenInfo memory);\\n\\n    function ebcIncludes(address ebc) external view returns (bool);\\n\\n    function updateEbcs(address[] calldata ebcs_, bool[] calldata statuses) external;\\n\\n    function submitter() external view returns (address);\\n\\n    function updateSubmitter(uint64 enableTime, address submitter_) external;\\n\\n    function protocolFee() external view returns (uint64);\\n\\n    function updateProtocolFee(uint64 enableTime, uint64 protocolFee_) external;\\n\\n    function minChallengeRatio() external view returns (uint64);\\n\\n    function updateMinChallengeRatio(uint64 enableTime, uint64 minChallengeRatio_) external;\\n\\n    function challengeUserRatio() external view returns (uint64);\\n\\n    function updateChallengeUserRatio(uint64 enableTime, uint64 challengeUserRatio_) external;\\n\\n    function feeChallengeSecond() external view returns (uint64);\\n\\n    function updateFeeChallengeSecond(uint64 enableTime, uint64 feeChallengeSecond_) external;\\n\\n    function feeTakeOnChallengeSecond() external view returns (uint64);\\n\\n    function updateFeeTakeOnChallengeSecond(uint64 enableTime, uint64 feeTakeOnChallengeSecond_) external;\\n\\n    function maxMDCLimit() external view returns (uint64);\\n\\n    function updateMaxMDCLimit(uint64 maxMDCLimit_) external;\\n\\n    function getExtraTransferContract(uint64 chainId) external view returns (uint);\\n\\n    function updateExtraTransferContracts(\\n        uint64 enableTime,\\n        uint64[] calldata chainIds,\\n        uint[] calldata extraTransferContracts\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IORMDCFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\nimport \\\"./IORManager.sol\\\";\\n\\ninterface IORMDCFactory {\\n    event MDCCreated(address maker, address mdc);\\n\\n    function manager() external view returns (address);\\n\\n    function implementation() external view returns (address);\\n\\n    function mdcCreatedTotal() external view returns (uint);\\n\\n    function createMDC() external;\\n\\n    function predictMDCAddress() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/library/BridgeLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nlibrary BridgeLib {\\n    struct TokenInfo {\\n        uint token; // uint160(address) will overflow in the token used for starknet\\n        address mainnetToken;\\n        uint8 decimals;\\n    }\\n\\n    struct ChainInfo {\\n        uint64 id;\\n        uint192 batchLimit;\\n        uint64 minVerifyChallengeSourceTxSecond;\\n        uint64 maxVerifyChallengeSourceTxSecond;\\n        uint64 minVerifyChallengeDestTxSecond;\\n        uint64 maxVerifyChallengeDestTxSecond;\\n        uint nativeToken;\\n        address[] spvs;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/library/ConstantsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nlibrary ConstantsLib {\\n    uint constant RATIO_MULTIPLE = 1000000;\\n\\n    uint constant MIN_ENABLE_DELAY = 120; // Unit: second\\n\\n    uint constant DEALER_WITHDRAW_DELAY = 3600; // Unit: second\\n\\n    uint constant WITHDRAW_DURATION = 3360; // Unit: second\\n\\n    uint constant LOCK_DURATION = 240; // Unit: second\\n    // uint constant DEALER_WITHDRAW_DELAY = 30; // Unit: second for test off-chain\\n\\n    // uint constant WITHDRAW_DURATION = 300; // Unit: second for test off-chain\\n\\n    // uint constant LOCK_DURATION = 180; // Unit: second for test off-chain\\n\\n    uint constant EBC_AMOUNT_PARAMS_MODULUS = 10000;\\n}\\n\"\r\n    },\r\n    \"contracts/library/HelperLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nlibrary HelperLib {\\n    function hash(bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(data);\\n    }\\n\\n    function includes(uint[] memory arr, uint element) internal pure returns (bool) {\\n        for (uint i = 0; i < arr.length; ) {\\n            if (element == arr[i]) {\\n                return true;\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function arrayIncludes(uint[] memory arr, uint[] memory elements) internal pure returns (bool) {\\n        for (uint i = 0; i < elements.length; i++) {\\n            bool ic = false;\\n            for (uint j = 0; j < arr.length; ) {\\n                if (elements[i] == arr[j]) {\\n                    ic = true;\\n                    break;\\n                }\\n                unchecked {\\n                    j++;\\n                }\\n            }\\n\\n            if (!ic) return false;\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function includes(address[] memory arr, address element) internal pure returns (bool) {\\n        for (uint i = 0; i < arr.length; ) {\\n            if (element == arr[i]) {\\n                return true;\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function arrayIncludes(address[] memory arr, address[] memory elements) internal pure returns (bool) {\\n        for (uint i = 0; i < elements.length; i++) {\\n            bool ic = false;\\n            for (uint j = 0; j < arr.length; ) {\\n                if (elements[i] == arr[j]) {\\n                    ic = true;\\n                    break;\\n                }\\n                unchecked {\\n                    j++;\\n                }\\n            }\\n\\n            if (!ic) return false;\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/library/RuleLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport {ConstantsLib} from \\\"./ConstantsLib.sol\\\";\\n\\nlibrary RuleLib {\\n    struct Rule {\\n        uint64 chainId0; // 59144\\n        uint64 chainId1; // 10\\n        uint8 status0;\\n        uint8 status1;\\n        uint token0;\\n        uint token1;\\n        uint128 minPrice0;\\n        uint128 minPrice1;\\n        uint128 maxPrice0;\\n        uint128 maxPrice1;\\n        uint128 withholdingFee0;\\n        uint128 withholdingFee1;\\n        uint32 tradingFee0;\\n        uint32 tradingFee1;\\n        uint32 responseTime0;\\n        uint32 responseTime1;\\n        uint32 compensationRatio0;\\n        uint32 compensationRatio1;\\n    }\\n\\n    struct RootWithVersion {\\n        bytes32 root;\\n        uint32 version;\\n    }\\n\\n    struct RuleOneway {\\n        uint64 sourceChainId;\\n        uint64 destChainId;\\n        uint8 status;\\n        uint sourceToken;\\n        uint destToken;\\n        uint128 minPrice;\\n        uint128 maxPrice;\\n        uint128 withholdingFee;\\n        uint32 tradingFee;\\n        uint32 responseTime;\\n        uint32 compensationRatio;\\n    }\\n\\n    function checkChainIds(uint64 chainId0, uint64 chainId1) internal pure {\\n        require(chainId0 < chainId1, \\\"C0LC1\\\");\\n    }\\n\\n    function checkWithholdingFees(uint128 withholdingFee0, uint128 withholdingFee1) internal pure {\\n        require(withholdingFee0 % ConstantsLib.EBC_AMOUNT_PARAMS_MODULUS == 0, \\\"WFI0\\\");\\n        require(withholdingFee1 % ConstantsLib.EBC_AMOUNT_PARAMS_MODULUS == 0, \\\"WFI1\\\");\\n    }\\n\\n    function convertToOneway(\\n        Rule memory rule,\\n        uint64 sourceChainId\\n    ) internal pure returns (RuleOneway memory ruleOneway) {\\n        require(sourceChainId == rule.chainId0 || sourceChainId == rule.chainId1, \\\"SCI\\\");\\n\\n        if (sourceChainId == rule.chainId0) {\\n            return\\n                RuleOneway(\\n                    rule.chainId0,\\n                    rule.chainId1,\\n                    rule.status0,\\n                    rule.token0,\\n                    rule.token1,\\n                    rule.minPrice0,\\n                    rule.maxPrice0,\\n                    rule.withholdingFee0,\\n                    rule.tradingFee0,\\n                    rule.responseTime0,\\n                    rule.compensationRatio0\\n                );\\n        } else {\\n            return\\n                RuleOneway(\\n                    rule.chainId1,\\n                    rule.chainId0,\\n                    rule.status1,\\n                    rule.token1,\\n                    rule.token0,\\n                    rule.minPrice1,\\n                    rule.maxPrice1,\\n                    rule.withholdingFee1,\\n                    rule.tradingFee1,\\n                    rule.responseTime1,\\n                    rule.compensationRatio1\\n                );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ORMDCFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"./interface/IORMDCFactory.sol\\\";\\nimport \\\"./interface/IORMakerDeposit.sol\\\";\\nimport \\\"./interface/IORManager.sol\\\";\\nimport {HelperLib} from \\\"./library/HelperLib.sol\\\";\\n\\ncontract ORMDCFactory is IORMDCFactory {\\n    using HelperLib for bytes;\\n\\n    IORManager private _manager;\\n    address private _implementation;\\n    uint256 private _mdcCreatedTotal;\\n\\n    constructor(address manager_, address implementation_) {\\n        require(manager_ != address(0), \\\"MZ\\\");\\n        require(implementation_ != address(0), \\\"IZ\\\");\\n\\n        _manager = IORManager(manager_);\\n        _implementation = implementation_;\\n    }\\n\\n    function manager() external view returns (address) {\\n        return address(_manager);\\n    }\\n\\n    function implementation() external view returns (address) {\\n        return _implementation;\\n    }\\n\\n    function mdcCreatedTotal() external view returns (uint) {\\n        return _mdcCreatedTotal;\\n    }\\n\\n    function createMDC() external {\\n        require(_mdcCreatedTotal < _manager.maxMDCLimit(), \\\"MML\\\");\\n        address mdcAddress = Clones.cloneDeterministic(\\n            _implementation,\\n            abi.encodePacked(address(this), msg.sender).hash()\\n        );\\n\\n        unchecked {\\n            ++_mdcCreatedTotal;\\n        }\\n\\n        IORMakerDeposit(mdcAddress).initialize(msg.sender);\\n\\n        emit MDCCreated(msg.sender, mdcAddress);\\n    }\\n\\n    function predictMDCAddress() external view returns (address) {\\n        address mdcAddress = Clones.predictDeterministicAddress(\\n            _implementation,\\n            abi.encodePacked(address(this), msg.sender).hash()\\n        );\\n        return mdcAddress;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mdc\",\"type\":\"address\"}],\"name\":\"MDCCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"createMDC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mdcCreatedTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"predictMDCAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ORMDCFactory", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "000000000000000000000000e90fab21febfb008886b3639c26ccf70e414b9de00000000000000000000000076c7bc16b3601da267e45ebe9b86651d69ae6665", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}