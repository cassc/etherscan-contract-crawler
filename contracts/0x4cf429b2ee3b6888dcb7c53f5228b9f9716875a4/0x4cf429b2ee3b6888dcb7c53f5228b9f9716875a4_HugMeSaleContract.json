{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function decimals() external view returns (uint8);\r\n}\r\ninterface IERC20_USDT {\r\n    function transferFrom(address from, address to, uint value) external;\r\n}\r\ncontract HugMeSaleContract {\r\n    IERC20 public saleToken;\r\n    address payable public owner;\r\n    \r\n    mapping(address => uint256) public rates;\r\n    \r\n    enum QuoteType { PaymentToSale, SaleToPayment }\r\n    \r\n    event TokensPurchased(address indexed buyer, uint256 amount, uint256 rate);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor(address _saleToken) {\r\n        saleToken = IERC20(_saleToken);\r\n        owner = payable(msg.sender);\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the owner can call this function\");\r\n        _;\r\n    }\r\n    \r\n    function quote(QuoteType quoteType, address paymentTokenAddress, uint256 amount) public view returns (uint256) {\r\n        require(rates[paymentTokenAddress] > 0, \"Rate for this token not set\");\r\n        \r\n        if (quoteType == QuoteType.PaymentToSale) {\r\n            if (paymentTokenAddress == address(0)) { // ETH\r\n                return (rates[address(0)] * amount / 1 ether) * (10 ** uint256(saleToken.decimals()));\r\n            } else { // ERC20\r\n                IERC20 paymentToken = IERC20(paymentTokenAddress);\r\n                return (rates[paymentTokenAddress] * amount) * (10 ** uint256(saleToken.decimals())) / (10 ** uint256(paymentToken.decimals()));\r\n            }\r\n        } else { // SaleToPayment\r\n            if (paymentTokenAddress == address(0)) { // ETH\r\n                return (amount / rates[address(0)]) * 1 ether / (10 ** uint256(saleToken.decimals()));\r\n            } else { // ERC20\r\n                IERC20 paymentToken = IERC20(paymentTokenAddress);\r\n                return (amount / rates[paymentTokenAddress]) * (10 ** uint256(paymentToken.decimals())) / (10 ** uint256(saleToken.decimals()));\r\n            }\r\n        }\r\n    }\r\n\r\n    // Purchase tokens with ETH\r\n    function buyTokensWithETH() external payable {\r\n        uint256 tokensToBuy = quote(QuoteType.PaymentToSale, address(0), msg.value);\r\n        require(saleToken.transfer(msg.sender, tokensToBuy), \"Failed to transfer tokens\");\r\n        owner.transfer(msg.value);\r\n        emit TokensPurchased(msg.sender, tokensToBuy, rates[address(0)]);\r\n    }\r\n\r\n    // Purchase tokens with ERC20\r\n    function buyTokensWithERC20(address paymentTokenAddress, uint256 amount) external {\r\n        uint256 tokensToBuy = quote(QuoteType.PaymentToSale, paymentTokenAddress, amount);\r\n\r\n        if (paymentTokenAddress == 0xdAC17F958D2ee523a2206206994597C13D831ec7) { // Replace with the actual USDT address\r\n            IERC20_USDT usdtToken = IERC20_USDT(paymentTokenAddress);\r\n            usdtToken.transferFrom(msg.sender, owner, amount);\r\n            // Handle non-standard USDT transfer\r\n        } else {\r\n            IERC20 paymentToken = IERC20(paymentTokenAddress);\r\n            require(paymentToken.transferFrom(msg.sender, owner, amount), \"Failed to transfer payment tokens\");\r\n        }\r\n\r\n        require(saleToken.transfer(msg.sender, tokensToBuy), \"Failed to transfer tokens\");\r\n        emit TokensPurchased(msg.sender, tokensToBuy, rates[paymentTokenAddress]);\r\n    }\r\n\r\n\r\n    // Finalize the sale\r\n    function finalize() external onlyOwner {\r\n        require(saleToken.transfer(owner, saleToken.balanceOf(address(this))), \"Failed to transfer remaining tokens\");\r\n    }\r\n\r\n    // Update the rate for a specific payment token\r\n    function updateRate(address paymentTokenAddress, uint256 _newRate) external onlyOwner {\r\n        rates[paymentTokenAddress] = _newRate;\r\n    }\r\n\r\n    // Transfer ownership\r\n    function transferOwnership(address payable newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"New owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_saleToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyTokensWithERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTokensWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum HugMeSaleContract.QuoteType\",\"name\":\"quoteType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"updateRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HugMeSaleContract", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a35f68f312efdee84254621c89999a95ce37adb4", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e9069a0098c9f6795cbaa9961bde662f9705bba706c9807c4bf4e6c2dbd5783c"}