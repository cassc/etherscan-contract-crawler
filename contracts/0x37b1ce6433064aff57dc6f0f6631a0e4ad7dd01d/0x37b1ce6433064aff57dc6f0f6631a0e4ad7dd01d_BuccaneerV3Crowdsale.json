{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Crowdsale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\n\\r\\n/*\\r\\n\\r\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2003\u2003\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\\r\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2003\u2003\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\\r\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2566\u255d\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2003\u2003\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d\u2591\u2588\u2588\u2588\u2588\u2588\u2554\u255d\\r\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2003\u2003\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\\r\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2566\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2003\u2003\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\\r\\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u2003\u2003\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\\r\\n*/\\r\\n\\r\\ncontract BuccaneerV3Crowdsale {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IERC20 private token;\\r\\n    address private owner;\\r\\n    uint256 private endTime;\\r\\n    uint256 private raisedAmount = 0;\\r\\n    uint256 private tokenPrice = 180;  // 180 tokens per ETH, updated\\r\\n    uint256 private goal = 280 ether;\\r\\n    uint256 private maxLimit = 20 ether;\\r\\n    uint256 private minLimit = 0.1 ether;\\r\\n    uint256 private totalTokens = 50400000000000000000000;\\r\\n    string private description = \\\"Buccaneer V3 is an advanced on-chain privacy token that allows users to discreetly send BUCC tokens around privately. BUCC will be available approximately a month after the sale has concluded. IMPORTANT LEGAL NOTICE: This transaction is not available to residents, citizens, or green card holders of the United States of America or any of its territories or possessions, including Puerto Rico, the U.S. Virgin Islands, and Guam (collectively, 'US Persons'). The service offered in this transaction has not been registered under the United States Securities Act of 1933, as amended (the 'Securities Act'), or any state securities laws, and may not be offered, sold, pledged, or otherwise transferred within the United States or to or for the benefit of US Persons, except pursuant to an exemption from, or in a transaction not subject to, the registration requirements of the Securities Act and applicable state securities laws. US Persons are not permitted to participate in the transaction offered here. By participating in this transaction, you represent and warrant that you are not a US Person and that you are not purchasing on behalf of or for the benefit of a US Person. The Buccaneer team does not accept any responsibility or liability for any violation of local regulations by any user. All participants must ensure they are compliant with their local regulations and laws before participating. The user assumes all responsibility and risk associated with this transaction, and the Buccaneer team will not be held liable for any actions, claims, damages, costs, or liabilities arising from or related to this contract. It's imperative that participants conduct thorough research and consult with legal professionals where necessary. By interacting with this contract, you agree to these terms. Join https://t.me/BuccaneerV3 for more information.\\\";\\r\\n    //remember to fix\\r\\n    bool private saleStarted = false;\\r\\n    uint256 private tokensSold = 0;\\r\\n    uint256 private startTime;\\r\\n    \\r\\n\\r\\n\\r\\n    struct Buyer {\\r\\n        address buyerAddress;\\r\\n        uint256 amountBought;\\r\\n    }\\r\\n\\r\\n    Buyer[] private buyers;\\r\\n    mapping(address => uint256) private buyerIDs;\\r\\n    mapping(address => uint256) private balances;\\r\\n    mapping(address => bool) private userLock;\\r\\n    mapping(address => uint256) private contributedEth;\\r\\n    mapping(address => bool) private claimed;\\r\\n\\r\\n\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"Not the contract owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier hasMinimumPurchase() {\\r\\n        require(msg.value >= minLimit, \\\"0.1 ETH is the minimum purchase limit\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier hasMaximumPurchase() {\\r\\n        require(contributedEth[msg.sender].add(msg.value) <= maxLimit, \\\"20 ETH is the maximum total contribution per address\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier saleHasStarted() {\\r\\n        require(saleStarted, \\\"Sale has not started yet\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() {\\r\\n        owner = msg.sender;\\r\\n        endTime = block.timestamp + 48 hours;\\r\\n    }\\r\\n\\r\\n\\r\\n    function VIII_startSale() external onlyOwner {\\r\\n        startTime = block.timestamp;\\r\\n        endTime = block.timestamp + 48 hours;\\r\\n        saleStarted = true;\\r\\n    }\\r\\n\\r\\n\\r\\n    function VIII_setToken(address _token) external onlyOwner {\\r\\n        //require(address(token) == address(0), \\\"Token already set!\\\");\\r\\n        token = IERC20(_token);\\r\\n    }\\r\\n\\r\\n\\r\\n    function buyTokensInternal() internal hasMinimumPurchase hasMaximumPurchase saleHasStarted {\\r\\n        require(!userLock[msg.sender], \\\"Reentrant call detected!\\\");\\r\\n\\r\\n        userLock[msg.sender] = true;\\r\\n\\r\\n        require(block.timestamp < endTime, \\\"Sale ended\\\");\\r\\n        uint256 tokensToBuy = msg.value.mul(tokenPrice);\\r\\n\\r\\n        // Calculate the number of tokens left for sale\\r\\n        uint256 tokensLeft = totalTokens.sub(tokensSold);\\r\\n        require(tokensLeft >= tokensToBuy, \\\"Not enough tokens left to buy\\\");\\r\\n\\r\\n        // Assign ID if the buyer is new\\r\\n        if(buyerIDs[msg.sender] == 0) {\\r\\n            buyers.push(Buyer({\\r\\n                buyerAddress: msg.sender,\\r\\n                amountBought: tokensToBuy\\r\\n            }));\\r\\n            buyerIDs[msg.sender] = buyers.length;  // This will be the ID for the buyer\\r\\n        } else {\\r\\n            uint256 index = buyerIDs[msg.sender] - 1;\\r\\n            buyers[index].amountBought = buyers[index].amountBought.add(tokensToBuy);\\r\\n        }\\r\\n\\r\\n        tokensSold = tokensSold.add(tokensToBuy);\\r\\n        raisedAmount = raisedAmount.add(msg.value);\\r\\n        balances[msg.sender] = balances[msg.sender].add(tokensToBuy);\\r\\n        \\r\\n        // Update the total ETH contributed by the sender\\r\\n        contributedEth[msg.sender] = contributedEth[msg.sender].add(msg.value);\\r\\n\\r\\n        userLock[msg.sender] = false;\\r\\n    }\\r\\n\\r\\n    function buyTokens() external payable hasMinimumPurchase hasMaximumPurchase saleHasStarted {\\r\\n        buyTokensInternal();\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        buyTokensInternal();\\r\\n    }\\r\\n\\r\\n\\r\\n    function claimTokens() external saleHasStarted {\\r\\n        require(block.timestamp > endTime, \\\"Sale not ended\\\");\\r\\n        require(!claimed[msg.sender], \\\"You have already claimed your tokens\\\");\\r\\n        require(!userLock[msg.sender], \\\"Reentrant call detected!\\\");\\r\\n\\r\\n        userLock[msg.sender] = true;\\r\\n\\r\\n        uint256 amount = balances[msg.sender];\\r\\n        require(amount > 0, \\\"No tokens to claim\\\");\\r\\n        balances[msg.sender] = 0; // Update the user's balance before the actual transfer for added security.\\r\\n        require(token.transfer(msg.sender, amount), \\\"Token transfer failed\\\");\\r\\n\\r\\n        claimed[msg.sender] = true;\\r\\n\\r\\n        userLock[msg.sender] = false;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function VIII_endSalePrematurely() external onlyOwner {\\r\\n        require(saleStarted, \\\"Sale hasn't started yet\\\");\\r\\n        require(block.timestamp < endTime, \\\"Sale has already ended\\\");\\r\\n        endTime = block.timestamp;  // Set endTime to the current time to end the sale\\r\\n    }\\r\\n\\r\\n    function VIII_withdrawETH() external onlyOwner {\\r\\n        payable(owner).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function VIII_emergencyPull(uint256 _amount) external onlyOwner {\\r\\n        payable(owner).transfer(_amount);\\r\\n    }\\r\\n\\r\\n\\r\\n    function VIII_setTokenPrice_in_RATIO(uint256 _price) external onlyOwner {\\r\\n        tokenPrice = _price;\\r\\n    }\\r\\n\\r\\n    function VIII_setGoal_in_WEI(uint256 _goal) external onlyOwner {\\r\\n        goal = _goal;\\r\\n    }\\r\\n\\r\\n    function VIII_setTotalTokens_in_18_Decimal(uint256 _newTotal) external onlyOwner {\\r\\n    totalTokens = _newTotal;\\r\\n    }\\r\\n\\r\\n\\r\\n                    \\r\\n                    function A_Check_My_Balance() external view returns (string memory) {\\r\\n                        address user = msg.sender;\\r\\n                        uint256 userTokens = balances[user];\\r\\n\\r\\n                        if (block.timestamp > endTime && claimed[user]) {\\r\\n                            return \\\"You have already claimed your tokens.\\\";\\r\\n                        }\\r\\n\\r\\n                        if (userTokens == 0) {\\r\\n                            return \\\"You haven't sent any tokens.\\\";\\r\\n                        }\\r\\n\\r\\n                        uint256 percentageOfTotal = (userTokens.mul(100)).div(totalTokens);\\r\\n                        string memory rank = getRank(contributedEth[user]);\\r\\n\\r\\n                        string memory baseString = \\\"You are ranked as a \\\";\\r\\n                        string memory rankStr = rank;\\r\\n                        string memory claimString = \\\". You will be able to claim \\\";\\r\\n                        string memory tokensStr = _uintToString(userTokens.div(1e18)); // Displaying compact value\\r\\n                        string memory middleString = \\\" tokens, which is \\\";\\r\\n                        string memory percentageStr = _uintToString(percentageOfTotal);\\r\\n                        string memory endString = \\\"% of the total tokens. Remember this is a rounded estimate. Use your ID and to the G_getBalanceByBuyerID function and input your ID for the exact amount.\\\";\\r\\n\\r\\n                        bytes memory b = new bytes(400); // estimation of space required, increased due to the addition of rank\\r\\n\\r\\n                        uint pos = 0;\\r\\n                        for (uint i = 0; i < bytes(baseString).length; i++) b[pos++] = bytes(baseString)[i];\\r\\n                        for (uint i = 0; i < bytes(rankStr).length; i++) b[pos++] = bytes(rankStr)[i];\\r\\n                        for (uint i = 0; i < bytes(claimString).length; i++) b[pos++] = bytes(claimString)[i];\\r\\n                        for (uint i = 0; i < bytes(tokensStr).length; i++) b[pos++] = bytes(tokensStr)[i];\\r\\n                        for (uint i = 0; i < bytes(middleString).length; i++) b[pos++] = bytes(middleString)[i];\\r\\n                        for (uint i = 0; i < bytes(percentageStr).length; i++) b[pos++] = bytes(percentageStr)[i];\\r\\n                        for (uint i = 0; i < bytes(endString).length; i++) b[pos++] = bytes(endString)[i];\\r\\n\\r\\n                        string memory finalStr = new string(pos);\\r\\n                        for (uint i = 0; i < pos; i++) {\\r\\n                            bytes(finalStr)[i] = b[i];\\r\\n                        }\\r\\n\\r\\n                        return finalStr;\\r\\n                    }\\r\\n\\r\\n\\r\\n\\r\\n                    function B_Show_What_Percentage_Sale_Is_Done() external view returns (string memory) {\\r\\n                        if (block.timestamp > endTime) {\\r\\n                            return \\\"The sale is over.\\\";\\r\\n                        }\\r\\n\\r\\n                        if (raisedAmount == 0) {\\r\\n                            return \\\"The sale hasn't had any ETH sent to it yet.\\\";\\r\\n                        }\\r\\n\\r\\n                        uint256 percentage = raisedAmount.mul(100).div(goal);\\r\\n                        \\r\\n                        if (percentage >= 995 && percentage < 1000) { // if it's close to 100% (>=99.5%)\\r\\n                            return \\\"The sale is at 100% completion.\\\";\\r\\n                        }\\r\\n\\r\\n                        return string(abi.encodePacked(\\\"The sale is at \\\", uint2str(percentage), \\\" percentage towards completion.\\\"));\\r\\n                    }\\r\\n\\r\\n\\r\\n                    function C_getSaleStatus() external view returns (string memory) {\\r\\n\\r\\n                        if (!saleStarted) {\\r\\n                            return \\\"The sale has not started.\\\";\\r\\n                        } else if (block.timestamp < endTime) {\\r\\n                            uint256 timeRemaining = endTime.sub(block.timestamp);\\r\\n                            uint256 U = timeRemaining.div(3600);\\r\\n                            uint256 Z = (timeRemaining.sub(U.mul(3600))).div(60);\\r\\n                            return string(abi.encodePacked(\\\"The sale is live, there are hours: \\\", _uintToString(U), \\\" and \\\", _uintToString(Z), \\\" minutes left.\\\"));\\r\\n\\r\\n                        } else {\\r\\n                            return \\\"The Sale is Over\\\";\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n\\r\\n                    function D_Tokens_Left_in_the_Sale() external view returns (string memory) {\\r\\n                        if (block.timestamp > endTime) {\\r\\n                            return \\\"The sale is over.\\\";\\r\\n                        }\\r\\n\\r\\n                        uint256 tokensRemaining = totalTokens.sub(tokensSold).div(1e18);\\r\\n                        uint256 compactTokensSold = tokensSold.div(1e18);\\r\\n                        \\r\\n                        string memory tokensSoldStr = _uintToString(compactTokensSold);\\r\\n                        string memory tokensRemainingStr = _uintToString(tokensRemaining);\\r\\n\\r\\n                        // Constructing the status message\\r\\n                        bytes memory b = new bytes(200); // estimation of space\\r\\n                        string memory baseString = \\\"A total of \\\";\\r\\n                        string memory middleString = \\\" tokens have been sold and \\\";\\r\\n                        string memory endString = \\\" are left.\\\";\\r\\n\\r\\n                        uint pos = 0;\\r\\n\\r\\n                        for (uint i = 0; i < bytes(baseString).length; i++) b[pos++] = bytes(baseString)[i];\\r\\n                        for (uint i = 0; i < bytes(tokensSoldStr).length; i++) b[pos++] = bytes(tokensSoldStr)[i];\\r\\n                        for (uint i = 0; i < bytes(middleString).length; i++) b[pos++] = bytes(middleString)[i];\\r\\n                        for (uint i = 0; i < bytes(tokensRemainingStr).length; i++) b[pos++] = bytes(tokensRemainingStr)[i];\\r\\n                        for (uint i = 0; i < bytes(endString).length; i++) b[pos++] = bytes(endString)[i];\\r\\n\\r\\n                        string memory finalStr = new string(pos);\\r\\n                        for (uint i = 0; i < pos; i++) {\\r\\n                            bytes(finalStr)[i] = b[i];\\r\\n                        }\\r\\n\\r\\n                        return finalStr;\\r\\n                    }\\r\\n\\r\\n                    function E_What_is_the_Minimum_Send_in_Limit() external view returns (string memory) {\\r\\n                        if (block.timestamp > endTime) {\\r\\n                            return \\\"The sale is over.\\\";\\r\\n                        }\\r\\n                        return \\\"The minimum send limit is 0.1 Ethereum. The maximum input is 20 Ethereum per address.\\\";\\r\\n                    }\\r\\n\\r\\n\\r\\n                    function F_What_is_the_Price() external view returns (string memory) {\\r\\n                        return string(abi.encodePacked(\\\"The number of tokens per ETH is: \\\", uint2str(tokenPrice)));\\r\\n                    }\\r\\n\\r\\n                    function G_getBalanceByBuyerID(uint256 _buyerID) external view returns (string memory) {\\r\\n                        // Ensure the buyerID is valid\\r\\n                        require(_buyerID > 0 && _buyerID <= buyers.length, \\\"Invalid buyerID\\\");\\r\\n\\r\\n                        // Retrieve the buyer's address using the buyerID\\r\\n                        address buyerAddress = buyers[_buyerID - 1].buyerAddress;\\r\\n\\r\\n                        // Convert the address to string\\r\\n                        string memory addressStr = _addrToString(buyerAddress);\\r\\n\\r\\n                        if (block.timestamp > endTime && claimed[buyerAddress]) {\\r\\n                            return \\\"Address has already claimed their tokens.\\\";\\r\\n                        }\\r\\n\\r\\n                        // Check if the user has a balance\\r\\n                        uint256 balance = balances[buyerAddress];\\r\\n                        if (balance == 0) {\\r\\n                            return string(abi.encodePacked(\\\"Address: \\\", addressStr, \\\" has not sent any ETH to the contract.\\\"));\\r\\n                        } else {\\r\\n                            return string(abi.encodePacked(\\\"Address: \\\", addressStr, \\\" has a balance of: \\\", uint2str(balance)));\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n\\r\\n                    function H_getTotalBuyers() external view returns (string memory) {\\r\\n                        if (block.timestamp > endTime) {\\r\\n                            return string(abi.encodePacked(\\\"The sale is over. The final number of buyers was: \\\", uint2str(buyers.length)));\\r\\n                        }\\r\\n                        return string(abi.encodePacked(\\\"The total number of buyers is: \\\", uint2str(buyers.length)));\\r\\n                    }\\r\\n\\r\\n\\r\\n\\r\\n                    function I_getDescription() external view returns (string memory) {\\r\\n                        return description;\\r\\n                    }\\r\\n\\r\\n                    function J_estimatedTimeToEndSale() external view saleHasStarted returns (string memory) {\\r\\n                        if (block.timestamp >= endTime || tokensSold == totalTokens) {\\r\\n                            return \\\"The sale has either ended or all tokens are sold.\\\";\\r\\n                        }\\r\\n\\r\\n                        uint256 averageRate = tokensSold.div(block.timestamp.sub(startTime)); // Tokens per second\\r\\n                        if (averageRate == 0) {\\r\\n                            return \\\"Not enough data to estimate time to end sale.\\\";\\r\\n                        }\\r\\n\\r\\n                        uint256 estimatedSecondsToEnd = totalTokens.sub(tokensSold).div(averageRate);\\r\\n                        uint256 estimatedHoursToEnd = estimatedSecondsToEnd.div(3600);\\r\\n\\r\\n                        return string(abi.encodePacked(\\\"Estimated hours to end sale: \\\", uint2str(estimatedHoursToEnd)));\\r\\n                    }\\r\\n\\r\\n                    function K_getUserID() external view returns (uint256) {\\r\\n                        return buyerIDs[msg.sender];\\r\\n                    }\\r\\n\\r\\n\\r\\n                    function L_getTokensLeft() external view returns (string memory) {\\r\\n                        uint256 tokensLeft = token.balanceOf(address(this)).div(1e18);\\r\\n                        return string(abi.encodePacked(\\\"Number of tokens left in the contract: \\\", uint2str(tokensLeft)));\\r\\n                    }\\r\\n\\r\\n\\r\\n\\r\\n                    function getRank(uint256 contribution) internal pure returns (string memory) {\\r\\n                        if (contribution < 0.3 ether) return \\\"Slave\\\";\\r\\n                        if (contribution < 1.5 ether) return \\\"Swab\\\";\\r\\n                        if (contribution < 3 ether) return \\\"Cook\\\";\\r\\n                        if (contribution < 4.5 ether) return \\\"Boatswain\\\";\\r\\n                        if (contribution < 5 ether) return \\\"Carpenter\\\";\\r\\n                        if (contribution < 7.5 ether) return \\\"Chaplain\\\";\\r\\n                        if (contribution < 10 ether) return \\\"Quartermaster\\\";\\r\\n                        if (contribution < 12.5 ether) return \\\"Master Gunner\\\";\\r\\n                        if (contribution < 15 ether) return \\\"Sailmaster\\\";\\r\\n                        return \\\"First Mate\\\";\\r\\n                    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n                    //UTIL\\r\\n                    function uint2str(uint256 _i) internal pure returns (string memory) {\\r\\n                        if (_i == 0) {\\r\\n                            return \\\"0\\\";\\r\\n                        }\\r\\n                        uint256 j = _i;\\r\\n                        uint256 length;\\r\\n                        while (j != 0) {\\r\\n                            length++;\\r\\n                            j /= 10;\\r\\n                        }\\r\\n                        bytes memory bstr = new bytes(length);\\r\\n                        uint256 k = length;\\r\\n                        while (_i != 0) {\\r\\n                            bstr[--k] = bytes1(uint8(48 + _i % 10));\\r\\n                            _i /= 10;\\r\\n                        }\\r\\n                        return string(bstr);\\r\\n                    }\\r\\n\\r\\n\\r\\n\\r\\n                    function _uintToString(uint256 _i) internal pure returns (string memory) {\\r\\n                        if (_i == 0) {\\r\\n                            return \\\"0\\\";\\r\\n                        }\\r\\n                        uint256 j = _i;\\r\\n                        uint256 length;\\r\\n                        while (j != 0) {\\r\\n                            length++;\\r\\n                            j /= 10;\\r\\n                        }\\r\\n                        bytes memory bstr = new bytes(length);\\r\\n                        uint256 k = length;\\r\\n                        j = _i;\\r\\n                        while (j != 0) {\\r\\n                            bstr[--k] = bytes1(uint8(48 + j % 10));\\r\\n                            j /= 10;\\r\\n                        }\\r\\n                        return string(bstr);\\r\\n                    }\\r\\n\\r\\n                    function _addrToString(address _addr) internal pure returns(string memory) {\\r\\n                        bytes32 value = bytes32(uint256(uint160(_addr)));\\r\\n                        bytes memory alphabet = \\\"0123456789abcdef\\\";\\r\\n\\r\\n                        bytes memory str = new bytes(42);\\r\\n                        str[0] = '0';\\r\\n                        str[1] = 'x';\\r\\n                        for (uint256 i = 0; i < 20; i++) {\\r\\n                            str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];\\r\\n                            str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];\\r\\n                        }\\r\\n                        return string(str);\\r\\n                    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"A_Check_My_Balance\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"B_Show_What_Percentage_Sale_Is_Done\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"C_getSaleStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"D_Tokens_Left_in_the_Sale\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"E_What_is_the_Minimum_Send_in_Limit\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"F_What_is_the_Price\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyerID\",\"type\":\"uint256\"}],\"name\":\"G_getBalanceByBuyerID\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"H_getTotalBuyers\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"I_getDescription\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"J_estimatedTimeToEndSale\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"K_getUserID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L_getTokensLeft\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"VIII_emergencyPull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VIII_endSalePrematurely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_goal\",\"type\":\"uint256\"}],\"name\":\"VIII_setGoal_in_WEI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"VIII_setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"VIII_setTokenPrice_in_RATIO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTotal\",\"type\":\"uint256\"}],\"name\":\"VIII_setTotalTokens_in_18_Decimal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VIII_startSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VIII_withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BuccaneerV3Crowdsale", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}