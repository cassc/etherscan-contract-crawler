{"SourceCode": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\n\n/**\n * SafeMath from OpenZeppelin - commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/5dfe7215a9156465d550030eadc08770503b2b2f\n *\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage)\n        internal\n        pure\n        returns (uint256)\n    {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n/**\n * @title MBDAAsset is a template for MB Digital Asset token\n * */\ncontract MBDAAsset {\n    using SafeMath for uint256;\n\n    //\n    // events\n    //\n    // ERC20 events\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    // mint/burn events\n    event Mint(address indexed _to, uint256 _amount, uint256 _newTotalSupply);\n    event Burn(address indexed _from, uint256 _amount, uint256 _newTotalSupply);\n\n    // admin events\n    event BlockLockSet(uint256 _value);\n    event NewAdmin(address _newAdmin);\n    event NewManager(address _newManager);\n    event NewInvestor(address _newInvestor);\n    event RemovedInvestor(address _investor);\n    event FundAssetsChanged(\n        string indexed tokenSymbol,\n        string assetInfo,\n        uint8 amount,\n        uint256 totalAssetAmount\n    );\n\n    modifier onlyAdmin {\n        require(msg.sender == admin, \"Only admin can perform this operation\");\n        _;\n    }\n\n    modifier managerOrAdmin {\n        require(\n            msg.sender == manager || msg.sender == admin,\n            \"Only manager or admin can perform this operation\"\n        );\n        _;\n    }\n\n    modifier boardOrAdmin {\n        require(\n            msg.sender == board || msg.sender == admin,\n            \"Only admin or board can perform this operation\"\n        );\n        _;\n    }\n\n    modifier blockLock(address _sender) {\n        require(\n            !isLocked() || _sender == admin,\n            \"Contract is locked except for the admin\"\n        );\n        _;\n    }\n\n    modifier onlyIfMintable() {\n      require(mintable, \"Token minting is disabled\");\n      _;\n    }\n\n    struct Asset {\n        string assetTicker;\n        string assetInfo;\n        uint8 assetPercentageParticipation;\n    }\n\n    struct Investor {\n        string info;\n        bool exists;\n    }\n\n    uint256 public totalSupply;\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    address public admin;\n    address public board;\n    address public manager;\n    uint256 public lockedUntilBlock;\n    bool public canChangeAssets;\n    bool public mintable;\n    bool public hasWhiteList;\n    bool public isSyndicate;\n    string public urlFinancialDetailsDocument;\n    bytes32 public financialDetailsHash;\n    string[] public tradingPlatforms;\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowed;\n    mapping(address => Investor) public clearedInvestors;\n    Asset[] public assets;\n\n    /**\n     * @dev Constructor\n     * @param _fundAdmin - Fund admin\n     * @param _fundBoard - Board\n     * @param _tokenName - Detailed ERC20 token name\n     * @param _decimalUnits - Detailed ERC20 decimal units\n     * @param _tokenSymbol - Detailed ERC20 token symbol\n     * @param _lockedUntilBlock - Block lock\n     * @param _newTotalSupply - Total Supply owned by the contract itself, only Manager can move\n     * @param _canChangeAssets - True allows the Manager to change assets in the portfolio\n     * @param _mintable - True allows Manager to rebalance the portfolio\n     * @param _hasWhiteList - Allows transfering only between whitelisted addresses\n     * @param _isSyndicate - Allows secondary market\n     */\n    constructor(\n        address _fundAdmin,\n        address _fundBoard,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        uint256 _lockedUntilBlock,\n        uint256 _newTotalSupply,\n        bool _canChangeAssets,\n        bool _mintable,\n        bool _hasWhiteList,\n        bool _isSyndicate\n    ) public {\n        name = _tokenName;\n        require(_decimalUnits <= 18, \"Decimal units should be 18 or lower\");\n        decimals = _decimalUnits;\n        symbol = _tokenSymbol;\n        lockedUntilBlock = _lockedUntilBlock;\n        admin = _fundAdmin;\n        board = _fundBoard;\n        totalSupply = _newTotalSupply;\n        canChangeAssets = _canChangeAssets;\n        mintable = _mintable;\n        hasWhiteList = _hasWhiteList;\n        isSyndicate = _isSyndicate;\n        balances[address(this)] = totalSupply;\n        Investor memory tmp = Investor(\"Contract\", true);\n        clearedInvestors[address(this)] = tmp;\n        emit NewInvestor(address(this));\n    }\n\n    /**\n     * @dev Set financial details url\n     * @param _url - URL\n     * @return True if success\n     */\n    function setFinancialDetails(string memory _url)\n        public\n        onlyAdmin\n        returns (bool)\n    {\n        urlFinancialDetailsDocument = _url;\n        return true;\n    }\n\n    /**\n     * @dev Set financial details IPFS hash\n     * @param _hash - URL\n     * @return True if success\n     */\n    function setFinancialDetailsHash(bytes32 _hash)\n        public\n        onlyAdmin\n        returns (bool)\n    {\n        financialDetailsHash = _hash;\n        return true;\n    }\n\n    /**\n     * @dev Add trading platform\n     * @param _details - Details of the trading platform\n     * @return True if success\n     */\n    function addTradingPlatform(string memory _details)\n        public\n        onlyAdmin\n        returns (bool)\n    {\n        tradingPlatforms.push(_details);\n        return true;\n    }\n\n    /**\n     * @dev Remove trading platform\n     * @param _index - Index of the trading platform to be removed\n     * @return True if success\n     */\n    function removeTradingPlatform(uint256 _index)\n        public\n        onlyAdmin\n        returns (bool)\n    {\n        require(_index < tradingPlatforms.length, \"Invalid platform index\");\n        tradingPlatforms[_index] = tradingPlatforms[tradingPlatforms.length -\n            1];\n        tradingPlatforms.pop();\n        return true;\n    }\n\n    /**\n     * @dev Whitelists an Investor\n     * @param _investor - Address of the investor\n     * @param _investorInfo - Info\n     * @return True if success\n     */\n    function addNewInvestor(address _investor, string memory _investorInfo)\n        public\n        onlyAdmin\n        returns (bool)\n    {\n        require(_investor != address(0), \"Invalid investor address\");\n        Investor memory tmp = Investor(_investorInfo, true);\n        clearedInvestors[_investor] = tmp;\n        emit NewInvestor(_investor);\n        return true;\n    }\n\n    /**\n     * @dev Removes an Investor from whitelist\n     * @param _investor - Address of the investor\n     * @return True if success\n     */\n    function removeInvestor(address _investor) public onlyAdmin returns (bool) {\n        require(_investor != address(0), \"Invalid investor address\");\n        delete (clearedInvestors[_investor]);\n        emit RemovedInvestor(_investor);\n        return true;\n    }\n\n    /**\n     * @dev Add new asset to Portfolio\n     * @param _assetTicker - Ticker\n     * @param _assetInfo - Info\n     * @param _assetPercentageParticipation - % of portfolio taken by the asset\n     * @return success\n     */\n    function addNewAsset(\n        string memory _assetTicker,\n        string memory _assetInfo,\n        uint8 _assetPercentageParticipation\n    ) public onlyAdmin returns (bool success) {\n        uint256 totalPercentageAssets = 0;\n        for (uint256 i = 0; i < assets.length; i++) {\n            require(\n                keccak256(bytes(_assetTicker)) !=\n                    keccak256(bytes(assets[i].assetTicker)),\n                \"An asset cannot be assigned twice\"\n            );\n            totalPercentageAssets = SafeMath.add(\n                assets[i].assetPercentageParticipation,\n                totalPercentageAssets\n            );\n        }\n        totalPercentageAssets = SafeMath.add(\n            totalPercentageAssets,\n            _assetPercentageParticipation\n        );\n        require(\n            totalPercentageAssets <= 100,\n            \"Total assets number cannot be higher than 100\"\n        );\n        emit FundAssetsChanged(\n            _assetTicker,\n            _assetInfo,\n            _assetPercentageParticipation,\n            totalPercentageAssets\n        );\n        Asset memory newAsset = Asset(\n            _assetTicker,\n            _assetInfo,\n            _assetPercentageParticipation\n        );\n        assets.push(newAsset);\n        success = true;\n        return success;\n    }\n\n    /**\n     * @dev Remove asset from Portfolio\n     * @param _assetIndex - Asset\n     * @return True if success\n     */\n    function removeAnAsset(uint8 _assetIndex) public onlyAdmin returns (bool) {\n        require(canChangeAssets, \"Cannot change asset portfolio\");\n        require(\n            _assetIndex < assets.length,\n            \"Invalid asset index number. Greater than total assets\"\n        );\n        string memory assetTicker = assets[_assetIndex].assetTicker;\n        assets[_assetIndex] = assets[assets.length - 1];\n        delete assets[assets.length - 1];\n        assets.pop();\n        emit FundAssetsChanged(assetTicker, \"\", 0, 0);\n        return true;\n    }\n\n    /**\n     * @dev Updates an asset\n     * @param _assetTicker - Ticker\n     * @param _assetInfo - Info to update\n     * @param _newAmount - % of portfolio taken by the asset\n     * @return True if success\n     */\n    function updateAnAssetQuantity(\n        string memory _assetTicker,\n        string memory _assetInfo,\n        uint8 _newAmount\n    ) public onlyAdmin returns (bool) {\n        require(canChangeAssets, \"Cannot change asset amount\");\n        require(_newAmount > 0, \"Cannot set zero asset amount\");\n        uint256 totalAssets = 0;\n        uint256 assetIndex = 0;\n        for (uint256 i = 0; i < assets.length; i++) {\n            if (\n                keccak256(bytes(_assetTicker)) ==\n                keccak256(bytes(assets[i].assetTicker))\n            ) {\n                assetIndex = i;\n                totalAssets = SafeMath.add(totalAssets, _newAmount);\n            } else {\n                totalAssets = SafeMath.add(\n                    totalAssets,\n                    assets[i].assetPercentageParticipation\n                );\n            }\n        }\n        emit FundAssetsChanged(\n            _assetTicker,\n            _assetInfo,\n            _newAmount,\n            totalAssets\n        );\n        require(\n            totalAssets <= 100,\n            \"Fund assets total percentage must be less than 100\"\n        );\n        assets[assetIndex].assetPercentageParticipation = _newAmount;\n        assets[assetIndex].assetInfo = _assetInfo;\n        return true;\n    }\n\n    /**\n     * @return Number of assets in Portfolio\n     */\n    function totalAssetsArray() public view returns (uint256) {\n        return assets.length;\n    }\n\n    /**\n     * @dev ERC20 Transfer\n     * @param _to - destination address\n     * @param _value - value to transfer\n     * @return True if success\n     */\n    function transfer(address _to, uint256 _value)\n        public\n        blockLock(msg.sender)\n        returns (bool)\n    {\n        address from = (admin == msg.sender) ? address(this) : msg.sender;\n        require(\n            isTransferValid(from, _to, _value),\n            \"Invalid Transfer Operation\"\n        );\n        balances[from] = balances[from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(from, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev ERC20 Approve\n     * @param _spender - destination address\n     * @param _value - value to be approved\n     * @return True if success\n     */\n    function approve(address _spender, uint256 _value)\n        public\n        blockLock(msg.sender)\n        returns (bool)\n    {\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\n\n        address from = (admin == msg.sender) ? address(this) : msg.sender;\n        allowed[from][_spender] = _value;\n        emit Approval(from, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @dev ERC20 TransferFrom\n     * @param _from - source address\n     * @param _to - destination address\n     * @param _value - value\n     * @return True if success\n     */\n    function transferFrom(address _from, address _to, uint256 _value)\n        public\n        blockLock(_from)\n        returns (bool)\n    {\n        // check sufficient allowance\n        require(\n            _value <= allowed[_from][msg.sender],\n            \"Value informed is invalid\"\n        );\n        require(\n            isTransferValid(_from, _to, _value),\n            \"Invalid Transfer Operation\"\n        );\n        // transfer tokens\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(\n            _value,\n            \"Value lower than approval\"\n        );\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Mint new tokens. Can only be called by minter or owner\n     * @param _to - destination address\n     * @param _value - value\n     * @return True if success\n     */\n    function mint(address _to, uint256 _value)\n        public\n        onlyIfMintable\n        managerOrAdmin\n        blockLock(msg.sender)\n        returns (bool)\n    {\n        balances[_to] = balances[_to].add(_value);\n        totalSupply = totalSupply.add(_value);\n\n        emit Mint(_to, _value, totalSupply);\n        emit Transfer(address(0), _to, _value);\n\n        return true;\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param _account - address\n     * @param _value - value\n     * @return True if success\n     */\n    function burn(address payable _account, uint256 _value)\n        public\n        payable\n        blockLock(msg.sender)\n        managerOrAdmin\n        returns (bool)\n    {\n        require(_account != address(0), \"ERC20: burn from the zero address\");\n\n        totalSupply = totalSupply.sub(_value);\n        balances[_account] = balances[_account].sub(_value);\n        emit Transfer(_account, address(0), _value);\n        emit Burn(_account, _value, totalSupply);\n        if (msg.value > 0) {\n            (bool success, ) = _account.call{value: msg.value}(\"\");\n            require(success, \"Ether transfer failed.\");\n        }\n        return true;\n    }\n\n    /**\n     * @dev Set block lock. Until that block (exclusive) transfers are disallowed\n     * @param _lockedUntilBlock - Block Number\n     * @return True if success\n     */\n    function setBlockLock(uint256 _lockedUntilBlock)\n        public\n        boardOrAdmin\n        returns (bool)\n    {\n        lockedUntilBlock = _lockedUntilBlock;\n        emit BlockLockSet(_lockedUntilBlock);\n        return true;\n    }\n\n    /**\n     * @dev Replace current admin with new one\n     * @param _newAdmin New token admin\n     * @return True if success\n     */\n    function replaceAdmin(address _newAdmin)\n        public\n        boardOrAdmin\n        returns (bool)\n    {\n        require(_newAdmin != address(0x0), \"Null address\");\n        admin = _newAdmin;\n        emit NewAdmin(_newAdmin);\n        return true;\n    }\n\n    /**\n     * @dev Set an account can perform some operations\n     * @param _newManager Manager address\n     * @return True if success\n     */\n    function setManager(address _newManager) public onlyAdmin returns (bool) {\n        manager = _newManager;\n        emit NewManager(_newManager);\n        return true;\n    }\n\n    /**\n     * @dev ERC20 balanceOf\n     * @param _owner Owner address\n     * @return True if success\n     */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    /**\n     * @dev ERC20 allowance\n     * @param _owner Owner address\n     * @param _spender Address allowed to spend from Owner's balance\n     * @return uint256 allowance\n     */\n    function allowance(address _owner, address _spender)\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n     * @dev Are transfers currently disallowed\n     * @return True if disallowed\n     */\n    function isLocked() public view returns (bool) {\n        return lockedUntilBlock > block.number;\n    }\n\n    /**\n     * @dev Checks if transfer parameters are valid\n     * @param _from Source address\n     * @param _to Destination address\n     * @param _amount Amount to check\n     * @return True if valid\n     */\n    function isTransferValid(address _from, address _to, uint256 _amount)\n        public\n        view\n        returns (bool)\n    {\n        if (_from == address(0)) {\n            return false;\n        }\n\n        if (_to == address(0)) {\n            return false;\n        }\n\n        if (!hasWhiteList) {\n            return balances[_from] >= _amount; // sufficient balance\n        }\n\n        bool fromOK = clearedInvestors[_from].exists;\n\n        if (!isSyndicate) {\n            return\n                balances[_from] >= _amount && // sufficient balance\n                fromOK; // a seller holder within the whitelist\n        }\n\n        bool toOK = clearedInvestors[_to].exists;\n\n        return\n            balances[_from] >= _amount && // sufficient balance\n            fromOK && // a seller holder within the whitelist\n            toOK; // a buyer holder within the whitelist\n    }\n}\n\n\ncontract MBDAWallet {\n    mapping(address => bool) public controllers;\n    address[] public controllerList;\n    bytes32 public recipientID;\n    string public recipient;\n\n    modifier onlyController() {\n        require(controllers[msg.sender], \"Sender must be a Controller Member\");\n        _;\n    }\n\n    event EtherReceived(address sender, uint256 amount);\n\n    /**\n     * @dev Constructor\n     * @param _controller - Controller of the new wallet\n     * @param recipientExternalID - The Recipient ID (managed externally)\n     */\n    constructor(address _controller, string memory recipientExternalID) public {\n        require(_controller != address(0), \"Invalid address of controller 1\");\n        controllers[_controller] = true;\n        controllerList.push(_controller);\n        recipientID = keccak256(abi.encodePacked(recipientExternalID));\n        recipient = recipientExternalID;\n    }\n\n    /**\n     * @dev Getter for the total number of controllers\n     * @return Total number of controllers\n     */\n    function getTotalControllers() public view returns (uint256) {\n        return controllerList.length;\n    }\n\n    /**\n     * @dev Adds a new Controller\n     * @param _controller - Controller to be added\n     * @return True if success\n     */\n    function newController(address _controller)\n        public\n        onlyController\n        returns (bool)\n    {\n        require(!controllers[_controller], \"Already a controller\");\n        require(_controller != address(0), \"Invalid Controller address\");\n        require(\n            msg.sender != _controller,\n            \"The sender cannot vote to include himself\"\n        );\n        controllers[_controller] = true;\n        controllerList.push(_controller);\n        return true;\n    }\n\n    /**\n     * @dev Deletes a Controller\n     * @param _controller - Controller to be deleted\n     * @return True if success\n     */\n    function deleteController(address _controller)\n        public\n        onlyController\n        returns (bool)\n    {\n        require(_controller != address(0), \"Invalid Controller address\");\n        require(\n            controllerList.length > 1,\n            \"Cannot leave the wallet without a controller\"\n        );\n        delete (controllers[_controller]);\n        for (uint256 i = 0; i < controllerList.length; i++) {\n            if (controllerList[i] == _controller) {\n                controllerList[i] = controllerList[controllerList.length - 1];\n                delete controllerList[controllerList.length - 1];\n                controllerList.pop();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Getter for the wallet balance for a given asset\n     * @param _assetAddress - Asset to check balance\n     * @return Balance\n     */\n    function getBalance(address _assetAddress) public view returns (uint256) {\n        MBDAAsset mbda2 = MBDAAsset(_assetAddress);\n        return mbda2.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Transfer and ERC20 asset\n     * @param _assetAddress - Asset\n     * @param _recipient - Recipient\n     * @param _amount - Amount to be transferred\n     * @notice USE NATIVE TOKEN DECIMAL PLACES\n     * @return True if success\n     */\n    function transfer(\n        address _assetAddress,\n        address _recipient,\n        uint256 _amount\n    ) public onlyController returns (bool) {\n        require(_recipient != address(0), \"Invalid address\");\n        MBDAAsset mbda = MBDAAsset(_assetAddress);\n        require(\n            mbda.balanceOf(address(this)) >= _amount,\n            \"Insufficient balance\"\n        );\n        return mbda.transfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Getter for the Recipient\n     * @return Recipient (string converted)\n     */\n    function getRecipient() public view returns (string memory) {\n        return recipient;\n    }\n\n    /**\n     * @dev Getter for the Recipient ID\n     * @return Recipient (bytes32)\n     */\n    function getRecipientID() external view returns (bytes32) {\n        return recipientID;\n    }\n\n    /**\n     * @dev Change the recipient of the wallet\n     * @param recipientExternalID - Recipient ID\n     * @return True if success\n     */\n    function changeRecipient(string memory recipientExternalID)\n        public\n        onlyController\n        returns (bool)\n    {\n        recipientID = keccak256(abi.encodePacked(recipientExternalID));\n        recipient = recipientExternalID;\n        return true;\n    }\n\n    /**\n     * @dev Receive\n     * Emits an event on ether received\n     */\n    receive() external payable {\n        emit EtherReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Withdraw Ether from the contract\n     * @param _beneficiary - Destination\n     * @param _amount - Amount\n     * @return True if success\n     */\n    function withdrawEther(address payable _beneficiary, uint256 _amount)\n        public\n        onlyController\n        returns (bool)\n    {\n        require(\n            address(this).balance >= _amount,\n            \"There is not enough balance\"\n        );\n        (bool success, ) = _beneficiary.call{value: _amount}(\"\");\n        require(success, \"Transfer failed.\");\n        return success;\n    }\n\n    function isController(address _checkAddress) external view returns (bool) {\n        return controllers[_checkAddress];\n    }\n}\n\n\n/**\n * @dev Wallet Factory\n */\ncontract MBDAWalletFactory {\n    struct Wallet {\n        string recipientID;\n        address walletAddress;\n        address controller;\n    }\n\n    Wallet[] public wallets;\n    mapping(string => Wallet) public walletsIDMap;\n\n    event NewWalletCreated(\n        address walletAddress,\n        address indexed controller,\n        string recipientExternalID\n    );\n\n    /**\n     * @dev Creates a new wallet\n     * @param _controller - Controller of the new wallet\n     * @param recipientExternalID - The Recipient ID (managed externally)\n     * @return true if success\n     */\n    function CreateWallet(\n        address _controller,\n        string memory recipientExternalID\n    ) public returns (bool) {\n        Wallet memory wallet = walletsIDMap[recipientExternalID];\n        if (wallet.walletAddress != address(0x0)) {\n            return false;\n        }\n        MBDAWallet newWallet = (new MBDAWallet)(\n            _controller,\n            recipientExternalID\n        );\n        wallet = Wallet(recipientExternalID, address(newWallet), _controller);\n        wallets.push(wallet);\n        walletsIDMap[recipientExternalID] = wallet;\n        emit NewWalletCreated(\n            address(newWallet),\n            _controller,\n            recipientExternalID\n        );\n        return true;\n    }\n\n    /**\n     * @dev Total Wallets ever created\n     * @return the total wallets ever created\n     */\n    function getTotalWalletsCreated() public view returns (uint256) {\n        return wallets.length;\n    }\n\n    /**\n     * @dev Wallet getter\n     * @param recipientID recipient ID\n     * @return Wallet (for frontend use)\n     */\n    function getWallet(string calldata recipientID)\n        external\n        view\n        returns (Wallet memory)\n    {\n        require(\n            walletsIDMap[recipientID].walletAddress != address(0x0),\n            \"invalid wallet\"\n        );\n        return walletsIDMap[recipientID];\n    }\n}\n\n\n/**\n * @title MBDAManager is a contract that generates tokens that represents a investment fund units and manages them\n */\ncontract MBDAManager {\n    struct FundTokenContract {\n        address fundManager;\n        address fundContractAddress;\n        string fundTokenSymbol;\n        bool exists;\n    }\n\n    FundTokenContract[] public contracts;\n    mapping(address => FundTokenContract) public contractsMap;\n\n    event NewFundCreated(\n        address indexed fundManager,\n        address indexed tokenAddress,\n        string indexed tokenSymbol\n    );\n\n    /**\n     * @dev Creates a new fund token\n     * @param _fundManager - Manager\n     * @param _fundChairman - Chairman\n     * @param _tokenName - Detailed ERC20 token name\n     * @param _decimalUnits - Detailed ERC20 decimal units\n     * @param _tokenSymbol - Detailed ERC20 token symbol\n     * @param _lockedUntilBlock - Block lock\n     * @param _newTotalSupply - Total Supply owned by the contract itself, only Manager can move\n     * @param _canChangeAssets - True allows the Manager to change assets in the portfolio\n     * @param _mintable - True allows Manager to min new tokens\n     * @param _hasWhiteList - Allows transfering only between whitelisted addresses\n     * @param _isSyndicate - Allows secondary market\n     * @return newFundTokenAddress the address of the newly created token\n     */\n    function newFund(\n        address _fundManager,\n        address _fundChairman,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        uint256 _lockedUntilBlock,\n        uint256 _newTotalSupply,\n        bool _canChangeAssets,    //  ---> Deixar tudo _canChangeAssets\n        bool _mintable, //  ---> Usar aqui _canMintNewTokens\n        bool _hasWhiteList,\n        bool _isSyndicate\n    ) public returns (address newFundTokenAddress) {\n        MBDAAsset ft = new MBDAAsset(\n            _fundManager,\n            _fundChairman,\n            _tokenName,\n            _decimalUnits,\n            _tokenSymbol,\n            _lockedUntilBlock,\n            _newTotalSupply,\n            _canChangeAssets,\n            _mintable,\n            _hasWhiteList,\n            _isSyndicate\n        );\n        newFundTokenAddress = address(ft);\n        FundTokenContract memory ftc = FundTokenContract(\n            _fundManager,\n            newFundTokenAddress,\n            _tokenSymbol,\n            true\n        );\n        contracts.push(ftc);\n        contractsMap[ftc.fundContractAddress] = ftc;\n        emit NewFundCreated(_fundManager, newFundTokenAddress, _tokenSymbol);\n        return newFundTokenAddress;\n    }\n\n    /**\n     * @return Total number of funds created\n     */\n    function totalContractsGenerated() public view returns (uint256) {\n        return contracts.length;\n    }\n}\n\n\n/**\n * @title MbdaBoard is the smart contract that will control all funds\n * */\ncontract MbdaBoard {\n    uint256 public minVotes; //minimum number of votes to execute a proposal\n\n    mapping(address => bool) public boardMembers; //board members\n    address[] public boardMembersList; // array with member addresses\n\n    /// @dev types of proposal allowed they are Solidity function signatures (bytes4) default ones are added on deploy later more can be added through a proposal\n    mapping(string => bytes4) public proposalTypes;\n    uint256 public totalProposals;\n\n    /// @notice proposal Struct\n    struct Proposal {\n        string proposalType;\n        address payable destination;\n        uint256 value;\n        uint8 votes;\n        bool executed;\n        bool exists;\n        bytes proposal; /// @dev ABI encoded parameters for the function of the proposal type\n        bool success;\n        bytes returnData;\n        mapping(address => bool) voters;\n    }\n\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @dev restricts calls to board members\n    modifier onlyBoardMember() {\n        require(boardMembers[msg.sender], \"Sender must be a Board Member\");\n        _;\n    }\n\n    /// @dev restricts calls to the board itself (these can only be called from a voted proposal)\n    modifier onlyBoard() {\n        require(msg.sender == address(this), \"Sender must the Board\");\n        _;\n    }\n\n    /// @dev Events\n    event NewProposal(\n        uint256 proposalID,\n        string indexed proposalType,\n        bytes proposalPayload\n    );\n    event Voted(address boardMember, uint256 proposalId);\n    event ProposalApprovedAndEnforced(\n        uint256 proposalID,\n        bytes payload,\n        bool success,\n        bytes returnData\n    );\n    event Deposit(uint256 value);\n\n    /**\n     * @dev Constructor\n     * @param _initialMembers - Initial board's members\n     * @param _minVotes - minimum votes to approve a proposal\n     * @param _proposalTypes - Proposal types to add upon deployment\n     * @param _ProposalTypeDescriptions - Description of the proposal types\n     */\n    constructor(\n        address[] memory _initialMembers,\n        uint256 _minVotes,\n        bytes4[] memory _proposalTypes,\n        string[] memory _ProposalTypeDescriptions\n    ) public {\n        require(\n            _initialMembers.length >= _minVotes,\n            \"Member list length must be equal or higher than minVotes\"\n        );\n        for (uint256 i = 0; i < _initialMembers.length; i++) {\n            require(\n                !boardMembers[_initialMembers[i]],\n                \"Duplicate Board Member sent\"\n            );\n            boardMembersList.push(_initialMembers[i]);\n            boardMembers[_initialMembers[i]] = true;\n        }\n        minVotes = _minVotes;\n\n        // setting up default proposalTypes (board management txs)\n        proposalTypes[\"addProposalType\"] = 0xeaa0dff1;\n        proposalTypes[\"removeProposalType\"] = 0x746d26b5;\n        proposalTypes[\"changeMinVotes\"] = 0x9bad192a;\n        proposalTypes[\"addBoardMember\"] = 0x1eac03ae;\n        proposalTypes[\"removeBoardMember\"] = 0x39a169f9;\n        proposalTypes[\"replaceBoardMember\"] = 0xbec44b4f;\n\n        // setting up user provided approved proposalTypes\n        if (_proposalTypes.length > 0) {\n            require(\n                _proposalTypes.length == _ProposalTypeDescriptions.length,\n                \"Proposal types and descriptions do not match\"\n            );\n            for (uint256 i = 0; i < _proposalTypes.length; i++)\n                proposalTypes[_ProposalTypeDescriptions[i]] = _proposalTypes[i];\n        }\n    }\n\n    /**\n     * @dev Adds a proposal and vote on it (onlyMember)\n     * @notice every proposal is a transaction to be executed by the board transaction type of proposal have to be previously approved (function sig)\n     * @param _type - proposal type\n     * @param _data - proposal data (ABI encoded)\n     * @param _destination - address to send the transaction to\n     * @param _value - value of the transaction\n     * @return proposalID The ID of the proposal\n     */\n    function addProposal(\n        string memory _type,\n        bytes memory _data,\n        address payable _destination,\n        uint256 _value\n    ) public onlyBoardMember returns (uint256 proposalID) {\n        require(proposalTypes[_type] != bytes4(0x0), \"Invalid proposal type\");\n        totalProposals++;\n        proposalID = totalProposals;\n\n        Proposal memory prop = Proposal(\n            _type,\n            _destination,\n            _value,\n            0,\n            false,\n            true,\n            _data,\n            false,\n            bytes(\"\")\n        );\n        proposals[proposalID] = prop;\n        emit NewProposal(proposalID, _type, _data);\n\n        // proposer automatically votes\n        require(vote(proposalID), \"Voting on the new proposal failed\");\n        return proposalID;\n    }\n\n    /**\n     * @dev Vote on a given proposal (onlyMember)\n     * @param _proposalID - Proposal ID\n     * @return True if success\n     */\n    function vote(uint256 _proposalID) public onlyBoardMember returns (bool) {\n        require(proposals[_proposalID].exists, \"The proposal is not found\");\n        require(\n            !proposals[_proposalID].voters[msg.sender],\n            \"This board member has voted already\"\n        );\n        require(\n            !proposals[_proposalID].executed,\n            \"This proposal has been approved and enforced\"\n        );\n\n        proposals[_proposalID].votes++;\n        proposals[_proposalID].voters[msg.sender] = true;\n        emit Voted(msg.sender, _proposalID);\n\n        if (proposals[_proposalID].votes >= minVotes)\n            executeProposal(_proposalID);\n\n        return true;\n    }\n\n    /**\n     * @dev Executes a proposal (internal)\n     * @param _proposalID - Proposal ID\n     */\n    function executeProposal(uint256 _proposalID) internal {\n        Proposal memory prop = proposals[_proposalID];\n        bytes memory payload = abi.encodePacked(\n            proposalTypes[prop.proposalType],\n            prop.proposal\n        );\n        proposals[_proposalID].executed = true;\n        (bool success, bytes memory returnData) = prop.destination.call{value: prop.value}(payload);\n        proposals[_proposalID].success = success;\n        proposals[_proposalID].returnData = returnData;\n        emit ProposalApprovedAndEnforced(\n            _proposalID,\n            payload,\n            success,\n            returnData\n        );\n    }\n\n    /**\n     * @dev Adds a proposal type (onlyBoard)\n     * @param _id - The name of the proposal Type\n     * @param _signature - 4 byte signature of the function to be called\n     * @return True if success\n     */\n    function addProposalType(string memory _id, bytes4 _signature)\n        public\n        onlyBoard\n        returns (bool)\n    {\n        proposalTypes[_id] = _signature;\n        return true;\n    }\n\n    /**\n     * @dev Removes a proposal type (onlyBoard)\n     * @param _id - The name of the proposal Type\n     * @return True if success\n     */\n    function removeProposalType(string memory _id)\n        public\n        onlyBoard\n        returns (bool)\n    {\n        proposalTypes[_id] = bytes4(\"\");\n        return true;\n    }\n\n    /**\n     * @dev Changes the amount of votes needed to approve a proposal (onlyBoard)\n     * @param _minVotes - New minimum quorum to approve proposals\n     * @return True if success\n     */\n    function changeMinVotes(uint256 _minVotes) public onlyBoard returns (bool) {\n        require(_minVotes > 0, \"MinVotes cannot be less than 0\");\n        require(\n            _minVotes <= boardMembersList.length,\n            \"MinVotes lower than number of members\"\n        );\n        minVotes = _minVotes;\n        return true;\n    }\n\n    /**\n     * @dev Adds a board member (onlyBoard)\n     * @param _newMember - New member to be added\n     * @return True if success\n     */\n    function addBoardMember(address _newMember)\n        public\n        onlyBoard\n        returns (bool)\n    {\n        require(!boardMembers[_newMember], \"Duplicate Board Member sent\");\n        boardMembersList.push(_newMember);\n        boardMembers[_newMember] = true;\n        if (boardMembersList.length > 1 && minVotes == 0) {\n            minVotes = 1;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Removes a board member (onlyBoard)\n     * @param _member - Member to be added\n     * @return True if success\n     */\n    function removeBoardMember(address _member)\n        public\n        onlyBoard\n        returns (bool)\n    {\n        boardMembers[_member] = false;\n        for (uint256 i = 0; i < boardMembersList.length; i++) {\n            if (boardMembersList[i] == _member) {\n                boardMembersList[i] = boardMembersList[boardMembersList.length -\n                    1];\n                boardMembersList.pop();\n            }\n        }\n        if (boardMembersList.length < minVotes) {\n            minVotes = boardMembersList.length;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Replaces a board member (onlyBoard)\n     * @param _oldMember - Old member to be replaced\n     * @param _newMember - New member to be added\n     * @return True if success\n     */\n    function replaceBoardMember(address _oldMember, address _newMember)\n        public\n        onlyBoard\n        returns (bool)\n    {\n        require(removeBoardMember(_oldMember), \"Failed to remove old member\");\n        return addBoardMember(_newMember);\n    }\n\n    /**\n     * @dev Receive\n     */\n    receive() external payable {\n        emit Deposit(msg.value);\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fundBoard\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimalUnits\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_lockedUntilBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_canChangeAssets\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_mintable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_hasWhiteList\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isSyndicate\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"BlockLockSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newTotalSupply\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"assetInfo\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"amount\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAssetAmount\",\"type\":\"uint256\"}],\"name\":\"FundAssetsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newTotalSupply\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newInvestor\",\"type\":\"address\"}],\"name\":\"NewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"NewManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"RemovedInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_assetTicker\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_assetInfo\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_assetPercentageParticipation\",\"type\":\"uint8\"}],\"name\":\"addNewAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investor\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_investorInfo\",\"type\":\"string\"}],\"name\":\"addNewInvestor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_details\",\"type\":\"string\"}],\"name\":\"addTradingPlatform\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assets\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"assetTicker\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"assetInfo\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"assetPercentageParticipation\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"board\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canChangeAssets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"clearedInvestors\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"financialDetailsHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSyndicate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"isTransferValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedUntilBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_assetIndex\",\"type\":\"uint8\"}],\"name\":\"removeAnAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"removeInvestor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeTradingPlatform\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"replaceAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockedUntilBlock\",\"type\":\"uint256\"}],\"name\":\"setBlockLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"setFinancialDetails\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"setFinancialDetailsHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssetsArray\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tradingPlatforms\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_assetTicker\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_assetInfo\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_newAmount\",\"type\":\"uint8\"}],\"name\":\"updateAnAssetQuantity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"urlFinancialDetailsDocument\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MBDAAsset", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a1a2bf87fd49e1d222353821b4335fc21a61880f000000000000000000000000192cdf05e035641482ac26c2d7c8bed6e1fa836c0000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000019546f6b656e205665726966696361646f2054657374652030320000000000000000000000000000000000000000000000000000000000000000000000000000055456543032000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}