{"SourceCode": "pragma solidity ^0.5.12;\r\n\r\n/**\r\n * @dev Simplified contract of a `../Swapper.sol`\r\n */\r\ncontract SwapperLike {\r\n    function fromDaiToBTU(address, uint256) external;\r\n}\r\n\r\n\r\n/**\r\n * @dev Simplified contract of a VatLike\r\n * For full implementation please see MakerDAO's repo at <https://github.com/makerdao/dss>\r\n */\r\ncontract VatLike {\r\n    function hope(address) external;\r\n}\r\n\r\n\r\n/**\r\n * @dev Simplified contract of a PotLike\r\n * For full implementation please see MakerDAO's repo at <https://github.com/makerdao/dss>\r\n */\r\ncontract PotLike {\r\n    function chi() external view returns (uint256);\r\n    function rho() external view returns (uint256);\r\n    function dsr() external view returns (uint256);\r\n    function drip() external returns (uint256);\r\n    function join(uint256) external;\r\n    function exit(uint256) external;\r\n}\r\n\r\n\r\n/**\r\n * @dev Simplified contract of a DaiJoin\r\n * For full implementation please see MakerDAO's repo at <https://github.com/makerdao/dss>\r\n */\r\ncontract JoinLike {\r\n    function join(address, uint256) external;\r\n    function exit(address, uint256) external;\r\n}\r\n\r\n\r\n/**\r\n * @dev Simplified contract of a ERC20 Token\r\n */\r\ncontract ERC20Like {\r\n    function transferFrom(address, address, uint256) external returns (bool);\r\n    function transfer(address, uint256) external returns (bool);\r\n    function approve(address, uint256) external returns (bool);\r\n    function allowance(address, address) external view returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary RayMath {\r\n    uint256 internal constant ONE_RAY = 10**27;\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a, \"Bdai: overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errMsg)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, errMsg);\r\n\r\n        return a - b;\r\n    }\r\n\r\n    function subOrZero(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b > a) {\r\n            return uint256(0);\r\n        } else {\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        require(c / a == b, \"bDai: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / ONE_RAY;\r\n    }\r\n\r\n    /**\r\n     * @dev Warning : result is rounded toward zero\r\n     */\r\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"bDai: division by 0\");\r\n\r\n        return mul(a, ONE_RAY) / b;\r\n    }\r\n\r\n    /**\r\n     * @dev do division with rouding up\r\n     */\r\n    function rdivup(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, ONE_RAY), sub(b, 1, \"bDai: division by 0\")) / b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Implementation of the bDAI ERC20 token\r\n *\r\n * This contracts aims to take `amount` DAI, subscribes it to the DSR program and\r\n * gives back `amount` of bDAI. User can then earn interests on these bDAI in BTU\r\n *\r\n * To have bDAI user needs to call join or joinFor\r\n * claim and claimFor are used to be get back interests in BTU\r\n * exit and exitFor are aimed to claim back the user's DAI\r\n */\r\ncontract Bdai is IERC20 {\r\n    using RayMath for uint256;\r\n\r\n    bool public live;\r\n    uint8 public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    string public constant name = \"BTU Incentivized DAI\";\r\n    string public constant symbol = \"bDAI\";\r\n    string public constant version = \"1\";\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => uint256) private _pies;\r\n    mapping(address => uint256) private _nonces;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    ERC20Like public dai;\r\n    JoinLike public daiJoin;\r\n    PotLike public pot;\r\n    VatLike public vat;\r\n    SwapperLike public swapper;\r\n\r\n    address public owner;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR; //EIP712 domain\r\n\r\n    //keccak256 \"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\"\r\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\r\n\r\n    //keccak256 \"ClaimFor(address holder,address spender,uint256 nonce,uint256 expiry,address dest)\"\r\n    bytes32 public constant CLAIM_TYPEHASH = 0xcbd06f2e482e52538ba0a2e3b1ec074c1ff826895448b9cf7b33c0abbbe904b3;\r\n\r\n    //keccak256 \"ExitFor(address holder,address spender,uint256 nonce,uint256 expiry,uint256 amount)\"\r\n    bytes32 public constant EXIT_TYPEHASH = 0x703d2576480f8b8746c2232693aae93ab2bda9c8b68427bce6eff0c6238807ed;\r\n\r\n    /**\r\n     * @dev Sets the external MakerDAO's contract address. All of these values are immutable.\r\n     *      Authorises these contracts to play with DAI owned by `this`\r\n     */\r\n    constructor(\r\n        address dai_,\r\n        address daiJoin_,\r\n        address pot_,\r\n        address vat_,\r\n        address swapper_,\r\n        uint256 chainId_\r\n    ) public {\r\n        owner = msg.sender;\r\n        live = true;\r\n\r\n        dai = ERC20Like(dai_);\r\n        daiJoin = JoinLike(daiJoin_);\r\n        pot = PotLike(pot_);\r\n        vat = VatLike(vat_);\r\n        swapper = SwapperLike(swapper_);\r\n\r\n        vat.hope(daiJoin_);\r\n        vat.hope(pot_);\r\n\r\n        dai.approve(daiJoin_, uint256(-1));\r\n        dai.approve(swapper_, uint256(-1));\r\n\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\r\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n                ),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(version)),\r\n                chainId_,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of bDAI owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amount` of bDAI from `sender` to `recipient`\r\n     *      Before the transfer, `sender` earns interrests on its bDAI\r\n     *\r\n     * Requirements :\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     *\r\n     * Emits {Transfer} event\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the pie owned by `account` on the DSR contract (e.g. pot.sol from MakerDAO).\r\n     */\r\n    function pieOf(address account) external view returns (uint256) {\r\n        return _pies[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the last recorded `chi` from the dsr contract\r\n     */\r\n    function chi() external view returns (uint256) {\r\n        return pot.chi();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the last recorded `rho` from the dsr contract\r\n     */\r\n    function rho() external view returns (uint256) {\r\n        return pot.rho();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the last recorded `dsr` from the dsr contract\r\n     */\r\n    function dsr() external view returns (uint256) {\r\n        return pot.dsr();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of bDAI which `spender` can take from `tokenOwner` account\r\n     */\r\n    function allowance(address tokenOwner, address spender)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowances[tokenOwner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets an allowance of `amount` for `spender` over the caller's bDAI\r\n     *\r\n     * Emits {Approval} event\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        require(spender != address(0), \"Bdai: approve to 0x0\");\r\n\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amount` of bDAI from `sender` to `recipient`\r\n     *      Before the transfer, `sender` earns interrests on its bDAI\r\n     *      Updates allowance if not set to MAX_UINT256\r\n     *\r\n     * Requirements :\r\n     * - `sender`cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have an allowance of at least `amount`.\r\n     * - `sender` must have at least `amount` of token\r\n     *\r\n     * Emits {Transfer} event\r\n     * Emits an {Approval} event indicating the updated allowance\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _allow(sender, msg.sender, amount);\r\n        _transfer(sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Takes `amount` of DAI (in wad) from the caller and subscribes it to the dsr\r\n     *      Mints `amount` of bDAI for the caller\r\n     *\r\n     * Requirements :\r\n     * - the caller must have at least `amount` of DAI.\r\n     *\r\n     * Emits {Transfer} event\r\n     */\r\n    function join(uint256 amount) external {\r\n        _join(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Takes `amount` of DAI (in wad) from the caller and subscribes it to the dsr\r\n     *      Mints `amount` of bDAI for `dest` (e.g. DAI are taken from caller and bDAI are sent to `dest`)\r\n     *\r\n     * Requirements :\r\n     * - the caller must have at least `amount` of DAI.\r\n     * - `dest` cannot be zero address\r\n     *\r\n     * Emits {Transfer} event\r\n     */\r\n    function joinFor(address dest, uint256 amount) external {\r\n        require(dest != address(0), \"bDai: dest cannot be 0x0\");\r\n        _join(dest, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Recalculates caller's `pie` to fit with its bDAI\r\n     *      Converts interrests to BTU and sends it to caller's address\r\n     */\r\n    function claim() external {\r\n        _claim(msg.sender, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Recalculates caller's `pie` to fit with its bDAI\r\n     *      Converts interrests to BTU and sends it to `dest` address\r\n     *\r\n     * Requirements :\r\n     * - `dest` cannot be the zero address\r\n     */\r\n    function claim(address dest) external {\r\n        require(dest != address(0), \"bDai: dest cannot be 0x0\");\r\n        _claim(msg.sender, dest);\r\n    }\r\n\r\n    /**\r\n     * @dev Takes `amount` of bDAI and returns `amount` of DAI\r\n     *      Claims interest\r\n     *      Burns `amount` of bDAI\r\n     *\r\n     * Requirements :\r\n     * - the caller must have at least `amount` of bDAI.\r\n     *\r\n     * Emits {Transfer} event\r\n     */\r\n    function exit(uint256 amount) external {\r\n        _exit(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amounts` of bDAI from caller to `recipients`\r\n     * Before the transfer, caller earns interrests on its bDAI\r\n     *\r\n     * Requirements :\r\n     * - `recipients` cannot contain the zero address.\r\n     * - the caller must have a balance of at least `total(amounts)`.\r\n     *\r\n     * Emits {Transfer} event\r\n     */\r\n    function transfer(address[] memory recipients, uint256[] memory amounts)\r\n        public\r\n        returns (bool)\r\n    {\r\n        _transfer(msg.sender, recipients, amounts);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amounts` of bDAI from caller to `recipients`\r\n     * Before the transfer, caller earns interrests on its bDAI\r\n     *\r\n     * Requirements :\r\n     * - `sender`cannot be the zero address.\r\n     * - `recipients` cannot contain the zero address.\r\n     * - the caller must have an allowance of at least `total(amounts)`.\r\n     * - `sender` must have a balance of at least `total(amounts)`.\r\n     *\r\n     * Emits {Transfer} event\r\n     * Emits an {Approval} event indicating the updated allowance\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address[] memory recipients,\r\n        uint256[] memory amounts\r\n    ) public returns (bool) {\r\n        uint256 total;\r\n\r\n        for (uint256 i; i < recipients.length; ++i) {\r\n            total = total.add(amounts[i]);\r\n        }\r\n\r\n        _allow(sender, msg.sender, total);\r\n        _transfer(sender, recipients, amounts);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the noce ofe `account`\r\n     */\r\n    function nonces(address account) external view returns (uint256) {\r\n        return _nonces[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets an allowance of `MAX_UINT256` for `spender` over the holder's bDAI if `allowaed` set to `true`\r\n     *\r\n     * Requiremets:\r\n     * - `holder` cannot be the zero address\r\n     * - `spender` cannot be the zero address\r\n     * - `nonce` must be actual nonce of `holder` + 1\r\n     * - `expiry` must be zero (for infinite validity) or lower than `now` if not null\r\n     * - `v`, `r`, `s` must contain the permit message signed by `holder`\r\n     *\r\n     * Emits {Approval} event\r\n     */\r\n    function permit(\r\n        address holder,\r\n        address spender,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        bool allowed,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(holder != address(0), \"bDai: approve from 0x0\");\r\n        require(spender != address(0), \"bDai: approve to 0x0\");\r\n        require(expiry == 0 || now <= expiry, \"bDai: permit-expired\");\r\n        require(nonce == _nonces[holder]++, \"bDai: invalid-nonce\");\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(\r\n                    abi.encode(\r\n                        PERMIT_TYPEHASH,\r\n                        holder,\r\n                        spender,\r\n                        nonce,\r\n                        expiry,\r\n                        allowed\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        require(holder == ecrecover(digest, v, r, s), \"bDai: invalid-permit\");\r\n        uint256 amount = allowed ? uint256(-1) : 0;\r\n        _allowances[holder][spender] = amount;\r\n        emit Approval(holder, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Recalculates `account`'s `pie` to fit with its bDAI\r\n     *      Converts interrests to BTU and sends it to `dest` address\r\n     *\r\n     * Requirements :\r\n     * - the caller must have an allowance >= of the `account`'s balance\r\n     * - `dest` cannot be the zero address\r\n     */\r\n    function claimFor(\r\n        address holder,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        address dest,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(dest != address(0), \"bDai: dest cannot be 0x0\");\r\n        require(holder != address(0), \"bDai: claim from 0x0\");\r\n        require(expiry == 0 || now <= expiry, \"bDai: permit-expired\");\r\n        require(nonce == _nonces[holder]++, \"bDai: invalid-nonce\");\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(\r\n                    abi.encode(\r\n                        CLAIM_TYPEHASH,\r\n                        holder,\r\n                        msg.sender,\r\n                        nonce,\r\n                        expiry,\r\n                        dest\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        require(holder == ecrecover(digest, v, r, s), \"bDai: invalid-permit\");\r\n        _claim(holder, dest);\r\n    }\r\n\r\n    /**\r\n     * @dev Takes `amount` of bDAI and returns `amount` of DAI in the name of `account`\r\n     * Claims interest\r\n     * Burns `amount` of bDAI\r\n     *\r\n     * Requirements :\r\n     * - `holder` must have at least `amount` of bDAI.\r\n     * - `holder` cannot be the zero address\r\n     * - `nonce` must be actual nonce of `holder` + 1\r\n     * - `expiry` must be zero (for infinite validity) or lower than `now` if not null\r\n     * - `v`, `r`, `s` must contain the permit message signed by `holder`\r\n     *\r\n     * Emits {Transfer} event\r\n     */\r\n    function exitFor(\r\n        address holder,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        uint256 amount,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(holder != address(0), \"bDai: exit from 0x0\");\r\n        require(expiry == 0 || now <= expiry, \"bDai: permit-expired\");\r\n        require(nonce == _nonces[holder]++, \"bDai: invalid-nonce\");\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(\r\n                    abi.encode(\r\n                        EXIT_TYPEHASH,\r\n                        holder,\r\n                        msg.sender,\r\n                        nonce,\r\n                        expiry,\r\n                        amount\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        require(holder == ecrecover(digest, v, r, s), \"bDai: invalid-permit\");\r\n        _exit(holder, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev only callers with address equals to `owner` can call functions with this modifier\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"bDai: op not allowed\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the contract owner from `owner` to `owner_`\r\n     *\r\n     * Requirements :\r\n     * - the caller must be the actual contract `owner`\r\n     * - `owner_` cannot be the zero address\r\n     *\r\n     */\r\n    function setOwner(address owner_) external onlyOwner {\r\n        require(owner_ != address(0), \"bDai: owner cannot be 0x0\");\r\n        owner = owner_;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the `live` params, if set to `false` join functionnality is blocked\r\n     *\r\n     * Requirements :\r\n     * - the caller must be the actual contract `owner`\r\n     *\r\n     */\r\n    function freeze(bool freeze_) external onlyOwner {\r\n        live = !freeze_;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the `swapper` contract\r\n     *\r\n     * Requirements :\r\n     * - the caller must be the actual contract `owner`\r\n     * - `swapper_` cannot be the zero address\r\n     *\r\n     */\r\n    function setSwapper(address swapper_) external onlyOwner {\r\n        require(swapper_ != address(0), \"bDai: cannot set to 0x0\");\r\n        address oldSwapper = address(swapper);\r\n        swapper = SwapperLike(swapper_);\r\n\r\n        dai.approve(oldSwapper, uint256(0));\r\n        dai.approve(swapper_, uint256(-1));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the actual `chi` from the DSR (e.g. call `pot.drip()` if needed)\r\n     */\r\n    function _chi() internal returns (uint256) {\r\n        return now > pot.rho() ? pot.drip() : pot.chi();\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the allowance of `caller` over `sender` for a specified `amount`\r\n     * Emits an {Approval} event indicating the updated allowance\r\n     */\r\n    function _allow(address sender, address caller, uint256 amount) internal {\r\n        uint256 a = _allowances[sender][caller];\r\n        require(a > 0, \"bDAI: bad allowance\");\r\n        if (a != uint256(-1)) {\r\n            _allowances[sender][caller] = a.sub(amount, \"bDAI: bad allowance\");\r\n            emit Approval(sender, caller, _allowances[sender][caller]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amount` of bDAI from `sender` to `recipient`\r\n     * Before the transfer, `sender` earns interrests on its bDAI\r\n     *\r\n     * Requirements :\r\n     * - `sender`cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     *\r\n     * Emits {Transfer} event\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount)\r\n        internal\r\n    {\r\n        require(sender != address(0), \"Bdai: transfer from 0x0\");\r\n        require(recipient != address(0), \"Bdai: transfer to 0x0\");\r\n\r\n        uint256 c = _chi();\r\n        uint256 senderBalance = _balances[sender];\r\n        uint256 oldSenderPie = _pies[sender];\r\n        uint256 tmp = senderBalance.rdivup(c); //Pie reseted\r\n        uint256 pieToClaim = oldSenderPie.subOrZero(tmp);\r\n        uint256 pieToBeTransfered = amount.rdivup(c);\r\n\r\n        _balances[sender] = senderBalance.sub(\r\n            amount,\r\n            \"bDai: not enougth funds\"\r\n        );\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n\r\n        tmp = pieToClaim.add(pieToBeTransfered);\r\n        if (tmp > oldSenderPie) {\r\n            _pies[sender] = 0;\r\n            _pies[recipient] = _pies[recipient].add(oldSenderPie);\r\n        } else {\r\n            _pies[sender] = oldSenderPie - tmp;\r\n            _pies[recipient] = _pies[recipient].add(pieToBeTransfered);\r\n        }\r\n\r\n        if (pieToClaim > 0) {\r\n            uint256 claimedToken = pieToClaim.rmul(c);\r\n\r\n            pot.exit(pieToClaim);\r\n            daiJoin.exit(address(this), claimedToken);\r\n            swapper.fromDaiToBTU(sender, claimedToken);\r\n        }\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amounts` of bDAI from caller to `recipients`\r\n     * Before the transfer, caller earns interrests on its bDAI\r\n     *\r\n     * Requirements :\r\n     * - `sender`cannot be the zero address.\r\n     * - `recipients` cannot contain the zero address.\r\n     * - the caller must have an allowance of at least `total(amounts)`.\r\n     * - `sender` must have a balance of at least `total(amounts)`.\r\n     *\r\n     * Emits {Transfer} event\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address[] memory recipients,\r\n        uint256[] memory amounts\r\n    ) internal {\r\n        require(sender != address(0), \"Bdai: transfer from 0x0\");\r\n\r\n        uint256 c = _chi();\r\n        uint256 senderBalance = _balances[sender];\r\n        uint256 oldSenderPie = _pies[sender];\r\n        uint256 tmp = senderBalance.rdivup(c); //Pie reseted\r\n        uint256 pieToClaim = oldSenderPie.subOrZero(tmp);\r\n        uint256 pieToBeTransfered;\r\n\r\n        uint256 total;\r\n        uint256 totalPie = oldSenderPie;\r\n        for (uint256 i; i < recipients.length; ++i) {\r\n            require(recipients[i] != address(0), \"Bdai: transfer to 0x0\");\r\n            total = total.add(amounts[i]);\r\n\r\n            pieToBeTransfered = amounts[i].rdivup(c);\r\n            _balances[recipients[i]] = _balances[recipients[i]].add(amounts[i]);\r\n\r\n            tmp = pieToClaim.add(pieToBeTransfered);\r\n            if (tmp > oldSenderPie) {\r\n                totalPie = 0;\r\n                _pies[recipients[i]] = _pies[recipients[i]].add(oldSenderPie);\r\n            } else {\r\n                totalPie = oldSenderPie - tmp;\r\n                _pies[recipients[i]] = _pies[recipients[i]].add(\r\n                    pieToBeTransfered\r\n                );\r\n            }\r\n\r\n            emit Transfer(sender, recipients[i], amounts[i]);\r\n        }\r\n\r\n        _balances[sender] = senderBalance.sub(total, \"bDai: not enougth funds\");\r\n        _pies[sender] = totalPie;\r\n\r\n        if (pieToClaim > 0) {\r\n            uint256 claimedToken = pieToClaim.rmul(c);\r\n\r\n            pot.exit(pieToClaim);\r\n            daiJoin.exit(address(this), claimedToken);\r\n            swapper.fromDaiToBTU(sender, claimedToken);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes `amount` of DAI (in wad) from the caller and subscribes it to the dsr\r\n     * Mints `amount` of bDAI for `dest` (e.g. DAI are taken from caller and bDAI are sent to `dest`)\r\n     *\r\n     * Requirements :\r\n     * - the caller must have at least `amount` of DAI.\r\n     *\r\n     * Emits {Transfer} event\r\n     */\r\n    function _join(address dest, uint256 amount) internal {\r\n        require(live, \"bDai: system is frozen\");\r\n\r\n        uint256 c = _chi();\r\n        uint256 pie = amount.rdiv(c);\r\n\r\n        totalSupply = totalSupply.add(amount);\r\n        _balances[dest] = _balances[dest].add(amount);\r\n        _pies[dest] = _pies[dest].add(pie);\r\n\r\n        dai.transferFrom(msg.sender, address(this), amount);\r\n        daiJoin.join(address(this), amount);\r\n        pot.join(pie);\r\n\r\n        emit Transfer(address(0), dest, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Recalculates `account`'s `pie` to fit with its bDAI\r\n     *      Sends BTU to `dest` address\r\n     * Converts interrests to BTU and sends it to caller's address\r\n     */\r\n    function _claim(address account, address dest) internal {\r\n        uint256 c = _chi();\r\n        uint256 newPie = _balances[account].rdivup(c);\r\n        uint256 pieDiff = _pies[account].subOrZero(newPie);\r\n\r\n        if (pieDiff > 0) {\r\n            uint256 exitedTokens = pieDiff.rmul(c);\r\n            _pies[account] = newPie;\r\n\r\n            pot.exit(pieDiff);\r\n            daiJoin.exit(address(this), exitedTokens);\r\n            swapper.fromDaiToBTU(dest, exitedTokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Takes `amount` of bDAI and returns `amount` of DAI in the name of `account`\r\n     * Claims interest\r\n     * Burns `amount` of bDAI\r\n     *\r\n     * Requirements :\r\n     * - `amount` cannot be zero\r\n     * - `account` must have at least `amount` of bDAI.\r\n     * - the caller must have an allowance of at least `amount` over the `account` address\r\n     *\r\n     * Emits {Transfer} event\r\n     */\r\n    function _exit(address account, uint256 amount) internal {\r\n        require(amount > 0, \"bDai : zero amount\");\r\n\r\n        uint256 c = _chi();\r\n        uint256 bal2 = _balances[account].sub(\r\n            amount,\r\n            \"bDai: not enougth funds\"\r\n        );\r\n        uint256 pie2 = bal2.rdiv(c);\r\n        uint256 pieDiff = _pies[account].sub(pie2, \"bDai: not enougth funds\");\r\n        uint256 totalDai = pieDiff.rmul(c);\r\n        uint256 interestToken = totalDai.subOrZero(amount);\r\n\r\n        _balances[account] = bal2;\r\n        totalSupply = totalSupply.sub(amount, \"bDai: totalSupply underflow\");\r\n        _pies[account] = pie2;\r\n\r\n        pot.exit(pieDiff);\r\n        daiJoin.exit(address(this), totalDai);\r\n        dai.transfer(account, amount);\r\n\r\n        if (interestToken > 0) {\r\n            swapper.fromDaiToBTU(account, interestToken);\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dai_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"daiJoin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pot_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vat_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapper_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLAIM_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EXIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"claimFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"contract ERC20Like\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiJoin\",\"outputs\":[{\"internalType\":\"contract JoinLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dsr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"exitFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"freeze_\",\"type\":\"bool\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"join\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"joinFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pieOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pot\",\"outputs\":[{\"internalType\":\"contract PotLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rho\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapper_\",\"type\":\"address\"}],\"name\":\"setSwapper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapper\",\"outputs\":[{\"internalType\":\"contract SwapperLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract VatLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Bdai", "CompilerVersion": "v0.5.12+commit.7709ece9", "OptimizationUsed": "1", "Runs": "2048", "ConstructorArguments": "0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000009759a6ac90977b93b58547b4a71c78317f391a28000000000000000000000000197e90f9fad81970ba7976f33cbd77088e5d7cf700000000000000000000000035d1b3f3d7966a1dfe207aa4514c12a259a0492b00000000000000000000000013a36fef375cb8f3fdb776fea090e3016a7c3c600000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://0393be7c3b5ab2037e88e0dee20d88ed4adba8e53af7d1f6a002507d5e6f2038"}