{"SourceCode": "pragma solidity ^0.4.18;\r\n\r\ncontract useContractWeb {\r\n\r\n  ContractWeb internal web = ContractWeb(0x5F9489D7FfC63ce0bDCD282D14E595A865B259d7);\r\n\r\n}\r\n\r\ncontract Owned {\r\n\r\n  address public owner = msg.sender;\r\n\r\n  function transferOwner(address _newOwner) onlyOwner public returns (bool) {\r\n    owner = _newOwner;\r\n    return true;\r\n  }\r\n\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\ncontract CheckPayloadSize {\r\n\r\n  modifier onlyPayloadSize(uint256 _size) {\r\n    require(msg.data.length >= _size + 4);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\ncontract CanTransferTokens is CheckPayloadSize, Owned {\r\n\r\n  function transferCustomToken(address _token, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyOwner public returns (bool) {\r\n    Token tkn = Token(_token);\r\n    return tkn.transfer(_to, _value);\r\n  }\r\n\r\n}\r\n\r\ncontract SafeMath {\r\n\r\n  function add(uint256 x, uint256 y) pure internal returns (uint256) {\r\n    require(x <= x + y);\r\n    return x + y;\r\n  }\r\n\r\n  function sub(uint256 x, uint256 y) pure internal returns (uint256) {\r\n    require(x >= y);\r\n    return x - y;\r\n  }\r\n\r\n}\r\n\r\ncontract CheckIfContract {\r\n\r\n  function isContract(address _addr) view internal returns (bool) {\r\n    uint256 length;\r\n    if (_addr == address(0x0)) return false;\r\n    assembly {\r\n      length := extcodesize(_addr)\r\n    }\r\n    if(length > 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\ncontract ContractReceiver {\r\n\r\n  TKN internal fallback;\r\n\r\n  struct TKN {\r\n    address sender;\r\n    uint256 value;\r\n    bytes data;\r\n    bytes4 sig;\r\n  }\r\n\r\n  function getFallback() view public returns (TKN) {\r\n    return fallback;\r\n  }\r\n\r\n\r\n  function tokenFallback(address _from, uint256 _value, bytes _data) public returns (bool) {\r\n    TKN memory tkn;\r\n    tkn.sender = _from;\r\n    tkn.value = _value;\r\n    tkn.data = _data;\r\n    uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\r\n    tkn.sig = bytes4(u);\r\n    fallback = tkn;\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract Token1st {\r\n\r\n  address public currentTradingSystem;\r\n  address public currentExchangeSystem;\r\n\r\n  mapping(address => uint) public balanceOf;\r\n  mapping(address => mapping (address => uint)) public allowance;\r\n  mapping(address => mapping (address => uint)) public tradingBalanceOf;\r\n  mapping(address => mapping (address => uint)) public exchangeBalanceOf;\r\n\r\n  /* @notice get balance of a specific address */\r\n  function getBalanceOf(address _address) view public returns (uint amount){\r\n    return balanceOf[_address];\r\n  }\r\n\r\n  event Transfer (address _to, address _from, uint _decimalAmount);\r\n\r\n  /* A contract or user attempts to get the coins */\r\n  function transferDecimalAmountFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n    require(balanceOf[_from]\r\n      - tradingBalanceOf[_from][currentTradingSystem]\r\n      - exchangeBalanceOf[_from][currentExchangeSystem] >= _value);                 // Check if the sender has enough\r\n    require(balanceOf[_to] + (_value) >= balanceOf[_to]);  // Check for overflows\r\n    require(_value <= allowance[_from][msg.sender]);   // Check allowance\r\n    balanceOf[_from] -= _value;                          // Subtract from the sender\r\n    balanceOf[_to] += _value;                            // Add the same to the recipient\r\n    allowance[_from][msg.sender] -= _value;\r\n    Transfer(_to, _from, _value);\r\n    return true;\r\n  }\r\n\r\n    /* Allow another contract or user to spend some tokens in your behalf */\r\n  function approveSpenderDecimalAmount(address _spender, uint _value) public returns (bool success) {\r\n    allowance[msg.sender][_spender] = _value;\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract ContractWeb is CanTransferTokens, CheckIfContract {\r\n\r\n      //contract name | contract info\r\n  mapping(string => contractInfo) internal contracts;\r\n\r\n  event ContractAdded(string indexed _name, address indexed _referredTo);\r\n  event ContractEdited(string indexed _name, address indexed _referredTo);\r\n  event ContractMadePermanent(string indexed _name);\r\n\r\n  struct contractInfo {\r\n    address contractAddress;\r\n    bool isPermanent;\r\n  }\r\n\r\n  function getContractAddress(string _name) view public returns (address) {\r\n    return contracts[_name].contractAddress;\r\n  }\r\n\r\n  function isContractPermanent(string _name) view public returns (bool) {\r\n    return contracts[_name].isPermanent;\r\n  }\r\n\r\n  function setContract(string _name, address _address) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) {\r\n    require(isContract(_address));\r\n    require(this != _address);\r\n    require(contracts[_name].contractAddress != _address);\r\n    require(contracts[_name].isPermanent == false);\r\n    address oldAddress = contracts[_name].contractAddress;\r\n    contracts[_name].contractAddress = _address;\r\n    if(oldAddress == address(0x0)) {\r\n      ContractAdded(_name, _address);\r\n    } else {\r\n      ContractEdited(_name, _address);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function makeContractPermanent(string _name) onlyOwner public returns (bool) {\r\n    require(contracts[_name].contractAddress != address(0x0));\r\n    require(contracts[_name].isPermanent == false);\r\n    contracts[_name].isPermanent = true;\r\n    ContractMadePermanent(_name);\r\n    return true;\r\n  }\r\n\r\n  function tokenSetup(address _Tokens1st, address _Balancecs, address _Token, address _Conversion, address _Distribution) onlyPayloadSize(5 * 32) onlyOwner public returns (bool) {\r\n    setContract(\"Token1st\", _Tokens1st);\r\n    setContract(\"Balances\", _Balancecs);\r\n    setContract(\"Token\", _Token);\r\n    setContract(\"Conversion\", _Conversion);\r\n    setContract(\"Distribution\", _Distribution);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract Balances is CanTransferTokens, SafeMath, useContractWeb {\r\n\r\n  mapping(address => uint256) internal _balances;\r\n\r\n  function get(address _account) view public returns (uint256) {\r\n    return _balances[_account];\r\n  }\r\n\r\n  function tokenContract() view internal returns (address) {\r\n    return web.getContractAddress(\"Token\");\r\n  }\r\n\r\n  function Balances() public {\r\n    _balances[msg.sender] = 190 * 1000000 * 1000000000000000000;\r\n  }\r\n\r\n  modifier onlyToken {\r\n    require(msg.sender == tokenContract());\r\n    _;\r\n  }\r\n\r\n  function transfer(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyToken public returns (bool success) {\r\n  _balances[_from] = sub(_balances[_from], _value);\r\n  _balances[_to] = add(_balances[_to], _value);\r\n  return true;\r\n  }\r\n\r\n}\r\n\r\ncontract Token is CanTransferTokens, SafeMath, CheckIfContract, useContractWeb {\r\n\r\n  string public symbol = \"SHC\";\r\n  string public name = \"ShineCoin\";\r\n  uint8 public decimals = 18;\r\n  uint256 public totalSupply = 190 * 1000000 * 1000000000000000000;\r\n\r\n  mapping (address => mapping (address => uint256)) internal _allowance;\r\n\r\n    // ERC20 Events\r\n  event Approval(address indexed from, address indexed to, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // ERC223 Event\r\n  event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);\r\n\r\n  function balanceOf(address _account) view public returns (uint256) {\r\n    return Balances(balancesContract()).get(_account);\r\n  }\r\n\r\n  function allowance(address _from, address _to) view public returns (uint256 remaining) {\r\n    return _allowance[_from][_to];\r\n  }\r\n\r\n  function balancesContract() view internal returns (address) {\r\n    return web.getContractAddress(\"Balances\");\r\n  }\r\n\r\n  function Token() public {\r\n    bytes memory empty;\r\n    Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000);\r\n    Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000, empty);\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {\r\n    if(isContract(_to)) {\r\n      require(Balances(balancesContract()).get(msg.sender) >= _value);\r\n      Balances(balancesContract()).transfer(msg.sender, _to, _value);\r\n      ContractReceiver receiver = ContractReceiver(_to);\r\n      require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\r\n      Transfer(msg.sender, _to, _value);\r\n      Transfer(msg.sender, _to, _value, _data);\r\n      return true;\r\n    } else {\r\n      return transferToAddress(_to, _value, _data);\r\n    }\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value, bytes _data) onlyPayloadSize(3 * 32) public returns (bool success) {\r\n    if(isContract(_to)) {\r\n      return transferToContract(_to, _value, _data);\r\n    }\r\n    else {\r\n      return transferToAddress(_to, _value, _data);\r\n    }\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool success) {\r\n    bytes memory empty;\r\n    if(isContract(_to)) {\r\n      return transferToContract(_to, _value, empty);\r\n    }\r\n    else {\r\n      return transferToAddress(_to, _value, empty);\r\n    }\r\n  }\r\n\r\n  function transferToAddress(address _to, uint256 _value, bytes _data) internal returns (bool success) {\r\n    require(Balances(balancesContract()).get(msg.sender) >= _value);\r\n    Balances(balancesContract()).transfer(msg.sender, _to, _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    Transfer(msg.sender, _to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  function transferToContract(address _to, uint256 _value, bytes _data) internal returns (bool success) {\r\n    require(Balances(balancesContract()).get(msg.sender) >= _value);\r\n    Balances(balancesContract()).transfer(msg.sender, _to, _value);\r\n    ContractReceiver receiver = ContractReceiver(_to);\r\n    receiver.tokenFallback(msg.sender, _value, _data);\r\n    Transfer(msg.sender, _to, _value);\r\n    Transfer(msg.sender, _to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns (bool) {\r\n    bytes memory empty;\r\n    require(_value > 0 && _allowance[_from][msg.sender] >= _value && Balances(balancesContract()).get(_from) >= _value);\r\n    _allowance[_from][msg.sender] = sub(_allowance[_from][msg.sender], _value);\r\n    if(msg.sender != _to && isContract(_to)) {\r\n      Balances(balancesContract()).transfer(_from, _to, _value);\r\n      ContractReceiver receiver = ContractReceiver(_to);\r\n      receiver.tokenFallback(_from, _value, empty);\r\n    } else {\r\n      Balances(balancesContract()).transfer(_from, _to, _value);\r\n    }\r\n    Transfer(_from, _to, _value);\r\n    Transfer(_from, _to, _value, empty);\r\n    return true;\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) {\r\n    _allowance[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract Conversion is CanTransferTokens, useContractWeb {\r\n\r\n  function token1stContract() view internal returns (address) {\r\n    return web.getContractAddress(\"Token1st\");\r\n  }\r\n\r\n  function tokenContract() view internal returns (address) {\r\n    return web.getContractAddress(\"Token\");\r\n  }\r\n\r\n  function deposit() onlyOwner public returns (bool) {\r\n    require(Token(tokenContract()).allowance(owner, this) > 0);\r\n    return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this));\r\n  }\r\n\r\n  function convert() public returns (bool) {\r\n    uint256 senderBalance = Token1st(token1stContract()).getBalanceOf(msg.sender);\r\n    require(Token1st(token1stContract()).allowance(msg.sender, this) >= senderBalance);\r\n    Token1st(token1stContract()).transferDecimalAmountFrom(msg.sender, owner, senderBalance);\r\n    return Token(tokenContract()).transfer(msg.sender, senderBalance * 10000000000);\r\n  }\r\n\r\n}\r\n\r\ncontract Distribution is CanTransferTokens, SafeMath, useContractWeb {\r\n\r\n  uint256 public liveSince;\r\n  uint256 public withdrawn;\r\n\r\n  function withdrawnReadable() view public returns (uint256) {\r\n    return withdrawn / 1000000000000000000;\r\n  }\r\n\r\n  function secondsLive() view public returns (uint256) {\r\n    if(liveSince != 0) {\r\n      return now - liveSince;\r\n    }\r\n  }\r\n\r\n  function allowedSince() view public returns (uint256) {\r\n    return secondsLive() * 380265185769276972;\r\n  }\r\n\r\n  function allowedSinceReadable() view public returns (uint256) {\r\n    return secondsLive() * 380265185769276972 / 1000000000000000000;\r\n  }\r\n\r\n  function stillAllowed() view public returns (uint256) {\r\n    return allowedSince() - withdrawn;\r\n  }\r\n\r\n  function stillAllowedReadable() view public returns (uint256) {\r\n    uint256 _1 = allowedSince() - withdrawn;\r\n    return _1 / 1000000000000000000;\r\n  }\r\n\r\n  function tokenContract() view internal returns (address) {\r\n    return web.getContractAddress(\"Token\");\r\n  }\r\n\r\n  function makeLive() onlyOwner public returns (bool) {\r\n    require(liveSince == 0);\r\n    liveSince = now;\r\n    return true;\r\n  }\r\n\r\n  function deposit() onlyOwner public returns (bool) {\r\n    require(Token(tokenContract()).allowance(owner, this) > 0);\r\n    return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this));\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) {\r\n    require(stillAllowed() >= _value && _value > 0 && liveSince != 0);\r\n    withdrawn = add(withdrawn, _value);\r\n    return Token(tokenContract()).transfer(_to, _value);\r\n  }\r\n\r\n  function transferReadable(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) {\r\n    require(stillAllowed() >= _value * 1000000000000000000 && stillAllowed() != 0 && liveSince != 0);\r\n    withdrawn = add(withdrawn, _value * 1000000000000000000);\r\n    return Token(tokenContract()).transfer(_to, _value * 1000000000000000000);\r\n  }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferCustomToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_custom_fallback\",\"type\":\"string\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "Token", "CompilerVersion": "v0.4.18+commit.9cf6e910", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://4c7a2a9bedec622443db306b3c59d3b2147914f563a63ee32169da187750f957"}