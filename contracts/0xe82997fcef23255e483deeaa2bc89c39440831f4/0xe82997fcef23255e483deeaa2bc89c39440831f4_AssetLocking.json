{"SourceCode": "// File: contracts/interfaces/IERC721Receiver.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n// File: contracts/standards/ERC721Holder.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n// File: contracts/interfaces/IERC165.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n// File: contracts/standards/ERC165.sol\r\n\r\n\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n// File: contracts/interfaces/IERC1155Receiver.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\n\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n// File: contracts/standards/ERC1155Receiver.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n// File: contracts/standards/ERC1155Holder.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n// File: contracts/interfaces/IERC721.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n// File: contracts/interfaces/IERC1155.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\n\r\ninterface IERC1155 is IERC165 {\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    event URI(string value, uint256 indexed id);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n// File: contracts/utils/TokenAccessControl.sol\r\n\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\ncontract TokenAccessControl {\r\n    bool public paused = false;\r\n    address public owner;\r\n    address public newContractOwner;\r\n    mapping(address => bool) public authorizedContracts;\r\n\r\n    event Pause();\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier ifNotPaused() {\r\n        require(!paused, \"contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"caller is not an owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorizedUser() {\r\n        require(\r\n            authorizedContracts[msg.sender],\r\n            \"caller is not an authorized user\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrAuthorizedUser() {\r\n        require(\r\n            authorizedContracts[msg.sender] || msg.sender == owner,\r\n            \"caller is not an authorized user or an owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        newContractOwner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        newContractOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public ifNotPaused {\r\n        require(msg.sender == newContractOwner);\r\n        emit OwnershipTransferred(owner, newContractOwner);\r\n        owner = newContractOwner;\r\n        newContractOwner = address(0);\r\n    }\r\n\r\n    function setAuthorizedUser(\r\n        address _operator,\r\n        bool _approve\r\n    ) public onlyOwner {\r\n        if (_approve) {\r\n            authorizedContracts[_operator] = true;\r\n        } else {\r\n            delete authorizedContracts[_operator];\r\n        }\r\n    }\r\n\r\n    function setPause(bool _paused) public onlyOwner {\r\n        paused = _paused;\r\n        if (paused) {\r\n            emit Pause();\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/asset_locking.sol\r\n\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AssetLocking is TokenAccessControl, ERC1155Holder, ERC721Holder {\r\n\r\n    uint256 lockingPeriod = 86400;\r\n\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) private _lockedAssets;\r\n    mapping(address => uint256) private _lockedAssetsCount;\r\n    mapping(address => uint256) private _lockedUntil;\r\n    mapping(address => bool) private _isErc721;\r\n\r\n    bytes4 constant private IERC165_ID = 0x01ffc9a7;\r\n    bytes4 constant private IERC1155_ID = 0xd9b67a26;\r\n    bytes4 constant private IERC721_ID = 0x80ac58cd;\r\n\r\n    event LockAsset(address indexed owner, address contractAddress, uint256 tokenId);\r\n    event LockBatchAssets(address indexed owner, address contractAddress, uint256[] tokenIds, uint256[] amounts);\r\n    event RelockAsset(address indexed owner);\r\n    event UnlockAsset(address indexed owner, address contractAddress, uint256 tokenId);\r\n    event UnlockBatchAssets(address indexed owner, address contractAddress, uint256[] tokenIds, uint256[] amounts);\r\n\r\n\r\n    function setLockingPeriod(uint256 _lockingPeriod) onlyOwner external returns (bool) {\r\n        lockingPeriod = _lockingPeriod;\r\n        return true;\r\n    }\r\n\r\n    function lock(address contractAddress, uint256 tokenId) external returns (uint256) {\r\n        uint16 contractType = determineContractType(contractAddress);\r\n        if(contractType==1155){\r\n            IERC1155(contractAddress).safeTransferFrom(msg.sender, address(this), tokenId, 1, \"\");\r\n        }\r\n        else if(contractType==721){\r\n            IERC721(contractAddress).transferFrom(msg.sender, address(this), tokenId);\r\n            _isErc721[contractAddress] = true;\r\n        }\r\n        else{\r\n            revert(\"AssetLocking: Not valid NFT standard\");\r\n        }\r\n\r\n        _lockedAssets[msg.sender][contractAddress][tokenId]++;\r\n        _lockedAssetsCount[msg.sender]++;\r\n        _lockedUntil[msg.sender] = block.timestamp + lockingPeriod;\r\n\r\n        // return new timestamp the asset is locked until\r\n        emit LockAsset(msg.sender, contractAddress, tokenId);\r\n        return _lockedUntil[msg.sender];\r\n    }\r\n\r\n    function lockBatch(address contractAddress, uint256[] memory tokenIds, uint256[] memory amounts) external returns (uint256) {\r\n        uint16 contractType = determineContractType(contractAddress);\r\n        if(contractType==1155){\r\n            IERC1155(contractAddress).safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, \"\");\r\n        }\r\n        else{\r\n            revert(\"AssetLocking: Not valid NFT standard\");\r\n        }\r\n\r\n        for (uint256 j = 0; j < amounts.length ; j++) {\r\n            _lockedAssets[msg.sender][contractAddress][tokenIds[j]] += amounts[j];\r\n            _lockedAssetsCount[msg.sender] += amounts[j];\r\n        }\r\n        _lockedUntil[msg.sender] = block.timestamp + lockingPeriod;\r\n\r\n        // return new timestamp the asset is locked until\r\n        emit LockBatchAssets(msg.sender,contractAddress,tokenIds,amounts);\r\n        return _lockedUntil[msg.sender];\r\n    }\r\n\r\n    function relock() external returns (uint256) {\r\n        _lockedUntil[msg.sender] = block.timestamp + lockingPeriod;\r\n\r\n        // return new timestamp the asset is locked until\r\n        emit RelockAsset(msg.sender);\r\n        return _lockedUntil[msg.sender];\r\n    }\r\n\r\n    function unlock(address contractAddress, uint256 tokenId) external returns (uint256) {\r\n        require(_lockedAssets[msg.sender][contractAddress][tokenId] > 0, \"AssetLocking: Insufficient assets locked\");\r\n        require(_lockedUntil[msg.sender] < block.timestamp, \"AssetLocking: Assets are still locked\");\r\n\r\n        _lockedAssets[msg.sender][contractAddress][tokenId]--;\r\n        _lockedAssetsCount[msg.sender]--;\r\n\r\n        if (_isErc721[contractAddress]) {\r\n            IERC721(contractAddress).transferFrom(address(this), msg.sender, tokenId);\r\n        } else {\r\n            IERC1155(contractAddress).safeTransferFrom(address(this), msg.sender, tokenId, 1, \"\");\r\n        }\r\n\r\n        // return remaining locked count\r\n        emit UnlockAsset(msg.sender,contractAddress,tokenId);\r\n        return _lockedAssets[msg.sender][contractAddress][tokenId];\r\n    }\r\n\r\n    function unlockBatch(address contractAddress, uint256[] memory tokenIds, uint256[] memory amounts) external returns (uint256) {\r\n        require(tokenIds.length==amounts.length, \"AssetLocking: Length of tokenIds and amounts does not match\");\r\n        require(_lockedUntil[msg.sender] < block.timestamp, \"AssetLocking: Assets are still locked\");\r\n        require(_isErc721[contractAddress] == false, \"AssetLocking: Batch transfers are only supported for ERC1155\");\r\n\r\n        for (uint256 j = 0; j < amounts.length ; j++) {\r\n            require(_lockedAssets[msg.sender][contractAddress][tokenIds[j]] >= amounts[j], \"AssetLocking: Insufficient assets locked\");\r\n\r\n            _lockedAssets[msg.sender][contractAddress][tokenIds[j]] -= amounts[j];\r\n            _lockedAssetsCount[msg.sender] -= amounts[j];\r\n        }\r\n\r\n        IERC1155(contractAddress).safeBatchTransferFrom(address(this), msg.sender, tokenIds, amounts, \"\");\r\n\r\n        // return remaining locked total count\r\n        emit UnlockBatchAssets(msg.sender,contractAddress,tokenIds,amounts);\r\n        return _lockedAssetsCount[owner];\r\n    }\r\n\r\n    function checkCount(address owner, address contractAddress, uint256 tokenId) external view returns (uint256) {\r\n        return _lockedAssets[owner][contractAddress][tokenId];\r\n    }\r\n\r\n    function checkTotalCount(address owner) external view returns (uint256) {\r\n        return _lockedAssetsCount[owner];\r\n    }\r\n\r\n    function checkUntil(address owner) external view returns (uint256) {\r\n        return _lockedUntil[owner];\r\n    }\r\n\r\n    function determineContractType(address contractAddress) internal view returns(uint16){\r\n        (bool isSuccess, bytes memory response) = contractAddress.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\",IERC1155_ID));\r\n        if(isSuccess){\r\n            if(abi.decode(response, (bool))) return 1155;\r\n            (isSuccess,response) = contractAddress.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\",IERC721_ID));\r\n            if(isSuccess && abi.decode(response, (bool))) return 721;\r\n        }\r\n        (isSuccess,) = contractAddress.staticcall(abi.encodeWithSignature(\"balanceOf(address,uint256)\",msg.sender, 1));\r\n        if(isSuccess) return 1155;\r\n        (isSuccess,) = contractAddress.staticcall(abi.encodeWithSignature(\"balanceOf(address)\",msg.sender));\r\n        if(isSuccess){\r\n            (isSuccess,) = contractAddress.staticcall(abi.encodeWithSignature(\"decimals()\"));\r\n            if(isSuccess) return 20;\r\n            return 721;\r\n        }\r\n        return 0;\r\n    } \r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"LockAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"LockBatchAssets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"RelockAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"UnlockAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"UnlockBatchAssets\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"checkCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"checkTotalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"checkUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"lockBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newContractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approve\",\"type\":\"bool\"}],\"name\":\"setAuthorizedUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockingPeriod\",\"type\":\"uint256\"}],\"name\":\"setLockingPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"unlockBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AssetLocking", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f23e5fae990e22f6dc852b9dbe22a565b80ec49614d338eb81089a125c8daaeb"}