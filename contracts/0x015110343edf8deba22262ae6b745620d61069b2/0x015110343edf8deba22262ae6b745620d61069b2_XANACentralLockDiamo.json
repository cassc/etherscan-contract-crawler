{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\n/**\r\n * @title Contract ownership standard interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-173\r\n */\r\ninterface IERC173 {\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @notice get the ERC173 contract owner\r\n     * @return conract owner\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * @notice transfer contract ownership to new account\r\n     * @param account address of new owner\r\n     */\r\n    function transferOwnership(address account) external;\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/OwnableStorage.sol@v0.0.30\r\nlibrary OwnableStorage {\r\n    struct Layout {\r\n        address owner;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.Ownable');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n\r\n    function setOwner(Layout storage l, address owner) internal {\r\n        l.owner = owner;\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/OwnableInternal.sol@v0.0.30\r\nabstract contract OwnableInternal {\r\n    using OwnableStorage for OwnableStorage.Layout;\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == OwnableStorage.layout().owner,\r\n            'Ownable: sender must be owner'\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/Ownable.sol@v0.0.30\r\n/**\r\n * @title Ownership access control based on ERC173\r\n */\r\nabstract contract Ownable is IERC173, OwnableInternal {\r\n    using OwnableStorage for OwnableStorage.Layout;\r\n\r\n    /**\r\n     * @inheritdoc IERC173\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return OwnableStorage.layout().owner;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IERC173\r\n     */\r\n    function transferOwnership(address account) public virtual onlyOwner {\r\n        OwnableStorage.layout().setOwner(account);\r\n        emit OwnershipTransferred(msg.sender, account);\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/SafeOwnableStorage.sol@v0.0.30\r\nlibrary SafeOwnableStorage {\r\n    struct Layout {\r\n        address nomineeOwner;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.SafeOwnable');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n\r\n    function setNomineeOwner(Layout storage l, address nomineeOwner) internal {\r\n        l.nomineeOwner = nomineeOwner;\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/SafeOwnableInternal.sol@v0.0.30\r\nabstract contract SafeOwnableInternal {\r\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\r\n\r\n    modifier onlyNomineeOwner() {\r\n        require(\r\n            msg.sender == SafeOwnableStorage.layout().nomineeOwner,\r\n            'SafeOwnable: sender must be nominee owner'\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/SafeOwnable.sol@v0.0.30\r\n/**\r\n * @title Ownership access control based on ERC173 with ownership transfer safety check\r\n */\r\nabstract contract SafeOwnable is Ownable, SafeOwnableInternal {\r\n    using OwnableStorage for OwnableStorage.Layout;\r\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\r\n\r\n    function nomineeOwner() public view virtual returns (address) {\r\n        return SafeOwnableStorage.layout().nomineeOwner;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc Ownable\r\n     * @dev ownership transfer must be accepted by beneficiary before transfer is complete\r\n     */\r\n    function transferOwnership(address account)\r\n        public\r\n        virtual\r\n        override\r\n        onlyOwner\r\n    {\r\n        SafeOwnableStorage.layout().setNomineeOwner(account);\r\n    }\r\n\r\n    /**\r\n     * @notice accept transfer of contract ownership\r\n     */\r\n    function acceptOwnership() public virtual onlyNomineeOwner {\r\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\r\n        emit OwnershipTransferred(l.owner, msg.sender);\r\n        l.setOwner(msg.sender);\r\n        SafeOwnableStorage.layout().setNomineeOwner(address(0));\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/introspection/ERC165Storage.sol@v0.0.30\r\nlibrary ERC165Storage {\r\n    struct Layout {\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.ERC165');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n\r\n    function isSupportedInterface(Layout storage l, bytes4 interfaceId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return l.supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function setSupportedInterface(\r\n        Layout storage l,\r\n        bytes4 interfaceId,\r\n        bool status\r\n    ) internal {\r\n        require(interfaceId != 0xffffffff, 'ERC165: invalid interface id');\r\n        l.supportedInterfaces[interfaceId] = status;\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/introspection/IERC165.sol@v0.0.30\r\n/**\r\n * @title ERC165 interface registration interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-165\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice query whether contract has registered support for given interface\r\n     * @param interfaceId interface id\r\n     * @return bool whether interface is supported\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @solidstate/contracts/introspection/ERC165.sol@v0.0.30\r\n/**\r\n * @title ERC165 implementation\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    using ERC165Storage for ERC165Storage.Layout;\r\n\r\n    /**\r\n     * @inheritdoc IERC165\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\r\n        return ERC165Storage.layout().isSupportedInterface(interfaceId);\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/IDiamondCuttable.sol@v0.0.30\r\n/**\r\n * @title Diamond proxy upgrade interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\r\n */\r\ninterface IDiamondCuttable {\r\n    enum FacetCutAction {\r\n        ADD,\r\n        REPLACE,\r\n        REMOVE\r\n    }\r\n\r\n    event DiamondCut(FacetCut[] facetCuts, address target, bytes data);\r\n\r\n    struct FacetCut {\r\n        address target;\r\n        FacetCutAction action;\r\n        bytes4[] selectors;\r\n    }\r\n\r\n    /**\r\n     * @notice update diamond facets and optionally execute arbitrary initialization function\r\n     * @param facetCuts facet addresses, actions, and function selectors\r\n     * @param target initialization function target\r\n     * @param data initialization function call data\r\n     */\r\n    function diamondCut(\r\n        FacetCut[] calldata facetCuts,\r\n        address target,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File @solidstate/contracts/utils/UintUtils.sol@v0.0.30\r\n/**\r\n * @title utility functions for uint256 operations\r\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\r\n */\r\nlibrary UintUtils {\r\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return '0';\r\n        }\r\n\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n\r\n        bytes memory buffer = new bytes(digits);\r\n\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n\r\n        return string(buffer);\r\n    }\r\n\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return '0x00';\r\n        }\r\n\r\n        uint256 length = 0;\r\n\r\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\r\n            unchecked {\r\n                length++;\r\n            }\r\n        }\r\n\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    function toHexString(uint256 value, uint256 length)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = '0';\r\n        buffer[1] = 'x';\r\n\r\n        unchecked {\r\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\r\n                value >>= 4;\r\n            }\r\n        }\r\n\r\n        require(value == 0, 'UintUtils: hex length insufficient');\r\n\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/utils/AddressUtils.sol@v0.0.30\r\nlibrary AddressUtils {\r\n    using UintUtils for uint256;\r\n\r\n    function toString(address account) internal pure returns (string memory) {\r\n        return uint256(uint160(account)).toHexString(20);\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable account, uint256 amount) internal {\r\n        (bool success, ) = account.call{ value: amount }('');\r\n        require(success, 'AddressUtils: failed to send value');\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionCall(target, data, 'AddressUtils: failed low-level call');\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory error\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, error);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                'AddressUtils: failed low-level call with value'\r\n            );\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory error\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            'AddressUtils: insufficient balance for call'\r\n        );\r\n        return _functionCallWithValue(target, data, value, error);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory error\r\n    ) private returns (bytes memory) {\r\n        require(\r\n            isContract(target),\r\n            'AddressUtils: function call to non-contract'\r\n        );\r\n\r\n        (bool success, bytes memory returnData) = target.call{ value: value }(\r\n            data\r\n        );\r\n\r\n        if (success) {\r\n            return returnData;\r\n        } else if (returnData.length > 0) {\r\n            assembly {\r\n                let returnData_size := mload(returnData)\r\n                revert(add(32, returnData), returnData_size)\r\n            }\r\n        } else {\r\n            revert(error);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/DiamondBaseStorage.sol@v0.0.30\r\n/**\r\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\r\n */\r\nlibrary DiamondBaseStorage {\r\n    using AddressUtils for address;\r\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\r\n\r\n    struct Layout {\r\n        // function selector => (facet address, selector slot position)\r\n        mapping(bytes4 => bytes32) facets;\r\n        // total number of selectors registered\r\n        uint16 selectorCount;\r\n        // array of selector slots with 8 selectors per slot\r\n        mapping(uint256 => bytes32) selectorSlots;\r\n        address fallbackAddress;\r\n    }\r\n\r\n    bytes32 constant CLEAR_ADDRESS_MASK =\r\n        bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.DiamondBase');\r\n\r\n    event DiamondCut(\r\n        IDiamondCuttable.FacetCut[] facetCuts,\r\n        address target,\r\n        bytes data\r\n    );\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice update functions callable on Diamond proxy\r\n     * @param l storage layout\r\n     * @param facetCuts array of structured Diamond facet update data\r\n     * @param target optional recipient of initialization delegatecall\r\n     * @param data optional initialization call data\r\n     */\r\n    function diamondCut(\r\n        Layout storage l,\r\n        IDiamondCuttable.FacetCut[] memory facetCuts,\r\n        address target,\r\n        bytes memory data\r\n    ) internal {\r\n        unchecked {\r\n            uint256 originalSelectorCount = l.selectorCount;\r\n            uint256 selectorCount = originalSelectorCount;\r\n            bytes32 selectorSlot;\r\n\r\n            // Check if last selector slot is not full\r\n            if (selectorCount & 7 > 0) {\r\n                // get last selectorSlot\r\n                selectorSlot = l.selectorSlots[selectorCount >> 3];\r\n            }\r\n\r\n            for (uint256 i; i < facetCuts.length; i++) {\r\n                IDiamondCuttable.FacetCut memory facetCut = facetCuts[i];\r\n                IDiamondCuttable.FacetCutAction action = facetCut.action;\r\n\r\n                require(\r\n                    facetCut.selectors.length > 0,\r\n                    'DiamondBase: no selectors specified'\r\n                );\r\n\r\n                if (action == IDiamondCuttable.FacetCutAction.ADD) {\r\n                    (selectorCount, selectorSlot) = l.addFacetSelectors(\r\n                        selectorCount,\r\n                        selectorSlot,\r\n                        facetCut\r\n                    );\r\n                } else if (action == IDiamondCuttable.FacetCutAction.REPLACE) {\r\n                    l.replaceFacetSelectors(facetCut);\r\n                } else if (action == IDiamondCuttable.FacetCutAction.REMOVE) {\r\n                    (selectorCount, selectorSlot) = l.removeFacetSelectors(\r\n                        selectorCount,\r\n                        selectorSlot,\r\n                        facetCut\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (selectorCount != originalSelectorCount) {\r\n                l.selectorCount = uint16(selectorCount);\r\n            }\r\n\r\n            // If last selector slot is not full\r\n            if (selectorCount & 7 > 0) {\r\n                l.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n            }\r\n\r\n            emit DiamondCut(facetCuts, target, data);\r\n            initialize(target, data);\r\n        }\r\n    }\r\n\r\n    function addFacetSelectors(\r\n        Layout storage l,\r\n        uint256 selectorCount,\r\n        bytes32 selectorSlot,\r\n        IDiamondCuttable.FacetCut memory facetCut\r\n    ) internal returns (uint256, bytes32) {\r\n        unchecked {\r\n            require(\r\n                facetCut.target == address(this) ||\r\n                    facetCut.target.isContract(),\r\n                'DiamondBase: ADD target has no code'\r\n            );\r\n\r\n            for (uint256 i; i < facetCut.selectors.length; i++) {\r\n                bytes4 selector = facetCut.selectors[i];\r\n                bytes32 oldFacet = l.facets[selector];\r\n\r\n                require(\r\n                    address(bytes20(oldFacet)) == address(0),\r\n                    'DiamondBase: selector already added'\r\n                );\r\n\r\n                // add facet for selector\r\n                l.facets[selector] =\r\n                    bytes20(facetCut.target) |\r\n                    bytes32(selectorCount);\r\n                uint256 selectorInSlotPosition = (selectorCount & 7) << 5;\r\n\r\n                // clear selector position in slot and add selector\r\n                selectorSlot =\r\n                    (selectorSlot &\r\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\r\n                    (bytes32(selector) >> selectorInSlotPosition);\r\n\r\n                // if slot is full then write it to storage\r\n                if (selectorInSlotPosition == 224) {\r\n                    l.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n                    selectorSlot = 0;\r\n                }\r\n\r\n                selectorCount++;\r\n            }\r\n\r\n            return (selectorCount, selectorSlot);\r\n        }\r\n    }\r\n\r\n    function removeFacetSelectors(\r\n        Layout storage l,\r\n        uint256 selectorCount,\r\n        bytes32 selectorSlot,\r\n        IDiamondCuttable.FacetCut memory facetCut\r\n    ) internal returns (uint256, bytes32) {\r\n        unchecked {\r\n            require(\r\n                facetCut.target == address(0),\r\n                'DiamondBase: REMOVE target must be zero address'\r\n            );\r\n\r\n            uint256 selectorSlotCount = selectorCount >> 3;\r\n            uint256 selectorInSlotIndex = selectorCount & 7;\r\n\r\n            for (uint256 i; i < facetCut.selectors.length; i++) {\r\n                bytes4 selector = facetCut.selectors[i];\r\n                bytes32 oldFacet = l.facets[selector];\r\n\r\n                require(\r\n                    address(bytes20(oldFacet)) != address(0),\r\n                    'DiamondBase: selector not found'\r\n                );\r\n\r\n                require(\r\n                    address(bytes20(oldFacet)) != address(this),\r\n                    'DiamondBase: selector is immutable'\r\n                );\r\n\r\n                if (selectorSlot == 0) {\r\n                    selectorSlotCount--;\r\n                    selectorSlot = l.selectorSlots[selectorSlotCount];\r\n                    selectorInSlotIndex = 7;\r\n                } else {\r\n                    selectorInSlotIndex--;\r\n                }\r\n\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n\r\n                // adding a block here prevents stack too deep error\r\n                {\r\n                    // replace selector with last selector in l.facets\r\n                    lastSelector = bytes4(\r\n                        selectorSlot << (selectorInSlotIndex << 5)\r\n                    );\r\n\r\n                    if (lastSelector != selector) {\r\n                        // update last selector slot position info\r\n                        l.facets[lastSelector] =\r\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\r\n                            bytes20(l.facets[lastSelector]);\r\n                    }\r\n\r\n                    delete l.facets[selector];\r\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\r\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\r\n                }\r\n\r\n                if (oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = l.selectorSlots[\r\n                        oldSelectorsSlotCount\r\n                    ];\r\n\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    oldSelectorSlot =\r\n                        (oldSelectorSlot &\r\n                            ~(CLEAR_SELECTOR_MASK >>\r\n                                oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n\r\n                    // update storage with the modified slot\r\n                    l.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    selectorSlot =\r\n                        (selectorSlot &\r\n                            ~(CLEAR_SELECTOR_MASK >>\r\n                                oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete l.selectorSlots[selectorSlotCount];\r\n                    selectorSlot = 0;\r\n                }\r\n            }\r\n\r\n            selectorCount = (selectorSlotCount << 3) | selectorInSlotIndex;\r\n\r\n            return (selectorCount, selectorSlot);\r\n        }\r\n    }\r\n\r\n    function replaceFacetSelectors(\r\n        Layout storage l,\r\n        IDiamondCuttable.FacetCut memory facetCut\r\n    ) internal {\r\n        unchecked {\r\n            require(\r\n                facetCut.target.isContract(),\r\n                'DiamondBase: REPLACE target has no code'\r\n            );\r\n\r\n            for (uint256 i; i < facetCut.selectors.length; i++) {\r\n                bytes4 selector = facetCut.selectors[i];\r\n                bytes32 oldFacet = l.facets[selector];\r\n                address oldFacetAddress = address(bytes20(oldFacet));\r\n\r\n                require(\r\n                    oldFacetAddress != address(0),\r\n                    'DiamondBase: selector not found'\r\n                );\r\n\r\n                require(\r\n                    oldFacetAddress != address(this),\r\n                    'DiamondBase: selector is immutable'\r\n                );\r\n\r\n                require(\r\n                    oldFacetAddress != facetCut.target,\r\n                    'DiamondBase: REPLACE target is identical'\r\n                );\r\n\r\n                // replace old facet address\r\n                l.facets[selector] =\r\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\r\n                    bytes20(facetCut.target);\r\n            }\r\n        }\r\n    }\r\n\r\n    function initialize(address target, bytes memory data) private {\r\n        require(\r\n            (target == address(0)) == (data.length == 0),\r\n            'DiamondBase: invalid initialization parameters'\r\n        );\r\n\r\n        if (target != address(0)) {\r\n            if (target != address(this)) {\r\n                require(\r\n                    target.isContract(),\r\n                    'DiamondBase: initialization target has no code'\r\n                );\r\n            }\r\n\r\n            (bool success, ) = target.delegatecall(data);\r\n\r\n            if (!success) {\r\n                assembly {\r\n                    returndatacopy(0, 0, returndatasize())\r\n                    revert(0, returndatasize())\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/IDiamondLoupe.sol@v0.0.30\r\n/**\r\n * @title Diamond proxy introspection interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\r\n */\r\ninterface IDiamondLoupe {\r\n    struct Facet {\r\n        address target;\r\n        bytes4[] selectors;\r\n    }\r\n\r\n    /**\r\n     * @notice get all facets and their selectors\r\n     * @return diamondFacets array of structured facet data\r\n     */\r\n    function facets() external view returns (Facet[] memory diamondFacets);\r\n\r\n    /**\r\n     * @notice get all selectors for given facet address\r\n     * @param facet address of facet to query\r\n     * @return selectors array of function selectors\r\n     */\r\n    function facetFunctionSelectors(address facet)\r\n        external\r\n        view\r\n        returns (bytes4[] memory selectors);\r\n\r\n    /**\r\n     * @notice get addresses of all facets used by diamond\r\n     * @return addresses array of facet addresses\r\n     */\r\n    function facetAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory addresses);\r\n\r\n    /**\r\n     * @notice get the address of the facet associated with given selector\r\n     * @param selector function selector to query\r\n     * @return facet facet address (zero address if not found)\r\n     */\r\n    function facetAddress(bytes4 selector)\r\n        external\r\n        view\r\n        returns (address facet);\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/Proxy.sol@v0.0.30\r\n/**\r\n * @title Base proxy contract\r\n */\r\nabstract contract Proxy {\r\n    using AddressUtils for address;\r\n\r\n    /**\r\n     * @notice delegate all calls to implementation contract\r\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\r\n     * @dev memory location in use by assembly may be unsafe in other contexts\r\n     */\r\n    fallback() external payable virtual {\r\n        address implementation = _getImplementation();\r\n\r\n        require(\r\n            implementation.isContract(),\r\n            'Proxy: implementation must be contract'\r\n        );\r\n\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(\r\n                gas(),\r\n                implementation,\r\n                0,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice get logic implementation address\r\n     * @return implementation address\r\n     */\r\n    function _getImplementation() internal virtual returns (address);\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/DiamondBase.sol@v0.0.30\r\n/**\r\n * @title EIP-2535 \"Diamond\" proxy base contract\r\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\r\n */\r\nabstract contract DiamondBase is Proxy {\r\n    /**\r\n     * @inheritdoc Proxy\r\n     */\r\n    function _getImplementation() internal view override returns (address) {\r\n        // inline storage layout retrieval uses less gas\r\n        DiamondBaseStorage.Layout storage l;\r\n        bytes32 slot = DiamondBaseStorage.STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n\r\n        address implementation = address(bytes20(l.facets[msg.sig]));\r\n\r\n        if (implementation == address(0)) {\r\n            implementation = l.fallbackAddress;\r\n            require(\r\n                implementation != address(0),\r\n                'DiamondBase: no facet found for function signature'\r\n            );\r\n        }\r\n\r\n        return implementation;\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/DiamondCuttable.sol@v0.0.30\r\n/**\r\n * @title EIP-2535 \"Diamond\" proxy update contract\r\n */\r\nabstract contract DiamondCuttable is IDiamondCuttable, OwnableInternal {\r\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\r\n\r\n    /**\r\n     * @notice update functions callable on Diamond proxy\r\n     * @param facetCuts array of structured Diamond facet update data\r\n     * @param target optional recipient of initialization delegatecall\r\n     * @param data optional initialization call data\r\n     */\r\n    function diamondCut(\r\n        FacetCut[] calldata facetCuts,\r\n        address target,\r\n        bytes calldata data\r\n    ) external onlyOwner {\r\n        DiamondBaseStorage.layout().diamondCut(facetCuts, target, data);\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/DiamondLoupe.sol@v0.0.30\r\n/**\r\n * @title EIP-2535 \"Diamond\" proxy introspection contract\r\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\r\n */\r\nabstract contract DiamondLoupe is IDiamondLoupe {\r\n    /**\r\n     * @inheritdoc IDiamondLoupe\r\n     */\r\n    function facets() external view returns (Facet[] memory diamondFacets) {\r\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\r\n\r\n        diamondFacets = new Facet[](l.selectorCount);\r\n\r\n        uint8[] memory numFacetSelectors = new uint8[](l.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\r\n            bytes32 slot = l.selectorSlots[slotIndex];\r\n\r\n            for (\r\n                uint256 selectorSlotIndex;\r\n                selectorSlotIndex < 8;\r\n                selectorSlotIndex++\r\n            ) {\r\n                selectorIndex++;\r\n\r\n                if (selectorIndex > l.selectorCount) {\r\n                    break;\r\n                }\r\n\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facet = address(bytes20(l.facets[selector]));\r\n\r\n                bool continueLoop;\r\n\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (diamondFacets[facetIndex].target == facet) {\r\n                        diamondFacets[facetIndex].selectors[\r\n                            numFacetSelectors[facetIndex]\r\n                        ] = selector;\r\n                        // probably will never have more than 256 functions from one facet contract\r\n                        require(numFacetSelectors[facetIndex] < 255);\r\n                        numFacetSelectors[facetIndex]++;\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (continueLoop) {\r\n                    continue;\r\n                }\r\n\r\n                diamondFacets[numFacets].target = facet;\r\n                diamondFacets[numFacets].selectors = new bytes4[](\r\n                    l.selectorCount\r\n                );\r\n                diamondFacets[numFacets].selectors[0] = selector;\r\n                numFacetSelectors[numFacets] = 1;\r\n                numFacets++;\r\n            }\r\n        }\r\n\r\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n            uint256 numSelectors = numFacetSelectors[facetIndex];\r\n            bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\r\n\r\n            // setting the number of selectors\r\n            assembly {\r\n                mstore(selectors, numSelectors)\r\n            }\r\n        }\r\n\r\n        // setting the number of facets\r\n        assembly {\r\n            mstore(diamondFacets, numFacets)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IDiamondLoupe\r\n     */\r\n    function facetFunctionSelectors(address facet)\r\n        external\r\n        view\r\n        returns (bytes4[] memory selectors)\r\n    {\r\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\r\n\r\n        selectors = new bytes4[](l.selectorCount);\r\n\r\n        uint256 numSelectors;\r\n        uint256 selectorIndex;\r\n\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\r\n            bytes32 slot = l.selectorSlots[slotIndex];\r\n\r\n            for (\r\n                uint256 selectorSlotIndex;\r\n                selectorSlotIndex < 8;\r\n                selectorSlotIndex++\r\n            ) {\r\n                selectorIndex++;\r\n\r\n                if (selectorIndex > l.selectorCount) {\r\n                    break;\r\n                }\r\n\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n\r\n                if (facet == address(bytes20(l.facets[selector]))) {\r\n                    selectors[numSelectors] = selector;\r\n                    numSelectors++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // set the number of selectors in the array\r\n        assembly {\r\n            mstore(selectors, numSelectors)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IDiamondLoupe\r\n     */\r\n    function facetAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory addresses)\r\n    {\r\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\r\n\r\n        addresses = new address[](l.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n\r\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\r\n            bytes32 slot = l.selectorSlots[slotIndex];\r\n\r\n            for (\r\n                uint256 selectorSlotIndex;\r\n                selectorSlotIndex < 8;\r\n                selectorSlotIndex++\r\n            ) {\r\n                selectorIndex++;\r\n\r\n                if (selectorIndex > l.selectorCount) {\r\n                    break;\r\n                }\r\n\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facet = address(bytes20(l.facets[selector]));\r\n\r\n                bool continueLoop;\r\n\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facet == addresses[facetIndex]) {\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (continueLoop) {\r\n                    continue;\r\n                }\r\n\r\n                addresses[numFacets] = facet;\r\n                numFacets++;\r\n            }\r\n        }\r\n\r\n        // set the number of facet addresses in the array\r\n        assembly {\r\n            mstore(addresses, numFacets)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IDiamondLoupe\r\n     */\r\n    function facetAddress(bytes4 selector)\r\n        external\r\n        view\r\n        returns (address facet)\r\n    {\r\n        facet = address(bytes20(DiamondBaseStorage.layout().facets[selector]));\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/Diamond.sol@v0.0.30\r\n/**\r\n * @notice SolidState \"Diamond\" proxy reference implementation\r\n */\r\nabstract contract Diamond is\r\n    DiamondBase,\r\n    DiamondCuttable,\r\n    DiamondLoupe,\r\n    SafeOwnable,\r\n    ERC165\r\n{\r\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\r\n    using ERC165Storage for ERC165Storage.Layout;\r\n    using OwnableStorage for OwnableStorage.Layout;\r\n\r\n    constructor() {\r\n        ERC165Storage.Layout storage erc165 = ERC165Storage.layout();\r\n        bytes4[] memory selectors = new bytes4[](12);\r\n\r\n        // register DiamondCuttable\r\n\r\n        selectors[0] = IDiamondCuttable.diamondCut.selector;\r\n\r\n        erc165.setSupportedInterface(type(IDiamondCuttable).interfaceId, true);\r\n\r\n        // register DiamondLoupe\r\n\r\n        selectors[1] = IDiamondLoupe.facets.selector;\r\n        selectors[2] = IDiamondLoupe.facetFunctionSelectors.selector;\r\n        selectors[3] = IDiamondLoupe.facetAddresses.selector;\r\n        selectors[4] = IDiamondLoupe.facetAddress.selector;\r\n\r\n        erc165.setSupportedInterface(type(IDiamondLoupe).interfaceId, true);\r\n\r\n        // register ERC165\r\n\r\n        selectors[5] = IERC165.supportsInterface.selector;\r\n\r\n        erc165.setSupportedInterface(type(IERC165).interfaceId, true);\r\n\r\n        // register SafeOwnable\r\n\r\n        selectors[6] = Ownable.owner.selector;\r\n        selectors[7] = SafeOwnable.nomineeOwner.selector;\r\n        selectors[8] = SafeOwnable.transferOwnership.selector;\r\n        selectors[9] = SafeOwnable.acceptOwnership.selector;\r\n\r\n        erc165.setSupportedInterface(type(IERC173).interfaceId, true);\r\n\r\n        // register Diamond\r\n\r\n        selectors[10] = Diamond.getFallbackAddress.selector;\r\n        selectors[11] = Diamond.setFallbackAddress.selector;\r\n\r\n        // diamond cut\r\n\r\n        FacetCut[] memory facetCuts = new FacetCut[](1);\r\n\r\n        facetCuts[0] = FacetCut({\r\n            target: address(this),\r\n            action: IDiamondCuttable.FacetCutAction.ADD,\r\n            selectors: selectors\r\n        });\r\n\r\n        DiamondBaseStorage.layout().diamondCut(facetCuts, address(0), '');\r\n\r\n        // set owner\r\n\r\n        OwnableStorage.layout().setOwner(msg.sender);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @notice get the address of the fallback contract\r\n     * @return fallback address\r\n     */\r\n    function getFallbackAddress() external view returns (address) {\r\n        return DiamondBaseStorage.layout().fallbackAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice set the address of the fallback contract\r\n     * @param fallbackAddress fallback address\r\n     */\r\n    function setFallbackAddress(address fallbackAddress) external onlyOwner {\r\n        DiamondBaseStorage.layout().fallbackAddress = fallbackAddress;\r\n    }\r\n}\r\n\r\n\r\ncontract XANACentralLockDiamond is Diamond {}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCuttable.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCuttable.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCuttable.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCuttable.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"diamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondLoupe.Facet[]\",\"name\":\"diamondFacets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFallbackAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nomineeOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fallbackAddress\",\"type\":\"address\"}],\"name\":\"setFallbackAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "XANACentralLockDiamond", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x57e04239779e3a7197eebd825901eb86ddd829ca", "SwarmSource": "ipfs://317d3dcbd7997e60203f110d847f3020f52eedc93a9ba23dd1355c0a7b331d95"}