{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/deploy/Create3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IDeploy } from '../interfaces/IDeploy.sol';\\nimport { ContractAddress } from '../libs/ContractAddress.sol';\\nimport { CreateDeploy } from './CreateDeploy.sol';\\nimport { Create3Address } from './Create3Address.sol';\\n\\n/**\\n * @title Create3 contract\\n * @notice This contract can be used to deploy a contract with a deterministic address that depends only on\\n * the deployer address and deployment salt, not the contract bytecode and constructor parameters.\\n */\\ncontract Create3 is Create3Address, IDeploy {\\n    using ContractAddress for address;\\n\\n    /**\\n     * @notice Deploys a new contract using the `CREATE3` method.\\n     * @dev This function first deploys the CreateDeploy contract using\\n     * the `CREATE2` opcode and then utilizes the CreateDeploy to deploy the\\n     * new contract with the `CREATE` opcode.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param deploySalt A salt to influence the contract address\\n     * @return deployed The address of the deployed contract\\n     */\\n    function _create3(bytes memory bytecode, bytes32 deploySalt) internal returns (address deployed) {\\n        deployed = _create3Address(deploySalt);\\n\\n        if (bytecode.length == 0) revert EmptyBytecode();\\n        if (deployed.isContract()) revert AlreadyDeployed();\\n\\n        // Deploy using create2\\n        CreateDeploy create = new CreateDeploy{ salt: deploySalt }();\\n\\n        if (address(create) == address(0)) revert DeployFailed();\\n\\n        // Deploy using create\\n        create.deploy(bytecode);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/deploy/Create3Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport { CreateDeploy } from './CreateDeploy.sol';\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Create3Address contract\\n * @notice This contract can be used to predict the deterministic deployment address of a contract deployed with the `CREATE3` technique.\\n */\\ncontract Create3Address {\\n    /// @dev bytecode hash of the CreateDeploy helper contract\\n    bytes32 internal immutable createDeployBytecodeHash;\\n\\n    constructor() {\\n        createDeployBytecodeHash = keccak256(type(CreateDeploy).creationCode);\\n    }\\n\\n    /**\\n     * @notice Compute the deployed address that will result from the `CREATE3` method.\\n     * @param deploySalt A salt to influence the contract address\\n     * @return deployed The deterministic contract address if it was deployed\\n     */\\n    function _create3Address(bytes32 deploySalt) internal view returns (address deployed) {\\n        address deployer = address(\\n            uint160(uint256(keccak256(abi.encodePacked(hex'ff', address(this), deploySalt, createDeployBytecodeHash))))\\n        );\\n\\n        deployed = address(uint160(uint256(keccak256(abi.encodePacked(hex'd6_94', deployer, hex'01')))));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/deploy/Create3Deployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { Deployer } from './Deployer.sol';\\nimport { Create3 } from './Create3.sol';\\n\\n/**\\n * @title Create3Deployer Contract\\n * @notice This contract is responsible for deploying and initializing new contracts using the `CREATE3` method\\n * which computes the deployed contract address based on the deployer address and deployment salt.\\n */\\ncontract Create3Deployer is Create3, Deployer {\\n    function _deploy(bytes memory bytecode, bytes32 deploySalt) internal override returns (address) {\\n        return _create3(bytecode, deploySalt);\\n    }\\n\\n    function _deployedAddress(\\n        bytes memory, /* bytecode */\\n        bytes32 deploySalt\\n    ) internal view override returns (address) {\\n        return _create3Address(deploySalt);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/deploy/CreateDeploy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title CreateDeploy Contract\\n * @notice This contract deploys new contracts using the `CREATE` opcode and is used as part of\\n * the `CREATE3` deployment method.\\n */\\ncontract CreateDeploy {\\n    /**\\n     * @dev Deploys a new contract with the specified bytecode using the `CREATE` opcode.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     */\\n    // slither-disable-next-line locked-ether\\n    function deploy(bytes memory bytecode) external payable {\\n        assembly {\\n            if iszero(create(0, add(bytecode, 32), mload(bytecode))) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/deploy/Deployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IDeployer } from '../interfaces/IDeployer.sol';\\nimport { SafeNativeTransfer } from '../libs/SafeNativeTransfer.sol';\\n\\n/**\\n * @title Deployer Contract\\n * @notice This contract is responsible for deploying and initializing new contracts using\\n * a deployment method, such as `CREATE2` or `CREATE3`.\\n */\\nabstract contract Deployer is IDeployer {\\n    using SafeNativeTransfer for address;\\n\\n    /**\\n     * @notice Deploys a contract using a deployment method defined by derived contracts.\\n     * @dev The address where the contract will be deployed can be known in\\n     * advance via {deployedAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already by the same `msg.sender`.\\n     *\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param salt A salt to influence the contract address\\n     * @return deployedAddress_ The address of the deployed contract\\n     */\\n    // slither-disable-next-line locked-ether\\n    function deploy(bytes memory bytecode, bytes32 salt) external payable returns (address deployedAddress_) {\\n        bytes32 deploySalt = keccak256(abi.encode(msg.sender, salt));\\n        deployedAddress_ = _deployedAddress(bytecode, deploySalt);\\n\\n        if (msg.value > 0) {\\n            // slither-disable-next-line unused-return\\n            deployedAddress_.safeNativeTransfer(msg.value);\\n        }\\n\\n        deployedAddress_ = _deploy(bytecode, deploySalt);\\n\\n        emit Deployed(deployedAddress_, msg.sender, salt, keccak256(bytecode));\\n    }\\n\\n    /**\\n     * @notice Deploys a contract using a deployment method defined by derived contracts and initializes it.\\n     * @dev The address where the contract will be deployed can be known in advance\\n     * via {deployedAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already by the same `msg.sender`.\\n     * - `init` is used to initialize the deployed contract as an option to not have the\\n     *    constructor args affect the address derived by `CREATE2`.\\n     *\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param salt A salt to influence the contract address\\n     * @param init Init data used to initialize the deployed contract\\n     * @return deployedAddress_ The address of the deployed contract\\n     */\\n    // slither-disable-next-line locked-ether\\n    function deployAndInit(\\n        bytes memory bytecode,\\n        bytes32 salt,\\n        bytes calldata init\\n    ) external payable returns (address deployedAddress_) {\\n        bytes32 deploySalt = keccak256(abi.encode(msg.sender, salt));\\n        deployedAddress_ = _deployedAddress(bytecode, deploySalt);\\n\\n        if (msg.value > 0) {\\n            // slither-disable-next-line unused-return\\n            deployedAddress_.safeNativeTransfer(msg.value);\\n        }\\n\\n        deployedAddress_ = _deploy(bytecode, deploySalt);\\n\\n        emit Deployed(deployedAddress_, msg.sender, salt, keccak256(bytecode));\\n\\n        (bool success, ) = deployedAddress_.call(init);\\n        if (!success) revert DeployInitFailed();\\n    }\\n\\n    /**\\n     * @notice Returns the address where a contract will be stored if deployed via {deploy} or {deployAndInit} by `sender`.\\n     * @dev Any change in the `bytecode` (except for `CREATE3`), `sender`, or `salt` will result in a new deployed address.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param sender The address that will deploy the contract via the deployment method\\n     * @param salt The salt that will be used to influence the contract address\\n     * @return deployedAddress_ The address that the contract will be deployed to\\n     */\\n    function deployedAddress(\\n        bytes memory bytecode,\\n        address sender,\\n        bytes32 salt\\n    ) public view returns (address) {\\n        bytes32 deploySalt = keccak256(abi.encode(sender, salt));\\n        return _deployedAddress(bytecode, deploySalt);\\n    }\\n\\n    function _deploy(bytes memory bytecode, bytes32 deploySalt) internal virtual returns (address);\\n\\n    function _deployedAddress(bytes memory bytecode, bytes32 deploySalt) internal view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDeploy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IDeploy Interface\\n * @notice This interface defines the errors for a contract that is responsible for deploying new contracts.\\n */\\ninterface IDeploy {\\n    error EmptyBytecode();\\n    error AlreadyDeployed();\\n    error DeployFailed();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IDeploy } from './IDeploy.sol';\\n\\n/**\\n * @title IDeployer Interface\\n * @notice This interface defines the contract responsible for deploying and optionally initializing new contracts\\n *  via a specified deployment method.\\n */\\ninterface IDeployer is IDeploy {\\n    error DeployInitFailed();\\n\\n    event Deployed(address indexed deployedAddress, address indexed sender, bytes32 indexed salt, bytes32 bytecodeHash);\\n\\n    /**\\n     * @notice Deploys a contract using a deployment method defined by derived contracts.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param salt A salt to influence the contract address\\n     * @return deployedAddress_ The address of the deployed contract\\n     */\\n    function deploy(bytes memory bytecode, bytes32 salt) external payable returns (address deployedAddress_);\\n\\n    /**\\n     * @notice Deploys a contract using a deployment method defined by derived contracts and initializes it.\\n     * @param bytecode The bytecode of the contract to be deployed\\n     * @param salt A salt to influence the contract address\\n     * @param init Init data used to initialize the deployed contract\\n     * @return deployedAddress_ The address of the deployed contract\\n     */\\n    function deployAndInit(\\n        bytes memory bytecode,\\n        bytes32 salt,\\n        bytes calldata init\\n    ) external payable returns (address deployedAddress_);\\n\\n    /**\\n     * @notice Returns the address where a contract will be stored if deployed via {deploy} or {deployAndInit} by `sender`.\\n     * @param bytecode The bytecode of the contract\\n     * @param sender The address that will deploy the contract\\n     * @param salt The salt that will be used to influence the contract address\\n     * @return deployedAddress_ The address that the contract will be deployed to\\n     */\\n    function deployedAddress(\\n        bytes calldata bytecode,\\n        address sender,\\n        bytes32 salt\\n    ) external view returns (address deployedAddress_);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/ContractAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ContractAddress {\\n    function isContract(address contractAddress) internal view returns (bool) {\\n        bytes32 existingCodeHash = contractAddress.codehash;\\n\\n        // https://eips.ethereum.org/EIPS/eip-1052\\n        // keccak256('') == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\\n        return\\n            existingCodeHash != bytes32(0) &&\\n            existingCodeHash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/SafeNativeTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nerror NativeTransferFailed();\\n\\n/*\\n * @title SafeNativeTransfer\\n * @dev This library is used for performing safe native value transfers in Solidity by utilizing inline assembly.\\n */\\nlibrary SafeNativeTransfer {\\n    /*\\n     * @notice Perform a native transfer to a given address.\\n     * @param receiver The recipient address to which the amount will be sent.\\n     * @param amount The amount of native value to send.\\n     * @throws NativeTransferFailed error if transfer is not successful.\\n     */\\n    function safeNativeTransfer(address receiver, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            success := call(gas(), receiver, amount, 0, 0, 0, 0)\\n        }\\n\\n        if (!success) revert NativeTransferFailed();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"constantOptimizer\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyDeployed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeployFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeployInitFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyBytecode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployedAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"bytecodeHash\",\"type\":\"bytes32\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"init\",\"type\":\"bytes\"}],\"name\":\"deployAndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deployedAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Create3Deployer", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}