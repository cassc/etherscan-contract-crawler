{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@rmrk-team/evm-contracts/contracts/RMRK/emotable/IERC6381.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IERC6381 is IERC165 {\\n    event Emoted(\\n        address indexed emoter,\\n        address indexed collection,\\n        uint256 indexed tokenId,\\n        string emoji,\\n        bool on\\n    );\\n\\n    function emoteCountOf(\\n        address collection,\\n        uint256 tokenId,\\n        string memory emoji\\n    ) external view returns (uint256);\\n\\n    function bulkEmoteCountOf(\\n        address[] memory collections,\\n        uint256[] memory tokenIds,\\n        string[] memory emojis\\n    ) external view returns (uint256[] memory);\\n\\n    function hasEmoterUsedEmote(\\n        address emoter,\\n        address collection,\\n        uint256 tokenId,\\n        string memory emoji\\n    ) external view returns (bool);\\n\\n    function haveEmotersUsedEmotes(\\n        address[] memory emoters,\\n        address[] memory collections,\\n        uint256[] memory tokenIds,\\n        string[] memory emojis\\n    ) external view returns (bool[] memory);\\n\\n    function prepareMessageToPresignEmote(\\n        address collection,\\n        uint256 tokenId,\\n        string memory emoji,\\n        bool state,\\n        uint256 deadline\\n    ) external view returns (bytes32);\\n\\n    function bulkPrepareMessagesToPresignEmote(\\n        address[] memory collections,\\n        uint256[] memory tokenIds,\\n        string[] memory emojis,\\n        bool[] memory states,\\n        uint256[] memory deadlines\\n    ) external view returns (bytes32[] memory);\\n\\n    function emote(\\n        address collection,\\n        uint256 tokenId,\\n        string memory emoji,\\n        bool state\\n    ) external;\\n\\n    function bulkEmote(\\n        address[] memory collections,\\n        uint256[] memory tokenIds,\\n        string[] memory emojis,\\n        bool[] memory states\\n    ) external;\\n\\n    function presignedEmote(\\n        address emoter,\\n        address collection,\\n        uint256 tokenId,\\n        string memory emoji,\\n        bool state,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function bulkPresignedEmote(\\n        address[] memory emoters,\\n        address[] memory collections,\\n        uint256[] memory tokenIds,\\n        string[] memory emojis,\\n        bool[] memory states,\\n        uint256[] memory deadlines,\\n        uint8[] memory v,\\n        bytes32[] memory r,\\n        bytes32[] memory s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/EmoteRepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"@rmrk-team/evm-contracts/contracts/RMRK/emotable/IERC6381.sol\\\";\\n\\nerror BulkParametersOfUnequalLength();\\nerror ExpiredPresignedEmote();\\nerror InvalidSignature();\\n\\n/**\\n * @title EmoteRepository\\n * @author RMRK team\\n * @notice The user interface is available @ https://emotes.app/.\\n */\\ncontract EmoteRepository is IERC6381 {\\n    bytes32 public immutable DOMAIN_SEPARATOR =\\n        keccak256(\\n            abi.encode(\\n                \\\"ERC-6381: Public Non-Fungible Token Emote Repository\\\",\\n                \\\"1\\\",\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n\\n    // Used to avoid double emoting and control undoing\\n    // emoter address => collection => tokenId => emoji => state (1 for emoted, 0 for not)\\n    mapping(address => mapping(address => mapping(uint256 => mapping(string => uint256))))\\n        private _emotesUsedByEmoter; // Cheaper than using a bool\\n    // collection => tokenId => emoji => count\\n    mapping(address => mapping(uint256 => mapping(string => uint256)))\\n        private _emotesPerToken;\\n\\n    /**\\n     * @inheritdoc IERC6381\\n     */\\n    function emoteCountOf(\\n        address collection,\\n        uint256 tokenId,\\n        string memory emoji\\n    ) public view returns (uint256) {\\n        return _emotesPerToken[collection][tokenId][emoji];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC6381\\n     */\\n    function bulkEmoteCountOf(\\n        address[] memory collections,\\n        uint256[] memory tokenIds,\\n        string[] memory emojis\\n    ) public view returns (uint256[] memory) {\\n        if (\\n            collections.length != tokenIds.length ||\\n            collections.length != emojis.length\\n        ) {\\n            revert BulkParametersOfUnequalLength();\\n        }\\n\\n        uint256[] memory counts = new uint256[](collections.length);\\n        for (uint256 i; i < collections.length; ) {\\n            counts[i] = _emotesPerToken[collections[i]][tokenIds[i]][emojis[i]];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return counts;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC6381\\n     */\\n    function hasEmoterUsedEmote(\\n        address emoter,\\n        address collection,\\n        uint256 tokenId,\\n        string memory emoji\\n    ) public view returns (bool) {\\n        return _emotesUsedByEmoter[emoter][collection][tokenId][emoji] == 1;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC6381\\n     */\\n    function haveEmotersUsedEmotes(\\n        address[] memory emoters,\\n        address[] memory collections,\\n        uint256[] memory tokenIds,\\n        string[] memory emojis\\n    ) public view returns (bool[] memory) {\\n        if (\\n            emoters.length != collections.length ||\\n            emoters.length != tokenIds.length ||\\n            emoters.length != emojis.length\\n        ) {\\n            revert BulkParametersOfUnequalLength();\\n        }\\n\\n        bool[] memory states = new bool[](collections.length);\\n        for (uint256 i; i < collections.length; ) {\\n            states[i] =\\n                _emotesUsedByEmoter[emoters[i]][collections[i]][tokenIds[i]][\\n                    emojis[i]\\n                ] ==\\n                1;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return states;\\n    }\\n\\n    /**\\n     * @notice Used to emote or undo an emote on a token.\\n     * @dev Emits ***Emoted*** event.\\n     * @param collection Address of the collection containing the token being emoted\\n     * @param tokenId ID of the token being emoted\\n     * @param emoji Unicode identifier of the emoji\\n     * @param state Boolean value signifying whether to emote (`true`) or undo (`false`) emote\\n     */\\n    function emote(\\n        address collection,\\n        uint256 tokenId,\\n        string memory emoji,\\n        bool state\\n    ) public {\\n        bool currentVal = _emotesUsedByEmoter[msg.sender][collection][tokenId][\\n            emoji\\n        ] == 1;\\n        if (currentVal != state) {\\n            _beforeEmote(collection, tokenId, emoji, state);\\n            if (state) {\\n                _emotesPerToken[collection][tokenId][emoji] += 1;\\n            } else {\\n                _emotesPerToken[collection][tokenId][emoji] -= 1;\\n            }\\n            _emotesUsedByEmoter[msg.sender][collection][tokenId][emoji] = state\\n                ? 1\\n                : 0;\\n            emit Emoted(msg.sender, collection, tokenId, emoji, state);\\n            _afterEmote(collection, tokenId, emoji, state);\\n        }\\n    }\\n\\n    /**\\n     * @notice Used to emote or undo an emote on multiple tokens.\\n     * @dev Does nothing if attempting to set a pre-existent state.\\n     * @dev MUST emit the `Emoted` event is the state of the emote is changed.\\n     * @dev MUST revert if the lengths of the `collections`, `tokenIds`, `emojis` and `states` arrays are not equal.\\n     * @param collections An array of addresses of the collections containing the tokens being emoted at\\n     * @param tokenIds An array of IDs of the tokens being emoted\\n     * @param emojis An array of unicode identifiers of the emojis\\n     * @param states An array of boolean values signifying whether to emote (`true`) or undo (`false`) emote\\n     */\\n    function bulkEmote(\\n        address[] memory collections,\\n        uint256[] memory tokenIds,\\n        string[] memory emojis,\\n        bool[] memory states\\n    ) public {\\n        if (\\n            collections.length != tokenIds.length ||\\n            collections.length != emojis.length ||\\n            collections.length != states.length\\n        ) {\\n            revert BulkParametersOfUnequalLength();\\n        }\\n\\n        bool currentVal;\\n        for (uint256 i; i < collections.length; ) {\\n            currentVal =\\n                _emotesUsedByEmoter[msg.sender][collections[i]][tokenIds[i]][\\n                    emojis[i]\\n                ] ==\\n                1;\\n            if (currentVal != states[i]) {\\n                _beforeEmote(collections[i], tokenIds[i], emojis[i], states[i]);\\n                if (states[i]) {\\n                    _emotesPerToken[collections[i]][tokenIds[i]][\\n                        emojis[i]\\n                    ] += 1;\\n                } else {\\n                    _emotesPerToken[collections[i]][tokenIds[i]][\\n                        emojis[i]\\n                    ] -= 1;\\n                }\\n                _emotesUsedByEmoter[msg.sender][collections[i]][tokenIds[i]][\\n                    emojis[i]\\n                ] = states[i] ? 1 : 0;\\n                emit Emoted(\\n                    msg.sender,\\n                    collections[i],\\n                    tokenIds[i],\\n                    emojis[i],\\n                    states[i]\\n                );\\n                _afterEmote(collections[i], tokenIds[i], emojis[i], states[i]);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IERC6381\\n     */\\n    function prepareMessageToPresignEmote(\\n        address collection,\\n        uint256 tokenId,\\n        string memory emoji,\\n        bool state,\\n        uint256 deadline\\n    ) public view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    DOMAIN_SEPARATOR,\\n                    collection,\\n                    tokenId,\\n                    emoji,\\n                    state,\\n                    deadline\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IERC6381\\n     */\\n    function bulkPrepareMessagesToPresignEmote(\\n        address[] memory collections,\\n        uint256[] memory tokenIds,\\n        string[] memory emojis,\\n        bool[] memory states,\\n        uint256[] memory deadlines\\n    ) public view returns (bytes32[] memory) {\\n        if (\\n            collections.length != tokenIds.length ||\\n            collections.length != emojis.length ||\\n            collections.length != states.length ||\\n            collections.length != deadlines.length\\n        ) {\\n            revert BulkParametersOfUnequalLength();\\n        }\\n\\n        bytes32[] memory messages = new bytes32[](collections.length);\\n        for (uint256 i; i < collections.length; ) {\\n            messages[i] = keccak256(\\n                abi.encode(\\n                    DOMAIN_SEPARATOR,\\n                    collections[i],\\n                    tokenIds[i],\\n                    emojis[i],\\n                    states[i],\\n                    deadlines[i]\\n                )\\n            );\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return messages;\\n    }\\n\\n    /**\\n     * @notice Used to emote or undo an emote on someone else's behalf.\\n     * @dev Does nothing if attempting to set a pre-existent state.\\n     * @dev MUST emit the `Emoted` event is the state of the emote is changed.\\n     * @dev MUST revert if the lengths of the `collections`, `tokenIds`, `emojis` and `states` arrays are not equal.\\n     * @dev MUST revert if the `deadline` has passed.\\n     * @dev MUST revert if the recovered address is the zero address.\\n     * @param emoter The address that presigned the emote\\n     * @param collection The address of the collection smart contract containing the token being emoted at\\n     * @param tokenId IDs of the token being emoted\\n     * @param emoji Unicode identifier of the emoji\\n     * @param state Boolean value signifying whether to emote (`true`) or undo (`false`) emote\\n     * @param deadline UNIX timestamp of the deadline for the signature to be submitted\\n     * @param v `v` value of an ECDSA signature of the message obtained via `prepareMessageToPresignEmote`\\n     * @param r `r` value of an ECDSA signature of the message obtained via `prepareMessageToPresignEmote`\\n     * @param s `s` value of an ECDSA signature of the message obtained via `prepareMessageToPresignEmote`\\n     */\\n    function presignedEmote(\\n        address emoter,\\n        address collection,\\n        uint256 tokenId,\\n        string memory emoji,\\n        bool state,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public {\\n        if (block.timestamp > deadline) {\\n            revert ExpiredPresignedEmote();\\n        }\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(\\n                    abi.encode(\\n                        DOMAIN_SEPARATOR,\\n                        collection,\\n                        tokenId,\\n                        emoji,\\n                        state,\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        address signer = ecrecover(digest, v, r, s);\\n        if (signer != emoter) {\\n            revert InvalidSignature();\\n        }\\n\\n        bool currentVal = _emotesUsedByEmoter[signer][collection][tokenId][\\n            emoji\\n        ] == 1;\\n        if (currentVal != state) {\\n            _beforeEmote(collection, tokenId, emoji, state);\\n            if (state) {\\n                _emotesPerToken[collection][tokenId][emoji] += 1;\\n            } else {\\n                _emotesPerToken[collection][tokenId][emoji] -= 1;\\n            }\\n            _emotesUsedByEmoter[signer][collection][tokenId][emoji] = state\\n                ? 1\\n                : 0;\\n            emit Emoted(signer, collection, tokenId, emoji, state);\\n            _afterEmote(collection, tokenId, emoji, state);\\n        }\\n    }\\n\\n    /**\\n     * @notice Used to bulk emote or undo an emote on someone else's behalf.\\n     * @dev Does nothing if attempting to set a pre-existent state.\\n     * @dev MUST emit the `Emoted` event is the state of the emote is changed.\\n     * @dev MUST revert if the lengths of the `collections`, `tokenIds`, `emojis` and `states` arrays are not equal.\\n     * @dev MUST revert if the `deadline` has passed.\\n     * @dev MUST revert if the recovered address is the zero address.\\n     * @param emoters An array of addresses of the accounts that presigned the emotes\\n     * @param collections An array of addresses of the collections containing the tokens being emoted at\\n     * @param tokenIds An array of IDs of the tokens being emoted\\n     * @param emojis An array of unicode identifiers of the emojis\\n     * @param states An array of boolean values signifying whether to emote (`true`) or undo (`false`) emote\\n     * @param deadlines UNIX timestamp of the deadline for the signature to be submitted\\n     * @param v An array of `v` values of an ECDSA signatures of the messages obtained via `prepareMessageToPresignEmote`\\n     * @param r An array of `r` values of an ECDSA signatures of the messages obtained via `prepareMessageToPresignEmote`\\n     * @param s An array of `s` values of an ECDSA signatures of the messages obtained via `prepareMessageToPresignEmote`\\n     */\\n    function bulkPresignedEmote(\\n        address[] memory emoters,\\n        address[] memory collections,\\n        uint256[] memory tokenIds,\\n        string[] memory emojis,\\n        bool[] memory states,\\n        uint256[] memory deadlines,\\n        uint8[] memory v,\\n        bytes32[] memory r,\\n        bytes32[] memory s\\n    ) public {\\n        if (\\n            emoters.length != collections.length ||\\n            emoters.length != tokenIds.length ||\\n            emoters.length != emojis.length ||\\n            emoters.length != states.length ||\\n            emoters.length != deadlines.length ||\\n            emoters.length != v.length ||\\n            emoters.length != r.length ||\\n            emoters.length != s.length\\n        ) {\\n            revert BulkParametersOfUnequalLength();\\n        }\\n\\n        bytes32 digest;\\n        address signer;\\n        bool currentVal;\\n        for (uint256 i; i < collections.length; ) {\\n            if (block.timestamp > deadlines[i]) {\\n                revert ExpiredPresignedEmote();\\n            }\\n            digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                    keccak256(\\n                        abi.encode(\\n                            DOMAIN_SEPARATOR,\\n                            collections[i],\\n                            tokenIds[i],\\n                            emojis[i],\\n                            states[i],\\n                            deadlines[i]\\n                        )\\n                    )\\n                )\\n            );\\n            signer = ecrecover(digest, v[i], r[i], s[i]);\\n            if (signer != emoters[i]) {\\n                revert InvalidSignature();\\n            }\\n\\n            currentVal =\\n                _emotesUsedByEmoter[signer][collections[i]][tokenIds[i]][\\n                    emojis[i]\\n                ] ==\\n                1;\\n            if (currentVal != states[i]) {\\n                _beforeEmote(collections[i], tokenIds[i], emojis[i], states[i]);\\n                if (states[i]) {\\n                    _emotesPerToken[collections[i]][tokenIds[i]][\\n                        emojis[i]\\n                    ] += 1;\\n                } else {\\n                    _emotesPerToken[collections[i]][tokenIds[i]][\\n                        emojis[i]\\n                    ] -= 1;\\n                }\\n                _emotesUsedByEmoter[signer][collections[i]][tokenIds[i]][\\n                    emojis[i]\\n                ] = states[i] ? 1 : 0;\\n                emit Emoted(\\n                    signer,\\n                    collections[i],\\n                    tokenIds[i],\\n                    emojis[i],\\n                    states[i]\\n                );\\n                _afterEmote(collections[i], tokenIds[i], emojis[i], states[i]);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Hook that is called before emote is added or removed.\\n     * @param collection Address of the collection containing the token being emoted\\n     * @param tokenId ID of the token being emoted\\n     * @param emoji Unicode identifier of the emoji\\n     * @param state Boolean value signifying whether to emote (`true`) or undo (`false`) emote\\n     */\\n    function _beforeEmote(\\n        address collection,\\n        uint256 tokenId,\\n        string memory emoji,\\n        bool state\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after emote is added or removed.\\n     * @param collection Address of the collection smart contract containing the token being emoted\\n     * @param tokenId ID of the token being emoted\\n     * @param emoji Unicode identifier of the emoji\\n     * @param state Boolean value signifying whether to emote (`true`) or undo (`false`) emote\\n     */\\n    function _afterEmote(\\n        address collection,\\n        uint256 tokenId,\\n        string memory emoji,\\n        bool state\\n    ) internal virtual {}\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual returns (bool) {\\n        return\\n            interfaceId == type(IERC6381).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"BulkParametersOfUnequalLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpiredPresignedEmote\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"emoter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"emoji\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"Emoted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"emojis\",\"type\":\"string[]\"},{\"internalType\":\"bool[]\",\"name\":\"states\",\"type\":\"bool[]\"}],\"name\":\"bulkEmote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"emojis\",\"type\":\"string[]\"}],\"name\":\"bulkEmoteCountOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"emojis\",\"type\":\"string[]\"},{\"internalType\":\"bool[]\",\"name\":\"states\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"deadlines\",\"type\":\"uint256[]\"}],\"name\":\"bulkPrepareMessagesToPresignEmote\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"emoters\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"emojis\",\"type\":\"string[]\"},{\"internalType\":\"bool[]\",\"name\":\"states\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"deadlines\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"bulkPresignedEmote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"emoji\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"emote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"emoji\",\"type\":\"string\"}],\"name\":\"emoteCountOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"emoter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"emoji\",\"type\":\"string\"}],\"name\":\"hasEmoterUsedEmote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"emoters\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"emojis\",\"type\":\"string[]\"}],\"name\":\"haveEmotersUsedEmotes\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"emoji\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"prepareMessageToPresignEmote\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"emoter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"emoji\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"presignedEmote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EmoteRepository", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}