{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ERC20_BuySellTax.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function name() external view returns (string memory);\\n\\n    function getOwner() external view returns (address);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address _owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\\ncontract Ownable is Context {\\n    address public _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        authorizations[_owner] = true;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    mapping(address => bool) internal authorizations;\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\ninterface IUniswapV2Factory {\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n}\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\ninterface IUniswapV2Pair {\\n    function sync() external;\\n}\\n\\ncontract ERC20_BuySellTax is Ownable, IERC20 {\\n    IUniswapV2Router02 public router;\\n    IUniswapV2Pair private pairContract;\\n\\n    address public pair;\\n    address WETH;\\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\\n    address constant ZERO = 0x0000000000000000000000000000000000000000;\\n    address private outputAddress;\\n\\n    bool liquidityAdded;\\n    bool inSwap;\\n\\n    string public _name;\\n    string public _symbol;\\n\\n    uint256 private constant DENOMINATOR = 10000;\\n    uint256 public constant TOTAL_SUPPLY = 10_000_000 * 1e18;\\n    uint256 public maxTxAmount = 10_000 * 1e18;\\n    uint256 public maxWalletTokens = 10_000 * 1e18;\\n    uint256 public sellTax = 2000;\\n    uint256 public buyTax = 2000;\\n    uint256 public swapThreshold = 0;\\n\\n    mapping(address => uint256) _balances;\\n    mapping(address => mapping(address => uint256)) _allowances;\\n    mapping(address => bool) isExemptFromFees;\\n    mapping(address => bool) isExemptFromMaxTx;\\n\\n    event EditTax(uint8 Buy, uint8 Sell);\\n    event ClearStuck(uint256 amount);\\n    event ClearTokenAndEth(address tokenAddress, uint256 tokenAmount, uint256 ethAmount);\\n    event OutputAddressSet(address outputAddress);\\n    event MaxWalletTokensSet(uint256 maxWalletTokens);\\n    event SwapThresholdSet(uint256 amount);\\n\\n    error InsufficientBalance();\\n    error TransactionLimitExceeded();\\n    error TransferFailed();\\n    \\n    constructor(\\n        string memory _tokenName,\\n        string memory _tokenSymbol,\\n        address _outputAddress,\\n        address _router\\n    ) payable {\\n\\n        _name = _tokenName;\\n        _symbol = _tokenSymbol;\\n                        \\n        outputAddress = _outputAddress;\\n\\n        router = IUniswapV2Router02(_router);\\n        WETH = router.WETH();\\n        pair = IUniswapV2Factory(router.factory()).createPair(\\n            WETH,\\n            address(this)\\n        );\\n        pairContract = IUniswapV2Pair(pair);\\n        _allowances[address(this)][address(router)] = type(uint256).max;\\n\\n        //set exemptions\\n        isExemptFromFees[msg.sender] = true;\\n        isExemptFromFees[address(this)] = true;\\n        isExemptFromMaxTx[msg.sender] = true;\\n        isExemptFromMaxTx[pair] = true;\\n        isExemptFromMaxTx[outputAddress] = true;\\n        isExemptFromMaxTx[address(this)] = true;\\n\\n        //transfer 95% of TOTAL_SUPPLY to this contract for adding to liquidity pool\\n        _balances[address(this)] = (TOTAL_SUPPLY * 9500) / DENOMINATOR;\\n        emit Transfer(\\n            address(0),\\n            address(this),\\n            (TOTAL_SUPPLY * 9500) / DENOMINATOR\\n        );\\n\\n        //transfer 5% of TOTAL_SUPPLY to the deployer wallet\\n        _balances[msg.sender] = (TOTAL_SUPPLY * 500) / DENOMINATOR;\\n        emit Transfer(\\n            address(0),\\n            msg.sender,\\n            (TOTAL_SUPPLY * 500) / DENOMINATOR\\n        );\\n    }\\n\\n    modifier swapping() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    receive() external payable {}\\n\\n    //95% of TOTAL_SUPPLY to LP (will be contract balance at this point)\\n    function addLiquidity() external onlyOwner {\\n        _allowances[address(this)][address(router)] = type(uint256).max;\\n        emit Approval(address(this), address(router), type(uint256).max);\\n\\n        router.addLiquidityETH{value: address(this).balance}(\\n            address(this),\\n            balanceOf(address(this)),\\n            0,\\n            0,\\n            msg.sender,\\n            block.timestamp\\n        );\\n\\n        liquidityAdded = true;\\n    }\\n\\n    //=========================================\\n    // TRANSFER-RELATED LOGIC\\n    //=========================================\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, type(uint256).max);\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        return _transferFrom(msg.sender, recipient, amount);\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        if (_allowances[sender][msg.sender] != type(uint256).max && _allowances[sender][msg.sender] >= amount) {\\n            _allowances[sender][msg.sender] -= amount;\\n        }\\n        return _transferFrom(sender, recipient, amount);\\n    }\\n\\n    function _transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        if (inSwap) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n\\n        if (\\n            liquidityAdded &&\\n            !authorizations[sender] &&\\n            recipient != address(this) &&\\n            recipient != address(DEAD) &&\\n            recipient != pair &&\\n            recipient != outputAddress &&\\n            !isExemptFromMaxTx[recipient]\\n        ) {\\n            uint256 heldTokens = balanceOf(recipient);\\n\\n            if((heldTokens + amount) > maxWalletTokens) {\\n                revert TransactionLimitExceeded();\\n            }\\n        }\\n\\n        if (amount > maxTxAmount && !isExemptFromMaxTx[sender]) {\\n            revert TransactionLimitExceeded();\\n        }\\n\\n        if (_shouldSwapBack()) {\\n            _swapBack();\\n        }\\n\\n        if (_balances[sender] < amount) {\\n            revert InsufficientBalance();\\n        }\\n        _balances[sender] -= amount;\\n\\n        uint256 amountReceived = (isExemptFromFees[sender] ||\\n            isExemptFromFees[recipient])\\n            ? amount\\n            : _takeFee(sender, amount, recipient);\\n        _balances[recipient] += amountReceived;\\n\\n        emit Transfer(sender, recipient, amountReceived);\\n        return true;\\n    }\\n\\n    function _basicTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        if(_balances[sender] < amount) {\\n            revert InsufficientBalance();\\n        }\\n        _balances[sender] -= amount;\\n        _balances[recipient] += amount;\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function _takeFee(\\n        address sender,\\n        uint256 amount,\\n        address recipient\\n    ) internal returns (uint256) {\\n        uint256 thisTax = 0;\\n        if (recipient == pair) {\\n            thisTax = sellTax;\\n        } else if (sender == pair) {\\n            thisTax = buyTax;\\n        }\\n\\n        uint256 feeAmount = (amount * thisTax) / DENOMINATOR;\\n\\n        _balances[address(this)] += feeAmount;\\n        emit Transfer(sender, address(this), feeAmount);\\n\\n        return amount - feeAmount;\\n    }\\n\\n    function _shouldSwapBack() internal view returns (bool) {\\n        return\\n            msg.sender != pair &&\\n            liquidityAdded &&\\n            !inSwap &&\\n            _balances[address(this)] >= swapThreshold;\\n    }\\n\\n    function _swapBack() internal swapping {\\n        uint256 amountToSwap = balanceOf(address(this));\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = WETH;\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            outputAddress,\\n            block.timestamp\\n        );\\n    }\\n\\n    //=========================================\\n    // VIEW FUNCTIONS\\n    //=========================================\\n    function allowance(\\n        address holder,\\n        address spender\\n    ) external view override returns (uint256) {\\n        return _allowances[holder][spender];\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return TOTAL_SUPPLY;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        return uint8(18);\\n    }\\n\\n    function symbol() external view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function name() external view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function getOwner() external view override returns (address) {\\n        return owner();\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    //=========================================\\n    // SETTERS\\n    //=========================================\\n    function removeLimits() external onlyOwner {\\n        maxTxAmount = TOTAL_SUPPLY;\\n        maxWalletTokens = TOTAL_SUPPLY;\\n        emit MaxWalletTokensSet(maxWalletTokens);\\n    }  \\n\\n    function setMaxWalletAndTransactionTokens(\\n        uint256 _maxWalletTokens, \\n        uint256 _maxTxAmount\\n    ) external onlyOwner {\\n        require(_maxWalletTokens >= 1);\\n        require(_maxTxAmount >= 1);\\n        maxWalletTokens = _maxWalletTokens;\\n        maxTxAmount = _maxTxAmount;\\n        emit MaxWalletTokensSet(_maxWalletTokens);\\n    }\\n\\n    function setFees(\\n        uint256 _buyTax,\\n        uint256 _sellTax\\n    ) public onlyOwner {\\n        buyTax = _buyTax;\\n        sellTax = _sellTax;\\n    }\\n\\n    function setOutputAddress(address _outputAddress) external onlyOwner {\\n        outputAddress = _outputAddress;\\n        emit OutputAddressSet(outputAddress);\\n    }\\n\\n    function setSwapBackSettings(uint256 _amount) external onlyOwner {\\n        swapThreshold = _amount;\\n        emit SwapThresholdSet(swapThreshold);\\n    }\\n\\n    function manualUnclog(uint256 _percentageUnclog) external onlyOwner {\\n        uint256 amountToSwap = (balanceOf(address(this)) * _percentageUnclog) / DENOMINATOR;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = WETH;\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            outputAddress,\\n            block.timestamp\\n        );\\n    }\\n\\n    function clearTokenAndEth(\\n        address _tokenAddress\\n    ) external returns (bool success) {\\n        uint256 contractEthBalance = address(this).balance;\\n        uint256 contractTokenBalance = IERC20(_tokenAddress).balanceOf(\\n            address(this)\\n        );\\n\\n        bool tokenTransferSuccess = IERC20(_tokenAddress).transfer(\\n            outputAddress,\\n            contractTokenBalance\\n        );\\n\\n        (bool ethTransferSuccess, ) = payable(outputAddress).call{\\n            value: contractEthBalance\\n        }(\\\"\\\");\\n\\n        if(!tokenTransferSuccess || !ethTransferSuccess){\\n            revert TransferFailed();\\n        }\\n        emit ClearTokenAndEth(_tokenAddress, contractTokenBalance, contractEthBalance);\\n        return true;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_outputAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransactionLimitExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClearStuck\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"ClearTokenAndEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Buy\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Sell\",\"type\":\"uint8\"}],\"name\":\"EditTax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxWalletTokens\",\"type\":\"uint256\"}],\"name\":\"MaxWalletTokensSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outputAddress\",\"type\":\"address\"}],\"name\":\"OutputAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapThresholdSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TOTAL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"clearTokenAndEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentageUnclog\",\"type\":\"uint256\"}],\"name\":\"manualUnclog\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellTax\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxWalletTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletAndTransactionTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_outputAddress\",\"type\":\"address\"}],\"name\":\"setOutputAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ERC20_BuySellTax", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000031de8211ec0bdcb0d4382c730dc8e34bf16eaead0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000000000000000000000000000000000000000000e4b6162616220486f73706974616c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054b41424142000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}