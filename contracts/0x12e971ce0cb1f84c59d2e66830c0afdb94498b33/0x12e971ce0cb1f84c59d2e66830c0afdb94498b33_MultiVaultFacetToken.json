{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEverscale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n\\ninterface IEverscale {\\n    struct EverscaleAddress {\\n        int8 wid;\\n        uint256 addr;\\n    }\\n\\n    struct EverscaleEvent {\\n        uint64 eventTransactionLt;\\n        uint32 eventTimestamp;\\n        bytes eventData;\\n        int8 configurationWid;\\n        uint256 configurationAddress;\\n        int8 eventContractWid;\\n        uint256 eventContractAddress;\\n        address proxy;\\n        uint32 round;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/multivault/IMultiVaultFacetLiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n\\ninterface IMultiVaultFacetLiquidity {\\n    struct Liquidity {\\n        uint activation;\\n        uint supply;\\n        uint cash;\\n        uint interest;\\n    }\\n\\n    function mintLP(\\n        address token,\\n        uint amount,\\n        address recipient\\n    ) external;\\n\\n    function redeemLP(\\n        address token,\\n        uint amount,\\n        address recipient\\n    ) external;\\n\\n    function exchangeRateCurrent(\\n        address token\\n    ) external view returns(uint);\\n\\n    function getCash(\\n        address token\\n    ) external view returns(uint);\\n\\n    function getSupply(\\n        address token\\n    ) external view returns(uint);\\n\\n    function setTokenInterest(\\n        address token,\\n        uint interest\\n    ) external;\\n\\n    function setDefaultInterest(\\n        uint interest\\n    ) external;\\n\\n    function liquidity(\\n        address token\\n    ) external view returns (Liquidity memory);\\n\\n    function convertLPToUnderlying(\\n        address token,\\n        uint amount\\n    ) external view returns (uint);\\n\\n    function convertUnderlyingToLP(\\n        address token,\\n        uint amount\\n    ) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/multivault/IMultiVaultFacetPendingWithdrawals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"../IEverscale.sol\\\";\\nimport \\\"./IMultiVaultFacetWithdraw.sol\\\";\\n\\n\\ninterface IMultiVaultFacetPendingWithdrawals {\\n    enum ApproveStatus { NotRequired, Required, Approved, Rejected }\\n\\n    struct WithdrawalLimits {\\n        uint undeclared;\\n        uint daily;\\n        bool enabled;\\n    }\\n\\n    struct PendingWithdrawalParams {\\n        address token;\\n        uint256 amount;\\n        uint256 bounty;\\n        uint256 timestamp;\\n        ApproveStatus approveStatus;\\n\\n        uint256 chainId;\\n        IMultiVaultFacetWithdraw.Callback callback;\\n    }\\n\\n    struct PendingWithdrawalId {\\n        address recipient;\\n        uint256 id;\\n    }\\n\\n    struct WithdrawalPeriodParams {\\n        uint256 total;\\n        uint256 considered;\\n    }\\n\\n    function pendingWithdrawalsPerUser(address user) external view returns (uint);\\n    function pendingWithdrawalsTotal(address token) external view returns (uint);\\n\\n    function pendingWithdrawals(\\n        address user,\\n        uint256 id\\n    ) external view returns (PendingWithdrawalParams memory);\\n\\n    function setPendingWithdrawalBounty(\\n        uint256 id,\\n        uint256 bounty\\n    ) external;\\n\\n    function cancelPendingWithdrawal(\\n        uint256 id,\\n        uint256 amount,\\n        IEverscale.EverscaleAddress memory recipient,\\n        uint expected_evers,\\n        bytes memory payload,\\n        uint bounty\\n    ) external payable;\\n\\n    function setPendingWithdrawalApprove(\\n        PendingWithdrawalId memory pendingWithdrawalId,\\n        ApproveStatus approveStatus\\n    ) external;\\n\\n    function setPendingWithdrawalApprove(\\n        PendingWithdrawalId[] memory pendingWithdrawalId,\\n        ApproveStatus[] memory approveStatus\\n    ) external;\\n\\n    function forceWithdraw(\\n        PendingWithdrawalId[] memory pendingWithdrawalIds\\n    ) external;\\n\\n    function withdrawalLimits(\\n        address token\\n    ) external view returns(WithdrawalLimits memory);\\n\\n    function withdrawalPeriods(\\n        address token,\\n        uint256 withdrawalPeriodId\\n    ) external view returns (WithdrawalPeriodParams memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/multivault/IMultiVaultFacetTokenFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n// Not ingerited anyware\\n// MultiVaultFacetTokenFactory has different pragma solidity (0.8.0)\\n// Since it depends on not-upgredeable MultiVaultToken\\ninterface IMultiVaultFacetTokenFactory {\\n    function getLPToken(\\n        address token\\n    ) external view returns (address lp);\\n\\n    function getNativeToken(\\n        int8 wid,\\n        uint256 addr\\n    ) external view returns (address token);\\n\\n    function deployTokenForNative(\\n        int8 wid,\\n        uint256 addr,\\n        string calldata name,\\n        string calldata symbol,\\n        uint8 decimals\\n    ) external returns (address token);\\n\\n    function deployLPToken(\\n        address token\\n    ) external returns (address lp);\\n\\n    function mint(\\n        address token,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function burn(\\n        address token,\\n        address owner,\\n        uint256 amount\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/multivault/IMultiVaultFacetTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"./../IEverscale.sol\\\";\\n\\n\\ninterface IMultiVaultFacetTokens {\\n    enum TokenType { Native, Alien }\\n\\n    struct TokenPrefix {\\n        uint activation;\\n        string name;\\n        string symbol;\\n    }\\n\\n    struct TokenMeta {\\n        string name;\\n        string symbol;\\n        uint8 decimals;\\n    }\\n\\n    struct Token {\\n        uint activation;\\n        bool blacklisted;\\n        uint depositFee;\\n        uint withdrawFee;\\n        bool isNative;\\n        address custom; // deprecated\\n        uint256 depositLimit;\\n    }\\n\\n    function prefixes(address _token) external view returns (TokenPrefix memory);\\n    function tokens(address _token) external view returns (Token memory);\\n    function natives(address _token) external view returns (IEverscale.EverscaleAddress memory);\\n\\n    function setDepositLimit(\\n        address token,\\n        uint amount\\n    ) external;\\n\\n    function setTokenBlacklist(\\n        address token,\\n        bool blacklisted\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/multivault/IMultiVaultFacetTokensEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n\\ninterface IMultiVaultFacetTokensEvents {\\n    event UpdateTokenPrefix(address token, string name_prefix, string symbol_prefix);\\n    event UpdateTokenBlacklist(address token, bool status);\\n    event UpdateTokenDepositLimit(address token, uint limit);\\n\\n    event TokenActivated(\\n        address token,\\n        uint activation,\\n        bool isNative,\\n        uint depositFee,\\n        uint withdrawFee\\n    );\\n\\n    event TokenCreated(\\n        address token,\\n        int8 native_wid,\\n        uint256 native_addr,\\n        string name_prefix,\\n        string symbol_prefix,\\n        string name,\\n        string symbol,\\n        uint8 decimals\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/multivault/IMultiVaultFacetWithdraw.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"./IMultiVaultFacetTokens.sol\\\";\\nimport \\\"../IEverscale.sol\\\";\\n\\n\\ninterface IMultiVaultFacetWithdraw {\\n    struct Callback {\\n        address recipient;\\n        bytes payload;\\n        bool strict;\\n    }\\n\\n    struct NativeWithdrawalParams {\\n        IEverscale.EverscaleAddress native;\\n        IMultiVaultFacetTokens.TokenMeta meta;\\n        uint256 amount;\\n        address recipient;\\n        uint256 chainId;\\n        Callback callback;\\n    }\\n\\n    struct AlienWithdrawalParams {\\n        address token;\\n        uint256 amount;\\n        address recipient;\\n        uint256 chainId;\\n        Callback callback;\\n    }\\n\\n    function withdrawalIds(bytes32) external view returns (bool);\\n\\n    function saveWithdrawNative(\\n        bytes memory payload,\\n        bytes[] memory signatures\\n    ) external;\\n\\n    function saveWithdrawAlien(\\n        bytes memory payload,\\n        bytes[] memory signatures\\n    ) external;\\n\\n    function saveWithdrawAlien(\\n        bytes memory payload,\\n        bytes[] memory signatures,\\n        uint bounty\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/multivault/facets/MultiVaultFacetTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"../../interfaces/multivault/IMultiVaultFacetTokens.sol\\\";\\n\\n// import \\\"../MultiVaultToken.sol\\\";\\nimport \\\"../storage/MultiVaultStorage.sol\\\";\\n\\nimport \\\"../helpers/MultiVaultHelperActors.sol\\\";\\nimport \\\"../helpers/MultiVaultHelperTokens.sol\\\";\\n\\n\\ncontract MultiVaultFacetTokens is\\n    MultiVaultHelperActors,\\n    MultiVaultHelperTokens,\\n    IMultiVaultFacetTokens\\n{\\n    /// @notice Get token prefix\\n    /// @dev Used to set up in advance prefix for the ERC20 native token\\n    /// @param _token Token address\\n    /// @return Name and symbol prefix\\n    function prefixes(\\n        address _token\\n    ) external view override returns (IMultiVaultFacetTokens.TokenPrefix memory) {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        return s.prefixes_[_token];\\n    }\\n\\n    /// @notice Get token information\\n    /// @param _token Token address\\n    function tokens(\\n        address _token\\n    ) external view override returns (IMultiVaultFacetTokens.Token memory) {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        return s.tokens_[_token];\\n    }\\n\\n    /// @notice Get native Everscale token address for EVM token\\n    /// @param _token Token address\\n    function natives(\\n        address _token\\n    ) external view override returns (IEverscale.EverscaleAddress memory) {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        return s.natives_[_token];\\n    }\\n\\n    function setTokenBlacklist(\\n        address token,\\n        bool blacklisted\\n    ) external override onlyGovernance {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        s.tokens_[token].blacklisted = blacklisted;\\n\\n        emit UpdateTokenBlacklist(token, blacklisted);\\n    }\\n\\n    function setDepositLimit(\\n        address token,\\n        uint limit\\n    ) external override onlyGovernance {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        s.tokens_[token].depositLimit = limit;\\n\\n        emit UpdateTokenDepositLimit(token, limit);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/multivault/helpers/MultiVaultHelperActors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"../storage/MultiVaultStorage.sol\\\";\\n\\n\\nabstract contract MultiVaultHelperActors {\\n    modifier onlyPendingGovernance() {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        require(msg.sender == s.pendingGovernance, \\\"Actors: only pending governance\\\");\\n\\n        _;\\n    }\\n\\n    modifier onlyGovernance() {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        require(msg.sender == s.governance, \\\"Actors: only governance\\\");\\n\\n        _;\\n    }\\n\\n    modifier onlyGovernanceOrManagement() {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        require(msg.sender == s.governance || msg.sender == s.management, \\\"Actors: only governance or management\\\");\\n\\n        _;\\n    }\\n\\n    modifier onlyGovernanceOrWithdrawGuardian() {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        require(msg.sender == s.governance || msg.sender == s.withdrawGuardian, \\\"Actors: only governance or withdraw guardian\\\");\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/multivault/helpers/MultiVaultHelperEmergency.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"../storage/MultiVaultStorage.sol\\\";\\n\\n\\nabstract contract MultiVaultHelperEmergency {\\n    modifier onlyEmergencyDisabled() {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        require(!s.emergencyShutdown, \\\"Emergency: shutdown\\\");\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/multivault/helpers/MultiVaultHelperTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"../../interfaces/multivault/IMultiVaultFacetTokens.sol\\\";\\nimport \\\"../../interfaces/multivault/IMultiVaultFacetWithdraw.sol\\\";\\nimport \\\"../../interfaces/multivault/IMultiVaultFacetTokensEvents.sol\\\";\\nimport \\\"../../interfaces/multivault/IMultiVaultFacetTokenFactory.sol\\\";\\nimport \\\"../../interfaces/IEverscale.sol\\\";\\n\\nimport \\\"../storage/MultiVaultStorage.sol\\\";\\nimport \\\"./MultiVaultHelperEmergency.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n\\nabstract contract MultiVaultHelperTokens is\\n    MultiVaultHelperEmergency,\\n    IMultiVaultFacetTokensEvents\\n{\\n    modifier initializeToken(address _token) {\\n        _initializeToken(_token);\\n        _;\\n    }\\n\\n    modifier initializeWethToken() {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        _initializeToken(s.weth);\\n        _;\\n    }\\n\\n    function _initializeToken(address _token) internal {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n        if (s.tokens_[_token].activation == 0) {\\n            // Non-activated tokens are always aliens, native tokens are activate on the first `saveWithdrawNative`\\n\\n            require(\\n                IERC20Metadata(_token).decimals() <= MultiVaultStorage.DECIMALS_LIMIT &&\\n                bytes(IERC20Metadata(_token).symbol()).length <= MultiVaultStorage.SYMBOL_LENGTH_LIMIT &&\\n                bytes(IERC20Metadata(_token).name()).length <= MultiVaultStorage.NAME_LENGTH_LIMIT,\\n                \\\"Tokens: invalid token meta\\\"\\n            );\\n\\n            _activateToken(_token, false);\\n        }\\n    }\\n\\n    modifier tokenNotBlacklisted(address _token) {\\n        bool isBlackListed = isTokenNoBlackListed(_token);\\n        require(!isBlackListed, \\\"Tokens: token is blacklisted\\\");\\n\\n        _;\\n    }\\n    modifier wethNotBlacklisted() {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n        bool isBlackListed = isTokenNoBlackListed(s.weth);\\n        require(!isBlackListed, \\\"Tokens: weth is blacklisted\\\");\\n\\n        _;\\n    }\\n    function isTokenNoBlackListed(address _token) internal view returns (bool) {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n        return s.tokens_[_token].blacklisted;\\n    }\\n\\n    function _activateToken(\\n        address token,\\n        bool isNative\\n    ) internal {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        uint depositFee = isNative ? s.defaultNativeDepositFee : s.defaultAlienDepositFee;\\n        uint withdrawFee = isNative ? s.defaultNativeWithdrawFee : s.defaultAlienWithdrawFee;\\n\\n        s.tokens_[token] = IMultiVaultFacetTokens.Token({\\n            activation: block.number,\\n            blacklisted: false,\\n            isNative: isNative,\\n            depositFee: depositFee,\\n            withdrawFee: withdrawFee,\\n            custom: address(0),\\n            depositLimit: 0\\n        });\\n\\n        emit TokenActivated(\\n            token,\\n            block.number,\\n            isNative,\\n            depositFee,\\n            withdrawFee\\n        );\\n    }\\n\\n    function _getNativeWithdrawalToken(\\n        IMultiVaultFacetWithdraw.NativeWithdrawalParams memory withdrawal\\n    ) internal returns (address) {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        // Derive native token address from the Everscale (token wid, token addr)\\n        address token = IMultiVaultFacetTokenFactory(address(this)).getNativeToken(\\n            withdrawal.native.wid,\\n            withdrawal.native.addr\\n        );\\n\\n        // Token is being withdrawn first time - activate it (set default parameters)\\n        // And deploy ERC20 representation\\n        if (s.tokens_[token].activation == 0) {\\n            address deployedToken = IMultiVaultFacetTokenFactory(address(this)).deployTokenForNative(\\n                withdrawal.native.wid,\\n                withdrawal.native.addr,\\n                withdrawal.meta.name,\\n                withdrawal.meta.symbol,\\n                withdrawal.meta.decimals\\n            );\\n\\n            require(deployedToken == token, \\\"Tokens: invalid token\\\");\\n        \\n            emit TokenCreated(\\n                token,\\n                withdrawal.native.wid,\\n                withdrawal.native.addr,\\n                string(''),\\n                string(''),\\n                withdrawal.meta.name,\\n                withdrawal.meta.symbol,\\n                withdrawal.meta.decimals\\n            );\\n\\n            _activateToken(token, true);\\n\\n            s.natives_[token] = withdrawal.native;\\n        }\\n\\n        // Check if there is a custom ERC20 representing this withdrawal.native\\n        address custom = s.tokens_[token].custom;\\n\\n        if (custom != address(0)) return custom;\\n\\n        return token;\\n    }\\n\\n    function _limitsViolated(\\n        address token,\\n        uint amount\\n    ) internal view returns(bool) {\\n        MultiVaultStorage.Storage storage s = MultiVaultStorage._storage();\\n\\n        uint depositLimit = s.tokens_[token].depositLimit;\\n\\n        if (depositLimit == 0) return false;\\n\\n        uint balance = IERC20(token).balanceOf(address(this));\\n\\n        return (balance + amount) > depositLimit;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/multivault/storage/MultiVaultStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n\\nimport \\\"../../interfaces/IEverscale.sol\\\";\\nimport \\\"../../interfaces/multivault/IMultiVaultFacetTokens.sol\\\";\\nimport \\\"../../interfaces/multivault/IMultiVaultFacetPendingWithdrawals.sol\\\";\\nimport \\\"../../interfaces/multivault/IMultiVaultFacetLiquidity.sol\\\";\\n\\n\\nlibrary MultiVaultStorage {\\n    uint constant public MAX_BPS = 10_000;\\n    uint constant public FEE_LIMIT = MAX_BPS / 2;\\n\\n    uint8 constant public DECIMALS_LIMIT = 18;\\n    uint256 constant public SYMBOL_LENGTH_LIMIT = 32;\\n    uint256 constant public NAME_LENGTH_LIMIT = 32;\\n\\n    uint256 constant public WITHDRAW_PERIOD_DURATION_IN_SECONDS = 60 * 60 * 24; // 24 hours\\n\\n    // Previous version of the Vault contract was built with Upgradable Proxy Pattern, without using Diamond storage\\n    bytes32 constant public MULTIVAULT_LEGACY_STORAGE_POSITION = 0x0000000000000000000000000000000000000000000000000000000000000002;\\n\\n    uint constant LP_EXCHANGE_RATE_BPS = 10_000_000_000;\\n\\n    struct Storage {\\n        mapping (address => IMultiVaultFacetTokens.Token) tokens_;\\n        mapping (address => IEverscale.EverscaleAddress) natives_;\\n\\n        uint defaultNativeDepositFee;\\n        uint defaultNativeWithdrawFee;\\n        uint defaultAlienDepositFee;\\n        uint defaultAlienWithdrawFee;\\n\\n        bool emergencyShutdown;\\n\\n        address bridge;\\n        mapping(bytes32 => bool) withdrawalIds;\\n        IEverscale.EverscaleAddress rewards_; // deprecated\\n        IEverscale.EverscaleAddress configurationNative_;\\n        IEverscale.EverscaleAddress configurationAlien_;\\n\\n        address governance;\\n        address pendingGovernance;\\n        address guardian;\\n        address management;\\n\\n        mapping (address => IMultiVaultFacetTokens.TokenPrefix) prefixes_; // deprecated\\n        mapping (address => uint) fees;\\n\\n        // STORAGE UPDATE 1\\n        // Pending withdrawals\\n        // - Counter pending withdrawals per user\\n        mapping(address => uint) pendingWithdrawalsPerUser;\\n        // - Pending withdrawal details\\n        mapping(address => mapping(uint256 => IMultiVaultFacetPendingWithdrawals.PendingWithdrawalParams)) pendingWithdrawals_;\\n\\n        // - Total amount of pending withdrawals per token\\n        mapping(address => uint) pendingWithdrawalsTotal;\\n\\n        // STORAGE UPDATE 2\\n        // Withdrawal limits per token\\n        mapping(address => IMultiVaultFacetPendingWithdrawals.WithdrawalLimits) withdrawalLimits_;\\n\\n        // - Withdrawal periods. Each period is `WITHDRAW_PERIOD_DURATION_IN_SECONDS` seconds long.\\n        // If some period has reached the `withdrawalLimitPerPeriod` - all the future\\n        // withdrawals in this period require manual approve, see note on `setPendingWithdrawalsApprove`\\n        mapping(address => mapping(uint256 => IMultiVaultFacetPendingWithdrawals.WithdrawalPeriodParams)) withdrawalPeriods_;\\n\\n        address withdrawGuardian;\\n\\n        // STORAGE UPDATE 3\\n        mapping (address => IMultiVaultFacetLiquidity.Liquidity) liquidity;\\n        uint defaultInterest;\\n\\n        // STORAGE UPDATE 4\\n        // - Receives native value, attached to the deposit\\n        address gasDonor;\\n        address weth;\\n    }\\n\\n    function _storage() internal pure returns (Storage storage s) {\\n        assembly {\\n            s.slot := MULTIVAULT_LEGACY_STORAGE_POSITION\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"activation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isNative\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawFee\",\"type\":\"uint256\"}],\"name\":\"TokenActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int8\",\"name\":\"native_wid\",\"type\":\"int8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"native_addr\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name_prefix\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol_prefix\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"TokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdateTokenBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"UpdateTokenDepositLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name_prefix\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol_prefix\",\"type\":\"string\"}],\"name\":\"UpdateTokenPrefix\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"natives\",\"outputs\":[{\"components\":[{\"internalType\":\"int8\",\"name\":\"wid\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"addr\",\"type\":\"uint256\"}],\"internalType\":\"struct IEverscale.EverscaleAddress\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"prefixes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"activation\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"internalType\":\"struct IMultiVaultFacetTokens.TokenPrefix\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setDepositLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"blacklisted\",\"type\":\"bool\"}],\"name\":\"setTokenBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"activation\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"blacklisted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"depositFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isNative\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"custom\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositLimit\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiVaultFacetTokens.Token\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MultiVaultFacetTokens", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}