{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract Multicall {\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CollateralFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Collateral Filter API\\n * @author MetaStreet Labs\\n */\\nabstract contract CollateralFilter {\\n    /**\\n     * @notice Get collateral filter name\\n     * @return Collateral filter name\\n     */\\n    function COLLATERAL_FILTER_NAME() external view virtual returns (string memory);\\n\\n    /**\\n     * @notice Get collateral filter version\\n     * @return Collateral filter version\\n     */\\n    function COLLATERAL_FILTER_VERSION() external view virtual returns (string memory);\\n\\n    /**\\n     * @notice Get collateral token\\n     * @return Collateral token contract\\n     */\\n    function collateralToken() external view virtual returns (address);\\n\\n    /**\\n     * Query if collateral token is supported\\n     * @param token Collateral token contract\\n     * @param tokenId Collateral Token ID\\n     * @param index Collateral Token ID index\\n     * @param context ABI-encoded context\\n     * @return True if supported, otherwise false\\n     */\\n    function _collateralSupported(\\n        address token,\\n        uint256 tokenId,\\n        uint256 index,\\n        bytes calldata context\\n    ) internal view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/configurations/WeightedRateCollectionPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../Pool.sol\\\";\\nimport \\\"../rates/WeightedInterestRateModel.sol\\\";\\nimport \\\"../filters/CollectionCollateralFilter.sol\\\";\\n\\n/**\\n * @title Pool Configuration with a Weighted Interest Rate Model and Collection\\n * Collateral Filter\\n * @author MetaStreet Labs\\n */\\ncontract WeightedRateCollectionPool is Pool, WeightedInterestRateModel, CollectionCollateralFilter {\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initialized boolean\\n     */\\n    bool private _initialized;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Pool constructor\\n     * @param collateralLiquidator_ Collateral liquidator\\n     * @param delegationRegistry_ Delegation registry contract\\n     * @param collateralWrappers Collateral wrappers\\n     * @param parameters WeightedInterestRateModel parameters\\n     */\\n    constructor(\\n        address collateralLiquidator_,\\n        address delegationRegistry_,\\n        address[] memory collateralWrappers,\\n        WeightedInterestRateModel.Parameters memory parameters\\n    ) Pool(collateralLiquidator_, delegationRegistry_, collateralWrappers) WeightedInterestRateModel(parameters) {\\n        /* Disable initialization of implementation contract */\\n        _initialized = true;\\n    }\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initializer\\n     * @dev Fee-on-transfer currency tokens are not supported\\n     * @param params ABI-encoded parameters\\n     */\\n    function initialize(bytes memory params) external {\\n        require(!_initialized, \\\"Already initialized\\\");\\n\\n        _initialized = true;\\n\\n        /* Decode parameters */\\n        (address collateralToken_, address currencyToken_, uint64[] memory durations_, uint64[] memory rates_) = abi\\n            .decode(params, (address, address, uint64[], uint64[]));\\n\\n        /* Initialize Collateral Filter */\\n        CollectionCollateralFilter._initialize(collateralToken_);\\n\\n        /* Initialize Pool */\\n        Pool._initialize(currencyToken_, durations_, rates_);\\n    }\\n\\n    /**************************************************************************/\\n    /* Name */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc Pool\\n     */\\n    function IMPLEMENTATION_NAME() external pure override returns (string memory) {\\n        return \\\"WeightedRateCollectionPool\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/filters/CollectionCollateralFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"../CollateralFilter.sol\\\";\\n\\n/**\\n * @title Collection Collateral Filter\\n * @author MetaStreet Labs\\n */\\ncontract CollectionCollateralFilter is CollateralFilter {\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Supported token\\n     */\\n    address private _token;\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice CollectionCollateralFilter initializer\\n     */\\n    function _initialize(address token) internal {\\n        _token = token;\\n    }\\n\\n    /**************************************************************************/\\n    /* Implementation */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function COLLATERAL_FILTER_NAME() external pure override returns (string memory) {\\n        return \\\"CollectionCollateralFilter\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function COLLATERAL_FILTER_VERSION() external pure override returns (string memory) {\\n        return \\\"1.0\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function collateralToken() external view override returns (address) {\\n        return _token;\\n    }\\n\\n    /**\\n     * @inheritdoc CollateralFilter\\n     */\\n    function _collateralSupported(\\n        address token,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) internal view override returns (bool) {\\n        return token == _token;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/integrations/DelegateCash/IDelegationRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.19;\\n\\n/**\\n * @title An immutable registry contract to be deployed as a standalone primitive\\n * @dev See EIP-5639, new project launches can read previous cold wallet -> hot wallet delegations\\n * from here and integrate those permissions into their flow\\n */\\ninterface IDelegationRegistry {\\n    /// @notice Delegation type\\n    enum DelegationType {\\n        NONE,\\n        ALL,\\n        CONTRACT,\\n        TOKEN\\n    }\\n\\n    /// @notice Info about a single delegation, used for onchain enumeration\\n    struct DelegationInfo {\\n        DelegationType type_;\\n        address vault;\\n        address delegate;\\n        address contract_;\\n        uint256 tokenId;\\n    }\\n\\n    /// @notice Info about a single contract-level delegation\\n    struct ContractDelegation {\\n        address contract_;\\n        address delegate;\\n    }\\n\\n    /// @notice Info about a single token-level delegation\\n    struct TokenDelegation {\\n        address contract_;\\n        uint256 tokenId;\\n        address delegate;\\n    }\\n\\n    /// @notice Emitted when a user delegates their entire wallet\\n    event DelegateForAll(address vault, address delegate, bool value);\\n\\n    /// @notice Emitted when a user delegates a specific contract\\n    event DelegateForContract(address vault, address delegate, address contract_, bool value);\\n\\n    /// @notice Emitted when a user delegates a specific token\\n    event DelegateForToken(address vault, address delegate, address contract_, uint256 tokenId, bool value);\\n\\n    /// @notice Emitted when a user revokes all delegations\\n    event RevokeAllDelegates(address vault);\\n\\n    /// @notice Emitted when a user revoes all delegations for a given delegate\\n    event RevokeDelegate(address vault, address delegate);\\n\\n    /**\\n     * -----------  WRITE -----------\\n     */\\n\\n    /**\\n     * @notice Allow the delegate to act on your behalf for all contracts\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\n     */\\n    function delegateForAll(address delegate, bool value) external;\\n\\n    /**\\n     * @notice Allow the delegate to act on your behalf for a specific contract\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\n     */\\n    function delegateForContract(address delegate, address contract_, bool value) external;\\n\\n    /**\\n     * @notice Allow the delegate to act on your behalf for a specific token\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param tokenId The token id for the token you're delegating\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\n     */\\n    function delegateForToken(address delegate, address contract_, uint256 tokenId, bool value) external;\\n\\n    /**\\n     * @notice Revoke all delegates\\n     */\\n    function revokeAllDelegates() external;\\n\\n    /**\\n     * @notice Revoke a specific delegate for all their permissions\\n     * @param delegate The hotwallet to revoke\\n     */\\n    function revokeDelegate(address delegate) external;\\n\\n    /**\\n     * @notice Remove yourself as a delegate for a specific vault\\n     * @param vault The vault which delegated to the msg.sender, and should be removed\\n     */\\n    function revokeSelf(address vault) external;\\n\\n    /**\\n     * -----------  READ -----------\\n     */\\n\\n    /**\\n     * @notice Returns all active delegations a given delegate is able to claim on behalf of\\n     * @param delegate The delegate that you would like to retrieve delegations for\\n     * @return info Array of DelegationInfo structs\\n     */\\n    function getDelegationsByDelegate(address delegate) external view returns (DelegationInfo[] memory);\\n\\n    /**\\n     * @notice Returns an array of wallet-level delegates for a given vault\\n     * @param vault The cold wallet who issued the delegation\\n     * @return addresses Array of wallet-level delegates for a given vault\\n     */\\n    function getDelegatesForAll(address vault) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns an array of contract-level delegates for a given vault and contract\\n     * @param vault The cold wallet who issued the delegation\\n     * @param contract_ The address for the contract you're delegating\\n     * @return addresses Array of contract-level delegates for a given vault and contract\\n     */\\n    function getDelegatesForContract(address vault, address contract_) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns an array of contract-level delegates for a given vault's token\\n     * @param vault The cold wallet who issued the delegation\\n     * @param contract_ The address for the contract holding the token\\n     * @param tokenId The token id for the token you're delegating\\n     * @return addresses Array of contract-level delegates for a given vault's token\\n     */\\n    function getDelegatesForToken(\\n        address vault,\\n        address contract_,\\n        uint256 tokenId\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns all contract-level delegations for a given vault\\n     * @param vault The cold wallet who issued the delegations\\n     * @return delegations Array of ContractDelegation structs\\n     */\\n    function getContractLevelDelegations(address vault) external view returns (ContractDelegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns all token-level delegations for a given vault\\n     * @param vault The cold wallet who issued the delegations\\n     * @return delegations Array of TokenDelegation structs\\n     */\\n    function getTokenLevelDelegations(address vault) external view returns (TokenDelegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns true if the address is delegated to act on the entire vault\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param vault The cold wallet who issued the delegation\\n     */\\n    function checkDelegateForAll(address delegate, address vault) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the address is delegated to act on your behalf for a token contract or an entire vault\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param vault The cold wallet who issued the delegation\\n     */\\n    function checkDelegateForContract(address delegate, address vault, address contract_) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the address is delegated to act on your behalf for a specific token, the token's contract or an entire vault\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param tokenId The token id for the token you're delegating\\n     * @param vault The cold wallet who issued the delegation\\n     */\\n    function checkDelegateForToken(\\n        address delegate,\\n        address vault,\\n        address contract_,\\n        uint256 tokenId\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/InterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/ILiquidity.sol\\\";\\n\\n/**\\n * @title Interest Rate Model API\\n * @author MetaStreet Labs\\n */\\nabstract contract InterestRateModel {\\n    /**\\n     * @notice Get interest rate model name\\n     * @return Interest rate model name\\n     */\\n    function INTEREST_RATE_MODEL_NAME() external view virtual returns (string memory);\\n\\n    /**\\n     * @notice Get interest rate model version\\n     * @return Interest rate model version\\n     */\\n    function INTEREST_RATE_MODEL_VERSION() external view virtual returns (string memory);\\n\\n    /**\\n     * Get interest rate for liquidity\\n     * @param amount Liquidity amount\\n     * @param rates Rates\\n     * @param nodes Liquidity nodes\\n     * @param count Liquidity node count\\n     * @return Interest per second\\n     */\\n    function _rate(\\n        uint256 amount,\\n        uint64[] memory rates,\\n        ILiquidity.NodeSource[] memory nodes,\\n        uint16 count\\n    ) internal view virtual returns (uint256);\\n\\n    /**\\n     * Distribute interest to liquidity\\n     * @param amount Liquidity amount\\n     * @param interest Interest to distribute\\n     * @param nodes Liquidity nodes\\n     * @param count Liquidity node count\\n     * @return Interest distribution\\n     */\\n    function _distribute(\\n        uint256 amount,\\n        uint256 interest,\\n        ILiquidity.NodeSource[] memory nodes,\\n        uint16 count\\n    ) internal view virtual returns (uint128[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollateralLiquidationReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface to a Collateral Liquidation Receiver\\n */\\ninterface ICollateralLiquidationReceiver {\\n    /**\\n     * @notice Callback on collateral liquidated\\n     * @dev Pre-conditions: 1) proceeds were transferred, and 2) transferred amount >= proceeds\\n     * @param liquidationContext Liquidation context\\n     * @param proceeds Liquidation proceeds in currency tokens\\n     */\\n    function onCollateralLiquidated(bytes calldata liquidationContext, uint256 proceeds) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollateralLiquidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface to a Collateral Liquidator\\n */\\ninterface ICollateralLiquidator {\\n    /**\\n     * @notice Get collateral liquidator name\\n     * @return Collateral liquidator name\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice Liquidate collateral\\n     * @param currencyToken Currency token\\n     * @param collateralToken Collateral token, either underlying token or collateral wrapper\\n     * @param collateralTokenId Collateral token ID\\n     * @param collateralWrapperContext Collateral wrapper context\\n     * @param liquidationContext Liquidation callback context\\n     */\\n    function liquidate(\\n        address currencyToken,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        bytes calldata collateralWrapperContext,\\n        bytes calldata liquidationContext\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollateralWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface to a Collateral Wrapper\\n */\\ninterface ICollateralWrapper {\\n    /**************************************************************************/\\n    /* API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get collateral wrapper name\\n     * @return Collateral wrapper name\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice Enumerate wrapped collateral\\n     * @param tokenId Collateral wrapper token ID\\n     * @param context Implementation-specific context\\n     * @return token Token address\\n     * @return tokenIds List of token ids\\n     */\\n    function enumerate(\\n        uint256 tokenId,\\n        bytes calldata context\\n    ) external view returns (address token, uint256[] memory tokenIds);\\n\\n    /*\\n     * Unwrap collateral\\n     * @param tokenId Collateral wrapper token ID\\n     * @param context Implementation-specific context\\n     */\\n    function unwrap(uint256 tokenId, bytes calldata context) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface to Liquidity state\\n */\\ninterface ILiquidity {\\n    /**************************************************************************/\\n    /* Structures */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Node source\\n     * @param tick Tick\\n     * @param used Amount used\\n     */\\n    struct NodeSource {\\n        uint128 tick;\\n        uint128 used;\\n    }\\n\\n    /**\\n     * @notice Flattened liquidity node returned by getter\\n     * @param tick Tick\\n     * @param value Liquidity value\\n     * @param shares Liquidity shares outstanding\\n     * @param available Liquidity available\\n     * @param pending Liquidity pending (with interest)\\n     * @param redemptions Total pending redemptions\\n     * @param prev Previous liquidity node\\n     * @param next Next liquidity node\\n     */\\n    struct NodeInfo {\\n        uint128 tick;\\n        uint128 value;\\n        uint128 shares;\\n        uint128 available;\\n        uint128 pending;\\n        uint128 redemptions;\\n        uint128 prev;\\n        uint128 next;\\n    }\\n\\n    /**************************************************************************/\\n    /* API */\\n    /**************************************************************************/\\n\\n    /**\\n     * Get liquidity nodes spanning [startTick, endTick] range\\n     * @param startTick Start tick\\n     * @param endTick End tick\\n     * @return Liquidity nodes\\n     */\\n    function liquidityNodes(uint128 startTick, uint128 endTick) external view returns (NodeInfo[] memory);\\n\\n    /**\\n     * Get liquidity node at tick\\n     * @param tick Tick\\n     * @return Liquidity node\\n     */\\n    function liquidityNode(uint128 tick) external view returns (NodeInfo memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Interface to a Pool\\n */\\ninterface IPool {\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid caller\\n     */\\n    error InvalidCaller();\\n\\n    /**\\n     * @notice Insufficient shares\\n     */\\n    error InsufficientShares();\\n\\n    /**\\n     * @notice Invalid redemption status\\n     */\\n    error InvalidRedemptionStatus();\\n\\n    /**\\n     * @notice Invalid loan receipt\\n     */\\n    error InvalidLoanReceipt();\\n\\n    /**\\n     * @notice Invalid borrow options\\n     */\\n    error InvalidBorrowOptions();\\n\\n    /**\\n     * @notice Unsupported collateral\\n     * @param index Index of unsupported asset\\n     */\\n    error UnsupportedCollateral(uint256 index);\\n\\n    /**\\n     * @notice Unsupported loan duration\\n     */\\n    error UnsupportedLoanDuration();\\n\\n    /**\\n     * @notice Repayment too high\\n     */\\n    error RepaymentTooHigh();\\n\\n    /**\\n     * @notice Loan not expired\\n     */\\n    error LoanNotExpired();\\n\\n    /**************************************************************************/\\n    /* Events */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Emitted when currency is deposited\\n     * @param account Account\\n     * @param tick Tick\\n     * @param amount Amount of currency tokens\\n     * @param shares Amount of shares allocated\\n     */\\n    event Deposited(address indexed account, uint128 indexed tick, uint256 amount, uint256 shares);\\n\\n    /**\\n     * @notice Emitted when deposit shares are redeemed\\n     * @param account Account\\n     * @param tick Tick\\n     * @param shares Amount of shares to be redeemed\\n     */\\n    event Redeemed(address indexed account, uint128 indexed tick, uint256 shares);\\n\\n    /**\\n     * @notice Emitted when redeemed currency tokens are withdrawn\\n     * @param account Account\\n     * @param tick Tick\\n     * @param shares Amount of shares redeemed\\n     * @param amount Amount of currency tokens withdrawn\\n     */\\n    event Withdrawn(address indexed account, uint128 indexed tick, uint256 shares, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when a loan is originated\\n     * @param loanReceiptHash Loan receipt hash\\n     * @param loanReceipt Loan receipt\\n     */\\n    event LoanOriginated(bytes32 indexed loanReceiptHash, bytes loanReceipt);\\n\\n    /**\\n     * @notice Emitted when a loan is repaid\\n     * @param loanReceiptHash Loan receipt hash\\n     * @param repayment Repayment amount in currency tokens\\n     */\\n    event LoanRepaid(bytes32 indexed loanReceiptHash, uint256 repayment);\\n\\n    /**\\n     * @notice Emitted when a loan is liquidated\\n     * @param loanReceiptHash Loan receipt hash\\n     */\\n    event LoanLiquidated(bytes32 indexed loanReceiptHash);\\n\\n    /**\\n     * @notice Emitted when loan collateral is liquidated\\n     * @param loanReceiptHash Loan receipt hash\\n     * @param proceeds Total liquidation proceeds in currency tokens\\n     * @param borrowerProceeds Borrower's share of liquidation proceeds in\\n     * currency tokens\\n     */\\n    event CollateralLiquidated(bytes32 indexed loanReceiptHash, uint256 proceeds, uint256 borrowerProceeds);\\n\\n    /**\\n     * @notice Emitted when admin fee rate is updated\\n     * @param rate New admin fee rate in basis points\\n     */\\n    event AdminFeeRateUpdated(uint256 rate);\\n\\n    /**\\n     * @notice Emitted when admin fees are withdrawn\\n     * @param account Recipient account\\n     * @param amount Amount of currency tokens withdrawn\\n     */\\n    event AdminFeesWithdrawn(address indexed account, uint256 amount);\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get currency token\\n     * @return Currency token contract\\n     */\\n    function currencyToken() external view returns (address);\\n\\n    /**\\n     * @notice Get supported durations\\n     * @return List of loan durations in second\\n     */\\n    function durations() external view returns (uint64[] memory);\\n\\n    /**\\n     * @notice Get supported rates\\n     * @return List of rates in interest per second\\n     */\\n    function rates() external view returns (uint64[] memory);\\n\\n    /**\\n     * @notice Get admin\\n     * @return Admin\\n     */\\n    function admin() external view returns (address);\\n\\n    /**\\n     * @notice Get admin fee rate\\n     * @return Admin fee rate in basis points\\n     */\\n    function adminFeeRate() external view returns (uint32);\\n\\n    /**\\n     * @notice Get list of supported collateral wrappers\\n     * @return Collateral wrappers\\n     */\\n    function collateralWrappers() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Get collateral liquidator contract\\n     * @return Collateral liquidator contract\\n     */\\n    function collateralLiquidator() external view returns (address);\\n\\n    /**\\n     * @notice Get delegation registry contract\\n     * @return Delegation registry contract\\n     */\\n    function delegationRegistry() external view returns (address);\\n\\n    /**************************************************************************/\\n    /* Deposit API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Deposit amount at tick\\n     *\\n     * Emits a {Deposited} event.\\n     *\\n     * @param tick Tick\\n     * @param amount Amount of currency tokens\\n     * @param minShares Minimum amount of shares to receive\\n     * @return shares Amount of shares minted\\n     */\\n    function deposit(uint128 tick, uint256 amount, uint256 minShares) external returns (uint256 shares);\\n\\n    /**\\n     * @notice Redeem deposit shares for currency tokens. Currency tokens can\\n     * be withdrawn with the `withdraw()` method once the redemption is\\n     * processed.\\n     *\\n     * Emits a {Redeemed} event.\\n     *\\n     * @param tick Tick\\n     * @param shares Amount of deposit shares to redeem\\n     */\\n    function redeem(uint128 tick, uint256 shares) external;\\n\\n    /**\\n     * @notice Get redemption available\\n     *\\n     * @param account Account\\n     * @param tick Tick\\n     * @return shares Amount of deposit shares available for redemption\\n     * @return amount Amount of currency tokens available for withdrawal\\n     */\\n    function redemptionAvailable(address account, uint128 tick) external view returns (uint256 shares, uint256 amount);\\n\\n    /**\\n     * @notice Withdraw a redemption that is available\\n     *\\n     * Emits a {Withdrawn} event.\\n     *\\n     * @param tick Tick\\n     * @return shares Amount of deposit shares burned\\n     * @return amount Amount of currency tokens withdrawn\\n     */\\n    function withdraw(uint128 tick) external returns (uint256 shares, uint256 amount);\\n\\n    /**\\n     * @notice Rebalance a redemption that is available to a new tick\\n     *\\n     * Emits {Withdrawn} and {Deposited} events.\\n     *\\n     * @param srcTick Source tick\\n     * @param dstTick Destination Tick\\n     * @param minShares Minimum amount of destination shares to receive\\n     * @return oldShares Amount of source deposit shares burned\\n     * @return newShares Amount of destination deposit shares minted\\n     * @return amount Amount of currency tokens redeposited\\n     */\\n    function rebalance(\\n        uint128 srcTick,\\n        uint128 dstTick,\\n        uint256 minShares\\n    ) external returns (uint256 oldShares, uint256 newShares, uint256 amount);\\n\\n    /**************************************************************************/\\n    /* Lend API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Quote repayment for a loan\\n     * @param principal Principal amount in currency tokens\\n     * @param duration Duration in seconds\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenIds List of collateral token IDs\\n     * @param ticks Liquidity ticks\\n     * @param options Encoded options\\n     * @return Repayment amount in currency tokens\\n     */\\n    function quote(\\n        uint256 principal,\\n        uint64 duration,\\n        address collateralToken,\\n        uint256[] calldata collateralTokenIds,\\n        uint128[] calldata ticks,\\n        bytes calldata options\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Quote refinancing for a loan\\n     *\\n     * @param encodedLoanReceipt Encoded loan receipt\\n     * @param principal New principal amount in currency tokens\\n     * @param duration Duration in seconds\\n     * @param ticks Liquidity ticks\\n     * @return downpayment Downpayment in currency tokens (positive for downpayment, negative for credit)\\n     * @return repayment Repayment amount in currency tokens for new loan\\n     */\\n    function quoteRefinance(\\n        bytes calldata encodedLoanReceipt,\\n        uint256 principal,\\n        uint64 duration,\\n        uint128[] calldata ticks\\n    ) external view returns (int256 downpayment, uint256 repayment);\\n\\n    /**\\n     * @notice Originate a loan\\n     *\\n     * Emits a {LoanOriginated} event.\\n     *\\n     * @param principal Principal amount in currency tokens\\n     * @param duration Duration in seconds\\n     * @param collateralToken Collateral token address\\n     * @param collateralTokenId Collateral token ID\\n     * @param maxRepayment Maximum repayment amount in currency tokens\\n     * @param ticks Liquidity ticks\\n     * @param options Encoded options\\n     * @return Repayment amount in currency tokens\\n     */\\n    function borrow(\\n        uint256 principal,\\n        uint64 duration,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        uint256 maxRepayment,\\n        uint128[] calldata ticks,\\n        bytes calldata options\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Repay a loan\\n     *\\n     * Emits a {LoanRepaid} event.\\n     *\\n     * @param encodedLoanReceipt Encoded loan receipt\\n     * @return Repayment amount in currency tokens\\n     */\\n    function repay(bytes calldata encodedLoanReceipt) external returns (uint256);\\n\\n    /**\\n     * @notice Refinance a loan\\n     *\\n     * Emits a {LoanRepaid} event and a {LoanOriginated} event.\\n     *\\n     * @param encodedLoanReceipt Encoded loan receipt\\n     * @param principal Principal amount in currency tokens\\n     * @param duration Duration in seconds\\n     * @param maxRepayment Maximum repayment amount in currency tokens\\n     * @param ticks Liquidity ticks\\n     * @return Repayment amount in currency tokens\\n     */\\n    function refinance(\\n        bytes calldata encodedLoanReceipt,\\n        uint256 principal,\\n        uint64 duration,\\n        uint256 maxRepayment,\\n        uint128[] calldata ticks\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Liquidate an expired loan\\n     *\\n     * Emits a {LoanLiquidated} event.\\n     *\\n     * @param loanReceipt Loan receipt\\n     */\\n    function liquidate(bytes calldata loanReceipt) external;\\n}\\n\"\r\n    },\r\n    \"contracts/LiquidityManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"./interfaces/ILiquidity.sol\\\";\\nimport \\\"./Tick.sol\\\";\\n\\n/**\\n * @title LiquidityManager\\n * @author MetaStreet Labs\\n */\\nlibrary LiquidityManager {\\n    using SafeCast for uint256;\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Tick limit spacing basis points (10%)\\n     */\\n    uint256 internal constant TICK_LIMIT_SPACING_BASIS_POINTS = 1000;\\n\\n    /**\\n     * @notice Fixed point scale\\n     */\\n    uint256 internal constant FIXED_POINT_SCALE = 1e18;\\n\\n    /**\\n     * @notice Basis points scale\\n     */\\n    uint256 internal constant BASIS_POINTS_SCALE = 10_000;\\n\\n    /**\\n     * @notice Impaired price threshold (5%)\\n     */\\n    uint256 internal constant IMPAIRED_PRICE_THRESHOLD = 0.05 * 1e18;\\n\\n    /**\\n     * @notice Max redemption queue scan count\\n     */\\n    uint256 private constant MAX_REDEMPTION_QUEUE_SCAN_COUNT = 150;\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Insufficient liquidity\\n     */\\n    error InsufficientLiquidity();\\n\\n    /**\\n     * @notice Inactive liquidity\\n     */\\n    error InactiveLiquidity();\\n\\n    /**\\n     * @notice Insufficient tick spacing\\n     */\\n    error InsufficientTickSpacing();\\n\\n    /**************************************************************************/\\n    /* Structures */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Fulfilled redemption\\n     * @param shares Shares redeemed\\n     * @param amount Amount redeemed\\n     */\\n    struct FulfilledRedemption {\\n        uint128 shares;\\n        uint128 amount;\\n    }\\n\\n    /**\\n     * @notice Redemption state\\n     * @param pending Pending shares\\n     * @param index Current index\\n     * @param fulfilled Fulfilled redemptions\\n     */\\n    struct Redemptions {\\n        uint128 pending;\\n        uint128 index;\\n        mapping(uint128 => FulfilledRedemption) fulfilled;\\n    }\\n\\n    /**\\n     * @notice Liquidity node\\n     * @param value Liquidity value\\n     * @param shares Liquidity shares outstanding\\n     * @param available Liquidity available\\n     * @param pending Liquidity pending (with interest)\\n     * @param redemption Redemption state\\n     * @param prev Previous liquidity node\\n     * @param next Next liquidity node\\n     */\\n    struct Node {\\n        uint128 value;\\n        uint128 shares;\\n        uint128 available;\\n        uint128 pending;\\n        uint128 prev;\\n        uint128 next;\\n        Redemptions redemptions;\\n    }\\n\\n    /**\\n     * @notice Liquidity state\\n     * @param nodes Liquidity nodes\\n     */\\n    struct Liquidity {\\n        mapping(uint256 => Node) nodes;\\n    }\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * Get liquidity node at tick\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @return Liquidity node\\n     */\\n    function liquidityNode(\\n        Liquidity storage liquidity,\\n        uint128 tick\\n    ) internal view returns (ILiquidity.NodeInfo memory) {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        return\\n            ILiquidity.NodeInfo({\\n                tick: tick,\\n                value: node.value,\\n                shares: node.shares,\\n                available: node.available,\\n                pending: node.pending,\\n                redemptions: node.redemptions.pending,\\n                prev: node.prev,\\n                next: node.next\\n            });\\n    }\\n\\n    /**\\n     * Get liquidity nodes spanning [startTick, endTick] range where startTick\\n     * must be 0 or an instantiated tick\\n     * @param startTick Start tick\\n     * @param endTick End tick\\n     * @return Liquidity nodes\\n     */\\n    function liquidityNodes(\\n        Liquidity storage liquidity,\\n        uint128 startTick,\\n        uint128 endTick\\n    ) internal view returns (ILiquidity.NodeInfo[] memory) {\\n        /* Validate start tick has active liquidity */\\n        if (liquidity.nodes[startTick].next == 0) revert InactiveLiquidity();\\n\\n        /* Count nodes first to figure out how to size liquidity nodes array */\\n        uint256 i;\\n        uint128 t = startTick;\\n        while (t != type(uint128).max && t <= endTick) {\\n            t = liquidity.nodes[t].next;\\n            i++;\\n        }\\n\\n        ILiquidity.NodeInfo[] memory nodes = new ILiquidity.NodeInfo[](i);\\n\\n        /* Populate nodes */\\n        i = 0;\\n        t = startTick;\\n        while (t != type(uint128).max && t <= endTick) {\\n            nodes[i] = liquidityNode(liquidity, t);\\n            t = nodes[i].next;\\n            i++;\\n        }\\n\\n        return nodes;\\n    }\\n\\n    /**\\n     * @notice Get redemption available amount\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @param pending Redemption pending\\n     * @param index Redemption index\\n     * @param target Redemption target\\n     * @return redeemedShares Redeemed shares\\n     * @return redeemedAmount Redeemed amount\\n     * @return processedIndices Processed indices\\n     * @return processedShares Processed shares\\n     */\\n    function redemptionAvailable(\\n        Liquidity storage liquidity,\\n        uint128 tick,\\n        uint128 pending,\\n        uint128 index,\\n        uint128 target\\n    )\\n        internal\\n        view\\n        returns (uint128 redeemedShares, uint128 redeemedAmount, uint128 processedIndices, uint128 processedShares)\\n    {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        uint256 stopIndex = index + MAX_REDEMPTION_QUEUE_SCAN_COUNT;\\n\\n        for (; processedShares < target + pending && index < stopIndex; index++) {\\n            if (index == node.redemptions.index) {\\n                /* Reached pending unfulfilled redemption */\\n                break;\\n            }\\n\\n            /* Look up the next fulfilled redemption */\\n            FulfilledRedemption storage redemption = node.redemptions.fulfilled[index];\\n\\n            /* Update processed count */\\n            processedIndices += 1;\\n            processedShares += redemption.shares;\\n\\n            if (processedShares <= target) {\\n                /* Have not reached the redemption queue position yet */\\n                continue;\\n            } else {\\n                /* Compute number of shares to redeem in range of this\\n                 * redemption batch */\\n                uint128 shares = (((processedShares > target + pending) ? pending : (processedShares - target))) -\\n                    redeemedShares;\\n                /* Compute price of shares in this redemption batch */\\n                uint256 price = (redemption.amount * FIXED_POINT_SCALE) / redemption.shares;\\n\\n                /* Accumulate redeemed shares and corresponding amount */\\n                redeemedShares += shares;\\n                redeemedAmount += Math.mulDiv(shares, price, FIXED_POINT_SCALE).toUint128();\\n            }\\n        }\\n    }\\n\\n    /**************************************************************************/\\n    /* Internal Helpers */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev Check if tick is reserved\\n     * @param tick Tick\\n     * @return True if reserved, otherwise false\\n     */\\n    function _isReserved(uint128 tick) internal pure returns (bool) {\\n        return tick == 0 || tick == type(uint128).max;\\n    }\\n\\n    /**\\n     * @dev Check if liquidity node is empty\\n     * @param node Liquidity node\\n     * @return True if empty, otherwise false\\n     */\\n    function _isEmpty(Node storage node) internal view returns (bool) {\\n        return node.shares == 0 && node.pending == 0;\\n    }\\n\\n    /**\\n     * @dev Check if liquidity node is active\\n     * @param node Liquidity node\\n     * @return True if active, otherwise false\\n     */\\n    function _isActive(Node storage node) internal view returns (bool) {\\n        return node.prev != 0 || node.next != 0;\\n    }\\n\\n    /**\\n     * @dev Check if liquidity node is impaired\\n     * @param node Liquidity node\\n     * @return True if impaired, otherwise false\\n     */\\n    function _isImpaired(Node storage node) internal view returns (bool) {\\n        /* If there's shares, but insufficient value for a stable share price */\\n        return node.shares != 0 && node.value * FIXED_POINT_SCALE < node.shares * IMPAIRED_PRICE_THRESHOLD;\\n    }\\n\\n    /**\\n     * @notice Instantiate liquidity\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     */\\n    function _instantiate(Liquidity storage liquidity, Node storage node, uint128 tick) internal {\\n        /* If node is active, do nothing */\\n        if (_isActive(node)) return;\\n        /* If node is inactive and not empty, revert */\\n        if (!_isEmpty(node)) revert InactiveLiquidity();\\n\\n        /* Find prior node to new tick */\\n        uint128 prevTick;\\n        Node storage prevNode = liquidity.nodes[prevTick];\\n        while (prevNode.next < tick) {\\n            prevTick = prevNode.next;\\n            prevNode = liquidity.nodes[prevTick];\\n        }\\n\\n        /* Decode limits from previous tick, new tick, and next tick */\\n        (uint256 prevLimit, , , ) = Tick.decode(prevTick);\\n        (uint256 newLimit, , , ) = Tick.decode(tick);\\n        (uint256 nextLimit, , , ) = Tick.decode(prevNode.next);\\n\\n        /* Validate tick limit spacing */\\n        if (\\n            newLimit != prevLimit &&\\n            newLimit < (prevLimit * (BASIS_POINTS_SCALE + TICK_LIMIT_SPACING_BASIS_POINTS)) / BASIS_POINTS_SCALE\\n        ) revert InsufficientTickSpacing();\\n        if (\\n            newLimit != nextLimit &&\\n            nextLimit < (newLimit * (BASIS_POINTS_SCALE + TICK_LIMIT_SPACING_BASIS_POINTS)) / BASIS_POINTS_SCALE\\n        ) revert InsufficientTickSpacing();\\n\\n        /* Link new node */\\n        node.prev = prevTick;\\n        node.next = prevNode.next;\\n        liquidity.nodes[prevNode.next].prev = tick;\\n        prevNode.next = tick;\\n    }\\n\\n    /**\\n     * @dev Garbage collect an impaired or empty node, unlinking it from active\\n     * liquidity\\n     * @param liquidity Liquidity state\\n     * @param node Liquidity node\\n     */\\n    function _garbageCollect(Liquidity storage liquidity, Node storage node) internal {\\n        /* If node is not impaired and not empty, or already inactive, do nothing */\\n        if ((!_isImpaired(node) && !_isEmpty(node)) || !_isActive(node)) return;\\n\\n        /* Make node inactive by unlinking it */\\n        liquidity.nodes[node.prev].next = node.next;\\n        liquidity.nodes[node.next].prev = node.prev;\\n        node.next = 0;\\n        node.prev = 0;\\n    }\\n\\n    /**\\n     * @notice Process redemptions from available liquidity\\n     * @param liquidity Liquidity state\\n     * @param node Liquidity node\\n     */\\n    function _processRedemptions(Liquidity storage liquidity, Node storage node) internal {\\n        /* If there's no pending shares to redeem */\\n        if (node.redemptions.pending == 0) return;\\n\\n        /* Compute redemption price */\\n        uint256 price = (node.value * FIXED_POINT_SCALE) / node.shares;\\n\\n        if (price == 0) {\\n            /* If node has pending interest */\\n            if (node.pending != 0) return;\\n\\n            /* If node is insolvent, redeem all shares for zero amount */\\n            uint128 shares = node.redemptions.pending;\\n\\n            /* Record fulfilled redemption */\\n            node.redemptions.fulfilled[node.redemptions.index++] = FulfilledRedemption({shares: shares, amount: 0});\\n\\n            /* Update node state */\\n            node.shares -= shares;\\n            node.value = 0;\\n            node.available = 0;\\n            node.redemptions.pending = 0;\\n\\n            return;\\n        } else {\\n            /* Node is solvent */\\n\\n            /* If there's no cash to redeem from */\\n            if (node.available == 0) return;\\n\\n            /* Redeem as many shares as possible and pending from available cash */\\n            uint128 shares = uint128(Math.min((node.available * FIXED_POINT_SCALE) / price, node.redemptions.pending));\\n            uint128 amount = Math.mulDiv(shares, price, FIXED_POINT_SCALE).toUint128();\\n\\n            /* If there's insufficient cash to redeem non-zero pending shares\\n             * at current price */\\n            if (shares == 0) return;\\n\\n            /* Record fulfilled redemption */\\n            node.redemptions.fulfilled[node.redemptions.index++] = FulfilledRedemption({\\n                shares: shares,\\n                amount: amount\\n            });\\n\\n            /* Update node state */\\n            node.shares -= shares;\\n            node.value -= amount;\\n            node.available -= amount;\\n            node.redemptions.pending -= shares;\\n\\n            /* Garbage collect node if it is now empty */\\n            _garbageCollect(liquidity, node);\\n\\n            return;\\n        }\\n    }\\n\\n    /**************************************************************************/\\n    /* Primary API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Initialize liquidity state\\n     * @param liquidity Liquidity state\\n     */\\n    function initialize(Liquidity storage liquidity) internal {\\n        /* Liquidity state defaults to zero, but need to make head and tail nodes */\\n        liquidity.nodes[0].next = type(uint128).max;\\n        /* liquidity.nodes[type(uint128).max].prev = 0 by default */\\n    }\\n\\n    /**\\n     * @notice Deposit liquidity\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @param amount Amount\\n     * @return Number of shares\\n     */\\n    function deposit(Liquidity storage liquidity, uint128 tick, uint128 amount) internal returns (uint128) {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        /* If tick is reserved */\\n        if (_isReserved(tick)) revert InactiveLiquidity();\\n\\n        /* Instantiate node, if necessary */\\n        _instantiate(liquidity, node, tick);\\n\\n        /* Compute deposit price as current value + 50% of pending returns */\\n        uint256 price = node.shares == 0\\n            ? FIXED_POINT_SCALE\\n            : ((node.value + (node.available + node.pending - node.value) / 2) * FIXED_POINT_SCALE) / node.shares;\\n        uint128 shares = ((amount * FIXED_POINT_SCALE) / price).toUint128();\\n\\n        node.value += amount;\\n        node.shares += shares;\\n        node.available += amount;\\n\\n        /* Process any pending redemptions from available cash */\\n        _processRedemptions(liquidity, node);\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @notice Use liquidity from node\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @param used Used amount\\n     * @param pending Pending Amount\\n     */\\n    function use(Liquidity storage liquidity, uint128 tick, uint128 used, uint128 pending) internal {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        node.available -= used;\\n        node.pending += pending;\\n    }\\n\\n    /**\\n     * @notice Restore liquidity and process pending redemptions\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @param used Used amount\\n     * @param pending Pending amount\\n     * @param restored Restored amount\\n     */\\n    function restore(\\n        Liquidity storage liquidity,\\n        uint128 tick,\\n        uint128 used,\\n        uint128 pending,\\n        uint128 restored\\n    ) internal {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        node.value = node.value - used + restored;\\n        node.available += restored;\\n        node.pending -= pending;\\n\\n        /* Garbage collect node if it is now impaired */\\n        _garbageCollect(liquidity, node);\\n\\n        /* Process any pending redemptions */\\n        _processRedemptions(liquidity, node);\\n    }\\n\\n    /**\\n     * @notice Redeem liquidity\\n     * @param liquidity Liquidity state\\n     * @param tick Tick\\n     * @param shares Shares\\n     * @return Redemption index, Redemption target\\n     */\\n    function redeem(Liquidity storage liquidity, uint128 tick, uint128 shares) internal returns (uint128, uint128) {\\n        Node storage node = liquidity.nodes[tick];\\n\\n        /* Redemption from inactive liquidity nodes is allowed to facilitate\\n         * restoring garbage collected nodes */\\n\\n        /* Snapshot redemption target */\\n        uint128 redemptionIndex = node.redemptions.index;\\n        uint128 redemptionTarget = node.redemptions.pending;\\n\\n        /* Add shares to pending redemptions */\\n        node.redemptions.pending += shares;\\n\\n        /* Initialize redemption record to save gas in loan callbacks */\\n        if (node.redemptions.fulfilled[redemptionIndex].shares != type(uint128).max) {\\n            node.redemptions.fulfilled[redemptionIndex] = FulfilledRedemption({shares: type(uint128).max, amount: 0});\\n        }\\n\\n        /* Process any pending redemptions from available cash */\\n        _processRedemptions(liquidity, node);\\n\\n        return (redemptionIndex, redemptionTarget);\\n    }\\n\\n    /**\\n     * @notice Source liquidity from nodes\\n     * @param liquidity Liquidity state\\n     * @param amount Amount\\n     * @param ticks Ticks to source from\\n     * @param multiplier Multiplier for amount\\n     * @param durationIndex Duration index for amount\\n     * @return Sourced liquidity nodes, count of nodes\\n     */\\n    function source(\\n        Liquidity storage liquidity,\\n        uint256 amount,\\n        uint128[] calldata ticks,\\n        uint256 multiplier,\\n        uint256 durationIndex\\n    ) internal view returns (ILiquidity.NodeSource[] memory, uint16) {\\n        ILiquidity.NodeSource[] memory sources = new ILiquidity.NodeSource[](ticks.length);\\n\\n        uint256 prevTick;\\n        uint256 taken;\\n        uint256 count;\\n        for (; count < ticks.length && taken != amount; count++) {\\n            uint128 tick = ticks[count];\\n\\n            /* Validate tick and decode limit */\\n            uint256 limit = Tick.validate(tick, prevTick, durationIndex);\\n\\n            /* Look up liquidity node */\\n            Node storage node = liquidity.nodes[tick];\\n\\n            /* Consume as much as possible up to the tick limit, amount available, and amount remaining */\\n            uint128 take = uint128(Math.min(Math.min(limit * multiplier - taken, node.available), amount - taken));\\n\\n            /* Record the liquidity allocation in our sources list */\\n            sources[count] = ILiquidity.NodeSource({tick: tick, used: take});\\n\\n            taken += take;\\n            prevTick = tick;\\n        }\\n\\n        /* If unable to source required liquidity amount from provided ticks */\\n        if (taken < amount) revert InsufficientLiquidity();\\n\\n        return (sources, count.toUint16());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/LoanReceipt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/**\\n * @title LoanReceipt\\n * @author MetaStreet Labs\\n */\\nlibrary LoanReceipt {\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid receipt encoding\\n     */\\n    error InvalidReceiptEncoding();\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice LoanReceiptV1 version\\n     */\\n    uint8 internal constant LOAN_RECEIPT_V1_VERSION = 1;\\n\\n    /**\\n     * @notice LoanReceiptV1 header size in bytes\\n     * @dev Header excludes borrow options byte array\\n     */\\n    uint256 internal constant LOAN_RECEIPT_V1_HEADER_SIZE = 155;\\n\\n    /**\\n     * @notice LoanReceiptV1 node receipt size in bytes\\n     */\\n    uint256 internal constant LOAN_RECEIPT_V1_NODE_RECEIPT_SIZE = 48;\\n\\n    /**************************************************************************/\\n    /* Structures */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice LoanReceiptV1\\n     * @param version Version (1)\\n     * @param principal Principal amount in currency tokens\\n     * @param repayment Repayment amount in currency tokens\\n     * @param borrower Borrower\\n     * @param maturity Loan maturity timestamp\\n     * @param duration Loan duration\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param collateralWrapperContextLen Collateral wrapper context length\\n     * @param collateralWrapperContext Collateral wrapper context data\\n     * @param nodeReceipts Node receipts\\n     */\\n    struct LoanReceiptV1 {\\n        uint8 version;\\n        uint256 principal;\\n        uint256 repayment;\\n        address borrower;\\n        uint64 maturity;\\n        uint64 duration;\\n        address collateralToken;\\n        uint256 collateralTokenId;\\n        uint16 collateralWrapperContextLen;\\n        bytes collateralWrapperContext;\\n        NodeReceipt[] nodeReceipts;\\n    }\\n\\n    /**\\n     * @notice Node receipt\\n     * @param tick Tick\\n     * @param used Used amount\\n     * @param pending Pending amount\\n     */\\n    struct NodeReceipt {\\n        uint128 tick;\\n        uint128 used;\\n        uint128 pending;\\n    }\\n\\n    /**************************************************************************/\\n    /* Tightly packed format */\\n    /**************************************************************************/\\n\\n    /*\\n      Header (155 bytes)\\n          1   uint8   version                        0:1\\n          32  uint256 principal                      1:33\\n          32  uint256 repayment                      33:65\\n          20  address borrower                       65:85\\n          8   uint64  maturity                       85:93\\n          8   uint64  duration                       93:101\\n          20  address collateralToken                101:121\\n          32  uint256 collateralTokenId              121:153\\n          2   uint16  collateralWrapperContextLen    153:155\\n\\n      Collateral Wrapper Context Data (M bytes)      155:---\\n\\n      Node Receipts (48 * N bytes)\\n          N   NodeReceipts[] nodeReceipts\\n              16  uint128 tick\\n              16  uint128 used\\n              16  uint128 pending\\n    */\\n\\n    /**************************************************************************/\\n    /* API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev Compute loan receipt hash\\n     * @param encodedReceipt Encoded loan receipt\\n     * @return Loan Receipt hash\\n     */\\n    function hash(bytes memory encodedReceipt) internal view returns (bytes32) {\\n        /* Take hash of chain ID (32 bytes) concatenated with encoded loan receipt */\\n        return keccak256(abi.encodePacked(block.chainid, encodedReceipt));\\n    }\\n\\n    /**\\n     * @dev Encode a loan receipt into bytes\\n     * @param receipt Loan Receipt\\n     * @return Encoded loan receipt\\n     */\\n    function encode(LoanReceiptV1 memory receipt) internal pure returns (bytes memory) {\\n        /* Encode header */\\n        bytes memory header = abi.encodePacked(\\n            receipt.version,\\n            receipt.principal,\\n            receipt.repayment,\\n            receipt.borrower,\\n            receipt.maturity,\\n            receipt.duration,\\n            receipt.collateralToken,\\n            receipt.collateralTokenId,\\n            receipt.collateralWrapperContextLen,\\n            receipt.collateralWrapperContext\\n        );\\n\\n        /* Encode node receipts */\\n        bytes memory nodeReceipts;\\n        for (uint256 i; i < receipt.nodeReceipts.length; i++) {\\n            nodeReceipts = abi.encodePacked(\\n                nodeReceipts,\\n                receipt.nodeReceipts[i].tick,\\n                receipt.nodeReceipts[i].used,\\n                receipt.nodeReceipts[i].pending\\n            );\\n        }\\n\\n        return abi.encodePacked(header, nodeReceipts);\\n    }\\n\\n    /**\\n     * @dev Decode a loan receipt from bytes\\n     * @param encodedReceipt Encoded loan Receipt\\n     * @return Decoded loan receipt\\n     */\\n    function decode(bytes calldata encodedReceipt) internal pure returns (LoanReceiptV1 memory) {\\n        /* Validate encoded receipt length */\\n        if (encodedReceipt.length < LOAN_RECEIPT_V1_HEADER_SIZE) revert InvalidReceiptEncoding();\\n\\n        uint16 collateralWrapperContextLen = uint16(bytes2(encodedReceipt[153:155]));\\n\\n        /* Validate length with collateral wrapper context */\\n        if (encodedReceipt.length < LOAN_RECEIPT_V1_HEADER_SIZE + collateralWrapperContextLen)\\n            revert InvalidReceiptEncoding();\\n\\n        /* Validate length with node receipts */\\n        if (\\n            (encodedReceipt.length - LOAN_RECEIPT_V1_HEADER_SIZE - collateralWrapperContextLen) %\\n                LOAN_RECEIPT_V1_NODE_RECEIPT_SIZE !=\\n            0\\n        ) revert InvalidReceiptEncoding();\\n\\n        /* Validate encoded receipt version */\\n        if (uint8(encodedReceipt[0]) != LOAN_RECEIPT_V1_VERSION) revert InvalidReceiptEncoding();\\n\\n        LoanReceiptV1 memory receipt;\\n\\n        /* Decode header */\\n        receipt.version = uint8(encodedReceipt[0]);\\n        receipt.principal = uint256(bytes32(encodedReceipt[1:33]));\\n        receipt.repayment = uint256(bytes32(encodedReceipt[33:65]));\\n        receipt.borrower = address(uint160(bytes20(encodedReceipt[65:85])));\\n        receipt.maturity = uint64(bytes8(encodedReceipt[85:93]));\\n        receipt.duration = uint64(bytes8(encodedReceipt[93:101]));\\n        receipt.collateralToken = address(uint160(bytes20(encodedReceipt[101:121])));\\n        receipt.collateralTokenId = uint256(bytes32(encodedReceipt[121:153]));\\n        receipt.collateralWrapperContextLen = collateralWrapperContextLen;\\n        receipt.collateralWrapperContext = encodedReceipt[155:155 + collateralWrapperContextLen];\\n\\n        /* Decode node receipts */\\n        uint256 numNodeReceipts = (encodedReceipt.length - LOAN_RECEIPT_V1_HEADER_SIZE - collateralWrapperContextLen) /\\n            LOAN_RECEIPT_V1_NODE_RECEIPT_SIZE;\\n        receipt.nodeReceipts = new NodeReceipt[](numNodeReceipts);\\n        uint256 offset = LOAN_RECEIPT_V1_HEADER_SIZE + collateralWrapperContextLen;\\n        for (uint256 i; i < numNodeReceipts; i++) {\\n            receipt.nodeReceipts[i].tick = uint128(bytes16(encodedReceipt[offset:offset + 16]));\\n            receipt.nodeReceipts[i].used = uint128(bytes16(encodedReceipt[offset + 16:offset + 32]));\\n            receipt.nodeReceipts[i].pending = uint128(bytes16(encodedReceipt[offset + 32:offset + 48]));\\n            offset += LOAN_RECEIPT_V1_NODE_RECEIPT_SIZE;\\n        }\\n\\n        return receipt;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Multicall.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"./LoanReceipt.sol\\\";\\nimport \\\"./LiquidityManager.sol\\\";\\nimport \\\"./CollateralFilter.sol\\\";\\nimport \\\"./InterestRateModel.sol\\\";\\n\\nimport \\\"./interfaces/IPool.sol\\\";\\nimport \\\"./interfaces/ILiquidity.sol\\\";\\nimport \\\"./interfaces/ICollateralWrapper.sol\\\";\\nimport \\\"./interfaces/ICollateralLiquidator.sol\\\";\\nimport \\\"./interfaces/ICollateralLiquidationReceiver.sol\\\";\\n\\nimport \\\"./integrations/DelegateCash/IDelegationRegistry.sol\\\";\\n\\n/**\\n * @title Pool\\n * @author MetaStreet Labs\\n */\\nabstract contract Pool is\\n    ERC165,\\n    ReentrancyGuard,\\n    Multicall,\\n    CollateralFilter,\\n    InterestRateModel,\\n    IPool,\\n    ILiquidity,\\n    ICollateralLiquidationReceiver\\n{\\n    using SafeCast for uint256;\\n    using SafeERC20 for IERC20;\\n    using LoanReceipt for LoanReceipt.LoanReceiptV1;\\n    using LiquidityManager for LiquidityManager.Liquidity;\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Tick spacing basis points\\n     */\\n    uint256 public constant TICK_LIMIT_SPACING_BASIS_POINTS = LiquidityManager.TICK_LIMIT_SPACING_BASIS_POINTS;\\n\\n    /**\\n     * @notice Borrower's split of liquidation proceed surplus in basis points\\n     */\\n    uint256 public constant BORROWER_SURPLUS_SPLIT_BASIS_POINTS = 9_500;\\n\\n    /**\\n     * @notice Basis points scale\\n     */\\n    uint256 internal constant BASIS_POINTS_SCALE = 10_000;\\n\\n    /**\\n     * @notice Borrow options tag size in bytes\\n     */\\n    uint256 internal constant BORROW_OPTIONS_TAG_SIZE = 2;\\n\\n    /**\\n     * @notice Borrow options length size in bytes\\n     */\\n    uint256 internal constant BORROW_OPTIONS_LENGTH_SIZE = 2;\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid address\\n     */\\n    error InvalidAddress();\\n\\n    /**\\n     * @notice Parameter out of bounds\\n     */\\n    error ParameterOutOfBounds();\\n\\n    /**************************************************************************/\\n    /* Structures */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Deposit\\n     * @param shares Shares\\n     * @param redemptionPending Redemption shares pending\\n     * @param redemptionIndex Redemption queue index\\n     * @param redemptionTarget Redemption queue target\\n     */\\n    struct Deposit {\\n        uint128 shares;\\n        uint128 redemptionPending;\\n        uint128 redemptionIndex;\\n        uint128 redemptionTarget;\\n    }\\n\\n    /**\\n     * @notice Loan status\\n     */\\n    enum LoanStatus {\\n        Uninitialized,\\n        Active,\\n        Repaid,\\n        Liquidated,\\n        CollateralLiquidated\\n    }\\n\\n    /**\\n     * @notice Borrow function options\\n     */\\n    enum BorrowOptions {\\n        None,\\n        CollateralWrapperContext,\\n        CollateralFilterContext,\\n        DelegateCash\\n    }\\n\\n    /**************************************************************************/\\n    /* Immutable State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Collateral wrappers (max 3)\\n     */\\n    address internal immutable _collateralWrapper1;\\n    address internal immutable _collateralWrapper2;\\n    address internal immutable _collateralWrapper3;\\n\\n    /**\\n     * @notice Collateral liquidator\\n     */\\n    ICollateralLiquidator internal immutable _collateralLiquidator;\\n\\n    /**\\n     * @notice Delegation registry contract\\n     */\\n    IDelegationRegistry internal immutable _delegationRegistry;\\n\\n    /**************************************************************************/\\n    /* State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Currency token contract\\n     */\\n    IERC20 internal _currencyToken;\\n\\n    /**\\n     * @notice Admin fee rate in basis points\\n     */\\n    uint32 internal _adminFeeRate;\\n\\n    /**\\n     * @notice Durations\\n     */\\n    uint64[] internal _durations;\\n\\n    /**\\n     * @notice Rates\\n     */\\n    uint64[] internal _rates;\\n\\n    /**\\n     * @notice Admin\\n     */\\n    address private _admin;\\n\\n    /**\\n     * @notice Total admin fee balance\\n     */\\n    uint256 internal _adminFeeBalance;\\n\\n    /**\\n     * @notice Liquidity\\n     */\\n    LiquidityManager.Liquidity internal _liquidity;\\n\\n    /**\\n     * @notice Mapping of account to tick to deposit\\n     */\\n    mapping(address => mapping(uint128 => Deposit)) internal _deposits;\\n\\n    /**\\n     * @notice Mapping of loan receipt hash to loan status\\n     */\\n    mapping(bytes32 => LoanStatus) internal _loans;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Pool constructor\\n     * @param collateralLiquidator_ Collateral liquidator\\n     * @param delegationRegistry_ Delegation registry contract\\n     * @param collateralWrappers_ Collateral wrappers\\n     */\\n    constructor(address collateralLiquidator_, address delegationRegistry_, address[] memory collateralWrappers_) {\\n        _collateralLiquidator = ICollateralLiquidator(collateralLiquidator_);\\n\\n        _delegationRegistry = IDelegationRegistry(delegationRegistry_);\\n\\n        if (collateralWrappers_.length > 3) revert ParameterOutOfBounds();\\n        _collateralWrapper1 = (collateralWrappers_.length > 0) ? collateralWrappers_[0] : address(0);\\n        _collateralWrapper2 = (collateralWrappers_.length > 1) ? collateralWrappers_[1] : address(0);\\n        _collateralWrapper3 = (collateralWrappers_.length > 2) ? collateralWrappers_[2] : address(0);\\n    }\\n\\n    /**************************************************************************/\\n    /* Initializer */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Pool initializer\\n     * @dev Fee-on-transfer currency tokens are not supported\\n     * @param currencyToken_ Currency token contract\\n     * @param durations_ Duration tiers\\n     * @param rates_ Interest rate tiers\\n     */\\n    function _initialize(address currencyToken_, uint64[] memory durations_, uint64[] memory rates_) internal {\\n        if (IERC20Metadata(currencyToken_).decimals() != 18) revert ParameterOutOfBounds();\\n\\n        _currencyToken = IERC20(currencyToken_);\\n        _admin = msg.sender;\\n\\n        /* Assign durations */\\n        if (durations_.length > Tick.MAX_NUM_DURATIONS) revert ParameterOutOfBounds();\\n        for (uint256 i; i < durations_.length; i++) {\\n            /* Check duration is monotonic */\\n            if (i != 0 && durations_[i] <= durations_[i - 1]) revert ParameterOutOfBounds();\\n            _durations.push(durations_[i]);\\n        }\\n\\n        /* Assign rates */\\n        if (rates_.length > Tick.MAX_NUM_RATES) revert ParameterOutOfBounds();\\n        for (uint256 i; i < rates_.length; i++) {\\n            /* Check rate is monotonic */\\n            if (i != 0 && rates_[i] <= rates_[i - 1]) revert ParameterOutOfBounds();\\n            _rates.push(rates_[i]);\\n        }\\n\\n        /* Initialize liquidity */\\n        _liquidity.initialize();\\n    }\\n\\n    /**************************************************************************/\\n    /* Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Get implementation name\\n     * @return Implementation name\\n     */\\n    function IMPLEMENTATION_NAME() external pure virtual returns (string memory);\\n\\n    /**\\n     * @notice Get implementation version\\n     * @return Implementation version\\n     */\\n    function IMPLEMENTATION_VERSION() external pure returns (string memory) {\\n        return \\\"1.4\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function currencyToken() external view returns (address) {\\n        return address(_currencyToken);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function durations() external view returns (uint64[] memory) {\\n        return _durations;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function rates() external view returns (uint64[] memory) {\\n        return _rates;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function admin() external view returns (address) {\\n        return _admin;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function adminFeeRate() external view returns (uint32) {\\n        return _adminFeeRate;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function collateralWrappers() external view returns (address[] memory) {\\n        address[] memory collateralWrappers_ = new address[](3);\\n        collateralWrappers_[0] = _collateralWrapper1;\\n        collateralWrappers_[1] = _collateralWrapper2;\\n        collateralWrappers_[2] = _collateralWrapper3;\\n        return collateralWrappers_;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function collateralLiquidator() external view returns (address) {\\n        return address(_collateralLiquidator);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function delegationRegistry() external view returns (address) {\\n        return address(_delegationRegistry);\\n    }\\n\\n    /**\\n     * @notice Get deposit\\n     * @param account Account\\n     * @param tick Tick\\n     * @return Deposit information\\n     */\\n    function deposits(address account, uint128 tick) external view returns (Deposit memory) {\\n        return _deposits[account][tick];\\n    }\\n\\n    /**\\n     * @notice Get loan status\\n     * @param receiptHash Loan receipt hash\\n     * @return Loan status\\n     */\\n    function loans(bytes32 receiptHash) external view returns (LoanStatus) {\\n        return _loans[receiptHash];\\n    }\\n\\n    /**\\n     * @notice Get total admin fee balance\\n     * @return Total admin fee balance\\n     */\\n    function adminFeeBalance() external view returns (uint256) {\\n        return _adminFeeBalance;\\n    }\\n\\n    /**************************************************************************/\\n    /* Loan Receipt External Helpers */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Decode loan receipt\\n     * @param loanReceipt Loan receipt\\n     * @return Decoded loan receipt\\n     */\\n    function decodeLoanReceipt(bytes calldata loanReceipt) external pure returns (LoanReceipt.LoanReceiptV1 memory) {\\n        return LoanReceipt.decode(loanReceipt);\\n    }\\n\\n    /**************************************************************************/\\n    /* ILiquidity Getters */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc ILiquidity\\n     */\\n    function liquidityNodes(uint128 startTick, uint128 endTick) external view returns (NodeInfo[] memory) {\\n        return _liquidity.liquidityNodes(startTick, endTick);\\n    }\\n\\n    /**\\n     * @inheritdoc ILiquidity\\n     */\\n    function liquidityNode(uint128 tick) external view returns (NodeInfo memory) {\\n        return _liquidity.liquidityNode(tick);\\n    }\\n\\n    /**************************************************************************/\\n    /* Helper Functions */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Helper function to extract specified option tag from options\\n     * data\\n     *\\n     * @dev Options are encoded as:\\n     *   2 byte uint16 tag\\n     *   2 byte uint16 length\\n     *   n byte bytes  data\\n     * The first matching tag is returned.\\n     *\\n     * @param options Encoded options\\n     * @param tag Tag to find\\n     * @return Options data\\n     */\\n    function _getOptionsData(bytes calldata options, uint16 tag) internal pure returns (bytes calldata) {\\n        uint256 offsetTag = 0;\\n\\n        /* Scan the options for the tag */\\n        while (offsetTag < options.length) {\\n            /* Compute offsets with for tag length and data */\\n            uint256 offsetLength = offsetTag + BORROW_OPTIONS_TAG_SIZE;\\n            uint256 offsetData = offsetTag + BORROW_OPTIONS_TAG_SIZE + BORROW_OPTIONS_LENGTH_SIZE;\\n\\n            /* The tag is in the first 2 bytes of each options item */\\n            uint16 currentTag = uint16(bytes2(options[offsetTag:offsetLength]));\\n\\n            /* The length of the options data is in the second 2 bytes of each options item, after the tag */\\n            uint256 dataLength = uint16(bytes2(options[offsetLength:offsetData]));\\n\\n            /* Return the offset and length if the tag is found */\\n            if (currentTag == tag) {\\n                return options[offsetData:offsetData + dataLength];\\n            }\\n\\n            /* Increment to next options item */\\n            offsetTag = offsetData + dataLength;\\n        }\\n\\n        /* Return empty slice if no tag is found */\\n        return options[0:0];\\n    }\\n\\n    /**\\n     * @notice Helper function that returns underlying collateral in (address,\\n     * uint256[]) shape\\n     * @param collateralToken Collateral token, either underlying token or collateral wrapper\\n     * @param collateralTokenId Collateral token ID\\n     * @param collateralWrapperContext Collateral wrapper context\\n     * @return Underlying collateral token and token IDs\\n     */\\n    function _getUnderlyingCollateral(\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        bytes memory collateralWrapperContext\\n    ) internal view returns (address, uint256[] memory) {\\n        /* Enumerate bundle if collateral token is a collateral wrapper */\\n        if (\\n            collateralToken == _collateralWrapper1 ||\\n            collateralToken == _collateralWrapper2 ||\\n            collateralToken == _collateralWrapper3\\n        ) {\\n            return ICollateralWrapper(collateralToken).enumerate(collateralTokenId, collateralWrapperContext);\\n        }\\n\\n        /* If single asset, convert to length one token ID array */\\n        uint256[] memory underlyingCollateralTokenIds = new uint256[](1);\\n        underlyingCollateralTokenIds[0] = collateralTokenId;\\n\\n        return (collateralToken, underlyingCollateralTokenIds);\\n    }\\n\\n    /**\\n     * @notice Helper function that calls delegate.cash registry to delegate\\n     * token\\n     * @param collateralToken Collateral token\\n     * @param collateralTokenId Collateral token ID\\n     * @param options Options data\\n     */\\n    function _optionDelegateCash(address collateralToken, uint256 collateralTokenId, bytes calldata options) internal {\\n        /* Find delegate.cash tagged data in options */\\n        bytes calldata delegateData = _getOptionsData(options, uint16(BorrowOptions.DelegateCash));\\n\\n        if (delegateData.length != 0) {\\n            if (address(_delegationRegistry) == address(0) || delegateData.length != 20) revert InvalidBorrowOptions();\\n\\n            /* Delegate token */\\n            _delegationRegistry.delegateForToken(\\n                address(uint160(bytes20(delegateData))),\\n                collateralToken,\\n                collateralTokenId,\\n                true\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper function to revoke token delegate\\n     * @param collateralToken Contract address of token that delegation is being removed from\\n     * @param collateralTokenId Token id of token that delegation is being removed from\\n     */\\n    function _revokeDelegates(address collateralToken, uint256 collateralTokenId) internal {\\n        /* No operation if _delegationRegistry not set */\\n        if (address(_delegationRegistry) == address(0)) return;\\n\\n        /* Get delegates for collateral token and id */\\n        address[] memory delegates = _delegationRegistry.getDelegatesForToken(\\n            address(this),\\n            collateralToken,\\n            collateralTokenId\\n        );\\n\\n        for (uint256 i; i < delegates.length; i++) {\\n            /* Revoke by setting value to false */\\n            _delegationRegistry.delegateForToken(delegates[i], collateralToken, collateralTokenId, false);\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper function to quote a loan\\n     * @param principal Principal amount in currency tokens\\n     * @param duration Duration in seconds\\n     * @param collateralToken Collateral token address\\n     * @param collateralTokenIds List of collateral token ids\\n     * @param ticks Liquidity node ticks\\n     * @param collateralFilterContext Collateral filter context\\n     * @return Repayment amount in currency tokens, liquidity nodes, liquidity\\n     * node count\\n     */\\n    function _quote(\\n        uint256 principal,\\n        uint64 duration,\\n        address collateralToken,\\n        uint256[] memory collateralTokenIds,\\n        uint128[] calldata ticks,\\n        bytes calldata collateralFilterContext\\n    ) internal view returns (uint256, ILiquidity.NodeSource[] memory, uint16) {\\n        /* Verify collateral is supported */\\n        for (uint256 i; i < collateralTokenIds.length; i++) {\\n            if (!_collateralSupported(collateralToken, collateralTokenIds[i], i, collateralFilterContext))\\n                revert UnsupportedCollateral(i);\\n        }\\n\\n        /* Cache durations */\\n        uint64[] memory durations_ = _durations;\\n\\n        /* Lookup duration index */\\n        uint256 durationIndex;\\n        for (; durationIndex < durations_.length; durationIndex++) {\\n            if (duration <= durations_[durationIndex]) break;\\n        }\\n\\n        /* Validate duration index */\\n        if (durationIndex == durations_.length) revert UnsupportedLoanDuration();\\n\\n        /* Source liquidity nodes */\\n        (ILiquidity.NodeSource[] memory nodes, uint16 count) = _liquidity.source(\\n            principal,\\n            ticks,\\n            collateralTokenIds.length,\\n            durationIndex\\n        );\\n\\n        /* Calculate repayment from principal, rate, and duration */\\n        uint256 repayment = (principal *\\n            (LiquidityManager.FIXED_POINT_SCALE + (_rate(principal, _rates, nodes, count) * duration))) /\\n            LiquidityManager.FIXED_POINT_SCALE;\\n\\n        return (repayment, nodes, count);\\n    }\\n\\n    /**\\n     * @dev Helper function to calculated prorated repayment\\n     * @param loanReceipt Decoded loan receipt\\n     * @return repayment amount in currency tokens\\n     * @return proration based on elapsed duration\\n     */\\n    function _prorateRepayment(\\n        LoanReceipt.LoanReceiptV1 memory loanReceipt\\n    ) internal view returns (uint256 repayment, uint256 proration) {\\n        /* Minimum of proration and 1.0 */\\n        proration = Math.min(\\n            ((block.timestamp - (loanReceipt.maturity - loanReceipt.duration)) * LiquidityManager.FIXED_POINT_SCALE) /\\n                loanReceipt.duration,\\n            LiquidityManager.FIXED_POINT_SCALE\\n        );\\n\\n        /* Compute repayment using prorated interest */\\n        repayment =\\n            loanReceipt.principal +\\n            (((loanReceipt.repayment - loanReceipt.principal) * proration) / LiquidityManager.FIXED_POINT_SCALE);\\n    }\\n\\n    /**\\n     * @dev Helper function to handle borrow accounting\\n     * @param principal Principal amount in currency tokens\\n     * @param duration Duration in seconds\\n     * @param collateralToken Collateral token address\\n     * @param collateralTokenId Collateral token ID\\n     * @param maxRepayment Maximum repayment amount in currency tokens\\n     * @param ticks Liquidity node ticks\\n     * @param collateralWrapperContext Collateral wrapper context data\\n     * @param collateralFilterContext Collateral filter context data\\n     * @return Repayment amount in currency tokens, encoded loan receipt, loan\\n     * receipt hash\\n     */\\n    function _borrow(\\n        uint256 principal,\\n        uint64 duration,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        uint256 maxRepayment,\\n        uint128[] calldata ticks,\\n        bytes memory collateralWrapperContext,\\n        bytes calldata collateralFilterContext\\n    ) internal returns (uint256, bytes memory, bytes32) {\\n        /* Validate duration is non-zero */\\n        if (duration == 0) revert UnsupportedLoanDuration();\\n\\n        /* Get underlying collateral */\\n        (address underlyingCollateralToken, uint256[] memory underlyingCollateralTokenIds) = _getUnderlyingCollateral(\\n            collateralToken,\\n            collateralTokenId,\\n            collateralWrapperContext\\n        );\\n\\n        /* Quote repayment and liquidity nodes */\\n        (uint256 repayment, ILiquidity.NodeSource[] memory nodes, uint16 count) = _quote(\\n            principal,\\n            duration,\\n            underlyingCollateralToken,\\n            underlyingCollateralTokenIds,\\n            ticks,\\n            collateralFilterContext\\n        );\\n\\n        /* Validate repayment */\\n        if (repayment > maxRepayment) revert RepaymentTooHigh();\\n\\n        /* Compute total fee */\\n        uint256 totalFee = repayment - principal;\\n\\n        /* Compute admin fee */\\n        uint256 adminFee = (_adminFeeRate * totalFee) / BASIS_POINTS_SCALE;\\n\\n        /* Distribute interest */\\n        uint128[] memory interest = _distribute(principal, totalFee - adminFee, nodes, count);\\n\\n        /* Build the loan receipt */\\n        LoanReceipt.LoanReceiptV1 memory receipt = LoanReceipt.LoanReceiptV1({\\n            version: 1,\\n            principal: principal,\\n            repayment: repayment,\\n            borrower: msg.sender,\\n            maturity: uint64(block.timestamp + duration),\\n            duration: duration,\\n            collateralToken: collateralToken,\\n            collateralTokenId: collateralTokenId,\\n            collateralWrapperContextLen: collateralWrapperContext.length.toUint16(),\\n            collateralWrapperContext: collateralWrapperContext,\\n            nodeReceipts: new LoanReceipt.NodeReceipt[](count)\\n        });\\n\\n        /* Use liquidity nodes */\\n        for (uint256 i; i < count; i++) {\\n            /* Compute pending */\\n            uint128 pending = nodes[i].used + interest[i];\\n\\n            /* Use node */\\n            _liquidity.use(nodes[i].tick, nodes[i].used, pending);\\n\\n            /* Construct node receipt */\\n            receipt.nodeReceipts[i] = LoanReceipt.NodeReceipt({\\n                tick: nodes[i].tick,\\n                used: nodes[i].used,\\n                pending: pending\\n            });\\n        }\\n\\n        /* Encode and hash the loan receipt */\\n        bytes memory encodedLoanReceipt = receipt.encode();\\n        bytes32 loanReceiptHash = LoanReceipt.hash(encodedLoanReceipt);\\n\\n        /* Validate no loan receipt hash collision */\\n        if (_loans[loanReceiptHash] != LoanStatus.Uninitialized) revert InvalidLoanReceipt();\\n\\n        /* Store loan status */\\n        _loans[loanReceiptHash] = LoanStatus.Active;\\n\\n        return (repayment, encodedLoanReceipt, loanReceiptHash);\\n    }\\n\\n    /**\\n     * @dev Helper function to handle repay accounting\\n     * @param encodedLoanReceipt Encoded loan receipt\\n     * @return Repayment amount in currency tokens, decoded loan receipt, loan\\n     * receipt hash\\n     */\\n    function _repay(\\n        bytes calldata encodedLoanReceipt\\n    ) internal returns (uint256, LoanReceipt.LoanReceiptV1 memory, bytes32) {\\n        /* Compute loan receipt hash */\\n        bytes32 loanReceiptHash = LoanReceipt.hash(encodedLoanReceipt);\\n\\n        /* Validate loan receipt */\\n        if (_loans[loanReceiptHash] != LoanStatus.Active) revert InvalidLoanReceipt();\\n\\n        /* Decode loan receipt */\\n        LoanReceipt.LoanReceiptV1 memory loanReceipt = LoanReceipt.decode(encodedLoanReceipt);\\n\\n        /* Validate borrow and repay is not in same block */\\n        if (loanReceipt.maturity - loanReceipt.duration == block.timestamp) revert InvalidLoanReceipt();\\n\\n        /* Validate caller is borrower */\\n        if (msg.sender != loanReceipt.borrower) revert InvalidCaller();\\n\\n        /* Compute proration and repayment using prorated interest */\\n        (uint256 repayment, uint256 proration) = _prorateRepayment(loanReceipt);\\n\\n        /* Restore liquidity nodes */\\n        uint128 totalPending;\\n        for (uint256 i; i < loanReceipt.nodeReceipts.length; i++) {\\n            /* Restore node */\\n            _liquidity.restore(\\n                loanReceipt.nodeReceipts[i].tick,\\n                loanReceipt.nodeReceipts[i].used,\\n                loanReceipt.nodeReceipts[i].pending,\\n                loanReceipt.nodeReceipts[i].used +\\n                    uint128(\\n                        ((loanReceipt.nodeReceipts[i].pending - loanReceipt.nodeReceipts[i].used) * proration) /\\n                            LiquidityManager.FIXED_POINT_SCALE\\n                    )\\n            );\\n\\n            /* Accumulate pending */\\n            totalPending += loanReceipt.nodeReceipts[i].pending;\\n        }\\n\\n        /* Update admin fee total balance with prorated admin fee */\\n        _adminFeeBalance += ((loanReceipt.repayment - totalPending) * proration) / LiquidityManager.FIXED_POINT_SCALE;\\n\\n        /* Mark loan status repaid */\\n        _loans[loanReceiptHash] = LoanStatus.Repaid;\\n\\n        return (repayment, loanReceipt, loanReceiptHash);\\n    }\\n\\n    /**\\n     * @dev Helper function to handle deposit accounting\\n     * @param tick Tick\\n     * @param amount Amount\\n     * @param minShares Minimum shares\\n     * @return Deposit shares\\n     */\\n    function _deposit(uint128 tick, uint128 amount, uint128 minShares) internal returns (uint128) {\\n        /* Validate tick */\\n        Tick.validate(tick, 0, 0, _durations.length - 1, 0, _rates.length - 1);\\n\\n        /* Deposit into liquidity node */\\n        uint128 shares = _liquidity.deposit(tick, amount);\\n\\n        /* Validate shares received is sufficient */\\n        if (shares == 0 || shares < minShares) revert InsufficientShares();\\n\\n        /* Add to deposit */\\n        _deposits[msg.sender][tick].shares += shares;\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev Helper function to handle redeem accounting\\n     * @param tick Tick\\n     * @param shares Shares\\n     */\\n    function _redeem(uint128 tick, uint128 shares) internal {\\n        /* Look up Deposit */\\n        Deposit storage dep = _deposits[msg.sender][tick];\\n\\n        /* Validate shares */\\n        if (shares == 0 || shares > dep.shares) revert InsufficientShares();\\n\\n        /* Validate redemption isn't pending */\\n        if (dep.redemptionPending != 0) revert InvalidRedemptionStatus();\\n\\n        /* Redeem shares in tick with liquidity manager */\\n        (uint128 redemptionIndex, uint128 redemptionTarget) = _liquidity.redeem(tick, shares);\\n\\n        /* Update deposit state */\\n        dep.redemptionPending = shares;\\n        dep.redemptionIndex = redemptionIndex;\\n        dep.redemptionTarget = redemptionTarget;\\n    }\\n\\n    /**\\n     * @dev Helper function to handle withdraw accounting\\n     * @param tick Tick\\n     * @return Withdrawn shares and withdrawn amount\\n     */\\n    function _withdraw(uint128 tick) internal returns (uint128, uint128) {\\n        /* Look up Deposit */\\n        Deposit storage dep = _deposits[msg.sender][tick];\\n\\n        /* If no redemption is pending */\\n        if (dep.redemptionPending == 0) revert InvalidRedemptionStatus();\\n\\n        /* Look up redemption available */\\n        (uint128 shares, uint128 amount, uint128 processedIndices, uint128 processedShares) = _liquidity\\n            .redemptionAvailable(tick, dep.redemptionPending, dep.redemptionIndex, dep.redemptionTarget);\\n\\n        /* If the entire redemption is ready */\\n        if (shares == dep.redemptionPending) {\\n            dep.redemptionPending = 0;\\n            dep.redemptionIndex = 0;\\n            dep.redemptionTarget = 0;\\n        } else {\\n            dep.redemptionPending -= shares;\\n            dep.redemptionIndex += processedIndices;\\n            dep.redemptionTarget = (processedShares < dep.redemptionTarget)\\n                ? dep.redemptionTarget - processedShares\\n                : 0;\\n        }\\n\\n        /* Decrement deposit shares */\\n        dep.shares -= shares;\\n\\n        return (shares, amount);\\n    }\\n\\n    /**************************************************************************/\\n    /* Lend API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function quote(\\n        uint256 principal,\\n        uint64 duration,\\n        address collateralToken,\\n        uint256[] calldata collateralTokenIds,\\n        uint128[] calldata ticks,\\n        bytes calldata options\\n    ) external view returns (uint256) {\\n        /* Quote repayment */\\n        (uint256 repayment, , ) = _quote(\\n            principal,\\n            duration,\\n            collateralToken,\\n            collateralTokenIds,\\n            ticks,\\n            _getOptionsData(options, uint16(BorrowOptions.CollateralFilterContext))\\n        );\\n\\n        return repayment;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function quoteRefinance(\\n        bytes calldata encodedLoanReceipt,\\n        uint256 principal,\\n        uint64 duration,\\n        uint128[] calldata ticks\\n    ) external view returns (int256, uint256) {\\n        /* Decode loan receipt */\\n        LoanReceipt.LoanReceiptV1 memory loanReceipt = LoanReceipt.decode(encodedLoanReceipt);\\n\\n        /* Get underlying collateral */\\n        (address underlyingCollateralToken, uint256[] memory underlyingCollateralTokenIds) = _getUnderlyingCollateral(\\n            loanReceipt.collateralToken,\\n            loanReceipt.collateralTokenId,\\n            loanReceipt.collateralWrapperContext\\n        );\\n\\n        /* Quote repayment */\\n        (uint256 newRepayment, , ) = _quote(\\n            principal,\\n            duration,\\n            underlyingCollateralToken,\\n            underlyingCollateralTokenIds,\\n            ticks,\\n            encodedLoanReceipt[0:0]\\n        );\\n\\n        /* Compute repayment using prorated interest */\\n        (uint256 proratedRepayment, ) = _prorateRepayment(loanReceipt);\\n\\n        return (int256(proratedRepayment) - int256(principal), newRepayment);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function borrow(\\n        uint256 principal,\\n        uint64 duration,\\n        address collateralToken,\\n        uint256 collateralTokenId,\\n        uint256 maxRepayment,\\n        uint128[] calldata ticks,\\n        bytes calldata options\\n    ) external nonReentrant returns (uint256) {\\n        /* Handle borrow accounting */\\n        (uint256 repayment, bytes memory encodedLoanReceipt, bytes32 loanReceiptHash) = _borrow(\\n            principal,\\n            duration,\\n            collateralToken,\\n            collateralTokenId,\\n            maxRepayment,\\n            ticks,\\n            _getOptionsData(options, uint16(BorrowOptions.CollateralWrapperContext)),\\n            _getOptionsData(options, uint16(BorrowOptions.CollateralFilterContext))\\n        );\\n\\n        /* Handle delegate.cash option */\\n        _optionDelegateCash(collateralToken, collateralTokenId, options);\\n\\n        /* Transfer collateral from borrower to pool */\\n        IERC721(collateralToken).transferFrom(msg.sender, address(this), collateralTokenId);\\n\\n        /* Transfer principal from pool to borrower */\\n        _currencyToken.safeTransfer(msg.sender, principal);\\n\\n        /* Emit LoanOriginated */\\n        emit LoanOriginated(loanReceiptHash, encodedLoanReceipt);\\n\\n        return repayment;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function repay(bytes calldata encodedLoanReceipt) external nonReentrant returns (uint256) {\\n        /* Handle repay accounting */\\n        (uint256 repayment, LoanReceipt.LoanReceiptV1 memory loanReceipt, bytes32 loanReceiptHash) = _repay(\\n            encodedLoanReceipt\\n        );\\n\\n        /* Revoke delegates */\\n        _revokeDelegates(loanReceipt.collateralToken, loanReceipt.collateralTokenId);\\n\\n        /* Transfer repayment from borrower to pool */\\n        _currencyToken.safeTransferFrom(loanReceipt.borrower, address(this), repayment);\\n\\n        /* Transfer collateral from pool to borrower */\\n        IERC721(loanReceipt.collateralToken).transferFrom(\\n            address(this),\\n            loanReceipt.borrower,\\n            loanReceipt.collateralTokenId\\n        );\\n\\n        /* Emit Loan Repaid */\\n        emit LoanRepaid(loanReceiptHash, repayment);\\n\\n        return repayment;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function refinance(\\n        bytes calldata encodedLoanReceipt,\\n        uint256 principal,\\n        uint64 duration,\\n        uint256 maxRepayment,\\n        uint128[] calldata ticks\\n    ) external nonReentrant returns (uint256) {\\n        /* Handle repay accounting */\\n        (uint256 repayment, LoanReceipt.LoanReceiptV1 memory loanReceipt, bytes32 loanReceiptHash) = _repay(\\n            encodedLoanReceipt\\n        );\\n\\n        /* Handle borrow accounting */\\n        (uint256 newRepayment, bytes memory newEncodedLoanReceipt, bytes32 newLoanReceiptHash) = _borrow(\\n            principal,\\n            duration,\\n            loanReceipt.collateralToken,\\n            loanReceipt.collateralTokenId,\\n            maxRepayment,\\n            ticks,\\n            loanReceipt.collateralWrapperContext,\\n            encodedLoanReceipt[0:0]\\n        );\\n\\n        /* Determine transfer direction */\\n        if (principal < repayment) {\\n            /* Transfer prorated repayment less principal from borrower to pool */\\n            _currencyToken.safeTransferFrom(loanReceipt.borrower, address(this), repayment - principal);\\n        } else {\\n            /* Transfer principal less prorated repayment from pool to borrower */\\n            _currencyToken.safeTransfer(msg.sender, principal - repayment);\\n        }\\n\\n        /* Emit Loan Repaid */\\n        emit LoanRepaid(loanReceiptHash, repayment);\\n\\n        /* Emit LoanOriginated */\\n        emit LoanOriginated(newLoanReceiptHash, newEncodedLoanReceipt);\\n\\n        return newRepayment;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function liquidate(bytes calldata encodedLoanReceipt) external nonReentrant {\\n        /* Compute loan receipt hash */\\n        bytes32 loanReceiptHash = LoanReceipt.hash(encodedLoanReceipt);\\n\\n        /* Validate loan status is active */\\n        if (_loans[loanReceiptHash] != LoanStatus.Active) revert InvalidLoanReceipt();\\n\\n        /* Decode loan receipt */\\n        LoanReceipt.LoanReceiptV1 memory loanReceipt = LoanReceipt.decode(encodedLoanReceipt);\\n\\n        /* Validate loan is expired */\\n        if (block.timestamp <= loanReceipt.maturity) revert LoanNotExpired();\\n\\n        /* Approve collateral for transfer to _collateralLiquidator */\\n        IERC721(loanReceipt.collateralToken).approve(address(_collateralLiquidator), loanReceipt.collateralTokenId);\\n\\n        /* Mark loan status liquidated */\\n        _loans[loanReceiptHash] = LoanStatus.Liquidated;\\n\\n        /* Revoke delegates */\\n        _revokeDelegates(loanReceipt.collateralToken, loanReceipt.collateralTokenId);\\n\\n        /* Start liquidation with collateral liquidator */\\n        _collateralLiquidator.liquidate(\\n            address(_currencyToken),\\n            loanReceipt.collateralToken,\\n            loanReceipt.collateralTokenId,\\n            loanReceipt.collateralWrapperContext,\\n            encodedLoanReceipt\\n        );\\n\\n        /* Emit Loan Liquidated */\\n        emit LoanLiquidated(loanReceiptHash);\\n    }\\n\\n    /**************************************************************************/\\n    /* Callbacks */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc ICollateralLiquidationReceiver\\n     */\\n    function onCollateralLiquidated(bytes calldata encodedLoanReceipt, uint256 proceeds) external nonReentrant {\\n        /* Validate caller is collateral liquidator */\\n        if (msg.sender != address(_collateralLiquidator)) revert InvalidCaller();\\n\\n        /* Compute loan receipt hash */\\n        bytes32 loanReceiptHash = LoanReceipt.hash(encodedLoanReceipt);\\n\\n        /* Validate loan status is liquidated */\\n        if (_loans[loanReceiptHash] != LoanStatus.Liquidated) revert InvalidLoanReceipt();\\n\\n        /* Decode loan receipt */\\n        LoanReceipt.LoanReceiptV1 memory loanReceipt = LoanReceipt.decode(encodedLoanReceipt);\\n\\n        /* Compute borrower's share of liquidation surplus */\\n        uint256 borrowerSurplus = proceeds > loanReceipt.repayment\\n            ? Math.mulDiv(proceeds - loanReceipt.repayment, BORROWER_SURPLUS_SPLIT_BASIS_POINTS, BASIS_POINTS_SCALE)\\n            : 0;\\n\\n        /* Compute remaining proceeds */\\n        uint128 proceedsRemaining = (proceeds - borrowerSurplus).toUint128();\\n\\n        /* Restore liquidity nodes */\\n        for (uint256 i; i < loanReceipt.nodeReceipts.length; i++) {\\n            /* Restore node */\\n            uint128 restored = (i == loanReceipt.nodeReceipts.length - 1)\\n                ? proceedsRemaining\\n                : uint128(Math.min(loanReceipt.nodeReceipts[i].pending, proceedsRemaining));\\n            _liquidity.restore(\\n                loanReceipt.nodeReceipts[i].tick,\\n                loanReceipt.nodeReceipts[i].used,\\n                loanReceipt.nodeReceipts[i].pending,\\n                restored\\n            );\\n\\n            /* Update proceeds remaining */\\n            proceedsRemaining -= restored;\\n        }\\n\\n        /* Mark loan status collateral liquidated */\\n        _loans[loanReceiptHash] = LoanStatus.CollateralLiquidated;\\n\\n        /* Transfer surplus to borrower */\\n        if (borrowerSurplus != 0) IERC20(_currencyToken).safeTransfer(loanReceipt.borrower, borrowerSurplus);\\n\\n        /* Emit Collateral Liquidated */\\n        emit CollateralLiquidated(loanReceiptHash, proceeds, borrowerSurplus);\\n    }\\n\\n    /**************************************************************************/\\n    /* Deposit API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function deposit(uint128 tick, uint256 amount, uint256 minShares) external nonReentrant returns (uint256) {\\n        /* Handle deposit accounting and compute shares */\\n        uint128 shares = _deposit(tick, amount.toUint128(), minShares.toUint128());\\n\\n        /* Transfer deposit amount */\\n        _currencyToken.safeTransferFrom(msg.sender, address(this), amount);\\n\\n        /* Emit Deposited */\\n        emit Deposited(msg.sender, tick, amount, shares);\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function redeem(uint128 tick, uint256 shares) external nonReentrant {\\n        /* Handle redeem accounting */\\n        _redeem(tick, shares.toUint128());\\n\\n        /* Emit Redeemed event */\\n        emit Redeemed(msg.sender, tick, shares);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function redemptionAvailable(address account, uint128 tick) external view returns (uint256 shares, uint256 amount) {\\n        /* Look up Deposit */\\n        Deposit storage dep = _deposits[account][tick];\\n\\n        /* If no redemption is pending */\\n        if (dep.redemptionPending == 0) return (0, 0);\\n\\n        (shares, amount, , ) = _liquidity.redemptionAvailable(\\n            tick,\\n            dep.redemptionPending,\\n            dep.redemptionIndex,\\n            dep.redemptionTarget\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function withdraw(uint128 tick) external nonReentrant returns (uint256, uint256) {\\n        /* Handle withdraw accounting and compute both shares and amount */\\n        (uint128 shares, uint128 amount) = _withdraw(tick);\\n\\n        /* Transfer withdrawal amount */\\n        _currencyToken.safeTransfer(msg.sender, amount);\\n\\n        /* Emit Withdrawn */\\n        emit Withdrawn(msg.sender, tick, shares, amount);\\n\\n        return (shares, amount);\\n    }\\n\\n    /**\\n     * @inheritdoc IPool\\n     */\\n    function rebalance(\\n        uint128 srcTick,\\n        uint128 dstTick,\\n        uint256 minShares\\n    ) external nonReentrant returns (uint256, uint256, uint256) {\\n        /* Handle withdraw accounting and compute both shares and amount */\\n        (uint128 oldShares, uint128 amount) = _withdraw(srcTick);\\n\\n        /* Handle deposit accounting and compute new shares */\\n        uint128 newShares = _deposit(dstTick, amount, minShares.toUint128());\\n\\n        /* Emit Withdrawn */\\n        emit Withdrawn(msg.sender, srcTick, oldShares, amount);\\n        /* Emit Deposited */\\n        emit Deposited(msg.sender, dstTick, amount, newShares);\\n\\n        return (oldShares, newShares, amount);\\n    }\\n\\n    /**************************************************************************/\\n    /* Admin Fees API */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Set the admin fee rate\\n     *\\n     * Emits a {AdminFeeRateUpdated} event.\\n     *\\n     * @param rate Rate is the admin fee in basis points\\n     */\\n    function setAdminFeeRate(uint32 rate) external {\\n        if (msg.sender != _admin) revert InvalidCaller();\\n        if (rate == 0 || rate >= BASIS_POINTS_SCALE) revert ParameterOutOfBounds();\\n        _adminFeeRate = rate;\\n        emit AdminFeeRateUpdated(rate);\\n    }\\n\\n    /**\\n     * @notice Withdraw admin fees\\n     *\\n     * Emits a {AdminFeesWithdrawn} event.\\n     *\\n     * @param recipient Recipient account\\n     * @param amount Amount to withdraw\\n     */\\n    function withdrawAdminFees(address recipient, uint256 amount) external nonReentrant {\\n        if (msg.sender != _admin) revert InvalidCaller();\\n        if (recipient == address(0)) revert InvalidAddress();\\n        if (amount > _adminFeeBalance) revert ParameterOutOfBounds();\\n\\n        /* Update admin fees balance */\\n        _adminFeeBalance -= amount;\\n\\n        /* Transfer cash from Pool to recipient */\\n        _currencyToken.safeTransfer(recipient, amount);\\n\\n        emit AdminFeesWithdrawn(recipient, amount);\\n    }\\n\\n    /******************************************************/\\n    /* ERC165 interface */\\n    /******************************************************/\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return interfaceId == type(ICollateralLiquidationReceiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rates/WeightedInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"../InterestRateModel.sol\\\";\\nimport \\\"../Tick.sol\\\";\\n\\n/**\\n * @title Weighted Interest Rate Model\\n * @author MetaStreet Labs\\n */\\ncontract WeightedInterestRateModel is InterestRateModel {\\n    using SafeCast for uint256;\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Fixed point scale\\n     */\\n    uint256 internal constant FIXED_POINT_SCALE = 1e18;\\n\\n    /**\\n     * @notice Maximum tick threshold (0.5)\\n     */\\n    uint256 internal constant MAX_TICK_THRESHOLD = 0.5 * 1e18;\\n\\n    /**\\n     * @notice Minimum tick exponential (0.25)\\n     */\\n    uint256 internal constant MIN_TICK_EXPONENTIAL = 0.25 * 1e18;\\n\\n    /**\\n     * @notice Maximum tick exponential (4.0)\\n     */\\n    uint256 internal constant MAX_TICK_EXPONENTIAL = 4.0 * 1e18;\\n\\n    /**************************************************************************/\\n    /* Structures */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Parameters\\n     * @param tickThreshold Tick interest threshold\\n     * @param tickExponential Tick exponential base\\n     */\\n    struct Parameters {\\n        uint64 tickThreshold;\\n        uint64 tickExponential;\\n    }\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid Tick Parameter\\n     */\\n    error InvalidParameters();\\n\\n    /**\\n     * @notice Insufficient utilization\\n     */\\n    error InsufficientUtilization();\\n\\n    /**************************************************************************/\\n    /* Immutable State */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Tick interest threshold\\n     */\\n    uint64 internal immutable _tickThreshold;\\n\\n    /**\\n     * @notice Tick exponential base\\n     */\\n    uint64 internal immutable _tickExponential;\\n\\n    /**************************************************************************/\\n    /* Constructor */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice WeightedInterestRateModel constructor\\n     */\\n    constructor(Parameters memory parameters) {\\n        if (parameters.tickThreshold > MAX_TICK_THRESHOLD) revert InvalidParameters();\\n        if (parameters.tickExponential < MIN_TICK_EXPONENTIAL || parameters.tickExponential > MAX_TICK_EXPONENTIAL)\\n            revert InvalidParameters();\\n\\n        _tickThreshold = parameters.tickThreshold;\\n        _tickExponential = parameters.tickExponential;\\n    }\\n\\n    /**************************************************************************/\\n    /* Implementation */\\n    /**************************************************************************/\\n\\n    /**\\n     * @inheritdoc InterestRateModel\\n     */\\n    function INTEREST_RATE_MODEL_NAME() external pure override returns (string memory) {\\n        return \\\"WeightedInterestRateModel\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc InterestRateModel\\n     */\\n    function INTEREST_RATE_MODEL_VERSION() external pure override returns (string memory) {\\n        return \\\"1.0\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc InterestRateModel\\n     */\\n    function _rate(\\n        uint256 amount,\\n        uint64[] memory rates,\\n        ILiquidity.NodeSource[] memory nodes,\\n        uint16 count\\n    ) internal pure override returns (uint256) {\\n        uint256 weightedRate;\\n\\n        /* Accumulate weighted rate */\\n        for (uint256 i; i < count; i++) {\\n            (, , uint256 rateIndex, ) = Tick.decode(nodes[i].tick);\\n            weightedRate += (uint256(nodes[i].used) * rates[rateIndex]) / FIXED_POINT_SCALE;\\n        }\\n\\n        /* Return normalized weighted rate */\\n        return Math.mulDiv(weightedRate, FIXED_POINT_SCALE, amount);\\n    }\\n\\n    /**\\n     * @inheritdoc InterestRateModel\\n     */\\n    function _distribute(\\n        uint256 amount,\\n        uint256 interest,\\n        ILiquidity.NodeSource[] memory nodes,\\n        uint16 count\\n    ) internal view override returns (uint128[] memory) {\\n        /* Interest threshold for tick to receive interest */\\n        uint256 threshold = Math.mulDiv(_tickThreshold, amount, FIXED_POINT_SCALE);\\n\\n        /* Interest weight starting at final tick */\\n        uint256 base = _tickExponential;\\n        uint256 weight = (FIXED_POINT_SCALE * FIXED_POINT_SCALE) / base;\\n\\n        /* Assign weighted interest to ticks backwards */\\n        uint128[] memory pending = new uint128[](count);\\n        uint256 normalization;\\n        uint256 index = count;\\n        for (uint256 i; i < count; i++) {\\n            /* Skip tick if it's below threshold */\\n            if (nodes[--index].used <= threshold) continue;\\n\\n            /* Compute scaled weight */\\n            uint256 scaledWeight = Math.mulDiv(weight, nodes[index].used, amount);\\n\\n            /* Assign weighted interest */\\n            pending[index] = Math.mulDiv(scaledWeight, interest, FIXED_POINT_SCALE).toUint128();\\n\\n            /* Accumulate scaled weight for later normalization */\\n            normalization += scaledWeight;\\n\\n            /* Adjust interest weight for next tick */\\n            weight = Math.mulDiv(weight, FIXED_POINT_SCALE, base);\\n        }\\n\\n        /* Validate normalization is non-zero */\\n        if (normalization == 0) revert InsufficientUtilization();\\n\\n        /* Normalize weighted interest */\\n        for (uint256 i; i < count; i++) {\\n            /* Calculate normalized interest to tick */\\n            pending[i] = ((pending[i] * FIXED_POINT_SCALE) / normalization).toUint128();\\n\\n            /* Track remaining interest */\\n            interest -= pending[i];\\n        }\\n\\n        /* Drop off remaining dust at lowest tick */\\n        pending[0] += interest.toUint128();\\n\\n        return pending;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Tick.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\n/**\\n * @title Tick\\n * @author MetaStreet Labs\\n */\\nlibrary Tick {\\n    /*\\n     * A tick encodes three conditions on liquidity: limit, duration, and rate.\\n     * Limit is the maximum depth that liquidity sourced from the node can be\\n     * used in. Duration is the maximum allowed duration for that liquidity.\\n     * Rate is the interest rate associated with that liquidity. Duration and\\n     * rates are encoded as indexes into predetermined, discrete tiers.\\n     *\\n     * +-----------------------------------------------------------------------+\\n     * |                                 128                                   |\\n     * +--------------------------------------|----------|----------|----------+\\n     * |                  120                 |    3     |     3    |     2    |\\n     * |                 Limit                | Dur. Idx | Rate Idx | Reserved |\\n     * +-----------------------------------------------------------------------+\\n     *\\n     * Duration Index is ordered from shortest duration to longest, e.g. 7\\n     * days, 14 days, 30 days.\\n     *\\n     * Rate Index is ordered from lowest rate to highest rate, e.g. 10%, 30%,\\n     * 50%.\\n     */\\n\\n    /**************************************************************************/\\n    /* Constants */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Tick limit mask\\n     */\\n    uint256 internal constant TICK_LIMIT_MASK = 0xffffffffffffffffffffffffffffff;\\n\\n    /**\\n     * @notice Tick limit shift\\n     */\\n    uint256 internal constant TICK_LIMIT_SHIFT = 8;\\n\\n    /**\\n     * @notice Tick duration index mask\\n     */\\n    uint256 internal constant TICK_DURATION_MASK = 0x7;\\n\\n    /**\\n     * @notice Tick duration index shift\\n     */\\n    uint256 internal constant TICK_DURATION_SHIFT = 5;\\n\\n    /**\\n     * @notice Tick rate index mask\\n     */\\n    uint256 internal constant TICK_RATE_MASK = 0x7;\\n\\n    /**\\n     * @notice Tick rate index shift\\n     */\\n    uint256 internal constant TICK_RATE_SHIFT = 2;\\n\\n    /**\\n     * @notice Tick reserved mask\\n     */\\n    uint256 internal constant TICK_RESERVED_MASK = 0x3;\\n\\n    /**\\n     * @notice Tick reserved shift\\n     */\\n    uint256 internal constant TICK_RESERVED_SHIFT = 0;\\n\\n    /**\\n     * @notice Maximum number of durations supported\\n     */\\n    uint256 internal constant MAX_NUM_DURATIONS = TICK_DURATION_MASK + 1;\\n\\n    /**\\n     * @notice Maximum number of rates supported\\n     */\\n    uint256 internal constant MAX_NUM_RATES = TICK_RATE_MASK + 1;\\n\\n    /**************************************************************************/\\n    /* Errors */\\n    /**************************************************************************/\\n\\n    /**\\n     * @notice Invalid tick\\n     */\\n    error InvalidTick();\\n\\n    /**************************************************************************/\\n    /* Helper Functions */\\n    /**************************************************************************/\\n\\n    /**\\n     * @dev Decode a Tick\\n     * @param tick Tick\\n     * @return limit Limit field\\n     * @return duration Duration field\\n     * @return rate Rate field\\n     * @return reserved Reserved field\\n     */\\n    function decode(\\n        uint128 tick\\n    ) internal pure returns (uint256 limit, uint256 duration, uint256 rate, uint256 reserved) {\\n        limit = ((tick >> TICK_LIMIT_SHIFT) & TICK_LIMIT_MASK);\\n        duration = ((tick >> TICK_DURATION_SHIFT) & TICK_DURATION_MASK);\\n        rate = ((tick >> TICK_RATE_SHIFT) & TICK_RATE_MASK);\\n        reserved = ((tick >> TICK_RESERVED_SHIFT) & TICK_RESERVED_MASK);\\n    }\\n\\n    /**\\n     * @dev Validate a Tick (fast)\\n     * @param tick Tick\\n     * @param prevTick Previous tick\\n     * @param minDurationIndex Minimum Duration Index (inclusive)\\n     * @return Limit field\\n     */\\n    function validate(uint128 tick, uint256 prevTick, uint256 minDurationIndex) internal pure returns (uint256) {\\n        (uint256 limit, uint256 duration, , ) = decode(tick);\\n        if (tick <= prevTick) revert InvalidTick();\\n        if (duration < minDurationIndex) revert InvalidTick();\\n        return limit;\\n    }\\n\\n    /**\\n     * @dev Validate a Tick (slow)\\n     * @param tick Tick\\n     * @param minLimit Minimum Limit (exclusive)\\n     * @param minDurationIndex Minimum Duration Index (inclusive)\\n     * @param maxDurationIndex Maximum Duration Index (inclusive)\\n     * @param minRateIndex Minimum Rate Index (inclusive)\\n     * @param maxRateIndex Maximum Rate Index (inclusive)\\n     */\\n    function validate(\\n        uint128 tick,\\n        uint256 minLimit,\\n        uint256 minDurationIndex,\\n        uint256 maxDurationIndex,\\n        uint256 minRateIndex,\\n        uint256 maxRateIndex\\n    ) internal pure {\\n        (uint256 limit, uint256 duration, uint256 rate, uint256 reserved) = decode(tick);\\n        if (limit <= minLimit) revert InvalidTick();\\n        if (duration < minDurationIndex || duration > maxDurationIndex) revert InvalidTick();\\n        if (rate < minRateIndex || rate > maxRateIndex) revert InvalidTick();\\n        if (reserved != 0) revert InvalidTick();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralLiquidator_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegationRegistry_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"collateralWrappers\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"tickThreshold\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"tickExponential\",\"type\":\"uint64\"}],\"internalType\":\"struct WeightedInterestRateModel.Parameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InactiveLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientShares\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientTickSpacing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientUtilization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBorrowOptions\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLoanReceipt\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParameters\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReceiptEncoding\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRedemptionStatus\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTick\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LoanNotExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParameterOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RepaymentTooHigh\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"UnsupportedCollateral\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsupportedLoanDuration\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"AdminFeeRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AdminFeesWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanReceiptHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proceeds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowerProceeds\",\"type\":\"uint256\"}],\"name\":\"CollateralLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"tick\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanReceiptHash\",\"type\":\"bytes32\"}],\"name\":\"LoanLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanReceiptHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"loanReceipt\",\"type\":\"bytes\"}],\"name\":\"LoanOriginated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"loanReceiptHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayment\",\"type\":\"uint256\"}],\"name\":\"LoanRepaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"tick\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"tick\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BORROWER_SURPLUS_SPLIT_BASIS_POINTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COLLATERAL_FILTER_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COLLATERAL_FILTER_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IMPLEMENTATION_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IMPLEMENTATION_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INTEREST_RATE_MODEL_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INTEREST_RATE_MODEL_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TICK_LIMIT_SPACING_BASIS_POINTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminFeeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminFeeRate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRepayment\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"ticks\",\"type\":\"uint128[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"}],\"name\":\"borrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralLiquidator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralWrappers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currencyToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"loanReceipt\",\"type\":\"bytes\"}],\"name\":\"decodeLoanReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repayment\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"maturity\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"collateralWrapperContextLen\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"collateralWrapperContext\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"tick\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"used\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"pending\",\"type\":\"uint128\"}],\"internalType\":\"struct LoanReceipt.NodeReceipt[]\",\"name\":\"nodeReceipts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LoanReceipt.LoanReceiptV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delegationRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"tick\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minShares\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"tick\",\"type\":\"uint128\"}],\"name\":\"deposits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"shares\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"redemptionPending\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"redemptionIndex\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"redemptionTarget\",\"type\":\"uint128\"}],\"internalType\":\"struct Pool.Deposit\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"durations\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedLoanReceipt\",\"type\":\"bytes\"}],\"name\":\"liquidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"tick\",\"type\":\"uint128\"}],\"name\":\"liquidityNode\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"tick\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"shares\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"available\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"pending\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"redemptions\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"prev\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"next\",\"type\":\"uint128\"}],\"internalType\":\"struct ILiquidity.NodeInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"startTick\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endTick\",\"type\":\"uint128\"}],\"name\":\"liquidityNodes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"tick\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"shares\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"available\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"pending\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"redemptions\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"prev\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"next\",\"type\":\"uint128\"}],\"internalType\":\"struct ILiquidity.NodeInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"receiptHash\",\"type\":\"bytes32\"}],\"name\":\"loans\",\"outputs\":[{\"internalType\":\"enum Pool.LoanStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedLoanReceipt\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"proceeds\",\"type\":\"uint256\"}],\"name\":\"onCollateralLiquidated\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"collateralTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128[]\",\"name\":\"ticks\",\"type\":\"uint128[]\"},{\"internalType\":\"bytes\",\"name\":\"options\",\"type\":\"bytes\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedLoanReceipt\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"},{\"internalType\":\"uint128[]\",\"name\":\"ticks\",\"type\":\"uint128[]\"}],\"name\":\"quoteRefinance\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rates\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"srcTick\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"dstTick\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"minShares\",\"type\":\"uint256\"}],\"name\":\"rebalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"tick\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"tick\",\"type\":\"uint128\"}],\"name\":\"redemptionAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedLoanReceipt\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"maxRepayment\",\"type\":\"uint256\"},{\"internalType\":\"uint128[]\",\"name\":\"ticks\",\"type\":\"uint128[]\"}],\"name\":\"refinance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedLoanReceipt\",\"type\":\"bytes\"}],\"name\":\"repay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"rate\",\"type\":\"uint32\"}],\"name\":\"setAdminFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"tick\",\"type\":\"uint128\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAdminFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WeightedRateCollectionPool", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e0194f47040e2424b8a65cb5f7112a5dbe1f93bf00000000000000000000000000000000000076a84fef008cdabe6409d2fe638b00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000002386f26fc100000000000000000000000000000000000000000000000000001bc16d674ec800000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c4dc9ef8763433aae26635bc5a09e362605fad180000000000000000000000005f264625e6400102a2f5e9a5d6e006c7a6d41285", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}