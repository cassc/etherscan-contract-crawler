{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.23;\r\n\r\n\r\ninterface IERC165 {\r\n\t/// @notice Query if a contract implements an interface\r\n\t/// @param interfaceID The interface identifier, as specified in ERC-165\r\n\t/// @dev Interface identification is specified in ERC-165. This function\r\n\t/// uses less than 30,000 gas.\r\n\t/// @return `true` if the contract implements `interfaceID` and\r\n\t/// `interfaceID` is not 0xffffffff, `false` otherwise\r\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface IERC721 is IERC165 {\r\n\t/// @dev This emits when ownership of any NFT changes by any mechanism.\r\n\t/// This event emits when NFTs are created (`from` == 0) and destroyed\r\n\t/// (`to` == 0). Exception: during contract creation, any number of NFTs\r\n\t/// may be created and assigned without emitting Transfer. At the time of\r\n\t/// any transfer, the approved address for that NFT (if any) is reset to none.\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n\t/// @dev This emits when the approved address for an NFT is changed or\r\n\t/// reaffirmed. The zero address indicates there is no approved address.\r\n\t/// When a Transfer event emits, this also indicates that the approved\r\n\t/// address for that NFT (if any) is reset to none.\r\n\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n\t/// @dev This emits when an operator is enabled or disabled for an owner.\r\n\t/// The operator can manage all NFTs of the owner.\r\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n\t/// @notice Count all NFTs assigned to an owner\r\n\t/// @dev NFTs assigned to the zero address are considered invalid, and this\r\n\t/// function throws for queries about the zero address.\r\n\t/// @param _owner An address for whom to query the balance\r\n\t/// @return The number of NFTs owned by `_owner`, possibly zero\r\n\tfunction balanceOf(address _owner) external view returns (uint256);\r\n\r\n\t/// @notice Find the owner of an NFT\r\n\t/// @dev NFTs assigned to zero address are considered invalid, and queries\r\n\t/// about them do throw.\r\n\t/// @param _tokenId The identifier for an NFT\r\n\t/// @return The address of the owner of the NFT\r\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n\t/// @notice Transfers the ownership of an NFT from one address to another address\r\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n\t/// operator, or the approved address for this NFT. Throws if `_from` is\r\n\t/// not the current owner. Throws if `_to` is the zero address. Throws if\r\n\t/// `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n\t/// checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n\t/// `onERC721Received` on `_to` and throws if the return value is not\r\n\t/// `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n\t/// @param _from The current owner of the NFT\r\n\t/// @param _to The new owner\r\n\t/// @param _tokenId The NFT to transfer\r\n\t/// @param data Additional data with no specified format, sent in call to `_to`\r\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n\t/// @notice Transfers the ownership of an NFT from one address to another address\r\n\t/// @dev This works identically to the other function with an extra data parameter,\r\n\t/// except this function just sets data to \"\".\r\n\t/// @param _from The current owner of the NFT\r\n\t/// @param _to The new owner\r\n\t/// @param _tokenId The NFT to transfer\r\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n\t/// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n\t/// THEY MAY BE PERMANENTLY LOST\r\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n\t/// operator, or the approved address for this NFT. Throws if `_from` is\r\n\t/// not the current owner. Throws if `_to` is the zero address. Throws if\r\n\t/// `_tokenId` is not a valid NFT.\r\n\t/// @param _from The current owner of the NFT\r\n\t/// @param _to The new owner\r\n\t/// @param _tokenId The NFT to transfer\r\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n\t/// @notice Change or reaffirm the approved address for an NFT\r\n\t/// @dev The zero address indicates there is no approved address.\r\n\t/// Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n\t/// operator of the current owner.\r\n\t/// @param _approved The new approved NFT controller\r\n\t/// @param _tokenId The NFT to approve\r\n\tfunction approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n\t/// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n\t/// all of `msg.sender`'s assets\r\n\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n\t/// multiple operators per owner.\r\n\t/// @param _operator Address to add to the set of authorized operators\r\n\t/// @param _approved True if the operator is approved, false to revoke approval\r\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n\t/// @notice Get the approved address for a single NFT\r\n\t/// @dev Throws if `_tokenId` is not a valid NFT.\r\n\t/// @param _tokenId The NFT to find the approved address for\r\n\t/// @return The approved address for this NFT, or the zero address if there is none\r\n\tfunction getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n\t/// @notice Query if an address is an authorized operator for another address\r\n\t/// @param _owner The address that owns the NFTs\r\n\t/// @param _operator The address that acts on behalf of the owner\r\n\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface IERC721TokenReceiver {\r\n\t/// @notice Handle the receipt of an NFT\r\n\t/// @dev The ERC721 smart contract calls this function on the recipient\r\n\t/// after a `transfer`. This function MAY throw to revert and reject the\r\n\t/// transfer. Return of other than the magic value MUST result in the\r\n\t/// transaction being reverted.\r\n\t/// Note: the contract address is always the message sender.\r\n\t/// @param _operator The address which called `safeTransferFrom` function\r\n\t/// @param _from The address which previously owned the token\r\n\t/// @param _tokenId The NFT identifier which is being transferred\r\n\t/// @param _data Additional data with no specified format\r\n\t/// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n\t///  unless throwing\r\n\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)\r\n\texternal\r\n\treturns (bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Tree proofs.\r\n *\r\n * The tree and the proofs can be generated using our\r\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\r\n * You will find a quickstart guide in the readme.\r\n *\r\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\r\n * hashing, or use a hash function other than keccak256 for hashing leaves.\r\n * This is because the concatenation of a sorted pair of internal nodes in\r\n * the Merkle tree could be reinterpreted as a leaf value.\r\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\r\n * against this attack out of the box.\r\n */\r\nlibrary MerkleProof {\r\n\t/**\r\n\t *@dev The multiproof provided is not valid.\r\n     */\r\n\terror MerkleProofInvalidMultiproof();\r\n\r\n\t/**\r\n\t * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n\tfunction verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n\t\treturn processProof(proof, leaf) == root;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calldata version of {verify}\r\n     */\r\n\tfunction verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n\t\treturn processProofCalldata(proof, leaf) == root;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     */\r\n\tfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n\t\tbytes32 computedHash = leaf;\r\n\t\tfor (uint256 i = 0; i < proof.length; i++) {\r\n\t\t\tcomputedHash = _hashPair(computedHash, proof[i]);\r\n\t\t}\r\n\t\treturn computedHash;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calldata version of {processProof}\r\n     */\r\n\tfunction processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\r\n\t\tbytes32 computedHash = leaf;\r\n\t\tfor (uint256 i = 0; i < proof.length; i++) {\r\n\t\t\tcomputedHash = _hashPair(computedHash, proof[i]);\r\n\t\t}\r\n\t\treturn computedHash;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\r\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     */\r\n\tfunction multiProofVerify(\r\n\t\tbytes32[] memory proof,\r\n\t\tbool[] memory proofFlags,\r\n\t\tbytes32 root,\r\n\t\tbytes32[] memory leaves\r\n\t) internal pure returns (bool) {\r\n\t\treturn processMultiProof(proof, proofFlags, leaves) == root;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calldata version of {multiProofVerify}\r\n     *\r\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     */\r\n\tfunction multiProofVerifyCalldata(\r\n\t\tbytes32[] calldata proof,\r\n\t\tbool[] calldata proofFlags,\r\n\t\tbytes32 root,\r\n\t\tbytes32[] memory leaves\r\n\t) internal pure returns (bool) {\r\n\t\treturn processMultiProofCalldata(proof, proofFlags, leaves) == root;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\r\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\r\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\r\n     * respectively.\r\n     *\r\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\r\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\r\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\r\n     */\r\n\tfunction processMultiProof(\r\n\t\tbytes32[] memory proof,\r\n\t\tbool[] memory proofFlags,\r\n\t\tbytes32[] memory leaves\r\n\t) internal pure returns (bytes32 merkleRoot) {\r\n\t\t// This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n\t\t// consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n\t\t// `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n\t\t// the Merkle tree.\r\n\t\tuint256 leavesLen = leaves.length;\r\n\t\tuint256 proofLen = proof.length;\r\n\t\tuint256 totalHashes = proofFlags.length;\r\n\r\n\t\t// Check proof validity.\r\n\t\tif (leavesLen + proofLen != totalHashes + 1) {\r\n\t\t\trevert MerkleProofInvalidMultiproof();\r\n\t\t}\r\n\r\n\t\t// The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n\t\t// `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n\t\tbytes32[] memory hashes = new bytes32[](totalHashes);\r\n\t\tuint256 leafPos = 0;\r\n\t\tuint256 hashPos = 0;\r\n\t\tuint256 proofPos = 0;\r\n\t\t// At each step, we compute the next hash using two values:\r\n\t\t// - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n\t\t//   get the next hash.\r\n\t\t// - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n\t\t//   `proof` array.\r\n\t\tfor (uint256 i = 0; i < totalHashes; i++) {\r\n\t\t\tbytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n\t\t\tbytes32 b = proofFlags[i]\r\n\t\t\t\t? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n\t\t\t\t: proof[proofPos++];\r\n\t\t\thashes[i] = _hashPair(a, b);\r\n\t\t}\r\n\r\n\t\tif (totalHashes > 0) {\r\n\t\t\tif (proofPos != proofLen) {\r\n\t\t\t\trevert MerkleProofInvalidMultiproof();\r\n\t\t\t}\r\n\t\t\tunchecked {\r\n\t\t\t\treturn hashes[totalHashes - 1];\r\n\t\t\t}\r\n\t\t} else if (leavesLen > 0) {\r\n\t\t\treturn leaves[0];\r\n\t\t} else {\r\n\t\t\treturn proof[0];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calldata version of {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     */\r\n\tfunction processMultiProofCalldata(\r\n\t\tbytes32[] calldata proof,\r\n\t\tbool[] calldata proofFlags,\r\n\t\tbytes32[] memory leaves\r\n\t) internal pure returns (bytes32 merkleRoot) {\r\n\t\t// This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n\t\t// consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n\t\t// `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n\t\t// the Merkle tree.\r\n\t\tuint256 leavesLen = leaves.length;\r\n\t\tuint256 proofLen = proof.length;\r\n\t\tuint256 totalHashes = proofFlags.length;\r\n\r\n\t\t// Check proof validity.\r\n\t\tif (leavesLen + proofLen != totalHashes + 1) {\r\n\t\t\trevert MerkleProofInvalidMultiproof();\r\n\t\t}\r\n\r\n\t\t// The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n\t\t// `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n\t\tbytes32[] memory hashes = new bytes32[](totalHashes);\r\n\t\tuint256 leafPos = 0;\r\n\t\tuint256 hashPos = 0;\r\n\t\tuint256 proofPos = 0;\r\n\t\t// At each step, we compute the next hash using two values:\r\n\t\t// - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n\t\t//   get the next hash.\r\n\t\t// - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n\t\t//   `proof` array.\r\n\t\tfor (uint256 i = 0; i < totalHashes; i++) {\r\n\t\t\tbytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n\t\t\tbytes32 b = proofFlags[i]\r\n\t\t\t\t? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n\t\t\t\t: proof[proofPos++];\r\n\t\t\thashes[i] = _hashPair(a, b);\r\n\t\t}\r\n\r\n\t\tif (totalHashes > 0) {\r\n\t\t\tif (proofPos != proofLen) {\r\n\t\t\t\trevert MerkleProofInvalidMultiproof();\r\n\t\t\t}\r\n\t\t\tunchecked {\r\n\t\t\t\treturn hashes[totalHashes - 1];\r\n\t\t\t}\r\n\t\t} else if (leavesLen > 0) {\r\n\t\t\treturn leaves[0];\r\n\t\t} else {\r\n\t\t\treturn proof[0];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sorts the pair (a, b) and hashes the result.\r\n     */\r\n\tfunction _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\r\n\t\treturn a < b ? _efficientHash(a, b) : _efficientHash(b, a);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\r\n     */\r\n\tfunction _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tmstore(0x00, a)\r\n\t\t\tmstore(0x20, b)\r\n\t\t\tvalue := keccak256(0x00, 0x40)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n\t/**\r\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t/**\r\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n\t/**\r\n\t * @dev Returns the value of tokens in existence.\r\n     */\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n\tfunction transfer(address to, uint256 value) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n\tfunction approve(address spender, uint256 value) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\r\n\t\treturn msg.data;\r\n\t}\r\n\r\n\tfunction _contextSuffixLength() internal view virtual returns (uint256) {\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n\taddress private _owner;\r\n\r\n\t/**\r\n\t * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n\terror OwnableUnauthorizedAccount(address account);\r\n\r\n\t/**\r\n\t * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n\terror OwnableInvalidOwner(address owner);\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n\tconstructor(address initialOwner) {\r\n\t\tif (initialOwner == address(0)) {\r\n\t\t\trevert OwnableInvalidOwner(address(0));\r\n\t\t}\r\n\t\t_transferOwnership(initialOwner);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n     */\r\n\tmodifier onlyOwner() {\r\n\t\t_checkOwner();\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n     */\r\n\tfunction owner() public view virtual returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if the sender is not the owner.\r\n     */\r\n\tfunction _checkOwner() internal view virtual {\r\n\t\tif (owner() != _msgSender()) {\r\n\t\t\trevert OwnableUnauthorizedAccount(_msgSender());\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\t_transferOwnership(address(0));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\tif (newOwner == address(0)) {\r\n\t\t\trevert OwnableInvalidOwner(address(0));\r\n\t\t}\r\n\t\t_transferOwnership(newOwner);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n\tfunction _transferOwnership(address newOwner) internal virtual {\r\n\t\taddress oldOwner = _owner;\r\n\t\t_owner = newOwner;\r\n\t\temit OwnershipTransferred(oldOwner, newOwner);\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n\t/**\r\n\t * @dev Muldiv operation overflow.\r\n     */\r\n\terror MathOverflowedMulDiv();\r\n\r\n\tenum Rounding {\r\n\t\tFloor, // Toward negative infinity\r\n\t\tCeil, // Toward positive infinity\r\n\t\tTrunc, // Toward zero\r\n\t\tExpand // Away from zero\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     */\r\n\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\tuint256 c = a + b;\r\n\t\t\tif (c < a) return (false, 0);\r\n\t\t\treturn (true, c);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     */\r\n\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\tif (b > a) return (false, 0);\r\n\t\t\treturn (true, a - b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     */\r\n\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n\t\t\tif (a == 0) return (true, 0);\r\n\t\t\tuint256 c = a * b;\r\n\t\t\tif (c / a != b) return (false, 0);\r\n\t\t\treturn (true, c);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     */\r\n\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\tif (b == 0) return (false, 0);\r\n\t\t\treturn (true, a / b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     */\r\n\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\tif (b == 0) return (false, 0);\r\n\t\t\treturn (true, a % b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the largest of two numbers.\r\n     */\r\n\tfunction max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a > b ? a : b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the smallest of two numbers.\r\n     */\r\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a < b ? a : b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n\tfunction average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// (a + b) / 2 can overflow.\r\n\t\treturn (a & b) + (a ^ b) / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds towards infinity instead\r\n     * of rounding towards zero.\r\n     */\r\n\tfunction ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (b == 0) {\r\n\t\t\t// Guarantee the same behavior as in a regular Solidity division.\r\n\t\t\treturn a / b;\r\n\t\t}\r\n\r\n\t\t// (a + b - 1) / b can overflow on addition, so we distribute.\r\n\t\treturn a == 0 ? 0 : (a - 1) / b + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\r\n     * denominator == 0.\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\r\n     * Uniswap Labs also under MIT license.\r\n     */\r\n\tfunction mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n\t\tunchecked {\r\n\t\t// 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n\t\t// use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n\t\t// variables such that product = prod1 * 2^256 + prod0.\r\n\t\t\tuint256 prod0 = x * y; // Least significant 256 bits of the product\r\n\t\t\tuint256 prod1; // Most significant 256 bits of the product\r\n\t\t\tassembly {\r\n\t\t\t\tlet mm := mulmod(x, y, not(0))\r\n\t\t\t\tprod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n\t\t\t}\r\n\r\n\t\t// Handle non-overflow cases, 256 by 256 division.\r\n\t\t\tif (prod1 == 0) {\r\n\t\t\t\t// Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n\t\t\t\t// The surrounding unchecked block does not change this fact.\r\n\t\t\t\t// See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n\t\t\t\treturn prod0 / denominator;\r\n\t\t\t}\r\n\r\n\t\t// Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n\t\t\tif (denominator <= prod1) {\r\n\t\t\t\trevert MathOverflowedMulDiv();\r\n\t\t\t}\r\n\r\n\t\t///////////////////////////////////////////////\r\n\t\t// 512 by 256 division.\r\n\t\t///////////////////////////////////////////////\r\n\r\n\t\t// Make division exact by subtracting the remainder from [prod1 prod0].\r\n\t\t\tuint256 remainder;\r\n\t\t\tassembly {\r\n\t\t\t// Compute remainder using mulmod.\r\n\t\t\t\tremainder := mulmod(x, y, denominator)\r\n\r\n\t\t\t// Subtract 256 bit number from 512 bit number.\r\n\t\t\t\tprod1 := sub(prod1, gt(remainder, prod0))\r\n\t\t\t\tprod0 := sub(prod0, remainder)\r\n\t\t\t}\r\n\r\n\t\t// Factor powers of two out of denominator and compute largest power of two divisor of denominator.\r\n\t\t// Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n\t\t\tuint256 twos = denominator & (0 - denominator);\r\n\t\t\tassembly {\r\n\t\t\t// Divide denominator by twos.\r\n\t\t\t\tdenominator := div(denominator, twos)\r\n\r\n\t\t\t// Divide [prod1 prod0] by twos.\r\n\t\t\t\tprod0 := div(prod0, twos)\r\n\r\n\t\t\t// Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n\t\t\t\ttwos := add(div(sub(0, twos), twos), 1)\r\n\t\t\t}\r\n\r\n\t\t// Shift in bits from prod1 into prod0.\r\n\t\t\tprod0 |= prod1 * twos;\r\n\r\n\t\t// Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n\t\t// that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n\t\t// four bits. That is, denominator * inv = 1 mod 2^4.\r\n\t\t\tuint256 inverse = (3 * denominator) ^ 2;\r\n\r\n\t\t// Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\r\n\t\t// works in modular arithmetic, doubling the correct bits in each step.\r\n\t\t\tinverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n\t\t\tinverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n\t\t\tinverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n\t\t\tinverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n\t\t\tinverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n\t\t\tinverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n\t\t// Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n\t\t// This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n\t\t// less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n\t\t// is no longer required.\r\n\t\t\tresult = prod0 * inverse;\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n\tfunction mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n\t\tuint256 result = mulDiv(x, y, denominator);\r\n\t\tif (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\r\n\t\t\tresult += 1;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\r\n     * towards zero.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n\tfunction sqrt(uint256 a) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n\t\t//\r\n\t\t// We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n\t\t// `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n\t\t//\r\n\t\t// This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n\t\t// \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n\t\t// \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n\t\t//\r\n\t\t// Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n\t\tuint256 result = 1 << (log2(a) >> 1);\r\n\r\n\t\t// At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n\t\t// since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n\t\t// every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n\t\t// into the expected uint128 result.\r\n\t\tunchecked {\r\n\t\t\tresult = (result + a / result) >> 1;\r\n\t\t\tresult = (result + a / result) >> 1;\r\n\t\t\tresult = (result + a / result) >> 1;\r\n\t\t\tresult = (result + a / result) >> 1;\r\n\t\t\tresult = (result + a / result) >> 1;\r\n\t\t\tresult = (result + a / result) >> 1;\r\n\t\t\tresult = (result + a / result) >> 1;\r\n\t\t\treturn min(result, a / result);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n\tfunction sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\tuint256 result = sqrt(a);\r\n\t\t\treturn result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the log in base 2 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n\tfunction log2(uint256 value) internal pure returns (uint256) {\r\n\t\tuint256 result = 0;\r\n\t\tunchecked {\r\n\t\t\tif (value >> 128 > 0) {\r\n\t\t\t\tvalue >>= 128;\r\n\t\t\t\tresult += 128;\r\n\t\t\t}\r\n\t\t\tif (value >> 64 > 0) {\r\n\t\t\t\tvalue >>= 64;\r\n\t\t\t\tresult += 64;\r\n\t\t\t}\r\n\t\t\tif (value >> 32 > 0) {\r\n\t\t\t\tvalue >>= 32;\r\n\t\t\t\tresult += 32;\r\n\t\t\t}\r\n\t\t\tif (value >> 16 > 0) {\r\n\t\t\t\tvalue >>= 16;\r\n\t\t\t\tresult += 16;\r\n\t\t\t}\r\n\t\t\tif (value >> 8 > 0) {\r\n\t\t\t\tvalue >>= 8;\r\n\t\t\t\tresult += 8;\r\n\t\t\t}\r\n\t\t\tif (value >> 4 > 0) {\r\n\t\t\t\tvalue >>= 4;\r\n\t\t\t\tresult += 4;\r\n\t\t\t}\r\n\t\t\tif (value >> 2 > 0) {\r\n\t\t\t\tvalue >>= 2;\r\n\t\t\t\tresult += 2;\r\n\t\t\t}\r\n\t\t\tif (value >> 1 > 0) {\r\n\t\t\t\tresult += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n\tfunction log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\tuint256 result = log2(value);\r\n\t\t\treturn result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the log in base 10 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n\tfunction log10(uint256 value) internal pure returns (uint256) {\r\n\t\tuint256 result = 0;\r\n\t\tunchecked {\r\n\t\t\tif (value >= 10 ** 64) {\r\n\t\t\t\tvalue /= 10 ** 64;\r\n\t\t\t\tresult += 64;\r\n\t\t\t}\r\n\t\t\tif (value >= 10 ** 32) {\r\n\t\t\t\tvalue /= 10 ** 32;\r\n\t\t\t\tresult += 32;\r\n\t\t\t}\r\n\t\t\tif (value >= 10 ** 16) {\r\n\t\t\t\tvalue /= 10 ** 16;\r\n\t\t\t\tresult += 16;\r\n\t\t\t}\r\n\t\t\tif (value >= 10 ** 8) {\r\n\t\t\t\tvalue /= 10 ** 8;\r\n\t\t\t\tresult += 8;\r\n\t\t\t}\r\n\t\t\tif (value >= 10 ** 4) {\r\n\t\t\t\tvalue /= 10 ** 4;\r\n\t\t\t\tresult += 4;\r\n\t\t\t}\r\n\t\t\tif (value >= 10 ** 2) {\r\n\t\t\t\tvalue /= 10 ** 2;\r\n\t\t\t\tresult += 2;\r\n\t\t\t}\r\n\t\t\tif (value >= 10 ** 1) {\r\n\t\t\t\tresult += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n\tfunction log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\tuint256 result = log10(value);\r\n\t\t\treturn result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the log in base 256 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n\tfunction log256(uint256 value) internal pure returns (uint256) {\r\n\t\tuint256 result = 0;\r\n\t\tunchecked {\r\n\t\t\tif (value >> 128 > 0) {\r\n\t\t\t\tvalue >>= 128;\r\n\t\t\t\tresult += 16;\r\n\t\t\t}\r\n\t\t\tif (value >> 64 > 0) {\r\n\t\t\t\tvalue >>= 64;\r\n\t\t\t\tresult += 8;\r\n\t\t\t}\r\n\t\t\tif (value >> 32 > 0) {\r\n\t\t\t\tvalue >>= 32;\r\n\t\t\t\tresult += 4;\r\n\t\t\t}\r\n\t\t\tif (value >> 16 > 0) {\r\n\t\t\t\tvalue >>= 16;\r\n\t\t\t\tresult += 2;\r\n\t\t\t}\r\n\t\t\tif (value >> 8 > 0) {\r\n\t\t\t\tresult += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n\tfunction log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\tuint256 result = log256(value);\r\n\t\t\treturn result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\r\n     */\r\n\tfunction unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\r\n\t\treturn uint8(rounding) % 2 == 1;\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n\t/**\r\n\t * @dev Returns the largest of two signed numbers.\r\n     */\r\n\tfunction max(int256 a, int256 b) internal pure returns (int256) {\r\n\t\treturn a > b ? a : b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the smallest of two signed numbers.\r\n     */\r\n\tfunction min(int256 a, int256 b) internal pure returns (int256) {\r\n\t\treturn a < b ? a : b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the average of two signed numbers without overflow.\r\n     * The result is rounded towards zero.\r\n     */\r\n\tfunction average(int256 a, int256 b) internal pure returns (int256) {\r\n\t\t// Formula from the book \"Hacker's Delight\"\r\n\t\tint256 x = (a & b) + ((a ^ b) >> 1);\r\n\t\treturn x + (int256(uint256(x) >> 255) & (a ^ b));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the absolute unsigned value of a signed value.\r\n     */\r\n\tfunction abs(int256 n) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t// must be unchecked in order to support `n = type(int256).min`\r\n\t\t\treturn uint256(n >= 0 ? n : -n);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n\tbytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\r\n\tuint8 private constant ADDRESS_LENGTH = 20;\r\n\r\n\t/**\r\n\t * @dev The `value` string doesn't fit in the specified `length`.\r\n     */\r\n\terror StringsInsufficientHexLength(uint256 value, uint256 length);\r\n\r\n\t/**\r\n\t * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n\tfunction toString(uint256 value) internal pure returns (string memory) {\r\n\t\tunchecked {\r\n\t\t\tuint256 length = Math.log10(value) + 1;\r\n\t\t\tstring memory buffer = new string(length);\r\n\t\t\tuint256 ptr;\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\t\tassembly {\r\n\t\t\t\tptr := add(buffer, add(32, length))\r\n\t\t\t}\r\n\t\t\twhile (true) {\r\n\t\t\t\tptr--;\r\n\t\t\t\t/// @solidity memory-safe-assembly\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tmstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\r\n\t\t\t\t}\r\n\t\t\t\tvalue /= 10;\r\n\t\t\t\tif (value == 0) break;\r\n\t\t\t}\r\n\t\t\treturn buffer;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n     */\r\n\tfunction toStringSigned(int256 value) internal pure returns (string memory) {\r\n\t\treturn string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n\tfunction toHexString(uint256 value) internal pure returns (string memory) {\r\n\t\tunchecked {\r\n\t\t\treturn toHexString(value, Math.log256(value) + 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n\t\tuint256 localValue = value;\r\n\t\tbytes memory buffer = new bytes(2 * length + 2);\r\n\t\tbuffer[0] = \"0\";\r\n\t\tbuffer[1] = \"x\";\r\n\t\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\r\n\t\t\tbuffer[i] = HEX_DIGITS[localValue & 0xf];\r\n\t\t\tlocalValue >>= 4;\r\n\t\t}\r\n\t\tif (localValue != 0) {\r\n\t\t\trevert StringsInsufficientHexLength(value, length);\r\n\t\t}\r\n\t\treturn string(buffer);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\r\n     * representation.\r\n     */\r\n\tfunction toHexString(address addr) internal pure returns (string memory) {\r\n\t\treturn toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns true if the two strings are equal.\r\n     */\r\n\tfunction equal(string memory a, string memory b) internal pure returns (bool) {\r\n\t\treturn bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n\t// Booleans are more expensive than uint256 or any type that takes up a full\r\n\t// word because each write operation emits an extra SLOAD to first read the\r\n\t// slot's contents, replace the bits taken up by the boolean, and then write\r\n\t// back. This is the compiler's defense against contract upgrades and\r\n\t// pointer aliasing, and it cannot be disabled.\r\n\r\n\t// The values being non-zero value makes deployment a bit more expensive,\r\n\t// but in exchange the refund on every call to nonReentrant will be lower in\r\n\t// amount. Since refunds are capped to a percentage of the total\r\n\t// transaction's gas, it is best to keep them low in cases like this one, to\r\n\t// increase the likelihood of the full refund coming into effect.\r\n\tuint256 private constant NOT_ENTERED = 1;\r\n\tuint256 private constant ENTERED = 2;\r\n\r\n\tuint256 private _status;\r\n\r\n\t/**\r\n\t * @dev Unauthorized reentrant call.\r\n     */\r\n\terror ReentrancyGuardReentrantCall();\r\n\r\n\tconstructor() {\r\n\t\t_status = NOT_ENTERED;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n\tmodifier nonReentrant() {\r\n\t\t_nonReentrantBefore();\r\n\t\t_;\r\n\t\t_nonReentrantAfter();\r\n\t}\r\n\r\n\tfunction _nonReentrantBefore() private {\r\n\t\t// On the first call to nonReentrant, _status will be NOT_ENTERED\r\n\t\tif (_status == ENTERED) {\r\n\t\t\trevert ReentrancyGuardReentrantCall();\r\n\t\t}\r\n\r\n\t\t// Any calls to nonReentrant after this point will fail\r\n\t\t_status = ENTERED;\r\n\t}\r\n\r\n\tfunction _nonReentrantAfter() private {\r\n\t\t// By storing the original value once again, a refund is triggered (see\r\n\t\t// https://eips.ethereum.org/EIPS/eip-2200)\r\n\t\t_status = NOT_ENTERED;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n\tfunction _reentrancyGuardEntered() internal view returns (bool) {\r\n\t\treturn _status == ENTERED;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title IDelegateRegistry\r\n * @custom:version 2.0\r\n * @custom:author foobar (0xfoobar)\r\n * @notice A standalone immutable registry storing delegated permissions from one address to another\r\n */\r\ninterface IDelegateRegistry {\r\n\t/// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\r\n\tenum DelegationType {\r\n\t\tNONE,\r\n\t\tALL,\r\n\t\tCONTRACT,\r\n\t\tERC721,\r\n\t\tERC20,\r\n\t\tERC1155\r\n\t}\r\n\r\n\t/// @notice Struct for returning delegations\r\n\tstruct Delegation {\r\n\t\tDelegationType type_;\r\n\t\taddress to;\r\n\t\taddress from;\r\n\t\tbytes32 rights;\r\n\t\taddress contract_;\r\n\t\tuint256 tokenId;\r\n\t\tuint256 amount;\r\n\t}\r\n\r\n\t/// @notice Emitted when an address delegates or revokes rights for their entire wallet\r\n\tevent DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\r\n\r\n\t/// @notice Emitted when an address delegates or revokes rights for a contract address\r\n\tevent DelegateContract(address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable);\r\n\r\n\t/// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\r\n\tevent DelegateERC721(address indexed from, address indexed to, address indexed contract_, uint256 tokenId, bytes32 rights, bool enable);\r\n\r\n\t/// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\r\n\tevent DelegateERC20(address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount);\r\n\r\n\t/// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\r\n\tevent DelegateERC1155(address indexed from, address indexed to, address indexed contract_, uint256 tokenId, bytes32 rights, uint256 amount);\r\n\r\n\t/// @notice Thrown if multicall calldata is malformed\r\n\terror MulticallFailed();\r\n\r\n\t/**\r\n\t * -----------  WRITE -----------\r\n\t */\r\n\r\n\t/**\r\n\t * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\r\n     * @param data The encoded function data for each of the calls to make to this contract\r\n     * @return results The results from each of the calls passed in via data\r\n     */\r\n\tfunction multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\r\n\r\n\t/**\r\n\t * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\r\n     * @param to The address to act as delegate\r\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\r\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\r\n     * @return delegationHash The unique identifier of the delegation\r\n     */\r\n\tfunction delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\r\n\r\n\t/**\r\n\t * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\r\n     * @param to The address to act as delegate\r\n     * @param contract_ The contract whose rights are being delegated\r\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\r\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\r\n     * @return delegationHash The unique identifier of the delegation\r\n     */\r\n\tfunction delegateContract(address to, address contract_, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\r\n\r\n\t/**\r\n\t * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\r\n     * @param to The address to act as delegate\r\n     * @param contract_ The contract whose rights are being delegated\r\n     * @param tokenId The token id to delegate\r\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\r\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\r\n     * @return delegationHash The unique identifier of the delegation\r\n     */\r\n\tfunction delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\r\n\r\n\t/**\r\n\t * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\r\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\r\n     * @param to The address to act as delegate\r\n     * @param contract_ The address for the fungible token contract\r\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\r\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\r\n     * @return delegationHash The unique identifier of the delegation\r\n     */\r\n\tfunction delegateERC20(address to, address contract_, bytes32 rights, uint256 amount) external payable returns (bytes32 delegationHash);\r\n\r\n\t/**\r\n\t * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\r\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\r\n     * @param to The address to act as delegate\r\n     * @param contract_ The address of the contract that holds the token\r\n     * @param tokenId The token id to delegate\r\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\r\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\r\n     * @return delegationHash The unique identifier of the delegation\r\n     */\r\n\tfunction delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount) external payable returns (bytes32 delegationHash);\r\n\r\n\t/**\r\n\t * ----------- CHECKS -----------\r\n\t */\r\n\r\n\t/**\r\n\t * @notice Check if `to` is a delegate of `from` for the entire wallet\r\n     * @param to The potential delegate address\r\n     * @param from The potential address who delegated rights\r\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\r\n     * @return valid Whether delegate is granted to act on the from's behalf\r\n     */\r\n\tfunction checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\r\n\r\n\t/**\r\n\t * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\r\n     * @param to The delegated address to check\r\n     * @param contract_ The specific contract address being checked\r\n     * @param from The cold wallet who issued the delegation\r\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\r\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\r\n     */\r\n\tfunction checkDelegateForContract(address to, address from, address contract_, bytes32 rights) external view returns (bool);\r\n\r\n\t/**\r\n\t * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\r\n     * @param to The delegated address to check\r\n     * @param contract_ The specific contract address being checked\r\n     * @param tokenId The token id for the token to delegating\r\n     * @param from The wallet that issued the delegation\r\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\r\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\r\n     */\r\n\tfunction checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights) external view returns (bool);\r\n\r\n\t/**\r\n\t * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\r\n     * @param to The delegated address to check\r\n     * @param contract_ The address of the token contract\r\n     * @param from The cold wallet who issued the delegation\r\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\r\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\r\n     */\r\n\tfunction checkDelegateForERC20(address to, address from, address contract_, bytes32 rights) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\r\n     * @param to The delegated address to check\r\n     * @param contract_ The address of the token contract\r\n     * @param tokenId The token id to check the delegated amount of\r\n     * @param from The cold wallet who issued the delegation\r\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\r\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\r\n     */\r\n\tfunction checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights) external view returns (uint256);\r\n\r\n\t/**\r\n\t * ----------- ENUMERATIONS -----------\r\n\t */\r\n\r\n\t/**\r\n\t * @notice Returns all enabled delegations a given delegate has received\r\n     * @param to The address to retrieve delegations for\r\n     * @return delegations Array of Delegation structs\r\n     */\r\n\tfunction getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\r\n\r\n\t/**\r\n\t * @notice Returns all enabled delegations an address has given out\r\n     * @param from The address to retrieve delegations for\r\n     * @return delegations Array of Delegation structs\r\n     */\r\n\tfunction getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\r\n\r\n\t/**\r\n\t * @notice Returns all hashes associated with enabled delegations an address has received\r\n     * @param to The address to retrieve incoming delegation hashes for\r\n     * @return delegationHashes Array of delegation hashes\r\n     */\r\n\tfunction getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\r\n\r\n\t/**\r\n\t * @notice Returns all hashes associated with enabled delegations an address has given out\r\n     * @param from The address to retrieve outgoing delegation hashes for\r\n     * @return delegationHashes Array of delegation hashes\r\n     */\r\n\tfunction getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\r\n\r\n\t/**\r\n\t * @notice Returns the delegations for a given array of delegation hashes\r\n     * @param delegationHashes is an array of hashes that correspond to delegations\r\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\r\n     */\r\n\tfunction getDelegationsFromHashes(bytes32[] calldata delegationHashes) external view returns (Delegation[] memory delegations);\r\n\r\n\t/**\r\n\t * ----------- STORAGE ACCESS -----------\r\n\t */\r\n\r\n\t/**\r\n\t * @notice Allows external contracts to read arbitrary storage slots\r\n     */\r\n\tfunction readSlot(bytes32 location) external view returns (bytes32);\r\n\r\n\t/**\r\n\t * @notice Allows external contracts to read an arbitrary array of storage slots\r\n     */\r\n\tfunction readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\r\n}\r\n\r\n/*\r\n\r\n           MMMMMMMM\r\n        MMMZZZZZZZZMMM\r\n       MZZZZZZZZZZZZZZM\r\n       MZZZZZMMMMMMMMMM\r\n     MMZZZZMM++++MMMMMMMMMMM\r\n     MMZZZZMM+MMMMM===M===MM\r\n     MMZZZM++++++MM===M,,=MM\r\n     MMZZZM++I+++MMMMMM,,,=====\r\n     MMZZZM++III+++++++,,,======\r\n     MMZZZM++IIIIIIIIII,,=========\r\n       MZZM+++         II?=====NNNN\r\n       MZZM+++++M       II??===NNNN\r\n       MZZM+++++MI        II?NNNNNN\r\n       MZZM+++++MI           MMNNNN\r\n       MZZM+++++MI            IMNNN\r\n       MZZM+++++MI              MMN\r\n       MZZM++++++MM               M\r\n       MMMZMM++++MMM\r\n     MMMZZZMMM++MMMZMM\r\n    MZZZZZZMMZMMZMMZZZM  @author png\r\n    MZZZZZZMMZZZZ$$ZZZM  https://nakamingos.io\r\n    MZZZMMZ$$ZZZZZZMZZM\r\n    MZZZMMZZZZZZZZZMZZM\r\n\r\no    o      .oo  o   o      .oo o     o o o    o .oPYo. .oPYo. .oPYo.\r\n8b   8     .P 8  8  .P     .P 8 8b   d8 8 8b   8 8    8 8    8 8\r\n8`b  8    .P  8 o8ob'     .P  8 8`b d'8 8 8`b  8 8      8    8 `Yooo.\r\n8 `b 8   oPooo8  8  `b   oPooo8 8 `o' 8 8 8 `b 8 8   oo 8    8     `8\r\n8  `b8  .P    8  8   8  .P    8 8     8 8 8  `b8 8    8 8    8      8\r\n8   `8 .P     8  8   8 .P     8 8     8 8 8   `8 `YooP8 `YooP' `YooP'\r\n..:::....:::::..:..::....:::::....::::......:::..:....8 :.....::.....:\r\n::::::::::::::::::::::::::::::::::::::::::::::::::::::8 ::::::::::::::\r\n */\r\ncontract Nakamingos is ReentrancyGuard, Ownable {\r\n\tusing Strings for uint256;\r\n\r\n\t// Token name\r\n\tstring private _name = \"Nakamingo Market\";\r\n\r\n\t// Token symbol\r\n\tstring private _symbol = \"MINGO\";\r\n\r\n\t// State Values\r\n\tbool paused = true;\r\n\tbool clonesActive = false;\r\n\tbool preSaleActive = false;\r\n\tbool pinkSaleActive = false;\r\n\tuint private nextTokenId = 1;\r\n\r\n\t// Address constants\r\n\taddress public NAKAMIGO = 0xd774557b647330C91Bf44cfEAB205095f7E6c367;\r\n\taddress public DELEGATE_REGISTRY = 0x00000000000000447e69651d841bD8D104Bed493;\r\n\taddress payable private locker;\r\n\taddress[] private teamAddressList;\r\n\r\n\t// Price constants\r\n\tuint constant public PINK_PRICE = 3690000000000000;\r\n\tuint constant public MINT_PRICE = 4200000000000000;\r\n\r\n\t// Purchase and minting limits\r\n\tuint8 constant public PURCHASE_LIMIT = 42;\r\n\tuint8 constant public DEV_TERM = 40;\r\n\tuint16 public MINGO_LIMIT = 19580;\r\n\r\n\t// 52 one per week +\r\n\tuint16 public PROMO_BUDGET = 187;\r\n\tuint16 public LAST_TEAM_MINT = 0;\r\n\r\n\t// Cloned mingo tracker\r\n\tmapping(uint => bool) public cloneMap;\r\n\tmapping(address => bool) public freeMap;\r\n\r\n\tmapping(uint256 => bytes32) private merkleRoot;\r\n\tmapping(uint256 => string) private merkleRootUri;\r\n\tmapping(address => uint8) public allowListClaimedAmount;\r\n\r\n\tuint8 public allowlistMaxClaimAmount = 42;\r\n\tuint256 private rootIndex = 0;\r\n\r\n\tevent EthscribeClone(address minter, address indexed mintTo, uint indexed tokenId, uint indexed migoId);\r\n\tevent EthscribeMingo(address minter, address indexed mintTo, uint indexed firstTokenId, uint indexed amount);\r\n\tevent PreSaleEvent(address indexed setter, string indexed preSaleState, bool indexed status);\r\n\tevent TeamAddressesSet(address indexed setter, uint listSize);\r\n\tevent LockerSet(address indexed setter, address indexed locker);\r\n\tevent MerkleRoot(uint256 id, string uri);\r\n\r\n\tevent AllowlistClaimed(address user, uint amount);\r\n\r\n\tconstructor(\r\n\t\taddress _locker,\r\n\t\taddress[] memory _teamAddressList,\r\n\t\taddress initialOwner)\r\n\tOwnable(initialOwner)\r\n\t{\r\n\t\tlocker = payable(_locker);\r\n\t\tsetTeamAddresses(_teamAddressList);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Ethscribe Nakamingo NFTs by paying the specified mint amount.\r\n     * @param mintAmount The number of tokens to Ethscribe.\r\n     * @param mintTo The address to send Ethscriptions too.\r\n     */\r\n\tfunction _ethscribe(uint8 mintAmount, address mintTo) private {\r\n\t\trequire(nextTokenId + mintAmount <= MINGO_LIMIT, \"Where are the mingos?!\");\r\n\t\trequire(mintAmount <= PURCHASE_LIMIT, \"Too many mingos!\");\r\n\t\trequire(mintTo != address(0), \"Fire Bad!\");\r\n\r\n\t\t// emit purchase event\r\n\t\temit EthscribeMingo(msg.sender, mintTo, nextTokenId, mintAmount);\r\n\r\n\t\t// increment tokenIds\r\n\t\tnextTokenId = nextTokenId + mintAmount;\r\n\r\n\t\t// check if team earned a token\r\n\t\tif(LAST_TEAM_MINT + DEV_TERM <= nextTokenId) {\r\n\t\t\t_teamShare();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Ethscribe Nakamingo NFTs by paying the specified mint amount.\r\n     * @param migoId The token ID of MIGO NFT to clone to Nakamingos.\r\n     */\r\n\tfunction _ethscribeClone(uint migoId) private {\r\n\t\trequire(cloneMap[migoId] != true, \"Cloned Already!\");\r\n\t\trequire(IERC721(NAKAMIGO).ownerOf(migoId) != address(0), \"No, Burned Clones!\");\r\n\r\n\t\t// set the mapping value to prevent double clone\r\n\t\tcloneMap[migoId] = true;\r\n\r\n\t\t// emit the event to api service to ethscribe the token\r\n\t\temit EthscribeClone(msg.sender, IERC721(NAKAMIGO).ownerOf(migoId), nextTokenId, migoId);\r\n\r\n\t\t// increment tokenIds\r\n\t\tnextTokenId++;\r\n\r\n\t\tif(LAST_TEAM_MINT + DEV_TERM <= nextTokenId) {\r\n\t\t\t_teamShare();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Ethscribe Nakamingo NFTs by paying the specified mint amount.\r\n     * @param mintAmount The number of MINGO NFTs to Ethscribe.\r\n     * @param mintTo The address to send the tokens to.\r\n     */\r\n\tfunction mintMingo(uint8 mintAmount, address mintTo) public payable nonReentrant {\r\n\t\trequire(paused == false, \"Hold up a mingo!\");\r\n\t\trequire(nextTokenId + mintAmount <= MINGO_LIMIT, \"Where are the mingos?!\");\r\n\t\trequire(msg.value >= MINT_PRICE * mintAmount, \"Insufficient Ether\");\r\n\r\n\t\t// Transfer Ether to the locker address\r\n\t\t_sendEth(locker, msg.value);\r\n\r\n\t\t// send to ethscribe the token\r\n\t\t_ethscribe(mintAmount, mintTo);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Ethscribe a cloned Nakamingo to the owner of the original Nakamigo.\r\n     * @param migoId The ID of the Nakamigo to clone.\r\n     */\r\n\tfunction mintClone(uint migoId) public payable nonReentrant {\r\n\t\trequire(clonesActive == false, \"Hold up a mingo!\");\r\n\t\trequire(nextTokenId <= MINGO_LIMIT, \"All have been hatched!\");\r\n\t\trequire(msg.value >= MINT_PRICE, \"Insufficient Price for Clone!\");\r\n\r\n\t\t// Transfer Ether to the locker address\r\n\t\t_sendEth(locker, msg.value);\r\n\r\n\t\t// ethscribe the clone\r\n\t\t_ethscribeClone(migoId);\r\n\t}\r\n\r\n\r\n\tfunction allowlistMint(\r\n\t\tuint8 mintAmount,\r\n\t\tbytes32[] calldata _merkleProof,\r\n\t\tuint256 rootId\r\n\t) external payable nonReentrant {\r\n\t\tuint8 budget = allowListClaimedAmount[msg.sender] + mintAmount;\r\n\t\tbytes32 leaf = keccak256(abi.encodePacked(msg.sender));\r\n\t\tuint256 cost = PINK_PRICE * mintAmount;\r\n\r\n\t\trequire(pinkSaleActive == true, \"Pink list is not active!\");\r\n\t\trequire(MerkleProof.verify(_merkleProof, merkleRoot[rootId], leaf),\r\n\t\t\t\"Invalid Pink Proof.\");\r\n\t\trequire(budget <= allowlistMaxClaimAmount, \"Can't pink any more\");\r\n\t\trequire(nextTokenId + mintAmount <= MINGO_LIMIT, \"Where are the mingos?!\");\r\n\t\trequire(msg.value >= cost, \"Wrong amount of ETH sent\");\r\n\r\n\t\tallowListClaimedAmount[msg.sender] = budget;\r\n\t\t_sendEth(locker, msg.value);\r\n\r\n\t\t_ethscribe(mintAmount, msg.sender);\r\n\r\n\t\temit AllowlistClaimed(msg.sender, mintAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Ethscribe a Nakamigo NFT during the presale if you have a Nakamigo and End of Sartoshi.\r\n     * @param migoId The ID of the NakaMIGO NFT to clone for free during presale.\r\n     */\r\n\tfunction preSaleClone(uint migoId) public nonReentrant {\r\n\t\trequire(_PreSaleEligible(msg.sender), \"Need a Migo to clone!\");\r\n\t\trequire(freeMap[IERC721(NAKAMIGO).ownerOf(migoId)] != true, \"You have been here before!\");\r\n\r\n\t\t// mark free mint in mapping\r\n\t\tfreeMap[IERC721(NAKAMIGO).ownerOf(migoId)] = true;\r\n\t\tfreeMap[msg.sender] = true;\r\n\r\n\t\t// mint a clone of a nakamigo to the owner of it for free\r\n\t\t_ethscribeClone(migoId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Ethscribe a Nakamigo NFT during the presale if you have a Nakamigo.\r\n     * @param migoId The ID of the NakaMIGO NFT to clone for free during presale.\r\n     */\r\n\tfunction delegatePreSaleClone(uint migoId, address delegate) public nonReentrant {\r\n\t\trequire(_PreSaleEligible(delegate), \"Delegate needs a Nakamigo!\");\r\n\t\trequire(freeMap[delegate] != true, \"Delegate has been here before!\");\r\n\t\trequire(IDelegateRegistry(DELEGATE_REGISTRY).checkDelegateForAll(\r\n\t\t\tmsg.sender,\r\n\t\t\tdelegate,\r\n\t\t\t0) != true, \"Delegate Not Set!\");\r\n\r\n\t\tfreeMap[msg.sender] = true;\r\n\t\tfreeMap[delegate] = true;\r\n\r\n\t\t// mint a clone of a nakamigo to the owner of it for free\r\n\t\t_ethscribeClone(migoId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Ethscribe Nakamingo NFTs by paying the specified mint amount.\r\n     * @param mintAmount The number of MINGO NFTs to Ethscribe.\r\n     */\r\n\tfunction promoMint(uint8 mintAmount, address mintTo) public onlyOwner {\r\n\t\t// Update the promo budget\r\n\t\tPROMO_BUDGET = PROMO_BUDGET - mintAmount;\r\n\t\trequire(PROMO_BUDGET >= 0, \"Promo budget exhausted.\");\r\n\r\n\t\t_ethscribe(mintAmount, mintTo);\r\n\t}\r\n\r\n\tfunction setMerkleRoot(\r\n\t\tuint _newIndex,\r\n\t\tbytes32 _newRoot,\r\n\t\tstring memory _merkleRootUri\r\n\t) external onlyOwner {\r\n\t\trequire(_newIndex == rootIndex + 1, \"Cannot rewrite an older root!\");\r\n\t\trootIndex = _newIndex;\r\n\t\tmerkleRoot[rootIndex] = _newRoot;\r\n\t\tmerkleRootUri[rootIndex] = _merkleRootUri;\r\n\t\temit MerkleRoot(_newIndex, _merkleRootUri);\r\n\t}\r\n\r\n\tfunction setLocker(address newLocker) public onlyOwner {\r\n\t\tlocker = payable(newLocker);\r\n\t\temit LockerSet(msg.sender, locker);\r\n\t}\r\n\r\n\tfunction setTeamAddresses(address[] memory newAddressList) public onlyOwner {\r\n\t\trequire(newAddressList.length > 0, \"Team addresses must not be empty!\");\r\n\r\n\t\t// Clear the old team array\r\n\t\tdelete teamAddressList;\r\n\r\n\t\t// Update the TeamAddresses array\r\n\t\tfor (uint i = 0; i < newAddressList.length; i++) {\r\n\t\t\tteamAddressList.push(newAddressList[i]);\r\n\t\t}\r\n\r\n\t\t// Emit an event to log the change\r\n\t\temit TeamAddressesSet(msg.sender, newAddressList.length);\r\n\t}\r\n\r\n\tfunction setAllowlistMaxClaimAmount(\r\n\t\tuint8 _allowlistMaxClaimAmount\r\n\t) external onlyOwner {\r\n\t\tallowlistMaxClaimAmount = _allowlistMaxClaimAmount;\r\n\t}\r\n\t/*\r\n\t *    Helper Functions\r\n\t/*\r\n\t/**\r\n\t * @dev Private helper function returning eligibility for presale\r\n     * @param _to address to check balanceOf() ERC721\r\n     */\r\n\tfunction _PreSaleEligible(address _user)\r\n\tprivate\r\n\tview\r\n\treturns (bool)\r\n\t{\r\n\t\trequire(preSaleActive == true, \"Still too early!\");\r\n\t\trequire((IERC721(NAKAMIGO).balanceOf(_user) > 0), \"Need a Nakamigo\");\r\n\t\trequire(freeMap[_user] != true, \"Presale Limit Reached\");\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction pause() public onlyOwner {\r\n\t\tpaused = true;\r\n\t\temit PreSaleEvent(msg.sender, \"paused\", paused);\r\n\t}\r\n\r\n\tfunction unpause() public onlyOwner {\r\n\t\tpaused = false;\r\n\t\temit PreSaleEvent(msg.sender, \"paused\", paused);\r\n\r\n\t}\r\n\r\n\tfunction openClones() public onlyOwner {\r\n\t\tclonesActive = true;\r\n\t\temit PreSaleEvent(msg.sender, \"clonesActive\", clonesActive);\r\n\t}\r\n\r\n\tfunction closeClones() public onlyOwner {\r\n\t\tclonesActive = false;\r\n\t\temit PreSaleEvent(msg.sender, \"clonesActive\", clonesActive);\r\n\r\n\t}\r\n\r\n\tfunction openPinkList() public onlyOwner {\r\n\t\tpinkSaleActive = true;\r\n\t\temit PreSaleEvent(msg.sender, \"pinkList\", pinkSaleActive);\r\n\t}\r\n\r\n\tfunction closePinkList() public onlyOwner {\r\n\t\tpinkSaleActive = false;\r\n\t\temit PreSaleEvent(msg.sender, \"pinkList\", pinkSaleActive);\r\n\r\n\t}\r\n\r\n\tfunction openPresale() public onlyOwner {\r\n\t\tpreSaleActive = true;\r\n\t\temit PreSaleEvent(msg.sender, \"preSaleActive\", preSaleActive);\r\n\r\n\t}\r\n\r\n\tfunction closePresale() public onlyOwner {\r\n\t\tpreSaleActive = false;\r\n\t\temit PreSaleEvent(msg.sender, \"preSaleActive\", preSaleActive);\r\n\t}\r\n\r\n\tfunction name() public view virtual returns (string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\tfunction symbol() public view virtual returns (string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\tfunction getPauseStatus() public view virtual returns (bool) {\r\n\t\treturn paused;\r\n\t}\r\n\r\n\tfunction getPreSaleStatus() public view virtual returns (bool) {\r\n\t\treturn preSaleActive;\r\n\t}\r\n\r\n\tfunction getNextTokenId() public view virtual returns (uint) {\r\n\t\treturn nextTokenId;\r\n\t}\r\n\r\n\tfunction getMingosRemaining() public view virtual returns (uint) {\r\n\t\treturn MINGO_LIMIT - (nextTokenId - 1);\r\n\t}\r\n\r\n\tfunction getAllowListClaimed(address user) public view virtual returns (uint) {\r\n\t\treturn allowListClaimedAmount[user];\r\n\t}\r\n\r\n\tfunction TeamAddressList() public view virtual returns (address[] memory){\r\n\t\treturn teamAddressList;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev team share allocated as mint occurs.\r\n     */\r\n\tfunction _teamShare() private {\r\n\t\tLAST_TEAM_MINT += DEV_TERM;\r\n\r\n\t\trequire(LAST_TEAM_MINT <= nextTokenId, \"Not team share time!\");\r\n\t\trequire(nextTokenId <= MINGO_LIMIT, \"All have been hatched!\");\r\n\t\trequire(teamAddressList.length > 0 , \"Where is that team?\");\r\n\r\n\t\t// emit the event to api service to ethscribe the token\r\n\t\t_ethscribe(1, teamAddressList[(LAST_TEAM_MINT/DEV_TERM) % teamAddressList.length]);\r\n\r\n\t\t// check if there are any dev tokens\r\n\t\tif(LAST_TEAM_MINT + DEV_TERM <= nextTokenId) {\r\n\t\t\t_teamShare();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _sendEth(address _destination, uint256 _amount) internal {\r\n\t\t(bool sent, ) = _destination.call{value: _amount}(\"\");\r\n\t\trequire(sent, \"Failed to send Ether\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev transfer tokens mistakenly sent to this contract\r\n     */\r\n\tfunction withdrawToken(address _tokenContract, uint256 _amount) external onlyOwner {\r\n\t\tIERC20 tokenContract = IERC20(_tokenContract);\r\n\r\n\t\t// needs to execute `approve()` on the token contract to allow itself the transfer\r\n\t\ttokenContract.approve(address(this), _amount);\r\n\r\n\t\ttokenContract.transferFrom(address(this), locker, _amount);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev transfer ETH mistakenly sent to this contract\r\n     */\r\n\tfunction withdrawETH(uint256 _amount) external onlyOwner {\r\n\t\t_sendEth(locker, _amount);\r\n\t}\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_locker\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_teamAddressList\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AllowlistClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mintTo\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"migoId\",\"type\":\"uint256\"}],\"name\":\"EthscribeClone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mintTo\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"firstTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthscribeMingo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"}],\"name\":\"LockerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"MerkleRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"preSaleState\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"PreSaleEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listSize\",\"type\":\"uint256\"}],\"name\":\"TeamAddressesSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELEGATE_REGISTRY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEV_TERM\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAST_TEAM_MINT\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINGO_LIMIT\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAKAMIGO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PINK_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROMO_BUDGET\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PURCHASE_LIMIT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TeamAddressList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowListClaimedAmount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowlistMaxClaimAmount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"mintAmount\",\"type\":\"uint8\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"rootId\",\"type\":\"uint256\"}],\"name\":\"allowlistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cloneMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeClones\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closePinkList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closePresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"migoId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"delegatePreSaleClone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"freeMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAllowListClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMingosRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPauseStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPreSaleStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"migoId\",\"type\":\"uint256\"}],\"name\":\"mintClone\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"mintAmount\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"mintTo\",\"type\":\"address\"}],\"name\":\"mintMingo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openClones\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openPinkList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"migoId\",\"type\":\"uint256\"}],\"name\":\"preSaleClone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"mintAmount\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"mintTo\",\"type\":\"address\"}],\"name\":\"promoMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_allowlistMaxClaimAmount\",\"type\":\"uint8\"}],\"name\":\"setAllowlistMaxClaimAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLocker\",\"type\":\"address\"}],\"name\":\"setLocker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_newRoot\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_merkleRootUri\",\"type\":\"string\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newAddressList\",\"type\":\"address[]\"}],\"name\":\"setTeamAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Nakamingos", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f4249a4a9a105d604778c3d2181a90facb9c77830000000000000000000000000000000000000000000000000000000000000060000000000000000000000000f4249a4a9a105d604778c3d2181a90facb9c77830000000000000000000000000000000000000000000000000000000000000007000000000000000000000000b4a1ad3772c63dc0d39e14e4bdbb10a3896d1eb30000000000000000000000004212d149f77308a87ce9928f1095eddb894f4d68000000000000000000000000b0ca7bca06bd8aa06b6b9b98ebacac71b17cc9ee000000000000000000000000facef700458d4fc9746f7f3e0d37b462711ff09e00000000000000000000000075a473c33bffb61e945d86b37113c0859965a789000000000000000000000000b4a1ad3772c63dc0d39e14e4bdbb10a3896d1eb300000000000000000000000066e4d5fb3b9710c1c30fe34f968a9ad45a9a855e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://317bae3c9e3d6b1b026d62b67587fee06ab779a862191c231f2b71f03700eb64"}