{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/SfrxEthUsdDualOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.19;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ======================= SfrxEthUsdDualOracle =======================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// ====================================================================\\nimport { Timelock2Step } from \\\"frax-std/access-control/v1/Timelock2Step.sol\\\";\\nimport { ITimelock2Step } from \\\"frax-std/access-control/v1/interfaces/ITimelock2Step.sol\\\";\\nimport { DualOracleBase, ConstructorParams as DualOracleBaseParams } from \\\"src/contracts/DualOracleBase.sol\\\";\\nimport { CurvePoolEmaPriceOracleWithMinMax, ConstructorParams as CurvePoolEmaPriceOracleWithMinMaxParams } from \\\"./abstracts/CurvePoolEmaPriceOracleWithMinMax.sol\\\";\\nimport { EthUsdChainlinkOracleWithMaxDelay, ConstructorParams as EthUsdChainlinkOracleWithMaxDelayParams } from \\\"./abstracts/EthUsdChainlinkOracleWithMaxDelay.sol\\\";\\nimport { FraxUsdChainlinkOracleWithMaxDelay, ConstructorParams as FraxUsdChainlinkOracleWithMaxDelayParams } from \\\"./abstracts/FraxUsdChainlinkOracleWithMaxDelay.sol\\\";\\nimport { UniswapV3SingleTwapOracle, ConstructorParams as UniswapV3SingleTwapOracleParams } from \\\"./abstracts/UniswapV3SingleTwapOracle.sol\\\";\\nimport { IDualOracle } from \\\"interfaces/IDualOracle.sol\\\";\\nimport { IPriceSource } from \\\"./frax-oracle/interfaces/IPriceSource.sol\\\";\\nimport { IPriceSourceReceiver } from \\\"./frax-oracle/interfaces/IPriceSourceReceiver.sol\\\";\\nimport { ISfrxEth } from \\\"interfaces/ISfrxEth.sol\\\";\\n\\nstruct ConstructorParams {\\n    // = DualOracleBase\\n    address baseToken0; // sfrxEth\\n    uint8 baseToken0Decimals;\\n    address quoteToken0; // usd\\n    uint8 quoteToken0Decimals;\\n    address baseToken1; // sfrxEth\\n    uint8 baseToken1Decimals;\\n    address quoteToken1; // usd\\n    uint8 quoteToken1Decimals;\\n    // = UniswapV3SingleTwapOracle\\n    address frxEthErc20;\\n    address fraxErc20;\\n    address uniV3PairAddress;\\n    uint32 twapDuration;\\n    // = FraxUsdChainlinkOracleWithMaxDelay\\n    address fraxUsdChainlinkFeedAddress;\\n    uint256 fraxUsdMaximumOracleDelay;\\n    // = EthUsdChainlinkOracleWithMaxDelay\\n    address ethUsdChainlinkFeed;\\n    uint256 maxEthUsdOracleDelay;\\n    // = CurvePoolEmaPriceOracleWithMinMax\\n    address curvePoolEmaPriceOracleAddress;\\n    uint256 minimumCurvePoolEma;\\n    uint256 maximumCurvePoolEma;\\n    // = Timelock2Step\\n    address timelockAddress;\\n    // = sfrxEth Erc4626\\n    address sfrxEthErc4626Address;\\n}\\n\\n/// @title FrxEthWethDualOracle\\n/// @notice This price source feeds prices to the FraxOracle system\\n/// @dev Returns prices of Frax assets in Ether\\ncontract SfrxEthUsdDualOracle is\\n    DualOracleBase,\\n    CurvePoolEmaPriceOracleWithMinMax,\\n    UniswapV3SingleTwapOracle,\\n    FraxUsdChainlinkOracleWithMaxDelay,\\n    EthUsdChainlinkOracleWithMaxDelay,\\n    IPriceSource,\\n    Timelock2Step\\n{\\n    /// @notice The address of the Erc4626 token contract for sfrxEth\\n    ISfrxEth public immutable SFRXETH_ERC4626;\\n\\n    constructor(\\n        ConstructorParams memory _params\\n    )\\n        DualOracleBase(\\n            DualOracleBaseParams({\\n                baseToken0: _params.baseToken0,\\n                baseToken0Decimals: _params.baseToken0Decimals,\\n                quoteToken0: _params.quoteToken0,\\n                quoteToken0Decimals: _params.quoteToken0Decimals,\\n                baseToken1: _params.baseToken1,\\n                baseToken1Decimals: _params.baseToken1Decimals,\\n                quoteToken1: _params.quoteToken1,\\n                quoteToken1Decimals: _params.quoteToken1Decimals\\n            })\\n        )\\n        CurvePoolEmaPriceOracleWithMinMax(\\n            CurvePoolEmaPriceOracleWithMinMaxParams({\\n                curvePoolEmaPriceOracleAddress: _params.curvePoolEmaPriceOracleAddress,\\n                minimumCurvePoolEma: _params.minimumCurvePoolEma,\\n                maximumCurvePoolEma: _params.maximumCurvePoolEma\\n            })\\n        )\\n        UniswapV3SingleTwapOracle(\\n            UniswapV3SingleTwapOracleParams({\\n                uniswapV3PairAddress: _params.uniV3PairAddress,\\n                twapDuration: _params.twapDuration,\\n                baseToken: _params.frxEthErc20,\\n                quoteToken: _params.fraxErc20\\n            })\\n        )\\n        EthUsdChainlinkOracleWithMaxDelay(\\n            EthUsdChainlinkOracleWithMaxDelayParams({\\n                ethUsdChainlinkFeedAddress: _params.ethUsdChainlinkFeed,\\n                maxEthUsdOracleDelay: _params.maxEthUsdOracleDelay\\n            })\\n        )\\n        FraxUsdChainlinkOracleWithMaxDelay(\\n            FraxUsdChainlinkOracleWithMaxDelayParams({\\n                fraxUsdChainlinkFeedAddress: _params.fraxUsdChainlinkFeedAddress,\\n                fraxUsdMaximumOracleDelay: _params.fraxUsdMaximumOracleDelay\\n            })\\n        )\\n        Timelock2Step()\\n    {\\n        _setTimelock({ _newTimelock: _params.timelockAddress });\\n        _registerInterface({ interfaceId: type(IDualOracle).interfaceId });\\n        _registerInterface({ interfaceId: type(ITimelock2Step).interfaceId });\\n        _registerInterface({ interfaceId: type(IPriceSource).interfaceId });\\n\\n        SFRXETH_ERC4626 = ISfrxEth(_params.sfrxEthErc4626Address);\\n    }\\n\\n    // ====================================================================\\n    // Metadata\\n    // ====================================================================\\n\\n    /// @notice The ```name``` function returns the name of the contract\\n    /// @return _name The name of the contract\\n    function name() external pure virtual returns (string memory _name) {\\n        _name = \\\"v2 sfrxEth Dual Oracle In USD with Curve Pool (WETH) EMA and Uniswap v3 TWAP and Frax and ETH Chainlink\\\";\\n    }\\n\\n    /// @notice The ```version``` function returns the version of the contract\\n    /// @return _major The major version of the contract\\n    /// @return _minor The minor version of the contract\\n    /// @return _patch The patch version of the contract\\n    function version() external pure virtual returns (uint256 _major, uint256 _minor, uint256 _patch) {\\n        _major = 2;\\n        _minor = 0;\\n        _patch = 0;\\n    }\\n\\n    // ====================================================================\\n    // Configuration Setters\\n    // ====================================================================\\n\\n    /// @notice The ```setMinimumCurvePoolEma``` function sets the minimum price of frxEth in Ether units of the EMA\\n    /// @dev Must match precision of the EMA\\n    /// @param _minimumPrice The minimum price of frxEth in Ether units of the EMA\\n    function setMinimumCurvePoolEma(uint256 _minimumPrice) external override {\\n        _requireTimelock();\\n        _setMinimumCurvePoolEma({ _minimumPrice: _minimumPrice });\\n    }\\n\\n    /// @notice The ```setMaximumCurvePoolEma``` function sets the maximum price of frxEth in Ether units of the EMA\\n    /// @dev Must match precision of the EMA\\n    /// @param _maximumPrice The maximum price of frxEth in Ether units of the EMA\\n    function setMaximumCurvePoolEma(uint256 _maximumPrice) external override {\\n        _requireTimelock();\\n        _setMaximumCurvePoolEma({ _maximumPrice: _maximumPrice });\\n    }\\n\\n    /// @notice The ```setTwapDuration``` function sets the TWAP duration for the Uniswap V3 oracle\\n    /// @dev Must be called by the timelock\\n    /// @param _newTwapDuration The new TWAP duration\\n    function setTwapDuration(uint32 _newTwapDuration) external override {\\n        _requireTimelock();\\n        _setTwapDuration({ _newTwapDuration: _newTwapDuration });\\n    }\\n\\n    /// @notice The ```setMaximumOracleDelay``` function sets the max oracle delay to determine if Chainlink data is stale\\n    /// @dev Requires msg.sender to be the timelock address\\n    /// @param _newMaxOracleDelay The new max oracle delay\\n    function setMaximumEthUsdOracleDelay(uint256 _newMaxOracleDelay) external override {\\n        _requireTimelock();\\n        _setMaximumEthUsdOracleDelay({ _newMaxOracleDelay: _newMaxOracleDelay });\\n    }\\n\\n    /// @notice The ```setMaximumFraxUsdOracleDelay``` function sets the max oracle delay to determine if Chainlink data is stale\\n    /// @dev Must be called by the timelock\\n    /// @param _newMaxOracleDelay The new max oracle delay\\n    function setMaximumFraxUsdOracleDelay(uint256 _newMaxOracleDelay) external override {\\n        _requireTimelock();\\n        _setMaximumFraxUsdOracleDelay({ _newMaxOracleDelay: _newMaxOracleDelay });\\n    }\\n\\n    // ====================================================================\\n    // Price Source Function\\n    // ====================================================================\\n\\n    /// @notice The ```addRoundData``` adds new price data to a FraxOracle\\n    /// @dev This contract must be whitelisted on the receiver address\\n    /// @param _fraxOracle Address of a FraxOracle that has this contract set as its priceSource\\n    function addRoundData(IPriceSourceReceiver _fraxOracle) external {\\n        (bool _isBadData, uint256 _priceLow, uint256 _priceHigh) = getPrices();\\n        // Authorization is handled on fraxOracle side\\n        _fraxOracle.addRoundData({\\n            isBadData: _isBadData,\\n            priceLow: uint104(_priceLow),\\n            priceHigh: uint104(_priceHigh),\\n            timestamp: uint40(block.timestamp)\\n        });\\n    }\\n\\n    // ====================================================================\\n    // Price Functions\\n    // ====================================================================\\n\\n    /// @notice The ```getWethPerFrxEthCurveEma``` function gets the EMA price of frxEth in weth units\\n    /// @dev normalized to match precision of oracle\\n    /// @return _wethPerFrxEth\\n    function getWethPerFrxEthCurveEma() public view returns (uint256 _wethPerFrxEth) {\\n        _wethPerFrxEth = _getCurvePoolToken1EmaPrice();\\n\\n        // Note: ORACLE_PRECISION == CURVE_POOL_EMA_PRICE_ORACLE_PRECISION\\n        // _wethPerFrxEth = (ORACLE_PRECISION * _getCurvePoolToken1EmaPrice()) / CURVE_POOL_EMA_PRICE_ORACLE_PRECISION;\\n    }\\n\\n    /// @notice The ```getUsdPerFraxChainlink``` function gets the Chainlink price of frax in usd units\\n    /// @dev normalized to match precision of oracle\\n    /// @return _isBadData Whether the Chainlink data is stale\\n    /// @return _usdPerFrax\\n    function getUsdPerFraxChainlink() public view returns (bool _isBadData, uint256 _usdPerFrax) {\\n        (bool _isBadDataChainlink, , uint256 _usdPerFraxRaw) = _getFraxUsdChainlinkPrice();\\n\\n        // Set return values\\n        _isBadData = _isBadDataChainlink;\\n        _usdPerFrax = (ORACLE_PRECISION * _usdPerFraxRaw) / FRAX_USD_CHAINLINK_FEED_PRECISION;\\n    }\\n\\n    /// @notice The ```getUsdPerEthChainlink``` function returns USD per ETH using the Chainlink oracle\\n    /// @return _isBadData If the Chainlink oracle is stale\\n    /// @return _usdPerEth The Eth Price is usd units\\n    function getUsdPerEthChainlink() public view returns (bool _isBadData, uint256 _usdPerEth) {\\n        (bool _isBadDataChainlink, , uint256 _usdPerEthChainlinkRaw) = _getEthUsdChainlinkPrice();\\n\\n        // Set return values\\n        _isBadData = _isBadDataChainlink;\\n        _usdPerEth = (ORACLE_PRECISION * _usdPerEthChainlinkRaw) / ETH_USD_CHAINLINK_FEED_PRECISION;\\n    }\\n\\n    /// @notice The ```getFraxPerFrxEthUniV3Twap``` function gets the TWAP price of frxEth in frax units\\n    /// @return _fraxPerFrxEthTwap The TWAP price of frxEth in frax units\\n    function getFraxPerFrxEthUniV3Twap() public view returns (uint256 _fraxPerFrxEthTwap) {\\n        _fraxPerFrxEthTwap = _getUniswapV3Twap();\\n    }\\n\\n    /// @notice The ```getFrxEthPerSfrxEthErc4626Vault``` function gets the price of sfrxEth in frxEth units from the ERC4626 vault\\n    /// @return _frxEthPerSfrxEth The price of sfrxEth in frxEth units\\n    function getFrxEthPerSfrxEthErc4626Vault() public view returns (uint256 _frxEthPerSfrxEth) {\\n        _frxEthPerSfrxEth = SFRXETH_ERC4626.pricePerShare();\\n    }\\n\\n    /// @notice The ```calculatePrices``` function calculates the normalized prices in a pure function\\n    /// @return _isBadData True if any of the oracles return stale data\\n    /// @return _priceLow The normalized low price\\n    /// @return _priceHigh The normalized high price\\n    function calculatePrices(\\n        uint256 _wethPerFrxEthCurveEma,\\n        uint256 _fraxPerFrxEthTwap,\\n        bool _isBadDataEthUsdChainlink,\\n        uint256 _usdPerEthChainlink,\\n        bool _isBadDataFraxUsdChainlink,\\n        uint256 _usdPerFraxChainlink,\\n        uint256 _frxEthPerSfrxEth\\n    ) public view virtual returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh) {\\n        uint256 _frxEthPerUsdCurveChainlink = (ORACLE_PRECISION * ORACLE_PRECISION * ORACLE_PRECISION) /\\n            (_wethPerFrxEthCurveEma * _usdPerEthChainlink);\\n\\n        uint256 _frxEthPerUsdTwapChainlink = (ORACLE_PRECISION * ORACLE_PRECISION * ORACLE_PRECISION) /\\n            (_fraxPerFrxEthTwap * _usdPerFraxChainlink);\\n\\n        // NOTE: break out these steps to prevent potential overflow\\n        uint256 _sfrxEthPerUsdCurveChainlink = (ORACLE_PRECISION * _frxEthPerUsdCurveChainlink) / _frxEthPerSfrxEth;\\n        uint256 _sfrxEthPerUsdTwapChainlink = (ORACLE_PRECISION * _frxEthPerUsdTwapChainlink) / _frxEthPerSfrxEth;\\n\\n        // Set return values\\n        _isBadData = _isBadDataEthUsdChainlink || _isBadDataFraxUsdChainlink;\\n        _priceLow = _sfrxEthPerUsdCurveChainlink < _sfrxEthPerUsdTwapChainlink\\n            ? _sfrxEthPerUsdCurveChainlink\\n            : _sfrxEthPerUsdTwapChainlink;\\n        _priceHigh = _sfrxEthPerUsdCurveChainlink > _sfrxEthPerUsdTwapChainlink\\n            ? _sfrxEthPerUsdCurveChainlink\\n            : _sfrxEthPerUsdTwapChainlink;\\n    }\\n\\n    /// @notice The ```getPrices``` function is intended to return two prices from different oracles\\n    /// @notice Returns the number of wei of the quote token equivalent to 1e18 wei of base token\\n    /// @return _isBadData is true when data is stale or otherwise bad\\n    /// @return _priceLow is the lower of the two prices\\n    /// @return _priceHigh is the higher of the two prices\\n    function getPrices() public view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh) {\\n        uint256 _wethPerFrxEthCurveEma = getWethPerFrxEthCurveEma();\\n        uint256 _fraxPerFrxEthTwap = getFraxPerFrxEthUniV3Twap();\\n        (bool _isBadDataEthUsdChainlink, uint256 _usdPerEthChainlink) = getUsdPerEthChainlink();\\n        (bool _isBadDataFraxUsdChainlink, uint256 _usdPerFraxChainlink) = getUsdPerFraxChainlink();\\n        uint256 _frxEthPerSfrxEth = getFrxEthPerSfrxEthErc4626Vault();\\n\\n        (_isBadData, _priceLow, _priceHigh) = calculatePrices({\\n            _wethPerFrxEthCurveEma: _wethPerFrxEthCurveEma,\\n            _fraxPerFrxEthTwap: _fraxPerFrxEthTwap,\\n            _isBadDataEthUsdChainlink: _isBadDataEthUsdChainlink,\\n            _usdPerEthChainlink: _usdPerEthChainlink,\\n            _isBadDataFraxUsdChainlink: _isBadDataFraxUsdChainlink,\\n            _usdPerFraxChainlink: _usdPerFraxChainlink,\\n            _frxEthPerSfrxEth: _frxEthPerSfrxEth\\n        });\\n    }\\n\\n    /// @notice The ```getPricesNormalized``` function returns the normalized prices in human readable form\\n    /// @dev decimals of underlying tokens match so we can just return _getPrices()\\n    /// @return _isBadDataNormal If the oracle is stale\\n    /// @return _priceLowNormal The normalized low price\\n    /// @return _priceHighNormal The normalized high price\\n    function getPricesNormalized()\\n        external\\n        view\\n        override\\n        returns (bool _isBadDataNormal, uint256 _priceLowNormal, uint256 _priceHighNormal)\\n    {\\n        // NOTE: because precision of both tokens is the same, we can just return the prices\\n        (_isBadDataNormal, _priceLowNormal, _priceHighNormal) = getPrices();\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/frax-standard-solidity/src/access-control/v1/Timelock2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.19;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ========================== Timelock2Step ===========================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Primary Author\\n// Drake Evans: https://github.com/DrakeEvans\\n\\n// Reviewers\\n// Dennis: https://github.com/denett\\n\\n// ====================================================================\\n\\n/// @title Timelock2Step\\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\\n/// @dev Inspired by the OpenZeppelin's Ownable2Step contract\\n/// @notice  An abstract contract which contains 2-step transfer and renounce logic for a timelock address\\nabstract contract Timelock2Step {\\n    /// @notice The pending timelock address\\n    address public pendingTimelockAddress;\\n\\n    /// @notice The current timelock address\\n    address public timelockAddress;\\n\\n    constructor() {\\n        timelockAddress = msg.sender;\\n    }\\n\\n    /// @notice Emitted when timelock is transferred\\n    error OnlyTimelock();\\n\\n    /// @notice Emitted when pending timelock is transferred\\n    error OnlyPendingTimelock();\\n\\n    /// @notice The ```TimelockTransferStarted``` event is emitted when the timelock transfer is initiated\\n    /// @param previousTimelock The address of the previous timelock\\n    /// @param newTimelock The address of the new timelock\\n    event TimelockTransferStarted(address indexed previousTimelock, address indexed newTimelock);\\n\\n    /// @notice The ```TimelockTransferred``` event is emitted when the timelock transfer is completed\\n    /// @param previousTimelock The address of the previous timelock\\n    /// @param newTimelock The address of the new timelock\\n    event TimelockTransferred(address indexed previousTimelock, address indexed newTimelock);\\n\\n    /// @notice The ```_isSenderTimelock``` function checks if msg.sender is current timelock address\\n    /// @return Whether or not msg.sender is current timelock address\\n    function _isSenderTimelock() internal view returns (bool) {\\n        return msg.sender == timelockAddress;\\n    }\\n\\n    /// @notice The ```_requireTimelock``` function reverts if msg.sender is not current timelock address\\n    function _requireTimelock() internal view {\\n        if (msg.sender != timelockAddress) revert OnlyTimelock();\\n    }\\n\\n    /// @notice The ```_isSenderPendingTimelock``` function checks if msg.sender is pending timelock address\\n    /// @return Whether or not msg.sender is pending timelock address\\n    function _isSenderPendingTimelock() internal view returns (bool) {\\n        return msg.sender == pendingTimelockAddress;\\n    }\\n\\n    /// @notice The ```_requirePendingTimelock``` function reverts if msg.sender is not pending timelock address\\n    function _requirePendingTimelock() internal view {\\n        if (msg.sender != pendingTimelockAddress) revert OnlyPendingTimelock();\\n    }\\n\\n    /// @notice The ```_transferTimelock``` function initiates the timelock transfer\\n    /// @dev This function is to be implemented by a public function\\n    /// @param _newTimelock The address of the nominated (pending) timelock\\n    function _transferTimelock(address _newTimelock) internal {\\n        pendingTimelockAddress = _newTimelock;\\n        emit TimelockTransferStarted(timelockAddress, _newTimelock);\\n    }\\n\\n    /// @notice The ```_acceptTransferTimelock``` function completes the timelock transfer\\n    /// @dev This function is to be implemented by a public function\\n    function _acceptTransferTimelock() internal {\\n        pendingTimelockAddress = address(0);\\n        _setTimelock(msg.sender);\\n    }\\n\\n    /// @notice The ```_setTimelock``` function sets the timelock address\\n    /// @dev This function is to be implemented by a public function\\n    /// @param _newTimelock The address of the new timelock\\n    function _setTimelock(address _newTimelock) internal {\\n        emit TimelockTransferred(timelockAddress, _newTimelock);\\n        timelockAddress = _newTimelock;\\n    }\\n\\n    /// @notice The ```transferTimelock``` function initiates the timelock transfer\\n    /// @dev Must be called by the current timelock\\n    /// @param _newTimelock The address of the nominated (pending) timelock\\n    function transferTimelock(address _newTimelock) external virtual {\\n        _requireTimelock();\\n        _transferTimelock(_newTimelock);\\n    }\\n\\n    /// @notice The ```acceptTransferTimelock``` function completes the timelock transfer\\n    /// @dev Must be called by the pending timelock\\n    function acceptTransferTimelock() external virtual {\\n        _requirePendingTimelock();\\n        _acceptTransferTimelock();\\n    }\\n\\n    /// @notice The ```renounceTimelock``` function renounces the timelock after setting pending timelock to current timelock\\n    /// @dev Pending timelock must be set to current timelock before renouncing, creating a 2-step renounce process\\n    function renounceTimelock() external virtual {\\n        _requireTimelock();\\n        _requirePendingTimelock();\\n        _transferTimelock(address(0));\\n        _setTimelock(address(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/frax-standard-solidity/src/access-control/v1/interfaces/ITimelock2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\ninterface ITimelock2Step {\\n    event TimelockTransferStarted(address indexed previousTimelock, address indexed newTimelock);\\n    event TimelockTransferred(address indexed previousTimelock, address indexed newTimelock);\\n\\n    function acceptTransferTimelock() external;\\n\\n    function pendingTimelockAddress() external view returns (address);\\n\\n    function renounceTimelock() external;\\n\\n    function timelockAddress() external view returns (address);\\n\\n    function transferTimelock(address _newTimelock) external;\\n}\\n\"\r\n    },\r\n    \"src/contracts/DualOracleBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.19;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ========================== DualOracleBase ==========================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Author\\n// Drake Evans: https://github.com/DrakeEvans\\n\\n// ====================================================================\\n\\nimport \\\"interfaces/IDualOracle.sol\\\";\\n\\nstruct ConstructorParams {\\n    address baseToken0;\\n    uint8 baseToken0Decimals;\\n    address quoteToken0;\\n    uint8 quoteToken0Decimals;\\n    address baseToken1;\\n    uint8 baseToken1Decimals;\\n    address quoteToken1;\\n    uint8 quoteToken1Decimals;\\n}\\n\\n/// @title DualOracleBase\\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\\n/// @notice  Base Contract for Frax Dual Oracles\\nabstract contract DualOracleBase is IDualOracle {\\n    /// @notice The precision of the oracle\\n    uint256 public constant ORACLE_PRECISION = 1e18;\\n\\n    /// @notice The first quote token\\n    address public immutable QUOTE_TOKEN_0;\\n\\n    /// @notice The first quote token decimals\\n    uint256 public immutable QUOTE_TOKEN_0_DECIMALS;\\n\\n    /// @notice The second quote token\\n    address public immutable QUOTE_TOKEN_1;\\n\\n    /// @notice The second quote token decimals\\n    uint256 public immutable QUOTE_TOKEN_1_DECIMALS;\\n\\n    /// @notice The first base token\\n    address public immutable BASE_TOKEN_0;\\n\\n    /// @notice The first base token decimals\\n    uint256 public immutable BASE_TOKEN_0_DECIMALS;\\n\\n    /// @notice The second base token\\n    address public immutable BASE_TOKEN_1;\\n\\n    /// @notice The second base token decimals\\n    uint256 public immutable BASE_TOKEN_1_DECIMALS;\\n\\n    /// @notice The first normalization factor which accounts for different decimals across ERC20s\\n    /// @dev Normalization = quoteTokenDecimals - baseTokenDecimals\\n    int256 public immutable NORMALIZATION_0;\\n\\n    /// @notice The second normalization factor which accounts for different decimals across ERC20s\\n    /// @dev Normalization = quoteTokenDecimals - baseTokenDecimals\\n    int256 public immutable NORMALIZATION_1;\\n\\n    constructor(ConstructorParams memory _params) {\\n        QUOTE_TOKEN_0 = _params.quoteToken0;\\n        QUOTE_TOKEN_0_DECIMALS = _params.quoteToken0Decimals;\\n        QUOTE_TOKEN_1 = _params.quoteToken1;\\n        QUOTE_TOKEN_1_DECIMALS = _params.quoteToken1Decimals;\\n        BASE_TOKEN_0 = _params.baseToken0;\\n        BASE_TOKEN_0_DECIMALS = _params.baseToken0Decimals;\\n        BASE_TOKEN_1 = _params.baseToken1;\\n        BASE_TOKEN_1_DECIMALS = _params.baseToken1Decimals;\\n        NORMALIZATION_0 = int256(QUOTE_TOKEN_0_DECIMALS) - int256(BASE_TOKEN_0_DECIMALS);\\n        NORMALIZATION_1 = int256(QUOTE_TOKEN_1_DECIMALS) - int256(BASE_TOKEN_1_DECIMALS);\\n    }\\n\\n    // ====================================================================\\n    // View Helpers\\n    // ====================================================================\\n\\n    function decimals() external pure returns (uint8) {\\n        return 18;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/abstracts/CurvePoolEmaPriceOracleWithMinMax.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.19;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ================ CurvePoolEmaPriceOracleWithMinMax =================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Author\\n// Drake Evans: https://github.com/DrakeEvans\\n\\n// Reviewers\\n// Dennis: https://github.com/denett\\n\\n// ====================================================================\\n\\nimport { ERC165Storage } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\\\";\\nimport { ICurvePoolEmaPriceOracleWithMinMax } from \\\"interfaces/oracles/abstracts/ICurvePoolEmaPriceOracleWithMinMax.sol\\\";\\nimport { IEmaPriceOracleStableSwap } from \\\"interfaces/IEmaPriceOracleStableSwap.sol\\\";\\n\\nstruct ConstructorParams {\\n    address curvePoolEmaPriceOracleAddress;\\n    uint256 minimumCurvePoolEma;\\n    uint256 maximumCurvePoolEma;\\n}\\n\\n/// @title CurvePoolEmaPriceOracleWithMinMax\\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\\n/// @notice  An oracle for getting EMA prices from Curve\\nabstract contract CurvePoolEmaPriceOracleWithMinMax is ERC165Storage, ICurvePoolEmaPriceOracleWithMinMax {\\n    /// @notice Curve pool, source of EMA\\n    address public immutable CURVE_POOL_EMA_PRICE_ORACLE;\\n\\n    /// @notice Precision of Curve pool price_oracle()\\n    uint256 public constant CURVE_POOL_EMA_PRICE_ORACLE_PRECISION = 1e18;\\n\\n    /// @notice Maximum price of token1 in token0 units of the EMA\\n    /// @dev Must match precision of EMA\\n    uint256 public minimumCurvePoolEma;\\n\\n    /// @notice Maximum price of token1 in token0 units of the EMA\\n    /// @dev Must match precision of EMA\\n    uint256 public maximumCurvePoolEma;\\n\\n    constructor(ConstructorParams memory _params) {\\n        _registerInterface({ interfaceId: type(ICurvePoolEmaPriceOracleWithMinMax).interfaceId });\\n\\n        CURVE_POOL_EMA_PRICE_ORACLE = _params.curvePoolEmaPriceOracleAddress;\\n        minimumCurvePoolEma = _params.minimumCurvePoolEma;\\n        maximumCurvePoolEma = _params.maximumCurvePoolEma;\\n    }\\n\\n    /// @notice The ```setMaximumCurvePoolEma``` function sets the maximum price of the EMA\\n    /// @dev Must match precision of the EMA\\n    /// @param _maximumPrice The maximum price of the EMA\\n    function _setMaximumCurvePoolEma(uint256 _maximumPrice) internal {\\n        emit SetMaximumCurvePoolEma({ oldMaximum: maximumCurvePoolEma, newMaximum: _maximumPrice });\\n        maximumCurvePoolEma = _maximumPrice;\\n    }\\n\\n    function setMaximumCurvePoolEma(uint256 _maximumPrice) external virtual;\\n\\n    /// @notice The ```setEmaMinimum``` function sets the minimum price of the EMA\\n    /// @dev Must match precision of the EMA\\n    /// @param _minimumPrice The minimum price of the EMA\\n    function _setMinimumCurvePoolEma(uint256 _minimumPrice) internal {\\n        emit SetMinimumCurvePoolEma({ oldMinimum: minimumCurvePoolEma, newMinimum: _minimumPrice });\\n        minimumCurvePoolEma = _minimumPrice;\\n    }\\n\\n    function setMinimumCurvePoolEma(uint256 _minimumPrice) external virtual;\\n\\n    function _getCurvePoolToken1EmaPrice() internal view returns (uint256 _token1Price) {\\n        uint256 _priceRaw = IEmaPriceOracleStableSwap(CURVE_POOL_EMA_PRICE_ORACLE).price_oracle();\\n        uint256 _price = _priceRaw > maximumCurvePoolEma ? maximumCurvePoolEma : _priceRaw;\\n\\n        _token1Price = _price < minimumCurvePoolEma ? minimumCurvePoolEma : _price;\\n    }\\n\\n    /// @notice The ```getCurvePoolToken1EmaPrice``` function gets the price of the second token in the Curve pool (token1)\\n    /// @dev Returned in units of the first token (token0)\\n    /// @return _emaPrice The price of the second token in the Curve pool\\n    function getCurvePoolToken1EmaPrice() external view returns (uint256 _emaPrice) {\\n        return _getCurvePoolToken1EmaPrice();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/abstracts/EthUsdChainlinkOracleWithMaxDelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.19;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ================ EthUsdChainlinkOracleWithMaxDelay =================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Author\\n// Drake Evans: https://github.com/DrakeEvans\\n\\n// Reviewers\\n// Dennis: https://github.com/denett\\n\\n// ====================================================================\\n\\nimport { AggregatorV3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport { ERC165Storage } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\\\";\\nimport { IEthUsdChainlinkOracleWithMaxDelay } from \\\"interfaces/oracles/abstracts/IEthUsdChainlinkOracleWithMaxDelay.sol\\\";\\n\\nstruct ConstructorParams {\\n    address ethUsdChainlinkFeedAddress;\\n    uint256 maxEthUsdOracleDelay;\\n}\\n\\n/// @title EthUsdChainlinkOracleWithMaxDelay\\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\\n/// @notice  An abstract oracle for getting eth/usd prices from Chainlink\\nabstract contract EthUsdChainlinkOracleWithMaxDelay is ERC165Storage, IEthUsdChainlinkOracleWithMaxDelay {\\n    /// @notice Chainlink aggregator\\n    address public immutable ETH_USD_CHAINLINK_FEED_ADDRESS;\\n\\n    /// @notice Decimals of ETH/USD chainlink feed\\n    uint8 public immutable ETH_USD_CHAINLINK_FEED_DECIMALS;\\n\\n    /// @notice Precision of ETH/USD chainlink feed\\n    uint256 public immutable ETH_USD_CHAINLINK_FEED_PRECISION;\\n\\n    /// @notice Maximum delay of Chainlink data, after which it is considered stale\\n    uint256 public maximumEthUsdOracleDelay;\\n\\n    constructor(ConstructorParams memory _params) {\\n        _registerInterface({ interfaceId: type(IEthUsdChainlinkOracleWithMaxDelay).interfaceId });\\n\\n        ETH_USD_CHAINLINK_FEED_ADDRESS = _params.ethUsdChainlinkFeedAddress;\\n        ETH_USD_CHAINLINK_FEED_DECIMALS = AggregatorV3Interface(ETH_USD_CHAINLINK_FEED_ADDRESS).decimals();\\n        ETH_USD_CHAINLINK_FEED_PRECISION = 10 ** uint256(ETH_USD_CHAINLINK_FEED_DECIMALS);\\n        maximumEthUsdOracleDelay = _params.maxEthUsdOracleDelay;\\n    }\\n\\n    /// @notice The ```_setMaximumEthUsdOracleDelay``` function sets the max oracle delay to determine if Chainlink data is stale\\n    /// @param _newMaxOracleDelay The new max oracle delay\\n    function _setMaximumEthUsdOracleDelay(uint256 _newMaxOracleDelay) internal {\\n        emit SetMaximumEthUsdOracleDelay({\\n            oldMaxOracleDelay: maximumEthUsdOracleDelay,\\n            newMaxOracleDelay: _newMaxOracleDelay\\n        });\\n        maximumEthUsdOracleDelay = _newMaxOracleDelay;\\n    }\\n\\n    function setMaximumEthUsdOracleDelay(uint256 _newMaxOracleDelay) external virtual;\\n\\n    /// @notice The ```_getEthUsdChainlinkPrice``` function is called to get the eth/usd price from Chainlink\\n    /// @dev If data is stale or negative, set bad data to true and return\\n    /// @return _isBadData If the data is stale\\n    /// @return _updatedAt The timestamp of the last update\\n    /// @return _usdPerEth The eth/usd price\\n    function _getEthUsdChainlinkPrice()\\n        internal\\n        view\\n        returns (bool _isBadData, uint256 _updatedAt, uint256 _usdPerEth)\\n    {\\n        (, int256 _answer, , uint256 _ethUsdChainlinkUpdatedAt, ) = AggregatorV3Interface(\\n            ETH_USD_CHAINLINK_FEED_ADDRESS\\n        ).latestRoundData();\\n\\n        // If data is stale or negative, set bad data to true and return\\n        _isBadData = _answer <= 0 || ((block.timestamp - _ethUsdChainlinkUpdatedAt) > maximumEthUsdOracleDelay);\\n        _updatedAt = _ethUsdChainlinkUpdatedAt;\\n        _usdPerEth = uint256(_answer);\\n    }\\n\\n    /// @notice The ```getEthUsdChainlinkPrice``` function is called to get the eth/usd price from Chainlink\\n    /// @return _isBadData If the data is stale\\n    /// @return _updatedAt The timestamp of the last update\\n    /// @return _usdPerEth The eth/usd price\\n    function getEthUsdChainlinkPrice()\\n        external\\n        view\\n        virtual\\n        returns (bool _isBadData, uint256 _updatedAt, uint256 _usdPerEth)\\n    {\\n        (_isBadData, _updatedAt, _usdPerEth) = _getEthUsdChainlinkPrice();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/abstracts/FraxUsdChainlinkOracleWithMaxDelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.19;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ================ FraxUsdChainlinkOracleWithMaxDelay =================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Author\\n// Drake Evans: https://github.com/DrakeEvans\\n\\n// Reviewers\\n// Dennis: https://github.com/denett\\n\\n// ====================================================================\\n\\nimport { AggregatorV3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport { ERC165Storage } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\\\";\\nimport { IFraxUsdChainlinkOracleWithMaxDelay } from \\\"interfaces/oracles/abstracts/IFraxUsdChainlinkOracleWithMaxDelay.sol\\\";\\n\\nstruct ConstructorParams {\\n    address fraxUsdChainlinkFeedAddress;\\n    uint256 fraxUsdMaximumOracleDelay;\\n}\\n\\n/// @title FraxUsdChainlinkOracleWithMaxDelay\\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\\n/// @notice  An abstract oracle for getting frax/usd prices from Chainlink\\nabstract contract FraxUsdChainlinkOracleWithMaxDelay is ERC165Storage, IFraxUsdChainlinkOracleWithMaxDelay {\\n    /// @notice Chainlink aggregator\\n    address public immutable FRAX_USD_CHAINLINK_FEED_ADDRESS;\\n\\n    /// @notice Decimals of FRAX/USD chainlink feed\\n    uint8 public immutable FRAX_USD_CHAINLINK_FEED_DECIMALS;\\n\\n    /// @notice Precision of FRAX/USD chainlink feed\\n    uint256 public immutable FRAX_USD_CHAINLINK_FEED_PRECISION;\\n\\n    /// @notice Maximum delay of Chainlink data, after which it is considered stale\\n    uint256 public maximumFraxUsdOracleDelay;\\n\\n    constructor(ConstructorParams memory _params) {\\n        _registerInterface({ interfaceId: type(IFraxUsdChainlinkOracleWithMaxDelay).interfaceId });\\n\\n        FRAX_USD_CHAINLINK_FEED_ADDRESS = _params.fraxUsdChainlinkFeedAddress;\\n        FRAX_USD_CHAINLINK_FEED_DECIMALS = AggregatorV3Interface(FRAX_USD_CHAINLINK_FEED_ADDRESS).decimals();\\n        FRAX_USD_CHAINLINK_FEED_PRECISION = 10 ** uint256(FRAX_USD_CHAINLINK_FEED_DECIMALS);\\n        maximumFraxUsdOracleDelay = _params.fraxUsdMaximumOracleDelay;\\n    }\\n\\n    /// @notice The ```_setMaximumFraxUsdOracleDelay``` function sets the max oracle delay to determine if Chainlink data is stale\\n    /// @param _newMaxOracleDelay The new max oracle delay\\n    function _setMaximumFraxUsdOracleDelay(uint256 _newMaxOracleDelay) internal {\\n        emit SetMaximumFraxUsdOracleDelay({\\n            oldMaxOracleDelay: maximumFraxUsdOracleDelay,\\n            newMaxOracleDelay: _newMaxOracleDelay\\n        });\\n        maximumFraxUsdOracleDelay = _newMaxOracleDelay;\\n    }\\n\\n    function setMaximumFraxUsdOracleDelay(uint256 _newMaxOracleDelay) external virtual;\\n\\n    /// @notice The ```_getFraxUsdChainlinkPrice``` function is called to get the frax/usd price from Chainlink\\n    /// @dev If data is stale or negative, set bad data to true and return\\n    /// @return _isBadData If the data is stale\\n    /// @return _updatedAt The timestamp of the last update\\n    /// @return _usdPerFrax The frax/usd price\\n    function _getFraxUsdChainlinkPrice()\\n        internal\\n        view\\n        returns (bool _isBadData, uint256 _updatedAt, uint256 _usdPerFrax)\\n    {\\n        (, int256 _answer, , uint256 _fraxUsdChainlinkUpdatedAt, ) = AggregatorV3Interface(\\n            FRAX_USD_CHAINLINK_FEED_ADDRESS\\n        ).latestRoundData();\\n\\n        // If data is stale or negative, set bad data to true and return\\n        _isBadData = _answer <= 0 || ((block.timestamp - _fraxUsdChainlinkUpdatedAt) > maximumFraxUsdOracleDelay);\\n        _updatedAt = _fraxUsdChainlinkUpdatedAt;\\n        _usdPerFrax = uint256(_answer);\\n    }\\n\\n    /// @notice The ```getFraxUsdChainlinkPrice``` function is called to get the frax/usd price from Chainlink\\n    /// @return _isBadData If the data is stale\\n    /// @return _updatedAt The timestamp of the last update\\n    /// @return _usdPerFrax The frax/usd price\\n    function getFraxUsdChainlinkPrice()\\n        external\\n        view\\n        virtual\\n        returns (bool _isBadData, uint256 _updatedAt, uint256 _usdPerFrax)\\n    {\\n        (_isBadData, _updatedAt, _usdPerFrax) = _getFraxUsdChainlinkPrice();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/abstracts/UniswapV3SingleTwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.19;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ==================== UniswapV3SingleTwapOracle =====================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Author\\n// Drake Evans: https://github.com/DrakeEvans\\n\\n// Reviewers\\n// Dennis: https://github.com/denett\\n\\n// ====================================================================\\n\\nimport { IStaticOracle } from \\\"@mean-finance/uniswap-v3-oracle/solidity/interfaces/IStaticOracle.sol\\\";\\nimport { ERC165Storage } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\\\";\\nimport { IUniswapV3SingleTwapOracle } from \\\"interfaces/oracles/abstracts/IUniswapV3SingleTwapOracle.sol\\\";\\n\\nstruct ConstructorParams {\\n    address uniswapV3PairAddress;\\n    uint32 twapDuration;\\n    address baseToken;\\n    address quoteToken;\\n}\\n\\n/// @title UniswapV3SingleTwapOracle\\n/// @author Drake Evans (Frax Finance) https://github.com/drakeevans\\n/// @notice  An oracle for UniV3 Twap prices\\nabstract contract UniswapV3SingleTwapOracle is ERC165Storage, IUniswapV3SingleTwapOracle {\\n    /// @notice address of the Uniswap V3 pair\\n    address public immutable UNI_V3_PAIR_ADDRESS;\\n\\n    /// @notice The precision of the twap\\n    uint128 public constant TWAP_PRECISION = 1e18;\\n\\n    /// @notice The base token of the twap\\n    address public immutable UNISWAP_V3_TWAP_BASE_TOKEN;\\n\\n    /// @notice The quote token of the twap\\n    address public immutable UNISWAP_V3_TWAP_QUOTE_TOKEN;\\n\\n    /// @notice The duration of the twap\\n    uint32 public twapDuration;\\n\\n    constructor(ConstructorParams memory _params) {\\n        _registerInterface({ interfaceId: type(IUniswapV3SingleTwapOracle).interfaceId });\\n\\n        UNI_V3_PAIR_ADDRESS = _params.uniswapV3PairAddress;\\n        twapDuration = _params.twapDuration;\\n        UNISWAP_V3_TWAP_BASE_TOKEN = _params.baseToken;\\n        UNISWAP_V3_TWAP_QUOTE_TOKEN = _params.quoteToken;\\n    }\\n\\n    /// @notice The ```_setTwapDuration``` function sets duration of the twap\\n    /// @param _newTwapDuration The new twap duration\\n    function _setTwapDuration(uint32 _newTwapDuration) internal {\\n        emit SetTwapDuration({ oldTwapDuration: twapDuration, newTwapDuration: _newTwapDuration });\\n        twapDuration = _newTwapDuration;\\n    }\\n\\n    function setTwapDuration(uint32 _newTwapDuration) external virtual;\\n\\n    /// @notice The ```_getUniswapV3Twap``` function is called to get the twap\\n    /// @return _twap The twap price\\n    function _getUniswapV3Twap() internal view returns (uint256 _twap) {\\n        address[] memory _pools = new address[](1);\\n        _pools[0] = UNI_V3_PAIR_ADDRESS;\\n\\n        _twap = IStaticOracle(0xB210CE856631EeEB767eFa666EC7C1C57738d438).quoteSpecificPoolsWithTimePeriod({\\n            baseAmount: TWAP_PRECISION,\\n            baseToken: UNISWAP_V3_TWAP_BASE_TOKEN,\\n            quoteToken: UNISWAP_V3_TWAP_QUOTE_TOKEN,\\n            pools: _pools,\\n            period: twapDuration\\n        });\\n    }\\n\\n    /// @notice The ```getUniswapV3Twap``` function is called to get the twap\\n    /// @return _twap The twap price\\n    function getUniswapV3Twap() external view virtual returns (uint256 _twap) {\\n        _twap = _getUniswapV3Twap();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/IDualOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IDualOracle is IERC165 {\\n    function ORACLE_PRECISION() external view returns (uint256);\\n\\n    function BASE_TOKEN_0() external view returns (address);\\n\\n    function BASE_TOKEN_0_DECIMALS() external view returns (uint256);\\n\\n    function BASE_TOKEN_1() external view returns (address);\\n\\n    function BASE_TOKEN_1_DECIMALS() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function getPricesNormalized() external view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh);\\n\\n    function getPrices() external view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh);\\n\\n    function name() external view returns (string memory);\\n\\n    function NORMALIZATION_0() external view returns (int256);\\n\\n    function NORMALIZATION_1() external view returns (int256);\\n\\n    function QUOTE_TOKEN_0() external view returns (address);\\n\\n    function QUOTE_TOKEN_0_DECIMALS() external view returns (uint256);\\n\\n    function QUOTE_TOKEN_1() external view returns (address);\\n\\n    function QUOTE_TOKEN_1_DECIMALS() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/contracts/frax-oracle/interfaces/IPriceSource.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.19;\\n\\nimport { IPriceSourceReceiver } from \\\"./IPriceSourceReceiver.sol\\\";\\n\\ninterface IPriceSource {\\n    function addRoundData(IPriceSourceReceiver _fraxOracle) external;\\n}\\n\"\r\n    },\r\n    \"src/contracts/frax-oracle/interfaces/IPriceSourceReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.19;\\n\\ninterface IPriceSourceReceiver {\\n    function addRoundData(bool isBadData, uint104 priceLow, uint104 priceHigh, uint40 timestamp) external;\\n\\n    function getPrices() external view returns (bool isBadData, uint256 priceLow, uint256 priceHigh);\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/ISfrxEth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.19;\\n\\n// NOTE: This file generated from sfrxEth contract at https://etherscan.io/address/0xac3e018457b222d93114458476f3e3416abbe38f#code\\ninterface ISfrxEth {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function allowance(address, address) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function asset() external view returns (address);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function convertToAssets(uint256 shares) external view returns (uint256);\\n\\n    function convertToShares(uint256 assets) external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    function depositWithSignature(\\n        uint256 assets,\\n        address receiver,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 shares);\\n\\n    function lastRewardAmount() external view returns (uint192);\\n\\n    function lastSync() external view returns (uint32);\\n\\n    function maxDeposit(address) external view returns (uint256);\\n\\n    function maxMint(address) external view returns (uint256);\\n\\n    function maxRedeem(address owner) external view returns (uint256);\\n\\n    function maxWithdraw(address owner) external view returns (uint256);\\n\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    function name() external view returns (string memory);\\n\\n    function nonces(address) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function previewDeposit(uint256 assets) external view returns (uint256);\\n\\n    function previewMint(uint256 shares) external view returns (uint256);\\n\\n    function previewRedeem(uint256 shares) external view returns (uint256);\\n\\n    function previewWithdraw(uint256 assets) external view returns (uint256);\\n\\n    function pricePerShare() external view returns (uint256);\\n\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n\\n    function rewardsCycleEnd() external view returns (uint32);\\n\\n    function rewardsCycleLength() external view returns (uint32);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function syncRewards() external;\\n\\n    function totalAssets() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev Storage based implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165Storage is ERC165 {\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/oracles/abstracts/ICurvePoolEmaPriceOracleWithMinMax.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface ICurvePoolEmaPriceOracleWithMinMax is IERC165 {\\n    event SetMaximumCurvePoolEma(uint256 oldMaximum, uint256 newMaximum);\\n    event SetMinimumCurvePoolEma(uint256 oldMinimum, uint256 newMinimum);\\n\\n    function CURVE_POOL_EMA_PRICE_ORACLE() external view returns (address);\\n\\n    function CURVE_POOL_EMA_PRICE_ORACLE_PRECISION() external view returns (uint256);\\n\\n    function getCurvePoolToken1EmaPrice() external view returns (uint256 _emaPrice);\\n\\n    function maximumCurvePoolEma() external view returns (uint256);\\n\\n    function minimumCurvePoolEma() external view returns (uint256);\\n\\n    function setMaximumCurvePoolEma(uint256 _maximumPrice) external;\\n\\n    function setMinimumCurvePoolEma(uint256 _minimumPrice) external;\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/IEmaPriceOracleStableSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.19;\\n\\ninterface IEmaPriceOracleStableSwap {\\n    function price_oracle() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"node_modules/@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/oracles/abstracts/IEthUsdChainlinkOracleWithMaxDelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IEthUsdChainlinkOracleWithMaxDelay is IERC165 {\\n    event SetMaximumEthUsdOracleDelay(uint256 oldMaxOracleDelay, uint256 newMaxOracleDelay);\\n\\n    function ETH_USD_CHAINLINK_FEED_ADDRESS() external view returns (address);\\n\\n    function ETH_USD_CHAINLINK_FEED_DECIMALS() external view returns (uint8);\\n\\n    function ETH_USD_CHAINLINK_FEED_PRECISION() external view returns (uint256);\\n\\n    function maximumEthUsdOracleDelay() external view returns (uint256);\\n\\n    function getEthUsdChainlinkPrice() external view returns (bool _isBadData, uint256 _updatedAt, uint256 _usdPerEth);\\n\\n    function setMaximumEthUsdOracleDelay(uint256 _newMaxOracleDelay) external;\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/oracles/abstracts/IFraxUsdChainlinkOracleWithMaxDelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IFraxUsdChainlinkOracleWithMaxDelay is IERC165 {\\n    event SetMaximumFraxUsdOracleDelay(uint256 oldMaxOracleDelay, uint256 newMaxOracleDelay);\\n\\n    function FRAX_USD_CHAINLINK_FEED_ADDRESS() external view returns (address);\\n\\n    function FRAX_USD_CHAINLINK_FEED_DECIMALS() external view returns (uint8);\\n\\n    function FRAX_USD_CHAINLINK_FEED_PRECISION() external view returns (uint256);\\n\\n    function maximumFraxUsdOracleDelay() external view returns (uint256);\\n\\n    function getFraxUsdChainlinkPrice()\\n        external\\n        view\\n        returns (bool _isBadData, uint256 _updatedAt, uint256 _usdPerFrax);\\n\\n    function setMaximumFraxUsdOracleDelay(uint256 _newMaxOracleDelay) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@mean-finance/uniswap-v3-oracle/solidity/interfaces/IStaticOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.7.6 <0.9.0;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol';\\n\\n/// @title Uniswap V3 Static Oracle\\n/// @notice Oracle contract for calculating price quoting against Uniswap V3\\ninterface IStaticOracle {\\n  /// @notice Returns the address of the Uniswap V3 factory\\n  /// @dev This value is assigned during deployment and cannot be changed\\n  /// @return The address of the Uniswap V3 factory\\n  function UNISWAP_V3_FACTORY() external view returns (IUniswapV3Factory);\\n\\n  /// @notice Returns how many observations are needed per minute in Uniswap V3 oracles, on the deployed chain\\n  /// @dev This value is assigned during deployment and cannot be changed\\n  /// @return Number of observation that are needed per minute\\n  function CARDINALITY_PER_MINUTE() external view returns (uint8);\\n\\n  /// @notice Returns all supported fee tiers\\n  /// @return The supported fee tiers\\n  function supportedFeeTiers() external view returns (uint24[] memory);\\n\\n  /// @notice Returns whether a specific pair can be supported by the oracle\\n  /// @dev The pair can be provided in tokenA/tokenB or tokenB/tokenA order\\n  /// @return Whether the given pair can be supported by the oracle\\n  function isPairSupported(address tokenA, address tokenB) external view returns (bool);\\n\\n  /// @notice Returns all existing pools for the given pair\\n  /// @dev The pair can be provided in tokenA/tokenB or tokenB/tokenA order\\n  /// @return All existing pools for the given pair\\n  function getAllPoolsForPair(address tokenA, address tokenB) external view returns (address[] memory);\\n\\n  /// @notice Returns a quote, based on the given tokens and amount, by querying all of the pair's pools\\n  /// @dev If some pools are not configured correctly for the given period, then they will be ignored\\n  /// @dev Will revert if there are no pools available/configured for the pair and period combination\\n  /// @param baseAmount Amount of token to be converted\\n  /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\\n  /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\\n  /// @param period Number of seconds from which to calculate the TWAP\\n  /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\\n  /// @return queriedPools The pools that were queried to calculate the quote\\n  function quoteAllAvailablePoolsWithTimePeriod(\\n    uint128 baseAmount,\\n    address baseToken,\\n    address quoteToken,\\n    uint32 period\\n  ) external view returns (uint256 quoteAmount, address[] memory queriedPools);\\n\\n  /// @notice Returns a quote, based on the given tokens and amount, by querying only the specified fee tiers\\n  /// @dev Will revert if the pair does not have a pool for one of the given fee tiers, or if one of the pools\\n  /// is not prepared/configured correctly for the given period\\n  /// @param baseAmount Amount of token to be converted\\n  /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\\n  /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\\n  /// @param feeTiers The fee tiers to consider when calculating the quote\\n  /// @param period Number of seconds from which to calculate the TWAP\\n  /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\\n  /// @return queriedPools The pools that were queried to calculate the quote\\n  function quoteSpecificFeeTiersWithTimePeriod(\\n    uint128 baseAmount,\\n    address baseToken,\\n    address quoteToken,\\n    uint24[] calldata feeTiers,\\n    uint32 period\\n  ) external view returns (uint256 quoteAmount, address[] memory queriedPools);\\n\\n  /// @notice Returns a quote, based on the given tokens and amount, by querying only the specified pools\\n  /// @dev Will revert if one of the pools is not prepared/configured correctly for the given period\\n  /// @param baseAmount Amount of token to be converted\\n  /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\\n  /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\\n  /// @param pools The pools to consider when calculating the quote\\n  /// @param period Number of seconds from which to calculate the TWAP\\n  /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\\n  function quoteSpecificPoolsWithTimePeriod(\\n    uint128 baseAmount,\\n    address baseToken,\\n    address quoteToken,\\n    address[] calldata pools,\\n    uint32 period\\n  ) external view returns (uint256 quoteAmount);\\n\\n  /// @notice Will initialize all existing pools for the given pair, so that they can be queried with the given period in the future\\n  /// @dev Will revert if there are no pools available for the pair and period combination\\n  /// @param tokenA One of the pair's tokens\\n  /// @param tokenB The other of the pair's tokens\\n  /// @param period The period that will be guaranteed when quoting\\n  /// @return preparedPools The pools that were prepared\\n  function prepareAllAvailablePoolsWithTimePeriod(\\n    address tokenA,\\n    address tokenB,\\n    uint32 period\\n  ) external returns (address[] memory preparedPools);\\n\\n  /// @notice Will initialize the pair's pools with the specified fee tiers, so that they can be queried with the given period in the future\\n  /// @dev Will revert if the pair does not have a pool for a given fee tier\\n  /// @param tokenA One of the pair's tokens\\n  /// @param tokenB The other of the pair's tokens\\n  /// @param feeTiers The fee tiers to consider when searching for the pair's pools\\n  /// @param period The period that will be guaranteed when quoting\\n  /// @return preparedPools The pools that were prepared\\n  function prepareSpecificFeeTiersWithTimePeriod(\\n    address tokenA,\\n    address tokenB,\\n    uint24[] calldata feeTiers,\\n    uint32 period\\n  ) external returns (address[] memory preparedPools);\\n\\n  /// @notice Will initialize all given pools, so that they can be queried with the given period in the future\\n  /// @param pools The pools to initialize\\n  /// @param period The period that will be guaranteed when quoting\\n  function prepareSpecificPoolsWithTimePeriod(address[] calldata pools, uint32 period) external;\\n\\n  /// @notice Will increase observations for all existing pools for the given pair, so they start accruing information for twap calculations\\n  /// @dev Will revert if there are no pools available for the pair and period combination\\n  /// @param tokenA One of the pair's tokens\\n  /// @param tokenB The other of the pair's tokens\\n  /// @param cardinality The cardinality that will be guaranteed when quoting\\n  /// @return preparedPools The pools that were prepared\\n  function prepareAllAvailablePoolsWithCardinality(\\n    address tokenA,\\n    address tokenB,\\n    uint16 cardinality\\n  ) external returns (address[] memory preparedPools);\\n\\n  /// @notice Will increase the pair's pools with the specified fee tiers observations, so they start accruing information for twap calculations\\n  /// @dev Will revert if the pair does not have a pool for a given fee tier\\n  /// @param tokenA One of the pair's tokens\\n  /// @param tokenB The other of the pair's tokens\\n  /// @param feeTiers The fee tiers to consider when searching for the pair's pools\\n  /// @param cardinality The cardinality that will be guaranteed when quoting\\n  /// @return preparedPools The pools that were prepared\\n  function prepareSpecificFeeTiersWithCardinality(\\n    address tokenA,\\n    address tokenB,\\n    uint24[] calldata feeTiers,\\n    uint16 cardinality\\n  ) external returns (address[] memory preparedPools);\\n\\n  /// @notice Will increase all given pools observations, so they start accruing information for twap calculations\\n  /// @param pools The pools to initialize\\n  /// @param cardinality The cardinality that will be guaranteed when quoting\\n  function prepareSpecificPoolsWithCardinality(address[] calldata pools, uint16 cardinality) external;\\n\\n  /// @notice Adds support for a new fee tier\\n  /// @dev Will revert if the given tier is invalid, or already supported\\n  /// @param feeTier The new fee tier to add\\n  function addNewFeeTier(uint24 feeTier) external;\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/oracles/abstracts/IUniswapV3SingleTwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IUniswapV3SingleTwapOracle is IERC165 {\\n    event SetTwapDuration(uint256 oldTwapDuration, uint256 newTwapDuration);\\n\\n    function TWAP_PRECISION() external view returns (uint128);\\n\\n    function UNISWAP_V3_TWAP_BASE_TOKEN() external view returns (address);\\n\\n    function UNISWAP_V3_TWAP_QUOTE_TOKEN() external view returns (address);\\n\\n    function UNI_V3_PAIR_ADDRESS() external view returns (address);\\n\\n    function getUniswapV3Twap() external view returns (uint256 _twap);\\n\\n    function twapDuration() external view returns (uint32);\\n\\n    function setTwapDuration(uint32 _newTwapDuration) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a pool is created\\n    /// @param token0 The first token of the pool by address sort order\\n    /// @param token1 The second token of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param pool The address of the created pool\\n    event PoolCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        uint24 indexed fee,\\n        int24 tickSpacing,\\n        address pool\\n    );\\n\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n    /// @notice Returns the current owner of the factory\\n    /// @dev Can be changed by the current owner via setOwner\\n    /// @return The address of the factory owner\\n    function owner() external view returns (address);\\n\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n    /// @return The tick spacing\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @return pool The pool address\\n    function getPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external view returns (address pool);\\n\\n    /// @notice Creates a pool for the given two tokens and fee\\n    /// @param tokenA One of the two tokens in the desired pool\\n    /// @param tokenB The other of the two tokens in the desired pool\\n    /// @param fee The desired fee for the pool\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n    /// are invalid.\\n    /// @return pool The address of the newly created pool\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external returns (address pool);\\n\\n    /// @notice Updates the owner of the factory\\n    /// @dev Must be called by the current owner\\n    /// @param _owner The new owner of the factory\\n    function setOwner(address _owner) external;\\n\\n    /// @notice Enables a fee amount with the given tickSpacing\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=node_modules/ds-test/src/\",\r\n      \"forge-std/=node_modules/forge-std/src/\",\r\n      \"frax-std/=node_modules/frax-standard-solidity/src/\",\r\n      \"script/=src/script/\",\r\n      \"src/=src/\",\r\n      \"test/=src/test/\",\r\n      \"interfaces/=src/contracts/interfaces/\",\r\n      \"arbitrum/=node_modules/@arbitrum/\",\r\n      \"rlp/=node_modules/solidity-rlp/contracts/\",\r\n      \"@arbitrum/=node_modules/@arbitrum/\",\r\n      \"@chainlink/=node_modules/@chainlink/\",\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"@mean-finance/=node_modules/@mean-finance/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@rari-capital/=node_modules/@rari-capital/\",\r\n      \"@uniswap/=node_modules/@uniswap/\",\r\n      \"base64-sol/=node_modules/base64-sol/\",\r\n      \"frax-standard-solidity/=node_modules/frax-standard-solidity/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"solidity-bytes-utils/=node_modules/solidity-bytes-utils/\",\r\n      \"solidity-rlp/=node_modules/solidity-rlp/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"baseToken0\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"baseToken0Decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"quoteToken0\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"quoteToken0Decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"baseToken1\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"baseToken1Decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"quoteToken1\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"quoteToken1Decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"frxEthErc20\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fraxErc20\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniV3PairAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"twapDuration\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"fraxUsdChainlinkFeedAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fraxUsdMaximumOracleDelay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ethUsdChainlinkFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxEthUsdOracleDelay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"curvePoolEmaPriceOracleAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumCurvePoolEma\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumCurvePoolEma\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"timelockAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sfrxEthErc4626Address\",\"type\":\"address\"}],\"internalType\":\"struct ConstructorParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OnlyPendingTimelock\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyTimelock\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaximum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaximum\",\"type\":\"uint256\"}],\"name\":\"SetMaximumCurvePoolEma\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxOracleDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxOracleDelay\",\"type\":\"uint256\"}],\"name\":\"SetMaximumEthUsdOracleDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxOracleDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxOracleDelay\",\"type\":\"uint256\"}],\"name\":\"SetMaximumFraxUsdOracleDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinimum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinimum\",\"type\":\"uint256\"}],\"name\":\"SetMinimumCurvePoolEma\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTwapDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTwapDuration\",\"type\":\"uint256\"}],\"name\":\"SetTwapDuration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTimelock\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTimelock\",\"type\":\"address\"}],\"name\":\"TimelockTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTimelock\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTimelock\",\"type\":\"address\"}],\"name\":\"TimelockTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_TOKEN_0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_TOKEN_0_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_TOKEN_1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_TOKEN_1_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CURVE_POOL_EMA_PRICE_ORACLE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CURVE_POOL_EMA_PRICE_ORACLE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH_USD_CHAINLINK_FEED_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH_USD_CHAINLINK_FEED_DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH_USD_CHAINLINK_FEED_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FRAX_USD_CHAINLINK_FEED_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FRAX_USD_CHAINLINK_FEED_DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FRAX_USD_CHAINLINK_FEED_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NORMALIZATION_0\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NORMALIZATION_1\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORACLE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTE_TOKEN_0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTE_TOKEN_0_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTE_TOKEN_1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTE_TOKEN_1_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SFRXETH_ERC4626\",\"outputs\":[{\"internalType\":\"contract ISfrxEth\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TWAP_PRECISION\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_V3_TWAP_BASE_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_V3_TWAP_QUOTE_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNI_V3_PAIR_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptTransferTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPriceSourceReceiver\",\"name\":\"_fraxOracle\",\"type\":\"address\"}],\"name\":\"addRoundData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wethPerFrxEthCurveEma\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fraxPerFrxEthTwap\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isBadDataEthUsdChainlink\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_usdPerEthChainlink\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isBadDataFraxUsdChainlink\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_usdPerFraxChainlink\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_frxEthPerSfrxEth\",\"type\":\"uint256\"}],\"name\":\"calculatePrices\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadData\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_priceLow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceHigh\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurvePoolToken1EmaPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_emaPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEthUsdChainlinkPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadData\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_usdPerEth\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFraxPerFrxEthUniV3Twap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_fraxPerFrxEthTwap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFraxUsdChainlinkPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadData\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_usdPerFrax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFrxEthPerSfrxEthErc4626Vault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_frxEthPerSfrxEth\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadData\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_priceLow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceHigh\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPricesNormalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadDataNormal\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_priceLowNormal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceHighNormal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUniswapV3Twap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_twap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsdPerEthChainlink\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadData\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_usdPerEth\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsdPerFraxChainlink\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBadData\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_usdPerFrax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWethPerFrxEthCurveEma\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_wethPerFrxEth\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumCurvePoolEma\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumEthUsdOracleDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumFraxUsdOracleDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumCurvePoolEma\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingTimelockAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maximumPrice\",\"type\":\"uint256\"}],\"name\":\"setMaximumCurvePoolEma\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxOracleDelay\",\"type\":\"uint256\"}],\"name\":\"setMaximumEthUsdOracleDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxOracleDelay\",\"type\":\"uint256\"}],\"name\":\"setMaximumFraxUsdOracleDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumPrice\",\"type\":\"uint256\"}],\"name\":\"setMinimumCurvePoolEma\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_newTwapDuration\",\"type\":\"uint32\"}],\"name\":\"setTwapDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelockAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTimelock\",\"type\":\"address\"}],\"name\":\"transferTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twapDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_major\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_patch\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "SfrxEthUsdDualOracle", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "1000000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000003480000000000000000000000000000000000000000000000000000000000000012000000000000000000000000ac3e018457b222d93114458476f3e3416abbe38f000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000003480000000000000000000000000000000000000000000000000000000000000012000000000000000000000000ac3e018457b222d93114458476f3e3416abbe38f00000000000000000000000000000000000000000000000000000000000000120000000000000000000000005e8422345238f34275888049021821e8e08caa1f000000000000000000000000853d955acef822db058eb8505911ed77f175b99e00000000000000000000000036c060cc4b088c830a561e959a679a58205d3f560000000000000000000000000000000000000000000000000000000000000384000000000000000000000000b9e1e3a9feff48998e45fa90847ed4d467e8bcfd0000000000000000000000000000000000000000000000000000000000000f3c0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b84190000000000000000000000000000000000000000000000000000000000000f3c0000000000000000000000009c3b46c0ceb5b9e304fcd6d88fc50f7dd24b31bc0000000000000000000000000000000000000000000000000c7d713b49da00000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000008412ebf45bac1b340bbe8f318b928c466c4e39ca000000000000000000000000ac3e018457b222d93114458476f3e3416abbe38f", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}