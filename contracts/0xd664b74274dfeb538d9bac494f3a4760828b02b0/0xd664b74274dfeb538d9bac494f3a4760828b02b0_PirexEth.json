{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/PirexEth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {Errors} from \\\"./libraries/Errors.sol\\\";\\nimport {DataTypes} from \\\"./libraries/DataTypes.sol\\\";\\nimport {IPirexFees} from \\\"./interfaces/IPirexFees.sol\\\";\\nimport {PirexEthValidators} from \\\"./PirexEthValidators.sol\\\";\\n\\n/**\\n * @title  Main contract for handling interactions with pxETH\\n * @notice This contract manages various interactions with pxETH, such as deposits, redemptions, and fee adjustments.\\n * @dev    This contract inherits from PirexEthValidators and utilizes SafeTransferLib for ERC20 token transfers.\\n * @author redactedcartel.finance\\n */\\ncontract PirexEth is PirexEthValidators {\\n    /**\\n     * @notice Smart contract uses the SafeTransferLib library for secure ERC20 token transfers.\\n     * @dev    The SafeTransferLib library provides enhanced safety checks and error handling for ERC20 token transfers,\\n     *         reducing the risk of common vulnerabilities such as reentrancy attacks. By using this library,\\n     *         the smart contract ensures safer and more reliable interactions with ERC20 tokens.\\n     */\\n    using SafeTransferLib for ERC20;\\n\\n    /**\\n     * @notice Immutable reference to the Pirex fee repository and distribution contract.\\n     * @dev    The `pirexFees` variable holds the address of the Pirex fee repository and distribution contract (IPirexFees).\\n     *         This contract is responsible for managing and distributing fees collected within the Pirex ecosystem.\\n     *         As an immutable variable, its value is set at deployment and cannot be changed thereafter.\\n     */\\n    IPirexFees public immutable pirexFees;\\n\\n    /**\\n     * @notice Mapping of maximum fees allowed for different operations in the contract.\\n     * @dev    The `maxFees` mapping associates each fee type (Deposit, Redemption, InstantRedemption) with its corresponding maximum fee percentage.\\n     *         For example, a value of 200000 represents a maximum fee of 20% (200000 / 1000000).\\n     *         Developers can access and modify these maximum fees directly through this public mapping.\\n     */\\n    mapping(DataTypes.Fees => uint32) public maxFees;\\n\\n    /**\\n     * @notice Mapping of fees for different operations in the contract.\\n     * @dev    The `fees` mapping associates each fee type (Deposit, Redemption, InstantRedemption) with its corresponding fee percentage.\\n     *         For example, a value of 5000 represents a 0.5% fee (5000 / 1000000).\\n     *         Developers can access and modify these fees directly through this public mapping.\\n     */\\n    mapping(DataTypes.Fees => uint32) public fees;\\n\\n    /**\\n     * @notice Current pause state of the contract.\\n     * @dev    The `paused` state variable indicates whether certain functionalities of the contract are currently paused or active.\\n     *         A value of 1 denotes a paused state, while 0 indicates the contract is not paused.\\n     */\\n    uint256 public paused;\\n\\n    // Events\\n    /**\\n     * @notice Event emitted when ETH is deposited, minting pxETH, and optionally compounding into the vault.\\n     * @dev    Use this event to log details about the deposit, including the caller's address, the receiver's address, whether compounding occurred, the deposited amount, received pxETH amount, and fee amount.\\n     * @param  caller          address  indexed  Address of the entity initiating the deposit.\\n     * @param  receiver        address  indexed  Address of the receiver of the minted pxETH or apxEth.\\n     * @param  shouldCompound  bool     indexed  Boolean indicating whether compounding into the vault occurred.\\n     * @param  deposited       uint256           Amount of ETH deposited.\\n     * @param  receivedAmount  uint256           Amount of pxETH minted for the receiver.\\n     * @param  feeAmount       uint256           Amount of pxETH distributed as fees.\\n     */\\n    event Deposit(\\n        address indexed caller,\\n        address indexed receiver,\\n        bool indexed shouldCompound,\\n        uint256 deposited,\\n        uint256 receivedAmount,\\n        uint256 feeAmount\\n    );\\n\\n    /**\\n     * @notice Event emitted when a redemption is initiated by burning pxETH in return for upxETH.\\n     * @dev    Use this event to log details about the redemption initiation, including the redeemed asset amount, post-fee amount, and the receiver's address.\\n     * @param  assets         uint256           Amount of pxETH burnt for the redemption.\\n     * @param  postFeeAmount  uint256           Amount of pxETH distributed to the receiver after deducting fees.\\n     * @param  receiver       address  indexed  Address of the receiver of the upxETH.\\n     */\\n    event InitiateRedemption(\\n        uint256 assets,\\n        uint256 postFeeAmount,\\n        address indexed receiver\\n    );\\n\\n    /**\\n     * @notice Event emitted when ETH is redeemed using UpxETH.\\n     * @dev    Use this event to log details about the redemption, including the tokenId, redeemed asset amount, and the receiver's address.\\n     * @param  tokenId   uint256           Identifier for the redemption batch.\\n     * @param  assets    uint256           Amount of ETH redeemed.\\n     * @param  receiver  address  indexed  Address of the receiver of the redeemed ETH.\\n     */\\n    event RedeemWithUpxEth(\\n        uint256 tokenId,\\n        uint256 assets,\\n        address indexed receiver\\n    );\\n\\n    /**\\n     * @notice Event emitted when pxETH is redeemed for ETH with fees.\\n     * @dev    Use this event to log details about pxETH redemption, including the redeemed asset amount, post-fee amount, and the receiver's address.\\n     * @param  assets         uint256           Amount of pxETH redeemed.\\n     * @param  postFeeAmount  uint256           Amount of ETH received by the receiver after deducting fees.\\n     * @param  _receiver      address  indexed  Address of the receiver of the redeemed ETH.\\n     */\\n    event RedeemWithPxEth(\\n        uint256 assets,\\n        uint256 postFeeAmount,\\n        address indexed _receiver\\n    );\\n\\n    /**\\n     * @notice Event emitted when the fee amount for a specific fee type is set.\\n     * @dev    Use this event to log changes in the fee amount for a particular fee type, including the fee type and the new fee amount.\\n     * @param  f    DataTypes.Fees  indexed (Deposit, Redemption, InstantRedemption) for which the fee amount is being set.\\n     * @param  fee  uint32                  New fee amount for the specified fee type.\\n     */\\n    event SetFee(DataTypes.Fees indexed f, uint32 fee);\\n\\n    /**\\n     * @notice Event emitted when the maximum fee for a specific fee type is set.\\n     * @dev    Use this event to log changes in the maximum fee for a particular fee type, including the fee type and the new maximum fee.\\n     * @param  f       DataTypes.Fees  indexed  Deposit, Redemption or InstantRedemption for which the maximum fee is being set.\\n     * @param  maxFee  uint32                   New maximum fee amount for the specified fee type.\\n     */\\n    event SetMaxFee(DataTypes.Fees indexed f, uint32 maxFee);\\n\\n    /**\\n     * @notice Event emitted when the contract's pause state is toggled.\\n     * @dev    Use this event to log changes in the contract's pause state, including the account triggering the change and the new state.\\n     * @param  account  address  Address of the entity toggling the pause state.\\n     * @param  state    uint256  New pause state: 1 for paused, 0 for not paused.\\n     */\\n    event SetPauseState(address account, uint256 state);\\n\\n    /**\\n     * @notice Event emitted when an emergency withdrawal occurs.\\n     * @dev    Use this event to log details about emergency withdrawals, including the receiver's address, the token involved, and the withdrawn amount.\\n     * @param  receiver address  indexed  Address of the receiver of the emergency withdrawal.\\n     * @param  token    address  indexed  Address of the token involved in the emergency withdrawal.\\n     * @param  amount   uint256           Amount withdrawn in the emergency withdrawal.\\n     */\\n    event EmergencyWithdrawal(\\n        address indexed receiver,\\n        address indexed token,\\n        uint256 amount\\n    );\\n\\n    // Modifiers\\n    /**\\n     * @dev Use this modifier to check if the contract is not currently paused before allowing function execution.\\n     */\\n    modifier whenNotPaused() {\\n        if (paused == _PAUSED) revert Errors.Paused();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Contract constructor to initialize PirexEthValidator with necessary parameters and configurations.\\n     * @dev    This constructor sets up the PirexEthValidator contract, configuring key parameters and initializing state variables.\\n     * @param  _pxEth                      address  PxETH contract address\\n     * @param  _admin                      address  Admin address\\n     * @param  _beaconChainDepositContract address  The address of the beacon chain deposit contract\\n     * @param  _upxEth                     address  UpxETH address\\n     * @param  _depositSize                uint256  Amount of eth to stake\\n     * @param  _preDepositAmount           uint256  Amount of ETH for pre-deposit\\n     * @param  _pirexFees                  address  PirexFees contract address\\n     * @param  _initialDelay               uint48   Delay required to schedule the acceptance\\n     *                                              of an access control transfer started\\n     */\\n    constructor(\\n        address _pxEth,\\n        address _admin,\\n        address _beaconChainDepositContract,\\n        address _upxEth,\\n        uint256 _depositSize,\\n        uint256 _preDepositAmount,\\n        address _pirexFees,\\n        uint48 _initialDelay\\n    )\\n        PirexEthValidators(\\n            _pxEth,\\n            _admin,\\n            _beaconChainDepositContract,\\n            _upxEth,\\n            _depositSize,\\n            _preDepositAmount,\\n            _initialDelay\\n        )\\n    {\\n        if (_pirexFees == address(0)) revert Errors.ZeroAddress();\\n\\n        pirexFees = IPirexFees(_pirexFees);\\n        maxFees[DataTypes.Fees.Deposit] = 200_000;\\n        maxFees[DataTypes.Fees.Redemption] = 200_000;\\n        maxFees[DataTypes.Fees.InstantRedemption] = 200_000;\\n        paused = _NOT_PAUSED;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            MUTATIVE FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Set fee\\n     * @dev    This function allows an entity with the GOVERNANCE_ROLE to set the fee amount for a specific fee type.\\n     * @param  f    DataTypes.Fees  Fee\\n     * @param  fee  uint32          Fee amount\\n     */\\n    function setFee(\\n        DataTypes.Fees f,\\n        uint32 fee\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        if (fee > maxFees[f]) revert Errors.InvalidFee();\\n\\n        fees[f] = fee;\\n\\n        emit SetFee(f, fee);\\n    }\\n\\n    /**\\n     * @notice Set Max fee\\n     * @dev    This function allows an entity with the GOVERNANCE_ROLE to set the maximum fee for a specific fee type.\\n     * @param  f       DataTypes.Fees  Fee\\n     * @param  maxFee  uint32          Max fee amount\\n     */\\n    function setMaxFee(\\n        DataTypes.Fees f,\\n        uint32 maxFee\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        if (maxFee < fees[f] || maxFee > DENOMINATOR) revert Errors.InvalidMaxFee();\\n\\n        maxFees[f] = maxFee;\\n\\n        emit SetMaxFee(f, maxFee);\\n    }\\n\\n    /**\\n     * @notice Toggle the contract's pause state\\n     * @dev    This function allows an entity with the GOVERNANCE_ROLE to toggle the contract's pause state.\\n     */\\n    function togglePauseState() external onlyRole(GOVERNANCE_ROLE) {\\n        paused = paused == _PAUSED ? _NOT_PAUSED : _PAUSED;\\n\\n        emit SetPauseState(msg.sender, paused);\\n    }\\n\\n    /**\\n     * @notice Emergency withdrawal for all ERC20 tokens (except pxETH) and ETH\\n     * @dev    This function should only be called under major emergency\\n     * @param  receiver address  Receiver address\\n     * @param  token    address  Token address\\n     * @param  amount   uint256  Token amount\\n     */\\n    function emergencyWithdraw(\\n        address receiver,\\n        address token,\\n        uint256 amount\\n    ) external onlyRole(GOVERNANCE_ROLE) onlyWhenDepositEtherPaused {\\n        if (paused == _NOT_PAUSED) revert Errors.NotPaused();\\n        if (receiver == address(0)) revert Errors.ZeroAddress();\\n        if (amount == 0) revert Errors.ZeroAmount();\\n        if (token == address(pxEth)) revert Errors.InvalidToken();\\n\\n        if (token == address(0)) {\\n            // Update pendingDeposit when affected by emergency withdrawal\\n            uint256 remainingBalance = address(this).balance - amount;\\n            if (pendingDeposit > remainingBalance) {\\n                pendingDeposit = remainingBalance;\\n            }\\n\\n            // Handle ETH withdrawal\\n            (bool _success, ) = payable(receiver).call{value: amount}(\\\"\\\");\\n            assert(_success);\\n        } else {\\n            ERC20(token).safeTransfer(receiver, amount);\\n        }\\n\\n        emit EmergencyWithdrawal(receiver, token, amount);\\n    }\\n\\n    /**\\n     * @notice Handle pxETH minting in return for ETH deposits\\n     * @dev    This function handles the minting of pxETH in return for ETH deposits.\\n     * @param  receiver        address  Receiver of the minted pxETH or apxEth\\n     * @param  shouldCompound  bool     Whether to also compound into the vault\\n     * @return postFeeAmount   uint256  pxETH minted for the receiver\\n     * @return feeAmount       uint256  pxETH distributed as fees\\n     */\\n    function deposit(\\n        address receiver,\\n        bool shouldCompound\\n    )\\n        external\\n        payable\\n        whenNotPaused\\n        nonReentrant\\n        returns (uint256 postFeeAmount, uint256 feeAmount)\\n    {\\n        if (msg.value == 0) revert Errors.ZeroAmount();\\n        if (receiver == address(0)) revert Errors.ZeroAddress();\\n\\n        // Get the pxETH amounts for the receiver and the protocol (fees)\\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\\n            DataTypes.Fees.Deposit,\\n            msg.value\\n        );\\n\\n        // Mint pxETH for the receiver (or this contract if compounding) excluding fees\\n        _mintPxEth(shouldCompound ? address(this) : receiver, postFeeAmount);\\n\\n        if (shouldCompound) {\\n            // Deposit pxETH excluding fees into the autocompounding vault\\n            // then mint shares (apxETH) for the user\\n            autoPxEth.deposit(postFeeAmount, receiver);\\n        }\\n\\n        // Mint pxETH for fee distribution contract\\n        if (feeAmount != 0) {\\n            _mintPxEth(address(pirexFees), feeAmount);\\n        }\\n\\n        // Redirect the deposit to beacon chain deposit contract\\n        _addPendingDeposit(msg.value);\\n\\n        emit Deposit(\\n            msg.sender,\\n            receiver,\\n            shouldCompound,\\n            msg.value,\\n            postFeeAmount,\\n            feeAmount\\n        );\\n    }\\n\\n    /**\\n     * @notice Initiate redemption by burning pxETH in return for upxETH\\n     * @dev    This function is used to initiate redemption by burning pxETH and receiving upxETH.\\n     * @param  _assets                      uint256  If caller is AutoPxEth then apxETH; pxETH otherwise.\\n     * @param  _receiver                    address  Receiver for upxETH.\\n     * @param  _shouldTriggerValidatorExit  bool     Whether the initiation should trigger voluntary exit.\\n     * @return postFeeAmount                uint256  pxETH burnt for the receiver.\\n     * @return feeAmount                    uint256  pxETH distributed as fees.\\n     */\\n    function initiateRedemption(\\n        uint256 _assets,\\n        address _receiver,\\n        bool _shouldTriggerValidatorExit\\n    )\\n        external\\n        override\\n        whenNotPaused\\n        nonReentrant\\n        returns (uint256 postFeeAmount, uint256 feeAmount)\\n    {\\n        if (_assets == 0) revert Errors.ZeroAmount();\\n        if (_receiver == address(0)) revert Errors.ZeroAddress();\\n\\n        uint256 _pxEthAmount;\\n\\n        if (msg.sender == address(autoPxEth)) {\\n            // The pxETH amount is calculated as per apxETH-ETH ratio during current block\\n            _pxEthAmount = autoPxEth.redeem(\\n                _assets,\\n                address(this),\\n                address(this)\\n            );\\n        } else {\\n            _pxEthAmount = _assets;\\n        }\\n\\n        // Get the pxETH amounts for the receiver and the protocol (fees)\\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\\n            DataTypes.Fees.Redemption,\\n            _pxEthAmount\\n        );\\n\\n        uint256 _requiredValidators = (pendingWithdrawal + postFeeAmount) /\\n            DEPOSIT_SIZE;\\n\\n        if (_shouldTriggerValidatorExit && _requiredValidators == 0)\\n            revert Errors.NoValidatorExit();\\n\\n        if (_requiredValidators > getStakingValidatorCount())\\n            revert Errors.NotEnoughValidators();\\n\\n        emit InitiateRedemption(_pxEthAmount, postFeeAmount, _receiver);\\n\\n        address _owner = msg.sender == address(autoPxEth)\\n            ? address(this)\\n            : msg.sender;\\n\\n        _burnPxEth(_owner, postFeeAmount);\\n\\n        if (feeAmount != 0) {\\n            // Allow PirexFees to distribute fees directly from sender\\n            pxEth.operatorApprove(_owner, address(pirexFees), feeAmount);\\n\\n            // Distribute fees\\n            pirexFees.distributeFees(_owner, address(pxEth), feeAmount);\\n        }\\n\\n        _initiateRedemption(\\n            postFeeAmount,\\n            _receiver,\\n            _shouldTriggerValidatorExit\\n        );\\n    }\\n\\n    /**\\n     * @notice Bulk redeem back ETH using a set of upxEth identifiers\\n     * @dev    This function allows the bulk redemption of ETH using upxEth tokens.\\n     * @param  _tokenIds  uint256[]  Redeem batch identifiers\\n     * @param  _amounts   uint256[]  Amounts of ETH to redeem for each identifier\\n     * @param  _receiver  address    Address of the ETH receiver\\n     */\\n    function bulkRedeemWithUpxEth(\\n        uint256[] calldata _tokenIds,\\n        uint256[] calldata _amounts,\\n        address _receiver\\n    ) external whenNotPaused nonReentrant {\\n        uint256 tLen = _tokenIds.length;\\n        uint256 aLen = _amounts.length;\\n\\n        if (tLen == 0) revert Errors.EmptyArray();\\n        if (tLen != aLen) revert Errors.MismatchedArrayLengths();\\n\\n        for (uint256 i; i < tLen; ++i) {\\n            _redeemWithUpxEth(_tokenIds[i], _amounts[i], _receiver);\\n        }\\n    }\\n\\n    /**\\n     * @notice Redeem back ETH using a single upxEth identifier\\n     * @dev    This function allows the redemption of ETH using upxEth tokens.\\n     * @param  _tokenId  uint256  Redeem batch identifier\\n     * @param  _assets   uint256  Amount of ETH to redeem\\n     * @param  _receiver  address  Address of the ETH receiver\\n     */\\n    function redeemWithUpxEth(\\n        uint256 _tokenId,\\n        uint256 _assets,\\n        address _receiver\\n    ) external whenNotPaused nonReentrant {\\n        _redeemWithUpxEth(_tokenId, _assets, _receiver);\\n    }\\n\\n    /**\\n     * @notice Instant redeem back ETH using pxETH\\n     * @dev    This function burns pxETH, calculates fees, and transfers ETH to the receiver.\\n     * @param  _assets        uint256   Amount of pxETH to redeem.\\n     * @param  _receiver      address   Address of the ETH receiver.\\n     * @return postFeeAmount  uint256   Post-fee amount for the receiver.\\n     * @return feeAmount      uinit256  Fee amount sent to the PirexFees.\\n     */\\n    function instantRedeemWithPxEth(\\n        uint256 _assets,\\n        address _receiver\\n    )\\n        external\\n        whenNotPaused\\n        nonReentrant\\n        returns (uint256 postFeeAmount, uint256 feeAmount)\\n    {\\n        if (_assets == 0) revert Errors.ZeroAmount();\\n        if (_receiver == address(0)) revert Errors.ZeroAddress();\\n\\n        // Get the pxETH amounts for the receiver and the protocol (fees)\\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\\n            DataTypes.Fees.InstantRedemption,\\n            _assets\\n        );\\n\\n        if (postFeeAmount > buffer) revert Errors.NotEnoughBuffer();\\n\\n        if (feeAmount != 0) {\\n            // Allow PirexFees to distribute fees directly from sender\\n            pxEth.operatorApprove(msg.sender, address(pirexFees), feeAmount);\\n\\n            // Distribute fees\\n            pirexFees.distributeFees(msg.sender, address(pxEth), feeAmount);\\n        }\\n\\n        _burnPxEth(msg.sender, postFeeAmount);\\n        buffer -= postFeeAmount;\\n\\n        (bool _success, ) = payable(_receiver).call{value: postFeeAmount}(\\\"\\\");\\n        assert(_success);\\n\\n        emit RedeemWithPxEth(_assets, postFeeAmount, _receiver);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Redeem back ETH using upxEth\\n     * @dev    This function allows the redemption of ETH using upxEth tokens.\\n     * @param  _tokenId  uint256  Redeem batch identifier\\n     * @param  _assets   uint256  Amount of ETH to redeem\\n     * @param  _receiver  address  Address of the ETH receiver\\n     */\\n    function _redeemWithUpxEth(\\n        uint256 _tokenId,\\n        uint256 _assets,\\n        address _receiver\\n    ) internal {\\n        if (_assets == 0) revert Errors.ZeroAmount();\\n        if (_receiver == address(0)) revert Errors.ZeroAddress();\\n\\n        DataTypes.ValidatorStatus _validatorStatus = status[\\n            batchIdToValidator[_tokenId]\\n        ];\\n\\n        if (\\n            _validatorStatus != DataTypes.ValidatorStatus.Dissolved &&\\n            _validatorStatus != DataTypes.ValidatorStatus.Slashed\\n        ) {\\n            revert Errors.StatusNotDissolvedOrSlashed();\\n        }\\n\\n        if (outstandingRedemptions < _assets) revert Errors.NotEnoughETH();\\n\\n        outstandingRedemptions -= _assets;\\n        upxEth.burn(msg.sender, _tokenId, _assets);\\n\\n        (bool _success, ) = payable(_receiver).call{value: _assets}(\\\"\\\");\\n        assert(_success);\\n\\n        emit RedeemWithUpxEth(_tokenId, _assets, _receiver);\\n    }\\n\\n    /**\\n     * @dev     This function calculates the post-fee asset amount and fee amount based on the specified fee type and total assets.\\n     * @param   f              DataTypes.Fees  representing the fee type.\\n     * @param   assets         uint256         Total ETH or pxETH asset amount.\\n     * @return  postFeeAmount  uint256         Post-fee asset amount (for mint/burn/claim/etc.).\\n     * @return  feeAmount      uint256         Fee amount.\\n     */\\n    function _computeAssetAmounts(\\n        DataTypes.Fees f,\\n        uint256 assets\\n    ) internal view returns (uint256 postFeeAmount, uint256 feeAmount) {\\n        feeAmount = (assets * fees[f]) / DENOMINATOR;\\n        postFeeAmount = assets - feeAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nlibrary Errors {\\n    /**\\n     * @dev Zero address specified\\n     */\\n    error ZeroAddress();\\n\\n    /**\\n     * @dev Zero amount specified\\n     */\\n    error ZeroAmount();\\n\\n    /**\\n     * @dev Invalid fee specified\\n     */\\n    error InvalidFee();\\n\\n    /**\\n     * @dev Invalid max fee specified\\n     */\\n    error InvalidMaxFee();\\n\\n    /**\\n     * @dev Zero multiplier used\\n     */\\n    error ZeroMultiplier();\\n\\n    /**\\n     * @dev ETH deposit is paused\\n     */\\n    error DepositingEtherPaused();\\n\\n    /**\\n     * @dev ETH deposit is not paused\\n     */\\n    error DepositingEtherNotPaused();\\n\\n    /**\\n     * @dev Contract is paused\\n     */\\n    error Paused();\\n\\n    /**\\n     * @dev Contract is not paused\\n     */\\n    error NotPaused();\\n\\n    /**\\n     * @dev Validator not yet dissolved\\n     */\\n    error NotDissolved();\\n\\n    /**\\n     * @dev Validator not yet withdrawable\\n     */\\n    error NotWithdrawable();\\n\\n    /**\\n     * @dev Validator has been previously used before\\n     */\\n    error NoUsedValidator();\\n\\n    /**\\n     * @dev Not oracle adapter\\n     */\\n    error NotOracleAdapter();\\n\\n    /**\\n     * @dev Not reward recipient\\n     */\\n    error NotRewardRecipient();\\n\\n    /**\\n     * @dev Exceeding max value\\n     */\\n    error ExceedsMax();\\n\\n    /**\\n     * @dev No rewards available\\n     */\\n    error NoRewards();\\n\\n    /**\\n     * @dev Not PirexEth\\n     */\\n    error NotPirexEth();\\n\\n    /**\\n     * @dev Not minter\\n     */\\n    error NotMinter();\\n\\n    /**\\n     * @dev Not burner\\n     */\\n    error NotBurner();\\n\\n    /**\\n     * @dev Empty string\\n     */\\n    error EmptyString();\\n\\n    /**\\n     * @dev Validator is Not Staking\\n     */\\n    error ValidatorNotStaking();\\n\\n    /**\\n     * @dev not enough buffer\\n     */\\n    error NotEnoughBuffer();\\n\\n    /**\\n     * @dev validator queue empty\\n     */\\n    error ValidatorQueueEmpty();\\n\\n    /**\\n     * @dev out of bounds\\n     */\\n    error OutOfBounds();\\n\\n    /**\\n     * @dev cannot trigger validator exit\\n     */\\n    error NoValidatorExit();\\n\\n    /**\\n     * @dev cannot initiate redemption partially\\n     */\\n    error NoPartialInitiateRedemption();\\n\\n    /**\\n     * @dev not enough validators\\n     */\\n    error NotEnoughValidators();\\n\\n    /**\\n     * @dev not enough ETH\\n     */\\n    error NotEnoughETH();\\n\\n    /**\\n     * @dev max processed count is invalid (< 1)\\n     */\\n    error InvalidMaxProcessedCount();\\n\\n    /**\\n     * @dev fromIndex and toIndex are invalid\\n     */\\n    error InvalidIndexRanges();\\n\\n    /**\\n     * @dev ETH is not allowed\\n     */\\n    error NoETHAllowed();\\n\\n    /**\\n     * @dev ETH is not passed\\n     */\\n    error NoETH();\\n\\n    /**\\n     * @dev validator status is neither dissolved nor slashed\\n     */\\n    error StatusNotDissolvedOrSlashed();\\n\\n    /**\\n     * @dev validator status is neither withdrawable nor staking\\n     */\\n    error StatusNotWithdrawableOrStaking();\\n\\n    /**\\n     * @dev account is not approved\\n     */\\n    error AccountNotApproved();\\n\\n    /**\\n     * @dev invalid token specified\\n     */\\n    error InvalidToken();\\n\\n    /**\\n     * @dev not same as deposit size\\n     */\\n    error InvalidAmount();\\n\\n    /**\\n     * @dev contract not recognised\\n     */\\n    error UnrecorgnisedContract();\\n\\n    /**\\n     * @dev empty array\\n     */\\n    error EmptyArray();\\n\\n    /**\\n     * @dev arrays length mismatch\\n     */\\n    error MismatchedArrayLengths();\\n}\\n\"\r\n    },\r\n    \"src/libraries/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title DataTypes\\n * @notice Library containing various data structures and enums for the PirexEth.\\n * @dev This library provides data structures and enums crucial for the functionality of the Pirex protocol.\\n * @author redactedcartel.finance\\n */\\nlibrary DataTypes {\\n    // Validator struct type\\n    struct Validator {\\n        // Publickey of the validator\\n        bytes pubKey;\\n        // Signature associated with the validator\\n        bytes signature;\\n        // Root hash of deposit data for the validator\\n        bytes32 depositDataRoot;\\n        // beneficiazry address to receive pxEth against preDeposit\\n        address receiver;\\n    }\\n\\n    // ValidatorDeque struct type\\n    struct ValidatorDeque {\\n        // Beginning index of the validator deque\\n        int128 _begin;\\n        // End index of the validator deque\\n        int128 _end;\\n        // Mapping of validator index to Validator struct\\n        mapping(int128 => Validator) _validators;\\n    }\\n\\n    // Burner Account Type\\n    struct BurnerAccount {\\n        // Address of the burner account\\n        address account;\\n        // Amount associated with the burner account\\n        uint256 amount;\\n    }\\n\\n    // Configurable fees\\n    enum Fees {\\n        // Fee type for deposit\\n        Deposit,\\n        // Fee type for redemption\\n        Redemption,\\n        // Fee type for instant redemption\\n        InstantRedemption\\n    }\\n\\n    // Configurable contracts\\n    enum Contract {\\n        // PxEth contract\\n        PxEth,\\n        // UpxEth contract\\n        UpxEth,\\n        // AutoPxEth contract\\n        AutoPxEth,\\n        // OracleAdapter contract\\n        OracleAdapter,\\n        // PirexEth contract\\n        PirexEth,\\n        // RewardRecipient contract\\n        RewardRecipient\\n    }\\n\\n    // Validator statuses\\n    enum ValidatorStatus {\\n        // The validator is not staking and has no defined status.\\n        None,\\n        // The validator is actively participating in the staking process.\\n        // It could be in one of the following states: pending_initialized, pending_queued, or active_ongoing.\\n        Staking,\\n        // The validator has proceed with the withdrawal process.\\n        // It represents a meta state for active_exiting, exited_unslashed, and the withdrawal process being possible.\\n        Withdrawable,\\n        // The validator's status indicating that ETH is released to the pirexEthValidators\\n        // It represents the withdrawal_done status.\\n        Dissolved,\\n        // The validator's status indicating that it has been slashed due to misbehavior.\\n        // It serves as a meta state encompassing active_slashed, exited_slashed,\\n        // and the possibility of starting the withdrawal process (withdrawal_possible) or already completed (withdrawal_done)\\n        // with the release of ETH, subject to a penalty for the misbehavior.\\n        Slashed\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPirexFees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/**\\n * @title IPirexFees\\n * @notice Interface for managing fee distribution in the PirexEth.\\n * @dev This interface defines functions related to the distribution of fees in the Pirex protocol.\\n * @author redactedcartel.finance\\n */\\ninterface IPirexFees {\\n    /**\\n     * @notice Distributes fees from a specified source.\\n     * @dev This function is responsible for distributing fees in the specified token amount.\\n     * @param from   address Address representing the source of fees.\\n     * @param token  address Address of the fee token.\\n     * @param amount uint256 The amount of the fee token to be distributed.\\n     */\\n    function distributeFees(\\n        address from,\\n        address token,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/PirexEthValidators.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {ReentrancyGuard} from \\\"solmate/utils/ReentrancyGuard.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {AccessControlDefaultAdminRules} from \\\"openzeppelin-contracts/contracts/access/AccessControlDefaultAdminRules.sol\\\";\\nimport {UpxEth} from \\\"./tokens/UpxEth.sol\\\";\\nimport {Errors} from \\\"./libraries/Errors.sol\\\";\\nimport {DataTypes} from \\\"./libraries/DataTypes.sol\\\";\\nimport {ValidatorQueue} from \\\"./libraries/ValidatorQueue.sol\\\";\\nimport {IOracleAdapter} from \\\"./interfaces/IOracleAdapter.sol\\\";\\nimport {IPirexEth} from \\\"./interfaces/IPirexEth.sol\\\";\\nimport {IDepositContract} from \\\"./interfaces/IDepositContract.sol\\\";\\nimport {AutoPxEth} from \\\"./AutoPxEth.sol\\\";\\nimport {PxEth} from \\\"./PxEth.sol\\\";\\n\\n/**\\n * @title  PirexEthValidators\\n * @notice Manages validators and deposits for the Eth2.0 deposit contract\\n * @dev    This contract includes functionality for handling validator-related operations and deposits.\\n * @author redactedcartel.finance\\n */\\nabstract contract PirexEthValidators is\\n    ReentrancyGuard,\\n    AccessControlDefaultAdminRules,\\n    IPirexEth\\n{\\n    /**\\n     * @dev This library provides enhanced safety features for ERC20 token transfers, reducing the risk of common vulnerabilities.\\n     */\\n    using ValidatorQueue for DataTypes.ValidatorDeque;\\n    /**\\n     * @dev This library extends the functionality of the DataTypes.ValidatorDeque data structure to facilitate validator management.\\n     */\\n    using SafeTransferLib for ERC20;\\n\\n    /**\\n     * @notice Denominator used for mathematical calculations.\\n     * @dev    This constant is used as a divisor in various mathematical calculations\\n     *         throughout the contract to achieve precise percentages and ratios.\\n     */\\n    uint256 internal constant DENOMINATOR = 1_000_000;\\n\\n    // Roles\\n    /**\\n     * @notice The role assigned to external keepers responsible for specific protocol functions.\\n     * @dev    This role is assigned to external entities that are responsible for performing specific\\n     *         functions within the protocol, such as validator upkeep and maintenance.\\n     */\\n    bytes32 internal constant KEEPER_ROLE = keccak256(\\\"KEEPER_ROLE\\\");\\n\\n    /**\\n     * @notice The role assigned to governance entities responsible for managing protocol parameters.\\n     * @dev    This role is assigned to governance entities that have the authority to manage and\\n     *         update various protocol parameters, ensuring the smooth operation and evolution of the protocol.\\n     */\\n    bytes32 internal constant GOVERNANCE_ROLE = keccak256(\\\"GOVERNANCE_ROLE\\\");\\n\\n    /**\\n     * @notice Paused status indicator when depositing Ether is not paused.\\n     * @dev    This constant represents the status indicator when depositing Ether is not paused.\\n     *         It is used as a reference for the depositEtherPaused state variable to determine whether\\n     *         depositing Ether is currently allowed or paused.\\n     */\\n    uint256 internal constant _NOT_PAUSED = 1;\\n\\n    /**\\n     * @notice Paused status indicator when depositing Ether is paused.\\n     * @dev    This constant represents the status indicator when depositing Ether is paused.\\n     *         It is used as a reference for the depositEtherPaused state variable to determine\\n     *         whether depositing Ether is currently allowed or paused.\\n     */\\n    uint256 internal constant _PAUSED = 2;\\n\\n    /**\\n     * @notice The address of the external beacon chain deposit contract.\\n     * @dev    This variable holds the immutable address of the external beacon chain deposit contract.\\n     *         It is used to interact with the contract for depositing validators to the Ethereum 2.0 beacon chain.\\n     */\\n    address public immutable beaconChainDepositContract;\\n\\n    /**\\n     * @notice The amount of Ether that a validator must deposit before being added to the initialized validator queue.\\n     * @dev    This variable represents the immutable pre-deposit amount required for a validator to be added to the initialized validator queue.\\n     *         Validators need to deposit this amount of Ether to be put in initialized validator queue.\\n     */\\n    uint256 public immutable preDepositAmount;\\n\\n    /**\\n     * @notice The default deposit size for validators, set once during contract initialization.\\n     * @dev    This variable represents the immutable default deposit size for validators.\\n     *         It is set during the contract initialization and represents the amount of Ether a validator needs to deposit\\n     *         to participate in the Ethereum 2.0 staking process.\\n     */\\n    uint256 public immutable DEPOSIT_SIZE;\\n\\n    /**\\n     * @notice The withdrawal credentials used when processing validator withdrawals.\\n     * @dev    This variable holds the withdrawal credentials, which are used to receive valdiator rewards\\n     */\\n    bytes public withdrawalCredentials;\\n\\n    /**\\n     * @notice Buffer for instant withdrawals and emergency top-ups.\\n     * @dev    This variable represents the buffer amount,\\n     *         which is utilized for immediate withdrawals and emergency top-ups.\\n     *         It serves as a reserve to facilitate rapid withdrawals or cover unexpected events within the protocol.\\n     */\\n    uint256 public buffer;\\n\\n    /**\\n     * @notice Maximum buffer size for instant withdrawals and emergency top-ups.\\n     * @dev    This variable represents the upper limit for the buffer size,\\n     *         determining the maximum amount that can be reserved for immediate withdrawals,\\n     *         and emergency top-ups in the protocol.\\n     */\\n    uint256 public maxBufferSize;\\n\\n    /**\\n     * @notice Percentage of pxEth total supply allocated to determine the max buffer size.\\n     * @dev    This variable represents the percentage of the total supply of pxEth that is allocated\\n     *         to determine the maximum buffer size. It influences the dynamic adjustment of the buffer\\n     *         size based on the total supply of pxEth in the protocol.\\n     */\\n    uint256 public maxBufferSizePct;\\n\\n    /**\\n     * @notice Maximum count of validators to be processed in a single `_deposit` call.\\n     * @dev    This variable determines the maximum number of validators that can be processed in a single call to the `_deposit` function.\\n     *         It helps control the efficiency and gas cost of the depositing process.\\n     */\\n    uint256 public maxProcessedValidatorCount = 20;\\n\\n    // Pirex contracts\\n    /**\\n     * @notice The UpxEth contract responsible for managing the upxEth token.\\n     * @dev    This variable holds the address of the UpxEth contract,\\n     *         which represents pending redemption.\\n     */\\n    UpxEth public upxEth;\\n\\n    /**\\n     * @notice The PxEth contract responsible for managing the pxEth token.\\n     * @dev    This variable holds the address of the PxEth contract,\\n     *         which represents ETH deposit made to Dinero protocol.\\n     */\\n    PxEth public pxEth;\\n\\n    /**\\n     * @notice The AutoPxEth contract responsible for automated management of the pxEth token.\\n     * @dev    This variable holds the address of the AutoPxEth contract,\\n     *         which represents pxEth deposit to auto compounding vault.\\n     */\\n    AutoPxEth public autoPxEth;\\n\\n    /**\\n     * @notice The OracleAdapter contract responsible for interfacing with the oracle for protocol data.\\n     * @dev    This variable holds the address of the OracleAdapter contract,\\n     *         which is used to request validator exit and update its status to dissolves or slashed.\\n     */\\n    IOracleAdapter public oracleAdapter;\\n\\n    /**\\n     * @notice The address designated as the reward recipient for protocol incentives.\\n     * @dev    This variable holds the address of the entity designated to receive consensus,\\n     *         execution and MEV rewards.\\n     */\\n    address public rewardRecipient;\\n\\n    /**\\n     * @notice Indicator for whether depositing Ether to the beacon chain deposit contract is paused or not.\\n     * @dev    This variable holds the status indicator (paused or not) for depositing Ether to the beacon chain deposit contract.\\n     */\\n    uint256 public depositEtherPaused;\\n\\n    /**\\n     * @notice Buffer for pending deposits to be staked, r\\n     *         equired to be greater than or equal to multiples of DEPOSIT_SIZE, including preDepositAmount.\\n     * @dev    This variable holds the amount of pending deposits that are waiting to be staked.\\n     *         It ensures that the buffer size is sufficient for multiples of DEPOSIT_SIZE, including preDepositAmount.\\n     */\\n    uint256 public pendingDeposit;\\n\\n    /**\\n     * @notice Queue to prioritize validator spinning on a FIFO basis.\\n     * @dev    This internal variable represents a deque (double-ended queue) used to prioritize validator\\n     *         spinning based on a First-In-First-Out (FIFO) basis.\\n     */\\n    DataTypes.ValidatorDeque internal _initializedValidators;\\n\\n    /**\\n     * @notice Queue to prioritize the next validator to be exited when required on a FIFO basis.\\n     * @dev    This internal variable represents a deque (double-ended queue) used to prioritize validators\\n     *         for exiting based on a First-In-First-Out (FIFO) basis.\\n     */\\n    DataTypes.ValidatorDeque internal _stakingValidators;\\n\\n    /**\\n     * @notice Buffer for withdrawals to be unstaked, required to be greater than or equal to multiples of DEPOSIT_SIZE.\\n     * @dev    This variable holds the amount of Ether that is pending withdrawal,\\n     *         and it must be greater than or equal to multiples of DEPOSIT_SIZE.\\n     */\\n    uint256 public pendingWithdrawal;\\n\\n    /**\\n     * @notice ETH available for redemptions.\\n     * @dev    This variable represents the amount of Ether available for redemptions by burning upxEth.\\n     */\\n    uint256 public outstandingRedemptions;\\n\\n    /**\\n     * @notice Batch Id for validator's voluntary exit.\\n     * @dev    This variable represents the batch ID for a validator's voluntary exit.\\n     */\\n    uint256 public batchId;\\n\\n    /**\\n     * @notice End block for the ETH rewards calculation.\\n     * @dev    This variable represents the block number until which ETH rewards are computed.\\n     */\\n    uint256 public endBlock;\\n\\n    /**\\n     * @notice Validator statuses, mapping from validator public key to their status.\\n     * @dev    This mapping tracks the status of each validator, using their public key as the identifier.\\n     */\\n    mapping(bytes => DataTypes.ValidatorStatus) public status;\\n\\n    /**\\n     * @notice Mapping from batchId to validator public key.\\n     * @dev    This mapping tracks the batch ID of each unstaked validator\\n     */\\n    mapping(uint256 => bytes) public batchIdToValidator;\\n\\n    /**\\n     * @notice Accounts designated for burning pxEth when the buffer is used for top-up and the validator is slashed.\\n     * @dev    This mapping identifies accounts designated for burning pxEth under specific conditions.\\n     */\\n    mapping(address => bool) public burnerAccounts;\\n\\n    // Events\\n    /**\\n     * @notice Emitted when a validator is deposited, indicating the addition of a new validator.\\n     * @dev    This event is triggered when a user deposits ETH for staking, creating a new validator.\\n     *         Validators play a crucial role in the proof-of-stake consensus mechanism and contribute\\n     *         to the security and functionality of the network. The `pubKey` parameter represents the public key of the deposited validator.\\n     * @param pubKey bytes Public key of the deposited validator.\\n     */\\n    event ValidatorDeposit(bytes pubKey);\\n\\n    /**\\n     * @notice Emitted when a contract address is set.\\n     * @dev    This event is triggered when a contract address is set for a specific contract type.\\n     * @param  c                DataTypes.Contract  The type of the contract being set.\\n     * @param  contractAddress  address             The address of the contract being set.\\n     */\\n    event SetContract(DataTypes.Contract indexed c, address contractAddress);\\n\\n    /**\\n     * @notice Emitted when the status of depositing Ether is paused or unpaused.\\n     * @dev    This event is triggered when there is a change in the status of depositing Ether.\\n     *         The `newStatus` parameter indicates whether depositing Ether is currently paused or unpaused.\\n     *         Pausing depositing Ether can be useful in certain scenarios, such as during contract upgrades or emergency situations.\\n     * @param  newStatus  uint256  The new status indicating whether depositing Ether is paused or unpaused.\\n     */\\n    event DepositEtherPaused(uint256 newStatus);\\n\\n    /**\\n     * @notice Emitted when harvesting rewards.\\n     * @dev    This event is triggered when rewards are harvested. The `amount` parameter indicates the amount of rewards harvested,\\n     *         and the `endBlock` parameter specifies the block until which ETH rewards are computed.\\n     * @param  amount    uint256  The amount of rewards harvested.\\n     * @param  endBlock  uint256  The block until which ETH rewards are computed.\\n     */\\n    event Harvest(uint256 amount, uint256 endBlock);\\n\\n    /**\\n     * @notice Emitted when the max buffer size percentage is set.\\n     * @dev    This event is triggered when the max buffer size percentage is updated.\\n     *         The `pct` parameter represents the new max buffer size percentage.\\n     * @param  pct  uint256  The new max buffer size percentage.\\n     */\\n    event SetMaxBufferSizePct(uint256 pct);\\n\\n    /**\\n     * @notice Emitted when a burner account is approved.\\n     * @dev    This event is triggered when a burner account is approved.\\n     *         The `account` parameter represents the approved burner account.\\n     * @param  account  address  The approved burner account.\\n     */\\n    event ApproveBurnerAccount(address indexed account);\\n\\n    /**\\n     * @notice Emitted when a burner account is revoked.\\n     * @dev    This event is triggered when a burner account is revoked.\\n     *         The `account` parameter represents the revoked burner account.\\n     * @param  account  address  The revoked burner account.\\n     */\\n    event RevokeBurnerAccount(address indexed account);\\n\\n    /**\\n     * @notice Emitted when a validator is dissolved.\\n     * @dev    This event is triggered when a validator is dissolved, indicating the update of the validator state.\\n     * @param  pubKey  bytes  Public key of the dissolved validator.\\n     */\\n    event DissolveValidator(bytes pubKey);\\n\\n    /**\\n     * @notice Emitted when a validator is slashed.\\n     * @dev    This event is triggered when a validator is slashed, indicating the slashing action and its details.\\n     * @param  pubKey          bytes    Public key of the slashed validator.\\n     * @param  useBuffer       bool     Indicates whether a buffer is used during slashing.\\n     * @param  releasedAmount  uint256  Amount released from the Beacon chain.\\n     * @param  penalty         uint256  Penalty amount.\\n     */\\n    event SlashValidator(\\n        bytes pubKey,\\n        bool useBuffer,\\n        uint256 releasedAmount,\\n        uint256 penalty\\n    );\\n\\n    /**\\n     * @notice Emitted when a validator's stake is topped up.\\n     * @dev    This event is triggered when a validator's stake is topped up, indicating the top-up action and its details.\\n     * @param  pubKey       bytes    Public key of the topped-up validator.\\n     * @param  useBuffer    bool     Indicates whether a buffer is used during topping up.\\n     * @param  topUpAmount  uint256  Amount topped up.\\n     */\\n    event TopUp(bytes pubKey, bool useBuffer, uint256 topUpAmount);\\n\\n    /**\\n     * @notice Emitted when the maximum processed validator count is set.\\n     * @dev    This event is triggered when the maximum count of processed validators is set, indicating a change in the processing limit.\\n     * @param  count  uint256  The new maximum count of processed validators.\\n     */\\n    event SetMaxProcessedValidatorCount(uint256 count);\\n\\n    /**\\n     * @notice Emitted when the max buffer size is updated.\\n     * @dev    This event is triggered when max buffer size is updated\\n     * @param  maxBufferSize  uint256  The updated maximum buffer size.\\n     */\\n    event UpdateMaxBufferSize(uint256 maxBufferSize);\\n\\n    /**\\n     * @notice Emitted when the withdrawal credentials are set.\\n     * @dev    This event is triggered when the withdrawal credentials are updated, indicating a change in the credentials used for validator withdrawals.\\n     * @param  withdrawalCredentials  bytes  The new withdrawal credentials.\\n     */\\n    event SetWithdrawCredentials(bytes withdrawalCredentials);\\n\\n    // Modifiers\\n    /**\\n     * @dev Reverts if the sender is not the specified reward recipient. Used to control access to functions that\\n     *      are intended for the designated recipient of rewards.\\n     */\\n    modifier onlyRewardRecipient() {\\n        if (msg.sender != rewardRecipient) revert Errors.NotRewardRecipient();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if depositing Ether is not paused. Used to control access to functions that should only be\\n     *      callable when depositing Ether is in a paused state.\\n     */\\n    modifier onlyWhenDepositEtherPaused() {\\n        if (depositEtherPaused == _NOT_PAUSED)\\n            revert Errors.DepositingEtherNotPaused();\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        CONSTRUCTOR/INITIALIZATION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Initializes the PirexEthValidators contract.\\n     * @dev    Initializes the contract with the provided parameters and sets up the initial state.\\n     * @param  _pxEth                      address  PxETH contract address\\n     * @param  _admin                      address  Admin address\\n     * @param  _beaconChainDepositContract address  The address of the deposit precompile\\n     * @param  _upxEth                     address  UpxETH address\\n     * @param  _depositSize                uint256  Amount of ETH to stake\\n     * @param  _preDepositAmount           uint256  Amount of ETH for pre-deposit\\n     * @param  _initialDelay               uint48   Delay required to schedule the acceptance\\n     *                                              of an access control transfer started\\n     */\\n    constructor(\\n        address _pxEth,\\n        address _admin,\\n        address _beaconChainDepositContract,\\n        address _upxEth,\\n        uint256 _depositSize,\\n        uint256 _preDepositAmount,\\n        uint48 _initialDelay\\n    ) AccessControlDefaultAdminRules(_initialDelay, _admin) {\\n        if (_pxEth == address(0)) revert Errors.ZeroAddress();\\n        if (_beaconChainDepositContract == address(0))\\n            revert Errors.ZeroAddress();\\n        if (_upxEth == address(0)) revert Errors.ZeroAddress();\\n        if (_depositSize < 1 ether && _depositSize % 1 gwei != 0)\\n            revert Errors.ZeroMultiplier();\\n        if (\\n            _preDepositAmount > _depositSize ||\\n            _preDepositAmount < 1 ether ||\\n            _preDepositAmount % 1 gwei != 0\\n        ) revert Errors.ZeroMultiplier();\\n\\n        pxEth = PxEth(_pxEth);\\n        DEPOSIT_SIZE = _depositSize;\\n        beaconChainDepositContract = _beaconChainDepositContract;\\n        preDepositAmount = _preDepositAmount;\\n        upxEth = UpxEth(_upxEth);\\n        depositEtherPaused = _NOT_PAUSED;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                VIEW\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Get the number of initialized validators\\n     * @dev    Returns the count of validators that are ready to be staked.\\n     * @return uint256 count of validators ready to be staked\\n     */\\n    function getInitializedValidatorCount() external view returns (uint256) {\\n        return _initializedValidators.count();\\n    }\\n\\n    /**\\n     * @notice Get the number of staked validators\\n     * @dev    Returns the count of validators with staking status.\\n     * @return uint256 count of validators with staking status\\n     */\\n    function getStakingValidatorCount() public view returns (uint256) {\\n        return _stakingValidators.count();\\n    }\\n\\n    /**\\n     * @notice Get the initialized validator info at the specified index\\n     * @dev    Returns the details of the initialized validator at the given index.\\n     * @param  _i  uint256  Index\\n     * @return     bytes    Public key\\n     * @return     bytes    Withdrawal credentials\\n     * @return     bytes    Signature\\n     * @return     bytes32  Deposit data root hash\\n     * @return     address  pxETH receiver\\n     */\\n    function getInitializedValidatorAt(\\n        uint256 _i\\n    )\\n        external\\n        view\\n        returns (bytes memory, bytes memory, bytes memory, bytes32, address)\\n    {\\n        return _initializedValidators.get(withdrawalCredentials, _i);\\n    }\\n\\n    /**\\n     * @notice Get the staking validator info at the specified index\\n     * @dev    Returns the details of the staking validator at the given index.\\n     * @param  _i  uint256  Index\\n     * @return     bytes    Public key\\n     * @return     bytes    Withdrawal credentials\\n     * @return     bytes    Signature\\n     * @return     bytes32  Deposit data root hash\\n     * @return     address  pxETH receiver\\n     */\\n    function getStakingValidatorAt(\\n        uint256 _i\\n    )\\n        external\\n        view\\n        returns (bytes memory, bytes memory, bytes memory, bytes32, address)\\n    {\\n        return _stakingValidators.get(withdrawalCredentials, _i);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        RESTRICTED FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Set a contract address\\n     * @dev    Allows the governance role to set the address for a contract in the system.\\n     * @param  _contract        DataTypes.Contract  Contract\\n     * @param  contractAddress  address             Contract address\\n     */\\n    function setContract(\\n        DataTypes.Contract _contract,\\n        address contractAddress\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        if (contractAddress == address(0)) revert Errors.ZeroAddress();\\n\\n        emit SetContract(_contract, contractAddress);\\n\\n        if (_contract == DataTypes.Contract.UpxEth) {\\n            upxEth = UpxEth(contractAddress);\\n        } else if (_contract == DataTypes.Contract.PxEth) {\\n            pxEth = PxEth(contractAddress);\\n        } else if (_contract == DataTypes.Contract.AutoPxEth) {\\n            ERC20 pxEthERC20 = ERC20(address(pxEth));\\n            address oldVault = address(autoPxEth);\\n\\n            if (oldVault != address(0)) {\\n                pxEthERC20.safeApprove(oldVault, 0);\\n            }\\n\\n            autoPxEth = AutoPxEth(contractAddress);\\n            pxEthERC20.safeApprove(address(autoPxEth), type(uint256).max);\\n        } else if (_contract == DataTypes.Contract.OracleAdapter) {\\n            oracleAdapter = IOracleAdapter(contractAddress);\\n        } else if (_contract == DataTypes.Contract.RewardRecipient) {\\n            rewardRecipient = contractAddress;\\n            withdrawalCredentials = abi.encodePacked(\\n                bytes1(0x01),\\n                bytes11(0x0),\\n                contractAddress\\n            );\\n\\n            emit SetWithdrawCredentials(withdrawalCredentials);\\n        } else {\\n            revert Errors.UnrecorgnisedContract();\\n        }\\n    }\\n\\n    /**\\n     * @notice Set the percentage that will be applied to total supply of pxEth to determine maxBufferSize\\n     * @dev    Allows the governance role to set the percentage of the total supply of pxEth that will be used as maxBufferSize.\\n     * @param  _pct  uint256  Max buffer size percentage\\n     */\\n    function setMaxBufferSizePct(\\n        uint256 _pct\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        if (_pct > DENOMINATOR) {\\n            revert Errors.ExceedsMax();\\n        }\\n\\n        maxBufferSizePct = _pct;\\n\\n        emit SetMaxBufferSizePct(_pct);\\n    }\\n\\n    /**\\n     * @notice Set the maximum count of validators to be processed in a single _deposit call\\n     * @dev    Only the role with the GOVERNANCE_ROLE can execute this function.\\n     * @param _count  uint256  Maximum count of validators to be processed\\n     */\\n    function setMaxProcessedValidatorCount(\\n        uint256 _count\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        if (_count == 0) {\\n            revert Errors.InvalidMaxProcessedCount();\\n        }\\n\\n        maxProcessedValidatorCount = _count;\\n\\n        emit SetMaxProcessedValidatorCount(_count);\\n    }\\n\\n    /**\\n     * @notice Toggle the ability to deposit ETH to validators\\n     * @dev    Only the role with the GOVERNANCE_ROLE can execute this function.\\n     */\\n    function togglePauseDepositEther() external onlyRole(GOVERNANCE_ROLE) {\\n        depositEtherPaused = depositEtherPaused == _NOT_PAUSED\\n            ? _PAUSED\\n            : _NOT_PAUSED;\\n\\n        emit DepositEtherPaused(depositEtherPaused);\\n    }\\n\\n    /**\\n     * @notice Approve or revoke addresses as burner accounts\\n     * @dev    Only the role with the GOVERNANCE_ROLE can execute this function.\\n     * @param _accounts  address[]  An array of addresses to be approved or revoked as burner accounts.\\n     * @param _state     bool       A boolean indicating whether to approve (true) or revoke (false) the burner account state.\\n     */\\n    function toggleBurnerAccounts(\\n        address[] calldata _accounts,\\n        bool _state\\n    ) external onlyRole(GOVERNANCE_ROLE) {\\n        uint256 _len = _accounts.length;\\n\\n        for (uint256 _i; _i < _len; ) {\\n            address account = _accounts[_i];\\n\\n            burnerAccounts[account] = _state;\\n\\n            if (_state) {\\n                emit ApproveBurnerAccount(account);\\n            } else {\\n                emit RevokeBurnerAccount(account);\\n            }\\n\\n            unchecked {\\n                ++_i;\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            MUTATIVE FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Update validator to Dissolve once Oracle confirms ETH release\\n     * @dev    Only the reward recipient can initiate the dissolution process.\\n     * @param  _pubKey  bytes  The public key of the validator to be dissolved.\\n     */\\n    function dissolveValidator(\\n        bytes calldata _pubKey\\n    ) external payable override onlyRewardRecipient {\\n        uint256 _amount = msg.value;\\n        if (_amount != DEPOSIT_SIZE) revert Errors.InvalidAmount();\\n        if (status[_pubKey] != DataTypes.ValidatorStatus.Withdrawable)\\n            revert Errors.NotWithdrawable();\\n\\n        status[_pubKey] = DataTypes.ValidatorStatus.Dissolved;\\n\\n        outstandingRedemptions += _amount;\\n\\n        emit DissolveValidator(_pubKey);\\n    }\\n\\n    /**\\n     * @notice Update validator state to be slashed\\n     * @dev    Only the reward recipient can initiate the slashing process.\\n     * @param  _pubKey          bytes                      The public key of the validator to be slashed.\\n     * @param  _removeIndex     uint256                    Index of the validator to be slashed.\\n     * @param  _amount          uint256                    ETH amount released from the Beacon chain.\\n     * @param  _unordered       bool                       Whether to remove from the staking validator queue in order or not.\\n     * @param  _useBuffer       bool                       Whether to use the buffer to compensate for the loss.\\n     * @param  _burnerAccounts  DataTypes.BurnerAccount[]  Burner accounts providing additional compensation.\\n     */\\n    function slashValidator(\\n        bytes calldata _pubKey,\\n        uint256 _removeIndex,\\n        uint256 _amount,\\n        bool _unordered,\\n        bool _useBuffer,\\n        DataTypes.BurnerAccount[] calldata _burnerAccounts\\n    ) external payable override onlyRewardRecipient {\\n        uint256 _ethAmount = msg.value;\\n        uint256 _defaultDepositSize = DEPOSIT_SIZE;\\n        DataTypes.ValidatorStatus _status = status[_pubKey];\\n\\n        if (\\n            _status != DataTypes.ValidatorStatus.Staking &&\\n            _status != DataTypes.ValidatorStatus.Withdrawable\\n        ) revert Errors.StatusNotWithdrawableOrStaking();\\n\\n        if (_useBuffer) {\\n            _updateBuffer(_defaultDepositSize - _ethAmount, _burnerAccounts);\\n        } else if (_ethAmount != _defaultDepositSize) {\\n            revert Errors.InvalidAmount();\\n        }\\n\\n        // It is possible that validator can be slashed while exiting\\n        if (_status == DataTypes.ValidatorStatus.Staking) {\\n            bytes memory _removedPubKey;\\n\\n            if (!_unordered) {\\n                _removedPubKey = _stakingValidators.removeOrdered(_removeIndex);\\n            } else {\\n                _removedPubKey = _stakingValidators.removeUnordered(\\n                    _removeIndex\\n                );\\n            }\\n\\n            assert(keccak256(_pubKey) == keccak256(_removedPubKey));\\n\\n            _addPendingDeposit(_defaultDepositSize);\\n        } else {\\n            outstandingRedemptions += _defaultDepositSize;\\n        }\\n        status[_pubKey] = DataTypes.ValidatorStatus.Slashed;\\n\\n        emit SlashValidator(\\n            _pubKey,\\n            _useBuffer,\\n            _amount,\\n            DEPOSIT_SIZE - _amount\\n        );\\n    }\\n\\n    /**\\n     * @notice Add multiple synced validators in the queue to be ready for staking.\\n     * @dev    Only callable when depositing Ether is paused and by a user with the GOVERNANCE_ROLE.\\n     * @param  _validators  DataTypes.Validator[]  An array of validator details (public key, withdrawal credentials, etc.).\\n     */\\n    function addInitializedValidators(\\n        DataTypes.Validator[] memory _validators\\n    ) external onlyWhenDepositEtherPaused onlyRole(GOVERNANCE_ROLE) {\\n        uint256 _arrayLength = _validators.length;\\n        for (uint256 _i; _i < _arrayLength; ) {\\n            if (\\n                status[_validators[_i].pubKey] != DataTypes.ValidatorStatus.None\\n            ) revert Errors.NoUsedValidator();\\n\\n            _initializedValidators.add(_validators[_i], withdrawalCredentials);\\n\\n            unchecked {\\n                ++_i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Swap initialized validators specified by the indexes.\\n     * @dev    Only callable when depositing Ether is paused and by a user with the GOVERNANCE_ROLE.\\n     * @param  _fromIndex  uint256  The index of the validator to be swapped from.\\n     * @param  _toIndex    uint256  The index of the validator to be swapped to.\\n     */\\n    function swapInitializedValidator(\\n        uint256 _fromIndex,\\n        uint256 _toIndex\\n    ) external onlyWhenDepositEtherPaused onlyRole(GOVERNANCE_ROLE) {\\n        _initializedValidators.swap(_fromIndex, _toIndex);\\n    }\\n\\n    /**\\n     * @notice Pop initialized validators from the queue.\\n     * @dev    Only callable when depositing Ether is paused and by a user with the GOVERNANCE_ROLE.\\n     * @param  _times  uint256  The count of pop operations to be performed.\\n     */\\n    function popInitializedValidator(\\n        uint256 _times\\n    ) external onlyWhenDepositEtherPaused onlyRole(GOVERNANCE_ROLE) {\\n        _initializedValidators.pop(_times);\\n    }\\n\\n    /**\\n     * @notice Remove an initialized validator from the queue.\\n     * @dev    Only callable when depositing Ether is paused and by a user with the GOVERNANCE_ROLE.\\n     * @param  _pubKey       bytes    The public key of the validator to be removed.\\n     * @param  _removeIndex  uint256  The index of the validator to be removed.\\n     * @param  _unordered    bool     A flag indicating whether removal should be unordered (true) or ordered (false).\\n     */\\n    function removeInitializedValidator(\\n        bytes calldata _pubKey,\\n        uint256 _removeIndex,\\n        bool _unordered\\n    ) external onlyWhenDepositEtherPaused onlyRole(GOVERNANCE_ROLE) {\\n        bytes memory _removedPubKey;\\n\\n        if (_unordered) {\\n            _removedPubKey = _initializedValidators.removeUnordered(\\n                _removeIndex\\n            );\\n        } else {\\n            _removedPubKey = _initializedValidators.removeOrdered(_removeIndex);\\n        }\\n\\n        assert(keccak256(_removedPubKey) == keccak256(_pubKey));\\n    }\\n\\n    /**\\n     * @notice Clear all initialized validators from the queue.\\n     * @dev    Only callable when depositing Ether is paused and by a user with the GOVERNANCE_ROLE.\\n     */\\n    function clearInitializedValidator()\\n        external\\n        onlyWhenDepositEtherPaused\\n        onlyRole(GOVERNANCE_ROLE)\\n    {\\n        _initializedValidators.clear();\\n    }\\n\\n    /**\\n     * @notice Trigger a privileged deposit to the ETH 2.0 deposit contract.\\n     * @dev    Only callable by a user with the KEEPER_ROLE and ensures that depositing Ether is not paused.\\n     *         This function initiates the deposit process to the ETH 2.0 deposit contract.\\n     */\\n    function depositPrivileged() external nonReentrant onlyRole(KEEPER_ROLE) {\\n        // Initial pause check\\n        if (depositEtherPaused == _PAUSED)\\n            revert Errors.DepositingEtherPaused();\\n\\n        _deposit();\\n    }\\n\\n    /**\\n     * @notice Top up ETH to a staking validator if the current balance drops below the effective balance.\\n     * @dev    Only callable by a user with the KEEPER_ROLE.\\n     * @param  _pubKey           bytes                      Validator public key.\\n     * @param  _signature        bytes                      A BLS12-381 signature.\\n     * @param  _depositDataRoot  bytes32                    The SHA-256 hash of the SSZ-encoded DepositData object.\\n     * @param  _topUpAmount      uint256                    Top-up amount in ETH.\\n     * @param  _useBuffer        bool                       Whether to use a buffer to compensate for the loss.\\n     * @param  _burnerAccounts   DataTypes.BurnerAccount[]  Array of burner accounts.\\n     */\\n    function topUpStake(\\n        bytes calldata _pubKey,\\n        bytes calldata _signature,\\n        bytes32 _depositDataRoot,\\n        uint256 _topUpAmount,\\n        bool _useBuffer,\\n        DataTypes.BurnerAccount[] calldata _burnerAccounts\\n    ) external payable nonReentrant onlyRole(KEEPER_ROLE) {\\n        if (status[_pubKey] != DataTypes.ValidatorStatus.Staking)\\n            revert Errors.ValidatorNotStaking();\\n\\n        if (_useBuffer) {\\n            if (msg.value > 0) {\\n                revert Errors.NoETHAllowed();\\n            }\\n            _updateBuffer(_topUpAmount, _burnerAccounts);\\n        } else if (msg.value != _topUpAmount) {\\n            revert Errors.NoETH();\\n        }\\n\\n        (bool success, ) = beaconChainDepositContract.call{value: _topUpAmount}(\\n            abi.encodeCall(\\n                IDepositContract.deposit,\\n                (_pubKey, withdrawalCredentials, _signature, _depositDataRoot)\\n            )\\n        );\\n\\n        assert(success);\\n\\n        emit TopUp(_pubKey, _useBuffer, _topUpAmount);\\n    }\\n\\n    /**\\n     * @notice Harvest and mint staking rewards when available.\\n     * @dev    Only callable by the reward recipient.\\n     * @param  _endBlock  uint256  Block until which ETH rewards are computed.\\n     */\\n    function harvest(\\n        uint256 _endBlock\\n    ) external payable override onlyRewardRecipient {\\n        if (msg.value != 0) {\\n            // update end block\\n            endBlock = _endBlock;\\n\\n            // Mint pxETH directly for the vault\\n            _mintPxEth(address(autoPxEth), msg.value);\\n\\n            // Update rewards tracking with the newly added rewards\\n            autoPxEth.notifyRewardAmount();\\n\\n            // Direct the excess balance for pending deposit\\n            _addPendingDeposit(msg.value);\\n\\n            emit Harvest(msg.value, _endBlock);\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev   Mints the specified amount of pxETH and updates the maximum buffer size.\\n     * @param _account  address  The address to which pxETH will be minted.\\n     * @param _amount   uint256  The amount of pxETH to be minted.\\n     */\\n    function _mintPxEth(address _account, uint256 _amount) internal {\\n        pxEth.mint(_account, _amount);\\n        uint256 _maxBufferSize = (pxEth.totalSupply() * maxBufferSizePct) /\\n            DENOMINATOR;\\n        maxBufferSize = _maxBufferSize;\\n        emit UpdateMaxBufferSize(_maxBufferSize);\\n    }\\n\\n    /**\\n     * @dev   Burns the specified amount of pxETH from the given account and updates the maximum buffer size.\\n     * @param _account  address  The address from which pxETH will be burned.\\n     * @param _amount   uint256  The amount of pxETH to be burned.\\n     */\\n    function _burnPxEth(address _account, uint256 _amount) internal {\\n        pxEth.burn(_account, _amount);\\n        uint256 _maxBufferSize = (pxEth.totalSupply() * maxBufferSizePct) /\\n            DENOMINATOR;\\n        maxBufferSize = _maxBufferSize;\\n        emit UpdateMaxBufferSize(_maxBufferSize);\\n    }\\n\\n    /**\\n     * @dev Processes the deposit of validators, taking into account the maximum processed validator count,\\n     *      the remaining deposit amount, and the status of initialized validators. It iterates through initialized\\n     *      validators, deposits them into the Beacon chain, mints pxETH if needed, and updates the validator status.\\n     */\\n    function _deposit() internal {\\n        uint256 remainingCount = maxProcessedValidatorCount;\\n        uint256 _remainingdepositAmount = DEPOSIT_SIZE - preDepositAmount;\\n\\n        while (\\n            _initializedValidators.count() != 0 &&\\n            pendingDeposit >= _remainingdepositAmount &&\\n            remainingCount > 0\\n        ) {\\n            // Get validator information\\n            (\\n                bytes memory _pubKey,\\n                bytes memory _withdrawalCredentials,\\n                bytes memory _signature,\\n                bytes32 _depositDataRoot,\\n                address _receiver\\n            ) = _initializedValidators.getNext(withdrawalCredentials);\\n\\n            // Make sure the validator hasn't been deposited into already\\n            // to prevent sending an extra eth equal to `_remainingdepositAmount`\\n            // until withdrawals are allowed\\n            if (status[_pubKey] != DataTypes.ValidatorStatus.None)\\n                revert Errors.NoUsedValidator();\\n\\n            (bool success, ) = beaconChainDepositContract.call{\\n                value: _remainingdepositAmount\\n            }(\\n                abi.encodeCall(\\n                    IDepositContract.deposit,\\n                    (\\n                        _pubKey,\\n                        _withdrawalCredentials,\\n                        _signature,\\n                        _depositDataRoot\\n                    )\\n                )\\n            );\\n\\n            assert(success);\\n\\n            pendingDeposit -= _remainingdepositAmount;\\n\\n            if (preDepositAmount != 0) {\\n                _mintPxEth(_receiver, preDepositAmount);\\n            }\\n\\n            unchecked {\\n                --remainingCount;\\n            }\\n\\n            status[_pubKey] = DataTypes.ValidatorStatus.Staking;\\n\\n            _stakingValidators.add(\\n                DataTypes.Validator(\\n                    _pubKey,\\n                    _signature,\\n                    _depositDataRoot,\\n                    _receiver\\n                ),\\n                _withdrawalCredentials\\n            );\\n\\n            emit ValidatorDeposit(_pubKey);\\n        }\\n    }\\n\\n    /**\\n     * @dev   Adds the specified amount to the pending deposit, considering the available buffer space and deposit pause status.\\n     *        If the buffer space is available, it may be fully or partially utilized. The method then checks if depositing\\n     *        ETH is not paused and spins up a validator if conditions are met.\\n     * @param _amount  uint256  The amount of ETH to be added to the pending deposit.\\n     */\\n    function _addPendingDeposit(uint256 _amount) internal virtual {\\n        uint256 _remainingBufferSpace = (\\n            maxBufferSize > buffer ? maxBufferSize - buffer : 0\\n        );\\n        uint256 _remainingAmount = _amount;\\n\\n        if (_remainingBufferSpace != 0) {\\n            bool _canBufferSpaceFullyUtilized = _remainingBufferSpace <=\\n                _remainingAmount;\\n            buffer += _canBufferSpaceFullyUtilized\\n                ? _remainingBufferSpace\\n                : _remainingAmount;\\n            _remainingAmount -= _canBufferSpaceFullyUtilized\\n                ? _remainingBufferSpace\\n                : _remainingAmount;\\n        }\\n\\n        pendingDeposit += _remainingAmount;\\n\\n        if (depositEtherPaused == _NOT_PAUSED) {\\n            // Spin up a validator when possible\\n            _deposit();\\n        }\\n    }\\n\\n    /**\\n     * @dev   Initiates the redemption process by adding the specified amount of pxETH to the pending withdrawal.\\n     *        Iteratively processes pending withdrawals in multiples of DEPOSIT_SIZE, triggering validator exits, updating\\n     *        batch information, and changing validator statuses accordingly. The process continues until the remaining\\n     *        pending withdrawal is less than DEPOSIT_SIZE. If `_shouldTriggerValidatorExit` is true and there's remaining\\n     *        pxETH after the redemption process, the function reverts, preventing partial initiation of redemption.\\n     * @param _pxEthAmount                 uint256  The amount of pxETH to be redeemed.\\n     * @param _receiver                    address  The receiver address for upxETH.\\n     * @param _shouldTriggerValidatorExit  bool     Whether to initiate partial redemption with a validator exit or not.\\n     */\\n    function _initiateRedemption(\\n        uint256 _pxEthAmount,\\n        address _receiver,\\n        bool _shouldTriggerValidatorExit\\n    ) internal {\\n        pendingWithdrawal += _pxEthAmount;\\n\\n        while (pendingWithdrawal / DEPOSIT_SIZE != 0) {\\n            uint256 _allocationPossible = DEPOSIT_SIZE +\\n                _pxEthAmount -\\n                pendingWithdrawal;\\n\\n            upxEth.mint(_receiver, batchId, _allocationPossible, \\\"\\\");\\n\\n            (bytes memory _pubKey, , , , ) = _stakingValidators.getNext(\\n                withdrawalCredentials\\n            );\\n\\n            pendingWithdrawal -= DEPOSIT_SIZE;\\n            _pxEthAmount -= _allocationPossible;\\n\\n            oracleAdapter.requestVoluntaryExit(_pubKey);\\n\\n            batchIdToValidator[batchId++] = _pubKey;\\n            status[_pubKey] = DataTypes.ValidatorStatus.Withdrawable;\\n        }\\n\\n        if (_shouldTriggerValidatorExit && _pxEthAmount > 0)\\n            revert Errors.NoPartialInitiateRedemption();\\n\\n        if (_pxEthAmount > 0) {\\n            upxEth.mint(_receiver, batchId, _pxEthAmount, \\\"\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev   Checks if the contract has enough buffer to cover the specified amount. Iterates through the provided\\n     *        `_burnerAccounts`, verifies each account's approval status, burns the corresponding amount of pxETH, and\\n     *        updates the buffer accordingly. Reverts if there is insufficient buffer, if an account is not approved, or\\n     *        if the sum of burned amounts does not match the specified amount.\\n     * @param _amount          uint256                    The amount to be updated in the buffer.\\n     * @param _burnerAccounts  DataTypes.BurnerAccount[]  An array of burner account details (account and amount).\\n     */\\n    function _updateBuffer(\\n        uint256 _amount,\\n        DataTypes.BurnerAccount[] calldata _burnerAccounts\\n    ) private {\\n        if (buffer < _amount) {\\n            revert Errors.NotEnoughBuffer();\\n        }\\n        uint256 _len = _burnerAccounts.length;\\n        uint256 _sum;\\n\\n        for (uint256 _i; _i < _len; ) {\\n            if (!burnerAccounts[_burnerAccounts[_i].account])\\n                revert Errors.AccountNotApproved();\\n\\n            _sum += _burnerAccounts[_i].amount;\\n\\n            _burnPxEth(_burnerAccounts[_i].account, _burnerAccounts[_i].amount);\\n\\n            unchecked {\\n                ++_i;\\n            }\\n        }\\n\\n        assert(_sum == _amount);\\n        buffer -= _amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/AccessControlDefaultAdminRules.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControlDefaultAdminRules.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AccessControl.sol\\\";\\nimport \\\"./IAccessControlDefaultAdminRules.sol\\\";\\nimport \\\"../utils/math/SafeCast.sol\\\";\\nimport \\\"../interfaces/IERC5313.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows specifying special rules to manage\\n * the `DEFAULT_ADMIN_ROLE` holder, which is a sensitive role with special permissions\\n * over other roles that may potentially have privileged rights in the system.\\n *\\n * If a specific role doesn't have an admin role assigned, the holder of the\\n * `DEFAULT_ADMIN_ROLE` will have the ability to grant it and revoke it.\\n *\\n * This contract implements the following risk mitigations on top of {AccessControl}:\\n *\\n * * Only one account holds the `DEFAULT_ADMIN_ROLE` since deployment until it's potentially renounced.\\n * * Enforces a 2-step process to transfer the `DEFAULT_ADMIN_ROLE` to another account.\\n * * Enforces a configurable delay between the two steps, with the ability to cancel before the transfer is accepted.\\n * * The delay can be changed by scheduling, see {changeDefaultAdminDelay}.\\n * * It is not possible to use another role to manage the `DEFAULT_ADMIN_ROLE`.\\n *\\n * Example usage:\\n *\\n * ```solidity\\n * contract MyToken is AccessControlDefaultAdminRules {\\n *   constructor() AccessControlDefaultAdminRules(\\n *     3 days,\\n *     msg.sender // Explicit initial `DEFAULT_ADMIN_ROLE` holder\\n *    ) {}\\n * }\\n * ```\\n *\\n * _Available since v4.9._\\n */\\nabstract contract AccessControlDefaultAdminRules is IAccessControlDefaultAdminRules, IERC5313, AccessControl {\\n    // pending admin pair read/written together frequently\\n    address private _pendingDefaultAdmin;\\n    uint48 private _pendingDefaultAdminSchedule; // 0 == unset\\n\\n    uint48 private _currentDelay;\\n    address private _currentDefaultAdmin;\\n\\n    // pending delay pair read/written together frequently\\n    uint48 private _pendingDelay;\\n    uint48 private _pendingDelaySchedule; // 0 == unset\\n\\n    /**\\n     * @dev Sets the initial values for {defaultAdminDelay} and {defaultAdmin} address.\\n     */\\n    constructor(uint48 initialDelay, address initialDefaultAdmin) {\\n        require(initialDefaultAdmin != address(0), \\\"AccessControl: 0 default admin\\\");\\n        _currentDelay = initialDelay;\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialDefaultAdmin);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlDefaultAdminRules).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC5313-owner}.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return defaultAdmin();\\n    }\\n\\n    ///\\n    /// Override AccessControl role management\\n    ///\\n\\n    /**\\n     * @dev See {AccessControl-grantRole}. Reverts for `DEFAULT_ADMIN_ROLE`.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\\n        require(role != DEFAULT_ADMIN_ROLE, \\\"AccessControl: can't directly grant default admin role\\\");\\n        super.grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-revokeRole}. Reverts for `DEFAULT_ADMIN_ROLE`.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\\n        require(role != DEFAULT_ADMIN_ROLE, \\\"AccessControl: can't directly revoke default admin role\\\");\\n        super.revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-renounceRole}.\\n     *\\n     * For the `DEFAULT_ADMIN_ROLE`, it only allows renouncing in two steps by first calling\\n     * {beginDefaultAdminTransfer} to the `address(0)`, so it's required that the {pendingDefaultAdmin} schedule\\n     * has also passed when calling this function.\\n     *\\n     * After its execution, it will not be possible to call `onlyRole(DEFAULT_ADMIN_ROLE)` functions.\\n     *\\n     * NOTE: Renouncing `DEFAULT_ADMIN_ROLE` will leave the contract without a {defaultAdmin},\\n     * thereby disabling any functionality that is only available for it, and the possibility of reassigning a\\n     * non-administrated role.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\\n            (address newDefaultAdmin, uint48 schedule) = pendingDefaultAdmin();\\n            require(\\n                newDefaultAdmin == address(0) && _isScheduleSet(schedule) && _hasSchedulePassed(schedule),\\n                \\\"AccessControl: only can renounce in two delayed steps\\\"\\n            );\\n            delete _pendingDefaultAdminSchedule;\\n        }\\n        super.renounceRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-_grantRole}.\\n     *\\n     * For `DEFAULT_ADMIN_ROLE`, it only allows granting if there isn't already a {defaultAdmin} or if the\\n     * role has been previously renounced.\\n     *\\n     * NOTE: Exposing this function through another mechanism may make the `DEFAULT_ADMIN_ROLE`\\n     * assignable again. Make sure to guarantee this is the expected behavior in your implementation.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual override {\\n        if (role == DEFAULT_ADMIN_ROLE) {\\n            require(defaultAdmin() == address(0), \\\"AccessControl: default admin already granted\\\");\\n            _currentDefaultAdmin = account;\\n        }\\n        super._grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-_revokeRole}.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual override {\\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\\n            delete _currentDefaultAdmin;\\n        }\\n        super._revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-_setRoleAdmin}. Reverts for `DEFAULT_ADMIN_ROLE`.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual override {\\n        require(role != DEFAULT_ADMIN_ROLE, \\\"AccessControl: can't violate default admin rules\\\");\\n        super._setRoleAdmin(role, adminRole);\\n    }\\n\\n    ///\\n    /// AccessControlDefaultAdminRules accessors\\n    ///\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function defaultAdmin() public view virtual returns (address) {\\n        return _currentDefaultAdmin;\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function pendingDefaultAdmin() public view virtual returns (address newAdmin, uint48 schedule) {\\n        return (_pendingDefaultAdmin, _pendingDefaultAdminSchedule);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function defaultAdminDelay() public view virtual returns (uint48) {\\n        uint48 schedule = _pendingDelaySchedule;\\n        return (_isScheduleSet(schedule) && _hasSchedulePassed(schedule)) ? _pendingDelay : _currentDelay;\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function pendingDefaultAdminDelay() public view virtual returns (uint48 newDelay, uint48 schedule) {\\n        schedule = _pendingDelaySchedule;\\n        return (_isScheduleSet(schedule) && !_hasSchedulePassed(schedule)) ? (_pendingDelay, schedule) : (0, 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function defaultAdminDelayIncreaseWait() public view virtual returns (uint48) {\\n        return 5 days;\\n    }\\n\\n    ///\\n    /// AccessControlDefaultAdminRules public and internal setters for defaultAdmin/pendingDefaultAdmin\\n    ///\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function beginDefaultAdminTransfer(address newAdmin) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _beginDefaultAdminTransfer(newAdmin);\\n    }\\n\\n    /**\\n     * @dev See {beginDefaultAdminTransfer}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _beginDefaultAdminTransfer(address newAdmin) internal virtual {\\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + defaultAdminDelay();\\n        _setPendingDefaultAdmin(newAdmin, newSchedule);\\n        emit DefaultAdminTransferScheduled(newAdmin, newSchedule);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function cancelDefaultAdminTransfer() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _cancelDefaultAdminTransfer();\\n    }\\n\\n    /**\\n     * @dev See {cancelDefaultAdminTransfer}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _cancelDefaultAdminTransfer() internal virtual {\\n        _setPendingDefaultAdmin(address(0), 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function acceptDefaultAdminTransfer() public virtual {\\n        (address newDefaultAdmin, ) = pendingDefaultAdmin();\\n        require(_msgSender() == newDefaultAdmin, \\\"AccessControl: pending admin must accept\\\");\\n        _acceptDefaultAdminTransfer();\\n    }\\n\\n    /**\\n     * @dev See {acceptDefaultAdminTransfer}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _acceptDefaultAdminTransfer() internal virtual {\\n        (address newAdmin, uint48 schedule) = pendingDefaultAdmin();\\n        require(_isScheduleSet(schedule) && _hasSchedulePassed(schedule), \\\"AccessControl: transfer delay not passed\\\");\\n        _revokeRole(DEFAULT_ADMIN_ROLE, defaultAdmin());\\n        _grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\\n        delete _pendingDefaultAdmin;\\n        delete _pendingDefaultAdminSchedule;\\n    }\\n\\n    ///\\n    /// AccessControlDefaultAdminRules public and internal setters for defaultAdminDelay/pendingDefaultAdminDelay\\n    ///\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function changeDefaultAdminDelay(uint48 newDelay) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _changeDefaultAdminDelay(newDelay);\\n    }\\n\\n    /**\\n     * @dev See {changeDefaultAdminDelay}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _changeDefaultAdminDelay(uint48 newDelay) internal virtual {\\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + _delayChangeWait(newDelay);\\n        _setPendingDelay(newDelay, newSchedule);\\n        emit DefaultAdminDelayChangeScheduled(newDelay, newSchedule);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function rollbackDefaultAdminDelay() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _rollbackDefaultAdminDelay();\\n    }\\n\\n    /**\\n     * @dev See {rollbackDefaultAdminDelay}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _rollbackDefaultAdminDelay() internal virtual {\\n        _setPendingDelay(0, 0);\\n    }\\n\\n    /**\\n     * @dev Returns the amount of seconds to wait after the `newDelay` will\\n     * become the new {defaultAdminDelay}.\\n     *\\n     * The value returned guarantees that if the delay is reduced, it will go into effect\\n     * after a wait that honors the previously set delay.\\n     *\\n     * See {defaultAdminDelayIncreaseWait}.\\n     */\\n    function _delayChangeWait(uint48 newDelay) internal view virtual returns (uint48) {\\n        uint48 currentDelay = defaultAdminDelay();\\n\\n        // When increasing the delay, we schedule the delay change to occur after a period of \\\"new delay\\\" has passed, up\\n        // to a maximum given by defaultAdminDelayIncreaseWait, by default 5 days. For example, if increasing from 1 day\\n        // to 3 days, the new delay will come into effect after 3 days. If increasing from 1 day to 10 days, the new\\n        // delay will come into effect after 5 days. The 5 day wait period is intended to be able to fix an error like\\n        // using milliseconds instead of seconds.\\n        //\\n        // When decreasing the delay, we wait the difference between \\\"current delay\\\" and \\\"new delay\\\". This guarantees\\n        // that an admin transfer cannot be made faster than \\\"current delay\\\" at the time the delay change is scheduled.\\n        // For example, if decreasing from 10 days to 3 days, the new delay will come into effect after 7 days.\\n        return\\n            newDelay > currentDelay\\n                ? uint48(Math.min(newDelay, defaultAdminDelayIncreaseWait())) // no need to safecast, both inputs are uint48\\n                : currentDelay - newDelay;\\n    }\\n\\n    ///\\n    /// Private setters\\n    ///\\n\\n    /**\\n     * @dev Setter of the tuple for pending admin and its schedule.\\n     *\\n     * May emit a DefaultAdminTransferCanceled event.\\n     */\\n    function _setPendingDefaultAdmin(address newAdmin, uint48 newSchedule) private {\\n        (, uint48 oldSchedule) = pendingDefaultAdmin();\\n\\n        _pendingDefaultAdmin = newAdmin;\\n        _pendingDefaultAdminSchedule = newSchedule;\\n\\n        // An `oldSchedule` from `pendingDefaultAdmin()` is only set if it hasn't been accepted.\\n        if (_isScheduleSet(oldSchedule)) {\\n            // Emit for implicit cancellations when another default admin was scheduled.\\n            emit DefaultAdminTransferCanceled();\\n        }\\n    }\\n\\n    /**\\n     * @dev Setter of the tuple for pending delay and its schedule.\\n     *\\n     * May emit a DefaultAdminDelayChangeCanceled event.\\n     */\\n    function _setPendingDelay(uint48 newDelay, uint48 newSchedule) private {\\n        uint48 oldSchedule = _pendingDelaySchedule;\\n\\n        if (_isScheduleSet(oldSchedule)) {\\n            if (_hasSchedulePassed(oldSchedule)) {\\n                // Materialize a virtual delay\\n                _currentDelay = _pendingDelay;\\n            } else {\\n                // Emit for implicit cancellations when another delay was scheduled.\\n                emit DefaultAdminDelayChangeCanceled();\\n            }\\n        }\\n\\n        _pendingDelay = newDelay;\\n        _pendingDelaySchedule = newSchedule;\\n    }\\n\\n    ///\\n    /// Private helpers\\n    ///\\n\\n    /**\\n     * @dev Defines if an `schedule` is considered set. For consistency purposes.\\n     */\\n    function _isScheduleSet(uint48 schedule) private pure returns (bool) {\\n        return schedule != 0;\\n    }\\n\\n    /**\\n     * @dev Defines if an `schedule` is considered passed. For consistency purposes.\\n     */\\n    function _hasSchedulePassed(uint48 schedule) private view returns (bool) {\\n        return schedule < block.timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tokens/UpxEth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/presets/ERC1155PresetMinterPauser.sol)\\n\\npragma solidity 0.8.19;\\n\\nimport {ERC1155} from \\\"solmate/tokens/ERC1155.sol\\\";\\nimport {AccessControlDefaultAdminRules} from \\\"openzeppelin-contracts/contracts/access/AccessControlDefaultAdminRules.sol\\\";\\n\\n/**\\n * @title UpxEth\\n * @notice Semi Fungible token contract used as an IOU by user \\n * @dev ERC1155 token contract with minting and burning capabilities, using AccessControl for role-based access.\\n *\\n * UpxEth contract includes:\\n * - Total supply tracking for each token ID\\n * - Token burning functionality for holders\\n * - Minter role for token creation\\n *\\n * The contract deploys with the default admin role, allowing it to grant minter and burner roles to other accounts.\\n * The contract uses AccessControl for role-based access control.\\n *\\n * Deprecated in favor of [Contracts Wizard](https://wizard.openzeppelin.com/).\\n * @author redactedcartel.finance\\n */\\ncontract UpxEth is AccessControlDefaultAdminRules, ERC1155 {\\n    /**\\n     * @dev Bytes32 constant representing the role to mint new tokens.\\n     */\\n    bytes32 internal constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n    /**\\n     * @dev Bytes32 constant representing the role to burn (destroy) tokens.\\n     */\\n    bytes32 internal constant BURNER_ROLE = keccak256(\\\"BURNER_ROLE\\\");\\n\\n    /**\\n     * @dev Constructor to initialize the UpxEth contract.\\n     * @param _initialDelay uint48 Initial delay for AccessControl's admin lock, set by the contract deployer.\\n     */\\n    constructor(\\n        uint48 _initialDelay\\n    ) AccessControlDefaultAdminRules(_initialDelay, msg.sender) {}\\n\\n    /**\\n     * @notice Mints new tokens for a specific address.\\n     * @dev Restricted to accounts with the MINTER_ROLE.\\n     * @param to     address Address to receive the minted tokens.\\n     * @param id     uint256 Token ID to mint.\\n     * @param amount uint256 Amount of tokens to mint.\\n     * @param data   bytes   Additional data to include in the minting transaction.\\n     */\\n    function mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external onlyRole(MINTER_ROLE) {\\n        _mint(to, id, amount, data);\\n    }\\n\\n    /**\\n     * @notice Mints a batch of new tokens for a specific address.\\n     * @dev Restricted to accounts with the MINTER_ROLE.\\n     * @param to      address   Address to receive the minted tokens.\\n     * @param ids     uint256[] Array of token IDs to mint.\\n     * @param amounts uint256[] Array of amounts of tokens to mint.\\n     * @param data    bytes     Additional data to include in the minting transaction.\\n     */\\n    function mintBatch(\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external onlyRole(MINTER_ROLE) {\\n        _batchMint(to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @notice Burns a batch of tokens from a specific address.\\n     * @dev Restricted to accounts with the BURNER_ROLE.\\n     * @param from    address   Address from which to burn tokens.\\n     * @param ids     uint256[] Array of token IDs to burn.\\n     * @param amounts uint256[] Array of amounts of tokens to burn.\\n     */\\n    function burnBatch(\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) external onlyRole(BURNER_ROLE) {\\n        _batchBurn(from, ids, amounts);\\n    }\\n\\n    /**\\n     * @notice Burns a specific amount of tokens from a specific address.\\n     * @dev Restricted to accounts with the BURNER_ROLE.\\n     * @param from   address Address from which to burn tokens.\\n     * @param id     uint256 Token ID to burn.\\n     * @param amount uint256 Amount of tokens to burn.\\n     */\\n    function burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) external onlyRole(BURNER_ROLE) {\\n        _burn(from, id, amount);\\n    }\\n\\n    /**\\n     * @inheritdoc ERC1155\\n     * @dev Not implemented due to semi-fungible only requirement\\n     */\\n    function uri(uint256 id) public view override returns (string memory) {}\\n\\n    /**\\n     * @inheritdoc ERC1155\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    )\\n        public\\n        view\\n        override(AccessControlDefaultAdminRules, ERC1155)\\n        returns (bool)\\n    {\\n        return super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/ValidatorQueue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {SafeCast} from \\\"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\\\";\\nimport {DataTypes} from \\\"./DataTypes.sol\\\";\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @title ValidatorQueue\\n * @notice Library for managing a FIFO queue of validators in the Pirex protocol.\\n * @dev This library provides functions for adding, swapping, and removing validators in the validator queue.\\n * It also includes functions for popping validators from the end of the queue, retrieving validator information, and clearing the entire queue.\\n * @author redactedcartel.finance\\n */\\nlibrary ValidatorQueue {\\n    /**\\n     * @notice Emitted when a validator is added to the queue.\\n     * @dev This event is emitted when a validator is successfully added to the end of the queue.\\n     * @param pubKey               bytes Public key of the added validator.\\n     * @param withdrawalCredential bytes Withdrawal credentials associated with the added validator.\\n     */\\n    event ValidatorAdded(bytes pubKey, bytes withdrawalCredential);\\n\\n    /**\\n     * @notice Emitted when the entire validator queue is cleared.\\n     * @dev This event is emitted when all validators are removed from the queue, clearing it completely.\\n     */\\n    event ValidatorQueueCleared();\\n\\n    /**\\n     * @notice Emitted when a validator is removed from the queue.\\n     * @dev This event is emitted when a validator is successfully removed from the queue, either ordered or unordered.\\n     * @param pubKey      bytes   Public key of the removed validator.\\n     * @param removeIndex uint256 Index of the removed validator.\\n     * @param unordered   bool    Indicates whether the removal was unordered.\\n     */\\n    event ValidatorRemoved(bytes pubKey, uint256 removeIndex, bool unordered);\\n\\n    /**\\n     * @notice Emitted when validators are popped from the front of the queue.\\n     * @dev This event is emitted when validators are successfully popped from the front of the queue.\\n     * @param times uint256 Number of pop operations performed.\\n     */\\n    event ValidatorsPopped(uint256 times);\\n\\n    /**\\n     * @notice Emitted when two validators are swapped in the queue.\\n     * @dev This event is emitted when two validators are successfully swapped in the queue.\\n     * @param fromPubKey bytes   Public key of the first validator being swapped.\\n     * @param toPubKey   bytes   Public key of the second validator being swapped.\\n     * @param fromIndex  uint256 Index of the first validator.\\n     * @param toIndex    uint256 Index of the second validator.\\n     */\\n    event ValidatorsSwapped(\\n        bytes fromPubKey,\\n        bytes toPubKey,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    );\\n\\n    /**\\n     * @notice Adds a synchronized validator to the FIFO queue, ready for staking.\\n     * @dev This function adds a validator to the end of the queue with the associated withdrawal credentials.\\n     * @param deque                 DataTypes.ValidatorDeque Storage reference to the validator deque.\\n     * @param validator             DataTypes.Validator      Validator information to be added.\\n     * @param withdrawalCredentials bytes                    Withdrawal credentials associated with the validator.\\n     */\\n    function add(\\n        DataTypes.ValidatorDeque storage deque,\\n        DataTypes.Validator memory validator,\\n        bytes memory withdrawalCredentials\\n    ) external {\\n        int128 backIndex = deque._end;\\n        deque._validators[backIndex] = validator;\\n\\n        unchecked {\\n            deque._end = backIndex + 1;\\n        }\\n\\n        emit ValidatorAdded(validator.pubKey, withdrawalCredentials);\\n    }\\n\\n    /**\\n     * @notice Swaps the location of one validator with another.\\n     * @dev This function swaps the position of two validators in the queue.\\n     * @param deque     DataTypes.ValidatorDeque Storage reference to the validator deque.\\n     * @param fromIndex uint256                  Index of the validator to be swapped.\\n     * @param toIndex   uint256                  Index of the validator to swap with.\\n     */\\n    function swap(\\n        DataTypes.ValidatorDeque storage deque,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    ) public {\\n        if (fromIndex == toIndex) revert Errors.InvalidIndexRanges();\\n        if (empty(deque)) revert Errors.ValidatorQueueEmpty();\\n\\n        int128 fromidx = SafeCast.toInt128(\\n            int256(deque._begin) + SafeCast.toInt256(fromIndex)\\n        );\\n\\n        if (fromidx >= deque._end) revert Errors.OutOfBounds();\\n\\n        int128 toidx = SafeCast.toInt128(\\n            int256(deque._begin) + SafeCast.toInt256(toIndex)\\n        );\\n\\n        if (toidx >= deque._end) revert Errors.OutOfBounds();\\n\\n        // Get the original values\\n        DataTypes.Validator memory fromVal = deque._validators[fromidx];\\n        DataTypes.Validator memory toVal = deque._validators[toidx];\\n\\n        // Set the swapped values\\n        deque._validators[toidx] = fromVal;\\n        deque._validators[fromidx] = toVal;\\n\\n        emit ValidatorsSwapped(\\n            fromVal.pubKey,\\n            toVal.pubKey,\\n            fromIndex,\\n            toIndex\\n        );\\n    }\\n\\n    /**\\n     * @notice Removes validators from the end of the queue, in case they were added in error.\\n     * @dev This function removes validators from the end of the queue, specified by the number of times to pop.\\n     * @param  deque     DataTypes.ValidatorDeque Storage reference to the validator deque.\\n     * @param  times     uint256                  Number of pop operations to perform.\\n     * @return validator DataTypes.Validator      Removed and returned validator.\\n     */\\n    function pop(\\n        DataTypes.ValidatorDeque storage deque,\\n        uint256 times\\n    ) public returns (DataTypes.Validator memory validator) {\\n        // Loop through and remove validator entries at the end\\n        for (uint256 _i; _i < times; ) {\\n            if (empty(deque)) revert Errors.ValidatorQueueEmpty();\\n\\n            int128 backIndex;\\n\\n            unchecked {\\n                backIndex = deque._end - 1;\\n                ++_i;\\n            }\\n\\n            validator = deque._validators[backIndex];\\n            delete deque._validators[backIndex];\\n            deque._end = backIndex;\\n        }\\n\\n        emit ValidatorsPopped(times);\\n    }\\n\\n    /**\\n     * @notice Check if the deque is empty\\n     * @dev Returns true if the validator deque is empty, otherwise false.\\n     * @param deque DataTypes.ValidatorDeque Storage reference to the validator deque.\\n     * @return      bool                     True if the deque is empty, otherwise false.\\n     */\\n    function empty(\\n        DataTypes.ValidatorDeque storage deque\\n    ) public view returns (bool) {\\n        return deque._end <= deque._begin;\\n    }\\n\\n    /**\\n     * @notice Remove a validator from the array using a more gas-efficient loop.\\n     * @dev Removes a validator at the specified index and emits an event.\\n     * @param  deque         DataTypes.ValidatorDeque Storage reference to the validator deque.\\n     * @param  removeIndex   uint256                  Index of the validator to remove.\\n     * @return removedPubKey bytes                    Public key of the removed validator.\\n     */\\n    function removeOrdered(\\n        DataTypes.ValidatorDeque storage deque,\\n        uint256 removeIndex\\n    ) external returns (bytes memory removedPubKey) {\\n        int128 idx = SafeCast.toInt128(\\n            int256(deque._begin) + SafeCast.toInt256(removeIndex)\\n        );\\n\\n        if (idx >= deque._end) revert Errors.OutOfBounds();\\n\\n        // Get the pubkey for the validator to remove (for informational purposes)\\n        removedPubKey = deque._validators[idx].pubKey;\\n\\n        for (int128 _i = idx; _i < deque._end - 1; ) {\\n            deque._validators[_i] = deque._validators[_i + 1];\\n\\n            unchecked {\\n                ++_i;\\n            }\\n        }\\n\\n        pop(deque, 1);\\n\\n        emit ValidatorRemoved(removedPubKey, removeIndex, false);\\n    }\\n\\n    /**\\n     * @notice Remove a validator from the array using swap and pop.\\n     * @dev Removes a validator at the specified index by swapping it with the last validator and then popping the last validator.\\n     * @param  deque         DataTypes.ValidatorDeque Storage reference to the validator deque.\\n     * @param  removeIndex   uint256                  Index of the validator to remove.\\n     * @return removedPubkey bytes                    Public key of the removed validator.\\n     */\\n    function removeUnordered(\\n        DataTypes.ValidatorDeque storage deque,\\n        uint256 removeIndex\\n    ) external returns (bytes memory removedPubkey) {\\n        int128 idx = SafeCast.toInt128(\\n            int256(deque._begin) + SafeCast.toInt256(removeIndex)\\n        );\\n\\n        if (idx >= deque._end) revert Errors.OutOfBounds();\\n\\n        // Get the pubkey for the validator to remove (for informational purposes)\\n        removedPubkey = deque._validators[idx].pubKey;\\n\\n        // Swap the (validator to remove) with the last validator in the array if needed\\n        uint256 lastIndex = count(deque) - 1;\\n        if (removeIndex != lastIndex) {\\n            swap(deque, removeIndex, lastIndex);\\n        }\\n\\n        // Pop off the validator to remove, which is now at the end of the array\\n        pop(deque, 1);\\n\\n        emit ValidatorRemoved(removedPubkey, removeIndex, true);\\n    }\\n\\n    /**\\n     * @notice Remove the last validator from the validators array and return its information\\n     * @dev Removes and returns information about the last validator in the queue.\\n     * @param  deque                   DataTypes.ValidatorDeque  Deque\\n     * @param  _withdrawalCredentials  bytes                     Credentials\\n     * @return pubKey                  bytes                     Key\\n     * @return withdrawalCredentials   bytes                     Credentials\\n     * @return signature               bytes                     Signature\\n     * @return depositDataRoot         bytes32                   Deposit data root\\n     * @return receiver                address                   account to receive pxEth\\n     */\\n    function getNext(\\n        DataTypes.ValidatorDeque storage deque,\\n        bytes memory _withdrawalCredentials\\n    )\\n        external\\n        returns (\\n            bytes memory pubKey,\\n            bytes memory withdrawalCredentials,\\n            bytes memory signature,\\n            bytes32 depositDataRoot,\\n            address receiver\\n        )\\n    {\\n        if (empty(deque)) revert Errors.ValidatorQueueEmpty();\\n\\n        int128 frontIndex = deque._begin;\\n        DataTypes.Validator memory popped = deque._validators[frontIndex];\\n        delete deque._validators[frontIndex];\\n\\n        unchecked {\\n            deque._begin = frontIndex + 1;\\n        }\\n\\n        // Return the validator's information\\n        pubKey = popped.pubKey;\\n        withdrawalCredentials = _withdrawalCredentials;\\n        signature = popped.signature;\\n        depositDataRoot = popped.depositDataRoot;\\n        receiver = popped.receiver;\\n    }\\n\\n    /**\\n     * @notice Return the information of the i'th validator in the registry\\n     * @dev Returns information about the validator at the specified index without removing it from the deque.\\n     * @param  deque                   DataTypes.ValidatorDeque  Deque\\n     * @param  _withdrawalCredentials  bytes                     Credentials\\n     * @param  _index                  uint256                   Index\\n     * @return pubKey                  bytes                     Key\\n     * @return withdrawalCredentials   bytes                     Credentials\\n     * @return signature               bytes                     Signature\\n     * @return depositDataRoot         bytes32                   Deposit data root\\n     * @return receiver                address                   account to receive pxEth\\n     */\\n    function get(\\n        DataTypes.ValidatorDeque storage deque,\\n        bytes memory _withdrawalCredentials,\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (\\n            bytes memory pubKey,\\n            bytes memory withdrawalCredentials,\\n            bytes memory signature,\\n            bytes32 depositDataRoot,\\n            address receiver\\n        )\\n    {\\n        // int256(deque._begin) is a safe upcast\\n        int128 idx = SafeCast.toInt128(\\n            int256(deque._begin) + SafeCast.toInt256(_index)\\n        );\\n\\n        if (idx >= deque._end) revert Errors.OutOfBounds();\\n\\n        DataTypes.Validator memory _v = deque._validators[idx];\\n\\n        // Return the validator's information\\n        pubKey = _v.pubKey;\\n        withdrawalCredentials = _withdrawalCredentials;\\n        signature = _v.signature;\\n        depositDataRoot = _v.depositDataRoot;\\n        receiver = _v.receiver;\\n    }\\n\\n    /**\\n     * @notice Empties the validator queue.\\n     * @dev Clears the entire validator deque, setting both begin and end to 0.\\n     *      Emits an event to signal the clearing of the queue.\\n     * @param deque DataTypes.ValidatorDeque Storage reference to the validator deque.\\n     */\\n    function clear(DataTypes.ValidatorDeque storage deque) external {\\n        deque._begin = 0;\\n        deque._end = 0;\\n\\n        emit ValidatorQueueCleared();\\n    }\\n\\n    /**\\n     * @notice Returns the number of validators in the queue.\\n     * @dev Calculates and returns the number of validators in the deque.\\n     * @param deque DataTypes.ValidatorDeque Storage reference to the validator deque.\\n     * @return      uint256                  Number of validators in the deque.\\n     */\\n    function count(\\n        DataTypes.ValidatorDeque storage deque\\n    ) public view returns (uint256) {\\n        // The interface preserves the invariant that begin <= end so we assume this will not overflow.\\n        // We also assume there are at most int256.max items in the queue.\\n        unchecked {\\n            return uint256(int256(deque._end) - int256(deque._begin));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOracleAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/**\\n * @title IOracleAdapter\\n * @notice Interface for Oracle Adapters\\n * @dev This interface defines the methods for interacting with OracleAdapter.\\n * @author redactedcartel.finance\\n */\\n\\ninterface IOracleAdapter {\\n    /**\\n     * @notice Requests a voluntary exit for a specific public key\\n     * @dev This function is used to initiate a voluntary exit process.\\n     * @param _pubKey bytes The public key of the entity requesting the exit.\\n     */\\n    function requestVoluntaryExit(bytes calldata _pubKey) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPirexEth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport {DataTypes} from \\\"../libraries/DataTypes.sol\\\";\\n\\n/**\\n * @title IPirexEth\\n * @notice Interface for the PirexEth contract\\n * @dev This interface defines the methods for interacting with PirexEth.\\n * @author redactedcartel.finance\\n */\\ninterface IPirexEth {\\n    /**\\n     * @notice Initiate redemption by burning pxETH in return for upxETH\\n     * @dev This function allows the initiation of redemption by burning pxETH in exchange for upxETH.\\n     * @param _assets                     uint256 The amount of assets to burn. If the caller is AutoPxEth, then apxETH; pxETH otherwise.\\n     * @param _receiver                   address The address to receive upxETH.\\n     * @param _shouldTriggerValidatorExit bool    Whether the initiation should trigger voluntary exit.\\n     * @return postFeeAmount              uint256 The amount of pxETH burnt for the receiver.\\n     * @return feeAmount                  uint256 The amount of pxETH distributed as fees.\\n     */\\n    function initiateRedemption(\\n        uint256 _assets,\\n        address _receiver,\\n        bool _shouldTriggerValidatorExit\\n    ) external returns (uint256 postFeeAmount, uint256 feeAmount);\\n\\n    /**\\n     * @notice Dissolve validator\\n     * @dev This function dissolves a validator.\\n     * @param _pubKey bytes The public key of the validator.\\n     */\\n    function dissolveValidator(bytes calldata _pubKey) external payable;\\n\\n    /**\\n     * @notice Update validator state to be slashed\\n     * @dev This function updates the validator state to be slashed.\\n     * @param _pubKey         bytes                     The public key of the validator.\\n     * @param _removeIndex    uint256                   The index of the validator to be slashed.\\n     * @param _amount         uint256                   The ETH amount released from the Beacon chain.\\n     * @param _unordered      bool                      Whether to remove from the staking validator queue in order or not.\\n     * @param _useBuffer      bool                      Whether to use a buffer to compensate for the loss.\\n     * @param _burnerAccounts DataTypes.BurnerAccount[] Burner accounts.\\n     */\\n    function slashValidator(\\n        bytes calldata _pubKey,\\n        uint256 _removeIndex,\\n        uint256 _amount,\\n        bool _unordered,\\n        bool _useBuffer,\\n        DataTypes.BurnerAccount[] calldata _burnerAccounts\\n    ) external payable;\\n\\n    /**\\n     * @notice Harvest and mint staking rewards when available\\n     * @dev This function harvests and mints staking rewards when available.\\n     * @param _endBlock uint256 The block until which ETH rewards are computed.\\n     */\\n    function harvest(uint256 _endBlock) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IDepositContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity 0.8.19;\\n\\n// This interface is designed to be compatible with the Vyper version.\\n/// @notice This is the Ethereum 2.0 deposit contract interface.\\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\\ninterface IDepositContract {\\n    /// @notice Submit a Phase 0 DepositData object.\\n    /// @param pubkey A BLS12-381 public key.\\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\\n    /// @param signature A BLS12-381 signature.\\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\\n    /// Used as a protection against malformed input.\\n    function deposit(\\n        bytes calldata pubkey,\\n        bytes calldata withdrawal_credentials,\\n        bytes calldata signature,\\n        bytes32 deposit_data_root\\n    ) external payable;\\n\\n    /// @notice Query the current deposit count.\\n    /// @return The deposit count encoded as a little endian 64-bit number.\\n    function get_deposit_count() external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"src/AutoPxEth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {Ownable2Step} from \\\"openzeppelin-contracts/contracts/access/Ownable2Step.sol\\\";\\nimport {ERC4626} from \\\"solmate/mixins/ERC4626.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {FixedPointMathLib} from \\\"solmate/utils/FixedPointMathLib.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {Errors} from \\\"./libraries/Errors.sol\\\";\\nimport {IPirexEth} from \\\"./interfaces/IPirexEth.sol\\\";\\n\\n/**\\n * @title AutoPxEth\\n * @notice Autocompounding vault for (staked) pxETH, adapted from pxCVX vault system\\n * @dev This contract enables autocompounding for pxETH assets and includes various fee mechanisms.\\n * @author redactedcartel.finance\\n */\\ncontract AutoPxEth is Ownable2Step, ERC4626 {\\n    /**\\n     * @dev Library: SafeTransferLib - Provides safe transfer functions for ERC20 tokens.\\n     */\\n    using SafeTransferLib for ERC20;\\n\\n    /**\\n     * @dev Library: FixedPointMathLib - Provides fixed-point arithmetic for uint256.\\n     */\\n    using FixedPointMathLib for uint256;\\n\\n    // Constants\\n\\n    /**\\n     * @dev Maximum withdrawal penalty percentage.\\n     */\\n    uint256 private constant MAX_WITHDRAWAL_PENALTY = 50_000;\\n    \\n\\n    /**\\n     * @dev Maximum platform fee percentage.\\n     */\\n    uint256 private constant MAX_PLATFORM_FEE = 200_000;\\n\\n    /**\\n     * @dev Fee denominator for precise fee calculations.\\n     */\\n    uint256 private constant FEE_DENOMINATOR = 1_000_000;\\n\\n    /**\\n     * @dev Duration of the rewards period.\\n     */\\n    uint256 private constant REWARDS_DURATION = 7 days;\\n\\n    // State variables for tracking rewards and actively staked assets\\n\\n    /**\\n     * @notice Reference to the PirexEth contract.\\n     */\\n    IPirexEth public pirexEth;\\n    \\n    /**\\n     * @notice Timestamp when the current rewards period will end.\\n     */\\n    uint256 public periodFinish;\\n    \\n    /**\\n     * @notice Rate at which rewards are distributed per second.\\n     */\\n    uint256 public rewardRate;\\n    \\n    /**\\n     * @notice Timestamp of the last update to the reward variables.\\n     */\\n    uint256 public lastUpdateTime;\\n    \\n    /**\\n     * @notice Accumulated reward per token stored.\\n     */\\n    uint256 public rewardPerTokenStored;\\n    \\n    /**\\n     * @notice Last calculated reward per token paid to stakers.\\n     */\\n    uint256 public rewardPerTokenPaid;\\n    \\n    /**\\n     * @notice Total rewards available for distribution.\\n     */\\n    uint256 public rewards;\\n    \\n    /**\\n     * @notice Total assets actively staked in the vault.\\n     */\\n    uint256 public totalStaked;\\n\\n    // State variables related to fees\\n    /**\\n     * @notice Withdrawal penalty percentage.\\n     */\\n    uint256 public withdrawalPenalty = 30_000;\\n    \\n    /**\\n     * @notice Platform fee percentage.\\n     */\\n    uint256 public platformFee = 100_000;\\n    \\n    /**\\n     * @notice Address of the platform that receives fees.\\n     */\\n    address public platform;\\n\\n    // Events\\n\\n    /**\\n     * @notice Emitted when rewards are harvested and staked.\\n     * @dev This event is emitted when a user triggers the harvest function.\\n     * @param caller address indexed Address that triggered the harvest.\\n     * @param value  uint256         Amount of rewards harvested.\\n     */\\n    event Harvest(address indexed caller, uint256 value);\\n\\n    /**\\n     * @notice Emitted when the withdrawal penalty is updated.\\n     * @dev This event is emitted when the withdrawal penalty is modified.\\n     * @param penalty uint256 New withdrawal penalty percentage.\\n     */\\n    event WithdrawalPenaltyUpdated(uint256 penalty);\\n\\n    /**\\n     * @notice Emitted when the platform fee is updated.\\n     * @dev This event is emitted when the platform fee is modified.\\n     * @param fee uint256 New platform fee percentage.\\n     */\\n    event PlatformFeeUpdated(uint256 fee);\\n    \\n    /**\\n     * @notice Emitted when the platform address is updated.\\n     * @dev This event is emitted when the platform address is modified.\\n     * @param _platform address New platform address.\\n     */\\n    event PlatformUpdated(address _platform);\\n\\n    /**\\n     * @notice Emitted when new rewards are added to the vault.\\n     * @dev This event is emitted when new rewards are added to the vault.\\n     * @param reward uint256 Amount of rewards added.\\n     */\\n    event RewardAdded(uint256 reward);\\n\\n    /**\\n     * @notice Emitted when the PirexEth contract address is set.\\n     * @dev This event is emitted when the PirexEth contract address is set.\\n     * @param _pirexEth address New PirexEth contract address.\\n     */\\n    event SetPirexEth(address _pirexEth);\\n\\n    // Modifiers\\n    /**\\n     * @dev Update reward states modifier\\n     * @param updateEarned bool Whether to update earned amount so far\\n     */\\n    modifier updateReward(bool updateEarned) {\\n        rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = lastTimeRewardApplicable();\\n\\n        if (updateEarned) {\\n            rewards = earned();\\n            rewardPerTokenPaid = rewardPerTokenStored;\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Contract constructor\\n     * @param _asset address Asset contract address\\n     * @param _platform address Platform address\\n     */\\n    constructor(\\n        address _asset,\\n        address _platform\\n    ) ERC4626(ERC20(_asset), \\\"Autocompounding Pirex Ether\\\", \\\"apxETH\\\") {\\n        if (_platform == address(0)) revert Errors.ZeroAddress();\\n\\n        platform = _platform;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        RESTRICTED FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Set the PirexEth contract address\\n     * @dev Function access restricted to only owner\\n     * @param _pirexEth address PirexEth contract address\\n     */\\n    function setPirexEth(address _pirexEth) external onlyOwner {\\n        if (_pirexEth == address(0)) revert Errors.ZeroAddress();\\n\\n        emit SetPirexEth(_pirexEth);\\n\\n        pirexEth = IPirexEth(_pirexEth);\\n    }\\n\\n    /**\\n     * @notice Set the withdrawal penalty\\n     * @dev Function access restricted to only owner\\n     * @param penalty uint256 Withdrawal penalty\\n     */\\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert Errors.ExceedsMax();\\n\\n        withdrawalPenalty = penalty;\\n\\n        emit WithdrawalPenaltyUpdated(penalty);\\n    }\\n\\n    /**\\n     * @notice Set the platform fee\\n     * @dev Function access restricted to only owner\\n     * @param fee uint256 Platform fee\\n     */\\n    function setPlatformFee(uint256 fee) external onlyOwner {\\n        if (fee > MAX_PLATFORM_FEE) revert Errors.ExceedsMax();\\n\\n        platformFee = fee;\\n\\n        emit PlatformFeeUpdated(fee);\\n    }\\n\\n    /**\\n     * @notice Set the platform\\n     * @dev Function access restricted to only owner\\n     * @param _platform address Platform\\n     */\\n    function setPlatform(address _platform) external onlyOwner {\\n        if (_platform == address(0)) revert Errors.ZeroAddress();\\n\\n        platform = _platform;\\n\\n        emit PlatformUpdated(_platform);\\n    }\\n\\n    /**\\n     * @notice Notify and sync the newly added rewards to be streamed over time\\n     * @dev Rewards are streamed following the duration set in REWARDS_DURATION\\n     */\\n    function notifyRewardAmount() external updateReward(false) {\\n        if (msg.sender != address(pirexEth)) revert Errors.NotPirexEth();\\n\\n        // Rewards transferred directly to this contract are not added to totalStaked\\n        // To get the rewards w/o relying on a potentially incorrect passed in arg,\\n        // we can use the difference between the asset balance and totalStaked.\\n        // Additionally, to avoid re-distributing rewards, deduct the output of `earned`\\n        uint256 rewardBalance = asset.balanceOf(address(this)) -\\n            totalStaked -\\n            earned();\\n\\n        rewardRate = rewardBalance / REWARDS_DURATION;\\n\\n        if (rewardRate == 0) revert Errors.NoRewards();\\n\\n        lastUpdateTime = block.timestamp;\\n        periodFinish = block.timestamp + REWARDS_DURATION;\\n\\n        emit RewardAdded(rewardBalance);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                VIEWS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @inheritdoc ERC4626\\n     * @notice Get the amount of available pxETH in the contract\\n     * @dev Rewards are streamed for the duration set in REWARDS_DURATION\\n     */\\n    function totalAssets() public view override returns (uint256) {\\n        // Based on the current totalStaked and available rewards\\n        uint256 _totalStaked = totalStaked;\\n        uint256 _rewards = ((_totalStaked *\\n            (rewardPerToken() - rewardPerTokenPaid)) / 1e18) + rewards;\\n\\n        // Deduct the exact reward amount staked (after fees are deducted when calling `harvest`)\\n        return\\n            _totalStaked +\\n            (\\n                _rewards == 0\\n                    ? 0\\n                    : (_rewards - ((_rewards * platformFee) / FEE_DENOMINATOR))\\n            );\\n    }\\n\\n    /**\\n     * @notice Returns the last effective timestamp of the current reward period\\n     * @return uint256 Timestamp\\n     */\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\\n    }\\n\\n    /**\\n     * @notice Returns the amount of rewards per staked token/asset\\n     * @return uint256 Rewards amount\\n     */\\n    function rewardPerToken() public view returns (uint256) {\\n        if (totalStaked == 0) {\\n            return rewardPerTokenStored;\\n        }\\n\\n        return\\n            rewardPerTokenStored +\\n            ((((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate) *\\n                1e18) / totalStaked);\\n    }\\n\\n    /**\\n     * @notice Returns the earned rewards amount so far\\n     * @return uint256 Rewards amount\\n     */\\n    function earned() public view returns (uint256) {\\n        return\\n            ((totalStaked * (rewardPerToken() - rewardPerTokenPaid)) / 1e18) +\\n            rewards;\\n    }\\n\\n    /**\\n     * @notice Return the amount of assets per 1 (1e18) share\\n     * @return uint256 Assets\\n     */\\n    function assetsPerShare() external view returns (uint256) {\\n        return previewRedeem(1e18);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Internal method to keep track of the total amount of staked token/asset on deposit/mint\\n     */\\n    function _stake(uint256 amount) internal updateReward(true) {\\n        totalStaked += amount;\\n    }\\n\\n    /**\\n     * @dev Internal method to keep track of the total amount of staked token/asset on withdrawal/redeem\\n     */\\n    function _withdraw(uint256 amount) internal updateReward(true) {\\n        totalStaked -= amount;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC4626 OVERRIDES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @inheritdoc ERC4626\\n     * @dev Deduct the specified amount of assets from totalStaked to prepare for transfer to the user\\n     * @param assets uint256 Assets\\n     */\\n    function beforeWithdraw(uint256 assets, uint256) internal override {\\n        // Perform harvest to make sure that totalStaked is always equal or larger than assets to be withdrawn\\n        if (assets > totalStaked) harvest();\\n\\n        _withdraw(assets);\\n    }\\n\\n    /**\\n     * @inheritdoc ERC4626\\n     * @dev Include the new assets in totalStaked so that rewards can be properly distributed\\n     * @param assets uint256 Assets\\n     */\\n    function afterDeposit(uint256 assets, uint256) internal override {\\n        _stake(assets);\\n    }\\n\\n    /**\\n     * @inheritdoc ERC4626\\n     * @dev Preview the amount of assets a user would receive from redeeming shares\\n     */\\n    function previewRedeem(\\n        uint256 shares\\n    ) public view override returns (uint256) {\\n        // Calculate assets based on a user's % ownership of vault shares\\n        uint256 assets = convertToAssets(shares);\\n\\n        uint256 _totalSupply = totalSupply;\\n\\n        // Calculate a penalty - zero if user is the last to withdraw.\\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\\n            ? 0\\n            : assets.mulDivUp(withdrawalPenalty, FEE_DENOMINATOR); // Round up the penalty in favour of the protocol.\\n\\n        // Redeemable amount is the post-penalty amount\\n        return assets - penalty;\\n    }\\n\\n    /**\\n     * @inheritdoc ERC4626\\n     * @notice Preview the amount of shares a user would need to redeem the specified asset amount\\n     * @dev This modified version takes into consideration the withdrawal fee\\n     */\\n    function previewWithdraw(\\n        uint256 assets\\n    ) public view override returns (uint256) {\\n        // Calculate shares based on the specified assets' proportion of the pool\\n        uint256 shares = convertToShares(assets);\\n\\n        // Save 1 SLOAD\\n        uint256 _totalSupply = totalSupply;\\n\\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\\n        return\\n            (_totalSupply == 0 || _totalSupply - shares == 0)\\n                ? shares\\n                : (shares * FEE_DENOMINATOR) /\\n                    (FEE_DENOMINATOR - withdrawalPenalty);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            MUTATIVE FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Harvest and stake available rewards after distributing fees to the platform\\n     * @dev This function claims and stakes the available rewards, deducting a fee for the platform.\\n     */\\n    function harvest() public updateReward(true) {\\n        uint256 _rewards = rewards;\\n\\n        if (_rewards != 0) {\\n            rewards = 0;\\n\\n            // Fee for platform\\n            uint256 feeAmount = (_rewards * platformFee) / FEE_DENOMINATOR;\\n\\n            // Deduct fee from reward balance\\n            _rewards -= feeAmount;\\n\\n            // Claimed rewards should be in pxETH\\n            asset.safeTransfer(platform, feeAmount);\\n\\n            // Stake rewards sans fee\\n            _stake(_rewards);\\n\\n            emit Harvest(msg.sender, _rewards);\\n        }\\n    }\\n\\n    /**\\n     * @notice Override transfer logic to trigger direct `initiateRedemption`.\\n     * @dev This function overrides the standard transfer logic to initiate redemption when transferring to the PirexEth contract.\\n     * @param to     address Transfer destination\\n     * @param amount uint256 Amount\\n     * @return       bool\\n     */\\n    function transfer(\\n        address to,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        super.transfer(to, amount);\\n\\n        if (to == address(pirexEth)) {\\n            pirexEth.initiateRedemption(amount, msg.sender, false);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Override transferFrom logic to trigger direct `initiateRedemption`.\\n     * @dev This function overrides the standard transferFrom logic to initiate redemption when transferring from the PirexEth contract.\\n     * @param from   Address of the transfer origin.\\n     * @param to     Address of the transfer destination.\\n     * @param amount Amount of tokens to transfer.\\n     * @return       A boolean indicating the success of the transfer.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        super.transferFrom(from, to, amount);\\n\\n        if (to == address(pirexEth)) {\\n            pirexEth.initiateRedemption(amount, from, false);\\n        }\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/PxEth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {DineroERC20} from \\\"./DineroERC20.sol\\\";\\nimport {Errors} from \\\"./libraries/Errors.sol\\\";\\n\\n/**\\n * @title  PxEth\\n * @notice The PxEth token, the main token for the PirexEth system used in the Dinero ecosystem.\\n * @dev    Extends the DineroERC20 contract and includes additional functionality.\\n * @author redactedcartel.finance\\n */\\ncontract PxEth is DineroERC20 {\\n    // Roles\\n    /**\\n     * @notice The OPERATOR_ROLE role assigned for operator functions in the PxEth token contract.\\n     * @dev    Used to control access to critical functions.\\n     */\\n    bytes32 private constant OPERATOR_ROLE = keccak256(\\\"OPERATOR_ROLE\\\");\\n\\n    /**\\n     * @notice Constructor to initialize the PxEth token.\\n     * @dev    Inherits from the DineroERC20 contract and sets the name, symbol, decimals, admin, and initial delay.\\n     * @param  _admin         address  Admin address.\\n     * @param  _initialDelay  uint48   Delay required to schedule the acceptance of an access control transfer started.\\n     */\\n    constructor(\\n        address _admin,\\n        uint48 _initialDelay\\n    ) DineroERC20(\\\"Pirex Ether\\\", \\\"pxETH\\\", 18, _admin, _initialDelay) {}\\n\\n    /**\\n     * @notice Operator function to approve allowances for specified accounts and amounts.\\n     * @dev    Only callable by the operator role.\\n     * @param  _from    address  Owner of the tokens.\\n     * @param  _to      address  Account to be approved.\\n     * @param  _amount  uint256  Amount to be approved.\\n     */\\n    function operatorApprove(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external onlyRole(OPERATOR_ROLE) {\\n        if (_from == address(0)) revert Errors.ZeroAddress();\\n        if (_to == address(0)) revert Errors.ZeroAddress();\\n\\n        allowance[_from][_to] = _amount;\\n\\n        emit Approval(_from, _to, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControlDefaultAdminRules.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/IAccessControlDefaultAdminRules.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlDefaultAdminRules declared to support ERC165 detection.\\n *\\n * _Available since v4.9._\\n */\\ninterface IAccessControlDefaultAdminRules is IAccessControl {\\n    /**\\n     * @dev Emitted when a {defaultAdmin} transfer is started, setting `newAdmin` as the next\\n     * address to become the {defaultAdmin} by calling {acceptDefaultAdminTransfer} only after `acceptSchedule`\\n     * passes.\\n     */\\n    event DefaultAdminTransferScheduled(address indexed newAdmin, uint48 acceptSchedule);\\n\\n    /**\\n     * @dev Emitted when a {pendingDefaultAdmin} is reset if it was never accepted, regardless of its schedule.\\n     */\\n    event DefaultAdminTransferCanceled();\\n\\n    /**\\n     * @dev Emitted when a {defaultAdminDelay} change is started, setting `newDelay` as the next\\n     * delay to be applied between default admin transfer after `effectSchedule` has passed.\\n     */\\n    event DefaultAdminDelayChangeScheduled(uint48 newDelay, uint48 effectSchedule);\\n\\n    /**\\n     * @dev Emitted when a {pendingDefaultAdminDelay} is reset if its schedule didn't pass.\\n     */\\n    event DefaultAdminDelayChangeCanceled();\\n\\n    /**\\n     * @dev Returns the address of the current `DEFAULT_ADMIN_ROLE` holder.\\n     */\\n    function defaultAdmin() external view returns (address);\\n\\n    /**\\n     * @dev Returns a tuple of a `newAdmin` and an accept schedule.\\n     *\\n     * After the `schedule` passes, the `newAdmin` will be able to accept the {defaultAdmin} role\\n     * by calling {acceptDefaultAdminTransfer}, completing the role transfer.\\n     *\\n     * A zero value only in `acceptSchedule` indicates no pending admin transfer.\\n     *\\n     * NOTE: A zero address `newAdmin` means that {defaultAdmin} is being renounced.\\n     */\\n    function pendingDefaultAdmin() external view returns (address newAdmin, uint48 acceptSchedule);\\n\\n    /**\\n     * @dev Returns the delay required to schedule the acceptance of a {defaultAdmin} transfer started.\\n     *\\n     * This delay will be added to the current timestamp when calling {beginDefaultAdminTransfer} to set\\n     * the acceptance schedule.\\n     *\\n     * NOTE: If a delay change has been scheduled, it will take effect as soon as the schedule passes, making this\\n     * function returns the new delay. See {changeDefaultAdminDelay}.\\n     */\\n    function defaultAdminDelay() external view returns (uint48);\\n\\n    /**\\n     * @dev Returns a tuple of `newDelay` and an effect schedule.\\n     *\\n     * After the `schedule` passes, the `newDelay` will get into effect immediately for every\\n     * new {defaultAdmin} transfer started with {beginDefaultAdminTransfer}.\\n     *\\n     * A zero value only in `effectSchedule` indicates no pending delay change.\\n     *\\n     * NOTE: A zero value only for `newDelay` means that the next {defaultAdminDelay}\\n     * will be zero after the effect schedule.\\n     */\\n    function pendingDefaultAdminDelay() external view returns (uint48 newDelay, uint48 effectSchedule);\\n\\n    /**\\n     * @dev Starts a {defaultAdmin} transfer by setting a {pendingDefaultAdmin} scheduled for acceptance\\n     * after the current timestamp plus a {defaultAdminDelay}.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the current {defaultAdmin}.\\n     *\\n     * Emits a DefaultAdminRoleChangeStarted event.\\n     */\\n    function beginDefaultAdminTransfer(address newAdmin) external;\\n\\n    /**\\n     * @dev Cancels a {defaultAdmin} transfer previously started with {beginDefaultAdminTransfer}.\\n     *\\n     * A {pendingDefaultAdmin} not yet accepted can also be cancelled with this function.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the current {defaultAdmin}.\\n     *\\n     * May emit a DefaultAdminTransferCanceled event.\\n     */\\n    function cancelDefaultAdminTransfer() external;\\n\\n    /**\\n     * @dev Completes a {defaultAdmin} transfer previously started with {beginDefaultAdminTransfer}.\\n     *\\n     * After calling the function:\\n     *\\n     * - `DEFAULT_ADMIN_ROLE` should be granted to the caller.\\n     * - `DEFAULT_ADMIN_ROLE` should be revoked from the previous holder.\\n     * - {pendingDefaultAdmin} should be reset to zero values.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the {pendingDefaultAdmin}'s `newAdmin`.\\n     * - The {pendingDefaultAdmin}'s `acceptSchedule` should've passed.\\n     */\\n    function acceptDefaultAdminTransfer() external;\\n\\n    /**\\n     * @dev Initiates a {defaultAdminDelay} update by setting a {pendingDefaultAdminDelay} scheduled for getting\\n     * into effect after the current timestamp plus a {defaultAdminDelay}.\\n     *\\n     * This function guarantees that any call to {beginDefaultAdminTransfer} done between the timestamp this\\n     * method is called and the {pendingDefaultAdminDelay} effect schedule will use the current {defaultAdminDelay}\\n     * set before calling.\\n     *\\n     * The {pendingDefaultAdminDelay}'s effect schedule is defined in a way that waiting until the schedule and then\\n     * calling {beginDefaultAdminTransfer} with the new delay will take at least the same as another {defaultAdmin}\\n     * complete transfer (including acceptance).\\n     *\\n     * The schedule is designed for two scenarios:\\n     *\\n     * - When the delay is changed for a larger one the schedule is `block.timestamp + newDelay` capped by\\n     * {defaultAdminDelayIncreaseWait}.\\n     * - When the delay is changed for a shorter one, the schedule is `block.timestamp + (current delay - new delay)`.\\n     *\\n     * A {pendingDefaultAdminDelay} that never got into effect will be canceled in favor of a new scheduled change.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the current {defaultAdmin}.\\n     *\\n     * Emits a DefaultAdminDelayChangeScheduled event and may emit a DefaultAdminDelayChangeCanceled event.\\n     */\\n    function changeDefaultAdminDelay(uint48 newDelay) external;\\n\\n    /**\\n     * @dev Cancels a scheduled {defaultAdminDelay} change.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the current {defaultAdmin}.\\n     *\\n     * May emit a DefaultAdminDelayChangeCanceled event.\\n     */\\n    function rollbackDefaultAdminDelay() external;\\n\\n    /**\\n     * @dev Maximum time in seconds for an increase to {defaultAdminDelay} (that is scheduled using {changeDefaultAdminDelay})\\n     * to take effect. Default to 5 days.\\n     *\\n     * When the {defaultAdminDelay} is scheduled to be increased, it goes into effect after the new delay has passed with\\n     * the purpose of giving enough time for reverting any accidental change (i.e. using milliseconds instead of seconds)\\n     * that may lock the contract. However, to avoid excessive schedules, the wait is capped by this function and it can\\n     * be overrode for a custom {defaultAdminDelay} increase scheduling.\\n     *\\n     * IMPORTANT: Make sure to add a reasonable amount of time while overriding this value, otherwise,\\n     * there's a risk of setting a high new delay that goes into effect almost immediately without the\\n     * possibility of human intervention in the case of an input error (eg. set milliseconds instead of seconds).\\n     */\\n    function defaultAdminDelayIncreaseWait() external view returns (uint48);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC5313.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5313.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface for the Light Contract Ownership Standard.\\n *\\n * A standardized minimal interface required to identify an account that controls a contract\\n *\\n * _Available since v4.9._\\n */\\ninterface IERC5313 {\\n    /**\\n     * @dev Gets the address of the owner.\\n     */\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i = 0; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/mixins/ERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, _asset.decimals()) {\\n        asset = _asset;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/DineroERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {AccessControlDefaultAdminRules} from \\\"openzeppelin-contracts/contracts/access/AccessControlDefaultAdminRules.sol\\\";\\nimport {Errors} from \\\"./libraries/Errors.sol\\\";\\n\\n/**\\n * @title DineroERC20\\n * @dev A Standard ERC20 token with minting and burning with access control.\\n * @author redactedcartel.finance\\n */\\ncontract DineroERC20 is ERC20, AccessControlDefaultAdminRules {\\n    // Roles\\n    /**\\n     * @dev Bytes32 constant representing the role to mint new tokens.\\n     */\\n    bytes32 private constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n    /**\\n     * @dev Bytes32 constant representing the role to burn (destroy) tokens.\\n     */\\n    bytes32 private constant BURNER_ROLE = keccak256(\\\"BURNER_ROLE\\\");\\n\\n    /**\\n     * @notice Constructor to initialize ERC20 token with access control.\\n     * @param _name          string   Token name.\\n     * @param _symbol        string   Token symbol.\\n     * @param _decimals      uint8    Token decimals.\\n     * @param _admin         address  Admin address.\\n     * @param _initialDelay  uint48   Delay required to schedule the acceptance\\n     *                                of an access control transfer started.\\n     */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        address _admin,\\n        uint48 _initialDelay\\n    )\\n        AccessControlDefaultAdminRules(_initialDelay, _admin)\\n        ERC20(_name, _symbol, _decimals)\\n    {\\n        if (bytes(_name).length == 0) revert Errors.EmptyString();\\n        if (bytes(_symbol).length == 0) revert Errors.EmptyString();\\n        if (_decimals == 0) revert Errors.ZeroAmount();\\n    }\\n\\n    /**\\n     * @notice Mints tokens to an address.\\n     * @dev Only callable by minters.\\n     * @param _to      address  Address to mint tokens to.\\n     * @param _amount  uint256  Amount of tokens to mint.\\n     */\\n    function mint(address _to, uint256 _amount) external onlyRole(MINTER_ROLE) {\\n        if (_to == address(0)) revert Errors.ZeroAddress();\\n        if (_amount == 0) revert Errors.ZeroAmount();\\n\\n        _mint(_to, _amount);\\n    }\\n\\n    /**\\n     * @notice Burns tokens from an address.\\n     * @dev Only callable by burners.\\n     * @param _from    address  Address to burn tokens from.\\n     * @param _amount  uint256  Amount of tokens to burn.\\n     */\\n    function burn(\\n        address _from,\\n        uint256 _amount\\n    ) external onlyRole(BURNER_ROLE) {\\n        if (_from == address(0)) revert Errors.ZeroAddress();\\n        if (_amount == 0) revert Errors.ZeroAmount();\\n\\n        _burn(_from, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {\r\n      \"src/libraries/ValidatorQueue.sol\": {\r\n        \"ValidatorQueue\": \"0x9e0d7d79735e1c63333128149c7b616a0dc0bbdb\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pxEth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_beaconChainDepositContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_upxEth\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_depositSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_preDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_pirexFees\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"_initialDelay\",\"type\":\"uint48\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccountNotApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositingEtherNotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositingEtherPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyArray\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMaxFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMaxProcessedCount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MismatchedArrayLengths\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoETHAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoPartialInitiateRedemption\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoUsedValidator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoValidatorExit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughBuffer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughValidators\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotRewardRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotWithdrawable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StatusNotDissolvedOrSlashed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StatusNotWithdrawableOrStaking\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnrecorgnisedContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValidatorNotStaking\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroMultiplier\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ApproveBurnerAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DefaultAdminDelayChangeCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"newDelay\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"effectSchedule\",\"type\":\"uint48\"}],\"name\":\"DefaultAdminDelayChangeScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DefaultAdminTransferCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"acceptSchedule\",\"type\":\"uint48\"}],\"name\":\"DefaultAdminTransferScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"shouldCompound\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposited\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStatus\",\"type\":\"uint256\"}],\"name\":\"DepositEtherPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubKey\",\"type\":\"bytes\"}],\"name\":\"DissolveValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"postFeeAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"InitiateRedemption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"postFeeAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"RedeemWithPxEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"RedeemWithUpxEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RevokeBurnerAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum DataTypes.Contract\",\"name\":\"c\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"SetContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum DataTypes.Fees\",\"name\":\"f\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"fee\",\"type\":\"uint32\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"}],\"name\":\"SetMaxBufferSizePct\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum DataTypes.Fees\",\"name\":\"f\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"maxFee\",\"type\":\"uint32\"}],\"name\":\"SetMaxFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"SetMaxProcessedValidatorCount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"}],\"name\":\"SetPauseState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"withdrawalCredentials\",\"type\":\"bytes\"}],\"name\":\"SetWithdrawCredentials\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubKey\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"useBuffer\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"releasedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"}],\"name\":\"SlashValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubKey\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"useBuffer\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"topUpAmount\",\"type\":\"uint256\"}],\"name\":\"TopUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBufferSize\",\"type\":\"uint256\"}],\"name\":\"UpdateMaxBufferSize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubKey\",\"type\":\"bytes\"}],\"name\":\"ValidatorDeposit\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptDefaultAdminTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"pubKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"depositDataRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"internalType\":\"struct DataTypes.Validator[]\",\"name\":\"_validators\",\"type\":\"tuple[]\"}],\"name\":\"addInitializedValidators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoPxEth\",\"outputs\":[{\"internalType\":\"contract AutoPxEth\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"batchIdToValidator\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beaconChainDepositContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"beginDefaultAdminTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"bulkRedeemWithUpxEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"burnerAccounts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelDefaultAdminTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"newDelay\",\"type\":\"uint48\"}],\"name\":\"changeDefaultAdminDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearInitializedValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultAdminDelay\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultAdminDelayIncreaseWait\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"shouldCompound\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"postFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositEtherPaused\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositPrivileged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_pubKey\",\"type\":\"bytes\"}],\"name\":\"dissolveValidator\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DataTypes.Fees\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_i\",\"type\":\"uint256\"}],\"name\":\"getInitializedValidatorAt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInitializedValidatorCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_i\",\"type\":\"uint256\"}],\"name\":\"getStakingValidatorAt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingValidatorCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_shouldTriggerValidatorExit\",\"type\":\"bool\"}],\"name\":\"initiateRedemption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"postFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"instantRedeemWithPxEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"postFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBufferSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBufferSizePct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DataTypes.Fees\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"maxFees\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxProcessedValidatorCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleAdapter\",\"outputs\":[{\"internalType\":\"contract IOracleAdapter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outstandingRedemptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingDefaultAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"schedule\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingDefaultAdminDelay\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"newDelay\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"schedule\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pirexFees\",\"outputs\":[{\"internalType\":\"contract IPirexFees\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_times\",\"type\":\"uint256\"}],\"name\":\"popInitializedValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pxEth\",\"outputs\":[{\"internalType\":\"contract PxEth\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"redeemWithUpxEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_pubKey\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_removeIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_unordered\",\"type\":\"bool\"}],\"name\":\"removeInitializedValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollbackDefaultAdminDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DataTypes.Contract\",\"name\":\"_contract\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DataTypes.Fees\",\"name\":\"f\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"fee\",\"type\":\"uint32\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pct\",\"type\":\"uint256\"}],\"name\":\"setMaxBufferSizePct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DataTypes.Fees\",\"name\":\"f\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"maxFee\",\"type\":\"uint32\"}],\"name\":\"setMaxFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"setMaxProcessedValidatorCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_pubKey\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_removeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_unordered\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_useBuffer\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.BurnerAccount[]\",\"name\":\"_burnerAccounts\",\"type\":\"tuple[]\"}],\"name\":\"slashValidator\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"status\",\"outputs\":[{\"internalType\":\"enum DataTypes.ValidatorStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toIndex\",\"type\":\"uint256\"}],\"name\":\"swapInitializedValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"toggleBurnerAccounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePauseDepositEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePauseState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_pubKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_depositDataRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_topUpAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_useBuffer\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.BurnerAccount[]\",\"name\":\"_burnerAccounts\",\"type\":\"tuple[]\"}],\"name\":\"topUpStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upxEth\",\"outputs\":[{\"internalType\":\"contract UpxEth\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalCredentials\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PirexEth", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000004c154b66cb340f3ae24111cc767e0184ed00cc6000000000000000000000000e8ea8990643a0431e4b28f7f7f6878aab88fe42400000000000000000000000000000000219ab540356cbb839cbe05303d7705fa0000000000000000000000005bf2419a33f82f4c1f075b4006d7fc4104c43868000000000000000000000000000000000000000000000001bc16d674ec8000000000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000177d685384aa1ac5aba41b7e649f9fa0be717fdb0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}