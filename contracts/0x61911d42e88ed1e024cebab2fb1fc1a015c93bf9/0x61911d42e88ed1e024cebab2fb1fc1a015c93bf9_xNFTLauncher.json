{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"xNFTLauncher.sol\": {\r\n      \"content\": \"//\\n// xNFT Launcher\\n// Easily create xNFT hybrid tokens, instantly available for trading and minting.\\n// Created by the CellMates team.\\n//\\n// https://launch.cellmates.io\\n// https://discord.gg/cellmates\\n// https://twitter.com/CellMatesERC\\n//\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./xNFTToken.sol\\\";\\n\\ncontract xNFTLauncher {\\n\\n\\tstruct Info {\\n\\t\\txNFTToken[] launchedTokens;\\n\\t\\tmapping(address => uint256) nonce;\\n\\t\\taddress template;\\n\\t}\\n\\tInfo private info;\\n\\n\\tevent NewToken(address indexed creator, address indexed token, string[4] _strings, uint256[4] _numbers, uint256 value, uint256 launchTime);\\n\\n\\tconstructor() {\\n\\t\\txNFTToken _template = new xNFTToken();\\n\\t\\t_template.skipInitialization();\\n\\t\\tinfo.template = address(_template);\\n\\t}\\n\\n\\tfunction salt() public returns (bytes32) {\\n\\t\\treturn keccak256(abi.encodePacked(msg.sender, info.nonce[msg.sender]++));\\n\\t}\\n\\n\\tfunction launch(string[4] memory _strings, uint256[4] memory _numbers) external payable returns (address) {\\n\\t\\txNFTToken _token;\\n\\t\\t{\\n\\t\\t\\tbytes32 _salt = salt();\\n\\t\\t\\taddress payable _proxy;\\n\\t\\t\\tbytes20 _template = bytes20(info.template);\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet _clone := mload(0x40)\\n\\t\\t\\t\\tmstore(_clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n\\t\\t\\t\\tmstore(add(_clone, 0x14), _template)\\n\\t\\t\\t\\tmstore(add(_clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n\\t\\t\\t\\t_proxy := create2(0, _clone, 0x37, _salt)\\n\\t\\t\\t}\\n\\t\\t\\t_token = xNFTToken(_proxy);\\n\\t\\t}\\n\\t\\t_token.initialize{value:msg.value}(_strings, _numbers);\\n\\t\\tinfo.launchedTokens.push(_token);\\n\\t\\temit NewToken(msg.sender, address(_token), _strings, _numbers, msg.value, block.timestamp);\\n\\t\\treturn address(_token);\\n\\t}\\n\\n\\n\\tfunction template() external view returns (address) {\\n\\t\\treturn info.template;\\n\\t}\\n\\t\\n\\tfunction totalLaunchedTokens() external view returns (uint256) {\\n\\t\\treturn info.launchedTokens.length;\\n\\t}\\n\\n\\tfunction allLaunchedTokens() external view returns (xNFTToken[] memory) {\\n\\t\\treturn info.launchedTokens;\\n\\t}\\n\\n\\tfunction launchedTokenAtIndex(uint256 _index) external view returns (xNFTToken) {\\n\\t\\treturn info.launchedTokens[_index];\\n\\t}\\n}\"\r\n    },\r\n    \"xNFTToken.sol\": {\r\n      \"content\": \"//\\n// Deployed From xNFT Launcher\\n// Easily create xNFT hybrid tokens, instantly available for trading and minting.\\n// Created by the CellMates team.\\n//\\n// https://launch.cellmates.io\\n// https://discord.gg/cellmates\\n// https://twitter.com/CellMatesERC\\n//\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./xNFTProxy.sol\\\";\\n\\ninterface Router {\\n\\tfunction WETH() external pure returns (address);\\n\\tfunction factory() external pure returns (address);\\n\\tfunction addLiquidityETH(address, uint256, uint256, uint256, address, uint256) external payable returns (uint256, uint256, uint256);\\n}\\n\\ninterface Factory {\\n\\tfunction createPair(address, address) external returns (address);\\n}\\n\\ninterface ERC20 {\\n\\tfunction balanceOf(address) external view returns (uint256);\\n\\tfunction transfer(address, uint256) external returns (bool);\\n}\\n\\ninterface Pair is ERC20 {\\n\\tfunction sync() external;\\n}\\n\\ninterface IWETH is ERC20 {\\n\\tfunction deposit() external payable;\\n}\\n\\n\\ncontract xNFTToken is xNFTProxy {\\n\\n\\tuint256 constant public LAUNCH_COST = 0.1 ether;\\n\\tRouter constant private ROUTER = Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n\\taddress payable private TEAM = payable(0xeeFE1c0bC74F0114722641656e6072002Eaac8cd);\\n\\tPair constant private CELL_PAIR = Pair(0xE849B038220DaE1E1a1496Cf53e8fF79B28B7e3a);\\n\\n\\tstring public override name;\\n\\tstring public override symbol;\\n\\tstring public baseTokenURI;\\n\\tstring public tokenURISuffix;\\n\\tuint256 public initialLiquidityETH;\\n\\tuint256 public initialLiquidityTokens;\\n\\tuint256 public devTokens;\\n\\tuint256 public mintableTokens;\\n\\tuint256 public mintPrice;\\n\\tuint256 public lpUnlockTimestamp;\\n\\tPair public pair;\\n\\n\\tbool internal initialized = false;\\n\\n\\t\\n\\tfunction skipInitialization() external {\\n\\t\\trequire(!initialized);\\n\\t\\tinitialized = true;\\n\\t}\\n\\t\\n\\tfunction initialize(string[4] memory _strings, uint256[4] memory _numbers) external payable _withoutEventEmits {\\n\\t\\trequire(msg.value > LAUNCH_COST);\\n\\t\\trequire(!initialized);\\n\\t\\tinitialized = true;\\n\\t\\t_initialize(address(this), _numbers[0]);\\n\\t\\tinfo.owner = tx.origin;\\n\\t\\tname = _strings[0];\\n\\t\\tsymbol = _strings[1];\\n\\t\\tbaseTokenURI = _strings[2];\\n\\t\\ttokenURISuffix = _strings[3];\\n\\t\\tinitialLiquidityETH = msg.value - LAUNCH_COST;\\n\\t\\tinitialLiquidityTokens = _numbers[1];\\n\\t\\tdevTokens = _numbers[2];\\n\\t\\tmintableTokens = _numbers[0] - _numbers[1] - _numbers[2];\\n\\t\\tmintPrice = _numbers[3];\\n\\t\\tlpUnlockTimestamp = block.timestamp + 30 days;\\n\\t\\tIWETH _weth = IWETH(ROUTER.WETH());\\n    _weth.deposit{value:LAUNCH_COST}();\\n\\t\\t_weth.transfer(address(CELL_PAIR), LAUNCH_COST);\\n\\t\\tCELL_PAIR.sync();\\n\\t\\taddress _this = address(this);\\n\\t\\t_approveERC20(_this, address(ROUTER), initialLiquidityTokens);\\n\\t\\tpair = Pair(Factory(ROUTER.factory()).createPair(ROUTER.WETH(), _this));\\n\\t\\tROUTER.addLiquidityETH{value:_this.balance}(_this, initialLiquidityTokens, 0, 0, _this, block.timestamp);\\n\\t\\tif (devTokens > 0) {\\n\\t\\t\\t_transferERC20(_this, owner(), devTokens);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction setName(string memory _name) external _onlyOwner {\\n\\t\\tname = _name;\\n\\t}\\n\\n\\tfunction setSymbol(string memory _symbol) external _onlyOwner {\\n\\t\\tsymbol = _symbol;\\n\\t}\\n\\t\\n\\tfunction setBaseTokenURI(string memory _baseTokenURI) external _onlyOwner {\\n\\t\\tbaseTokenURI = _baseTokenURI;\\n\\t}\\n\\n\\tfunction setTokenURISuffix(string memory _tokenURISuffix) external _onlyOwner {\\n\\t\\ttokenURISuffix = _tokenURISuffix;\\n\\t}\\n\\n\\tfunction unlockLP() external _onlyOwner {\\n\\t\\trequire(block.timestamp > lpUnlockTimestamp);\\n\\t\\tpair.transfer(owner(), pair.balanceOf(address(this)));\\n\\t}\\n\\n\\n\\treceive() external payable {\\n\\t\\tmint(msg.value / mintPrice);\\n\\t}\\n\\n\\tfunction mint(uint256 _tokens) public payable {\\n\\t\\taddress _this = address(this);\\n\\t\\tuint256 _available = balanceOf(_this);\\n\\t\\trequire(_tokens <= _available);\\n\\t\\tuint256 _cost = _tokens * mintPrice;\\n\\t\\trequire(msg.value >= _cost);\\n\\t\\t_transferERC20(_this, msg.sender, _tokens);\\n\\t\\tuint256 _teamFee = _cost / 10;\\n\\t\\tTEAM.transfer(_teamFee);\\n\\t\\tuint256 _cellFee = _cost / 20;\\n\\t\\tIWETH _weth = IWETH(ROUTER.WETH());\\n    _weth.deposit{value:_cellFee}();\\n\\t\\t_weth.transfer(address(CELL_PAIR), _cellFee);\\n\\t\\tCELL_PAIR.sync();\\n\\t\\tpayable(owner()).transfer(_cost - _teamFee - _cellFee);\\n\\t\\tif (msg.value > _cost) {\\n\\t\\t\\tpayable(msg.sender).transfer(msg.value - _cost);\\n\\t\\t}\\n\\t}\\n\\n\\n\\tfunction tokenURI(uint256 _tokenId) public override view returns (string memory) {\\n\\t\\treturn string(abi.encodePacked(baseTokenURI, _uint2str(_tokenId), tokenURISuffix));\\n\\t}\\n\\n\\tfunction remainingMintableTokens() external view returns (uint256) {\\n\\t\\treturn balanceOf(address(this));\\n\\t}\\n\\n\\n\\tfunction _uint2str(uint256 _value) internal pure returns (string memory) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 _digits = 1;\\n\\t\\t\\tuint256 _n = _value;\\n\\t\\t\\twhile (_n > 9) {\\n\\t\\t\\t\\t_n /= 10;\\n\\t\\t\\t\\t_digits++;\\n\\t\\t\\t}\\n\\t\\t\\tbytes memory _out = new bytes(_digits);\\n\\t\\t\\tfor (uint256 i = 0; i < _out.length; i++) {\\n\\t\\t\\t\\tuint256 _dec = (_value / (10**(_out.length - i - 1))) % 10;\\n\\t\\t\\t\\t_out[i] = bytes1(uint8(_dec) + 48);\\n\\t\\t\\t}\\n\\t\\t\\treturn string(_out);\\n\\t\\t}\\n\\t}\\n}\"\r\n    },\r\n    \"xNFTProxy.sol\": {\r\n      \"content\": \"//\\n// \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n//  \u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588         \u2588\u2588    \\n//   \u2588\u2588\u2588   \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588      \u2588\u2588    \\n//  \u2588\u2588 \u2588\u2588  \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588         \u2588\u2588    \\n// \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588         \u2588\u2588    \\n//\\n// xNFT - Exchangeable Non-Fungible Tokens\\n// An experimental hybrid of ERC-20 & ERC-721.\\n//\\n// - Easily inheritable\\n// - Extremely gas efficient\\n// - Logically coherent single contract hybrid\\n//\\n//\\n// !!! Important Caveats !!!\\n// - `ownerOf()` is unbounded in gas usage due to loops, as such, all contract\\n//   calls are blocked to it to prevent high transaction fees.\\n//   !! This will break external contracts that use `ownerOf()` !!\\n//   For new implementations, use the `isOwnerOf()` method to check ownership.\\n//   Queries outside of the blockchain should not be effected.\\n// - `transferFrom()` can behave unexpectedly due to how the function needs to\\n//   be overloaded to work for both ERC-20 & ERC-721 applications.\\n//   !! Any contract that does not wrap `transferFrom()` with a before/after\\n//   balance check has the potential to be exploited !!\\n//\\n// WARNING - Hybrid NFT standards are universally new, and inherently DANGEROUS,\\n// no systems have been built with these use cases in mind, and there are a number of \\n// ways that experimental, complex contracts can lead to unforeseen consequences.\\n// INTERACT WITH EXPERIMENTAL SMART CONTRACTS AT YOUR OWN RISK\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface Receiver {\\n\\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\\n}\\n\\nabstract contract xNFTProxy {\\n\\n\\tuint256 constant internal MASK_SIZE = 256;\\n\\tuint256 constant internal MAX_ALLOWED_SUPPLY = 57344;\\n\\tuint256 constant internal UINT_MAX = type(uint256).max;\\n\\tuint256 constant internal M1 = 0x5555555555555555555555555555555555555555555555555555555555555555;\\n\\tuint256 constant internal M2 = 0x3333333333333333333333333333333333333333333333333333333333333333;\\n\\tuint256 constant internal M4 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\\n\\tuint256 constant internal H01 = 0x0101010101010101010101010101010101010101010101010101010101010101;\\n\\tbytes32 constant internal TRANSFER_TOPIC = keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"));\\n\\tbytes32 constant internal APPROVAL_TOPIC = keccak256(bytes(\\\"Approval(address,address,uint256)\\\"));\\n\\n\\tuint8 constant public decimals = 0;\\n\\tuint256 public totalSupply;\\n\\tuint256 internal maskDepth;\\n\\tbool internal skipEventEmits = false;\\n\\n\\tstruct User {\\n\\t\\tuint16 balance;\\n\\t\\tuint16 approvedCount;\\n\\t\\tbytes28 activeMasks;\\n\\t\\tmapping(uint256 => bytes32) masks;\\n\\t\\tmapping(address => uint256) allowance;\\n\\t\\tmapping(address => bool) approved;\\n\\t}\\n\\n\\tstruct Info {\\n\\t\\taddress owner;\\n\\t\\tmapping(address => User) users;\\n\\t\\tmapping(uint256 => address) approved;\\n\\t\\taddress[] holders;\\n\\t\\tmapping(address => uint256) indexOf;\\n\\t}\\n\\tInfo internal info;\\n\\n\\tmapping(bytes4 => bool) public supportsInterface;\\n\\n\\n\\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\tevent ERC20Transfer(bytes32 indexed topic0, address indexed from, address indexed to, uint256 tokens) anonymous;\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\\n\\tevent ERC20Approval(bytes32 indexed topic0, address indexed owner, address indexed spender, uint256 tokens) anonymous;\\n\\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n\\n\\tmodifier _onlyOwner() {\\n\\t\\trequire(msg.sender == owner());\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier _withoutEventEmits() {\\n\\t\\tskipEventEmits = true;\\n\\t\\t_;\\n\\t\\tskipEventEmits = false;\\n\\t}\\n\\n\\n\\tfunction setOwner(address _owner) external _onlyOwner {\\n\\t\\tinfo.owner = _owner;\\n\\t}\\n\\n\\tfunction approve(address _spender, uint256 _tokens) external returns (bool) {\\n\\t\\tunchecked {\\n\\t\\t\\tif (_tokens > totalSupply && _tokens <= 2 * totalSupply) {\\n\\t\\t\\t\\t_approveNFT(_spender, _tokens);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_approveERC20(msg.sender, _spender, _tokens);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\t\\n\\t\\t}\\n\\t}\\n\\n\\tfunction setApprovalForAll(address _operator, bool _approved) external {\\n\\t\\tinfo.users[msg.sender].approved[_operator] = _approved;\\n\\t\\temit ApprovalForAll(msg.sender, _operator, _approved);\\n\\t}\\n\\n\\tfunction transfer(address _to, uint256 _tokens) external returns (bool) {\\n\\t\\t_transferERC20(msg.sender, _to, _tokens);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction transferFrom(address _from, address _to, uint256 _tokens) external returns (bool) {\\n\\t\\tunchecked {\\n\\t\\t\\tif (_tokens > totalSupply && _tokens <= 2 * totalSupply) {\\n\\t\\t\\t\\t_transferNFT(_from, _to, _tokens);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tuint256 _allowance = allowance(_from, msg.sender);\\n\\t\\t\\t\\trequire(_allowance >= _tokens);\\n\\t\\t\\t\\tif (_allowance != UINT_MAX) {\\n\\t\\t\\t\\t\\tinfo.users[_from].allowance[msg.sender] -= _tokens;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_transferERC20(_from, _to, _tokens);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\\n\\t\\tsafeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\n\\t}\\n\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public {\\n\\t\\t_transferNFT(_from, _to, _tokenId);\\n\\t\\tuint32 _size;\\n\\t\\tassembly {\\n\\t\\t\\t_size := extcodesize(_to)\\n\\t\\t}\\n\\t\\tif (_size > 0) {\\n\\t\\t\\trequire(Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) == Receiver.onERC721Received.selector);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction bulkTransfer(address _to, uint256[] memory _tokenIds) external {\\n\\t\\t_transferNFTs(_to, _tokenIds);\\n\\t}\\n\\t\\n\\n\\tfunction owner() public view returns (address) {\\n\\t\\treturn info.owner;\\n\\t}\\n\\n\\tfunction holders() external view returns (address[] memory) {\\n\\t\\treturn info.holders;\\n\\t}\\n\\n\\tfunction name() external virtual view returns (string memory);\\n\\n\\tfunction symbol() external virtual view returns (string memory);\\n\\n\\tfunction tokenURI(uint256 _tokenId) public virtual view returns (string memory);\\n\\n\\tfunction maskAtIndexOf(uint256 _index, address _user) public view returns (bytes32) {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(_index < maskDepth);\\n\\t\\t\\treturn info.users[_user].masks[_index];\\n\\t\\t}\\n\\t}\\n\\n\\tfunction masksOf(address _user) external view returns (bytes32[] memory masks) {\\n\\t\\tunchecked {\\n\\t\\t\\tmasks = new bytes32[](maskDepth);\\n\\t\\t\\tfor (uint256 i = 0; i < masks.length; i++) {\\n\\t\\t\\t\\tmasks[i] = maskAtIndexOf(i, _user);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction balanceOf(address _user) public view returns (uint256 balance) {\\n\\t\\treturn info.users[_user].balance;\\n\\t}\\n\\n\\tfunction allowance(address _user, address _spender) public view returns (uint256) {\\n\\t\\treturn info.users[_user].allowance[_spender];\\n\\t}\\n\\n\\t// !!! Important !!!\\n\\t// To save gas on bulk ERC-20 & ERC-721 transfers, this method has been written in a way\\n\\t// that doesn't individually update a storage slot for each token owner but instead loops\\n\\t// through an array of holders in order to find a match.\\n\\t// As such it costs approximately 5k gas per loop (1 block = 30m gas = 6k loops) so having\\n\\t// another contract call this method could result in very large transaction fees. To prevent\\n\\t// this from happening, this method will block and revert if the caller is a contract.\\n\\t// !! This will break external contracts that use `ownerOf()` but queries outside of the\\n\\t// blockchain should not be effected !!\\n\\t//\\n\\t// If you need to externally check if a token is owned by a certain address, use the\\n\\t// new `isOwnerOf(address _user, uint256 _tokenId)` method instead.\\n\\t// Most current NFT based contracts don't use `ownerOf()` and assume that if a call\\n\\t// to `transferFrom()` was successful then `_from` was in fact the owner.\\n\\tfunction ownerOf(uint256 _tokenId) public view returns (address) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint32 _size;\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\t_size := caller()\\n\\t\\t\\t}\\n\\t\\t\\trequire(_size == 0);\\n\\t\\t\\trequire(_tokenId > totalSupply && _tokenId <= 2 * totalSupply);\\n\\t\\t\\t(uint256 _maskIndex, bytes32 _mask) = _tokenIdToMask(_tokenId);\\n\\t\\t\\tuint256 _holdersLength = info.holders.length;\\n\\t\\t\\tfor (uint256 i = 0; i < _holdersLength; i++) {\\n\\t\\t\\t\\taddress _holder = info.holders[i];\\n\\t\\t\\t\\tif (maskAtIndexOf(_maskIndex, _holder) & _mask == _mask) {\\n\\t\\t\\t\\t\\treturn _holder;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn address(0x0);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getApproved(uint256 _tokenId) public view returns (address) {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(_tokenId > totalSupply && _tokenId <= 2 * totalSupply);\\n\\t\\t\\treturn info.approved[_tokenId];\\n\\t\\t}\\n\\t}\\n\\n\\tfunction isApprovedForAll(address _owner, address _operator) public view returns (bool) {\\n\\t\\treturn info.users[_owner].approved[_operator];\\n\\t}\\n\\n\\tfunction isOwnerOf(address _user, uint256 _tokenId) external view returns (bool) {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(_tokenId > totalSupply && _tokenId <= 2 * totalSupply);\\n\\t\\t\\t(uint256 _maskIndex, bytes32 _mask) = _tokenIdToMask(_tokenId);\\n\\t\\t\\treturn maskAtIndexOf(_maskIndex, _user) & _mask == _mask;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction tokenByIndex(uint256 _index) external view returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(_index < totalSupply);\\n\\t\\t\\treturn totalSupply + _index + 1;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId) {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(_index < balanceOf(_owner));\\n\\t\\t\\tuint256 _count = 0;\\n\\t\\t\\tuint256 _activeMasks = uint224(info.users[_owner].activeMasks);\\n\\t\\t\\twhile (_activeMasks > 0 && _count <= _index) {\\n\\t\\t\\t\\tuint256 _activeIndex = _lsb(_activeMasks);\\n\\t\\t\\t\\t_activeMasks ^= 1 << _activeIndex;\\n\\t\\t\\t\\tbytes32 _mask = maskAtIndexOf(_activeIndex, _owner);\\n\\t\\t\\t\\tuint256 _maskCount = _popcount(_mask);\\n\\t\\t\\t\\tif (_count + _maskCount <= _index) {\\n\\t\\t\\t\\t\\t_count += _maskCount;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tuint256 _n = uint256(_mask);\\n\\t\\t\\t\\t\\twhile (_n > 0 && _count <= _index) {\\n\\t\\t\\t\\t\\t\\tuint256 _pos = _lsb(_n);\\n\\t\\t\\t\\t\\t\\t_n ^= 1 << _pos;\\n\\t\\t\\t\\t\\t\\t_count++;\\n\\t\\t\\t\\t\\t\\tif (_count == _index + 1) {\\n\\t\\t\\t\\t\\t\\t\\treturn (MASK_SIZE * _activeIndex) + totalSupply + _pos + 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getToken(uint256 _tokenId, bool _getOwner) public view returns (address tokenOwner, address approved, string memory uri) {\\n\\t\\treturn (_getOwner ? ownerOf(_tokenId) : address(0x0), getApproved(_tokenId), tokenURI(_tokenId));\\n\\t}\\n\\n\\tfunction getTokens(uint256[] memory _tokenIds, bool _getOwner) external view returns (address[] memory owners, address[] memory approveds, string[] memory uris) {\\n\\t\\tuint256 _length = _tokenIds.length;\\n\\t\\towners = new address[](_length);\\n\\t\\tapproveds = new address[](_length);\\n\\t\\turis = new string[](_length);\\n\\t\\tfor (uint256 i = 0; i < _length; i++) {\\n\\t\\t\\t(owners[i], approveds[i], uris[i]) = getToken(_tokenIds[i], _getOwner);\\n\\t\\t}\\n\\t}\\n\\n\\n\\t// Can be overridden by a parent contract if needed. Most of the logic inside this function is\\n\\t// essential for setting up the initial supply so be careful when altering it.\\n\\t// If all you want to do is save gas on deployment by preventing all the NFT `Transfer()` events\\n\\t// from emitting, use this in your parent contract:\\n\\t// `function initialize(...) external _withoutEventEmits { _initialize(_owner, _totalSupply); }`\\n\\tfunction _initialize(address _owner, uint256 _totalSupply) internal virtual {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(totalSupply == 0);\\n\\t\\t\\trequire(_totalSupply > 0 && _totalSupply <= MAX_ALLOWED_SUPPLY);\\n\\t\\t\\tinfo.owner = _owner;\\n\\t\\t\\ttotalSupply = _totalSupply;\\n\\t\\t\\tmaskDepth = ((_totalSupply - 1) / MASK_SIZE) + 1;\\n\\t\\t\\tsupportsInterface[0x01ffc9a7] = true; // ERC-165\\n\\t\\t\\tsupportsInterface[0x80ac58cd] = true; // ERC-721\\n\\t\\t\\tsupportsInterface[0x5b5e139f] = true; // Metadata\\n\\t\\t\\tsupportsInterface[0x780e9d63] = true; // Enumerable\\n\\t\\t\\tfor (uint256 i = 0; i < maskDepth; i++) {\\n\\t\\t\\t\\tif (i == maskDepth - 1 && _totalSupply % MASK_SIZE != 0) {\\n\\t\\t\\t\\t\\tinfo.users[_owner].masks[i] = bytes32(UINT_MAX) >> (MASK_SIZE - (_totalSupply % MASK_SIZE));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tinfo.users[_owner].masks[i] = bytes32(UINT_MAX);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tinfo.users[_owner].balance = uint16(_totalSupply);\\n\\t\\t\\tinfo.users[_owner].activeMasks = bytes28(uint224(2**maskDepth - 1));\\n\\t\\t\\tinfo.holders.push(_owner);\\n\\t\\t\\temit ERC20Transfer(TRANSFER_TOPIC, address(0x0), _owner, _totalSupply);\\n\\t\\t\\tif (!skipEventEmits) {\\n\\t\\t\\t\\tfor (uint256 i = 0; i < _totalSupply; i++) {\\n\\t\\t\\t\\t\\temit Transfer(address(0x0), _owner, _totalSupply + i + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction _approveERC20(address _owner, address _spender, uint256 _tokens) internal {\\n\\t\\tinfo.users[_owner].allowance[_spender] = _tokens;\\n\\t\\temit ERC20Approval(APPROVAL_TOPIC, _owner, _spender, _tokens);\\n\\t}\\n\\n\\tfunction _approveNFT(address _spender, uint256 _tokenId) internal {\\n\\t\\tunchecked {\\n\\t\\t\\t(uint256 _maskIndex, bytes32 _mask) = _tokenIdToMask(_tokenId);\\n\\t\\t\\trequire(maskAtIndexOf(_maskIndex, msg.sender) & _mask == _mask);\\n\\t\\t\\tinfo.approved[_tokenId] = _spender;\\n\\t\\t\\tinfo.users[msg.sender].approvedCount++;\\n\\t\\t\\temit Approval(msg.sender, _spender, _tokenId);\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// Can be overridden by a parent contract to change how token ids are selected when performing\\n\\t// an ERC-20 transfer. It is not recommended to do this unless you're sure you know what\\n\\t// the outcome will be and test it to make sure your implementation works as expected.\\n\\tfunction _transferERC20(address _from, address _to, uint256 _tokens) internal virtual {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 _count = 0;\\n\\t\\t\\tuint256[] memory _tokenIds = new uint256[](_tokens);\\n\\t\\t\\tbytes32[] memory _masks = new bytes32[](maskDepth);\\n\\t\\t\\tuint256 _activeMasks = uint224(info.users[_from].activeMasks);\\n\\t\\t\\twhile (_activeMasks > 0 && _count < _tokens) {\\n\\t\\t\\t\\tuint256 _activeIndex = _lsb(_activeMasks);\\n\\t\\t\\t\\t_activeMasks ^= 1 << _activeIndex;\\n\\t\\t\\t\\tbytes32 _mask = maskAtIndexOf(_activeIndex, _from);\\n\\t\\t\\t\\tuint256 _n = uint256(_mask);\\n\\t\\t\\t\\twhile (_n > 0 && _count < _tokens) {\\n\\t\\t\\t\\t\\tuint256 _pos = _lsb(_n);\\n\\t\\t\\t\\t\\tbytes32 _tokenMask = bytes32(1 << _pos);\\n\\t\\t\\t\\t\\t_masks[_activeIndex] |= _tokenMask;\\n\\t\\t\\t\\t\\t_tokenIds[_count++] = (MASK_SIZE * _activeIndex) + totalSupply + _pos + 1;\\n\\t\\t\\t\\t\\t_n ^= uint256(_tokenMask);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trequire(_mask & _masks[_activeIndex] == _masks[_activeIndex]);\\n\\t\\t\\t}\\n\\t\\t\\trequire(_count == _tokens);\\n\\t\\t\\t_transfer(_from, _to, _masks, _tokenIds);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction _transferNFT(address _from, address _to, uint256 _tokenId) internal {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(_tokenId > totalSupply && _tokenId <= 2 * totalSupply);\\n\\t\\t\\t(uint256 _maskIndex, bytes32 _mask) = _tokenIdToMask(_tokenId);\\n\\t\\t\\trequire(maskAtIndexOf(_maskIndex, _from) & _mask == _mask);\\n\\t\\t\\trequire(msg.sender == _from || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender));\\n\\t\\t\\tbytes32[] memory _masks = new bytes32[](maskDepth);\\n\\t\\t\\t_masks[_maskIndex] = _mask;\\n\\t\\t\\tuint256[] memory _tokenIds = new uint256[](1);\\n\\t\\t\\t_tokenIds[0] = _tokenId;\\n\\t\\t\\t_transfer(_from, _to, _masks, _tokenIds);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction _transferNFTs(address _to, uint256[] memory _tokenIds) internal {\\n\\t\\tunchecked {\\n\\t\\t\\tbytes32[] memory _masks = new bytes32[](maskDepth);\\n\\t\\t\\tfor (uint256 i = 0; i < _tokenIds.length; i++) {\\n\\t\\t\\t\\t(uint256 _maskIndex, bytes32 _mask) = _tokenIdToMask(_tokenIds[i]);\\n\\t\\t\\t\\t_masks[_maskIndex] |= _mask;\\n\\t\\t\\t}\\n\\t\\t\\tuint256 _count = 0;\\n\\t\\t\\tfor (uint256 i = 0; i < _masks.length; i++) {\\n\\t\\t\\t\\tif (_masks[i] != 0x0) {\\n\\t\\t\\t\\t\\trequire(maskAtIndexOf(i, msg.sender) & _masks[i] == _masks[i]);\\n\\t\\t\\t\\t\\t_count += _popcount(_masks[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\trequire(_count == _tokenIds.length);\\n\\t\\t\\t_transfer(msg.sender, _to, _masks, _tokenIds);\\n\\t\\t}\\n\\t}\\n\\n\\t// Can be overridden by a parent contract in order to add some logic before the transfer completes. The\\n\\t// code here is important for the ERC-721 side of things so unless you explicitly want to change how this\\n\\t// works, you should always use `super._beforeTransfer(...);` in your overridden function.\\n\\tfunction _beforeTransfer(address _from, address _to, bytes32[] memory, uint256[] memory _tokenIds) internal virtual {\\n\\t\\tunchecked {\\n\\t\\t\\tbool _skip = skipEventEmits;\\n\\t\\t\\tbool _skipApproveds = info.users[_from].approvedCount == 0;\\n\\t\\t\\tif (!(_skipApproveds && _skip)) {\\n\\t\\t\\t\\tfor (uint256 i = 0; i < _tokenIds.length; i++) {\\n\\t\\t\\t\\t\\tif (!_skipApproveds && getApproved(_tokenIds[i]) != address(0x0)) {\\n\\t\\t\\t\\t\\t\\tinfo.users[_from].approvedCount--;\\n\\t\\t\\t\\t\\t\\tinfo.approved[_tokenIds[i]] = address(0x0);\\n\\t\\t\\t\\t\\t\\temit Approval(address(0x0), address(0x0), _tokenIds[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!_skip) {\\n\\t\\t\\t\\t\\t\\temit Transfer(_from, _to, _tokenIds[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _transfer(address _from, address _to, bytes32[] memory _masks, uint256[] memory _tokenIds) internal {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(_to != address(0x0));\\n\\t\\t\\trequire(_tokenIds.length > 0);\\n\\t\\t\\t_beforeTransfer(_from, _to, _masks, _tokenIds);\\n\\t\\t\\tuint256 _fromActive = uint224(info.users[_from].activeMasks);\\n\\t\\t\\tuint256 _toActive = uint224(info.users[_to].activeMasks);\\n\\t\\t\\tfor (uint256 i = 0; i < _masks.length; i++) {\\n\\t\\t\\t\\tif (_masks[i] != bytes32(0x0)) {\\n\\t\\t\\t\\t\\tbytes32 _fromMask = maskAtIndexOf(i, _from);\\n\\t\\t\\t\\t\\t_fromMask ^= _masks[i];\\n\\t\\t\\t\\t\\tinfo.users[_from].masks[i] = _fromMask;\\n\\t\\t\\t\\t\\tbytes32 _toMask = maskAtIndexOf(i, _to);\\n\\t\\t\\t\\t\\t_toMask |= _masks[i];\\n\\t\\t\\t\\t\\tinfo.users[_to].masks[i] = _toMask;\\n\\t\\t\\t\\t\\tif (_fromMask == 0x0) {\\n\\t\\t\\t\\t\\t\\t_fromActive ^= 1 << i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t_toActive |= 1 << i;\\n\\t\\t\\t\\t\\trequire(_fromMask & _toMask == 0x0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tuint256 _fromBalance = balanceOf(_from);\\n\\t\\t\\t_fromBalance -= _tokenIds.length;\\n\\t\\t\\tinfo.users[_from].balance = uint16(_fromBalance);\\n\\t\\t\\tinfo.users[_from].activeMasks = bytes28(uint224(_fromActive));\\n\\t\\t\\tuint256 _toBalance = balanceOf(_to);\\n\\t\\t\\tinfo.users[_to].balance = uint16(_toBalance + _tokenIds.length);\\n\\t\\t\\tinfo.users[_to].activeMasks = bytes28(uint224(_toActive));\\n\\t\\t\\tif (_fromBalance == 0) {\\n\\t\\t\\t\\tuint256 _index = info.indexOf[_from];\\n\\t\\t\\t\\tif (_toBalance == 0) {\\n\\t\\t\\t\\t\\tinfo.holders[_index] = _to;\\n\\t\\t\\t\\t\\tinfo.indexOf[_to] = _index;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\taddress _moved = info.holders[info.holders.length - 1];\\n\\t\\t\\t\\t\\tinfo.holders[_index] = _moved;\\n\\t\\t\\t\\t\\tinfo.indexOf[_moved] = _index;\\n\\t\\t\\t\\t\\tinfo.holders.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdelete info.indexOf[_from];\\n\\t\\t\\t} else if (_toBalance == 0) {\\n\\t\\t\\t\\tinfo.holders.push(_to);\\n\\t\\t\\t\\tinfo.indexOf[_to] = info.holders.length - 1;\\n\\t\\t\\t}\\n\\t\\t\\temit ERC20Transfer(TRANSFER_TOPIC, _from, _to, _tokenIds.length);\\n\\t\\t\\t_afterTransfer(_from, _to, _masks, _tokenIds);\\n\\t\\t}\\n\\t}\\n\\n\\t// Can be overridden by a parent contract and used as a way to execute extra code after a transfer has completed.\\n\\tfunction _afterTransfer(address _from, address _to, bytes32[] memory _masks, uint256[] memory _tokenIds) internal virtual {}\\n\\n\\n\\tfunction _tokenIdToMask(uint256 _tokenId) internal view returns (uint256 maskIndex, bytes32 mask) {\\n\\t\\tunchecked {\\n\\t\\t\\tmaskIndex = (_tokenId - totalSupply - 1) / MASK_SIZE;\\n\\t\\t\\tmask = bytes32(1 << (_tokenId - (MASK_SIZE * maskIndex) - totalSupply - 1));\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfunction _popcount(bytes32 _b) internal pure returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 _n = uint256(_b);\\n\\t\\t\\tif (_n == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t} else if (_n == UINT_MAX) {\\n\\t\\t\\t\\treturn MASK_SIZE;\\n\\t\\t\\t}\\n\\t\\t\\t_n -= (_n >> 1) & M1;\\n\\t\\t\\t_n = (_n & M2) + ((_n >> 2) & M2);\\n\\t\\t\\t_n = (_n + (_n >> 4)) & M4;\\n\\t\\t\\t_n = (_n * H01) >> 248;\\n\\t\\t\\treturn _n;\\n\\t\\t}\\n\\t}\\n\\n\\n\\t// An extremely gas efficient implementation of the least significant bit algorithm. Due to all of\\n\\t// the constants in the if/else binary search tree, this function does add approximately 1.1m gas\\n\\t// to the deployment cost (~0.022 ETH @ 20 Gwei) but the end users will save on transaction fees.\\n\\t// The 'break even' point is around 3,000 total transfer volume where by you spending the extra to\\n\\t// make it more efficient, you have saved your end users more than you initially paid.\\n\\t// If you would rather have cheaper deployment costs and slightly less efficient transfers, replace\\n\\t// the entire `_lsb()` function with the one commented below:\\n\\t// ```function _lsb(uint256 _n) internal pure returns (uint256 i) {\\n\\t// \\tunchecked { uint256 _b = _n & ~(_n - 1); i = 0;\\n\\t// \\tfor (uint256 _s = 0x80; _s > 0; _s >>= 1) { if (_b >= (1 << _s)) { _b >>= _s; i |= _s; } } }\\n\\t// }```\\n\\tfunction _lsb(uint256 _n) internal pure returns (uint256 i) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 _b = _n & ~(_n - 1);\\n\\t\\t\\tif (_b < 0x0100000000000000000000000000000000)\\n\\t\\t\\t\\tif (_b < 0x010000000000000000)\\n\\t\\t\\t\\t\\tif (_b < 0x0100000000)\\n\\t\\t\\t\\t\\t\\tif (_b < 0x010000)\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0100)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x10)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x04)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x02) return 0; else return 1;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x08) return 2; else return 3;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x40)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x20) return 4; else return 5;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x80) return 6; else return 7;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x1000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0400)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0200) return 8; else return 9;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0800) return 10; else return 11;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x4000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x2000) return 12; else return 13;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x8000) return 14; else return 15;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x01000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x100000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x040000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x020000) return 16; else return 17;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x080000) return 18; else return 19;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x400000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x200000) return 20; else return 21;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x800000) return 22; else return 23;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x10000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x04000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x02000000) return 24; else return 25;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x08000000) return 26; else return 27;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x40000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x20000000) return 28; else return 29;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x80000000) return 30; else return 31;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tif (_b < 0x01000000000000)\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x010000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x1000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0400000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0200000000) return 32; else return 33;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0800000000) return 34; else return 35;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x4000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x2000000000) return 36; else return 37;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x8000000000) return 38; else return 39;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x100000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x040000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x020000000000) return 40; else return 41;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x080000000000) return 42; else return 43;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x400000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x200000000000) return 44; else return 45;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x800000000000) return 46; else return 47;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0100000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x10000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x04000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x02000000000000) return 48; else return 49;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x08000000000000) return 50; else return 51;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x40000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x20000000000000) return 52; else return 53;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x80000000000000) return 54; else return 55;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x1000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0400000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0200000000000000) return 56; else return 57;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0800000000000000) return 58; else return 59;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x4000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x2000000000000000) return 60; else return 61;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x8000000000000000) return 62; else return 63;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tif (_b < 0x01000000000000000000000000)\\n\\t\\t\\t\\t\\t\\tif (_b < 0x0100000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x01000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x100000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x040000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x020000000000000000) return 64; else return 65;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x080000000000000000) return 66; else return 67;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x400000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x200000000000000000) return 68; else return 69;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x800000000000000000) return 70; else return 71;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x10000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x04000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x02000000000000000000) return 72; else return 73;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x08000000000000000000) return 74; else return 75;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x40000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x20000000000000000000) return 76; else return 77;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x80000000000000000000) return 78; else return 79;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x010000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x1000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0400000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0200000000000000000000) return 80; else return 81;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0800000000000000000000) return 82; else return 83;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x4000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x2000000000000000000000) return 84; else return 85;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x8000000000000000000000) return 86; else return 87;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x100000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x040000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x020000000000000000000000) return 88; else return 89;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x080000000000000000000000) return 90; else return 91;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x400000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x200000000000000000000000) return 92; else return 93;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x800000000000000000000000) return 94; else return 95;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tif (_b < 0x010000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0100000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x10000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x04000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x02000000000000000000000000) return 96; else return 97;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x08000000000000000000000000) return 98; else return 99;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x40000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x20000000000000000000000000) return 100; else return 101;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x80000000000000000000000000) return 102; else return 103;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x1000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0400000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0200000000000000000000000000) return 104; else return 105;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0800000000000000000000000000) return 106; else return 107;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x4000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x2000000000000000000000000000) return 108; else return 109;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x8000000000000000000000000000) return 110; else return 111;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x01000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x100000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x040000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x020000000000000000000000000000) return 112; else return 113;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x080000000000000000000000000000) return 114; else return 115;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x400000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x200000000000000000000000000000) return 116; else return 117;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x800000000000000000000000000000) return 118; else return 119;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x10000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x04000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x02000000000000000000000000000000) return 120; else return 121;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x08000000000000000000000000000000) return 122; else return 123;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x40000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x20000000000000000000000000000000) return 124; else return 125;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x80000000000000000000000000000000) return 126; else return 127;\\n\\t\\t\\telse\\n\\t\\t\\t\\tif (_b < 0x01000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\tif (_b < 0x010000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\tif (_b < 0x01000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x010000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x1000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0400000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0200000000000000000000000000000000) return 128; else return 129;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0800000000000000000000000000000000) return 130; else return 131;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x4000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x2000000000000000000000000000000000) return 132; else return 133;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x8000000000000000000000000000000000) return 134; else return 135;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x100000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x040000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x020000000000000000000000000000000000) return 136; else return 137;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x080000000000000000000000000000000000) return 138; else return 139;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x400000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x200000000000000000000000000000000000) return 140; else return 141;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x800000000000000000000000000000000000) return 142; else return 143;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tif (_b < uint160(0x0100000000000000000000000000000000000000))\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x10000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x04000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x02000000000000000000000000000000000000) return 144; else return 145;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x08000000000000000000000000000000000000) return 146; else return 147;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x40000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x20000000000000000000000000000000000000) return 148; else return 149;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x80000000000000000000000000000000000000) return 150; else return 151;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < uint160(0x1000000000000000000000000000000000000000))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < uint160(0x0400000000000000000000000000000000000000))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < uint160(0x0200000000000000000000000000000000000000)) return 152; else return 153;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < uint160(0x0800000000000000000000000000000000000000)) return 154; else return 155;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < uint160(0x4000000000000000000000000000000000000000))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < uint160(0x2000000000000000000000000000000000000000)) return 156; else return 157;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < uint160(0x8000000000000000000000000000000000000000)) return 158; else return 159;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tif (_b < 0x0100000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x01000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x100000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x040000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x020000000000000000000000000000000000000000) return 160; else return 161;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x080000000000000000000000000000000000000000) return 162; else return 163;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x400000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x200000000000000000000000000000000000000000) return 164; else return 165;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x800000000000000000000000000000000000000000) return 166; else return 167;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x10000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x04000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x02000000000000000000000000000000000000000000) return 168; else return 169;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x08000000000000000000000000000000000000000000) return 170; else return 171;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x40000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x20000000000000000000000000000000000000000000) return 172; else return 173;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x80000000000000000000000000000000000000000000) return 174; else return 175;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x010000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x1000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0400000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0200000000000000000000000000000000000000000000) return 176; else return 177;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0800000000000000000000000000000000000000000000) return 178; else return 179;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x4000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x2000000000000000000000000000000000000000000000) return 180; else return 181;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x8000000000000000000000000000000000000000000000) return 182; else return 183;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x100000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x040000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x020000000000000000000000000000000000000000000000) return 184; else return 185;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x080000000000000000000000000000000000000000000000) return 186; else return 187;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x400000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x200000000000000000000000000000000000000000000000) return 188; else return 189;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x800000000000000000000000000000000000000000000000) return 190; else return 191;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tif (_b < 0x0100000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\tif (_b < 0x010000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0100000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x10000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x04000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x02000000000000000000000000000000000000000000000000) return 192; else return 193;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x08000000000000000000000000000000000000000000000000) return 194; else return 195;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x40000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x20000000000000000000000000000000000000000000000000) return 196; else return 197;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x80000000000000000000000000000000000000000000000000) return 198; else return 199;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x1000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0400000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0200000000000000000000000000000000000000000000000000) return 200; else return 201;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0800000000000000000000000000000000000000000000000000) return 202; else return 203;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x4000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x2000000000000000000000000000000000000000000000000000) return 204; else return 205;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x8000000000000000000000000000000000000000000000000000) return 206; else return 207;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x01000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x100000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x040000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x020000000000000000000000000000000000000000000000000000) return 208; else return 209;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x080000000000000000000000000000000000000000000000000000) return 210; else return 211;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x400000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x200000000000000000000000000000000000000000000000000000) return 212; else return 213;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x800000000000000000000000000000000000000000000000000000) return 214; else return 215;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x10000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x04000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x02000000000000000000000000000000000000000000000000000000) return 216; else return 217;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x08000000000000000000000000000000000000000000000000000000) return 218; else return 219;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x40000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x20000000000000000000000000000000000000000000000000000000) return 220; else return 221;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x80000000000000000000000000000000000000000000000000000000) return 222; else return 223;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tif (_b < 0x01000000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x010000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x1000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0400000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0200000000000000000000000000000000000000000000000000000000) return 224; else return 225;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0800000000000000000000000000000000000000000000000000000000) return 226; else return 227;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x4000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x2000000000000000000000000000000000000000000000000000000000) return 228; else return 229;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x8000000000000000000000000000000000000000000000000000000000) return 230; else return 231;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x100000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x040000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x020000000000000000000000000000000000000000000000000000000000) return 232; else return 233;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x080000000000000000000000000000000000000000000000000000000000) return 234; else return 235;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x400000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x200000000000000000000000000000000000000000000000000000000000) return 236; else return 237;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x800000000000000000000000000000000000000000000000000000000000) return 238; else return 239;\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0100000000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x10000000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x04000000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x02000000000000000000000000000000000000000000000000000000000000) return 240; else return 241;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x08000000000000000000000000000000000000000000000000000000000000) return 242; else return 243;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x40000000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x20000000000000000000000000000000000000000000000000000000000000) return 244; else return 245;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x80000000000000000000000000000000000000000000000000000000000000) return 246; else return 247;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x1000000000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0400000000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0200000000000000000000000000000000000000000000000000000000000000) return 248; else return 249;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x0800000000000000000000000000000000000000000000000000000000000000) return 250; else return 251;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x4000000000000000000000000000000000000000000000000000000000000000)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x2000000000000000000000000000000000000000000000000000000000000000) return 252; else return 253;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_b < 0x8000000000000000000000000000000000000000000000000000000000000000) return 254; else return 255;\\n\\t\\t}\\n\\t}\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string[4]\",\"name\":\"_strings\",\"type\":\"string[4]\"},{\"indexed\":false,\"internalType\":\"uint256[4]\",\"name\":\"_numbers\",\"type\":\"uint256[4]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"launchTime\",\"type\":\"uint256\"}],\"name\":\"NewToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allLaunchedTokens\",\"outputs\":[{\"internalType\":\"contract xNFTToken[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[4]\",\"name\":\"_strings\",\"type\":\"string[4]\"},{\"internalType\":\"uint256[4]\",\"name\":\"_numbers\",\"type\":\"uint256[4]\"}],\"name\":\"launch\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"launchedTokenAtIndex\",\"outputs\":[{\"internalType\":\"contract xNFTToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"template\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLaunchedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "xNFTLauncher", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}