{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value => uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/HoodyGangStake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\r\\nimport \\\"./IHoody.sol\\\";\\r\\nimport \\\"./IHoodySign.sol\\\";\\r\\n\\r\\ninterface IHoodyGang is IHoody {\\r\\n    function transferFrom(address, address, uint256) external;\\r\\n\\r\\n    function ownerOf(uint256) external view returns (address);\\r\\n\\r\\n    function approve(address, uint256) external;\\r\\n}\\r\\n\\r\\ninterface IHoodyCredit {\\r\\n    function transfer(address, uint256) external returns (bool);\\r\\n\\r\\n    function balanceOf(address) external returns (uint256);\\r\\n}\\r\\n\\r\\ncontract HoodyGangStake is IHoody, Ownable {\\r\\n    using EnumerableSet for EnumerableSet.UintSet;\\r\\n\\r\\n    uint256 public rewardInterval = 1 days;\\r\\n    mapping(address => EnumerableSet.UintSet) stakedNFTsByHolder;\\r\\n    mapping(HoodyGangRarity => uint256) public rewardPointByRarity;\\r\\n    mapping(uint256 => HoodyGangRarity) public stakedNFTsRarity;\\r\\n    mapping(uint256 => uint256) public lastClaimedTime;\\r\\n\\r\\n    address public hoodyGang;\\r\\n    address public hoodyCredit;\\r\\n    address public hoodySign;\\r\\n\\r\\n    bool public rewardAvailable = true;\\r\\n\\r\\n    event StakeNFT(address indexed holder, uint256 tokenID);\\r\\n    event UnStakeNFT(address indexed holder, uint256 tokenID);\\r\\n    event ResetTimer(uint256 tokenID, uint256 claimTime);\\r\\n\\r\\n    constructor(address _hoodyGang, address _hoodyCredit) Ownable(msg.sender) {\\r\\n        hoodyGang = _hoodyGang;\\r\\n        hoodyCredit = _hoodyCredit;\\r\\n    }\\r\\n\\r\\n    function stake(\\r\\n        uint256[] memory _tokenIds,\\r\\n        HoodyGangRarity[] memory _rarities,\\r\\n        bytes memory _signature\\r\\n    ) external {\\r\\n        require(\\r\\n            IHoodySign(hoodySign).verifyForStake(\\r\\n                msg.sender,\\r\\n                _tokenIds,\\r\\n                _rarities,\\r\\n                _signature\\r\\n            ),\\r\\n            \\\"Invalid Signature\\\"\\r\\n        );\\r\\n\\r\\n        IHoodySign(hoodySign).increaseNonce(msg.sender);\\r\\n\\r\\n        for (uint i; i < _tokenIds.length; i++) {\\r\\n            require(\\r\\n                IHoodyGang(hoodyGang).ownerOf(_tokenIds[i]) == msg.sender,\\r\\n                \\\"Not your token!\\\"\\r\\n            );\\r\\n            stakedNFTsRarity[_tokenIds[i]] = _rarities[i];\\r\\n            stakedNFTsByHolder[msg.sender].add(_tokenIds[i]);\\r\\n            IHoodyGang(hoodyGang).approve(address(this), _tokenIds[i]);\\r\\n            IHoodyGang(hoodyGang).transferFrom(\\r\\n                msg.sender,\\r\\n                address(this),\\r\\n                _tokenIds[i]\\r\\n            );\\r\\n            lastClaimedTime[_tokenIds[i]] = block.timestamp;\\r\\n\\r\\n            emit StakeNFT(msg.sender, _tokenIds[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function unstake(uint256[] memory _tokenIds) external {\\r\\n        claimCredit();\\r\\n        for (uint i; i < _tokenIds.length; i++) {\\r\\n            require(\\r\\n                stakedNFTsByHolder[msg.sender].contains(_tokenIds[i]),\\r\\n                \\\"Not your token!\\\"\\r\\n            );\\r\\n            stakedNFTsByHolder[msg.sender].remove(_tokenIds[i]);\\r\\n            IHoodyGang(hoodyGang).transferFrom(\\r\\n                address(this),\\r\\n                msg.sender,\\r\\n                _tokenIds[i]\\r\\n            );\\r\\n\\r\\n            emit UnStakeNFT(msg.sender, _tokenIds[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calcTotalCreditsByHolder(\\r\\n        address _holder\\r\\n    ) public view returns (uint256) {\\r\\n        uint256[] memory tokenIds = getStakeTokensByHolder(_holder);\\r\\n        uint256 credit;\\r\\n        for (uint256 i; i < tokenIds.length; i++) {\\r\\n            uint256 tokenId = tokenIds[i];\\r\\n            if (block.timestamp >= lastClaimedTime[tokenId] + rewardInterval) {\\r\\n                credit +=\\r\\n                    rewardPointByRarity[stakedNFTsRarity[tokenId]] *\\r\\n                    ((block.timestamp - lastClaimedTime[tokenId]) /\\r\\n                        rewardInterval);\\r\\n            }\\r\\n        }\\r\\n        return credit;\\r\\n    }\\r\\n\\r\\n    function claimCredit() public {\\r\\n        if (rewardAvailable) {\\r\\n            uint256[] memory tokenIds = getStakeTokensByHolder(msg.sender);\\r\\n            uint256 credit;\\r\\n            for (uint256 i; i < tokenIds.length; i++) {\\r\\n                uint256 tokenId = tokenIds[i];\\r\\n                if (\\r\\n                    block.timestamp >= lastClaimedTime[tokenId] + rewardInterval\\r\\n                ) {\\r\\n                    uint256 passed = (block.timestamp -\\r\\n                        lastClaimedTime[tokenId]) / rewardInterval;\\r\\n                    credit +=\\r\\n                        rewardPointByRarity[stakedNFTsRarity[tokenId]] *\\r\\n                        passed;\\r\\n                    lastClaimedTime[tokenId] += passed * rewardInterval;\\r\\n                }\\r\\n\\r\\n                emit ResetTimer(tokenId, lastClaimedTime[tokenId]);\\r\\n            }\\r\\n            IHoodyCredit(hoodyCredit).transfer(msg.sender, credit);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getStakeTokensByHolder(\\r\\n        address _holder\\r\\n    ) public view returns (uint256[] memory) {\\r\\n        uint256[] memory tokenIds = new uint256[](\\r\\n            stakedNFTsByHolder[_holder].length()\\r\\n        );\\r\\n        for (uint256 i; i < stakedNFTsByHolder[_holder].length(); i++) {\\r\\n            tokenIds[i] = stakedNFTsByHolder[_holder].at(i);\\r\\n        }\\r\\n        return tokenIds;\\r\\n    }\\r\\n\\r\\n    function getLastClaimedTime(\\r\\n        uint256[] memory _tokenIds\\r\\n    ) external view returns (uint256[] memory) {\\r\\n        uint256[] memory claimTimes = new uint256[](_tokenIds.length);\\r\\n        for (uint i; i < _tokenIds.length; i++) {\\r\\n            claimTimes[i] = lastClaimedTime[_tokenIds[i]];\\r\\n        }\\r\\n\\r\\n        return claimTimes;\\r\\n    }\\r\\n\\r\\n    function setRewardPointByRarity(\\r\\n        HoodyGangRarity[] memory _rarities,\\r\\n        uint256[] memory _points\\r\\n    ) external onlyOwner {\\r\\n        require(_rarities.length == _points.length, \\\"Invalid Params!\\\");\\r\\n        for (uint i; i < _rarities.length; i++) {\\r\\n            rewardPointByRarity[_rarities[i]] = _points[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdraw() external onlyOwner {\\r\\n        uint256 balance = IHoodyCredit(hoodyCredit).balanceOf(address(this));\\r\\n        IHoodyCredit(hoodyCredit).transfer(owner(), balance);\\r\\n    }\\r\\n\\r\\n    function closeStaking() external onlyOwner {\\r\\n        rewardAvailable = false;\\r\\n    }\\r\\n\\r\\n    function setHoodySign(address _hoodySign) external onlyOwner {\\r\\n        hoodySign = _hoodySign;\\r\\n    }\\r\\n\\r\\n    function setHoodyGang(address _hoodyGang) external onlyOwner {\\r\\n        hoodyGang = _hoodyGang;\\r\\n    }\\r\\n\\r\\n    function setHoodyCredit(address _hoodyCredit) external onlyOwner {\\r\\n        hoodyCredit = _hoodyCredit;\\r\\n    }\\r\\n\\r\\n    function setRewardInterval(uint256 _rewardInterval) external onlyOwner {\\r\\n        rewardInterval = _rewardInterval;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/IHoody.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\ninterface IHoody {\\r\\n    enum HoodyGangRarity {\\r\\n        Common,\\r\\n        Rare,\\r\\n        Legendary\\r\\n    }\\r\\n\\r\\n    enum HoodyTraitRarity {\\r\\n        Common,\\r\\n        Rare,\\r\\n        Legendary\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/IHoodySign.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.19;\\r\\nimport \\\"./IHoody.sol\\\";\\r\\n\\r\\ninterface IHoodySign is IHoody {\\r\\n    function verifyForTraits(\\r\\n        address,\\r\\n        string memory,\\r\\n        uint16[] memory,\\r\\n        bytes memory\\r\\n    ) external view returns (bool);\\r\\n\\r\\n    function verifyForStake(\\r\\n        address,\\r\\n        uint256[] memory,\\r\\n        HoodyGangRarity[] memory,\\r\\n        bytes memory\\r\\n    ) external view returns (bool);\\r\\n\\r\\n    function verifyForMigrate(\\r\\n        address,\\r\\n        uint256,\\r\\n        string memory,\\r\\n        bytes memory\\r\\n    ) external view returns (bool);\\r\\n\\r\\n    function increaseNonce(address) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hoodyGang\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_hoodyCredit\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimTime\",\"type\":\"uint256\"}],\"name\":\"ResetTimer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"StakeNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"UnStakeNFT\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"calcTotalCreditsByHolder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimCredit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getLastClaimedTime\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"getStakeTokensByHolder\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hoodyCredit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hoodyGang\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hoodySign\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastClaimedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IHoody.HoodyGangRarity\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"rewardPointByRarity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hoodyCredit\",\"type\":\"address\"}],\"name\":\"setHoodyCredit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hoodyGang\",\"type\":\"address\"}],\"name\":\"setHoodyGang\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hoodySign\",\"type\":\"address\"}],\"name\":\"setHoodySign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardInterval\",\"type\":\"uint256\"}],\"name\":\"setRewardInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IHoody.HoodyGangRarity[]\",\"name\":\"_rarities\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_points\",\"type\":\"uint256[]\"}],\"name\":\"setRewardPointByRarity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"enum IHoody.HoodyGangRarity[]\",\"name\":\"_rarities\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakedNFTsRarity\",\"outputs\":[{\"internalType\":\"enum IHoody.HoodyGangRarity\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HoodyGangStake", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c26022fcfadedf8d448cd3fc3670dfc837ddfc7c0000000000000000000000009ba1d69e4ec2722ad3fe49c2162a69e516ec630b", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}