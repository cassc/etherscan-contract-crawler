{"SourceCode": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ninterface IProxy {\r\n    function masterCopy() external view returns (address);\r\n}\r\n\r\n/// @title GnosisSafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.io>\r\n/// @author Richard Meissner - <richard@gnosis.io>\r\ncontract GnosisSafeProxy {\r\n    // singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\r\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\r\n    address internal singleton;\r\n\r\n    /// @dev Constructor function sets address of singleton contract.\r\n    /// @param _singleton Singleton address.\r\n    constructor(address _singleton) {\r\n        require(_singleton != address(0), \"Invalid singleton address provided\");\r\n        singleton = _singleton;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    fallback() external payable {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\r\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\r\n                mstore(0, _singleton)\r\n                return(0, 0x20)\r\n            }\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            if eq(success, 0) {\r\n                revert(0, returndatasize())\r\n            }\r\n            return(0, returndatasize())\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract GnosisSafeProxyFactory {\r\n    event ProxyCreation(GnosisSafeProxy proxy, address singleton);\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param singleton Address of singleton contract.\r\n    /// @param data Payload for message call sent to new proxy contract.\r\n    function createProxy(address singleton, bytes memory data) public returns (GnosisSafeProxy proxy) {\r\n        proxy = new GnosisSafeProxy(singleton);\r\n        if (data.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, singleton);\r\n    }\r\n\r\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\r\n    function proxyRuntimeCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).runtimeCode;\r\n    }\r\n\r\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\r\n    function proxyCreationCode() public pure returns (bytes memory) {\r\n        return type(GnosisSafeProxy).creationCode;\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\r\n    ///      This method is only meant as an utility to be called from other methods\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function deployProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) internal returns (GnosisSafeProxy proxy) {\r\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\r\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\r\n        bytes memory deploymentData = abi.encodePacked(type(GnosisSafeProxy).creationCode, uint256(uint160(_singleton)));\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\r\n        }\r\n        require(address(proxy) != address(0), \"Create2 call failed\");\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function createProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        if (initializer.length > 0)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        emit ProxyCreation(proxy, _singleton);\r\n    }\r\n\r\n    /// @dev Allows to create new proxy contact, execute a message call to the new proxy and call a specified callback within one transaction\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    /// @param callback Callback that will be invoced after the new proxy contract has been successfully deployed and initialized.\r\n    function createProxyWithCallback(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce,\r\n        IProxyCreationCallback callback\r\n    ) public returns (GnosisSafeProxy proxy) {\r\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\r\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\r\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\r\n    }\r\n\r\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\r\n    ///      This method is only meant for address calculation purpose when you use an initializer that would revert,\r\n    ///      therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function calculateCreateProxyWithNonceAddress(\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external returns (GnosisSafeProxy proxy) {\r\n        proxy = deployProxyWithNonce(_singleton, initializer, saltNonce);\r\n        revert(string(abi.encodePacked(proxy)));\r\n    }\r\n}\r\n\r\ninterface IProxyCreationCallback {\r\n    function proxyCreated(\r\n        GnosisSafeProxy proxy,\r\n        address _singleton,\r\n        bytes calldata initializer,\r\n        uint256 saltNonce\r\n    ) external;\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_singleton\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "GnosisSafeProxy", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000d9Db270c1B5E3Bd161E8c8503c55cEABeE709552", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d1429297349653a4918076d650332de1a1068c5f3e07c5c82360c277770b9552"}