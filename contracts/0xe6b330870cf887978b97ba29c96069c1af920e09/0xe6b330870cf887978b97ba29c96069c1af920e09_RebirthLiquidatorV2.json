{"SourceCode": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity 0.8.19;\r\n\r\ncontract RebirthTestDeployer{\r\n    //this deployer needs to deploy in the constructor an RBH token and send half the tokens to core after deploying it aswell, and half to the deployer, create another ERC20 token memecoin for testing, and then use the ethereum deposited for the constructor to create a liquidity pool for both RBH and the memecoin with ETH, then send the liquidity tokens to the deployer\r\n    constructor() {\r\n        RebirthProtocolCore DeployedCore = new RebirthProtocolCore(address(new RebirthedToken(100000000000000000000000000, \"Rebirth Token\", \"RBH\")));\r\n        DeployedCore.AddRemoveAdmin(msg.sender, true);\r\n        DeployedCore.setSuperAdmin(msg.sender);\r\n        RebirthedToken RBH = RebirthedToken(address(DeployedCore.RBH()));\r\n        RBH.transfer(address(DeployedCore), RBH.balanceOf(address(this)) / 2);\r\n        RBH.transfer(msg.sender, RBH.balanceOf(address(this)) / 2);\r\n        RebirthedToken Memecoin = new RebirthedToken(100000000000000000000000000, \"Test Memecoin\", \"MEME\");\r\n        Memecoin.transfer(msg.sender, Memecoin.balanceOf(address(this)));\r\n        // DeployedCore.CreatePool(address(Memecoin), address(0), 0, 1, 0, \"Test Memecoin\", \"MEME\");\r\n        // DeployedCore.ClosePool(0);\r\n        // IUniswapV2Factory UniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n        // IUniswapV2Router02 UniswapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        // //create pair on uniswap with factory between RBH and ETH and another between MEME and ETH, between the two pairs and send the liquidity tokens to the deployer\r\n        // IUniswapV2Pair RBHPair = IUniswapV2Pair(UniswapFactory.createPair(address(RBH), UniswapRouter.WETH()));\r\n        // IUniswapV2Pair MemecoinPair = IUniswapV2Pair(UniswapFactory.createPair(address(Memecoin), UniswapRouter.WETH()));\r\n        // RBH.approve(address(UniswapRouter), RBH.balanceOf(address(this)));\r\n        // Memecoin.approve(address(UniswapRouter), Memecoin.balanceOf(address(this)));\r\n        // //use addLiquidityETH and half the ether balance for each pair\r\n        // UniswapRouter.addLiquidityETH{value: address(this).balance / 2}(address(RBH), RBH.balanceOf(address(this)), 0, 0, address(this), block.timestamp + 300);\r\n        // UniswapRouter.addLiquidityETH{value: address(this).balance / 2}(address(Memecoin), Memecoin.balanceOf(address(this)), 0, 0, address(this), block.timestamp + 300);\r\n        // //transfer the liquidity tokens to the deployer\r\n        // RBHPair.transfer(msg.sender, RBHPair.balanceOf(address(this)));\r\n        // MemecoinPair.transfer(msg.sender, MemecoinPair.balanceOf(address(this)));\r\n    }\r\n}\r\n\r\ncontract RebirthProtocolCore{\r\n    //Variable Declarations\r\n    address public RBH_SuperAdmin;\r\n    ERC20 public RBH;\r\n    IUniswapV2Factory UniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n    IUniswapV2Router02 UniswapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    address public Liquidator;\r\n    address public FreemintContract;\r\n    uint256[] public OpenPools;\r\n    uint256[] public ClosedPools;\r\n    uint256 public TotalUsers;\r\n    uint256 public TotalEtherDepositedEquivalents;\r\n    uint256 internal PoolIncrement;\r\n    //Struct-Enum Declarations\r\n\r\n    enum AlternativePayoutOption { RBHTokens, NFTFreemints, RelaunchShares }\r\n\r\n    struct RebirthPool{\r\n        string Name;\r\n        string Symbol;\r\n        address TokenAddress;\r\n        address RebirthedTokenAddress;\r\n        address PairAddress;\r\n        uint256 PoolOpeningTime;\r\n        uint256 PoolClosingTime;\r\n        uint256 SoftCap;\r\n        uint256 MemecoinsPerRelaunchShare;\r\n        uint256 TotalTokensDeposited;\r\n        bool PoolSuccessful;\r\n        bool PoolClosed;\r\n    }\r\n\r\n    struct UserPoolDetails{\r\n        uint256 AmountDeposited;\r\n        AlternativePayoutOption AlternatePayoutChoice;\r\n        bool PreviouslyDeposited;\r\n        bool Claimed;\r\n    }\r\n\r\n    //Mapping Declarations\r\n    mapping(uint256 => RebirthPool) public Pools;\r\n    mapping(uint256 => mapping(address => UserPoolDetails)) public PoolDeposits;\r\n    mapping(address => uint256[]) public YourPools;\r\n    mapping(uint256 => uint256) internal OpenPoolsIndexer;\r\n    mapping(address => bool) public Admins;\r\n    mapping(address => bool) public UserParticipated;\r\n    mapping(address => uint256) public RelaunchShares;\r\n    mapping(address => uint256) public NFT_Freemints;\r\n\r\n    //Event Declarations\r\n\r\n    //Modifier Declarations\r\n    modifier onlyAdmin() {\r\n        require(Admins[msg.sender], \"Only admins can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySuperAdmin() {\r\n        require(msg.sender == RBH_SuperAdmin, \"Only super admin can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier OnlyLiquidator() {\r\n        require(msg.sender == Liquidator, \"Only liquidator can call this function\");\r\n        _;\r\n    }\r\n\r\n    //Constructor\r\n    constructor(address _RBH) {\r\n        RBH_SuperAdmin = msg.sender;\r\n        Admins[msg.sender] = true;\r\n        RBH = ERC20(_RBH);\r\n        Liquidator = address(0);\r\n    }\r\n\r\n    //Public Functions\r\n\r\n    function DepositTokens(uint256 PoolID, uint256 Amount, AlternativePayoutOption AlternatePayoutChoice) public {\r\n        require(block.timestamp >= Pools[PoolID].PoolOpeningTime && block.timestamp <= Pools[PoolID].PoolClosingTime, \"Pool is not open\");\r\n        require(ERC20(Pools[PoolID].TokenAddress).transferFrom(msg.sender, address(this), Amount), \"Transfer failed\");\r\n\r\n        if(!UserParticipated[msg.sender]){ TotalUsers++; UserParticipated[msg.sender] = true; }\r\n\r\n        if(!PoolDeposits[PoolID][msg.sender].PreviouslyDeposited){\r\n            require(Amount >= 1000); //Requires first time depositors to deposit some amount of token\r\n            YourPools[msg.sender].push(PoolID);\r\n        }\r\n\r\n        PoolDeposits[PoolID][msg.sender].AmountDeposited += Amount;\r\n        PoolDeposits[PoolID][msg.sender].AlternatePayoutChoice = AlternatePayoutChoice;\r\n        PoolDeposits[PoolID][msg.sender].PreviouslyDeposited = true;\r\n        Pools[PoolID].TotalTokensDeposited += Amount;\r\n    }\r\n\r\n    function DepositRelaunchShares(uint256 PoolID, uint256 Amount, AlternativePayoutOption AlternatePayoutChoice) public {\r\n        require(block.timestamp >= Pools[PoolID].PoolOpeningTime && block.timestamp <= Pools[PoolID].PoolClosingTime, \"Pool is not open\");\r\n        require(Amount > 0, \"Cannot deposit zero relaunch shares\");\r\n        require(RelaunchShares[msg.sender] >= Amount, \"Not enough relaunch shares\");\r\n\r\n        if(!UserParticipated[msg.sender]){ TotalUsers++; UserParticipated[msg.sender] = true; }\r\n\r\n        if(!PoolDeposits[PoolID][msg.sender].PreviouslyDeposited){\r\n            YourPools[msg.sender].push(PoolID);\r\n        }\r\n\r\n        RelaunchShares[msg.sender] -= Amount;\r\n\r\n        address[] memory Path = new address[](2);\r\n        Path[0] = UniswapRouter.WETH();\r\n        Path[1] = Pools[PoolID].TokenAddress;\r\n\r\n        uint256 MemecoinsPerRelaunchShare = UniswapRouter.getAmountsOut(0.001 ether, Path)[1];\r\n        uint256 DepositEquivalent = MemecoinsPerRelaunchShare * Amount;\r\n\r\n        PoolDeposits[PoolID][msg.sender].AmountDeposited += DepositEquivalent;\r\n        PoolDeposits[PoolID][msg.sender].AlternatePayoutChoice = AlternatePayoutChoice;\r\n        PoolDeposits[PoolID][msg.sender].PreviouslyDeposited = true;\r\n        Pools[PoolID].TotalTokensDeposited += DepositEquivalent;\r\n    }\r\n\r\n    function ClaimPool(uint256 PoolID) public {\r\n        require(Pools[PoolID].PoolClosed, \"Pool is still open\");\r\n        require(!PoolDeposits[PoolID][msg.sender].Claimed, \"Already claimed\");\r\n        require(PoolDeposits[PoolID][msg.sender].AmountDeposited > 0, \"No tokens deposited\");\r\n\r\n        if(Pools[PoolID].PoolSuccessful){\r\n            //Send the new contract tokens to the user\r\n            ERC20 NewMemecoin = ERC20(Pools[PoolID].RebirthedTokenAddress);\r\n            NewMemecoin.transfer(msg.sender, PoolDeposits[PoolID][msg.sender].AmountDeposited);\r\n        }\r\n        else{\r\n            //execute alternative payout option, nft freemints cost 10x relaunch shares\r\n            uint256 UserRelaunchSharesEquivalent = PoolDeposits[PoolID][msg.sender].AmountDeposited / Pools[PoolID].MemecoinsPerRelaunchShare;\r\n            if(PoolDeposits[PoolID][msg.sender].AlternatePayoutChoice == AlternativePayoutOption.RBHTokens){\r\n                //Send RBH tokens to the user\r\n                address[] memory Path = new address[](2);\r\n                Path[0] = UniswapRouter.WETH();\r\n                Path[1] = address(RBH);\r\n\r\n                uint256 RBHpayout = (UniswapRouter.getAmountsOut(0.001 ether * UserRelaunchSharesEquivalent,Path)[1] * 110) / 100;\r\n                RBH.transfer(msg.sender, RBHpayout);\r\n            }\r\n            else if(PoolDeposits[PoolID][msg.sender].AlternatePayoutChoice == AlternativePayoutOption.NFTFreemints){\r\n                NFT_Freemints[msg.sender] += UserRelaunchSharesEquivalent / 10; //Watch out, could be 0 if memecoins are worth less than 0.01 Ether\r\n            }\r\n            else if(PoolDeposits[PoolID][msg.sender].AlternatePayoutChoice == AlternativePayoutOption.RelaunchShares){\r\n                RelaunchShares[msg.sender] += UserRelaunchSharesEquivalent;\r\n            }\r\n        }\r\n\r\n        PoolDeposits[PoolID][msg.sender].Claimed = true;\r\n    }\r\n\r\n    //OnlyOwner Functions\r\n    function CreatePool(address TokenAddress, address PairAddress, uint256 HoursTillOpen, uint256 LenghtInHours, uint256 SoftCap, string memory TokenName, string memory TokenSymbol) public onlyAdmin {\r\n        uint256 PoolID = PoolIncrement;\r\n        PoolIncrement++;\r\n        uint256 StartTime = (block.timestamp + (HoursTillOpen * 3600));\r\n        uint256 EndTime = StartTime + (LenghtInHours * 3600);\r\n        Pools[PoolID] = RebirthPool(TokenName, TokenSymbol, TokenAddress, address(0), PairAddress, StartTime, EndTime, SoftCap, 0, 0, false, false);\r\n\r\n        address[] memory Path = new address[](2);\r\n        Path[0] = UniswapRouter.WETH();\r\n        Path[1] = Pools[PoolID].TokenAddress;\r\n\r\n        uint256 MemecoinsPerRelaunchShare = UniswapRouter.getAmountsOut(0.001 ether, Path)[1];\r\n        Pools[PoolID].MemecoinsPerRelaunchShare = MemecoinsPerRelaunchShare;\r\n\r\n        AddRemoveActivePool(PoolID, true);\r\n    }\r\n\r\n    function ClosePool(uint256 PoolID) public onlyAdmin {\r\n        require(block.timestamp >= Pools[PoolID].PoolClosingTime, \"Pool is still open\");\r\n        require(Pools[PoolID].PoolClosed == false, \"Pool is already closed\");\r\n        AddRemoveActivePool(PoolID, false);\r\n\r\n        if (Pools[PoolID].TotalTokensDeposited < Pools[PoolID].SoftCap){\r\n            Pools[PoolID].PoolSuccessful = false;\r\n            ERC20 Token = ERC20(Pools[PoolID].TokenAddress);\r\n            Token.transfer(RBH_SuperAdmin, Token.balanceOf(address(this)));\r\n\r\n            address[] memory Path = new address[](2);\r\n            Path[0] = Pools[PoolID].TokenAddress;\r\n            Path[1] = UniswapRouter.WETH();\r\n\r\n            uint256 EtherEquivalent = UniswapRouter.getAmountsOut(Pools[PoolID].TotalTokensDeposited, Path)[1];\r\n            unchecked{\r\n                TotalEtherDepositedEquivalents += EtherEquivalent;\r\n            }\r\n        }\r\n        else{\r\n            Pools[PoolID].PoolSuccessful = true;\r\n\r\n            ERC20 Token = ERC20(Pools[PoolID].TokenAddress);\r\n            Token.approve(address(UniswapRouter), Token.balanceOf(address(this)));\r\n\r\n            address[] memory Path = new address[](2);\r\n            Path[0] = Pools[PoolID].TokenAddress;\r\n            Path[1] = UniswapRouter.WETH();\r\n\r\n            UniswapRouter.swapExactTokensForETH(Token.balanceOf(address(this)), 0, Path, address(this), block.timestamp + 300);\r\n\r\n            //Buy back RBH with wrapped eth\r\n            Path[0] = UniswapRouter.WETH();\r\n            Path[1] = address(RBH);\r\n\r\n            uint256 RBH_TradeAmount = UniswapRouter.getAmountsOut(address(this).balance, Path)[1];\r\n\r\n            unchecked{\r\n                TotalEtherDepositedEquivalents += address(this).balance;\r\n            }\r\n\r\n            payable(RBH_SuperAdmin).transfer(address(this).balance);\r\n\r\n            //Create new ERC20 token with the name and symbol of the old memecoin\r\n            uint256 BalanceToLiquidity = Pools[PoolID].TotalTokensDeposited;\r\n            RebirthedToken NewToken = new RebirthedToken(((Pools[PoolID].TotalTokensDeposited * 210) / 100), Pools[PoolID].Name, Pools[PoolID].Symbol);\r\n            Pools[PoolID].RebirthedTokenAddress = address(NewToken);\r\n            NewToken.transfer(RBH_SuperAdmin, (BalanceToLiquidity / 10));\r\n\r\n            //Create new RBH/Memecoin pair on uniswap, send the liquidity tokens to the zero address\r\n            IUniswapV2Pair NewTokenPair = IUniswapV2Pair(UniswapFactory.createPair(address(RBH), address(NewToken)));\r\n            NewToken.approve(address(UniswapRouter), BalanceToLiquidity);\r\n            RBH.approve(address(UniswapRouter), RBH_TradeAmount);\r\n            UniswapRouter.addLiquidity(address(RBH), address(NewToken), RBH_TradeAmount, BalanceToLiquidity, 0, 0, address(this), (block.timestamp + 300));\r\n            ERC20(address(NewTokenPair)).transfer(address(0), ERC20(address(NewTokenPair)).balanceOf(address(this)));\r\n        }\r\n\r\n        Pools[PoolID].PoolClosed = true;\r\n        ClosedPools.push(PoolID);\r\n    }\r\n\r\n    function setSuperAdmin(address _newAdmin) public onlySuperAdmin {\r\n        RBH_SuperAdmin = _newAdmin;\r\n    }\r\n\r\n    function AddRemoveAdmin(address _newAdmin, bool AddRemove) public onlySuperAdmin {\r\n        Admins[_newAdmin] = AddRemove;\r\n    }\r\n\r\n    function SetFreemintContract(address _FreemintContract) public onlySuperAdmin {\r\n        FreemintContract = _FreemintContract;\r\n    }\r\n\r\n    function SetLiquidator(address _Liquidator) public onlySuperAdmin {\r\n        Liquidator = _Liquidator;\r\n        RBH.approve(Liquidator, 2**256 - 1);\r\n    }\r\n\r\n    function WithdrawRBH() public onlySuperAdmin {\r\n        RBH.transfer(RBH_SuperAdmin, RBH.balanceOf(address(this)));\r\n    }\r\n\r\n    //Only liquidator functions\r\n\r\n    function AddFreemint(address User, uint256 Amount) public OnlyLiquidator{\r\n        NFT_Freemints[User] += Amount;\r\n    }\r\n\r\n    function AddRelaunchShare(address User, uint256 Amount) public OnlyLiquidator {\r\n        RelaunchShares[User] += Amount;\r\n    }\r\n\r\n    function AddUserToCountAndParticipated(address User) public OnlyLiquidator {\r\n        if(!UserParticipated[User]){ TotalUsers++; UserParticipated[User] = true; }\r\n    }\r\n\r\n    //Only freemint contract\r\n    function Freeminted(address User, uint256 Amount) external {\r\n        require(msg.sender == FreemintContract, \"Only freemint contract can call this function\");\r\n        require(NFT_Freemints[User] > 0 && NFT_Freemints[User] >= Amount, \"User has no freemints or requested amount is too high\");\r\n\r\n        NFT_Freemints[User] -= Amount;\r\n    } \r\n\r\n    //Internal Functions\r\n    function AddRemoveActivePool(uint256 PoolID, bool AddRemove) internal {\r\n        if(AddRemove){\r\n            OpenPools.push(PoolID);\r\n            OpenPoolsIndexer[PoolID] = OpenPools.length - 1;\r\n        }\r\n        else{\r\n            OpenPools[OpenPoolsIndexer[PoolID]] = OpenPools[OpenPools.length - 1];\r\n            OpenPools.pop();\r\n        }\r\n    }\r\n\r\n    //View Functions\r\n    function GetOpenPools() public view returns (uint256[] memory){\r\n        return OpenPools;\r\n    }\r\n\r\n    function GetClosedPools() public view returns (uint256[] memory){\r\n        return ClosedPools;\r\n    }\r\n\r\n    function GetPoolDetails(uint256 PoolID) public view returns (RebirthPool memory){\r\n        return Pools[PoolID];\r\n    }\r\n\r\n    function GetUserPoolDetails(uint256 PoolID, address User) public view returns (UserPoolDetails memory){\r\n        return PoolDeposits[PoolID][User];\r\n    }\r\n\r\n    function GetUserPools(address User) public view returns (uint256[] memory){\r\n        return YourPools[User];\r\n    }\r\n\r\n    //Receive function\r\n    receive() external payable {\r\n    }\r\n}\r\n\r\n//This next contract needs to be able to accept any memecoin with any ethereum liquidity on uniswap, sell the ether, send to the rebirthcore superadmin address, then allow the user to claim once again one of the 3 available options\r\ncontract RebirthLiquidatorV2 {\r\n    address public RebirthCoreAddress;\r\n    IUniswapV2Router02 public uniswapRouter; \r\n    ERC20 public RBH;\r\n    uint256 public TotalEtherLiquidated;\r\n    uint256 public ReferalCut; //in bps (basis points)\r\n\r\n    mapping(address => mapping(address => UserRBHLiquidation)) public UserRBHLiquidations;\r\n    mapping(address => address[]) public AllUserLiquidations;\r\n    mapping(address => address) public Referrals;\r\n\r\n    struct UserRBHLiquidation{\r\n        uint256 RBHPayout;\r\n        uint256 ClaimTime;\r\n    }\r\n\r\n    enum AlternativePayoutOption { RBHTokens, NFTFreemints, RelaunchShares }\r\n\r\n    //superadmin modifier (call core for superadmin)\r\n    modifier onlySuperAdmin() {\r\n        require(msg.sender == RebirthProtocolCore(payable(RebirthCoreAddress)).RBH_SuperAdmin(), \"Only super admin can call this function\");\r\n        _;\r\n    }\r\n\r\n    constructor(address rebirthCoreAddress) {\r\n        RebirthCoreAddress = rebirthCoreAddress;\r\n        uniswapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        RBH = ERC20(RebirthProtocolCore(payable(RebirthCoreAddress)).RBH());\r\n    }\r\n\r\n    function LiquidateMultiple(address[] memory memecoins, uint256[] memory amounts, AlternativePayoutOption PayoutChoice) public {\r\n        require(memecoins.length == amounts.length, \"Arrays must be the same length\");\r\n        for(uint256 i = 0; i < memecoins.length; i++){\r\n            Liquidate(memecoins[i], amounts[i], PayoutChoice);\r\n        }\r\n    }\r\n\r\n    // Function to liquidate memecoins, and allow users to select which of the three options they want to claim\r\n    function Liquidate(address memecoinAddress, uint256 amount, AlternativePayoutOption PayoutChoice) public {\r\n        require(ERC20(uniswapRouter.WETH()).balanceOf(IUniswapV2Factory(uniswapRouter.factory()).getPair(memecoinAddress, uniswapRouter.WETH())) > 0, \"Pair doesn't exist or has no liquidity\");\r\n        require(ERC20(memecoinAddress).transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\r\n        require(UserRBHLiquidations[msg.sender][memecoinAddress].ClaimTime == 0, \"Await or claim existing liquidation on this token\");\r\n\r\n        RebirthProtocolCore(payable(RebirthCoreAddress)).AddUserToCountAndParticipated(msg.sender);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = memecoinAddress;\r\n        path[1] = uniswapRouter.WETH();\r\n\r\n        ERC20(memecoinAddress).approve(address(uniswapRouter), amount);\r\n        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(ERC20(memecoinAddress).balanceOf(address(this)), 0, path, address(this), block.timestamp + 300);\r\n        uint256 wETHIn = address(this).balance;\r\n        unchecked{\r\n            TotalEtherLiquidated += wETHIn;\r\n        }\r\n        payable(RebirthProtocolCore(payable(RebirthCoreAddress)).RBH_SuperAdmin()).transfer(address(this).balance);\r\n\r\n        //increase wethin by the refferal cut if the user has a refferal\r\n        if(Referrals[msg.sender] != address(0)){\r\n            wETHIn += (wETHIn * ReferalCut) / 10000;\r\n        }\r\n\r\n        //handle payout choice\r\n        if(PayoutChoice == AlternativePayoutOption.RBHTokens){\r\n            path[0] = uniswapRouter.WETH();\r\n            path[1] = address(RBH);\r\n\r\n            uint256 RBH_TradeAmount = uniswapRouter.getAmountsOut(wETHIn, path)[1];\r\n            UserRBHLiquidations[msg.sender][memecoinAddress].RBHPayout = (RBH_TradeAmount * 110) / 100;\r\n            UserRBHLiquidations[msg.sender][memecoinAddress].ClaimTime = block.timestamp + 604800;\r\n            AllUserLiquidations[msg.sender].push(memecoinAddress);\r\n        }\r\n        else if(PayoutChoice == AlternativePayoutOption.NFTFreemints){\r\n            RebirthProtocolCore(payable(RebirthCoreAddress)).AddFreemint(msg.sender, wETHIn / 10000000000000000);\r\n        }\r\n        else if(PayoutChoice == AlternativePayoutOption.RelaunchShares){\r\n            RebirthProtocolCore(payable(RebirthCoreAddress)).AddRelaunchShare(msg.sender, wETHIn / 1000000000000000);\r\n        }\r\n    }\r\n\r\n    //Function to claim RBH tokens from a liquidation\r\n    function ClaimRBH(address memecoinAddress) public {\r\n        require(UserRBHLiquidations[msg.sender][memecoinAddress].ClaimTime != 0, \"No liquidation to claim\");\r\n        require(UserRBHLiquidations[msg.sender][memecoinAddress].ClaimTime <= block.timestamp, \"Await liquidation to be claimable\");\r\n\r\n        //transferfrom rbh from rebirthcore \r\n        RBH.transferFrom(RebirthCoreAddress, msg.sender, UserRBHLiquidations[msg.sender][memecoinAddress].RBHPayout);\r\n        if(Referrals[msg.sender] != address(0)){\r\n            //set the payout fee amount to that of the rebirthcore liquidator refferal cut\r\n            RBH.transferFrom(RebirthCoreAddress, Referrals[msg.sender], (UserRBHLiquidations[msg.sender][memecoinAddress].RBHPayout * ReferalCut) / 10000);\r\n        }\r\n\r\n        UserRBHLiquidations[msg.sender][memecoinAddress].RBHPayout = 0;\r\n        UserRBHLiquidations[msg.sender][memecoinAddress].ClaimTime = 0;\r\n    }\r\n\r\n    //function to claim all liquidations for a user\r\n    function ClaimAll() external {\r\n        for(uint256 i = 0; i < AllUserLiquidations[msg.sender].length; i++){\r\n            if(UserRBHLiquidations[msg.sender][AllUserLiquidations[msg.sender][i]].ClaimTime <= block.timestamp){\r\n                ClaimRBH(AllUserLiquidations[msg.sender][i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    //function to set a refferal address for a user\r\n    function SetRefferal(address refferal) external {\r\n        require(Referrals[msg.sender] == address(0), \"Already has a refferal\");\r\n        Referrals[msg.sender] = refferal;\r\n    }\r\n\r\n    function GetUserLiquidations(address User) public view returns (address[] memory){\r\n        return AllUserLiquidations[User];\r\n    }\r\n\r\n    function CheckPayout(address memecoinAddress, uint256 amount, AlternativePayoutOption AltOption) public view returns (uint256){\r\n        address[] memory path = new address[](2);\r\n        path[0] = memecoinAddress;\r\n        path[1] = uniswapRouter.WETH();\r\n\r\n        uint256 wETHIn = uniswapRouter.getAmountsOut(amount, path)[1];\r\n    \r\n        if(AltOption == AlternativePayoutOption.RBHTokens){\r\n            if(Referrals[msg.sender] != address(0)){\r\n                wETHIn += (wETHIn * ReferalCut) / 10000;\r\n            }\r\n\r\n            path[0] = uniswapRouter.WETH();\r\n            path[1] = address(RBH);\r\n\r\n            uint256 RBH_TradeAmount = uniswapRouter.getAmountsOut(wETHIn, path)[1];\r\n            return (RBH_TradeAmount * 110) / 100;\r\n        }\r\n        else if(AltOption == AlternativePayoutOption.NFTFreemints){\r\n            return wETHIn / 10000000000000000;\r\n        }\r\n        else if(AltOption == AlternativePayoutOption.RelaunchShares){\r\n            return wETHIn / 1000000000000000;\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n\r\n    function GetUserLiquidationDetails(address User, address Memecoin) public view returns (UserRBHLiquidation memory){\r\n        return UserRBHLiquidations[User][Memecoin];\r\n    }\r\n\r\n    //only superadmin functions\r\n    function SetReferalCut(uint256 referalCut) external onlySuperAdmin {\r\n        ReferalCut = referalCut;\r\n    }\r\n\r\n\r\n    //receive function\r\n    receive() external payable {\r\n    }\r\n\r\n}\r\n\r\n\r\n//TODO: Update interfaces depending on existing contracts\r\n\r\ncontract RebirthedToken {\r\n    uint256 public tokenCap;\r\n    uint256 public totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    address private ZeroAddress;\r\n    //variable Declarations\r\n    \r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event BurnEvent(address indexed burner, uint256 indexed buramount);\r\n    event ManageMinterEvent(address indexed newminter);\r\n    //Event Declarations \r\n    \r\n    mapping(address => uint256) public balances;\r\n\r\n    mapping(address => mapping (address => uint256)) public allowance;\r\n    \r\n    constructor(uint256 _TokenCap, string memory _name, string memory _symbol){\r\n        tokenCap = _TokenCap;\r\n        totalSupply = 0;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = 18;\r\n        Mint(msg.sender, _TokenCap);\r\n    }\r\n    \r\n    function balanceOf(address Address) public view returns (uint256 balance){\r\n        return balances[Address];\r\n    }\r\n\r\n    function approve(address delegate, uint _amount) public returns (bool) {\r\n        allowance[msg.sender][delegate] = _amount;\r\n        emit Approval(msg.sender, delegate, _amount);\r\n        return true;\r\n    }\r\n    //Approves an address to spend your coins\r\n\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\r\n        require(_amount <= balances[_from]);    \r\n        require(_amount <= allowance[_from][msg.sender]);\r\n    \r\n        balances[_from] = balances[_from]-(_amount);\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender]-(_amount);\r\n        balances[_to] = balances[_to]+(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n    //Transfer From an other address\r\n\r\n\r\n    function transfer(address _to, uint256 _amount) public returns (bool) {\r\n        require(_amount <= balances[msg.sender]);\r\n        balances[msg.sender] = balances[msg.sender]-(_amount);\r\n        balances[_to] = balances[_to]+(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function Mint(address _MintTo, uint256 _MintAmount) internal {\r\n        require (totalSupply+(_MintAmount) <= tokenCap);\r\n        balances[_MintTo] = balances[_MintTo]+(_MintAmount);\r\n        totalSupply = totalSupply+(_MintAmount);\r\n        ZeroAddress = 0x0000000000000000000000000000000000000000;\r\n        emit Transfer(ZeroAddress ,_MintTo, _MintAmount);\r\n    } //Can only be used on deploy, view Internal \r\n\r\n\r\n    function Burn(uint256 _BurnAmount) public {\r\n        require (balances[msg.sender] >= _BurnAmount);\r\n        balances[msg.sender] = balances[msg.sender]-(_BurnAmount);\r\n        totalSupply = totalSupply-(_BurnAmount);\r\n        ZeroAddress = 0x0000000000000000000000000000000000000000;\r\n        emit Transfer(msg.sender, ZeroAddress, _BurnAmount);\r\n        emit BurnEvent(msg.sender, _BurnAmount);\r\n        \r\n    }\r\n\r\n}\r\n\r\ninterface ERC20 {\r\n  function balanceOf(address owner) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool); \r\n  function totalSupply() external view returns (uint);\r\n} \r\n\r\ninterface ERC721{\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router02{\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n     function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rebirthCoreAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"AllUserLiquidations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"memecoinAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum RebirthLiquidatorV2.AlternativePayoutOption\",\"name\":\"AltOption\",\"type\":\"uint8\"}],\"name\":\"CheckPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ClaimAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"memecoinAddress\",\"type\":\"address\"}],\"name\":\"ClaimRBH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"Memecoin\",\"type\":\"address\"}],\"name\":\"GetUserLiquidationDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"RBHPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ClaimTime\",\"type\":\"uint256\"}],\"internalType\":\"struct RebirthLiquidatorV2.UserRBHLiquidation\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"}],\"name\":\"GetUserLiquidations\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"memecoinAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum RebirthLiquidatorV2.AlternativePayoutOption\",\"name\":\"PayoutChoice\",\"type\":\"uint8\"}],\"name\":\"Liquidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"memecoins\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"enum RebirthLiquidatorV2.AlternativePayoutOption\",\"name\":\"PayoutChoice\",\"type\":\"uint8\"}],\"name\":\"LiquidateMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RBH\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RebirthCoreAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ReferalCut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Referrals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"referalCut\",\"type\":\"uint256\"}],\"name\":\"SetReferalCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"refferal\",\"type\":\"address\"}],\"name\":\"SetRefferal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalEtherLiquidated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UserRBHLiquidations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"RBHPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ClaimTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RebirthLiquidatorV2", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000006bfe28b41539c6825fb28368c39dea529a29152", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6d99fd111929df4c22f19ce45d6065c520de0f176cfeced01d859fe4c3bcbab7"}