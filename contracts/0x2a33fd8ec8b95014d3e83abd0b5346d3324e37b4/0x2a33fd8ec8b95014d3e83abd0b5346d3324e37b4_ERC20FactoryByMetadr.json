{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20Factory/ERC20/ERC20ByMetadrop.sol\": {\r\n      \"content\": \"// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&B&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&PG@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#YY#@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#J^.  5@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B?:   !@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&G7.   .@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&G!.      ?@@@@@@@@@@@@@@@@@@@@@@@@@@@&5~.      ~@@@@@@@@@@@@@@@@@@@@@@@@@@@#Y^.      .@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#Y^.         J@@@@@@@@@@@@@@@@@@@@@@@@B?:.         ~@@@@@@@@@@@@@@@@@@@@@@@&G7:          .@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&G7:             J@@@@@@@@@@@@@@@@@@@@&P!.             ~@@@@@@@@@@@@@@@@@@@@&5~.             .@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#Y~.                J@@@@@@@@@@@@@@@@@#J^.                ~@@@@@@@@@@@@@@@@@B?:                 .@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@B?:                    J@@@@@@@@@@@@@&P!.                    ~@@@@@@@@@@@@@&5~.                    .@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@&5~.                       ?@@@@@@@@@@#Y^.                       ^@@@@@@@@@@B?:.                       .@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@B?:.                          :#@@@@@&G7:                           .P@@@@@&P!.                           .@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@&P~.                               .~?Y?^.                                :~7!:.                              .@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@BJ^.                                                                                                             !@@@@@@@@@@@@\\n// @@@@@@@@@@@@B:                                                                                                               .J@@@@@@@@@@@@@\\n// @@@@@@@@@@@&.                                                                                                            .^J#@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@#                              .^JPPY^                               .~YBBG?.                              .!P&@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@#                           .!P&@@@@@@P                           :7G&@@@@@@&.                         .:?B@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@#                       .:JB@@@@@@@@@@@.                      .^Y#@@@@@@@@@@@^                      .~5&@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@#                    .~5&@@@@@@@@@@@@@@.                   .7G&@@@@@@@@@@@@@@^                   :?B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@#                 :?B@@@@@@@@@@@@@@@@@@.               .^J#@@@@@@@@@@@@@@@@@@^               .~5&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@#             .~5&@@@@@@@@@@@@@@@@@@@@@.            .!P&@@@@@@@@@@@@@@@@@@@@@^            :7G&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@#          :7G@@@@@@@@@@@@@@@@@@@@@@@@@.        .^JB@@@@@@@@@@@@@@@@@@@@@@@@@^        .^Y#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@#      .~Y#@@@@@@@@@@@@@@@@@@@@@@@@@@@@.     .!P&@@@@@@@@@@@@@@@@@@@@@@@@@@@@:     :7G&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@&.  :7G&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@~ .:?B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J..^Y#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@&B#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@#^~!^~@@@@@@7^!~^B@G^~^^^^^^^^&#^^^^^~~^^^^Y@@&~^!^~&@@@@@!^^^^^^^~7P&@@@!^^^^^^^^75&@@@@BJ~^::^~?G@@@@!^^^^^^^^7P@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@B  ?: ?@@@@5 .J  5@5  J#BBBBBB@@BBBB:  PBBB&@@^ .#. ^@@@@@. .BBBBGY: .5@@. .BBBBBP. .&@B: :JG##BY^ .5@@. .BBBBBP. .&@@@@@@@@@@@@\\n// @@@@@@@@@@@@B  Y#  B@@&. PG  P@5  JBBBBBB@@@@@@@! .&@@@@@! .#@#. !@@@@. ^@@@@@@@7  B@: :@@@@@&^ .&&. ~@@@@@@@@J  G@: :@@@@@@~  &@@@@@@@@@@@@\\n// @@@@@@@@@@@@B  J@? :@@~ ~@G  P@5  ^!~~~~!@@@@@@@~ .&@@@@?  ?&&&?  ?@@@. ^@@@@@@@5  G@: .::::. ^Y@@B  J@@@@@@@@G  Y@: .:::::.:!#@@@@@@@@@@@@@\\n// @@@@@@@@@@@@B  J@@: YG .&@P  P@5  G@@@@@@@@@@@@@~ .&@@@Y  :^^^^^:  Y@@. ^@@@@@&5. ^@@. :&&&&&? .5@@7  J&@@@@&P. ^@@: :&&&&&@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@B  J@@B .: 5@@P  P@5  .:::::::#@@@@@~ .&@@G  ~@@@@@@@~  G@. .:::::..~P@@@: ^@@@@@@~  G@@B!..::::..~G@@@: :@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@@&&@@@@&&&&@@@@&&@@@&&&#######@@@@@@&&&@@@&&&@@@@@@@@@&&&@&&&####&&@@@@@@&&&@@@@@@@&&&@@@@@&####&@@@@@@&&&@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@                                                                                                                                        @@\\n// @@   This token was launched using software provided by Metadrop.                                                                         @@\\n// @@   Metadrop is a platform that provides software that creators can use to launch coins and NFTs efficiently.                            @@\\n// @@                                                                                                                                        @@\\n// @@   Metadrop has no affiliation with and does not endorse this token or its creators in any way, unless otherwise stated by Metadrop.    @@\\n// @@                                                                                                                                        @@\\n// @@   To learn more or to launch your own token, visit: https://metadrop.com                                                               @@\\n// @@                                                                                                                                        @@\\n// @@   For all terms and conditions associated with tokens launched using Metadrop software products, please refer to                       @@\\n// @@   Metadrop's Terms of Use published on its website at https://metadrop.com/legal                                                       @@\\n// @@                                                                                                                                        @@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n// @@                                                                                                                                        @@\\n// @@   To view this token project's official links:                                                                                         @@\\n// @@                                                                                                                                        @@\\n// @@   Step 1) On Etherscan, under the 'Contract' tab, click 'Read Contract'.                                                               @@\\n// @@                                                                                                                                        @@\\n// @@   Step 2) Select one of the following read functions to view the official link:                                                        @@\\n// @@                                                                                                                                        @@\\n// @@       * _1___website                                                                                                                   @@\\n// @@       * _2___twitter (or X...)                                                                                                         @@\\n// @@       * _3___telegram                                                                                                                  @@\\n// @@       * _4___discord                                                                                                                   @@\\n// @@                                                                                                                                        @@\\n// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n\\n// SPDX-License-Identifier: BUSL-1.1\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.21;\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {ERC20Spendable} from \\\"../../ThirdParty/omnus/ERC20Spendable/ERC20Spendable.sol\\\";\\nimport {IERC20ByMetadrop} from \\\"./IERC20ByMetadrop.sol\\\";\\nimport {IERC20FactoryByMetadrop} from \\\"../ERC20Factory/IERC20FactoryByMetadrop.sol\\\";\\nimport {IUniswapV2Factory} from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport {IUniswapV2Locker} from \\\"../../ThirdParty/Unicrypt/IUniswapV2Locker.sol\\\";\\nimport {IUniswapV2Router02} from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport {IWETH} from \\\"../../ThirdParty/WETH/IWETH.sol\\\";\\nimport {Manager2Step} from \\\"../../Global/Manager2Step.sol\\\";\\nimport {Ownable2Step} from \\\"../../Global/OZ/Ownable2Step.sol\\\";\\nimport {Revert} from \\\"../../Global/Revert.sol\\\";\\nimport {SafeERC20, IERC20} from \\\"../../Global/OZ/SafeERC20.sol\\\";\\n\\n/**\\n * @dev Metadrop core ERC-20 contract\\n *\\n * @dev Implementation of the {IERC20} interface.\\n *\\n */\\ncontract ERC20ByMetadrop is\\n  Context,\\n  ERC20Spendable,\\n  IERC20ByMetadrop,\\n  Ownable2Step,\\n  Manager2Step\\n{\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n  using SafeERC20 for IERC20;\\n\\n  uint256 public constant x_VERSION = 100020001000000000;\\n  uint256 internal constant BP_DENOM = 10000;\\n  uint256 internal constant ROUND_DEC = 100000000000;\\n  uint256 internal constant CALL_GAS_LIMIT = 50000;\\n  uint256 internal constant MAX_SWAP_THRESHOLD_MULTIPLE = 20;\\n  bytes32 internal constant GNOSIS_SAFE_PROXY =\\n    0xb89c1b3bdf2cf8827818646bce9a8f6e372885f8c55e5c07acbd307cb133b000;\\n\\n  uint256 public immutable lpSupply;\\n  uint256 public immutable projectSupply;\\n  uint256 public immutable maxTokensPerTransaction;\\n  uint256 public immutable maxTokensPerWallet;\\n  uint256 public immutable maxProjectBuyTaxBasisPoints;\\n  uint256 public immutable maxProjectSellTaxBasisPoints;\\n  uint256 public immutable maxMetadropBuyTaxBasisPoints;\\n  uint256 public immutable maxMetadropSellTaxBasisPoints;\\n  uint256 public immutable botProtectionDurationInSeconds;\\n  address public immutable metadropTaxRecipient;\\n  address public immutable uniswapV2Pair;\\n  address public immutable driPool;\\n  address public immutable lpOwner;\\n  address public immutable projectSupplyRecipient;\\n  address internal immutable _metadropFactory;\\n  uint256 internal immutable _metadropTaxPeriodInDays;\\n  bool internal immutable _tokenHasTax;\\n  IUniswapV2Locker internal immutable _unicryptLocker;\\n  IUniswapV2Router02 internal immutable _uniswapRouter;\\n\\n  /** @dev {Storage Slot 1} Vars read as part of transfers packed to a single\\n   * slot for warm reads.\\n   *   Slot 1:\\n   *      128\\n   *       32\\n   *   16 * 5\\n   *    8 * 2\\n   *   ------\\n   *      256\\n   *   ------ */\\n  uint128 private _totalSupply;\\n  uint32 public fundedDate;\\n  uint16 public projectBuyTaxBasisPoints;\\n  uint16 public projectSellTaxBasisPoints;\\n  uint16 public metadropBuyTaxBasisPoints;\\n  uint16 public metadropSellTaxBasisPoints;\\n  uint16 public swapThresholdBasisPoints;\\n  /** @dev {_autoSwapInProgress} We start with {_autoSwapInProgress} ON, as we don't want to\\n   * call autoswap when processing initial liquidity from this address. We turn this OFF when\\n   * liquidity has been loaded, and use this bool to control processing during auto-swaps\\n   * from that point onwards. */\\n  bool private _autoSwapInProgress = true;\\n\\n  /** @dev {Storage Slot 2} Not read / written in transfers (unless autoswap taking place):\\n   *      160\\n   *       96\\n   *   ------\\n   *      256\\n   *   ------ */\\n  address public projectTaxRecipient;\\n  uint96 public lpLockupInDays;\\n\\n  /** @dev {Storage Slot 3} Potentially written in transfers:\\n   *   Slot 3:\\n   *      128\\n   *      128\\n   *   ------\\n   *      256\\n   *   ------ */\\n  uint128 public projectTaxPendingSwap;\\n  uint128 public metadropTaxPendingSwap;\\n\\n  /** @dev {Storage Slot 4 to n} Not read as part of transfers etc. */\\n  string private _name;\\n  string private _symbol;\\n\\n  /** @dev {Social Links} internal storage, prefixed with chars in external functions */\\n  string internal _websiteLink;\\n  string internal _twitterLink;\\n  string internal _telegramLink;\\n  string internal _discordLink;\\n\\n  /** @dev {_balances} Addresses balances */\\n  mapping(address => uint256) private _balances;\\n\\n  /** @dev {_allowances} Addresses allocance details */\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  /** @dev {_validCallerCodeHashes} Code hashes of callers we consider valid */\\n  EnumerableSet.Bytes32Set private _validCallerCodeHashes;\\n\\n  /** @dev {_liquidityPools} Enumerable set for liquidity pool addresses */\\n  EnumerableSet.AddressSet private _liquidityPools;\\n\\n  /** @dev {_unlimited} Enumerable set for addresses where limits do not apply */\\n  EnumerableSet.AddressSet private _unlimited;\\n\\n  /**\\n   * @dev {constructor}\\n   *\\n   * @param integrationAddresses_ The project owner, uniswap router, unicrypt locker, metadrop factory and pool template.\\n   * @param baseParams_ configuration of this ERC20.\\n   * @param supplyParams_ Supply configuration of this ERC20.\\n   * @param taxParams_  Tax configuration of this ERC20\\n   * @param taxParams_  Launch pool configuration of this ERC20\\n   */\\n  constructor(\\n    address[5] memory integrationAddresses_,\\n    bytes memory baseParams_,\\n    bytes memory supplyParams_,\\n    bytes memory taxParams_,\\n    bytes memory poolParams_\\n  ) {\\n    _decodeBaseParams(integrationAddresses_[0], baseParams_);\\n    _uniswapRouter = IUniswapV2Router02(integrationAddresses_[1]);\\n    _unicryptLocker = IUniswapV2Locker(integrationAddresses_[2]);\\n    _metadropFactory = (integrationAddresses_[3]);\\n\\n    ERC20SupplyParameters memory supplyParams = abi.decode(\\n      supplyParams_,\\n      (ERC20SupplyParameters)\\n    );\\n\\n    ERC20TaxParameters memory taxParams = abi.decode(\\n      taxParams_,\\n      (ERC20TaxParameters)\\n    );\\n\\n    driPool = integrationAddresses_[4];\\n\\n    ERC20PoolParameters memory poolParams;\\n\\n    if (integrationAddresses_[4] != address(0)) {\\n      poolParams = abi.decode(poolParams_, (ERC20PoolParameters));\\n    }\\n\\n    _processSupplyParams(supplyParams, poolParams);\\n    projectSupplyRecipient = supplyParams.projectSupplyRecipient;\\n    lpSupply = supplyParams.lpSupply * (10 ** decimals());\\n    projectSupply = supplyParams.projectSupply * (10 ** decimals());\\n    maxTokensPerWallet = supplyParams.maxTokensPerWallet * (10 ** decimals());\\n    maxTokensPerTransaction = supplyParams.maxTokensPerTxn * (10 ** decimals());\\n    lpLockupInDays = uint96(supplyParams.lpLockupInDays);\\n    botProtectionDurationInSeconds = supplyParams\\n      .botProtectionDurationInSeconds;\\n    lpOwner = supplyParams.projectLPOwner;\\n\\n    _tokenHasTax = _processTaxParams(taxParams);\\n    maxProjectBuyTaxBasisPoints = taxParams.maxProjectBuyTaxBasisPoints;\\n    maxProjectSellTaxBasisPoints = taxParams.maxProjectSellTaxBasisPoints;\\n    maxMetadropBuyTaxBasisPoints = taxParams.maxMetadropBuyTaxBasisPoints;\\n    maxMetadropSellTaxBasisPoints = taxParams.maxMetadropSellTaxBasisPoints;\\n    _metadropTaxPeriodInDays = taxParams.metadropTaxPeriodInDays;\\n    swapThresholdBasisPoints = uint16(taxParams.taxSwapThresholdBasisPoints);\\n    projectTaxRecipient = taxParams.projectTaxRecipient;\\n    metadropTaxRecipient = taxParams.metadropTaxRecipient;\\n\\n    _mintBalances(\\n      lpSupply,\\n      projectSupply,\\n      poolParams.poolSupply * (10 ** decimals())\\n    );\\n\\n    uniswapV2Pair = _createPair();\\n  }\\n\\n  /**\\n   * @dev {onlyOwnerFactoryOrPool}\\n   *\\n   * Throws if called by any account other than the owner, factory or pool.\\n   */\\n  modifier onlyOwnerFactoryOrPool() {\\n    if (\\n      _metadropFactory != _msgSender() &&\\n      owner() != _msgSender() &&\\n      driPool != _msgSender()\\n    ) {\\n      _revert(CallerIsNotFactoryProjectOwnerOrPool.selector);\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @dev function {_1___website}\\n   *\\n   * Returns the stored website address, with prefixed chars\\n   *\\n   * @return string The website address\\n   */\\n  function _1___website() external view returns (string memory) {\\n    return string.concat(\\\"https://\\\", _websiteLink);\\n  }\\n\\n  /**\\n   * @dev function {_2___twitter}\\n   *\\n   * Returns the stored twitter address, with prefixed chars\\n   *\\n   * @return string The twitter address\\n   */\\n  function _2___twitter() external view returns (string memory) {\\n    return string.concat(\\\"twitter.com/\\\", _twitterLink);\\n  }\\n\\n  /**\\n   * @dev function {_3___telegram}\\n   *\\n   * Returns the stored telegram address, with prefixed chars\\n   *\\n   * @return string The telegram address\\n   */\\n  function _3___telegram() external view returns (string memory) {\\n    return string.concat(\\\"t.me/\\\", _telegramLink);\\n  }\\n\\n  /**\\n   * @dev function {_4___discord}\\n   *\\n   * Returns the stored discord address, with prefixed chars\\n   *\\n   * @return string The discord address\\n   */\\n  function _4___discord() external view returns (string memory) {\\n    return string.concat(\\\"discord.gg/\\\", _discordLink);\\n  }\\n\\n  /**\\n   * @dev function {_decodeBaseParams}\\n   *\\n   * Decode NFT Parameters\\n   *\\n   * @param projectOwner_ The owner of this contract\\n   * @param encodedBaseParams_ The base params encoded into a bytes array\\n   */\\n  function _decodeBaseParams(\\n    address projectOwner_,\\n    bytes memory encodedBaseParams_\\n  ) internal {\\n    _transferOwnership(projectOwner_);\\n    _transferManager(projectOwner_);\\n\\n    (\\n      _name,\\n      _symbol,\\n      _websiteLink,\\n      _twitterLink,\\n      _telegramLink,\\n      _discordLink\\n    ) = abi.decode(\\n      encodedBaseParams_,\\n      (string, string, string, string, string, string)\\n    );\\n  }\\n\\n  /**\\n   * @dev function {_processSupplyParams}\\n   *\\n   * Process provided supply params\\n   *\\n   * @param erc20SupplyParameters_ The supply params\\n   * @param erc20PoolParameters_ The pool params\\n   */\\n  function _processSupplyParams(\\n    ERC20SupplyParameters memory erc20SupplyParameters_,\\n    ERC20PoolParameters memory erc20PoolParameters_\\n  ) internal {\\n    if (\\n      erc20SupplyParameters_.maxSupply !=\\n      (erc20SupplyParameters_.lpSupply +\\n        erc20SupplyParameters_.projectSupply +\\n        erc20PoolParameters_.poolSupply)\\n    ) {\\n      _revert(SupplyTotalMismatch.selector);\\n    }\\n\\n    if (erc20SupplyParameters_.maxSupply > type(uint128).max) {\\n      _revert(MaxSupplyTooHigh.selector);\\n    }\\n\\n    if (erc20SupplyParameters_.lpLockupInDays > type(uint96).max) {\\n      _revert(LPLockUpMustFitUint96.selector);\\n    }\\n\\n    _unlimited.add(erc20SupplyParameters_.projectSupplyRecipient);\\n    _unlimited.add(address(this));\\n    _unlimited.add(address(0));\\n  }\\n\\n  /**\\n   * @dev function {_processTaxParams}\\n   *\\n   * Process provided tax params\\n   *\\n   * @param erc20TaxParameters_ The tax params\\n   */\\n  function _processTaxParams(\\n    ERC20TaxParameters memory erc20TaxParameters_\\n  ) internal returns (bool tokenHasTax_) {\\n    /**\\n     * @dev We use the immutable var {_tokenHasTax} to avoid unneccesary storage writes and reads. If this\\n     * token does NOT have tax applied then there is no need to store or read these parameters, and we can\\n     * avoid this simply by checking the immutable var. Pass back the value for this var from this method.\\n     */\\n    if (\\n      erc20TaxParameters_.projectBuyTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.projectSellTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.metadropBuyTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.metadropSellTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.maxProjectBuyTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.maxProjectSellTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.maxMetadropBuyTaxBasisPoints == 0 &&\\n      erc20TaxParameters_.maxMetadropSellTaxBasisPoints == 0\\n    ) {\\n      return false;\\n    } else {\\n      projectBuyTaxBasisPoints = uint16(\\n        erc20TaxParameters_.projectBuyTaxBasisPoints\\n      );\\n      projectSellTaxBasisPoints = uint16(\\n        erc20TaxParameters_.projectSellTaxBasisPoints\\n      );\\n      metadropBuyTaxBasisPoints = uint16(\\n        erc20TaxParameters_.metadropBuyTaxBasisPoints\\n      );\\n      metadropSellTaxBasisPoints = uint16(\\n        erc20TaxParameters_.metadropSellTaxBasisPoints\\n      );\\n      return true;\\n    }\\n  }\\n\\n  /**\\n   * @dev function {_mintBalances}\\n   *\\n   * Mint initial balances\\n   *\\n   * @param lpMint_ The number of tokens for liquidity\\n   * @param projectMint_ The number of tokens for the project treasury\\n   * @param poolMint_ The number of tokens for the launch pool\\n   */\\n  function _mintBalances(\\n    uint256 lpMint_,\\n    uint256 projectMint_,\\n    uint256 poolMint_\\n  ) internal {\\n    if (lpMint_ > 0) {\\n      _mint(address(this), lpMint_);\\n    }\\n\\n    if (projectMint_ > 0) {\\n      _mint(projectSupplyRecipient, projectMint_);\\n    }\\n\\n    if (poolMint_ > 0) {\\n      _mint(driPool, poolMint_);\\n    }\\n  }\\n\\n  /**\\n   * @dev function {_createPair}\\n   *\\n   * Create the uniswap pair\\n   *\\n   * @return uniswapV2Pair_ The pair address\\n   */\\n  function _createPair() internal returns (address uniswapV2Pair_) {\\n    if (_totalSupply > 0) {\\n      uniswapV2Pair_ = IUniswapV2Factory(_uniswapRouter.factory()).createPair(\\n        address(this),\\n        _uniswapRouter.WETH()\\n      );\\n\\n      _liquidityPools.add(uniswapV2Pair_);\\n      emit LiquidityPoolCreated(uniswapV2Pair_);\\n    }\\n    _unlimited.add(address(_uniswapRouter));\\n    _unlimited.add(uniswapV2Pair_);\\n    return (uniswapV2Pair_);\\n  }\\n\\n  /**\\n   * @dev function {addInitialLiquidity}\\n   *\\n   * Add initial liquidity to the uniswap pair\\n   *\\n   * @param lockerFee_ The locker fee in wei. This must match the required fee from the external locker contract.\\n   * @param lpLockupInDays_ The number of days to lock liquidity NOTE you can pass 0 to use the stored immutable value.\\n   */\\n  function addInitialLiquidity(\\n    uint256 lockerFee_,\\n    uint256 lpLockupInDays_\\n  ) external payable onlyOwnerFactoryOrPool {\\n    if (lockerFee_ >= msg.value) {\\n      // The amount of ETH MUST exceed the locker fee, otherwise what liquidity are we adding?\\n      _revert(NoETHForLiquidityPair.selector);\\n    }\\n\\n    if (lpLockupInDays_ > lpLockupInDays) {\\n      lpLockupInDays = uint96(lpLockupInDays_);\\n    }\\n\\n    _addInitialLiquidity((msg.value - lockerFee_), lockerFee_);\\n  }\\n\\n  /**\\n   * @dev function {_addInitialLiquidity}\\n   *\\n   * Add initial liquidity to the uniswap pair (internal function that does processing)\\n   *\\n   * @param ethAmount_ The amount of ETH passed into the call\\n   * @param lockerFee_ The locker fee in wei. This must match the required fee from the external locker contract.\\n   */\\n  function _addInitialLiquidity(\\n    uint256 ethAmount_,\\n    uint256 lockerFee_\\n  ) internal {\\n    // Funded date is the date of first funding. We can only add initial liquidity once. If this date is set,\\n    // we cannot proceed\\n    if (fundedDate != 0) {\\n      _revert(InitialLiquidityAlreadyAdded.selector);\\n    }\\n\\n    fundedDate = uint32(block.timestamp);\\n\\n    // Can only do this if this contract holds tokens:\\n    if (balanceOf(address(this)) == 0) {\\n      _revert(NoTokenForLiquidityPair.selector);\\n    }\\n\\n    // Approve the uniswap router for an inifinite amount (max uint256)\\n    // This means that we don't need to worry about later incrememtal\\n    // approvals on tax swaps, as the uniswap router allowance will never\\n    // be decreased (see code in decreaseAllowance for reference)\\n    _approve(address(this), address(_uniswapRouter), type(uint256).max);\\n\\n    // Add the liquidity:\\n    (uint256 amountA, uint256 amountB, uint256 lpTokens) = _uniswapRouter\\n      .addLiquidityETH{value: ethAmount_}(\\n      address(this),\\n      balanceOf(address(this)),\\n      0,\\n      0,\\n      address(this),\\n      block.timestamp\\n    );\\n\\n    emit InitialLiquidityAdded(amountA, amountB, lpTokens);\\n\\n    // We now set this to false so that future transactions can be eligibile for autoswaps\\n    _autoSwapInProgress = false;\\n\\n    // Lock the liqidity:\\n    _lockInitialLiquidity(lockerFee_, lpTokens);\\n  }\\n\\n  /**\\n   * @dev function {_lockInitialLiquidity}\\n   *\\n   * Lock initial liquidity on locker contract\\n   *\\n   * @param lockerFee_ The locker fee in wei. This must match the required fee from the external locker contract.\\n   * @param lpTokens_ The amount of LP tokens to be locked\\n   */\\n  function _lockInitialLiquidity(\\n    uint256 lockerFee_,\\n    uint256 lpTokens_\\n  ) internal {\\n    IERC20(uniswapV2Pair).approve(address(_unicryptLocker), lpTokens_);\\n\\n    _unicryptLocker.lockLPToken{value: lockerFee_}(\\n      uniswapV2Pair,\\n      IERC20(uniswapV2Pair).balanceOf(address(this)),\\n      block.timestamp + (lpLockupInDays * 1 days),\\n      payable(address(0)),\\n      true,\\n      payable(lpOwner)\\n    );\\n\\n    emit LiquidityLocked(lpLockupInDays);\\n  }\\n\\n  /**\\n   * @dev function {updateLinks} onlyManager\\n   *\\n   * Allows the owner to update links\\n   *\\n   * @param linkHasChanged_ a bool array, set to true where the corresponding link has been updated\\n   * @param links_ a string array, holds updated links\\n   */\\n  function updateLinks(\\n    bool[4] memory linkHasChanged_,\\n    string[4] memory links_\\n  ) external onlyManager {\\n    if (linkHasChanged_[0]) {\\n      _websiteLink = links_[0];\\n    }\\n\\n    if (linkHasChanged_[1]) {\\n      _twitterLink = links_[1];\\n    }\\n\\n    if (linkHasChanged_[2]) {\\n      _telegramLink = links_[2];\\n    }\\n\\n    if (linkHasChanged_[3]) {\\n      _discordLink = links_[3];\\n    }\\n\\n    emit LinksUpdated();\\n  }\\n\\n  /**\\n   * @dev function {isLiquidityPool}\\n   *\\n   * Return if an address is a liquidity pool\\n   *\\n   * @param queryAddress_ The address being queried\\n   * @return bool The address is / isn't a liquidity pool\\n   */\\n  function isLiquidityPool(address queryAddress_) public view returns (bool) {\\n    /** @dev We check the uniswapV2Pair address first as this is an immutable variable and therefore does not need\\n     * to be fetched from storage, saving gas if this address IS the uniswapV2Pool. We also add this address\\n     * to the enumerated set for ease of reference (for example it is returned in the getter), and it does\\n     * not add gas to any other calls, that still complete in 0(1) time.\\n     */\\n    return (queryAddress_ == uniswapV2Pair ||\\n      _liquidityPools.contains(queryAddress_));\\n  }\\n\\n  /**\\n   * @dev function {liquidityPools}\\n   *\\n   * Returns a list of all liquidity pools\\n   *\\n   * @return liquidityPools_ a list of all liquidity pools\\n   */\\n  function liquidityPools()\\n    external\\n    view\\n    returns (address[] memory liquidityPools_)\\n  {\\n    return (_liquidityPools.values());\\n  }\\n\\n  /**\\n   * @dev function {addLiquidityPool} onlyManager\\n   *\\n   * Allows the manager to add a liquidity pool to the pool enumerable set\\n   *\\n   * @param newLiquidityPool_ The address of the new liquidity pool\\n   */\\n  function addLiquidityPool(address newLiquidityPool_) public onlyManager {\\n    // Don't allow calls that didn't pass an address:\\n    if (newLiquidityPool_ == address(0)) {\\n      _revert(LiquidityPoolCannotBeAddressZero.selector);\\n    }\\n    // Only allow smart contract addresses to be added, as only these can be pools:\\n    if (newLiquidityPool_.code.length == 0) {\\n      _revert(LiquidityPoolMustBeAContractAddress.selector);\\n    }\\n    // Add this to the enumerated list:\\n    _liquidityPools.add(newLiquidityPool_);\\n    emit LiquidityPoolAdded(newLiquidityPool_);\\n  }\\n\\n  /**\\n   * @dev function {removeLiquidityPool} onlyManager\\n   *\\n   * Allows the manager to remove a liquidity pool\\n   *\\n   * @param removedLiquidityPool_ The address of the old removed liquidity pool\\n   */\\n  function removeLiquidityPool(\\n    address removedLiquidityPool_\\n  ) external onlyManager {\\n    // Remove this from the enumerated list:\\n    _liquidityPools.remove(removedLiquidityPool_);\\n    emit LiquidityPoolRemoved(removedLiquidityPool_);\\n  }\\n\\n  /**\\n   * @dev function {isUnlimited}\\n   *\\n   * Return if an address is unlimited (is not subject to per txn and per wallet limits)\\n   *\\n   * @param queryAddress_ The address being queried\\n   * @return bool The address is / isn't unlimited\\n   */\\n  function isUnlimited(address queryAddress_) public view returns (bool) {\\n    return (_unlimited.contains(queryAddress_));\\n  }\\n\\n  /**\\n   * @dev function {unlimitedAddresses}\\n   *\\n   * Returns a list of all unlimited addresses\\n   *\\n   * @return unlimitedAddresses_ a list of all unlimited addresses\\n   */\\n  function unlimitedAddresses()\\n    external\\n    view\\n    returns (address[] memory unlimitedAddresses_)\\n  {\\n    return (_unlimited.values());\\n  }\\n\\n  /**\\n   * @dev function {addUnlimited} onlyManager\\n   *\\n   * Allows the manager to add an unlimited address\\n   *\\n   * @param newUnlimited_ The address of the new unlimited address\\n   */\\n  function addUnlimited(address newUnlimited_) external onlyManager {\\n    // Add this to the enumerated list:\\n    _unlimited.add(newUnlimited_);\\n    emit UnlimitedAddressAdded(newUnlimited_);\\n  }\\n\\n  /**\\n   * @dev function {removeUnlimited} onlyManager\\n   *\\n   * Allows the manager to remove an unlimited address\\n   *\\n   * @param removedUnlimited_ The address of the old removed unlimited address\\n   */\\n  function removeUnlimited(address removedUnlimited_) external onlyManager {\\n    // Remove this from the enumerated list:\\n    _unlimited.remove(removedUnlimited_);\\n    emit UnlimitedAddressRemoved(removedUnlimited_);\\n  }\\n\\n  /**\\n   * @dev function {isValidCaller}\\n   *\\n   * Return if an address is a valid caller\\n   *\\n   * @param queryHash_ The code hash being queried\\n   * @return bool The address is / isn't a valid caller\\n   */\\n  function isValidCaller(bytes32 queryHash_) public view returns (bool) {\\n    return (_validCallerCodeHashes.contains(queryHash_));\\n  }\\n\\n  /**\\n   * @dev function {validCallers}\\n   *\\n   * Returns a list of all valid caller code hashes\\n   *\\n   * @return validCallerHashes_ a list of all valid caller code hashes\\n   */\\n  function validCallers()\\n    external\\n    view\\n    returns (bytes32[] memory validCallerHashes_)\\n  {\\n    return (_validCallerCodeHashes.values());\\n  }\\n\\n  /**\\n   * @dev function {addValidCaller} onlyOwner\\n   *\\n   * Allows the owner to add the hash of a valid caller\\n   *\\n   * @param newValidCallerHash_ The hash of the new valid caller\\n   */\\n  function addValidCaller(bytes32 newValidCallerHash_) external onlyOwner {\\n    _validCallerCodeHashes.add(newValidCallerHash_);\\n    emit ValidCallerAdded(newValidCallerHash_);\\n  }\\n\\n  /**\\n   * @dev function {removeValidCaller} onlyOwner\\n   *\\n   * Allows the owner to remove a valid caller\\n   *\\n   * @param removedValidCallerHash_ The hash of the old removed valid caller\\n   */\\n  function removeValidCaller(\\n    bytes32 removedValidCallerHash_\\n  ) external onlyOwner {\\n    // Remove this from the enumerated list:\\n    _validCallerCodeHashes.remove(removedValidCallerHash_);\\n    emit ValidCallerRemoved(removedValidCallerHash_);\\n  }\\n\\n  /**\\n   * @dev function {setProjectTaxRecipient} onlyManager\\n   *\\n   * Allows the manager to set the project tax recipient address\\n   *\\n   * @param projectTaxRecipient_ New recipient address\\n   */\\n  function setProjectTaxRecipient(\\n    address projectTaxRecipient_\\n  ) external onlyManager {\\n    projectTaxRecipient = projectTaxRecipient_;\\n    emit ProjectTaxRecipientUpdated(projectTaxRecipient_);\\n  }\\n\\n  /**\\n   * @dev function {setSwapThresholdBasisPoints} onlyManager\\n   *\\n   * Allows the manager to set the autoswap threshold\\n   *\\n   * @param swapThresholdBasisPoints_ New swap threshold in basis points\\n   */\\n  function setSwapThresholdBasisPoints(\\n    uint16 swapThresholdBasisPoints_\\n  ) external onlyManager {\\n    uint256 oldswapThresholdBasisPoints = swapThresholdBasisPoints;\\n    swapThresholdBasisPoints = swapThresholdBasisPoints_;\\n    emit AutoSwapThresholdUpdated(\\n      oldswapThresholdBasisPoints,\\n      swapThresholdBasisPoints_\\n    );\\n  }\\n\\n  /**\\n   * @dev function {setProjectTaxRates} onlyManager\\n   *\\n   * Change the tax rates, subject to max rate\\n   *\\n   * @param newProjectBuyTaxBasisPoints_ The new buy tax rate\\n   * @param newProjectSellTaxBasisPoints_ The new sell tax rate\\n   */\\n  function setProjectTaxRates(\\n    uint16 newProjectBuyTaxBasisPoints_,\\n    uint16 newProjectSellTaxBasisPoints_\\n  ) external onlyManager {\\n    // Cannot increase above the maximum:\\n    if (newProjectBuyTaxBasisPoints_ > maxProjectBuyTaxBasisPoints) {\\n      _revert(NewBuyTaxBasisPointsExceedsMaximum.selector);\\n    }\\n    // Cannot increase above the maximum:\\n    if (newProjectSellTaxBasisPoints_ > maxProjectSellTaxBasisPoints) {\\n      _revert(NewSellTaxBasisPointsExceedsMaximum.selector);\\n    }\\n\\n    uint16 oldBuyTaxBasisPoints = projectBuyTaxBasisPoints;\\n    projectBuyTaxBasisPoints = newProjectBuyTaxBasisPoints_;\\n\\n    uint16 oldSellTaxBasisPoints = projectSellTaxBasisPoints;\\n    projectSellTaxBasisPoints = newProjectSellTaxBasisPoints_;\\n\\n    emit ProjectTaxBasisPointsChanged(\\n      oldBuyTaxBasisPoints,\\n      newProjectBuyTaxBasisPoints_,\\n      oldSellTaxBasisPoints,\\n      newProjectSellTaxBasisPoints_\\n    );\\n  }\\n\\n  /**\\n   * @dev function {setMetadropTaxRates} onlyManager\\n   *\\n   * Change the tax rates, subject to max rate and minimum tax period.\\n   *\\n   * @param newMetadropBuyTaxBasisPoints_ The new buy tax rate\\n   * @param newMetadropSellTaxBasisPoints_ The new sell tax rate\\n   */\\n  function setMetadropTaxRates(\\n    uint16 newMetadropBuyTaxBasisPoints_,\\n    uint16 newMetadropSellTaxBasisPoints_\\n  ) external onlyManager {\\n    // Cannot increase above the maximum:\\n    if (newMetadropBuyTaxBasisPoints_ > maxMetadropBuyTaxBasisPoints) {\\n      _revert(NewBuyTaxBasisPointsExceedsMaximum.selector);\\n    }\\n\\n    // Cannot increase above the maximum:\\n    if (newMetadropSellTaxBasisPoints_ > maxMetadropSellTaxBasisPoints) {\\n      _revert(NewSellTaxBasisPointsExceedsMaximum.selector);\\n    }\\n\\n    // Reducing the basis points can only occur after the tax period:\\n    if (\\n      (newMetadropBuyTaxBasisPoints_ < metadropBuyTaxBasisPoints ||\\n        newMetadropSellTaxBasisPoints_ < metadropSellTaxBasisPoints) &&\\n      block.timestamp < (fundedDate + (_metadropTaxPeriodInDays * 1 days))\\n    ) {\\n      _revert(TaxPeriodStillInForce.selector);\\n    }\\n\\n    uint16 oldBuyTaxBasisPoints = metadropBuyTaxBasisPoints;\\n    uint16 oldSellTaxBasisPoints = metadropSellTaxBasisPoints;\\n\\n    metadropBuyTaxBasisPoints = newMetadropBuyTaxBasisPoints_;\\n    metadropSellTaxBasisPoints = newMetadropSellTaxBasisPoints_;\\n\\n    emit MetadropTaxBasisPointsChanged(\\n      oldBuyTaxBasisPoints,\\n      newMetadropBuyTaxBasisPoints_,\\n      oldSellTaxBasisPoints,\\n      newMetadropSellTaxBasisPoints_\\n    );\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\n   * name.\\n   */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used to get its user representation.\\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n   *\\n   * Tokens usually opt for a value of 18, imitating the relationship between\\n   * Ether and Wei. This is the default value returned by this function, unless\\n   * it's overridden.\\n   *\\n   * NOTE: This information is only used for _display_ purposes: it in\\n   * no way affects any of the arithmetic of the contract, including\\n   * {IERC20-balanceOf} and {IERC20-transfer}.\\n   */\\n  function decimals() public view virtual override returns (uint8) {\\n    return 18;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-totalSupply}.\\n   */\\n  function totalSupply() public view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev Provide easy to view tax total:\\n   */\\n  function _totalBuyTaxBasisPoints() internal view returns (uint256) {\\n    return projectBuyTaxBasisPoints + metadropBuyTaxBasisPoints;\\n  }\\n\\n  /**\\n   * @dev Provide easy to view tax total:\\n   */\\n  function _totalSellTaxBasisPoints() internal view returns (uint256) {\\n    return projectSellTaxBasisPoints + metadropSellTaxBasisPoints;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-balanceOf}.\\n   */\\n  function balanceOf(\\n    address account\\n  ) public view virtual override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev See {IERC20-transfer}.\\n   *\\n   * Requirements:\\n   *\\n   * - `to` cannot be the zero address.\\n   * - the caller must have a balance of at least `amount`.\\n   */\\n  function transfer(\\n    address to,\\n    uint256 amount\\n  ) public virtual override(ERC20Spendable, IERC20) returns (bool) {\\n    address owner = _msgSender();\\n    _transfer(\\n      owner,\\n      to,\\n      amount,\\n      (isLiquidityPool(owner) || isLiquidityPool(to))\\n    );\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-allowance}.\\n   */\\n  function allowance(\\n    address owner,\\n    address spender\\n  ) public view virtual override returns (uint256) {\\n    return _allowances[owner][spender];\\n  }\\n\\n  /**\\n   * @dev See {IERC20-approve}.\\n   *\\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function approve(\\n    address spender,\\n    uint256 amount\\n  ) public virtual override returns (bool) {\\n    address owner = _msgSender();\\n    _approve(owner, spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {IERC20-transferFrom}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance. This is not\\n   * required by the EIP. See the note at the beginning of {ERC20}.\\n   *\\n   * NOTE: Does not update the allowance if the current allowance\\n   * is the maximum `uint256`.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` and `to` cannot be the zero address.\\n   * - `from` must have a balance of at least `amount`.\\n   * - the caller must have allowance for ``from``'s tokens of at least\\n   * `amount`.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) public virtual override returns (bool) {\\n    address spender = _msgSender();\\n    _spendAllowance(from, spender, amount);\\n    _transfer(from, to, amount, (isLiquidityPool(from) || isLiquidityPool(to)));\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {IERC20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function increaseAllowance(\\n    address spender,\\n    uint256 addedValue\\n  ) public virtual returns (bool) {\\n    address owner = _msgSender();\\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {IERC20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   * - `spender` must have allowance for the caller of at least\\n   * `subtractedValue`.\\n   */\\n  function decreaseAllowance(\\n    address spender,\\n    uint256 subtractedValue\\n  ) public virtual returns (bool) {\\n    address owner = _msgSender();\\n    uint256 currentAllowance = allowance(owner, spender);\\n    if (currentAllowance < subtractedValue) {\\n      _revert(AllowanceDecreasedBelowZero.selector);\\n    }\\n    unchecked {\\n      _approve(owner, spender, currentAllowance - subtractedValue);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Moves `amount` of tokens from `from` to `to`.\\n   *\\n   * This internal function is equivalent to {transfer}, and can be used to\\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\\n   *\\n   * Emits a {Transfer} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `from` cannot be the zero address.\\n   * - `to` cannot be the zero address.\\n   * - `from` must have a balance of at least `amount`.\\n   */\\n  function _transfer(\\n    address from,\\n    address to,\\n    uint256 amount,\\n    bool applyTax\\n  ) internal virtual {\\n    _beforeTokenTransfer(from, to, amount);\\n\\n    // Perform pre-tax validation (e.g. amount doesn't exceed balance, max txn amount)\\n    uint256 fromBalance = _pretaxValidationAndLimits(from, to, amount);\\n\\n    // Perform autoswap if eligible\\n    _autoSwap(from, to);\\n\\n    // Process taxes\\n    uint256 amountMinusTax = _taxProcessing(applyTax, to, from, amount);\\n\\n    // Perform post-tax validation (e.g. total balance after post-tax amount applied)\\n    _posttaxValidationAndLimits(from, to, amountMinusTax);\\n\\n    _balances[from] = fromBalance - amount;\\n    _balances[to] += amountMinusTax;\\n\\n    emit Transfer(from, to, amountMinusTax);\\n\\n    _afterTokenTransfer(from, to, amount);\\n  }\\n\\n  /**\\n   * @dev function {_pretaxValidationAndLimits}\\n   *\\n   * Perform validation on pre-tax amounts\\n   *\\n   * @param from_ From address for the transaction\\n   * @param to_ To address for the transaction\\n   * @param amount_ Amount of the transaction\\n   */\\n  function _pretaxValidationAndLimits(\\n    address from_,\\n    address to_,\\n    uint256 amount_\\n  ) internal view returns (uint256 fromBalance_) {\\n    // This can't be a transfer to the liquidity pool before the funding date\\n    // UNLESS the from address is this contract. This ensures that the initial\\n    // LP funding transaction is from this contract using the supply of tokens\\n    // designated for the LP pool, and therefore the initial price in the pool\\n    // is being set as expected.\\n    //\\n    // This protects from, for example, tokens from a team minted supply being\\n    // paired with ETH and added to the pool, setting the initial price, BEFORE\\n    // the initial liquidity is added through this contract.\\n    if (to_ == uniswapV2Pair && from_ != address(this) && fundedDate == 0) {\\n      _revert(InitialLiquidityNotYetAdded.selector);\\n    }\\n\\n    if (from_ == address(0)) {\\n      _revert(TransferFromZeroAddress.selector);\\n    }\\n\\n    if (to_ == address(0)) {\\n      _revert(TransferToZeroAddress.selector);\\n    }\\n\\n    fromBalance_ = _balances[from_];\\n\\n    if (fromBalance_ < amount_) {\\n      _revert(TransferAmountExceedsBalance.selector);\\n    }\\n\\n    // Liquidity pools aren't always going to round cleanly. This can (and does)\\n    // mean that a limit of 5,000 tokens (for example) will trigger on a transfer\\n    // of 5,000 tokens, as the transfer is actually for 5,000.00000000000000213.\\n    // While 4,999 will work fine, it isn't hugely user friendly. So we buffer\\n    // the limit with rounding decimals, which in all cases are considerably less\\n    // than one whole token:\\n    uint256 roundedLimited;\\n\\n    unchecked {\\n      roundedLimited = maxTokensPerTransaction + ROUND_DEC;\\n    }\\n\\n    if (\\n      _botProtectionEnforced() &&\\n      (maxTokensPerTransaction != 0) &&\\n      (amount_ > roundedLimited) &&\\n      ((isLiquidityPool(from_) && !isUnlimited(to_)) ||\\n        (isLiquidityPool(to_) && !isUnlimited(from_)))\\n    ) {\\n      _revert(MaxTokensPerTxnExceeded.selector);\\n    }\\n\\n    return (fromBalance_);\\n  }\\n\\n  /**\\n   * @dev function {_botProtectionEnforced}\\n   *\\n   * Are bot protections enforced?\\n   *\\n   * @return botProtectionEnforced_ They are! / arent\\n   */\\n  function _botProtectionEnforced()\\n    internal\\n    view\\n    returns (bool botProtectionEnforced_)\\n  {\\n    // Limits are not enforced after then protection end date OR prior to LP funding:\\n    // The second clause of 'fundedDate == 0' isn't strictly needed, since with a funded\\n    // date of 0 we would always expect the block.timestamp to be less than 0 plus\\n    // the botProtectionDurationInSeconds. But, to cover the miniscule chance of a user\\n    // selecting a truly enormous bot protection period, such that when added to 0 it\\n    // is more than the current block.timestamp, we have included this second clause. There\\n    // is no permanent gas overhead (the logic will be returning from the first clause after\\n    // the bot protection period has expired). During the bot protection period there is a minor\\n    // gas overhead from evaluating the fundedDate == 0 (which will be false), but this is minimal.\\n    if (\\n      block.timestamp > fundedDate + botProtectionDurationInSeconds ||\\n      fundedDate == 0\\n    ) {\\n      return false;\\n    } else {\\n      // LP has been funded AND we are within the protection period:\\n      return true;\\n    }\\n  }\\n\\n  /**\\n   * @dev function {_callerIsValid}\\n   *\\n   * Does the msg.sender meet anti-bot requirements\\n   *\\n   * @return callerIsValid_ They are! / aren't!\\n   */\\n  function _callerIsValid() internal view returns (bool callerIsValid_) {\\n    // If the origin and sender are the same we can proceed:\\n    if (tx.origin == _msgSender()) {\\n      callerIsValid_ = true;\\n    } else {\\n      // Otherwise, check the sender's bytecode:\\n      address callingAddress = _msgSender();\\n      bytes32 codeHash;\\n\\n      assembly {\\n        codeHash := extcodesize(callingAddress)\\n      }\\n\\n      // If they are not a contract OR they are a gnosis multisig they are OK:\\n      if (codeHash == bytes32(0) || codeHash == GNOSIS_SAFE_PROXY) {\\n        callerIsValid_ = true;\\n      } else {\\n        // If they are a contract, they may still be OK!\\n        callerIsValid_ = isValidCaller(codeHash);\\n      }\\n    }\\n    return (callerIsValid_);\\n  }\\n\\n  /**\\n   * @dev function {_posttaxValidationAndLimits}\\n   *\\n   * Perform validation on post-tax amounts\\n   *\\n   * @param to_ To address for the transaction\\n   * @param amount_ Amount of the transaction\\n   */\\n  function _posttaxValidationAndLimits(\\n    address from_,\\n    address to_,\\n    uint256 amount_\\n  ) internal view returns (uint256 fromBalance_) {\\n    // Liquidity pools aren't always going to round cleanly. This can (and does)\\n    // mean that a limit of 5,000 tokens (for example) will trigger on a max holding\\n    // of 5,000 tokens, as the transfer to achieve that is actually for\\n    // 5,000.00000000000000213. While 4,999 will work fine, it isn't hugely user friendly.\\n    // So we buffer the limit with rounding decimals, which in all cases are considerably\\n    // less than one whole token:\\n    uint256 roundedLimited;\\n\\n    unchecked {\\n      roundedLimited = maxTokensPerWallet + ROUND_DEC;\\n    }\\n    if (\\n      _botProtectionEnforced() &&\\n      (maxTokensPerWallet != 0) &&\\n      (amount_ + balanceOf(to_) > roundedLimited) &&\\n      // If this is a buy (from a liquidity pool), we apply if the to_\\n      // address isn't noted as unlimited:\\n      (isLiquidityPool(from_) && !isUnlimited(to_))\\n    ) {\\n      _revert(MaxTokensPerWalletExceeded.selector);\\n    }\\n\\n    return (fromBalance_);\\n  }\\n\\n  /**\\n   * @dev function {_taxProcessing}\\n   *\\n   * Perform tax processing\\n   *\\n   * @param applyTax_ Do we apply tax to this transaction?\\n   * @param to_ The reciever of the token\\n   * @param from_ The sender of the token\\n   * @param sentAmount_ The amount being send\\n   * @return amountLessTax_ The amount that will be recieved, i.e. the send amount minus tax\\n   */\\n  function _taxProcessing(\\n    bool applyTax_,\\n    address to_,\\n    address from_,\\n    uint256 sentAmount_\\n  ) internal returns (uint256 amountLessTax_) {\\n    amountLessTax_ = sentAmount_;\\n    unchecked {\\n      if (_tokenHasTax && applyTax_ && !_autoSwapInProgress) {\\n        uint256 tax;\\n\\n        // on sell\\n        if (isLiquidityPool(to_) && _totalSellTaxBasisPoints() > 0) {\\n          if (projectSellTaxBasisPoints > 0) {\\n            uint256 projectTax = ((sentAmount_ * projectSellTaxBasisPoints) /\\n              BP_DENOM);\\n            projectTaxPendingSwap += uint128(projectTax);\\n            tax += projectTax;\\n          }\\n          if (metadropSellTaxBasisPoints > 0) {\\n            uint256 metadropTax = ((sentAmount_ * metadropSellTaxBasisPoints) /\\n              BP_DENOM);\\n            metadropTaxPendingSwap += uint128(metadropTax);\\n            tax += metadropTax;\\n          }\\n        }\\n        // on buy\\n        else if (isLiquidityPool(from_) && _totalBuyTaxBasisPoints() > 0) {\\n          if (projectBuyTaxBasisPoints > 0) {\\n            uint256 projectTax = ((sentAmount_ * projectBuyTaxBasisPoints) /\\n              BP_DENOM);\\n            projectTaxPendingSwap += uint128(projectTax);\\n            tax += projectTax;\\n          }\\n          if (metadropBuyTaxBasisPoints > 0) {\\n            uint256 metadropTax = ((sentAmount_ * metadropBuyTaxBasisPoints) /\\n              BP_DENOM);\\n            metadropTaxPendingSwap += uint128(metadropTax);\\n            tax += metadropTax;\\n          }\\n        }\\n\\n        if (tax > 0) {\\n          _balances[address(this)] += tax;\\n          emit Transfer(from_, address(this), tax);\\n          amountLessTax_ -= tax;\\n        }\\n      }\\n    }\\n    return (amountLessTax_);\\n  }\\n\\n  /**\\n   * @dev function {_autoSwap}\\n   *\\n   * Automate the swap of accumulated tax fees to native token\\n   *\\n   * @param from_ The sender of the token\\n   * @param to_ The recipient of the token\\n   */\\n  function _autoSwap(address from_, address to_) internal {\\n    if (_tokenHasTax) {\\n      uint256 contractBalance = balanceOf(address(this));\\n      uint256 swapBalance = contractBalance;\\n\\n      uint256 swapThresholdInTokens = (_totalSupply *\\n        swapThresholdBasisPoints) / BP_DENOM;\\n\\n      if (_eligibleForSwap(from_, to_, swapBalance, swapThresholdInTokens)) {\\n        // Store that a swap back is in progress:\\n        _autoSwapInProgress = true;\\n        // Check if we need to reduce the amount of tokens for this swap:\\n        if (swapBalance > swapThresholdInTokens * MAX_SWAP_THRESHOLD_MULTIPLE) {\\n          swapBalance = swapThresholdInTokens * MAX_SWAP_THRESHOLD_MULTIPLE;\\n        }\\n        // Perform the auto swap to native token:\\n        _swapTaxForNative(swapBalance, contractBalance);\\n        // Flag that the autoswap is complete:\\n        _autoSwapInProgress = false;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev function {_eligibleForSwap}\\n   *\\n   * Is the current transfer eligible for autoswap\\n   *\\n   * @param from_ The sender of the token\\n   * @param to_ The recipient of the token\\n   * @param taxBalance_ The current accumulated tax balance\\n   * @param swapThresholdInTokens_ The swap threshold as a token amount\\n   */\\n  function _eligibleForSwap(\\n    address from_,\\n    address to_,\\n    uint256 taxBalance_,\\n    uint256 swapThresholdInTokens_\\n  ) internal view returns (bool) {\\n    return (taxBalance_ >= swapThresholdInTokens_ &&\\n      !_autoSwapInProgress &&\\n      !isLiquidityPool(from_) &&\\n      from_ != address(_uniswapRouter) &&\\n      to_ != address(_uniswapRouter));\\n  }\\n\\n  /**\\n   * @dev function {_swapTaxForNative}\\n   *\\n   * Swap tokens taken as tax for native token\\n   *\\n   * @param swapBalance_ The current accumulated tax balance to swap\\n   * @param contractBalance_ The current accumulated total tax balance\\n   */\\n  function _swapTaxForNative(\\n    uint256 swapBalance_,\\n    uint256 contractBalance_\\n  ) internal {\\n    uint256 preSwapBalance = address(this).balance;\\n\\n    address[] memory path = new address[](2);\\n    path[0] = address(this);\\n    path[1] = _uniswapRouter.WETH();\\n\\n    // Wrap external calls in try / catch to handle errors\\n    try\\n      _uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        swapBalance_,\\n        0,\\n        path,\\n        address(this),\\n        block.timestamp + 600\\n      )\\n    {\\n      uint256 postSwapBalance = address(this).balance;\\n\\n      uint256 balanceToDistribute = postSwapBalance - preSwapBalance;\\n\\n      uint256 totalPendingSwap = projectTaxPendingSwap + metadropTaxPendingSwap;\\n\\n      uint256 projectBalanceToDistribute = (balanceToDistribute *\\n        projectTaxPendingSwap) / totalPendingSwap;\\n\\n      uint256 metadropBalanceToDistribute = (balanceToDistribute *\\n        metadropTaxPendingSwap) / totalPendingSwap;\\n\\n      // We will not have swapped all tax tokens IF the amount was greater than the max auto swap.\\n      // We therefore cannot just set the pending swap counters to 0. Instead, in this scenario,\\n      // we must reduce them in proportion to the swap amount vs the remaining balance + swap\\n      // amount.\\n      //\\n      // For example:\\n      //  * swap Balance is 250\\n      //  * contract balance is 385.\\n      //  * projectTaxPendingSwap is 300\\n      //  * metadropTaxPendingSwap is 85.\\n      //\\n      // The new total for the projectTaxPendingSwap is:\\n      //   = 300 - ((300 * 250) / 385)\\n      //   = 300 - 194\\n      //   = 106\\n      // The new total for the metadropTaxPendingSwap is:\\n      //   = 85 - ((85 * 250) / 385)\\n      //   = 85 - 55\\n      //   = 30\\n      //\\n      if (swapBalance_ < contractBalance_) {\\n        projectTaxPendingSwap -= uint128(\\n          (projectTaxPendingSwap * swapBalance_) / contractBalance_\\n        );\\n        metadropTaxPendingSwap -= uint128(\\n          (metadropTaxPendingSwap * swapBalance_) / contractBalance_\\n        );\\n      } else {\\n        (projectTaxPendingSwap, metadropTaxPendingSwap) = (0, 0);\\n      }\\n      // Distribute to treasuries:\\n      bool success;\\n      address weth;\\n      uint256 gas;\\n\\n      if (projectBalanceToDistribute > 0) {\\n        // If no gas limit was provided or provided gas limit greater than gas left, just use the remaining gas.\\n        gas = (CALL_GAS_LIMIT == 0 || CALL_GAS_LIMIT > gasleft())\\n          ? gasleft()\\n          : CALL_GAS_LIMIT;\\n\\n        // We limit the gas passed so that a called address cannot cause a block out of gas error:\\n        (success, ) = projectTaxRecipient.call{\\n          value: projectBalanceToDistribute,\\n          gas: gas\\n        }(\\\"\\\");\\n\\n        // If the ETH transfer fails, wrap the ETH and send it as WETH. We do this so that a called\\n        // address cannot cause this transfer to fail, either intentionally or by mistake:\\n        if (!success) {\\n          if (weth == address(0)) {\\n            weth = _uniswapRouter.WETH();\\n          }\\n\\n          try IWETH(weth).deposit{value: projectBalanceToDistribute}() {\\n            try\\n              IERC20(address(weth)).transfer(\\n                projectTaxRecipient,\\n                projectBalanceToDistribute\\n              )\\n            {} catch {\\n              // Dont allow a failed external call (in this case to WETH) to stop a transfer.\\n              // Emit that this has occured and continue.\\n              emit ExternalCallError(1);\\n            }\\n          } catch {\\n            // Dont allow a failed external call (in this case to WETH) to stop a transfer.\\n            // Emit that this has occured and continue.\\n            emit ExternalCallError(2);\\n          }\\n        }\\n      }\\n\\n      if (metadropBalanceToDistribute > 0) {\\n        // If no gas limit was provided or provided gas limit greater than gas left, just use the remaining gas.\\n        gas = (CALL_GAS_LIMIT == 0 || CALL_GAS_LIMIT > gasleft())\\n          ? gasleft()\\n          : CALL_GAS_LIMIT;\\n\\n        (success, ) = metadropTaxRecipient.call{\\n          value: metadropBalanceToDistribute,\\n          gas: gas\\n        }(\\\"\\\");\\n\\n        // If the ETH transfer fails, wrap the ETH and send it as WETH. We do this so that a called\\n        // address cannot cause this transfer to fail, either intentionally or by mistake:\\n        if (!success) {\\n          if (weth == address(0)) {\\n            weth = _uniswapRouter.WETH();\\n          }\\n          try IWETH(weth).deposit{value: metadropBalanceToDistribute}() {\\n            try\\n              IERC20(address(weth)).transfer(\\n                metadropTaxRecipient,\\n                metadropBalanceToDistribute\\n              )\\n            {} catch {\\n              // Dont allow a failed external call (in this case to WETH) to stop a transfer.\\n              // Emit that this has occured and continue.\\n              emit ExternalCallError(3);\\n            }\\n          } catch {\\n            // Dont allow a failed external call (in this case to WETH) to stop a transfer.\\n            // Emit that this has occured and continue.\\n            emit ExternalCallError(4);\\n          }\\n        }\\n      }\\n    } catch {\\n      // Dont allow a failed external call (in this case to uniswap) to stop a transfer.\\n      // Emit that this has occured and continue.\\n      emit ExternalCallError(5);\\n    }\\n  }\\n\\n  /**\\n   * @dev distributeTaxTokens\\n   *\\n   * Allows the distribution of tax tokens to the designated recipient(s)\\n   *\\n   * As part of standard processing the tax token balance being above the threshold\\n   * will trigger an autoswap to ETH and distribution of this ETH to the designated\\n   * recipients. This is automatic and there is no need for user involvement.\\n   *\\n   * As part of this swap there are a number of calculations performed, particularly\\n   * if the tax balance is above MAX_SWAP_THRESHOLD_MULTIPLE.\\n   *\\n   * Testing indicates that these calculations are safe. But given the data / code\\n   * interactions it remains possible that some edge case set of scenarios may cause\\n   * an issue with these calculations.\\n   *\\n   * This method is therefore provided as a 'fallback' option to safely distribute\\n   * accumulated taxes from the contract, with a direct transfer of the ERC20 tokens\\n   * themselves.\\n   */\\n  function distributeTaxTokens() external {\\n    if (projectTaxPendingSwap > 0) {\\n      uint256 projectDistribution = projectTaxPendingSwap;\\n      projectTaxPendingSwap = 0;\\n      _transfer(address(this), projectTaxRecipient, projectDistribution, false);\\n    }\\n\\n    if (metadropTaxPendingSwap > 0) {\\n      uint256 metadropDistribution = metadropTaxPendingSwap;\\n      metadropTaxPendingSwap = 0;\\n      _transfer(\\n        address(this),\\n        metadropTaxRecipient,\\n        metadropDistribution,\\n        false\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @dev function {withdrawETH} onlyManager\\n   *\\n   * A withdraw function to allow ETH to be withdrawn by the manager\\n   *\\n   * This contract should never hold ETH. The only envisaged scenario where\\n   * it might hold ETH is a failed autoswap where the uniswap swap has completed,\\n   * the recipient of ETH reverts, the contract then wraps to WETH and the\\n   * wrap to WETH fails.\\n   *\\n   * This feels unlikely. But, for safety, we include this method.\\n   *\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawETH(uint256 amount_) external onlyManager {\\n    (bool success, ) = _msgSender().call{value: amount_}(\\\"\\\");\\n    if (!success) {\\n      _revert(TransferFailed.selector);\\n    }\\n  }\\n\\n  /**\\n   * @dev function {withdrawERC20} onlyManager\\n   *\\n   * A withdraw function to allow ERC20s (except address(this)) to be withdrawn.\\n   *\\n   * This contract should never hold ERC20s other than tax tokens. The only envisaged\\n   * scenario where it might hold an ERC20 is a failed autoswap where the uniswap swap\\n   * has completed, the recipient of ETH reverts, the contract then wraps to WETH, the\\n   * wrap to WETH succeeds, BUT then the transfer of WETH fails.\\n   *\\n   * This feels even less likely than the scenario where ETH is held on the contract.\\n   * But, for safety, we include this method.\\n   *\\n   * @param token_ The ERC20 contract\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawERC20(address token_, uint256 amount_) external onlyManager {\\n    if (token_ == address(this)) {\\n      _revert(CannotWithdrawThisToken.selector);\\n    }\\n    IERC20(token_).safeTransfer(_msgSender(), amount_);\\n  }\\n\\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n   * the total supply.\\n   *\\n   * Emits a {Transfer} event with `from` set to the zero address.\\n   *\\n   * Requirements:\\n   *\\n   * - `account` cannot be the zero address.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    if (account == address(0)) {\\n      _revert(MintToZeroAddress.selector);\\n    }\\n\\n    _beforeTokenTransfer(address(0), account, amount);\\n\\n    _totalSupply += uint128(amount);\\n    unchecked {\\n      // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n      _balances[account] += amount;\\n    }\\n    emit Transfer(address(0), account, amount);\\n\\n    _afterTokenTransfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\n   * total supply.\\n   *\\n   * Emits a {Transfer} event with `to` set to the zero address.\\n   *\\n   * Requirements:\\n   *\\n   * - `account` cannot be the zero address.\\n   * - `account` must have at least `amount` tokens.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    if (account == address(0)) {\\n      _revert(BurnFromTheZeroAddress.selector);\\n    }\\n\\n    _beforeTokenTransfer(account, address(0), amount);\\n\\n    uint256 accountBalance = _balances[account];\\n    if (accountBalance < amount) {\\n      _revert(BurnExceedsBalance.selector);\\n    }\\n\\n    unchecked {\\n      _balances[account] = accountBalance - amount;\\n      // Overflow not possible: amount <= accountBalance <= totalSupply.\\n      _totalSupply -= uint128(amount);\\n    }\\n\\n    emit Transfer(account, address(0), amount);\\n\\n    _afterTokenTransfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n   *\\n   * This internal function is equivalent to `approve`, and can be used to\\n   * e.g. set automatic allowances for certain subsystems, etc.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `owner` cannot be the zero address.\\n   * - `spender` cannot be the zero address.\\n   */\\n  function _approve(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) internal virtual {\\n    if (owner == address(0)) {\\n      _revert(ApproveFromTheZeroAddress.selector);\\n    }\\n\\n    if (spender == address(0)) {\\n      _revert(ApproveToTheZeroAddress.selector);\\n    }\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n  /**\\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n   *\\n   * Does not update the allowance amount in case of infinite allowance.\\n   * Revert if not enough allowance is available.\\n   *\\n   * Might emit an {Approval} event.\\n   */\\n  function _spendAllowance(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) internal virtual {\\n    uint256 currentAllowance = allowance(owner, spender);\\n    if (currentAllowance != type(uint256).max) {\\n      if (currentAllowance < amount) {\\n        _revert(InsufficientAllowance.selector);\\n      }\\n\\n      unchecked {\\n        _approve(owner, spender, currentAllowance - amount);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Destroys a `value` amount of tokens from the caller.\\n   *\\n   * See {ERC20-_burn}.\\n   */\\n  function burn(uint256 value) public virtual {\\n    _burn(_msgSender(), value);\\n  }\\n\\n  /**\\n   * @dev Destroys a `value` amount of tokens from `account`, deducting from\\n   * the caller's allowance.\\n   *\\n   * See {ERC20-_burn} and {ERC20-allowance}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have allowance for ``accounts``'s tokens of at least\\n   * `value`.\\n   */\\n  function burnFrom(address account, uint256 value) public virtual {\\n    _spendAllowance(account, _msgSender(), value);\\n    _burn(account, value);\\n  }\\n\\n  /**\\n   * @dev Hook that is called before any transfer of tokens. This includes\\n   * minting and burning.\\n   *\\n   * Calling conditions:\\n   *\\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n   * will be transferred to `to`.\\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n   * - `from` and `to` are never both zero.\\n   *\\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n   */\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual {}\\n\\n  /**\\n   * @dev Hook that is called after any transfer of tokens. This includes\\n   * minting and burning.\\n   *\\n   * Calling conditions:\\n   *\\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n   * has been transferred to `to`.\\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n   * - `from` and `to` are never both zero.\\n   *\\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n   */\\n  function _afterTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual {}\\n\\n  receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20Factory/ERC20/IERC20ByMetadrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.21;\\n\\nimport {IConfigStructures} from \\\"../../Global/IConfigStructures.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20ConfigByMetadrop} from \\\"./IERC20ConfigByMetadrop.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n/**\\n * @dev Metadrop core ERC-20 contract, interface\\n */\\ninterface IERC20ByMetadrop is\\n  IConfigStructures,\\n  IERC20,\\n  IERC20ConfigByMetadrop,\\n  IERC20Metadata\\n{\\n  struct SocialLinks {\\n    string linkType;\\n    string link;\\n  }\\n\\n  event AutoSwapThresholdUpdated(uint256 oldThreshold, uint256 newThreshold);\\n\\n  event ExternalCallError(uint256 identifier);\\n\\n  event InitialLiquidityAdded(uint256 tokenA, uint256 tokenB, uint256 lpToken);\\n\\n  event LinksUpdated();\\n\\n  event LiquidityLocked(uint256 lpLockupInDays);\\n\\n  event LiquidityPoolCreated(address addedPool);\\n\\n  event LiquidityPoolAdded(address addedPool);\\n\\n  event LiquidityPoolRemoved(address removedPool);\\n\\n  event MetadropTaxBasisPointsChanged(\\n    uint256 oldBuyBasisPoints,\\n    uint256 newBuyBasisPoints,\\n    uint256 oldSellBasisPoints,\\n    uint256 newSellBasisPoints\\n  );\\n\\n  event ProjectTaxBasisPointsChanged(\\n    uint256 oldBuyBasisPoints,\\n    uint256 newBuyBasisPoints,\\n    uint256 oldSellBasisPoints,\\n    uint256 newSellBasisPoints\\n  );\\n\\n  event RevenueAutoSwap();\\n\\n  event ProjectTaxRecipientUpdated(address treasury);\\n\\n  event UnlimitedAddressAdded(address addedUnlimted);\\n\\n  event UnlimitedAddressRemoved(address removedUnlimted);\\n\\n  event ValidCallerAdded(bytes32 addedValidCaller);\\n\\n  event ValidCallerRemoved(bytes32 removedValidCaller);\\n\\n  /**\\n   * @dev function {_1___website}\\n   *\\n   * Returns the stored website address, with prefixed chars\\n   *\\n   * @return string The website address\\n   */\\n  function _1___website() external view returns (string memory);\\n\\n  /**\\n   * @dev function {_2___twitter}\\n   *\\n   * Returns the stored twitter address, with prefixed chars\\n   *\\n   * @return string The twitter address\\n   */\\n  function _2___twitter() external view returns (string memory);\\n\\n  /**\\n   * @dev function {_3___telegram}\\n   *\\n   * Returns the stored telegram address, with prefixed chars\\n   *\\n   * @return string The telegram address\\n   */\\n  function _3___telegram() external view returns (string memory);\\n\\n  /**\\n   * @dev function {_4___discord}\\n   *\\n   * Returns the stored discord address, with prefixed chars\\n   *\\n   * @return string The discord address\\n   */\\n  function _4___discord() external view returns (string memory);\\n\\n  /**\\n   * @dev function {addInitialLiquidity}\\n   *\\n   * Add initial liquidity to the uniswap pair\\n   *\\n   * @param lockerFee_ The locker fee in wei. This must match the required fee from the external locker contract.\\n   * @param lpLockupInDays_ The number of days to lock liquidity NOTE you can pass 0 to use the stored immutable value.\\n   */\\n  function addInitialLiquidity(\\n    uint256 lockerFee_,\\n    uint256 lpLockupInDays_\\n  ) external payable;\\n\\n  /**\\n   * @dev function {updateLinks} onlyOwner\\n   *\\n   * Allows the owner to update links\\n   *\\n   * @param linkHasChanged_ a bool array, set to true where the corresponding link has been updated\\n   * @param links_ a string array, holds updated links\\n   */\\n  function updateLinks(\\n    bool[4] memory linkHasChanged_,\\n    string[4] memory links_\\n  ) external;\\n\\n  /**\\n   * @dev function {isLiquidityPool}\\n   *\\n   * Return if an address is a liquidity pool\\n   *\\n   * @param queryAddress_ The address being queried\\n   * @return bool The address is / isn't a liquidity pool\\n   */\\n  function isLiquidityPool(address queryAddress_) external view returns (bool);\\n\\n  /**\\n   * @dev function {liquidityPools}\\n   *\\n   * Returns a list of all liquidity pools\\n   *\\n   * @return liquidityPools_ a list of all liquidity pools\\n   */\\n  function liquidityPools()\\n    external\\n    view\\n    returns (address[] memory liquidityPools_);\\n\\n  /**\\n   * @dev function {addLiquidityPool} onlyManager\\n   *\\n   * Allows the manager to add a liquidity pool to the pool enumerable set\\n   *\\n   * @param newLiquidityPool_ The address of the new liquidity pool\\n   */\\n  function addLiquidityPool(address newLiquidityPool_) external;\\n\\n  /**\\n   * @dev function {removeLiquidityPool} onlyManager\\n   *\\n   * Allows the manager to remove a liquidity pool\\n   *\\n   * @param removedLiquidityPool_ The address of the old removed liquidity pool\\n   */\\n  function removeLiquidityPool(address removedLiquidityPool_) external;\\n\\n  /**\\n   * @dev function {isUnlimited}\\n   *\\n   * Return if an address is unlimited (is not subject to per txn and per wallet limits)\\n   *\\n   * @param queryAddress_ The address being queried\\n   * @return bool The address is / isn't unlimited\\n   */\\n  function isUnlimited(address queryAddress_) external view returns (bool);\\n\\n  /**\\n   * @dev function {unlimitedAddresses}\\n   *\\n   * Returns a list of all unlimited addresses\\n   *\\n   * @return unlimitedAddresses_ a list of all unlimited addresses\\n   */\\n  function unlimitedAddresses()\\n    external\\n    view\\n    returns (address[] memory unlimitedAddresses_);\\n\\n  /**\\n   * @dev function {addUnlimited} onlyManager\\n   *\\n   * Allows the manager to add an unlimited address\\n   *\\n   * @param newUnlimited_ The address of the new unlimited address\\n   */\\n  function addUnlimited(address newUnlimited_) external;\\n\\n  /**\\n   * @dev function {removeUnlimited} onlyManager\\n   *\\n   * Allows the manager to remove an unlimited address\\n   *\\n   * @param removedUnlimited_ The address of the old removed unlimited address\\n   */\\n  function removeUnlimited(address removedUnlimited_) external;\\n\\n  /**\\n   * @dev function {isValidCaller}\\n   *\\n   * Return if an address is a valid caller\\n   *\\n   * @param queryHash_ The code hash being queried\\n   * @return bool The address is / isn't a valid caller\\n   */\\n  function isValidCaller(bytes32 queryHash_) external view returns (bool);\\n\\n  /**\\n   * @dev function {validCallers}\\n   *\\n   * Returns a list of all valid caller code hashes\\n   *\\n   * @return validCallerHashes_ a list of all valid caller code hashes\\n   */\\n  function validCallers()\\n    external\\n    view\\n    returns (bytes32[] memory validCallerHashes_);\\n\\n  /**\\n   * @dev function {addValidCaller} onlyOwner\\n   *\\n   * Allows the owner to add the hash of a valid caller\\n   *\\n   * @param newValidCallerHash_ The hash of the new valid caller\\n   */\\n  function addValidCaller(bytes32 newValidCallerHash_) external;\\n\\n  /**\\n   * @dev function {removeValidCaller} onlyOwner\\n   *\\n   * Allows the owner to remove a valid caller\\n   *\\n   * @param removedValidCallerHash_ The hash of the old removed valid caller\\n   */\\n  function removeValidCaller(bytes32 removedValidCallerHash_) external;\\n\\n  /**\\n   * @dev function {setProjectTaxRecipient} onlyManager\\n   *\\n   * Allows the manager to set the project tax recipient address\\n   *\\n   * @param projectTaxRecipient_ New recipient address\\n   */\\n  function setProjectTaxRecipient(address projectTaxRecipient_) external;\\n\\n  /**\\n   * @dev function {setSwapThresholdBasisPoints} onlyManager\\n   *\\n   * Allows the manager to set the autoswap threshold\\n   *\\n   * @param swapThresholdBasisPoints_ New swap threshold in basis points\\n   */\\n  function setSwapThresholdBasisPoints(\\n    uint16 swapThresholdBasisPoints_\\n  ) external;\\n\\n  /**\\n   * @dev function {setProjectTaxRates} onlyManager\\n   *\\n   * Change the tax rates, subject to max rate\\n   *\\n   * @param newProjectBuyTaxBasisPoints_ The new buy tax rate\\n   * @param newProjectSellTaxBasisPoints_ The new sell tax rate\\n   */\\n  function setProjectTaxRates(\\n    uint16 newProjectBuyTaxBasisPoints_,\\n    uint16 newProjectSellTaxBasisPoints_\\n  ) external;\\n\\n  /**\\n   * @dev function {setMetadropTaxRates} onlyManager\\n   *\\n   * Change the tax rates, subject to max rate and minimum tax period.\\n   *\\n   * @param newMetadropBuyTaxBasisPoints_ The new buy tax rate\\n   * @param newMetadropSellTaxBasisPoints_ The new sell tax rate\\n   */\\n  function setMetadropTaxRates(\\n    uint16 newMetadropBuyTaxBasisPoints_,\\n    uint16 newMetadropSellTaxBasisPoints_\\n  ) external;\\n\\n  /**\\n   * @dev distributeTaxTokens\\n   *\\n   * Allows the distribution of tax tokens to the designated recipient(s)\\n   *\\n   * As part of standard processing the tax token balance being above the threshold\\n   * will trigger an autoswap to ETH and distribution of this ETH to the designated\\n   * recipients. This is automatic and there is no need for user involvement.\\n   *\\n   * As part of this swap there are a number of calculations performed, particularly\\n   * if the tax balance is above MAX_SWAP_THRESHOLD_MULTIPLE.\\n   *\\n   * Testing indicates that these calculations are safe. But given the data / code\\n   * interactions it remains possible that some edge case set of scenarios may cause\\n   * an issue with these calculations.\\n   *\\n   * This method is therefore provided as a 'fallback' option to safely distribute\\n   * accumulated taxes from the contract, with a direct transfer of the ERC20 tokens\\n   * themselves.\\n   */\\n  function distributeTaxTokens() external;\\n\\n  /**\\n   * @dev function {withdrawETH} onlyManager\\n   *\\n   * A withdraw function to allow ETH to be withdrawn by the manager\\n   *\\n   * This contract should never hold ETH. The only envisaged scenario where\\n   * it might hold ETH is a failed autoswap where the uniswap swap has completed,\\n   * the recipient of ETH reverts, the contract then wraps to WETH and the\\n   * wrap to WETH fails.\\n   *\\n   * This feels unlikely. But, for safety, we include this method.\\n   *\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawETH(uint256 amount_) external;\\n\\n  /**\\n   * @dev function {withdrawERC20} onlyManager\\n   *\\n   * A withdraw function to allow ERC20s (except address(this)) to be withdrawn.\\n   *\\n   * This contract should never hold ERC20s other than tax tokens. The only envisaged\\n   * scenario where it might hold an ERC20 is a failed autoswap where the uniswap swap\\n   * has completed, the recipient of ETH reverts, the contract then wraps to WETH, the\\n   * wrap to WETH succeeds, BUT then the transfer of WETH fails.\\n   *\\n   * This feels even less likely than the scenario where ETH is held on the contract.\\n   * But, for safety, we include this method.\\n   *\\n   * @param token_ The ERC20 contract\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawERC20(address token_, uint256 amount_) external;\\n\\n  /**\\n   * @dev Destroys a `value` amount of tokens from the caller.\\n   *\\n   * See {ERC20-_burn}.\\n   */\\n  function burn(uint256 value) external;\\n\\n  /**\\n   * @dev Destroys a `value` amount of tokens from `account`, deducting from\\n   * the caller's allowance.\\n   *\\n   * See {ERC20-_burn} and {ERC20-allowance}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have allowance for ``accounts``'s tokens of at least\\n   * `value`.\\n   */\\n  function burnFrom(address account, uint256 value) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20Factory/ERC20/IERC20ConfigByMetadrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title IERC20ByMetadrop.sol. Interface for metadrop ERC20 standard\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.21;\\n\\ninterface IERC20ConfigByMetadrop {\\n  struct ERC20Config {\\n    bytes baseParameters;\\n    bytes supplyParameters;\\n    bytes taxParameters;\\n    bytes poolParameters;\\n  }\\n\\n  struct ERC20BaseParameters {\\n    string name;\\n    string symbol;\\n    string website;\\n    string twitter;\\n    string telegram;\\n    string otherSocials;\\n    bool addLiquidityOnCreate;\\n    bool usesDRIPool;\\n  }\\n\\n  struct ERC20SupplyParameters {\\n    uint256 maxSupply;\\n    uint256 lpSupply;\\n    uint256 projectSupply;\\n    uint256 maxTokensPerWallet;\\n    uint256 maxTokensPerTxn;\\n    uint256 lpLockupInDays;\\n    uint256 botProtectionDurationInSeconds;\\n    address projectSupplyRecipient;\\n    address projectLPOwner;\\n  }\\n\\n  struct ERC20TaxParameters {\\n    uint256 projectBuyTaxBasisPoints;\\n    uint256 projectSellTaxBasisPoints;\\n    uint256 maxProjectBuyTaxBasisPoints;\\n    uint256 maxProjectSellTaxBasisPoints;\\n    uint256 taxSwapThresholdBasisPoints;\\n    uint256 metadropBuyTaxBasisPoints;\\n    uint256 metadropSellTaxBasisPoints;\\n    uint256 maxMetadropBuyTaxBasisPoints;\\n    uint256 maxMetadropSellTaxBasisPoints;\\n    uint256 metadropTaxPeriodInDays;\\n    address projectTaxRecipient;\\n    address metadropTaxRecipient;\\n  }\\n\\n  struct ERC20PoolParameters {\\n    uint256 poolSupply;\\n    uint256 poolStartDate;\\n    uint256 poolEndDate;\\n    uint256 poolVestingInDays;\\n    uint256 poolMaxETH;\\n    uint256 poolPerAddressMaxETH;\\n    uint256 poolMinETH;\\n    uint256 poolPerTransactionMinETH;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20Factory/ERC20Factory/ERC20FactoryByMetadrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.21;\\n\\nimport {AuthorityModel} from \\\"../../Global/AuthorityModel.sol\\\";\\nimport {Clones} from \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {Decommissionable} from \\\"../../Global/Decommissionable.sol\\\";\\nimport {IERC20ByMetadrop} from \\\"../ERC20/IERC20ByMetadrop.sol\\\";\\nimport {IERC20DRIPool} from \\\"../ERC20Pools/IERC20DRIPool.sol\\\";\\nimport {IERC20FactoryByMetadrop} from \\\"./IERC20FactoryByMetadrop.sol\\\";\\nimport {IERC20MachineByMetadrop} from \\\"../ERC20Machine/IERC20MachineByMetadrop.sol\\\";\\nimport {SafeERC20, IERC20} from \\\"../../Global/OZ/SafeERC20.sol\\\";\\nimport {SignatureChecker} from \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\n\\n/**\\n * @dev Metadrop ERC-20 factory\\n */\\ncontract ERC20FactoryByMetadrop is\\n  Context,\\n  Decommissionable,\\n  IERC20FactoryByMetadrop,\\n  AuthorityModel\\n{\\n  using SafeERC20 for IERC20;\\n  using Clones for address payable;\\n\\n  // Uniswap router address\\n  address public immutable uniswapRouter;\\n  // Unicrypt locker address\\n  address public immutable unicryptLocker;\\n  // Deployer address\\n  address private immutable deployer;\\n\\n  // DRIPool template:\\n  address payable public driPoolTemplate;\\n  // Machine template:\\n  address payable public machineTemplate;\\n  // Metadrop trusted oracle address\\n  address public metadropOracleAddress;\\n  // Address for all platform fee payments\\n  address public platformTreasury;\\n  // The oracle signed message validity period:\\n  // Note that maximum is 65,535, therefore 18.2 hours (which seems plenty)\\n  uint16 private messageValidityInSeconds = 30 minutes;\\n\\n  /**\\n   * @dev {constructor}\\n   *\\n   * @param superAdmin_ The address that can add and remove user authority roles. Will also be added as the\\n   * first platform admin.\\n   * @param platformAdmins_ The address(es) for the platform admin(s)\\n   * @param platformTreasury_ The address of the platform treasury. This will be used on primary vesting\\n   * for the platform share of funds and on the royalty payment splitter for the platform share.\\n   * @param metadropOracleAddress_ The address of the metadrop oracle signer\\n   * @param uniswapRouter_ The address of the uniswap router\\n   * @param unicryptLocker_ The address of the unicrypt locker\\n   * @param driPoolTemplate_ The address of the launch pool template\\n   */\\n  constructor(\\n    address superAdmin_,\\n    address[] memory platformAdmins_,\\n    address platformTreasury_,\\n    address metadropOracleAddress_,\\n    address uniswapRouter_,\\n    address unicryptLocker_,\\n    address driPoolTemplate_\\n  ) {\\n    // Save the deployer address:\\n    deployer = _msgSender();\\n\\n    // The initial instance owner is set as the Ownable owner on all cloned contracts:\\n    if (superAdmin_ == address(0)) {\\n      _revert(SuperAdminCannotBeAddressZero.selector);\\n    }\\n\\n    // superAdmin can grant and revoke all other roles. This address MUST be secured.\\n    // For the duration of this constructor only the super admin is the deployer.\\n    // This is so the deployer can set initial authorities.\\n    // We set to the configured super admin address at the end of the constructor.\\n    superAdmin = _msgSender();\\n    // Grant platform admin to the deployer for the duration of the constructor:\\n    grantPlatformAdmin(_msgSender());\\n    // By default we will revoke the temporary authority for the deployer, BUT,\\n    // if the deployer is in the platform admin array then we want to keep that\\n    // authority, as it has been explicitly set. We handle that situation using\\n    // a bool:\\n    bool revokeDeployerPlatformAdmin = true;\\n\\n    grantPlatformAdmin(superAdmin_);\\n\\n    for (uint256 i = 0; i < platformAdmins_.length; ) {\\n      // Check if the address we are granting for is the deployer. If it is,\\n      // then the deployer address already IS a platform admin and it would be\\n      // a waste of gas to grant again. Instead, we update the bool to show that\\n      // we DON'T want to revoke this permission at the end of this method:\\n      if (platformAdmins_[i] == _msgSender()) {\\n        revokeDeployerPlatformAdmin = false;\\n      } else {\\n        grantPlatformAdmin(platformAdmins_[i]);\\n      }\\n      unchecked {\\n        i++;\\n      }\\n    }\\n\\n    // Set platform treasury:\\n    if (platformTreasury_ == address(0)) {\\n      _revert(PlatformTreasuryCannotBeAddressZero.selector);\\n    }\\n    platformTreasury = platformTreasury_;\\n\\n    if (metadropOracleAddress_ == address(0)) {\\n      _revert(MetadropOracleCannotBeAddressZero.selector);\\n    }\\n    metadropOracleAddress = metadropOracleAddress_;\\n\\n    uniswapRouter = uniswapRouter_;\\n\\n    unicryptLocker = unicryptLocker_;\\n\\n    driPoolTemplate = payable(driPoolTemplate_);\\n\\n    // This is the factory\\n    factory = address(this);\\n\\n    // Revoke platform admin status of the deployer and transfer superAdmin\\n    // and ownable owner to the superAdmin_.\\n    // Revoke platform admin based on the bool flag set earlier (see above\\n    // for an explanation of how this flag is set)\\n    if (revokeDeployerPlatformAdmin) {\\n      revokePlatformAdmin(_msgSender());\\n    }\\n    if (superAdmin_ != _msgSender()) {\\n      transferSuperAdmin(superAdmin_);\\n    }\\n  }\\n\\n  /**\\n   * @dev function {initialiseMachineAddress}\\n   *\\n   * Initialise the machine template address. This needs to be separate from\\n   * the constructor as the machine needs the factory address on its constructor.\\n   *\\n   * This must ALWAYS be called as part of deployment.\\n   *\\n   * @param machineTemplate_ the machine address\\n   */\\n  function initialiseMachineAddress(address machineTemplate_) external {\\n    if (_msgSender() != deployer) {\\n      _revert(DeployerOnly.selector);\\n    }\\n    if (machineTemplate != address(0)) {\\n      _revert(AddressAlreadySet.selector);\\n    }\\n    machineTemplate = payable(machineTemplate_);\\n    emit MachineAddressUpdated(address(0), machineTemplate_);\\n  }\\n\\n  /**\\n   * @dev function {decommissionFactory} onlySuperAdmin\\n   *\\n   * Make this factory unusable for creating new ERC20s, forever\\n   *\\n   */\\n  function decommissionFactory() external onlySuperAdmin {\\n    _decommission();\\n  }\\n\\n  /**\\n   * @dev function {setMetadropOracleAddress} onlyPlatformAdmin\\n   *\\n   * Set the metadrop trusted oracle address\\n   *\\n   * @param metadropOracleAddress_ Trusted metadrop oracle address\\n   */\\n  function setMetadropOracleAddress(\\n    address metadropOracleAddress_\\n  ) external onlyPlatformAdmin {\\n    if (metadropOracleAddress_ == address(0)) {\\n      _revert(MetadropOracleCannotBeAddressZero.selector);\\n    }\\n    address oldMetadropOracleAddress = metadropOracleAddress;\\n    metadropOracleAddress = metadropOracleAddress_;\\n    emit OracleAddressUpdated(oldMetadropOracleAddress, metadropOracleAddress_);\\n  }\\n\\n  /**\\n   * @dev function {setMessageValidityInSeconds} onlyPlatformAdmin\\n   *\\n   * Set the validity period of signed messages\\n   *\\n   * @param messageValidityInSeconds_ Validity period in seconds for messages signed by the trusted oracle\\n   */\\n  function setMessageValidityInSeconds(\\n    uint256 messageValidityInSeconds_\\n  ) external onlyPlatformAdmin {\\n    uint16 oldMessageValidityInSeconds = messageValidityInSeconds;\\n    messageValidityInSeconds = uint16(messageValidityInSeconds_);\\n    emit MessageValidityInSecondsUpdated(\\n      oldMessageValidityInSeconds,\\n      messageValidityInSeconds_\\n    );\\n  }\\n\\n  /**\\n   * @dev function {setPlatformTreasury} onlySuperAdmin\\n   *\\n   * Set the address that platform fees will be paid to / can be withdrawn to.\\n   * Note that this is restricted to the highest authority level, the super\\n   * admin. Platform admins can trigger a withdrawal to the treasury, but only\\n   * the default admin can set or alter the treasury address. It is recommended\\n   * that the default admin is highly secured and restrited e.g. a multi-sig.\\n   *\\n   * @param platformTreasury_ New treasury address\\n   */\\n  function setPlatformTreasury(\\n    address platformTreasury_\\n  ) external onlySuperAdmin {\\n    if (platformTreasury_ == address(0)) {\\n      _revert(PlatformTreasuryCannotBeAddressZero.selector);\\n    }\\n    address oldPlatformTreasury = platformTreasury;\\n    platformTreasury = platformTreasury_;\\n    emit PlatformTreasuryUpdated(oldPlatformTreasury, platformTreasury_);\\n  }\\n\\n  /**\\n   * @dev function {setMachineAddress} onlyPlatformAdmin\\n   *\\n   * Set a new machine template address\\n   *\\n   * @param newMachineAddress_ the new machine address\\n   */\\n  function setMachineAddress(\\n    address newMachineAddress_\\n  ) external onlyPlatformAdmin {\\n    if (newMachineAddress_ == address(0)) {\\n      _revert(MachineAddressCannotBeAddressZero.selector);\\n    }\\n    address oldMachineAddress = machineTemplate;\\n    machineTemplate = payable(newMachineAddress_);\\n    emit MachineAddressUpdated(oldMachineAddress, newMachineAddress_);\\n  }\\n\\n  /**\\n   * @dev function {setDriPoolAddress} onlyPlatformAdmin\\n   *\\n   * Set a new launch pool template address\\n   *\\n   * @param newDriPoolAddress_ the new launch pool address\\n   */\\n  function setDriPoolAddress(\\n    address newDriPoolAddress_\\n  ) external onlyPlatformAdmin {\\n    if (newDriPoolAddress_ == address(0)) {\\n      _revert(DriPoolAddressCannotBeAddressZero.selector);\\n    }\\n    address oldDriPoolAddress = driPoolTemplate;\\n    driPoolTemplate = payable(newDriPoolAddress_);\\n    emit DriPoolAddressUpdated(oldDriPoolAddress, newDriPoolAddress_);\\n  }\\n\\n  /**\\n   * @dev function {withdrawETH} onlyPlatformAdmin\\n   *\\n   * A withdraw function to allow ETH to be withdrawn to the treasury\\n   *\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawETH(uint256 amount_) external onlyPlatformAdmin {\\n    (bool success, ) = platformTreasury.call{value: amount_}(\\\"\\\");\\n    if (!success) {\\n      _revert(TransferFailed.selector);\\n    }\\n  }\\n\\n  /**\\n   * @dev function {withdrawERC20} onlyPlatformAdmin\\n   *\\n   * A withdraw function to allow ERC20s to be withdrawn to the treasury\\n   *\\n   * @param token_ The contract address of the token being withdrawn\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawERC20(\\n    IERC20 token_,\\n    uint256 amount_\\n  ) external onlyPlatformAdmin {\\n    token_.safeTransfer(platformTreasury, amount_);\\n  }\\n\\n  /**\\n   * @dev function {createERC20}\\n   *\\n   * Create an ERC-20\\n   *\\n   * @param metaId_ The drop Id being approved\\n   * @param salt_ Salt for create2\\n   * @param erc20Config_ ERC20 configuration\\n   * @param signedMessage_ The signed message object\\n   * @param lockerFee_ The fee for the unicrypt locker\\n   * @param deploymentFee_ The fee for deployment, if any\\n   * @return deployedAddress_ The deployed ERC20 contract address\\n   */\\n  function createERC20(\\n    string calldata metaId_,\\n    bytes32 salt_,\\n    ERC20Config calldata erc20Config_,\\n    SignedDropMessageDetails calldata signedMessage_,\\n    uint256 lockerFee_,\\n    uint256 deploymentFee_\\n  ) external payable notWhenDecommissioned returns (address deployedAddress_) {\\n    // Check the signed message origin and time:\\n    _verifyMessage(signedMessage_);\\n\\n    // We can only proceed if the hash of the passed configuration matches the hash\\n    // signed by our oracle signer:\\n    _checkConfigHashMatches(\\n      metaId_,\\n      salt_,\\n      erc20Config_,\\n      signedMessage_,\\n      lockerFee_,\\n      deploymentFee_\\n    );\\n\\n    // Decode required base parameters:\\n    (\\n      string[2] memory tokenDetails,\\n      bool addLiquidityOnCreate,\\n      bool usesDRIPool\\n    ) = _decodeBaseData(erc20Config_.baseParameters);\\n\\n    address driPool = _processDRIPool(\\n      usesDRIPool,\\n      erc20Config_.poolParameters,\\n      tokenDetails\\n    );\\n\\n    // Deploy the new contract:\\n    address newERC20 = _deployERC20Contract(\\n      salt_,\\n      erc20Config_,\\n      IERC20MachineByMetadrop(machineTemplate),\\n      driPool\\n    );\\n\\n    // Process liquidity operations (if any):\\n    _processLiquidity(\\n      addLiquidityOnCreate,\\n      lockerFee_,\\n      deploymentFee_,\\n      newERC20,\\n      driPool\\n    );\\n\\n    // Emit details of the new ERC20:\\n    _emitOnCreation(metaId_, newERC20, driPool, tokenDetails);\\n\\n    // Return the address of the new contract up the call stack:\\n    return (newERC20);\\n  }\\n\\n  /**\\n   * @dev function {_emitOnCreation} Emit the creation event\\n   *\\n   * @param metaId_ The string ID for this ERC-20 deployment\\n   * @param newERC20_ Address of the new ERC-20\\n   * @param driPool_ Address of the pool (if any)\\n   * @param tokenDetails_ The name [0] and symbol [1] of this token\\n   */\\n  function _emitOnCreation(\\n    string memory metaId_,\\n    address newERC20_,\\n    address driPool_,\\n    string[2] memory tokenDetails_\\n  ) internal {\\n    emit ERC20Created(\\n      metaId_,\\n      _msgSender(),\\n      newERC20_,\\n      driPool_,\\n      tokenDetails_[0],\\n      tokenDetails_[1]\\n    );\\n  }\\n\\n  /**\\n   * @dev function {_processDRIPool} Process DRIPool creation, if applicable.\\n   *\\n   * @param usesDRIPool_ Are we using a DRIPool?\\n   * @param poolParameters_ Pool parameters in bytes.\\n   * @param tokenDetails_ Name and symbol of the token.\\n   * @return driPoolAddress_ address of the launch pool\\n   */\\n  function _processDRIPool(\\n    bool usesDRIPool_,\\n    bytes calldata poolParameters_,\\n    string[2] memory tokenDetails_\\n  ) internal returns (address driPoolAddress_) {\\n    if (usesDRIPool_) {\\n      // Create a minimal proxy DRIPool:\\n      driPoolAddress_ = driPoolTemplate.clone();\\n      // Initialise it:\\n      IERC20DRIPool(driPoolAddress_).initialiseDRIP(\\n        poolParameters_,\\n        tokenDetails_[0],\\n        tokenDetails_[1]\\n      );\\n    } else {\\n      driPoolAddress_ = address(0);\\n    }\\n    return (driPoolAddress_);\\n  }\\n\\n  /**\\n   * @dev function {_processLiquidity} Process liquidity, if relevant.\\n   *\\n   * @param addLiquidityOnCreate_ If we are adding liquidity now\\n   * @param lockerFee_ The fee for the unicrypt locker\\n   * @param deploymentFee_ The fee for deployment, if any\\n   * @param newERC20_ The address of the new ERC20\\n   * @param driPool_ The address of the launch pool\\n\\n   */\\n  function _processLiquidity(\\n    bool addLiquidityOnCreate_,\\n    uint256 lockerFee_,\\n    uint256 deploymentFee_,\\n    address newERC20_,\\n    address driPool_\\n  ) internal {\\n    if (addLiquidityOnCreate_ && (driPool_ == address(0))) {\\n      // Check the fee, we must have enough ETH for the fees, plus at least ONE wei if adding liquidity:\\n      if (msg.value < (lockerFee_ + deploymentFee_)) {\\n        _revert(IncorrectPayment.selector);\\n      }\\n\\n      // Value to pass on (for locking fee plus liquidity, if any) is the sent\\n      // amount minus the deployment fee (if any)\\n      IERC20ByMetadrop(newERC20_).addInitialLiquidity{\\n        value: msg.value - deploymentFee_\\n      }(lockerFee_, 0);\\n    } else {\\n      // Check if we have a DRIPool for this token. If so, we need to initialise the\\n      // token address on the pool. We pass in the DRIPool address on the constructor\\n      // of the ERC-20, but as they BOTH need to know each others address we need to perform\\n      // this update.\\n      // We also fund any intial seed ETH from the project in this call.\\n      if (driPool_ != address(0)) {\\n        // We must have at least the deploymentFee. If we have more, this is ETH that the project\\n        // is seeding into the launch pool\\n        if (msg.value < deploymentFee_) {\\n          _revert(IncorrectPayment.selector);\\n        }\\n\\n        uint256 ethSeedAmount = msg.value - deploymentFee_;\\n\\n        address ethSeeContributor = address(0);\\n        if (ethSeedAmount > 0) {\\n          ethSeeContributor = _msgSender();\\n        }\\n\\n        IERC20DRIPool(driPool_).loadERC20AddressAndSeedETH{\\n          value: ethSeedAmount\\n        }(newERC20_, ethSeeContributor);\\n      } else {\\n        // Check the fee, we must have ETH for ONLY the deployment fee\\n        if (msg.value != deploymentFee_) {\\n          _revert(IncorrectPayment.selector);\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev function {_deployERC20Contract} Deploy the ERC20 using CREATE2\\n   *\\n   * @param salt_ Salt for create2\\n   * @param erc20Config_ ERC20 configuration\\n   * @param machine_ The machine contract\\n   * @param machine_ The address of the launch pool (if any)\\n   * @return erc20ContractAddress_ Address of the newly deployed ERC20\\n   */\\n  function _deployERC20Contract(\\n    bytes32 salt_,\\n    ERC20Config calldata erc20Config_,\\n    IERC20MachineByMetadrop machine_,\\n    address driPool_\\n  ) internal returns (address erc20ContractAddress_) {\\n    address[5] memory integrationAddresses = [\\n      _msgSender(),\\n      uniswapRouter,\\n      unicryptLocker,\\n      address(this),\\n      driPool_\\n    ];\\n\\n    bytes memory args = abi.encode(\\n      integrationAddresses,\\n      erc20Config_.baseParameters,\\n      erc20Config_.supplyParameters,\\n      erc20Config_.taxParameters,\\n      erc20Config_.poolParameters\\n    );\\n\\n    return (machine_.deploy(salt_, args));\\n  }\\n\\n  /**\\n   * @dev function {_decodeBaseData} Create an ERC-20\\n   *\\n   * Decode the name, symbol and if we are adding liquidity on create\\n   *\\n   * @param encodedBaseParams_ Base ERC20 params\\n   * @return tokenDetails_ The name [0] and symbol [1] of this token\\n   * @return addLiquidityOnCreate_ bool to indicate we are adding liquidity on create\\n   * @return usesDRIPool_ bool to indicate we are using a launch pool\\n   */\\n  function _decodeBaseData(\\n    bytes memory encodedBaseParams_\\n  )\\n    internal\\n    pure\\n    returns (\\n      string[2] memory tokenDetails_,\\n      bool addLiquidityOnCreate_,\\n      bool usesDRIPool_\\n    )\\n  {\\n    string memory name;\\n    string memory symbol;\\n\\n    (name, symbol, , , , , addLiquidityOnCreate_, usesDRIPool_) = abi.decode(\\n      encodedBaseParams_,\\n      (string, string, string, string, string, string, bool, bool)\\n    );\\n\\n    return ([name, symbol], addLiquidityOnCreate_, usesDRIPool_);\\n  }\\n\\n  /**\\n   * @dev function {_verifyMessage}\\n   *\\n   * Check the signature and expiry of the passed message\\n   *\\n   * @param signedMessage_ The signed message object\\n   */\\n  function _verifyMessage(\\n    SignedDropMessageDetails calldata signedMessage_\\n  ) internal view {\\n    // Check that this signature is from the oracle signer:\\n    if (\\n      !_validSignature(\\n        signedMessage_.messageHash,\\n        signedMessage_.messageSignature\\n      )\\n    ) {\\n      _revert(InvalidOracleSignature.selector);\\n    }\\n\\n    // Check that the signature has not expired:\\n    unchecked {\\n      if (\\n        (signedMessage_.messageTimeStamp + messageValidityInSeconds) <\\n        block.timestamp\\n      ) {\\n        _revert(OracleSignatureHasExpired.selector);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev function {_validSignature}\\n   *\\n   * Checks the the signature on the signed message is from the metadrop oracle\\n   *\\n   * @param messageHash_ The message hash signed by the trusted oracle signer. This will be the\\n   * keccack256 hash of received data about this token.\\n   * @param messageSignature_ The signed message from the backend oracle signer for validation.\\n   * @return messageIsValid_ If the message is valid (or not)\\n   */\\n  function _validSignature(\\n    bytes32 messageHash_,\\n    bytes memory messageSignature_\\n  ) internal view returns (bool messageIsValid_) {\\n    bytes32 ethSignedMessageHash = keccak256(\\n      abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", messageHash_)\\n    );\\n\\n    // Check the signature is valid:\\n    return (\\n      SignatureChecker.isValidSignatureNow(\\n        metadropOracleAddress,\\n        ethSignedMessageHash,\\n        messageSignature_\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @dev function {_checkConfigHashMatches}\\n   *\\n   * Check the passed config against the stored config hash\\n   *\\n   * @param metaId_ The drop Id being approved\\n   * @param salt_ Salt for create2\\n   * @param erc20Config_ ERC20 configuration\\n   * @param signedMessage_ The signed message object\\n   * @param lockerFee_ The fee for the unicrypt locker\\n   * @param deploymentFee_ The fee for deployment, if any\\n   */\\n  function _checkConfigHashMatches(\\n    string calldata metaId_,\\n    bytes32 salt_,\\n    ERC20Config calldata erc20Config_,\\n    SignedDropMessageDetails calldata signedMessage_,\\n    uint256 lockerFee_,\\n    uint256 deploymentFee_\\n  ) internal view {\\n    // Create the hash of the passed data for comparison:\\n    bytes32 passedConfigHash = createConfigHash(\\n      metaId_,\\n      salt_,\\n      erc20Config_,\\n      signedMessage_.messageTimeStamp,\\n      lockerFee_,\\n      deploymentFee_,\\n      _msgSender()\\n    );\\n\\n    // Must equal the stored hash:\\n    if (passedConfigHash != signedMessage_.messageHash) {\\n      _revert(PassedConfigDoesNotMatchApproved.selector);\\n    }\\n  }\\n\\n  /**\\n   * @dev function {createConfigHash}\\n   *\\n   * Create the config hash\\n   *\\n   * @param metaId_ The drop Id being approved\\n   * @param salt_ Salt for create2\\n   * @param erc20Config_ ERC20 configuration\\n   * @param messageTimeStamp_ When the message for this config hash was signed\\n   * @param lockerFee_ The fee for the unicrypt locker\\n   * @param deploymentFee_ The fee for deployment, if any\\n   * @param deployer_ Address performing the deployment\\n   * @return configHash_ The bytes32 config hash\\n   */\\n  function createConfigHash(\\n    string calldata metaId_,\\n    bytes32 salt_,\\n    ERC20Config calldata erc20Config_,\\n    uint256 messageTimeStamp_,\\n    uint256 lockerFee_,\\n    uint256 deploymentFee_,\\n    address deployer_\\n  ) public pure returns (bytes32 configHash_) {\\n    configHash_ = keccak256(\\n      abi.encodePacked(\\n        metaId_,\\n        salt_,\\n        _createBytesParamsHash(erc20Config_),\\n        messageTimeStamp_,\\n        lockerFee_,\\n        deploymentFee_,\\n        deployer_\\n      )\\n    );\\n\\n    return (configHash_);\\n  }\\n\\n  /**\\n   * @dev function {_createBytesParamsHash}\\n   *\\n   * Create a hash of the bytes params objects\\n   *\\n   * @param erc20Config_ ERC20 configuration\\n   * @return configHash_ The bytes32 config hash\\n   */\\n  function _createBytesParamsHash(\\n    ERC20Config calldata erc20Config_\\n  ) internal pure returns (bytes32 configHash_) {\\n    configHash_ = keccak256(\\n      abi.encodePacked(\\n        erc20Config_.baseParameters,\\n        erc20Config_.supplyParameters,\\n        erc20Config_.taxParameters,\\n        erc20Config_.poolParameters\\n      )\\n    );\\n\\n    return (configHash_);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20Factory/ERC20Factory/IERC20FactoryByMetadrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IConfigStructures} from \\\"../../Global/IConfigStructures.sol\\\";\\nimport {IErrors} from \\\"../../Global/IErrors.sol\\\";\\nimport {IERC20ConfigByMetadrop} from \\\"../ERC20/IERC20ConfigByMetadrop.sol\\\";\\n\\n/**\\n * @dev Metadrop ERC-20 factory, interface\\n */\\ninterface IERC20FactoryByMetadrop is\\n  IConfigStructures,\\n  IErrors,\\n  IERC20ConfigByMetadrop\\n{\\n  event DriPoolAddressUpdated(address oldAddress, address newAddress);\\n\\n  event ERC20Created(\\n    string metaId,\\n    address indexed deployer,\\n    address contractInstance,\\n    address driPoolInstance,\\n    string symbol,\\n    string name\\n  );\\n\\n  event MachineAddressUpdated(address oldAddress, address newAddress);\\n\\n  event OracleAddressUpdated(address oldAddress, address newAddress);\\n\\n  event MessageValidityInSecondsUpdated(\\n    uint256 oldMessageValidityInSeconds,\\n    uint256 newMessageValidityInSeconds\\n  );\\n\\n  event PlatformTreasuryUpdated(address oldAddress, address newAddress);\\n\\n  /**\\n   * @dev function {initialiseMachineAddress}\\n   *\\n   * Initialise the machine template address. This needs to be separate from\\n   * the constructor as the machine needs the factory address on its constructor.\\n   *\\n   * This must ALWAYS be called as part of deployment.\\n   *\\n   * @param machineTemplate_ the machine address\\n   */\\n  function initialiseMachineAddress(address machineTemplate_) external;\\n\\n  /**\\n   * @dev function {decommissionFactory} onlySuperAdmin\\n   *\\n   * Make this factory unusable for creating new ERC20s, forever\\n   *\\n   */\\n  function decommissionFactory() external;\\n\\n  /**\\n   * @dev function {setMetadropOracleAddress} onlyPlatformAdmin\\n   *\\n   * Set the metadrop trusted oracle address\\n   *\\n   * @param metadropOracleAddress_ Trusted metadrop oracle address\\n   */\\n  function setMetadropOracleAddress(address metadropOracleAddress_) external;\\n\\n  /**\\n   * @dev function {setMessageValidityInSeconds} onlyPlatformAdmin\\n   *\\n   * Set the validity period of signed messages\\n   *\\n   * @param messageValidityInSeconds_ Validity period in seconds for messages signed by the trusted oracle\\n   */\\n  function setMessageValidityInSeconds(\\n    uint256 messageValidityInSeconds_\\n  ) external;\\n\\n  /**\\n   * @dev function {setPlatformTreasury} onlySuperAdmin\\n   *\\n   * Set the address that platform fees will be paid to / can be withdrawn to.\\n   * Note that this is restricted to the highest authority level, the super\\n   * admin. Platform admins can trigger a withdrawal to the treasury, but only\\n   * the default admin can set or alter the treasury address. It is recommended\\n   * that the default admin is highly secured and restrited e.g. a multi-sig.\\n   *\\n   * @param platformTreasury_ New treasury address\\n   */\\n  function setPlatformTreasury(address platformTreasury_) external;\\n\\n  /**\\n   * @dev function {setMachineAddress} onlyPlatformAdmin\\n   *\\n   * Set a new machine template address\\n   *\\n   * @param newMachineAddress_ the new machine address\\n   */\\n  function setMachineAddress(address newMachineAddress_) external;\\n\\n  /**\\n   * @dev function {setDriPoolAddress} onlyPlatformAdmin\\n   *\\n   * Set a new launch pool template address\\n   *\\n   * @param newDriPoolAddress_ the new launch pool address\\n   */\\n  function setDriPoolAddress(address newDriPoolAddress_) external;\\n\\n  /**\\n   * @dev function {withdrawETH} onlyPlatformAdmin\\n   *\\n   * A withdraw function to allow ETH to be withdrawn to the treasury\\n   *\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawETH(uint256 amount_) external;\\n\\n  /**\\n   * @dev function {withdrawERC20} onlyPlatformAdmin\\n   *\\n   * A withdraw function to allow ERC20s to be withdrawn to the treasury\\n   *\\n   * @param token_ The contract address of the token being withdrawn\\n   * @param amount_ The amount to withdraw\\n   */\\n  function withdrawERC20(IERC20 token_, uint256 amount_) external;\\n\\n  /**\\n   * @dev function {createERC20}\\n   *\\n   * Create an ERC-20\\n   *\\n   * @param metaId_ The drop Id being approved\\n   * @param salt_ Salt for create2\\n   * @param erc20Config_ ERC20 configuration\\n   * @param signedMessage_ The signed message object\\n   * @param lockerFee_ The fee for the unicrypt locker\\n   * @param deploymentFee_ The fee for deployment, if any\\n   * @return deployedAddress_ The deployed ERC20 contract address\\n   */\\n  function createERC20(\\n    string calldata metaId_,\\n    bytes32 salt_,\\n    ERC20Config calldata erc20Config_,\\n    SignedDropMessageDetails calldata signedMessage_,\\n    uint256 lockerFee_,\\n    uint256 deploymentFee_\\n  ) external payable returns (address deployedAddress_);\\n\\n  /**\\n   * @dev function {createConfigHash}\\n   *\\n   * Create the config hash\\n   *\\n   * @param metaId_ The drop Id being approved\\n   * @param salt_ Salt for create2\\n   * @param erc20Config_ ERC20 configuration\\n   * @param messageTimeStamp_ When the message for this config hash was signed\\n   * @param lockerFee_ The fee for the unicrypt locker\\n   * @param deploymentFee_ The fee for deployment, if any\\n   * @param deployer_ Address performing the deployment\\n   * @return configHash_ The bytes32 config hash\\n   */\\n  function createConfigHash(\\n    string calldata metaId_,\\n    bytes32 salt_,\\n    ERC20Config calldata erc20Config_,\\n    uint256 messageTimeStamp_,\\n    uint256 lockerFee_,\\n    uint256 deploymentFee_,\\n    address deployer_\\n  ) external pure returns (bytes32 configHash_);\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20Factory/ERC20Machine/IERC20MachineByMetadrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.21;\\n\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {IConfigStructures} from \\\"../../Global/IConfigStructures.sol\\\";\\nimport {IERC20ConfigByMetadrop} from \\\"../ERC20/IERC20ConfigByMetadrop.sol\\\";\\nimport {IERC20ByMetadrop, ERC20ByMetadrop} from \\\"../ERC20/ERC20ByMetadrop.sol\\\";\\nimport {IErrors} from \\\"../../Global/IErrors.sol\\\";\\n\\n/**\\n * @dev Metadrop ERC-20 contract deployer\\n *\\n * @dev Implementation of the {IERC20DeployerByMetasdrop} interface.\\n *\\n * Lightweight deployment module for use with template contracts\\n */\\ninterface IERC20MachineByMetadrop is IERC20ConfigByMetadrop, IErrors {\\n  /**\\n   * @dev function {deploy}\\n   *\\n   * Deploy a fresh instance\\n   */\\n  function deploy(\\n    bytes32 salt_,\\n    bytes memory args_\\n  ) external payable returns (address erc20ContractAddress_);\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20Factory/ERC20Pools/IERC20DRIPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Metadrop Contracts (v2.1.0)\\n\\npragma solidity 0.8.21;\\n\\nimport {IERC20ConfigByMetadrop} from \\\"../ERC20/IERC20ConfigByMetadrop.sol\\\";\\nimport {IErrors} from \\\"../../Global/IErrors.sol\\\";\\n\\ninterface IERC20DRIPool is IERC20ConfigByMetadrop, IErrors {\\n  enum PhaseStatus {\\n    beforePoolPhase,\\n    duringPoolPhase,\\n    afterPoolPhase\\n  }\\n\\n  event AddToPool(address dripHolder, uint256 dripTokenMinted);\\n\\n  event ClaimFromPool(\\n    address dripHolder,\\n    uint256 dripTokenBurned,\\n    uint256 pooledTokenClaimed\\n  );\\n\\n  event RefundFromPool(\\n    address dripHolder,\\n    uint256 dripTokenBurned,\\n    uint256 ethRefunded\\n  );\\n\\n  event LiquidityAddedFromPool(uint256 ethTotal, uint256 tokenTotal);\\n\\n  /**\\n   * @dev {initialiseDRIP}\\n   *\\n   * Initalise configuration on a new minimal proxy clone\\n   *\\n   * @param poolParams_ bytes parameter object that will be decoded into configuration\\n   * items.\\n   * @param name_ the name of the associated ERC20 token\\n   * @param symbol_ the symbol of the associated ERC20 token\\n   */\\n  function initialiseDRIP(\\n    bytes calldata poolParams_,\\n    string calldata name_,\\n    string calldata symbol_\\n  ) external;\\n\\n  /**\\n   * @dev {supplyForLP}\\n   *\\n   * Convenience function to return the LP supply from the ERC-20 token contract.\\n   *\\n   * @return supplyForLP_ The total supply for LP creation.\\n   */\\n  function supplyForLP() external view returns (uint256 supplyForLP_);\\n\\n  /**\\n   * @dev {poolPhaseStatus}\\n   *\\n   * Convenience function to return the pool status in string format.\\n   *\\n   * @return poolPhaseStatus_ The pool phase status as a string\\n   */\\n  function poolPhaseStatus()\\n    external\\n    view\\n    returns (string memory poolPhaseStatus_);\\n\\n  /**\\n   * @dev {vestingEndDate}\\n   *\\n   * The vesting end date, being the end of the pool phase plus number of days vesting, if any\\n   *\\n   * @return vestingEndDate_ The vesting end date as a timestamp\\n   */\\n  function vestingEndDate() external view returns (uint256 vestingEndDate_);\\n\\n  /**\\n   * @dev Return if the pool total has exceeded the minimum:\\n   *\\n   * @return poolIsAboveMinimum_ If the pool is above the minimum (or not)\\n   */\\n  function poolIsAboveMinimum()\\n    external\\n    view\\n    returns (bool poolIsAboveMinimum_);\\n\\n  /**\\n   * @dev {loadERC20AddressAndSeedETH}\\n   *\\n   * Load the target ERC-20 address. This is called by the factory in the same transaction as the clone\\n   * is instantiated\\n   *\\n   * @param createdERC20_ The ERC-20 address\\n   * @param poolCreator_ The creator of this pool\\n   */\\n  function loadERC20AddressAndSeedETH(\\n    address createdERC20_,\\n    address poolCreator_\\n  ) external payable;\\n\\n  /**\\n   * @dev {addToPool}\\n   *\\n   * A user calls this to contribute to the pool\\n   *\\n   * Note that we could have used the receive method for this, and processed any ETH send to the\\n   * contract as a contribution to the pool. We've opted for the clarity of a specific method,\\n   * with the recieve method reverting an unidentified ETH.\\n   */\\n  function addToPool() external payable;\\n\\n  /**\\n   * @dev {claimFromPool}\\n   *\\n   * A user calls this to burn their DRIP and claim their ERC-20 tokens\\n   *\\n   */\\n  function claimFromPool() external;\\n\\n  /**\\n   * @dev {refundFromPool}\\n   *\\n   * A user calls this to burn their DRIP and claim an ETH refund where the\\n   * minimum ETH pooled amount was not exceeded\\n   *\\n   */\\n  function refundFromPool() external;\\n\\n  /**\\n   * @dev {supplyLiquidity}\\n   *\\n   * When the pool phase is over this can be called to supply the pooled ETH to\\n   * the token contract. There it will be forwarded along with the LP supply of\\n   * tokens to uniswap to create the funded pair\\n   *\\n   * Note that this function can be called by anyone. While clearly it is likely\\n   * that this will be the project team, having this method open to anyone ensures that\\n   * liquidity will not be trapped in this contract if the team as unable to perform\\n   * this action.\\n   *\\n   * @param lockerFee_ The ETH fee required to lock LP tokens\\n   *\\n   */\\n  function supplyLiquidity(uint256 lockerFee_) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/Global/AuthorityModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title AuthorityModel.sol. Library for global authority components\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.21;\\n\\n/**\\n *\\n * @dev Inheritance details:\\n *      EnumerableSet           OZ enumerable mapping sets\\n *      IErrors                 Interface for platform error definitions\\n *\\n */\\n\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {IErrors} from \\\"./IErrors.sol\\\";\\nimport {Revert} from \\\"./Revert.sol\\\";\\n\\ncontract AuthorityModel is IErrors, Revert {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  event SuperAdminTransferred(address oldSuperAdmin, address newSuperAdmin);\\n  event PlatformAdminAdded(address platformAdmin);\\n  event PlatformAdminRevoked(address platformAdmin);\\n\\n  // Address for the factory:\\n  address public factory;\\n\\n  // The super admin can grant and revoke roles\\n  address public superAdmin;\\n\\n  //\u00a0Enumerable set to store platform admins:\\n  EnumerableSet.AddressSet private _platformAdmins;\\n\\n  /** ====================================================================================================================\\n   *                                                       MODIFIERS\\n   * =====================================================================================================================\\n   */\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                     -->ACCESS CONTROL\\n   * @dev (modifier) onlySuperAdmin. The associated action can only be taken by the super admin (an address with the\\n   * default admin role).\\n   *\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  modifier onlySuperAdmin() {\\n    if (!isSuperAdmin(msg.sender)) revert CallerIsNotSuperAdmin(msg.sender);\\n    _;\\n  }\\n\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                     -->ACCESS CONTROL\\n   * @dev (modifier) onlyPlatformAdmin. The associated action can only be taken by an address with the\\n   * platform admin role.\\n   *\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  modifier onlyPlatformAdmin() {\\n    if (!isPlatformAdmin(msg.sender))\\n      revert CallerIsNotPlatformAdmin(msg.sender);\\n    _;\\n  }\\n\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                             -->GETTER\\n   * @dev (function) isSuperAdmin   check if an address is the super admin\\n   *\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * @return bool\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  function isSuperAdmin(address queryAddress_) public view returns (bool) {\\n    return (superAdmin == queryAddress_);\\n  }\\n\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                             -->GETTER\\n   * @dev (function) isPlatformAdmin   check if an address is a platform admin\\n   *\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * @return bool\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  function isPlatformAdmin(address queryAddress_) public view returns (bool) {\\n    return (_platformAdmins.contains(queryAddress_));\\n  }\\n\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                     -->ACCESS CONTROL\\n   * @dev (function) grantPlatformAdmin  Allows the super user Default Admin to add an address to the platform admin group\\n   *\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * @param newPlatformAdmin_              The address of the new platform admin\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  function grantPlatformAdmin(address newPlatformAdmin_) public onlySuperAdmin {\\n    if (newPlatformAdmin_ == address(0)) {\\n      _revert(PlatformAdminCannotBeAddressZero.selector);\\n    }\\n    // Add this to the enumerated list:\\n    _platformAdmins.add(newPlatformAdmin_);\\n    emit PlatformAdminAdded(newPlatformAdmin_);\\n  }\\n\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                     -->ACCESS CONTROL\\n   * @dev (function) revokePlatformAdmin  Allows the super user Default Admin to revoke from the platform admin group\\n   *\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * @param oldPlatformAdmin_              The address of the old platform admin\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  function revokePlatformAdmin(\\n    address oldPlatformAdmin_\\n  ) public onlySuperAdmin {\\n    // Remove this from the enumerated list:\\n    _platformAdmins.remove(oldPlatformAdmin_);\\n    emit PlatformAdminRevoked(oldPlatformAdmin_);\\n  }\\n\\n  /** ____________________________________________________________________________________________________________________\\n   *                                                                                                     -->ACCESS CONTROL\\n   * @dev (function) transferSuperAdmin  Allows the super user Default Admin to transfer this right to another address\\n   *\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * @param newSuperAdmin_              The address of the new default admin\\n   * ---------------------------------------------------------------------------------------------------------------------\\n   * _____________________________________________________________________________________________________________________\\n   */\\n  function transferSuperAdmin(address newSuperAdmin_) public onlySuperAdmin {\\n    address oldSuperAdmin = superAdmin;\\n    // Update storage of this address:\\n    superAdmin = newSuperAdmin_;\\n    emit SuperAdminTransferred(oldSuperAdmin, newSuperAdmin_);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/Decommissionable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title Decommissionable.sol. Simple contract to implement a decommission 'kill switch'\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.21;\\n\\nimport {IErrors} from \\\"./IErrors.sol\\\";\\nimport {Revert} from \\\"./Revert.sol\\\";\\n\\nabstract contract Decommissionable is IErrors, Revert {\\n  bool internal _decommissioned;\\n\\n  event Decomissioned();\\n\\n  /**\\n   * @dev {notWhenDecommissioned}\\n   *\\n   * Throws if the contract has been decommissioned\\n   */\\n  modifier notWhenDecommissioned() {\\n    if (_decommissioned) {\\n      _revert(ContractIsDecommissioned.selector);\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @dev Internal method to set the decommissioned flag. Should be called\\n   * by an external method with access control (e.g. ownable etc.)\\n   */\\n  function _decommission() internal {\\n    _decommissioned = true;\\n    emit Decomissioned();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/IConfigStructures.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title IConfigStructures.sol. Interface for common config structures used accross the platform\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.21;\\n\\ninterface IConfigStructures {\\n  enum DropStatus {\\n    approved,\\n    deployed,\\n    cancelled\\n  }\\n\\n  enum TemplateStatus {\\n    live,\\n    terminated\\n  }\\n\\n  // The current status of the mint:\\n  //   - notEnabled: This type of mint is not part of this drop\\n  //   - notYetOpen: This type of mint is part of the drop, but it hasn't started yet\\n  //   - open: it's ready for ya, get in there.\\n  //   - finished: been and gone.\\n  //   - unknown: theoretically impossible.\\n  enum MintStatus {\\n    notEnabled,\\n    notYetOpen,\\n    open,\\n    finished,\\n    unknown\\n  }\\n\\n  struct SubListConfig {\\n    uint256 start;\\n    uint256 end;\\n    uint256 phaseMaxSupply;\\n  }\\n\\n  struct PrimarySaleModuleInstance {\\n    address instanceAddress;\\n    string instanceDescription;\\n  }\\n\\n  struct NFTModuleConfig {\\n    uint256 templateId;\\n    bytes configData;\\n    bytes vestingData;\\n  }\\n\\n  struct PrimarySaleModuleConfig {\\n    uint256 templateId;\\n    bytes configData;\\n  }\\n\\n  struct ProjectBeneficiary {\\n    address payable payeeAddress;\\n    uint256 payeeShares;\\n  }\\n\\n  struct VestingConfig {\\n    uint256 start;\\n    uint256 projectUpFrontShare;\\n    uint256 projectVestedShare;\\n    uint256 vestingPeriodInDays;\\n    uint256 vestingCliff;\\n    ProjectBeneficiary[] projectPayees;\\n  }\\n\\n  struct RoyaltySplitterModuleConfig {\\n    uint256 templateId;\\n    bytes configData;\\n  }\\n\\n  struct InLifeModuleConfig {\\n    uint256 templateId;\\n    bytes configData;\\n  }\\n\\n  struct InLifeModules {\\n    InLifeModuleConfig[] modules;\\n  }\\n\\n  struct NFTConfig {\\n    uint256 supply;\\n    string name;\\n    string symbol;\\n    bytes32 positionProof;\\n    bool includePriorPhasesInMintTracking;\\n    bool singleMetadataCollection;\\n    uint256 reservedAllocation;\\n    uint256 assistanceRequestWindowInSeconds;\\n  }\\n\\n  struct Template {\\n    TemplateStatus status;\\n    uint16 templateNumber;\\n    uint32 loadedDate;\\n    address payable templateAddress;\\n    string templateDescription;\\n  }\\n\\n  struct RoyaltyDetails {\\n    address newRoyaltyPaymentSplitterInstance;\\n    uint96 royaltyFromSalesInBasisPoints;\\n  }\\n\\n  struct SignedDropMessageDetails {\\n    uint256 messageTimeStamp;\\n    bytes32 messageHash;\\n    bytes messageSignature;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/IErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title IErrors.sol. Interface for error definitions used across the platform\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.21;\\n\\ninterface IErrors {\\n  enum BondingCurveErrorType {\\n    OK, //                                                  No error\\n    INVALID_NUMITEMS, //                                    The numItem value is 0\\n    SPOT_PRICE_OVERFLOW //                                  The updated spot price doesn't fit into 128 bits\\n  }\\n\\n  error AdapterParamsMustBeEmpty(); //                      The adapter parameters on this LZ call must be empty.\\n\\n  error AdditionToPoolIsBelowPerTransactionMinimum(); //    The contribution amount is less than the minimum.\\n\\n  error AdditionToPoolWouldExceedPoolCap(); //              This addition to the pool would exceed the pool cap.\\n\\n  error AdditionToPoolWouldExceedPerAddressCap(); //        This addition to the pool would exceed the per address cap.\\n\\n  error AddressAlreadySet(); //                             The address being set can only be set once, and is already non-0.\\n\\n  error AllowanceDecreasedBelowZero(); //                   You cannot decrease the allowance below zero.\\n\\n  error AlreadyInitialised(); //                            The contract is already initialised: it cannot be initialised twice!\\n\\n  error ApprovalCallerNotOwnerNorApproved(); //             The caller must own the token or be an approved operator.\\n\\n  error ApproveFromTheZeroAddress(); //                     Approval cannot be called from the zero address (indeed, how have you??).\\n\\n  error ApproveToTheZeroAddress(); //                       Approval cannot be given to the zero address.\\n\\n  error ApprovalQueryForNonexistentToken(); //              The token does not exist.\\n\\n  error AuctionStatusIsNotEnded(); //                       Throw if the action required the auction to be closed, and it isn't.\\n\\n  error AuctionStatusIsNotOpen(); //                        Throw if the action requires the auction to be open, and it isn't.\\n\\n  error AuxCallFailed(\\n    address[] modules,\\n    uint256 value,\\n    bytes data,\\n    uint256 txGas\\n  ); //                                                     An auxilliary call from the drop factory failed.\\n\\n  error BalanceQueryForZeroAddress(); //                    Cannot query the balance for the zero address.\\n\\n  error BidMustBeBelowTheFloorWhenReducingQuantity(); //    Only bids that are below the floor can reduce the quantity of the bid.\\n\\n  error BidMustBeBelowTheFloorForRefundDuringAuction(); //  Only bids that are below the floor can be refunded during the auction.\\n\\n  error BondingCurveError(BondingCurveErrorType error); //  An error of the type specified has occured in bonding curve processing.\\n\\n  error BurnExceedsBalance(); //                            The amount you have selected to burn exceeds the addresses balance.\\n\\n  error BurnFromTheZeroAddress(); //                        Tokens cannot be burned from the zero address. (Also, how have you called this!?!)\\n\\n  error CallerIsNotFactory(); //                            The caller of this function must match the factory address in storage.\\n\\n  error CallerIsNotFactoryOrProjectOwner(); //              The caller of this function must match the factory address OR project owner address.\\n\\n  error CallerIsNotFactoryProjectOwnerOrPool(); //          The caller of this function must match the factory address, project owner or pool address.\\n\\n  error CallerIsNotTheOwner(); //                           The caller is not the owner of this contract.\\n\\n  error CallerIsNotTheManager(); //                         The caller is not the manager of this contract.\\n\\n  error CallerMustBeLzApp(); //                             The caller must be an LZ application.\\n\\n  error CallerIsNotPlatformAdmin(address caller); //        The caller of this function must be part of the platformAdmin group.\\n\\n  error CallerIsNotSuperAdmin(address caller); //           The caller of this function must match the superAdmin address in storage.\\n\\n  error CannotAddLiquidityOnCreateAndUseDRIPool(); //       Cannot use both liquidity added on create and a DRIPool in the same token.\\n\\n  error CannotSetNewOwnerToTheZeroAddress(); //             You can't set the owner of this contract to the zero address (address(0)).\\n\\n  error CannotSetToZeroAddress(); //                        The corresponding address cannot be set to the zero address (address(0)).\\n\\n  error CannotSetNewManagerToTheZeroAddress(); //           Cannot transfer the manager to the zero address (address(0)).\\n\\n  error CannotWithdrawThisToken(); //                       Cannot withdraw the specified token.\\n\\n  error CollectionAlreadyRevealed(); //                     The collection is already revealed; you cannot call reveal again.\\n\\n  error ContractIsDecommissioned(); //                      This contract is decommissioned!\\n\\n  error ContractIsPaused(); //                              The call requires the contract to be unpaused, and it is paused.\\n\\n  error ContractIsNotPaused(); //                           The call required the contract to be paused, and it is NOT paused.\\n\\n  error DecreasedAllowanceBelowZero(); //                   The request would decrease the allowance below zero, and that is not allowed.\\n\\n  error DestinationIsNotTrustedSource(); //                 The destination that is being called through LZ has not been set as trusted.\\n\\n  error DeployerOnly(); //                                  This method can only be called by the deployer address.\\n\\n  error DriPoolAddressCannotBeAddressZero(); //             The Dri Pool address cannot be the zero address.\\n\\n  error GasLimitIsTooLow(); //                              The gas limit for the LayerZero call is too low.\\n\\n  error IncorrectConfirmationValue(); //                    You need to enter the right confirmation value to call this funtion (usually 69420).\\n\\n  error IncorrectPayment(); //                              The function call did not include passing the correct payment.\\n\\n  error InitialLiquidityAlreadyAdded(); //                  Initial liquidity has already been added. You can't do it again.\\n\\n  error InitialLiquidityNotYetAdded(); //                   Initial liquidity needs to have been added for this to succedd.\\n\\n  error InsufficientAllowance(); //                         There is not a high enough allowance for this operation.\\n\\n  error InvalidAdapterParams(); //                          The current adapter params for LayerZero on this contract won't work :(.\\n\\n  error InvalidAddress(); //                                An address being processed in the function is not valid.\\n\\n  error InvalidEndpointCaller(); //                         The calling address is not a valid LZ endpoint. The LZ endpoint was set at contract creation\\n  //                                                        and cannot be altered after. Check the address LZ endpoint address on the contract.\\n\\n  error InvalidMinGas(); //                                 The minimum gas setting for LZ in invalid.\\n\\n  error InvalidOracleSignature(); //                        The signature provided with the contract call is not valid, either in format or signer.\\n\\n  error InvalidPayload(); //                                The LZ payload is invalid\\n\\n  error InvalidReceiver(); //                               The address used as a target for funds is not valid.\\n\\n  error InvalidSourceSendingContract(); //                  The LZ message is being related from a source contract on another chain that is NOT trusted.\\n\\n  error InvalidTotalShares(); //                            Total shares must equal 100 percent in basis points.\\n\\n  error ListLengthMismatch(); //                            Two or more lists were compared and they did not match length.\\n\\n  error LiquidityPoolMustBeAContractAddress(); //           Cannot add a non-contract as a liquidity pool.\\n\\n  error LiquidityPoolCannotBeAddressZero(); //              Cannot add a liquidity pool from the zero address.\\n\\n  error LPLockUpMustFitUint96(); //                         LP lockup is held in a uint96, so must fit.\\n\\n  error NoTrustedPathRecord(); //                           LZ needs a trusted path record for this to work. What's that, you ask?\\n\\n  error MachineAddressCannotBeAddressZero(); //             Cannot set the machine address to the zero address.\\n\\n  error ManagerUnauthorizedAccount(); //                    The caller is not the pending manager.\\n\\n  error MaxBidQuantityIs255(); //                           Validation: as we use a uint8 array to track bid positions the max bid quantity is 255.\\n\\n  error MaxPublicMintAllowanceExceeded(\\n    uint256 requested,\\n    uint256 alreadyMinted,\\n    uint256 maxAllowance\\n  ); //                                                     The calling address has requested a quantity that would exceed the max allowance.\\n\\n  error MaxSupplyTooHigh(); //                              Max supply must fit in a uint128.\\n\\n  error MaxTokensPerWalletExceeded(); //                    The transfer would exceed the max tokens per wallet limit.\\n\\n  error MaxTokensPerTxnExceeded(); //                       The transfer would exceed the max tokens per transaction limit.\\n\\n  error MetadataIsLocked(); //                              The metadata on this contract is locked; it cannot be altered!\\n\\n  error MetadropFactoryOnlyOncePerReveal(); //              This function can only be called (a) by the factory and, (b) just one time!\\n\\n  error MetadropModulesOnly(); //                           Can only be called from a metadrop contract.\\n\\n  error MetadropOracleCannotBeAddressZero(); //             The metadrop Oracle cannot be the zero address (address(0)).\\n\\n  error MinGasLimitNotSet(); //                             The minimum gas limit for LayerZero has not been set.\\n\\n  error MintERC2309QuantityExceedsLimit(); //               The `quantity` minted with ERC2309 exceeds the safety limit.\\n\\n  error MintingIsClosedForever(); //                        Minting is, as the error suggests, so over (and locked forever).\\n\\n  error MintToZeroAddress(); //                             Cannot mint to the zero address.\\n\\n  error MintZeroQuantity(); //                              The quantity of tokens minted must be more than zero.\\n\\n  error NewBuyTaxBasisPointsExceedsMaximum(); //            Project owner trying to set the tax rate too high.\\n\\n  error NewSellTaxBasisPointsExceedsMaximum(); //           Project owner trying to set the tax rate too high.\\n\\n  error NoETHForLiquidityPair(); //                         No ETH has been provided for the liquidity pair.\\n\\n  error TaxPeriodStillInForce(); //                         The minimum tax period has not yet expired.\\n\\n  error NoPaymentDue(); //                                  No payment is due for this address.\\n\\n  error NoRefundForCaller(); //                             Error thrown when the calling address has no refund owed.\\n\\n  error NoStoredMessage(); //                               There is no stored message matching the passed parameters.\\n\\n  error NothingToClaim(); //                                The calling address has nothing to claim.\\n\\n  error NoTokenForLiquidityPair(); //                       There is no token to add to the LP.\\n\\n  error OperationDidNotSucceed(); //                        The operation failed (vague much?).\\n\\n  error OracleSignatureHasExpired(); //                     A signature has been provided but it is too old.\\n\\n  error OwnableUnauthorizedAccount(); //                    The caller is not the pending owner.\\n\\n  error OwnershipNotInitializedForExtraData(); //           The `extraData` cannot be set on an uninitialized ownership slot.\\n\\n  error OwnerQueryForNonexistentToken(); //                 The token does not exist.\\n\\n  error ParametersDoNotMatchSignedMessage(); //             The parameters passed with the signed message do not match the message itself.\\n\\n  error ParamTooLargeStartDate(); //                        The passed parameter exceeds the var type max.\\n\\n  error ParamTooLargeEndDate(); //                          The passed parameter exceeds the var type max.\\n\\n  error ParamTooLargeMinETH(); //                           The passed parameter exceeds the var type max.\\n\\n  error ParamTooLargePerAddressMax(); //                    The passed parameter exceeds the var type max.\\n\\n  error ParamTooLargeVestingDays(); //                      The passed parameter exceeds the var type max.\\n\\n  error ParamTooLargePoolSupply(); //                       The passed parameter exceeds the var type max.\\n\\n  error ParamTooLargePoolPerTxnMinETH(); //                 The passed parameter exceeds the var type max.\\n\\n  error PassedConfigDoesNotMatchApproved(); //              The config provided on the call does not match the approved config.\\n\\n  error PauseCutOffHasPassed(); //                          The time period in which we can pause has passed; this contract can no longer be paused.\\n\\n  error PaymentMustCoverPerMintFee(); //                    The payment passed must at least cover the per mint fee for the quantity requested.\\n\\n  error PermitDidNotSucceed(); //                           The safeERC20 permit failed.\\n\\n  error PlatformAdminCannotBeAddressZero(); //              We cannot use the zero address (address(0)) as a platformAdmin.\\n\\n  error PlatformTreasuryCannotBeAddressZero(); //           The treasury address cannot be set to the zero address.\\n\\n  error PoolIsAboveMinimum(); //                            You required the pool to be below the minimum, and it is not\\n\\n  error PoolIsBelowMinimum(); //                            You required the pool to be above the minimum, and it is not\\n\\n  error PoolPhaseIsClosed(); //                             The block.timestamp is either before the pool is open or after it is closed.\\n\\n  error PoolPhaseIsNotAfter(); //                           The block.timestamp is either before or during the pool open phase.\\n\\n  error PoolVestingNotYetComplete(); //                     Tokens in the pool are not yet vested.\\n\\n  error ProjectOwnerCannotBeAddressZero(); //               The project owner has to be a non zero address.\\n\\n  error ProofInvalid(); //                                  The provided proof is not valid with the provided arguments.\\n\\n  error QuantityExceedsRemainingCollectionSupply(); //      The requested quantity would breach the collection supply.\\n\\n  error QuantityExceedsRemainingPhaseSupply(); //           The requested quantity would breach the phase supply.\\n\\n  error QuantityExceedsMaxPossibleCollectionSupply(); //    The requested quantity would breach the maximum trackable supply\\n\\n  error ReferralIdAlreadyUsed(); //                         This referral ID has already been used; they are one use only.\\n\\n  error RequestingMoreThanRemainingAllocation(\\n    uint256 previouslyMinted,\\n    uint256 requested,\\n    uint256 remainingAllocation\\n  ); //                                                     Number of tokens requested for this mint exceeds the remaining allocation (taking the\\n  //                                                        original allocation from the list and deducting minted tokens).\\n\\n  error RoyaltyFeeWillExceedSalePrice(); //                 The ERC2981 royalty specified will exceed the sale price.\\n\\n  error ShareTotalCannotBeZero(); //                        The total of all the shares cannot be nothing.\\n\\n  error SliceOutOfBounds(); //                              The bytes slice operation was out of bounds.\\n\\n  error SliceOverflow(); //                                 The bytes slice operation overlowed.\\n\\n  error SuperAdminCannotBeAddressZero(); //                 The superAdmin cannot be the sero address (address(0)).\\n\\n  error SupplyTotalMismatch(); //                           The sum of the team supply and lp supply does not match.\\n\\n  error SupportWindowIsNotOpen(); //                        The project owner has not requested support within the support request expiry window.\\n\\n  error TaxFreeAddressCannotBeAddressZero(); //             A tax free address cannot be address(0)\\n\\n  error TemplateCannotBeAddressZero(); //                   The address for a template cannot be address zero (address(0)).\\n\\n  error TemplateNotFound(); //                              There is no template that matches the passed template Id.\\n\\n  error ThisMintIsClosed(); //                              It's over (well, this mint is, anyway).\\n\\n  error TotalSharesMustMatchDenominator(); //               The total of all shares must equal the denominator value.\\n\\n  error TransferAmountExceedsBalance(); //                  The transfer amount exceeds the accounts available balance.\\n\\n  error TransferCallerNotOwnerNorApproved(); //             The caller must own the token or be an approved operator.\\n\\n  error TransferFailed(); //                                The transfer has failed.\\n\\n  error TransferFromIncorrectOwner(); //                    The token must be owned by `from`.\\n\\n  error TransferToNonERC721ReceiverImplementer(); //        Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\\n\\n  error TransferFromZeroAddress(); //                       Cannot transfer from the zero address. Indeed, this surely is impossible, and likely a waste to check??\\n\\n  error TransferToZeroAddress(); //                         Cannot transfer to the zero address.\\n\\n  error UnrecognisedVRFMode(); //                           Currently supported VRF modes are 0: chainlink and 1: arrng\\n\\n  error URIQueryForNonexistentToken(); //                   The token does not exist.\\n\\n  error ValueExceedsMaximum(); //                           The value sent exceeds the maximum allowed (super useful explanation huh?).\\n\\n  error VRFCoordinatorCannotBeAddressZero(); //             The VRF coordinator cannot be the zero address (address(0)).\\n}\\n\"\r\n    },\r\n    \"contracts/Global/Manager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n// Metadrop based on OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity 0.8.21;\\n\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {IErrors} from \\\"./IErrors.sol\\\";\\nimport {Revert} from \\\"./Revert.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Manager is IErrors, Revert, Context {\\n  address private _manager;\\n\\n  event ManagerTransferred(\\n    address indexed previousManager,\\n    address indexed newManager\\n  );\\n\\n  constructor() {}\\n\\n  /**\\n   * @dev Throws if called by any account other than the manager.\\n   */\\n  modifier onlyManager() {\\n    _checkManager();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current manager.\\n   */\\n  function manager() public view virtual returns (address) {\\n    return _manager;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the manager.\\n   */\\n  function _checkManager() internal view virtual {\\n    if (manager() != _msgSender()) {\\n      _revert(CallerIsNotTheManager.selector);\\n    }\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without a manager. It will not be possible to call\\n   * `onlyManager` functions. Can only be called by the current manager.\\n   *\\n   * NOTE: Renouncing manager will leave the contract without an tax admim,\\n   * thereby disabling any functionality that is only available to the manager.\\n   */\\n  function renounceManager() public virtual onlyManager {\\n    _transferManager(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers the manager of the contract to a new account (`newManager`).\\n   * Can only be called by the current manager.\\n   */\\n  function transferManager(address newManager) public virtual onlyManager {\\n    if (newManager == address(0)) {\\n      _revert(CannotSetNewManagerToTheZeroAddress.selector);\\n    }\\n    _transferManager(newManager);\\n  }\\n\\n  /**\\n   * @dev Transfers the manager of the contract to a new account (`newManager`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferManager(address newManager) internal virtual {\\n    address oldManager = _manager;\\n    _manager = newManager;\\n    emit ManagerTransferred(oldManager, newManager);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/Manager2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n// Metadrop based on OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity 0.8.21;\\n\\nimport {Manager} from \\\"./Manager.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (a manager) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial manager is specified at deployment time in the constructor for `Manager`. This\\n * can later be changed with {transferManager} and {acceptManager}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Manager).\\n */\\nabstract contract Manager2Step is Manager {\\n  address private _pendingManager;\\n\\n  event ManagerTransferStarted(\\n    address indexed previousManager,\\n    address indexed newManager\\n  );\\n\\n  /**\\n   * @dev Returns the address of the pending manager.\\n   */\\n  function pendingManager() public view virtual returns (address) {\\n    return _pendingManager;\\n  }\\n\\n  /**\\n   * @dev Starts the manager transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n   * Can only be called by the current manager.\\n   */\\n  function transferManager(\\n    address newManager\\n  ) public virtual override onlyManager {\\n    _pendingManager = newManager;\\n    emit ManagerTransferStarted(manager(), newManager);\\n  }\\n\\n  /**\\n   * @dev Transfers manager of the contract to a new account (`newManager`) and deletes any pending manager.\\n   * Internal function without access restriction.\\n   */\\n  function _transferManager(address newManager) internal virtual override {\\n    delete _pendingManager;\\n    super._transferManager(newManager);\\n  }\\n\\n  /**\\n   * @dev The new manager accepts the manager transfer.\\n   */\\n  function acceptManager() public virtual {\\n    address sender = _msgSender();\\n    if (pendingManager() != sender) {\\n      _revert(ManagerUnauthorizedAccount.selector);\\n    }\\n    _transferManager(sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/OZ/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n// Metadrop based on OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity 0.8.21;\\n\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {IErrors} from \\\"../IErrors.sol\\\";\\nimport {Revert} from \\\"../Revert.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is IErrors, Revert, Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    if (owner() != _msgSender()) {\\n      _revert(CallerIsNotTheOwner.selector);\\n    }\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby disabling any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    if (newOwner == address(0)) {\\n      _revert(CannotSetNewOwnerToTheZeroAddress.selector);\\n    }\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/OZ/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n// Metadrop based on OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity 0.8.21;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n  address private _pendingOwner;\\n\\n  event OwnershipTransferStarted(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev Returns the address of the pending owner.\\n   */\\n  function pendingOwner() public view virtual returns (address) {\\n    return _pendingOwner;\\n  }\\n\\n  /**\\n   * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(\\n    address newOwner\\n  ) public virtual override onlyOwner {\\n    _pendingOwner = newOwner;\\n    emit OwnershipTransferStarted(owner(), newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual override {\\n    delete _pendingOwner;\\n    super._transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev The new owner accepts the ownership transfer.\\n   */\\n  function acceptOwnership() public virtual {\\n    address sender = _msgSender();\\n    if (pendingOwner() != sender) {\\n      _revert(OwnableUnauthorizedAccount.selector);\\n    }\\n    _transferOwnership(sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/OZ/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n// Metadrop based on OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity 0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {IErrors} from \\\"../IErrors.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  /**\\n   * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n   * non-reverting calls are assumed to be successful.\\n   */\\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n    _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n  }\\n\\n  /**\\n   * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n   * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n   */\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeCall(token.transferFrom, (from, to, value))\\n    );\\n  }\\n\\n  /**\\n   * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n   * non-reverting calls are assumed to be successful.\\n   */\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 oldAllowance = token.allowance(address(this), spender);\\n    forceApprove(token, spender, oldAllowance + value);\\n  }\\n\\n  /**\\n   * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n   * non-reverting calls are assumed to be successful.\\n   */\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    unchecked {\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\n      if (oldAllowance < value) {\\n        revert IErrors.DecreasedAllowanceBelowZero();\\n      }\\n      forceApprove(token, spender, oldAllowance - value);\\n    }\\n  }\\n\\n  /**\\n   * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n   * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n   * 0 before setting it to a non-zero value.\\n   */\\n  function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n    bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n    if (!_callOptionalReturnBool(token, approvalCall)) {\\n      _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n      _callOptionalReturn(token, approvalCall);\\n    }\\n  }\\n\\n  /**\\n   * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n   * Revert on invalid signature.\\n   */\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    if (nonceAfter != (nonceBefore + 1)) {\\n      revert IErrors.PermitDidNotSucceed();\\n    }\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \\\"call fail\\\");\\n    if ((returndata.length != 0) && !abi.decode(returndata, (bool))) {\\n      revert IErrors.OperationDidNotSucceed();\\n    }\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   *\\n   * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n   */\\n  function _callOptionalReturnBool(\\n    IERC20 token,\\n    bytes memory data\\n  ) private returns (bool) {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n    // and not revert is the subcall reverts.\\n\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    return\\n      success &&\\n      (returndata.length == 0 || abi.decode(returndata, (bool))) &&\\n      address(token).code.length > 0;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Global/Revert.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Metadrop Contracts (v2.1.0)\\n\\n/**\\n *\\n * @title Revert.sol. For efficient reverts\\n *\\n * @author metadrop https://metadrop.com/\\n *\\n */\\n\\npragma solidity 0.8.21;\\n\\nabstract contract Revert {\\n  /**\\n   * @dev For more efficient reverts.\\n   */\\n  function _revert(bytes4 errorSelector) internal pure {\\n    assembly {\\n      mstore(0x00, errorSelector)\\n      revert(0x00, 0x04)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ThirdParty/omnus/ERC20Spendable/ERC20Spendable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n// Omnus Contracts v3\\n// https://omn.us/spendable\\n// https://github.com/omnus/ERC20Spendable\\n// npm: @omnus/ERC20Spendable\\n\\npragma solidity 0.8.21;\\n\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {IERC20Spendable} from \\\"./IERC20Spendable.sol\\\";\\nimport {IERC20SpendableReceiver} from \\\"./IERC20SpendableReceiver.sol\\\";\\n\\n/**\\n * @title ERC-7492 ERC20Spendable.sol\\n *\\n * @author omnus\\n * https://omn.us\\n *\\n * @dev Implementation of {ERC20Spendable}.\\n *\\n * {ERC-7492 ERC20Spendable} allows ERC20s to operate as 'spendable' items, i.e. an ERC20 token that\\n * can trigger an action on another contract at the same time as being transfered. Similar to ERC677\\n * and the hooks in ERC777, but with more of an empasis on interoperability (returned values) than\\n * ERC677 and specifically scoped interaction rather than the general hooks of ERC777.\\n *\\n * For more detailed notes please see our guide https://omn.us/how-to-implement-erc20-spendable\\n */\\nabstract contract ERC20Spendable is Context, IERC20Spendable {\\n  /**\\n   * @dev {spend} Allows the transfer of the owners token to the receiver, a call on the receiver,\\n   * and then the return of information from the receiver back up the call stack.\\n   *\\n   * Overloaded method - call this if you are not specifying any arguments.\\n   *\\n   * @param receiver_ The receiving address for this token spend. Contracts must implement\\n   * ERCSpendableReceiver to receive spendadle tokens. For more detail see {ERC20SpendableReceiver}.\\n   * @param spent_ The amount of token being spent. This will be transfered as part of this call and\\n   * provided as an argument on the call to {onERC20SpendableReceived} on the {ERC20SpendableReceiver}.\\n   */\\n  function spend(address receiver_, uint256 spent_) public virtual {\\n    spend(receiver_, spent_, \\\"\\\");\\n  }\\n\\n  /**\\n   * @dev {spend} Allows the transfer of the owners token to the receiver, a call on the receiver, and\\n   * the return of information from the receiver back up the call stack.\\n   *\\n   * Overloaded method - call this to specify a bytes argument.\\n   *\\n   * @param receiver_ The receiving address for this token spend. Contracts must implement\\n   * ERCSpendableReceiver to receive spendadle tokens. For more detail see {ERC20SpendableReceiver}.\\n   * @param spent_ The amount of token being spent. This will be transfered as part of this call and\\n   * provided as an argument on the call to {onERC20SpendableReceived} on the {ERC20SpendableReceiver}.\\n   * @param arguments_ Bytes argument to send with the call. See {mock} contracts for details on encoding\\n   * and decoding arguments from bytes.\\n   */\\n  function spend(\\n    address receiver_,\\n    uint256 spent_,\\n    bytes memory arguments_\\n  ) public virtual {\\n    /**\\n     * @dev Transfer tokens to the receiver contract IF this is a non-0 amount. Don't try and transfer 0,\\n     * which leavesopen the possibility that the call is free. If not, the function call after will fail\\n     * and revert. Why would a {spend} method call ever be free? For example, a service provider may be\\n     * taking their ERC20 token as payment for a service. But they want to offer it for free, perhaps for a\\n     * limited time. Under this situation the spend callcan be used in all cases, but sending 0 token while\\n     * it is free, removing the need for different interfaces.\\n     *\\n     * We use the standard ERC20 public transfer method for the transfer, which means two things:\\n     * 1) This can only be called by the token owner (but that is the entire point!)\\n     * 2) We inherit all of the security checks in this method (e.g. owner has sufficient balance etc.)\\n     */\\n    if (spent_ != 0) {\\n      transfer(receiver_, spent_);\\n    }\\n\\n    /**\\n     * @dev Perform actions on the receiver and return arguments back up the callstack. In addition to allowing\\n     * the execution of the hook within the receiver, this call provides the same feature as onERC721Received\\n     * in the ERC721 standard.\\n     */\\n    if (receiver_.code.length > 0) {\\n      try\\n        IERC20SpendableReceiver(receiver_).onERC20SpendableReceived(\\n          _msgSender(),\\n          spent_,\\n          arguments_\\n        )\\n      returns (bytes4 retval, bytes memory returnedArguments) {\\n        if (\\n          retval != IERC20SpendableReceiver.onERC20SpendableReceived.selector\\n        ) {\\n          revert ERC20SpendableInvalidReveiver(receiver_);\\n        }\\n        emit SpendReceipt(\\n          _msgSender(),\\n          receiver_,\\n          spent_,\\n          arguments_,\\n          returnedArguments\\n        );\\n        /// @dev Handle returned values. Specify an override {_handleReceipt} method in your ERC20 contract if\\n        /// you wish to handle returned arguments.\\n        _handleReceipt(returnedArguments);\\n      } catch (bytes memory reason) {\\n        if (reason.length == 0) {\\n          revert ERC20SpendableInvalidReveiver(receiver_);\\n        } else {\\n          /// @solidity memory-safe-assembly\\n          assembly {\\n            revert(add(32, reason), mload(reason))\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev {_handleReceipt} Internal function called on completion of a call to {onERC20SpendableReceived}\\n   * on the {ERC20SpendableReceiver}.\\n   *\\n   * When making a token {ERC20Spendable} if you wish to process receipts you need to override\\n   * {_handleReceipt} in your contract. For an example, see {mock} contract {MockSpendableERC20ReturnedArgs}.\\n   *\\n   * @param returnedArguments_ Bytes argument to returned from the call. See {mock} contracts for details on\\n   * encoding and decoding arguments from bytes.\\n   */\\n  function _handleReceipt(bytes memory returnedArguments_) internal virtual {}\\n\\n  /**\\n   * @dev See {IERC165-supportsInterface}. This can be used to determine if an ERC20 is ERC20Spendable. For\\n   * example, a DEX may check this value, and make use of a single {spend} transaction (rather than the current\\n   * model of [approve -> pull]) if the ERC20Spendable interface is supported.\\n   *\\n   * @param interfaceId_ The bytes4 interface identifier being checked.\\n   */\\n  function supportsInterface(\\n    bytes4 interfaceId_\\n  ) public view virtual returns (bool) {\\n    // The interface IDs are constants representing the first 4 bytes\\n    // of the XOR of all function selectors in the interface.\\n    // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n    // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n    return interfaceId_ == type(IERC20Spendable).interfaceId;\\n  }\\n\\n  /**\\n   * @dev override this in your implementation\\n   *\\n   * @dev See {IERC20-transfer}.\\n   *\\n   * Requirements:\\n   *\\n   * - `to` cannot be the zero address.\\n   * - the caller must have a balance of at least `amount`.\\n   */\\n  function transfer(address to, uint256 amount) public virtual returns (bool) {}\\n}\\n\"\r\n    },\r\n    \"contracts/ThirdParty/omnus/ERC20Spendable/IERC20Spendable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n// Omnus Contracts v3\\n// https://omn.us/spendable\\n// https://github.com/omnus/ERC20Spendable\\n// npm: @omnus/ERC20Spendable\\n\\npragma solidity ^0.8.21;\\n\\n/**\\n * @title ERC-7492 IERC20Spendable.sol\\n *\\n * @author omnus\\n * https://omn.us\\n *\\n * @dev Implementation of {IERC20Spendable} interface.\\n *\\n * {ERC-7492 ERC20Spendable} allows ERC20s to operate as 'spendable' items, i.e. an ERC20 token that\\n * can trigger an action on another contract at the same time as being transfered. Similar to ERC677\\n * and the hooks in ERC777, but with more of an empasis on interoperability (returned values) than\\n * ERC677 and specifically scoped interaction rather than the general hooks of ERC777.\\n *\\n * For more detailed notes please see our guide https://omn.us/how-to-implement-erc20-spendable\\n */\\n\\ninterface IERC20Spendable {\\n  /// @dev Error {ERC20SpendableInvalidReveiver} The called contract does not support ERC20Spendable.\\n  error ERC20SpendableInvalidReveiver(address receiver);\\n\\n  /// @dev Event {SpendReceipt} issued on successful return from the {ERC20SpendableReceiver} call.\\n  event SpendReceipt(\\n    address spender,\\n    address receiver,\\n    uint256 amount,\\n    bytes sentArguments,\\n    bytes returnedArguments\\n  );\\n\\n  /**\\n   * @dev {spend} Allows the transfer of the owners token to the receiver, a call on the receiver,\\n   * and then the return of information from the receiver back up the call stack.\\n   *\\n   * Overloaded method - call this if you are not specifying any arguments.\\n   *\\n   * @param receiver_ The receiving address for this token spend. Contracts must implement\\n   * ERCSpendableReceiver to receive spendadle tokens. For more detail see {ERC20SpendableReceiver}.\\n   * @param spent_ The amount of token being spent. This will be transfered as part of this call and\\n   * provided as an argument on the call to {onERC20SpendableReceived} on the {ERC20SpendableReceiver}.\\n   */\\n  function spend(address receiver_, uint256 spent_) external;\\n\\n  /**\\n   * @dev {spend} Allows the transfer of the owners token to the receiver, a call on the receiver, and\\n   * the return of information from the receiver back up the call stack.\\n   *\\n   * Overloaded method - call this to specify a bytes argument.\\n   *\\n   * @param receiver_ The receiving address for this token spend. Contracts must implement\\n   * ERCSpendableReceiver to receive spendadle tokens. For more detail see {ERC20SpendableReceiver}.\\n   * @param spent_ The amount of token being spent. This will be transfered as part of this call and\\n   * provided as an argument on the call to {onERC20SpendableReceived} on the {ERC20SpendableReceiver}.\\n   * @param arguments_ Bytes argument to send with the call. See {mock} contracts for details on encoding\\n   * and decoding arguments from bytes.\\n   */\\n  function spend(\\n    address receiver_,\\n    uint256 spent_,\\n    bytes memory arguments_\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ThirdParty/omnus/ERC20Spendable/IERC20SpendableReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n// Omnus Contracts v3\\n// https://omn.us/spendable\\n// https://github.com/omnus/ERC20Spendable\\n// npm: @omnus/ERC20Spendable\\n\\npragma solidity ^0.8.21;\\n\\n/**\\n * @title ERC-7492 IERC20SpendableReceiver.sol\\n *\\n * @author omnus\\n * https://omn.us\\n *\\n * @dev Implementation of {IERC20SpendableReceiver} interface.\\n *\\n * {ERC-7492 ERC20Spendable} allows ERC20s to operate as 'spendable' items, i.e. an ERC20 token that\\n * can trigger an action on another contract at the same time as being transfered. Similar to ERC677\\n * and the hooks in ERC777, but with more of an empasis on interoperability (returned values) than\\n * ERC677 and specifically scoped interaction rather than the general hooks of ERC777.\\n *\\n * For more detailed notes please see our guide https://omn.us/how-to-implement-erc20-spendable\\n */\\n\\ninterface IERC20SpendableReceiver {\\n  ///\u00a0@dev Error {CallMustBeFromSpendableToken}. The call to this method can only be from a designated spendable token.\\n  error CallMustBeFromSpendableToken();\\n\\n  /**\\n   * @dev {onERC20SpendableReceived} External function called by ERC20SpendableTokens. This\\n   * validates that the token is valid and then calls the internal {_handleSpend} method.\\n   * You must overried {_handleSpend} in your contract to perform processing you wish to occur\\n   * on token spend.\\n   *\\n   * This method will pass back the valid bytes4 selector and any bytes argument passed from\\n   * {_handleSpend}.\\n   *\\n   * @param spender_ The address spending the ERC20Spendable\\n   * @param spent_ The amount of token spent\\n   * @param arguments_ Bytes sent with the call\\n   */\\n  function onERC20SpendableReceived(\\n    address spender_,\\n    uint256 spent_,\\n    bytes memory arguments_\\n  ) external returns (bytes4 retval_, bytes memory returnArguments_);\\n}\\n\"\r\n    },\r\n    \"contracts/ThirdParty/Unicrypt/IUniswapV2Locker.sol\": {\r\n      \"content\": \"// Interface definition for UniswapV2Locker.sol\\n\\npragma solidity 0.8.21;\\n\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\ninterface IERCBurn {\\n  function burn(uint256 _amount) external;\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender) external returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n}\\n\\ninterface IMigrator {\\n  function migrate(\\n    address lpToken,\\n    uint256 amount,\\n    uint256 unlockDate,\\n    address owner\\n  ) external returns (bool);\\n}\\n\\ninterface IUniswapV2Locker {\\n  struct UserInfo {\\n    EnumerableSet.AddressSet lockedTokens; // records all tokens the user has locked\\n    mapping(address => uint256[]) locksForToken; // map erc20 address to lock id for that token\\n  }\\n\\n  struct TokenLock {\\n    uint256 lockDate; // the date the token was locked\\n    uint256 amount; // the amount of tokens still locked (initialAmount minus withdrawls)\\n    uint256 initialAmount; // the initial lock amount\\n    uint256 unlockDate; // the date the token can be withdrawn\\n    uint256 lockID; // lockID nonce per uni pair\\n    address owner;\\n  }\\n\\n  struct FeeStruct {\\n    uint256 ethFee; // Small eth fee to prevent spam on the platform\\n    IERCBurn secondaryFeeToken; // UNCX or UNCL\\n    uint256 secondaryTokenFee; // optional, UNCX or UNCL\\n    uint256 secondaryTokenDiscount; // discount on liquidity fee for burning secondaryToken\\n    uint256 liquidityFee; // fee on univ2 liquidity tokens\\n    uint256 referralPercent; // fee for referrals\\n    IERCBurn referralToken; // token the refferer must hold to qualify as a referrer\\n    uint256 referralHold; // balance the referrer must hold to qualify as a referrer\\n    uint256 referralDiscount; // discount on flatrate fees for using a valid referral address\\n  }\\n\\n  function setDev(address payable _devaddr) external;\\n\\n  /**\\n   * @notice set the migrator contract which allows locked lp tokens to be migrated to uniswap v3\\n   */\\n  function setMigrator(IMigrator _migrator) external;\\n\\n  function setSecondaryFeeToken(address _secondaryFeeToken) external;\\n\\n  /**\\n   * @notice referrers need to hold the specified token and hold amount to be elegible for referral fees\\n   */\\n  function setReferralTokenAndHold(\\n    IERCBurn _referralToken,\\n    uint256 _hold\\n  ) external;\\n\\n  function setFees(\\n    uint256 _referralPercent,\\n    uint256 _referralDiscount,\\n    uint256 _ethFee,\\n    uint256 _secondaryTokenFee,\\n    uint256 _secondaryTokenDiscount,\\n    uint256 _liquidityFee\\n  ) external;\\n\\n  /**\\n   * @notice whitelisted accounts dont pay flatrate fees on locking\\n   */\\n  function whitelistFeeAccount(address _user, bool _add) external;\\n\\n  /**\\n   * @notice Creates a new lock\\n   * @param _lpToken the univ2 token address\\n   * @param _amount amount of LP tokens to lock\\n   * @param _unlock_date the unix timestamp (in seconds) until unlock\\n   * @param _referral the referrer address if any or address(0) for none\\n   * @param _fee_in_eth fees can be paid in eth or in a secondary token such as UNCX with a discount on univ2 tokens\\n   * @param _withdrawer the user who can withdraw liquidity once the lock expires.\\n   */\\n  function lockLPToken(\\n    address _lpToken,\\n    uint256 _amount,\\n    uint256 _unlock_date,\\n    address payable _referral,\\n    bool _fee_in_eth,\\n    address payable _withdrawer\\n  ) external payable;\\n\\n  /**\\n   * @notice extend a lock with a new unlock date, _index and _lockID ensure the correct lock is changed\\n   * this prevents errors when a user performs multiple tx per block possibly with varying gas prices\\n   */\\n  function relock(\\n    address _lpToken,\\n    uint256 _index,\\n    uint256 _lockID,\\n    uint256 _unlock_date\\n  ) external;\\n\\n  /**\\n   * @notice withdraw a specified amount from a lock. _index and _lockID ensure the correct lock is changed\\n   * this prevents errors when a user performs multiple tx per block possibly with varying gas prices\\n   */\\n  function withdraw(\\n    address _lpToken,\\n    uint256 _index,\\n    uint256 _lockID,\\n    uint256 _amount\\n  ) external;\\n\\n  /**\\n   * @notice increase the amount of tokens per a specific lock, this is preferable to creating a new lock, less fees, and faster loading on our live block explorer\\n   */\\n  function incrementLock(\\n    address _lpToken,\\n    uint256 _index,\\n    uint256 _lockID,\\n    uint256 _amount\\n  ) external;\\n\\n  /**\\n   * @notice split a lock into two seperate locks, useful when a lock is about to expire and youd like to relock a portion\\n   * and withdraw a smaller portion\\n   */\\n  function splitLock(\\n    address _lpToken,\\n    uint256 _index,\\n    uint256 _lockID,\\n    uint256 _amount\\n  ) external payable;\\n\\n  /**\\n   * @notice transfer a lock to a new owner, e.g. presale project -> project owner\\n   */\\n  function transferLockOwnership(\\n    address _lpToken,\\n    uint256 _index,\\n    uint256 _lockID,\\n    address payable _newOwner\\n  ) external;\\n\\n  /**\\n   * @notice migrates liquidity to uniswap v3\\n   */\\n  function migrate(\\n    address _lpToken,\\n    uint256 _index,\\n    uint256 _lockID,\\n    uint256 _amount\\n  ) external;\\n\\n  function getNumLocksForToken(\\n    address _lpToken\\n  ) external view returns (uint256);\\n\\n  function getNumLockedTokens() external view returns (uint256);\\n\\n  function getLockedTokenAtIndex(\\n    uint256 _index\\n  ) external view returns (address);\\n\\n  // user functions\\n  function getUserNumLockedTokens(\\n    address _user\\n  ) external view returns (uint256);\\n\\n  function getUserLockedTokenAtIndex(\\n    address _user,\\n    uint256 _index\\n  ) external view returns (address);\\n\\n  function getUserNumLocksForToken(\\n    address _user,\\n    address _lpToken\\n  ) external view returns (uint256);\\n\\n  function getUserLockForTokenAtIndex(\\n    address _user,\\n    address _lpToken,\\n    uint256 _index\\n  )\\n    external\\n    view\\n    returns (uint256, uint256, uint256, uint256, uint256, address);\\n\\n  // whitelist\\n  function getWhitelistedUsersLength() external view returns (uint256);\\n\\n  function getWhitelistedUserAtIndex(\\n    uint256 _index\\n  ) external view returns (address);\\n\\n  function getUserWhitelistStatus(address _user) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/ThirdParty/WETH/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n  function deposit() external payable;\\n\\n  function withdraw(uint256 wad) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superAdmin_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"platformAdmins_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"platformTreasury_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"metadropOracleAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapRouter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unicryptLocker_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"driPoolTemplate_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AdapterParamsMustBeEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdditionToPoolIsBelowPerTransactionMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdditionToPoolWouldExceedPerAddressCap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdditionToPoolWouldExceedPoolCap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AddressAlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AllowanceDecreasedBelowZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyInitialised\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveFromTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionStatusIsNotEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionStatusIsNotOpen\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"txGas\",\"type\":\"uint256\"}],\"name\":\"AuxCallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BidMustBeBelowTheFloorForRefundDuringAuction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BidMustBeBelowTheFloorWhenReducingQuantity\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum IErrors.BondingCurveErrorType\",\"name\":\"error\",\"type\":\"uint8\"}],\"name\":\"BondingCurveError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnFromTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotFactory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotFactoryOrProjectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotFactoryProjectOwnerOrPool\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotPlatformAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CallerIsNotSuperAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotTheManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotTheOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerMustBeLzApp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotAddLiquidityOnCreateAndUseDRIPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetNewManagerToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetNewOwnerToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotWithdrawThisToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollectionAlreadyRevealed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractIsDecommissioned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractIsNotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractIsPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DecreasedAllowanceBelowZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeployerOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DestinationIsNotTrustedSource\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DriPoolAddressCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GasLimitIsTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectConfirmationValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectPayment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitialLiquidityAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitialLiquidityNotYetAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAdapterParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEndpointCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMinGas\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOracleSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPayload\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSourceSendingContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTotalShares\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LPLockUpMustFitUint96\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityPoolCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityPoolMustBeAContractAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ListLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MachineAddressCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ManagerUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxBidQuantityIs255\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"alreadyMinted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAllowance\",\"type\":\"uint256\"}],\"name\":\"MaxPublicMintAllowanceExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxSupplyTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxTokensPerTxnExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxTokensPerWalletExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadataIsLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadropFactoryOnlyOncePerReveal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadropModulesOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadropOracleCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinGasLimitNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintERC2309QuantityExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintingIsClosedForever\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewBuyTaxBasisPointsExceedsMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewSellTaxBasisPointsExceedsMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoETHForLiquidityPair\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoPaymentDue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoRefundForCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoStoredMessage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTokenForLiquidityPair\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTrustedPathRecord\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToClaim\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OperationDidNotSucceed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OracleSignatureHasExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipNotInitializedForExtraData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargeEndDate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargeMinETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargePerAddressMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargePoolPerTxnMinETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargePoolSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargeStartDate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParamTooLargeVestingDays\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParametersDoNotMatchSignedMessage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PassedConfigDoesNotMatchApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PauseCutOffHasPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentMustCoverPerMintFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermitDidNotSucceed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PlatformAdminCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PlatformTreasuryCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolIsAboveMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolIsBelowMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolPhaseIsClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolPhaseIsNotAfter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolVestingNotYetComplete\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProjectOwnerCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProofInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuantityExceedsMaxPossibleCollectionSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuantityExceedsRemainingCollectionSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QuantityExceedsRemainingPhaseSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReferralIdAlreadyUsed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"previouslyMinted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingAllocation\",\"type\":\"uint256\"}],\"name\":\"RequestingMoreThanRemainingAllocation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoyaltyFeeWillExceedSalePrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ShareTotalCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SliceOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SliceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SuperAdminCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupplyTotalMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupportWindowIsNotOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TaxFreeAddressCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TaxPeriodStillInForce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TemplateCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TemplateNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ThisMintIsClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSharesMustMatchDenominator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferAmountExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnrecognisedVRFMode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VRFCoordinatorCannotBeAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValueExceedsMaximum\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Decomissioned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"DriPoolAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metaId\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractInstance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"driPoolInstance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"ERC20Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"MachineAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMessageValidityInSeconds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMessageValidityInSeconds\",\"type\":\"uint256\"}],\"name\":\"MessageValidityInSecondsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"OracleAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"platformAdmin\",\"type\":\"address\"}],\"name\":\"PlatformAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"platformAdmin\",\"type\":\"address\"}],\"name\":\"PlatformAdminRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"PlatformTreasuryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldSuperAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSuperAdmin\",\"type\":\"address\"}],\"name\":\"SuperAdminTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"metaId_\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"salt_\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"baseParameters\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"supplyParameters\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"taxParameters\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"poolParameters\",\"type\":\"bytes\"}],\"internalType\":\"struct IERC20ConfigByMetadrop.ERC20Config\",\"name\":\"erc20Config_\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"messageTimeStamp_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockerFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deploymentFee_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"deployer_\",\"type\":\"address\"}],\"name\":\"createConfigHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"configHash_\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"metaId_\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"salt_\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"baseParameters\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"supplyParameters\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"taxParameters\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"poolParameters\",\"type\":\"bytes\"}],\"internalType\":\"struct IERC20ConfigByMetadrop.ERC20Config\",\"name\":\"erc20Config_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"messageTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"messageSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct IConfigStructures.SignedDropMessageDetails\",\"name\":\"signedMessage_\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lockerFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deploymentFee_\",\"type\":\"uint256\"}],\"name\":\"createERC20\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decommissionFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"driPoolTemplate\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPlatformAdmin_\",\"type\":\"address\"}],\"name\":\"grantPlatformAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"machineTemplate_\",\"type\":\"address\"}],\"name\":\"initialiseMachineAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"queryAddress_\",\"type\":\"address\"}],\"name\":\"isPlatformAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"queryAddress_\",\"type\":\"address\"}],\"name\":\"isSuperAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"machineTemplate\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadropOracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldPlatformAdmin_\",\"type\":\"address\"}],\"name\":\"revokePlatformAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDriPoolAddress_\",\"type\":\"address\"}],\"name\":\"setDriPoolAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMachineAddress_\",\"type\":\"address\"}],\"name\":\"setMachineAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"messageValidityInSeconds_\",\"type\":\"uint256\"}],\"name\":\"setMessageValidityInSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"metadropOracleAddress_\",\"type\":\"address\"}],\"name\":\"setMetadropOracleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"platformTreasury_\",\"type\":\"address\"}],\"name\":\"setPlatformTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSuperAdmin_\",\"type\":\"address\"}],\"name\":\"transferSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unicryptLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC20FactoryByMetadrop", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bf9f7e7046b7a90a759cdc06ced11be634aada5600000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000bf9f7e7046b7a90a759cdc06ced11be634aada56000000000000000000000000abcc7736c42713cd40ae8c2915c3b3dcdef6b83d0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000663a5c229c09b049e36dcc11a9b0d4a8eb9db214000000000000000000000000ec73b49fe33a0c70deee11d07e533c7a79d3d0120000000000000000000000000000000000000000000000000000000000000004000000000000000000000000bf9f7e7046b7a90a759cdc06ced11be634aada56000000000000000000000000bf52436dbb09c97a301be66930392f61ee61c7b8000000000000000000000000e79f7a6af8d3bc37d30a172b2c9d2fd003af032b000000000000000000000000c0eba66b055aed2cc8e9e38f04e64501950cb470", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}