{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BaseCAVO.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport './libraries/SafeMath.sol';\\nimport './libraries/Math.sol';\\nimport './interfaces/ICAVO.sol';\\nimport './interfaces/IExcavoERC20.sol';\\nimport './interfaces/IxCAVO.sol';\\nimport './interfaces/IEXCV.sol';\\nimport './interfaces/IExcavoFactory.sol';\\n\\ncontract BaseCAVO is ICAVO, IExcavoERC20, ReentrancyGuard {\\n    using SafeMath for uint;\\n\\n    string public constant override name = 'CAVO';\\n    string public constant override symbol = 'CAVO';\\n    uint8 public constant override decimals = 18;\\n    \\n    uint public constant override MAX_SUPPLY = 10**6 * 10**18;\\n    uint public constant override CREATOR_SUPPLY = 200 ether + 120 ether;\\n\\n    address public override xCAVOToken;\\n    address public immutable override creator;\\n    address public override EXCVToken;\\n\\n    uint public override totalSupply;\\n    mapping(address => uint) public override balanceOf;\\n    mapping(address => mapping(address => uint)) public override allowance;\\n    mapping(address => uint) private lastBalanceOf;\\n    mapping(address => uint) private lastBalanceBlockOf;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    constructor() public {\\n        creator = msg.sender;\\n        _mint(msg.sender, CREATOR_SUPPLY);\\n    }\\n\\n    function initialize(address _factory) external override nonReentrant {\\n        require(msg.sender == creator && IEXCV(EXCVToken).factory() == address(0), 'EXCV: FORBIDDEN');\\n        IEXCV(EXCVToken).initialize(_factory);\\n        IxCAVO(xCAVOToken).initialize(_factory, EXCVToken);\\n    }\\n\\n    function virtualBalanceOf(address account) external view override returns (uint) {\\n        uint balance = balanceOf[account];\\n        if (block.number - lastBalanceBlockOf[account] > 0) {\\n            return balance;\\n        }\\n        uint lastBalance = lastBalanceOf[account];\\n        return balance < lastBalance ? balance : lastBalance;\\n    }\\n\\n    function mint(address account, uint256 amount) external override nonReentrant {\\n        require(msg.sender == xCAVOToken, 'Excavo: FORBIDDEN');\\n        _mint(account, amount);\\n    }\\n\\n    function _mint(address to, uint value) internal {\\n        _saveLastBalance(to);\\n        uint _value = Math.min(value, MAX_SUPPLY.sub(totalSupply));\\n        totalSupply = totalSupply.add(_value);\\n        balanceOf[to] = balanceOf[to].add(_value);\\n        emit Transfer(address(0), to, _value);\\n    }\\n\\n    function _approve(address owner, address spender, uint value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) internal {\\n        _saveLastBalance(from);\\n        _saveLastBalance(to);\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint value) external virtual override returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external virtual override returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external virtual override returns (bool) {\\n        if (allowance[from][msg.sender] != uint(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function _saveLastBalance(address account) private {\\n        if (block.number - lastBalanceBlockOf[account] > 0) {\\n            lastBalanceOf[account] = balanceOf[account];\\n            lastBalanceBlockOf[account] = block.number;\\n        } \\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n\\n    function div(uint x, uint y) internal pure returns (uint z) {\\n        require(y > 0, \\\"SafeMath: division by zero\\\");\\n        z = x / y;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICAVO.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface ICAVO {\\n    function MAX_SUPPLY() external pure returns(uint);\\n    function CREATOR_SUPPLY() external pure returns(uint);\\n    function creator() external returns (address);\\n    function xCAVOToken() external view returns (address);\\n    function EXCVToken() external view returns (address);\\n    function mint(address to, uint value) external;\\n    function initialize(address _factory) external;\\n    function virtualBalanceOf(address account) external view returns (uint);\\n}   \"\r\n    },\r\n    \"contracts/interfaces/IExcavoERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface IExcavoERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IxCAVO.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface IxCAVO {\\n    function excvEthPair() external view returns (address);\\n    function cavoEthPair() external view returns (address);\\n    function getEXCV() external view returns (address);\\n    function getCAVO() external view returns (address);\\n    \\n    function redeem(address recipient) external;\\n    function initialize(address _factory, address _EXCV) external;\\n    function registerPairCreation() external;\\n    function mint(uint price) external;\\n    function accumulatedMintableCAVOAmount() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEXCV.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface IEXCV {\\n    function MAX_SUPPLY() external pure returns(uint);\\n    function CREATOR_SUPPLY() external pure returns(uint);\\n    function xEXCVToken() external view returns (address);\\n    function factory() external view returns (address);\\n\\n    function mint(address to, uint value) external;\\n    function initialize(address _factory) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IExcavoFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface IExcavoFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n    \\n    function EXCVToken() external view returns (address);\\n    function CAVOToken() external view returns (address);\\n    function WETHToken() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n    function router() external view returns(address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n    function initialize(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/PublicPresale.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\\nimport './libraries/TransferHelper.sol';\\nimport './libraries/Math.sol';\\nimport './libraries/SafeMath.sol';\\nimport './libraries/DistributionLibrary.sol';\\nimport './interfaces/ICAVO.sol';\\nimport './interfaces/IExcavoERC20.sol';\\nimport './interfaces/IxCAVO.sol';\\nimport './interfaces/IPublicPresale.sol';\\nimport './BaseCAVO.sol';\\n\\ncontract PublicPresale is BaseCAVO, IPublicPresale {\\n    \\n    using SafeMath for uint;\\n    using DistributionLibrary for DistributionLibrary.Data;\\n\\n    event PublicPresalePurchase(address indexed recipient, uint amount);\\n    event PublicDistributed(address indexed recipient, uint amount);\\n\\n    address public immutable override presaleOwner;\\n    uint private presaleDurationInBlocks;\\n    uint private presaleStartBlock;\\n    \\n    DistributionLibrary.Data private distribution;\\n\\n    constructor(address _presaleOwner, uint32 _vestingBlocksInPeriod, uint _presaleDurationInBlocks) public {\\n        presaleOwner = _presaleOwner;\\n        distribution.blocksInPeriod = _vestingBlocksInPeriod;\\n        presaleDurationInBlocks = _presaleDurationInBlocks;\\n    }\\n\\n    function availablePublicPresaleAmountOf(address account) external view override returns (uint) {\\n        return distribution.availableAmountOf(account);\\n    }\\n\\n    function publicPresaleClaim(uint amount) external override nonReentrant {\\n        distribution.claim(amount);\\n        emit PublicDistributed(msg.sender, amount);\\n    }\\n\\n    function startPublicPresaleDistribution() external override nonReentrant {\\n        require(presaleStartBlock != 0 && block.number >= presaleStartBlock.add(presaleDurationInBlocks), 'PublicPresale: INVALID_PARAMS');\\n        distribution.start();\\n    }\\n\\n    function startPublicPresale() external override nonReentrant {\\n        require(presaleStartBlock == 0 && msg.sender == creator, 'PublicPresale: FORBIDDEN');\\n        presaleStartBlock = block.number;\\n    }\\n\\n    receive() external payable nonReentrant {\\n        require(block.number >= presaleStartBlock && block.number < presaleStartBlock.add(presaleDurationInBlocks), 'PublicPresale: INACTIVE');\\n        // P = 0.5 ETH/CAVO\\n        uint mintedCAVO = msg.value.mul(100).div(50);\\n        payable(presaleOwner).transfer(msg.value);\\n        _mint(address(this), mintedCAVO);\\n        distribution.maxAmountOf[msg.sender] = distribution.maxAmountOf[msg.sender].add(mintedCAVO);\\n        emit PublicPresalePurchase(msg.sender, mintedCAVO);\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.6;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DistributionLibrary.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport './TransferHelper.sol';\\nimport './Math.sol';\\nimport './SafeMath.sol';\\nimport '../interfaces/ICAVO.sol';\\n\\nlibrary DistributionLibrary {\\n    using SafeMath for uint;\\n\\n    struct Data {\\n        mapping(address => uint) claimedAmountOf;\\n        mapping(address => uint) maxAmountOf;\\n        uint unlockBlock;\\n        uint32 blocksInPeriod;\\n    }\\n\\n    function availableAmountOf(Data storage self, address account) internal view returns (uint) {\\n        if (self.unlockBlock == 0 || block.number <= self.unlockBlock || self.maxAmountOf[account] == 0) {\\n            return 0;\\n        }\\n        uint unlockedAmountPerPeriod = self.maxAmountOf[account].mul(10).div(100);\\n        uint unlockPeriodInBlocks = self.maxAmountOf[account].div(unlockedAmountPerPeriod).mul(self.blocksInPeriod);\\n        return Math.min(self.unlockBlock.add(unlockPeriodInBlocks), block.number)\\n            .sub(self.unlockBlock)\\n            .div(self.blocksInPeriod)\\n            .mul(unlockedAmountPerPeriod)\\n            .sub(self.claimedAmountOf[account]);\\n    }\\n\\n    function start(Data storage self) internal {\\n        require(self.unlockBlock == 0 && msg.sender == ICAVO(address(this)).creator(), 'DistributionLibrary: FORBIDDEN');\\n        self.unlockBlock = block.number;\\n    }\\n\\n    function claim(Data storage self, uint amount) internal {\\n        require(amount <= availableAmountOf(self, msg.sender), 'DistributionLibrary: OVERDRAFT');\\n        self.claimedAmountOf[msg.sender] = self.claimedAmountOf[msg.sender].add(amount);\\n        TransferHelper.safeTransfer(address(this), msg.sender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPublicPresale.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface IPublicPresale {\\n    function presaleOwner() external view returns (address);\\n    function availablePublicPresaleAmountOf(address account) external view returns (uint);\\n\\n    function publicPresaleClaim(uint amount) external;\\n    function startPublicPresaleDistribution() external;\\n    function startPublicPresale() external;\\n}   \"\r\n    },\r\n    \"contracts/test/TestCAVO.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport '../PublicPresale.sol';\\nimport '../TeamDistribution.sol';\\nimport '../PrivatePresale.sol';\\nimport './TestxCAVO.sol';\\nimport './TestEXCV.sol';\\n\\ncontract TestCAVO is PublicPresale, PrivatePresale, TeamDistribution {\\n\\n    uint public constant PUBLIC_PRESALE_DURATION_IN_BLOCKS = 10;\\n    uint32 public constant PRESALE_VESTING_PERIOD_IN_BLOCKS = 10;\\n    uint public constant PRIVATE_PRESALE_DISTRIBUTED_CAVO_IN_WEI = 10000;\\n    address private constant PUBLIC_PRESALE_OWNER = 0xeAD9C93b79Ae7C1591b1FB5323BD777E86e150d4;\\n    address[] private _teamAddresses = [\\n        0xeAD9C93b79Ae7C1591b1FB5323BD777E86e150d4, \\n        0xE5904695748fe4A84b40b3fc79De2277660BD1D3, \\n        0x92561F28Ec438Ee9831D00D1D59fbDC981b762b2\\n    ];\\n    uint[] private _teamAmounts = [\\n        1000000,\\n        1500000,\\n        2000000\\n    ];\\n\\n    constructor() \\n        public \\n        PublicPresale(PUBLIC_PRESALE_OWNER, PRESALE_VESTING_PERIOD_IN_BLOCKS, PUBLIC_PRESALE_DURATION_IN_BLOCKS) \\n        PrivatePresale(PRESALE_VESTING_PERIOD_IN_BLOCKS, PRIVATE_PRESALE_DISTRIBUTED_CAVO_IN_WEI) \\n        TeamDistribution(PRESALE_VESTING_PERIOD_IN_BLOCKS, _teamAddresses, _teamAmounts) \\n    {\\n        address _xCAVO;\\n        address _EXCV;\\n        bytes memory xCAVOBytecode = type(TestxCAVO).creationCode;\\n        bytes memory EXCVBytecode = type(TestEXCV).creationCode;\\n        bytes32 xCAVOSalt = keccak256(abi.encodePacked(\\\"xCAVO\\\"));\\n        bytes32 EXCVSalt = keccak256(abi.encodePacked(\\\"EXCV\\\"));\\n        assembly {\\n            _xCAVO := create2(0, add(xCAVOBytecode, 32), mload(xCAVOBytecode), xCAVOSalt)\\n            _EXCV := create2(0, add(EXCVBytecode, 32), mload(EXCVBytecode), EXCVSalt)\\n        }\\n        xCAVOToken = _xCAVO;\\n        EXCVToken = _EXCV;\\n\\n        _mint(address(this), totalTeamDistribution.add(totalPrivatePresaleDistribution));\\n    }\\n\\n    function teamAddresses() external view returns (address[] memory) {\\n        return _teamAddresses;\\n    }\\n\\n    function teamAmounts() external view returns (uint[] memory) {\\n        return _teamAmounts;\\n    }\\n\\n    function testMint(address account, uint256 amount) external {\\n        _mint(account, amount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/TeamDistribution.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport './libraries/TransferHelper.sol';\\nimport './libraries/Math.sol';\\nimport './libraries/SafeMath.sol';\\nimport './libraries/DistributionLibrary.sol';\\nimport './interfaces/ICAVO.sol';\\nimport './interfaces/IExcavoERC20.sol';\\nimport './interfaces/IxCAVO.sol';\\nimport './interfaces/ITeamDistribution.sol';\\n\\nabstract contract TeamDistribution is ITeamDistribution, ICAVO, IExcavoERC20, ReentrancyGuard {\\n    using SafeMath for uint;\\n    using DistributionLibrary for DistributionLibrary.Data;\\n\\n    event TeamDistributed(address indexed recipient, uint amount);\\n\\n    uint public override totalTeamDistribution;\\n    DistributionLibrary.Data private distribution;\\n\\n    constructor(uint32 _blocksInPeriod, address[] memory _team, uint[] memory _amounts) public {\\n        require(_team.length == _amounts.length, 'TeamDistribution: INVALID_PARAMS');\\n        uint total;\\n        for (uint i = 0; i < _team.length; ++i) {\\n            distribution.maxAmountOf[_team[i]] = _amounts[i];\\n            total = total.add(_amounts[i]);\\n        }\\n        totalTeamDistribution = total;\\n        distribution.blocksInPeriod = _blocksInPeriod;\\n    }\\n\\n    function availableTeamMemberAmountOf(address account) external view override returns (uint) {\\n        return distribution.availableAmountOf(account);\\n    }\\n\\n    function teamMemberClaim(uint amount) external override nonReentrant {\\n        distribution.claim(amount);\\n        emit TeamDistributed(msg.sender, amount);\\n    }\\n\\n    function startTeamDistribution() external override nonReentrant {\\n        distribution.start();\\n    }\\n}\"\r\n    },\r\n    \"contracts/PrivatePresale.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport './libraries/TransferHelper.sol';\\nimport './libraries/SafeMath.sol';\\nimport './libraries/DistributionLibrary.sol';\\nimport './interfaces/ICAVO.sol';\\nimport './interfaces/IExcavoERC20.sol';\\nimport './interfaces/IxCAVO.sol';\\nimport './interfaces/IPrivatePresale.sol';\\n\\nabstract contract PrivatePresale is IPrivatePresale, ICAVO, IExcavoERC20, ReentrancyGuard {\\n    using SafeMath for uint;\\n    using DistributionLibrary for DistributionLibrary.Data;\\n\\n    event PrivateDistributionInitialized(address indexed recipient, uint amount);\\n    event PrivateDistributed(address indexed recipient, uint amount);\\n\\n    DistributionLibrary.Data private distribution;\\n    uint public override totalPrivatePresaleDistribution;\\n    uint public override privatePresaleDistributed;\\n\\n    constructor(uint32 _blocksInPeriod, uint _totalPrivatePresaleDistribution) public {\\n        distribution.blocksInPeriod = _blocksInPeriod;\\n        totalPrivatePresaleDistribution = _totalPrivatePresaleDistribution;\\n    }\\n\\n    function distribute(address[] calldata _accounts, uint[] calldata _amounts) external override nonReentrant {\\n        require(msg.sender == ICAVO(address(this)).creator(), 'PrivatePresale: FORBIDDEN');\\n        require(_accounts.length == _amounts.length, 'PrivatePresale: INVALID_LENGTH');\\n        uint _distributed = privatePresaleDistributed;\\n        for (uint i = 0; i < _accounts.length; ++i) {\\n            uint max = distribution.maxAmountOf[_accounts[i]].add(_amounts[i]);\\n            distribution.maxAmountOf[_accounts[i]] = max;\\n            _distributed = _distributed.add(_amounts[i]);\\n            emit PrivateDistributionInitialized(_accounts[i], max);\\n        }\\n        require(_distributed <= totalPrivatePresaleDistribution, 'PrivatePresale: LIMIT_EXCEEDED');\\n        privatePresaleDistributed = _distributed;\\n    }\\n\\n    function editDistributed(address _account, uint _amount) external override nonReentrant {\\n        // disabled if admin has started the private presale distribution\\n        require(distribution.unlockBlock == 0 && msg.sender == ICAVO(address(this)).creator(), 'PrivatePresale: FORBIDDEN');\\n        uint _distributed = privatePresaleDistributed.sub(distribution.maxAmountOf[_account]).add(_amount);\\n        distribution.maxAmountOf[_account] = _amount;\\n        require(_distributed <= totalPrivatePresaleDistribution, 'PrivatePresale: LIMIT_EXCEEDED');\\n        privatePresaleDistributed = _distributed;\\n        emit PrivateDistributionInitialized(_account, _amount);\\n    }\\n\\n    function availablePrivatePresaleAmountOf(address account) external view override returns (uint) {\\n        return distribution.availableAmountOf(account);\\n    }\\n\\n    function privatePresaleClaim(uint amount) external override nonReentrant {\\n        distribution.claim(amount);\\n        emit PrivateDistributed(msg.sender, amount);\\n    }\\n\\n    function startPrivatePresaleDistribution() external override nonReentrant {\\n        // called, once admin has distributed all of the presale tokens\\n        require(privatePresaleDistributed == totalPrivatePresaleDistribution, 'PrivatePresale: DISTRIBUTION_UNFINISHED');\\n        distribution.start();\\n    }\\n}\"\r\n    },\r\n    \"contracts/test/TestxCAVO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.6;\\n\\nimport '../xCAVO.sol';\\n\\ncontract TestxCAVO is xCAVO {\\n    function testSetExpectedPrice(uint price) external {\\n        expectedPriceInUQ = price;\\n    }\\n}\"\r\n    },\r\n    \"contracts/test/TestEXCV.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport \\\"../EXCV.sol\\\";\\n\\ncontract TestEXCV is EXCV {\\n    function testMint(address account, uint256 amount) external {\\n        _mint(account, amount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITeamDistribution.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface ITeamDistribution {\\n    function totalTeamDistribution() external view returns (uint);\\n    function availableTeamMemberAmountOf(address account) external view returns (uint);\\n\\n    function teamMemberClaim(uint amount) external;\\n    function startTeamDistribution() external;\\n}   \"\r\n    },\r\n    \"contracts/interfaces/IPrivatePresale.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface IPrivatePresale {\\n    function totalPrivatePresaleDistribution() external view returns (uint);\\n    function privatePresaleDistributed() external view returns (uint);\\n    function availablePrivatePresaleAmountOf(address account) external view returns (uint);\\n\\n    function distribute(address[] calldata _accounts, uint[] calldata _amounts) external;\\n    function editDistributed(address _account, uint _amount) external;\\n    function privatePresaleClaim(uint amount) external;\\n    function startPrivatePresaleDistribution() external;\\n}   \"\r\n    },\r\n    \"contracts/xCAVO.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport './interfaces/IxCAVO.sol';\\nimport './interfaces/ICAVO.sol';\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IEXCV.sol\\\";\\nimport \\\"./interfaces/IExcavoPair.sol\\\";\\nimport \\\"./interfaces/IExcavoFactory.sol\\\";\\nimport './libraries/SafeMath.sol';\\nimport \\\"./libraries/ExcavoLibrary.sol\\\";\\nimport './libraries/UQ112x112.sol';\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\ncontract xCAVO is IxCAVO, IERC20, ReentrancyGuard {\\n    using SafeMath for uint;\\n    \\n    event Redeem(address indexed sender, address indexed recipient, uint amount);\\n\\n    string public constant override name = 'xCAVO';\\n    string public constant override symbol = 'xCAVO';\\n    uint8 public constant override decimals = 18;\\n    uint private constant Q112 = 2**112;\\n    uint private constant WEI_IN_CAVO = 10**18;\\n    uint private constant VESTING_PERIOD = 7020000; // 36 * 30 * 6500 = 7020000 = 36 months in blocks\\n    \\n    address public immutable override getCAVO;\\n    address public override excvEthPair;\\n    address public override cavoEthPair;\\n    address public override getEXCV;\\n\\n    mapping(address => uint) private lastAccumulatedMintableCAVOAmount;\\n    mapping(address => uint) private lastAccumulatedUnclaimedLiquidity;\\n\\n    uint public override accumulatedMintableCAVOAmount;\\n    uint private firstBlockNumber;\\n    uint private lastBlockNumber;\\n    uint internal expectedPriceInUQ;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    constructor() public {\\n        getCAVO = msg.sender;\\n    }\\n\\n    function initialize(address _factory, address _EXCV) external override nonReentrant  {\\n        require(getEXCV == address(0) && excvEthPair == address(0) && cavoEthPair == address(0) && msg.sender == getCAVO, \\\"xCAVO: FORBIDDEN\\\"); \\n        getEXCV = _EXCV;\\n        address WETH = IExcavoFactory(_factory).WETHToken();\\n        excvEthPair = ExcavoLibrary.pairFor(_factory, getEXCV, WETH);\\n        cavoEthPair = ExcavoLibrary.pairFor(_factory, getCAVO, WETH);\\n    }\\n\\n    function registerPairCreation() external override nonReentrant {\\n        require(firstBlockNumber == 0 && msg.sender == cavoEthPair, \\\"xCAVO: FORBIDDEN\\\");\\n        firstBlockNumber = block.number;\\n        lastBlockNumber = block.number;\\n    }\\n\\n    function totalSupply() external view override returns (uint) {\\n        return IERC20(getCAVO).totalSupply();\\n    }\\n\\n    function balanceOf(address owner) external view override returns (uint) {\\n        uint totalUnclaimedLiquidity = IExcavoPair(excvEthPair).accumulatedLiquidityGrowth() - lastAccumulatedUnclaimedLiquidity[owner];\\n        if (totalUnclaimedLiquidity == 0) {\\n            return 0;\\n        }\\n        uint totalMintableCAVO = accumulatedMintableCAVOAmount - lastAccumulatedMintableCAVOAmount[owner];\\n        uint liquidity = IExcavoPair(excvEthPair).unclaimedLiquidityOf(owner);\\n        return liquidity.mul(totalMintableCAVO) / totalUnclaimedLiquidity;\\n    }\\n\\n    function redeem(address recipient) external override nonReentrant {\\n        uint liquidity = IExcavoPair(excvEthPair).claimAllLiquidity(msg.sender);\\n        uint accumulatedUnclaimedLiquidity = IExcavoPair(excvEthPair).accumulatedUnclaimedLiquidity();\\n        uint totalUnclaimedLiquidity = accumulatedUnclaimedLiquidity - lastAccumulatedUnclaimedLiquidity[msg.sender]; // overflow desired\\n        if (totalUnclaimedLiquidity == 0) {\\n            revert('xCAVO: INSUFFICIENT_MINTED_AMOUNT');\\n        }\\n        uint totalMintableCAVO = accumulatedMintableCAVOAmount - lastAccumulatedMintableCAVOAmount[msg.sender]; // overflow desired\\n        uint mintedAmount = liquidity.mul(totalMintableCAVO) / totalUnclaimedLiquidity;\\n        require(mintedAmount > 0, 'xCAVO: INSUFFICIENT_MINTED_AMOUNT');\\n        lastAccumulatedUnclaimedLiquidity[msg.sender] = accumulatedUnclaimedLiquidity;\\n        lastAccumulatedMintableCAVOAmount[msg.sender] = accumulatedMintableCAVOAmount;\\n        ICAVO(getCAVO).mint(recipient, mintedAmount);\\n        emit Redeem(msg.sender, recipient, mintedAmount);\\n    }\\n\\n    function mint(uint priceInUQ) external override nonReentrant {\\n        require(msg.sender == cavoEthPair, \\\"xCAVO: FORBIDDEN\\\");\\n\\n        if (block.number - firstBlockNumber >= VESTING_PERIOD || block.number == lastBlockNumber) {\\n            return;\\n        }\\n        uint priceChangeInUQ = Q112.mul(block.number.sub(lastBlockNumber)).mul(3).div(6500000);\\n        if (expectedPriceInUQ + priceChangeInUQ < expectedPriceInUQ) {\\n            return; // overflow: stop minting\\n        }\\n        expectedPriceInUQ += priceChangeInUQ; // cannot overflow\\n        if (priceInUQ >= expectedPriceInUQ) {\\n            // mintedAmount = 10^6 * (N - Nprev) * (N + Nprev - 2 * N0) / ((36 * 30 * 6500)^2)\\n            // ((36 * 30 * 6500)**2) = 49280400000000\\n            // 10**6 = 1000000\\n            uint mintedAmount = block.number.sub(lastBlockNumber).mul(1000000)\\n                .mul(block.number.add(lastBlockNumber).sub(firstBlockNumber.mul(2)))\\n                .mul(WEI_IN_CAVO)\\n                .div(49280400000000);\\n            if (mintedAmount > 0) {\\n                accumulatedMintableCAVOAmount = accumulatedMintableCAVOAmount + mintedAmount; // overflow desired\\n            }\\n        }\\n        lastBlockNumber = block.number;\\n    }\\n\\n    function allowance(address /*owner*/, address /*spender*/) external view override returns (uint) {\\n        revert(\\\"xCAVO: FORBIDDEN\\\");\\n    }\\n\\n    function approve(address /*spender*/, uint /*value*/) external override returns (bool) {\\n        revert(\\\"xCAVO: FORBIDDEN\\\");\\n    }\\n\\n    function transfer(address /*to*/, uint /*value*/) external override returns (bool) {\\n        revert(\\\"xCAVO: FORBIDDEN\\\");\\n    }\\n\\n    function transferFrom(address /*from*/, address /*to*/, uint /*value*/) external override returns (bool) {\\n        revert(\\\"xCAVO: FORBIDDEN\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExcavoPair.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport './IExcavoERC20.sol';\\n\\ninterface IExcavoPair is IExcavoERC20 {\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function router() external view returns (address);\\n    function accumulatedLiquidityGrowth() external view returns (uint);\\n    function accumulatedUnclaimedLiquidity() external view returns (uint);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata _data, uint discount) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address, address) external;\\n    function setxEXCV(address) external;\\n\\n    function unclaimedLiquidityOf(address) external view returns (uint);\\n    function claimLiquidity(address account, uint256 amount) external returns (uint claimAmount);\\n    function claimAllLiquidity(address account) external returns (uint claimAmount);\\n\\n    function compoundLiquidity() external;\\n    function setCAVO(address _CAVO, address _xCAVO) external;   \\n}\"\r\n    },\r\n    \"contracts/libraries/ExcavoLibrary.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport '../interfaces/IExcavoPair.sol';\\nimport \\\"./SafeMath.sol\\\";\\nimport './Math.sol';\\n\\nlibrary ExcavoLibrary {\\n    using SafeMath for uint;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'ExcavoLibrary: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'ExcavoLibrary: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex'3b4596e5d4f0ba0faf3c029e2a152a4931e4da86804417810c5960569e839f1e' // init code hash\\n            ))));\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = IExcavoPair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'ExcavoLibrary: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'ExcavoLibrary: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint discount) internal pure returns (uint amountOut) {\\n        require(amountIn > 0, 'ExcavoLibrary: INSUFFICIENT_INPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'ExcavoLibrary: INSUFFICIENT_LIQUIDITY');\\n        uint amountInWithFee = amountIn.mul(10000 - 4 * discount);\\n        uint numerator = amountInWithFee.mul(reserveOut);\\n        uint denominator = reserveIn.mul(10000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint discount) internal pure returns (uint amountIn) {\\n        require(amountOut > 0, 'ExcavoLibrary: INSUFFICIENT_OUTPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'ExcavoLibrary: INSUFFICIENT_LIQUIDITY');\\n        uint numerator = reserveIn.mul(amountOut).mul(10000);\\n        uint denominator = reserveOut.sub(amountOut).mul(10000 - 4 * discount);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(address factory, uint amountIn, address[] memory path, uint discount) internal view returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'ExcavoLibrary: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint i; i < path.length - 1; i++) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, discount);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(address factory, uint amountOut, address[] memory path, uint discount) internal view returns (uint[] memory amounts) {\\n        require(path.length >= 2, 'ExcavoLibrary: INVALID_PATH');\\n        amounts = new uint[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint i = path.length - 1; i > 0; i--) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut, discount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UQ112x112.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EXCV.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport './interfaces/IExcavoERC20.sol';\\nimport './interfaces/ICAVO.sol';\\nimport './libraries/Math.sol';\\nimport \\\"./xEXCV.sol\\\";\\n\\ncontract EXCV is IEXCV, IExcavoERC20, ReentrancyGuard {\\n    using SafeMath for uint;\\n\\n    string public constant override name = 'EXCV';\\n    string public constant override symbol = 'EXCV';\\n    uint8 public constant override decimals = 18;\\n\\n    uint public constant override MAX_SUPPLY = 10**9 * 10**18;\\n    // TODO: make sure, it's OK\\n    uint public constant override CREATOR_SUPPLY = 600 * 5 * 10**18;\\n\\n    address public override immutable xEXCVToken;\\n    address public override factory;\\n\\n    uint public override totalSupply;\\n    mapping(address => uint) public override balanceOf;\\n    mapping(address => mapping(address => uint)) public override allowance;\\n    address private immutable creator;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    constructor() public {\\n        creator = msg.sender;\\n        address _xEXCV;\\n        bytes memory bytecode = type(xEXCV).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(\\\"xEXCV\\\"));\\n        assembly {\\n            _xEXCV := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n        xEXCVToken = _xEXCV;\\n    }\\n\\n    function initialize(address _factory) external override nonReentrant {\\n        require(factory == address(0) && msg.sender == creator, \\\"EXCV: FORBIDDEN\\\");\\n        factory = _factory;\\n        IxEXCV(xEXCVToken).initialize(_factory);\\n        _mint(ICAVO(creator).creator(), CREATOR_SUPPLY);\\n    }\\n\\n    function _mint(address to, uint value) internal {\\n        uint _value = Math.min(value, MAX_SUPPLY.sub(totalSupply));\\n        totalSupply = totalSupply.add(_value);\\n        balanceOf[to] = balanceOf[to].add(_value);\\n        emit Transfer(address(0), to, _value);\\n    }\\n\\n    function _approve(address owner, address spender, uint value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function mint(address to, uint value) external override nonReentrant {\\n        require(msg.sender == xEXCVToken, \\\"EXCV: FORBIDDEN\\\");\\n        _mint(to, value);\\n    }\\n\\n    function approve(address spender, uint value) external virtual override nonReentrant returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external virtual override returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external virtual override nonReentrant returns (bool) {\\n        if (allowance[from][msg.sender] != uint(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n}\"\r\n    },\r\n    \"contracts/xEXCV.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport \\\"./interfaces/IxEXCV.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IEXCV.sol\\\";\\nimport \\\"./interfaces/IExcavoFactory.sol\\\";\\nimport \\\"./interfaces/IExcavoPair.sol\\\";\\nimport \\\"./libraries/ExcavoLibrary.sol\\\";\\nimport './libraries/Math.sol';\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\ncontract xEXCV is IxEXCV, IERC20, ReentrancyGuard {\\n    // each time user adds liquidity to EXCV generating pairs, add active pair address\\n    // each time user removes liquidity to EXCV generating pairs, remove active pair address\\n    using SafeMath for uint;\\n\\n    event Redeem(address indexed sender, address indexed recipient, uint amount);\\n\\n    uint constant MIN_LIQUIDITY_PAIR_COUNT = 3;\\n    \\n    address public immutable override getEXCV;\\n    address public override factory;\\n    address public override excvEthPair;\\n    address[] private _liquidityPairs;\\n\\n    string public constant override symbol = \\\"xEXCV\\\";\\n    string public constant override name = \\\"xEXCV\\\";\\n    uint8 public constant override decimals = 18; \\n\\n    constructor() public {\\n        getEXCV = msg.sender;\\n    }\\n\\n    function initialize(address _factory) external override nonReentrant {\\n        require(msg.sender == getEXCV && factory == address(0) && excvEthPair == address(0), \\\"xEXCV: FORBIDDEN\\\");\\n        factory = _factory;\\n        address WETH = IExcavoFactory(_factory).WETHToken();\\n        excvEthPair = ExcavoLibrary.pairFor(_factory, getEXCV, WETH);\\n    }\\n\\n    function addPair(address tokenA, address tokenB) external override nonReentrant {\\n        require(ExcavoLibrary.pairFor(factory, tokenA, tokenB) == msg.sender, \\\"xEXCV: FORBIDDEN\\\");\\n        if (!_pairExists(msg.sender)) {\\n            _liquidityPairs.push(msg.sender);\\n        }\\n    }\\n\\n    function redeem(address recipient) external override nonReentrant {\\n        address[] memory pairs = _liquidityPairs;\\n        uint _circulatingSupply = circulatingSupply();\\n        uint excvQuantity;\\n        for (uint i = 0; i < pairs.length; i++) {\\n            uint lastK = IExcavoPair(pairs[i]).totalSupply();\\n            uint claimedLiquidity = IExcavoPair(pairs[i]).claimAllLiquidity(msg.sender);\\n            excvQuantity = excvQuantity.add(claimedLiquidity.mul(_circulatingSupply).div(lastK));\\n        }\\n        IEXCV(getEXCV).mint(recipient, excvQuantity);\\n        emit Redeem(msg.sender, recipient, excvQuantity);\\n    }\\n\\n    function redeemPair(address recipient, address pair, uint claimedLiquidityAmount) external override nonReentrant {\\n        require(_pairExists(pair), \\\"xEXCV: unknown pair\\\");\\n\\n        uint _circulatingSupply = circulatingSupply();\\n        uint lastK = IExcavoPair(pair).totalSupply();\\n        IExcavoPair(pair).claimLiquidity(msg.sender, claimedLiquidityAmount);\\n        uint excvQuantity = claimedLiquidityAmount.mul(_circulatingSupply).div(lastK);\\n\\n        IEXCV(getEXCV).mint(recipient, excvQuantity);\\n        emit Redeem(msg.sender, recipient, excvQuantity);\\n    }\\n\\n    function totalSupply() external view override returns (uint) {\\n        return IERC20(getEXCV).totalSupply();\\n    }\\n\\n    function balanceOf(address owner) external view override returns (uint) {\\n        address[] memory pairs = _liquidityPairs;\\n        uint _circulatingSupply = circulatingSupply();\\n        uint excvQuantity;\\n        for (uint i = 0; i < pairs.length; i++) {\\n            uint accumulatedLiquidity = IExcavoPair(pairs[i]).unclaimedLiquidityOf(owner);\\n            uint lastK = IExcavoPair(pairs[i]).totalSupply();\\n            excvQuantity = excvQuantity.add(accumulatedLiquidity.mul(_circulatingSupply).div(lastK));\\n        }\\n        return excvQuantity;\\n    }\\n\\n    function liquidityPairs() external view override returns (address[] memory) {\\n        return _liquidityPairs;\\n    }\\n\\n    function pairBalanceOf(address owner, address pair) external view override returns (uint) {\\n        if (!_pairExists(pair)) {\\n            return 0;\\n        }\\n        uint lastK = IExcavoPair(pair).totalSupply();\\n        if (lastK == 0) {\\n            return 0;\\n        }\\n        uint _circulatingSupply = circulatingSupply();\\n        uint accumulatedLiquidity = IExcavoPair(pair).unclaimedLiquidityOf(owner);\\n        return accumulatedLiquidity.mul(_circulatingSupply) / lastK;\\n    }\\n\\n    function circulatingSupply() private view returns (uint) {\\n        (uint reserve0, uint reserve1, ) = IExcavoPair(excvEthPair).getReserves();\\n        return IExcavoPair(excvEthPair).token0() == getEXCV ? reserve0 : reserve1;\\n    }\\n\\n    function _pairExists(address pair) private view returns (bool) {\\n        address[] memory pairs = _liquidityPairs;\\n        for (uint i = 0; i < pairs.length; ++i) {\\n            if (pairs[i] == pair) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function allowance(address /*owner*/, address /*spender*/) external view override returns (uint) {\\n        revert(\\\"xEXCV: FORBIDDEN\\\");\\n    }\\n\\n    function approve(address /*spender*/, uint /*value*/) external override returns (bool) {\\n        revert(\\\"xEXCV: FORBIDDEN\\\");\\n    }\\n\\n    function transfer(address /*to*/, uint /*value*/) external override returns (bool) {\\n        revert(\\\"xEXCV: FORBIDDEN\\\");\\n    }\\n\\n    function transferFrom(address /*from*/, address /*to*/, uint /*value*/) external override returns (bool) {\\n        revert(\\\"xEXCV: FORBIDDEN\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IxEXCV.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface IxEXCV {\\n    function liquidityPairs() external view returns (address[] memory);\\n    function factory() external view returns (address);\\n    function excvEthPair() external view returns (address);\\n    function getEXCV() external view returns (address);\\n\\n    function initialize(address _factory) external;\\n    function redeem(address recipient) external;\\n    function redeemPair(address recipient, address pair, uint claimedLiquidityAmount) external;\\n    function addPair(address tokenA, address tokenB) external;\\n    function pairBalanceOf(address owner, address pair) external view returns (uint);\\n}\"\r\n    },\r\n    \"contracts/test/DistributionTest.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport '../libraries/TransferHelper.sol';\\nimport '../libraries/Math.sol';\\nimport '../libraries/SafeMath.sol';\\nimport '../libraries/DistributionLibrary.sol';\\nimport '../interfaces/ICAVO.sol';\\nimport '../interfaces/IExcavoERC20.sol';\\nimport '../interfaces/IxCAVO.sol';\\nimport './TestCAVO.sol';\\n\\ncontract DistributionTest is TestCAVO {\\n    using SafeMath for uint;\\n    using DistributionLibrary for DistributionLibrary.Data;\\n\\n    event Distributed(address indexed recipient, uint amount);\\n    event DistributionStarted(address indexed sender, uint blockNumber);\\n\\n    DistributionLibrary.Data private testDistribution;\\n    uint private totalDistribution;\\n\\n    constructor(uint32 _blocksInPeriod, address[] memory _team, uint[] memory _amounts) public {\\n        require(_team.length == _amounts.length, 'DistributionTest: INVALID_PARAMS');\\n        uint total;\\n        for (uint i = 0; i < _team.length; ++i) {\\n            testDistribution.maxAmountOf[_team[i]] = _amounts[i];\\n            total = total.add(_amounts[i]);\\n        }\\n        totalDistribution = total;\\n        testDistribution.blocksInPeriod = _blocksInPeriod;\\n\\n        _mint(address(this), totalDistribution);\\n    }\\n\\n    function testAvailableAmountOf(address account) external view returns (uint) {\\n        return testDistribution.availableAmountOf(account);\\n    }\\n\\n    function testClaim(uint amount) external {\\n        testDistribution.claim(amount);\\n        emit Distributed(msg.sender, amount);\\n    }\\n\\n    function testStartDistribution() external nonReentrant {\\n        testDistribution.start();\\n        emit DistributionStarted(msg.sender, block.number);\\n    }\\n}\"\r\n    },\r\n    \"contracts/ExcavoPair.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IxEXCV.sol';\\nimport './interfaces/IxCAVO.sol';\\nimport './interfaces/IExcavoFactory.sol';\\nimport './interfaces/IExcavoCallee.sol';\\nimport './interfaces/IExcavoPair.sol';\\nimport './libraries/Math.sol';\\nimport './libraries/UQ112x112.sol';\\nimport './libraries/PairLibrary.sol';\\nimport './BaseExcavoPair.sol';\\n\\ncontract ExcavoPair is IExcavoPair, BaseExcavoPair {\\n    using SafeMath  for uint;\\n    using UQ112x112 for uint224;\\n\\n    event Compound(address indexed owner, uint liquidityGrowth);\\n\\n    struct SwapDetails {\\n        uint balance0;\\n        uint balance1;\\n        address _token0;\\n        address _token1;\\n        uint balance0Adjusted;\\n        uint balance1Adjusted;\\n    }\\n\\n    uint public constant override MINIMUM_LIQUIDITY = 10**3;\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\\n\\n    uint private unlocked = 1;\\n    modifier lock() {\\n        require(unlocked == 1, 'Excavo: LOCKED');\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    function getReserves() public view override returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\\n        _reserve0 = data.reserve0;\\n        _reserve1 = data.reserve1;\\n        _blockTimestampLast = data.blockTimestampLast;\\n    }\\n\\n    function _safeTransfer(address token, address to, uint value) private {\\n        (bool success, bytes memory _data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n        require(success && (_data.length == 0 || abi.decode(_data, (bool))), 'Excavo: TRANSFER_FAILED');\\n    }\\n\\n    constructor() public {\\n        data.factory = msg.sender;\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function initialize(address _token0, address _token1, address _router) external override lock {\\n        data.initialize(_token0, _token1, _router);\\n    }       \\n\\n    function setCAVO(address _CAVO, address _xCAVO) external override lock {\\n        data.setCAVO(_CAVO, _xCAVO);\\n    }\\n\\n    function setxEXCV(address _xEXCV) external override lock {\\n        data.setxEXCV(_xEXCV);\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'Excavo: OVERFLOW');\\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\\n        uint32 timeElapsed = blockTimestamp - data.blockTimestampLast; // overflow is desired\\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n            // * never overflows, and + overflow is desired\\n            data.price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\\n            data.price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\\n        }\\n        data.reserve0 = uint112(balance0);\\n        data.reserve1 = uint112(balance1);\\n        data.blockTimestampLast = blockTimestamp;\\n        emit Sync(data.reserve0, data.reserve1);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function mint(address to) external lock override returns (uint liquidity) {\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n        uint balance0 = IERC20(data.token0).balanceOf(address(this));\\n        uint balance1 = IERC20(data.token1).balanceOf(address(this));\\n        uint amount0 = balance0.sub(_reserve0);\\n        uint amount1 = balance1.sub(_reserve1);\\n        uint _totalSupply = data.totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        uint _liquidity = Math.sqrt(amount0.mul(amount1));\\n        if (_totalSupply == 0) {\\n            liquidity = _liquidity.sub(MINIMUM_LIQUIDITY);\\n            _mint(address(0), MINIMUM_LIQUIDITY, MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n            require(liquidity > 0, 'Excavo: INSUFFICIENT_LIQUIDITY_MINTED');\\n            _mint(to, liquidity, liquidity);\\n        } else {\\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\\n            require(liquidity > 0, 'Excavo: INSUFFICIENT_LIQUIDITY_MINTED');\\n            _mint(to, liquidity, _liquidity);\\n        }\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        emit Mint(msg.sender, amount0, amount1);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function burn(address to) public override lock returns (uint amount0, uint amount1) {\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n        address _token0 = data.token0;                                // gas savings\\n        address _token1 = data.token1;                                // gas savings\\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\\n        uint liquidity = data.balanceOf[address(this)];\\n        uint _totalSupply = data.totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n        require(amount0 > 0 && amount1 > 0, 'Excavo: INSUFFICIENT_LIQUIDITY_BURNED');\\n\\n        _burn(address(this), liquidity);\\n        _safeTransfer(_token0, to, amount0);\\n        _safeTransfer(_token1, to, amount1);\\n        balance0 = IERC20(_token0).balanceOf(address(this));\\n        balance1 = IERC20(_token1).balanceOf(address(this));\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata _data, uint discount) external override lock {\\n        require(msg.sender == data.router, \\\"Excavo: FORBIDDEN\\\");\\n        SwapDetails memory details;\\n        require(amount0Out > 0 || amount1Out > 0, 'Excavo: INSUFFICIENT_OUTPUT_AMOUNT');\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Excavo: INSUFFICIENT_LIQUIDITY');\\n\\n        { // scope for _token{0,1}, avoids stack too deep errors\\n        details._token0 = data.token0;\\n        details._token1 = data.token1;\\n        require(to != details._token0 && to != details._token1, 'Excavo: INVALID_TO');\\n        if (amount0Out > 0) _safeTransfer(details._token0, to, amount0Out); // optimistically transfer tokens\\n        if (amount1Out > 0) _safeTransfer(details._token1, to, amount1Out); // optimistically transfer tokens\\n        if (_data.length > 0) IExcavoCallee(to).ExcavoCall(msg.sender, amount0Out, amount1Out, _data);\\n        details.balance0 = IERC20(details._token0).balanceOf(address(this));\\n        details.balance1 = IERC20(details._token1).balanceOf(address(this));\\n        }\\n        uint amount0In = details.balance0 > _reserve0 - amount0Out ? details.balance0 - (_reserve0 - amount0Out) : 0;\\n        uint amount1In = details.balance1 > _reserve1 - amount1Out ? details.balance1 - (_reserve1 - amount1Out) : 0;\\n        require(amount0In > 0 || amount1In > 0, 'Excavo: INSUFFICIENT_INPUT_AMOUNT');\\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n        details.balance0Adjusted = details.balance0.mul(10000).sub(amount0In.mul(4 * discount));\\n        details.balance1Adjusted = details.balance1.mul(10000).sub(amount1In.mul(4 * discount));\\n        require(details.balance0Adjusted.mul(details.balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(10000**2), 'Excavo: K');\\n        }\\n        \\n        if (data.CAVO != address(0)) {\\n            uint prevPriceCumulativeLast = data.token0 == data.CAVO ? data.price0CumulativeLast : data.price1CumulativeLast;\\n            uint prevBlockTimestampLast = data.blockTimestampLast;\\n            _update(details.balance0, details.balance1, _reserve0, _reserve1);\\n            // call mint first call per block \\n            if (data.blockTimestampLast != prevBlockTimestampLast) {\\n                uint priceCumulativeLast = data.token0 == data.CAVO ? data.price0CumulativeLast : data.price1CumulativeLast;\\n                IxCAVO(data.xCAVO).mint((priceCumulativeLast - prevPriceCumulativeLast) / (data.blockTimestampLast - prevBlockTimestampLast));\\n            }\\n        } else {\\n            _update(details.balance0, details.balance1, _reserve0, _reserve1);\\n        }\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external override lock {\\n        address _token0 = data.token0; // gas savings\\n        address _token1 = data.token1; // gas savings\\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(data.reserve0));\\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(data.reserve1));\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external override lock {\\n        _update(IERC20(data.token0).balanceOf(address(this)), IERC20(data.token1).balanceOf(address(this)), data.reserve0, data.reserve1);\\n    }\\n\\n    function factory() external view override returns (address) {\\n        return data.factory;\\n    }\\n\\n    function token0() external view override returns (address) {\\n        return data.token0;\\n    }\\n\\n    function token1() external view override returns (address) {\\n        return data.token1;\\n    }\\n\\n    function router() external view override returns (address) {\\n        return data.router;\\n    }\\n\\n    function accumulatedUnclaimedLiquidity() external view override returns (uint) {\\n        return data.accumulatedUnclaimedLiquidity;\\n    }\\n\\n    function price0CumulativeLast() external view override returns (uint) {\\n        return data.price0CumulativeLast;\\n    }\\n\\n    function price1CumulativeLast() external view override returns (uint) {\\n        return data.price1CumulativeLast;\\n    }\\n\\n    function claimLiquidity(address account, uint256 amount) external override lock returns (uint) {\\n        return data.claimLiquidity(account, amount);\\n    }\\n\\n    function claimAllLiquidity(address account) external override lock returns (uint) {\\n        return data.claimAllLiquidity(account);\\n    }\\n\\n    function accumulatedLiquidityGrowth() external view override returns (uint) {\\n        return data.accumulatedLiquidityGrowth();\\n    }\\n\\n    function unclaimedLiquidityOf(address account) external view override returns (uint) {\\n        return data.unclaimedLiquidityOf(account);\\n    }\\n\\n    function compoundLiquidity() external override lock {\\n        emit Compound(msg.sender, data.compoundLiquidity());\\n    }\\n\\n    function _mint(address to, uint value, uint k) private {\\n        data.mint(to, value, k);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) private {\\n        data.burn(from, value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) internal virtual override {\\n        data.transfer(from, to, value);\\n        emit Transfer(from, to, value);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IExcavoCallee.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface IExcavoCallee {\\n    function ExcavoCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/PairLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.6;\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../interfaces/IxEXCV.sol';\\nimport '../interfaces/IxCAVO.sol';\\nimport '../interfaces/IExcavoFactory.sol';\\nimport '../interfaces/IExcavoCallee.sol';\\nimport '../interfaces/IERC20.sol';\\nimport './SafeMath.sol';\\nimport './Math.sol';\\n\\nlibrary PairLibrary {\\n    using SafeMath for uint;\\n\\n    struct Data {\\n        address factory;\\n        address token0;\\n        address token1;\\n        address router;\\n        uint totalSupply;\\n        \\n        uint accumulatedUnclaimedLiquidity;\\n    \\n        uint112 reserve0;           // uses single storage slot, accessible via getReserves\\n        uint112 reserve1;           // uses single storage slot, accessible via getReserves\\n        uint32 blockTimestampLast;  // uses single storage slot, accessible via getReserves\\n\\n        uint price0CumulativeLast;\\n        uint price1CumulativeLast;\\n    \\n        mapping(address => uint) kOf;\\n        mapping(address => uint) lastUnclaimedLiquidityOf;\\n        mapping(address => uint) virtualKOf;\\n        mapping(address => uint) balanceOf;\\n\\n        uint totalK;\\n        address xEXCV;\\n        address xCAVO;\\n        address CAVO;\\n    }\\n\\n    function initialize(Data storage self, address _token0, address _token1, address _router) external {\\n        require(msg.sender == self.factory, 'Excavo: FORBIDDEN'); // sufficient check\\n        self.token0 = _token0;\\n        self.token1 = _token1;\\n        self.router = _router;\\n    }       \\n\\n    function setCAVO(Data storage self, address _CAVO, address _xCAVO) external {\\n        require(msg.sender == self.factory, 'Excavo: FORBIDDEN'); // sufficient check\\n        self.CAVO = _CAVO;\\n        self.xCAVO = _xCAVO;\\n        if (_CAVO != address(0)) {\\n            IxCAVO(_xCAVO).registerPairCreation();\\n        }\\n    }\\n\\n    function setxEXCV(Data storage self, address _xEXCV) external {\\n        require(self.xEXCV == address(0) && msg.sender == IExcavoFactory(self.factory).feeToSetter(), \\\"Excavo: FORBIDDEN\\\"); \\n        self.xEXCV = _xEXCV;\\n        IxEXCV(_xEXCV).addPair(self.token0, self.token1);\\n    }\\n\\n    function claimLiquidity(Data storage self, address account, uint256 amount) external returns (uint claimAmount) {\\n        require(msg.sender == self.xEXCV || msg.sender == self.xCAVO, \\\"Excavo: FORBIDDEN\\\");\\n        _accumulateLiquidityGrowth(\\n            self,\\n            IERC20(self.token0).balanceOf(address(this)), \\n            IERC20(self.token1).balanceOf(address(this)), \\n            self.balanceOf[account], \\n            self.totalSupply, \\n            account\\n        );\\n        claimAmount = self.lastUnclaimedLiquidityOf[account].sub(amount); \\n        self.lastUnclaimedLiquidityOf[account] = claimAmount;\\n    }\\n\\n    function claimAllLiquidity(Data storage self, address account) public returns (uint claimAmount) {\\n        require(msg.sender == self.xEXCV || msg.sender == self.xCAVO, \\\"Excavo: FORBIDDEN\\\");\\n        self.virtualKOf[address(this)] = _accumulateTotalLiquidityGrowth(self);\\n        _accumulateLiquidityGrowth(\\n            self,\\n            IERC20(self.token0).balanceOf(address(this)), \\n            IERC20(self.token1).balanceOf(address(this)), \\n            self.balanceOf[account], \\n            self.totalSupply, \\n            account\\n        );\\n        claimAmount = self.lastUnclaimedLiquidityOf[account];\\n        self.lastUnclaimedLiquidityOf[account] = 0;\\n    }\\n\\n    function accumulatedLiquidityGrowth(Data storage self) external view returns (uint) {\\n        uint lastTotalK = self.virtualKOf[address(this)].add(self.totalK);\\n        uint newTotalK = _calculateNewK(\\n            self.reserve0, \\n            self.reserve1, \\n            self.totalSupply,\\n            self.totalSupply,\\n            lastTotalK\\n        );\\n        if (newTotalK > lastTotalK) {\\n            return self.accumulatedUnclaimedLiquidity + (newTotalK - lastTotalK); // overflow desired\\n        }\\n        return self.accumulatedUnclaimedLiquidity;\\n    }\\n\\n    function unclaimedLiquidityOf(Data storage self, address account) external view returns (uint) {\\n        uint newK = _calculateNewK(\\n            IERC20(self.token0).balanceOf(address(this)), \\n            IERC20(self.token1).balanceOf(address(this)), \\n            self.balanceOf[account],\\n            self.totalSupply,\\n            self.virtualKOf[account]\\n        );\\n        if (newK > self.virtualKOf[account]) {\\n            uint liquidityGrowth = newK - self.virtualKOf[account]; // cannot overflow\\n            return self.lastUnclaimedLiquidityOf[account].add(liquidityGrowth);\\n        }\\n        return self.lastUnclaimedLiquidityOf[account];\\n    }\\n\\n    function compoundLiquidity(Data storage self) external returns (uint) {\\n        self.virtualKOf[address(this)] = _accumulateTotalLiquidityGrowth(self);\\n        return _accumulateLiquidityGrowth(\\n            self,\\n            IERC20(self.token0).balanceOf(address(this)), \\n            IERC20(self.token1).balanceOf(address(this)), \\n            self.balanceOf[msg.sender], \\n            self.totalSupply, \\n            msg.sender\\n        );\\n    }\\n\\n    function mint(Data storage self, address to, uint value, uint k) external {\\n        _accumulateTotalLiquidityGrowth(self);\\n        _accumulateLiquidityGrowth(\\n            self,\\n            IERC20(self.token0).balanceOf(address(this)), \\n            IERC20(self.token1).balanceOf(address(this)), \\n            self.balanceOf[to], \\n            self.totalSupply, \\n            to\\n        );\\n        uint newKTo = self.kOf[to].add(k);\\n        _updateK(self, to, newKTo, newKTo);\\n        self.totalK = self.totalK.add(k);\\n        self.virtualKOf[address(this)] = 0;\\n       \\n        uint newBalance = self.balanceOf[to].add(value);\\n        self.totalSupply = self.totalSupply.add(value);\\n        self.balanceOf[to] = newBalance;\\n    }\\n\\n    function burn(Data storage self, address from, uint value) external {\\n        uint newBalance = self.balanceOf[from].sub(value);\\n        _accumulateTotalLiquidityGrowth(self);\\n        _accumulateLiquidityGrowth(\\n            self,\\n            IERC20(self.token0).balanceOf(address(this)), \\n            IERC20(self.token1).balanceOf(address(this)), \\n            self.balanceOf[from], \\n            self.totalSupply, \\n            from\\n        );\\n        uint newK = self.kOf[from].mul(newBalance).div(self.balanceOf[from]);\\n        _updateK(self, from, newK, newK);\\n        \\n        self.totalK = self.totalK.sub(self.kOf[from].sub(newK));\\n        self.virtualKOf[address(this)] = 0;\\n        self.balanceOf[from] = newBalance;\\n        self.totalSupply = self.totalSupply.sub(value);\\n    }\\n\\n    function transfer(Data storage self, address from, address to, uint value) external {\\n        uint newBalanceFrom = self.balanceOf[from].sub(value);\\n        uint newBalanceTo = self.balanceOf[to].add(value);\\n\\n        uint balance0 = IERC20(self.token0).balanceOf(address(this));\\n        uint balance1 = IERC20(self.token1).balanceOf(address(this));\\n        uint _totalSupply = self.totalSupply;\\n        _accumulateLiquidityGrowth(\\n            self,\\n            balance0, \\n            balance1, \\n            self.balanceOf[from], \\n            _totalSupply, \\n            from\\n        );\\n        _accumulateLiquidityGrowth(\\n            self,\\n            balance0, \\n            balance1, \\n            self.balanceOf[to], \\n            _totalSupply, \\n            to\\n        );\\n\\n        uint newKFrom = self.kOf[from].mul(newBalanceFrom).div(self.balanceOf[from]);\\n        uint newKTo = self.kOf[to].add(self.kOf[from].sub(newKFrom));\\n        uint virtualKTo = _calculateNewK(\\n            balance0, \\n            balance1, \\n            newBalanceTo,\\n            _totalSupply,\\n            newKTo\\n        );\\n        uint virtualKFrom = _calculateNewK(\\n            balance0, \\n            balance1, \\n            newBalanceFrom,\\n            _totalSupply,\\n            newKFrom\\n        );\\n        _updateK(self, to, newKTo, virtualKTo);\\n        _updateK(self, from, newKFrom, virtualKFrom);\\n\\n        self.balanceOf[from] = newBalanceFrom;\\n        self.balanceOf[to] = newBalanceTo;\\n    }\\n\\n    function _calculateNewK(\\n        uint balance0, \\n        uint balance1,\\n        uint liquidity, \\n        uint totalSupply,\\n        uint virtualK\\n    ) private pure returns (uint k) {\\n        if (totalSupply == 0) {\\n            return virtualK;\\n        } \\n        uint amount0 = liquidity.mul(balance0) / totalSupply;\\n        uint amount1 = liquidity.mul(balance1) / totalSupply;\\n        if (amount0 == 0 || amount1 == 0) {\\n            return virtualK;\\n        }\\n        k = Math.sqrt(amount0.mul(amount1));\\n    }   \\n\\n    function _accumulateTotalLiquidityGrowth(Data storage self) private returns (uint virtualTotalK) {\\n        virtualTotalK = self.virtualKOf[address(this)];\\n        uint lastTotalK = virtualTotalK.add(self.totalK);\\n        uint newTotalK = _calculateNewK(\\n            self.reserve0, \\n            self.reserve1, \\n            self.totalSupply,\\n            self.totalSupply,\\n            lastTotalK\\n        );\\n        if (newTotalK > lastTotalK) {\\n            virtualTotalK = newTotalK.sub(self.totalK);\\n            self.accumulatedUnclaimedLiquidity = self.accumulatedUnclaimedLiquidity + (newTotalK - lastTotalK); // overflow desired\\n        }\\n    }\\n\\n    function _accumulateLiquidityGrowth(\\n        Data storage self, \\n        uint balance0, \\n        uint balance1,\\n        uint liquidity, \\n        uint totalSupply,\\n        address account\\n    ) private returns (uint liquidityGrowth) {\\n        uint virtualK = self.virtualKOf[account];\\n        if (account == address(this)) {\\n            return virtualK;\\n        }\\n        uint newK = _calculateNewK(\\n            balance0, \\n            balance1, \\n            liquidity,\\n            totalSupply,\\n            virtualK\\n        );\\n        if (newK > virtualK) {\\n            liquidityGrowth = newK - virtualK; // cannot overflow\\n            self.virtualKOf[account] = newK;\\n            self.lastUnclaimedLiquidityOf[account] = self.lastUnclaimedLiquidityOf[account].add(liquidityGrowth);\\n        }\\n    }\\n\\n    function _updateK(Data storage self, address account, uint k, uint virtualK) private {\\n        self.kOf[account] = k;\\n        self.virtualKOf[account] = virtualK;\\n    }\\n}\"\r\n    },\r\n    \"contracts/BaseExcavoPair.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport './interfaces/IExcavoERC20.sol';\\nimport './libraries/SafeMath.sol';\\nimport './libraries/PairLibrary.sol';\\n\\nabstract contract BaseExcavoPair is IExcavoERC20 {\\n    using SafeMath for uint;\\n    using PairLibrary for PairLibrary.Data;\\n\\n    string public constant override name = 'Excavo';\\n    string public constant override symbol = 'EXCAVO';\\n    uint8 public constant override decimals = 18;\\n    \\n    PairLibrary.Data internal data;\\n    mapping(address => mapping(address => uint)) public override allowance;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    constructor() public {}\\n\\n    function totalSupply() external view override returns (uint) {\\n        return data.totalSupply;\\n    }\\n\\n    function balanceOf(address account) external view override returns (uint) {\\n        return data.balanceOf[account];\\n    }\\n\\n    function _approve(address owner, address spender, uint value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) internal virtual;\\n\\n    function approve(address spender, uint value) external override returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external override returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\\n        if (allowance[from][msg.sender] != uint(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ExcavoERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport './interfaces/IExcavoERC20.sol';\\nimport './libraries/SafeMath.sol';\\n\\ncontract ExcavoERC20 is IExcavoERC20 {\\n    using SafeMath for uint;\\n\\n    string public constant override name = 'Excavo';\\n    string public constant override symbol = 'EXCAVO';\\n    uint8 public constant override decimals = 18;\\n    uint  public override totalSupply;\\n    mapping(address => uint) public override balanceOf;\\n    mapping(address => mapping(address => uint)) public override allowance;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    constructor() public {}\\n\\n    function _mint(address to, uint value) internal virtual {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) internal virtual {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) internal virtual {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint value) external override returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external override returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\\n        if (allowance[from][msg.sender] != uint(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/ERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport '../ExcavoERC20.sol';\\n\\ncontract ERC20 is ExcavoERC20 {\\n    constructor(uint _totalSupply) public {\\n        _mint(msg.sender, _totalSupply);\\n    }\\n}\"\r\n    },\r\n    \"contracts/test/TestERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport '../libraries/SafeMath.sol';\\n\\ncontract TestERC20 {\\n    using SafeMath for uint;\\n\\n    string public constant name = 'Test Token';\\n    string public constant symbol = 'TT';\\n    uint8 public constant decimals = 18;\\n    uint  public totalSupply;\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint)) public allowance;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    constructor(uint _totalSupply) public {\\n        _mint(msg.sender, _totalSupply);\\n    }\\n\\n    function _mint(address to, uint value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/DeflatingERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport '../libraries/SafeMath.sol';\\n\\ncontract DeflatingERC20 {\\n    using SafeMath for uint;\\n\\n    string public constant name = 'Deflating Test Token';\\n    string public constant symbol = 'DTT';\\n    uint8 public constant decimals = 18;\\n    uint  public totalSupply;\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint)) public allowance;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    constructor(uint _totalSupply) public {\\n        _mint(msg.sender, _totalSupply);\\n    }\\n\\n    function _mint(address to, uint value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) private {\\n        uint burnAmount = value / 100;\\n        _burn(from, burnAmount);\\n        uint transferAmount = value.sub(burnAmount);\\n        balanceOf[from] = balanceOf[from].sub(transferAmount);\\n        balanceOf[to] = balanceOf[to].add(transferAmount);\\n        emit Transfer(from, to, transferAmount);\\n    }\\n\\n    function approve(address spender, uint value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ExcavoRouter.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport './interfaces/IExcavoFactory.sol';\\nimport './libraries/TransferHelper.sol';\\n\\nimport './interfaces/IExcavoRouter.sol';\\nimport './libraries/ExcavoLibrary.sol';\\nimport \\\"./libraries/TraderDiscount.sol\\\";\\nimport './libraries/SafeMath.sol';\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IWETH.sol';\\nimport './interfaces/ICAVO.sol';\\n\\ncontract ExcavoRouter is IExcavoRouter {\\n    using SafeMath for uint;\\n\\n    address public immutable override factory;\\n    address public immutable override WETH;\\n    address public immutable override CAVO;\\n\\n    modifier ensure(uint deadline) {\\n        require(deadline >= block.timestamp, 'ExcavoRouter: EXPIRED');\\n        _;\\n    }\\n\\n    constructor(address _factory, address _WETH, address _CAVO) public {\\n        factory = _factory;\\n        WETH = _WETH;\\n        CAVO = _CAVO;\\n    }\\n\\n    receive() external payable {\\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    // **** ADD LIQUIDITY ****\\n    function _addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin\\n    ) internal virtual returns (uint amountA, uint amountB) {\\n        // create the pair if it doesn't exist yet\\n        if (IExcavoFactory(factory).getPair(tokenA, tokenB) == address(0)) {\\n            IExcavoFactory(factory).createPair(tokenA, tokenB);\\n        }\\n\\n        (uint reserveA, uint reserveB) = ExcavoLibrary.getReserves(factory, tokenA, tokenB);\\n\\n        if (reserveA == 0 && reserveB == 0) {\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\n        } else {\\n            uint amountBOptimal = ExcavoLibrary.quote(amountADesired, reserveA, reserveB);\\n            if (amountBOptimal <= amountBDesired) {\\n                require(amountBOptimal >= amountBMin, 'ExcavoRouter: INSUFFICIENT_B_AMOUNT');\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\n            } else {\\n                uint amountAOptimal = ExcavoLibrary.quote(amountBDesired, reserveB, reserveA);\\n                assert(amountAOptimal <= amountADesired);\\n                require(amountAOptimal >= amountAMin, 'ExcavoRouter: INSUFFICIENT_A_AMOUNT');\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\n            }\\n        }\\n    }\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\\n        address pair = ExcavoLibrary.pairFor(factory, tokenA, tokenB);\\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\\n        liquidity = IExcavoPair(pair).mint(to);  \\n    }\\n    \\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\\n        (amountToken, amountETH) = _addLiquidity(\\n            token,\\n            WETH,\\n            amountTokenDesired,\\n            msg.value,\\n            amountTokenMin,\\n            amountETHMin\\n        );\\n        address pair = ExcavoLibrary.pairFor(factory, token, WETH);\\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\\n        IWETH(WETH).deposit{value: amountETH}();\\n        assert(IWETH(WETH).transfer(pair, amountETH));\\n        liquidity = IExcavoPair(pair).mint(to);\\n        // refund dust eth, if any\\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n    }\\n\\n    // **** REMOVE LIQUIDITY ****\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\\n        address pair = ExcavoLibrary.pairFor(factory, tokenA, tokenB);\\n        IExcavoPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n        (uint amount0, uint amount1) = IExcavoPair(pair).burn(to);\\n        (address token0,) = ExcavoLibrary.sortTokens(tokenA, tokenB);\\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\\n        require(amountA >= amountAMin, 'ExcavoRouter: INSUFFICIENT_A_AMOUNT');\\n        require(amountB >= amountBMin, 'ExcavoRouter: INSUFFICIENT_B_AMOUNT');\\n    }\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\\n        (amountToken, amountETH) = removeLiquidity(\\n            token,\\n            WETH,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            address(this),\\n            deadline\\n        );\\n        TransferHelper.safeTransfer(token, to, amountToken);\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n\\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\\n        (, amountETH) = removeLiquidity(\\n            token,\\n            WETH,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            address(this),\\n            deadline\\n        );\\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\\n        IWETH(WETH).withdraw(amountETH);\\n        TransferHelper.safeTransferETH(to, amountETH);\\n    }\\n    // function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    //     address token,\\n    //     uint liquidity,\\n    //     uint amountTokenMin,\\n    //     uint amountETHMin,\\n    //     address to,\\n    //     uint deadline,\\n    //     bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    // ) external virtual override returns (uint amountETH) {\\n    //     // address pair = ExcavoLibrary.pairFor(factory, token, WETH);\\n    //     // uint value = approveMax ? uint(-1) : liquidity;\\n    //     // IExcavoPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n    //     // amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\\n    //     //     token, liquidity, amountTokenMin, amountETHMin, to, deadline\\n    //     // );\\n    // }\\n\\n    // **** SWAP ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swap(uint[] memory amounts, address[] memory path, address _to, uint discount) internal virtual {\\n        for (uint i; i < path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (address token0,) = ExcavoLibrary.sortTokens(input, output);\\n            uint amountOut = amounts[i + 1];\\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\n            address to = i < path.length - 2 ? ExcavoLibrary.pairFor(factory, output, path[i + 2]) : _to;\\n            \\n            IExcavoPair(ExcavoLibrary.pairFor(factory, input, output)).swap(\\n                amount0Out, amount1Out, to, new bytes(0), discount\\n            );\\n        }\\n    }\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        \\n        amounts = ExcavoLibrary.getAmountsOut(factory, amountIn, path, discount);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'ExcavoRouter: INSUFFICIENT_OUTPUT_AMOUNT');\\n        TransferHelper.safeTransferFrom(\\n            path[0], msg.sender, ExcavoLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        _swap(amounts, path, to, discount);\\n    }\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        \\n        amounts = ExcavoLibrary.getAmountsIn(factory, amountOut, path, discount);\\n        require(amounts[0] <= amountInMax, 'ExcavoRouter: EXCESSIVE_INPUT_AMOUNT');\\n        TransferHelper.safeTransferFrom(\\n            path[0], msg.sender, ExcavoLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        _swap(amounts, path, to, discount);\\n    }\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        virtual\\n        override\\n        payable \\n        ensure(deadline)\\n        returns (uint[] memory amounts)\\n    {\\n        require(path[0] == WETH, 'ExcavoRouter: INVALID_PATH');\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        \\n        amounts = ExcavoLibrary.getAmountsOut(factory, msg.value, path, discount);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'ExcavoRouter: INSUFFICIENT_OUTPUT_AMOUNT');\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(IWETH(WETH).transfer(ExcavoLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\\n        _swap(amounts, path, to, discount);\\n    }\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        virtual\\n        override \\n        ensure(deadline)\\n        returns (uint[] memory amounts)\\n    {\\n        require(path[path.length - 1] == WETH, 'ExcavoRouter: INVALID_PATH');\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        \\n        amounts = ExcavoLibrary.getAmountsIn(factory, amountOut, path, discount);\\n        require(amounts[0] <= amountInMax, 'ExcavoRouter: EXCESSIVE_INPUT_AMOUNT');\\n        TransferHelper.safeTransferFrom(\\n            path[0], msg.sender, ExcavoLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        _swap(amounts, path, address(this), discount);\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        virtual\\n        override \\n        ensure(deadline)\\n        returns (uint[] memory amounts)\\n    {\\n        require(path[path.length - 1] == WETH, 'ExcavoRouter: INVALID_PATH');\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        amounts = ExcavoLibrary.getAmountsOut(factory, amountIn, path, discount);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'ExcavoRouter: INSUFFICIENT_OUTPUT_AMOUNT');\\n        TransferHelper.safeTransferFrom(\\n            path[0], msg.sender, ExcavoLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n        );\\n        _swap(amounts, path, address(this), discount);\\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        virtual\\n        override\\n        payable \\n        ensure(deadline)\\n        returns (uint[] memory amounts)\\n    {\\n        require(path[0] == WETH, 'ExcavoRouter: INVALID_PATH');\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        \\n        amounts = ExcavoLibrary.getAmountsIn(factory, amountOut, path, discount);\\n        require(amounts[0] <= msg.value, 'ExcavoRouter: EXCESSIVE_INPUT_AMOUNT');\\n        IWETH(WETH).deposit{value: amounts[0]}();\\n        assert(IWETH(WETH).transfer(ExcavoLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\\n        _swap(amounts, path, to, discount);\\n        // refund dust eth, if any\\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n    }\\n\\n    // **** SWAP (supporting fee-on-transfer tokens) ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to, uint k) internal virtual {\\n        for (uint i; i < path.length - 1; i++) {\\n            {\\n            //(address input, address output) = (path[i], path[i + 1]);\\n            (address token0,) = ExcavoLibrary.sortTokens(path[i], path[i + 1]);\\n            IExcavoPair pair = IExcavoPair(ExcavoLibrary.pairFor(factory, path[i], path[i + 1]));\\n            uint amountInput;\\n            uint amountOutput;\\n            { // scope to avoid stack too deep errors\\n            (uint reserve0, uint reserve1,) = pair.getReserves();\\n            (uint reserveInput, uint reserveOutput) = path[i] == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n            amountInput = IERC20(path[i]).balanceOf(address(pair)).sub(reserveInput);\\n            amountOutput = ExcavoLibrary.getAmountOut(amountInput, reserveInput, reserveOutput, k);\\n            }\\n\\n            {\\n            (uint amount0Out, uint amount1Out) = path[i] == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\\n            address to = i < path.length - 2 ? ExcavoLibrary.pairFor(factory, path[i + 1], path[i + 2]) : _to;\\n            pair.swap(amount0Out, amount1Out, to, new bytes(0), k);\\n            }\\n            }\\n        }\\n    }\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external virtual override ensure(deadline) {\\n        TransferHelper.safeTransferFrom(\\n            path[0], msg.sender, ExcavoLibrary.pairFor(factory, path[0], path[1]), amountIn\\n        );\\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\n        {\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        _swapSupportingFeeOnTransferTokens(path, to, discount);\\n        }\\n        require(\\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\\n            'ExcavoRouter: INSUFFICIENT_OUTPUT_AMOUNT'\\n        );\\n    }\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        virtual\\n        override\\n        payable \\n        ensure(deadline)\\n    {\\n        require(path[0] == WETH, 'ExcavoRouter: INVALID_PATH');\\n        uint amountIn = msg.value;\\n        IWETH(WETH).deposit{value: amountIn}();\\n        assert(IWETH(WETH).transfer(ExcavoLibrary.pairFor(factory, path[0], path[1]), amountIn));\\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        _swapSupportingFeeOnTransferTokens(path, to, discount);\\n        require(\\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\\n            'ExcavoRouter: INSUFFICIENT_OUTPUT_AMOUNT'\\n        );\\n    }\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        virtual\\n        override \\n        ensure(deadline)\\n    {\\n        require(path[path.length - 1] == WETH, 'ExcavoRouter: INVALID_PATH');\\n        TransferHelper.safeTransferFrom(\\n            path[0], msg.sender, ExcavoLibrary.pairFor(factory, path[0], path[1]), amountIn\\n        );\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        _swapSupportingFeeOnTransferTokens(path, address(this), discount);\\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\\n        require(amountOut >= amountOutMin, 'ExcavoRouter: INSUFFICIENT_OUTPUT_AMOUNT');\\n        IWETH(WETH).withdraw(amountOut);\\n        TransferHelper.safeTransferETH(to, amountOut);\\n    }\\n\\n    // **** LIBRARY FUNCTIONS ****\\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\\n        return ExcavoLibrary.quote(amountA, reserveA, reserveB);\\n    }\\n\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint amountOut)\\n    {\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        \\n        return ExcavoLibrary.getAmountOut(amountIn, reserveIn, reserveOut, discount);\\n    }\\n\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint amountIn)\\n    {\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        \\n        return ExcavoLibrary.getAmountIn(amountOut, reserveIn, reserveOut, discount);\\n    }\\n\\n    function getAmountsOut(uint amountIn, address[] memory path)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint[] memory amounts)\\n    {\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        \\n        return ExcavoLibrary.getAmountsOut(factory, amountIn, path, discount);\\n    }\\n\\n    function getAmountsIn(uint amountOut, address[] memory path)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint[] memory amounts)\\n    {\\n        uint discount = TraderDiscount.calculateDiscount(ICAVO(CAVO).virtualBalanceOf(msg.sender));\\n        \\n        return ExcavoLibrary.getAmountsIn(factory, amountOut, path, discount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IExcavoRouter.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface IExcavoRouter {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function CAVO() external view returns (address);\\n    \\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    // function removeLiquidityWithPermit(\\n    //     address tokenA,\\n    //     address tokenB,\\n    //     uint liquidity,\\n    //     uint amountAMin,\\n    //     uint amountBMin,\\n    //     address to,\\n    //     uint deadline,\\n    //     bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    // ) external returns (uint amountA, uint amountB);\\n    // function removeLiquidityETHWithPermit(\\n    //     address token,\\n    //     uint liquidity,\\n    //     uint amountTokenMin,\\n    //     uint amountETHMin,\\n    //     address to,\\n    //     uint deadline,\\n    //     bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    // ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external view returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external view returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    // function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    //     address token,\\n    //     uint liquidity,\\n    //     uint amountTokenMin,\\n    //     uint amountETHMin,\\n    //     address to,\\n    //     uint deadline,\\n    //     bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    // ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TraderDiscount.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nimport '../interfaces/IERC20.sol';\\n\\nlibrary TraderDiscount {\\n    function calculateDiscount(uint tokenAmount) internal pure returns (uint k)  {\\n        k = 4;\\n        tokenAmount = tokenAmount / (10 ** 18);\\n        if (tokenAmount < 1 ) {\\n            k = 10;\\n        } else if (tokenAmount >= 1 && tokenAmount <= 5) {\\n            k = 9;\\n        } else if (tokenAmount > 5 && tokenAmount <= 10) {\\n            k = 8;\\n        } else if (tokenAmount > 10 && tokenAmount <= 20) {\\n            k = 7;\\n        } else if (tokenAmount > 20 && tokenAmount <= 50) {\\n            k = 6;\\n        } else if (tokenAmount > 50 && tokenAmount <= 100) {\\n            k = 5;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestExcavoRouter02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport '../ExcavoRouter.sol';\\n\\ncontract TestExcavoRouter is ExcavoRouter {\\n    constructor(address _factory, address _WETH, address _xCAVO) public ExcavoRouter(_factory, _WETH, _xCAVO) {}\\n\\n    function testSwap(address pair, uint amount0Out, uint amount1Out, address to, bytes calldata data, uint k) external {\\n        IExcavoPair(pair).swap(amount0Out, amount1Out, to, data, k);\\n    }\\n}\"\r\n    },\r\n    \"contracts/ExcavoFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport './interfaces/IExcavoFactory.sol';\\nimport './interfaces/IEXCV.sol';\\nimport './interfaces/ICAVO.sol';\\nimport './ExcavoPair.sol';\\n\\ncontract ExcavoFactory is IExcavoFactory {\\n    address public immutable override EXCVToken;\\n    address public immutable override CAVOToken;\\n    address public immutable override WETHToken;\\n    address public immutable override feeToSetter;\\n\\n    address public override router;\\n    // TODO: Remove\\n    bytes32 public immutable getCreationCode;\\n\\n    mapping(address => mapping(address => address)) public override getPair;\\n    address[] public override allPairs;\\n\\n    constructor(address _CAVO, address _EXCV, address _WETH) public {\\n        feeToSetter = msg.sender;\\n        CAVOToken = _CAVO;\\n        EXCVToken = _EXCV;\\n        WETHToken = _WETH;\\n        getCreationCode = keccak256(type(ExcavoPair).creationCode);\\n    }\\n\\n    function allPairsLength() external view override returns (uint) {\\n        return allPairs.length;\\n    }\\n\\n    function createPair(address tokenA, address tokenB) external override returns (address pair) {\\n        require(tokenA != tokenB, 'Excavo: FORBIDDEN');\\n        require(router != address(0), 'Excavo: ROUTER_NOT_SET');\\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'Excavo: ZERO_ADDRESS');\\n        require(getPair[token0][token1] == address(0), 'Excavo: PAIR_EXISTS'); // single check is sufficient\\n        bytes memory bytecode = type(ExcavoPair).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n        assembly {\\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n\\n        IExcavoPair(pair).initialize(token0, token1, router);\\n       \\n        if ((token0 == CAVOToken || token1 == CAVOToken) && (token0 == WETHToken || token1 == WETHToken)) {\\n            // enable CAVO farming for CAVO/ETH pair only\\n            IExcavoPair(pair).setCAVO(CAVOToken, ICAVO(CAVOToken).xCAVOToken());\\n        } else if ((token0 == EXCVToken || token1 == EXCVToken) && (token0 == WETHToken || token1 == WETHToken)) {\\n            // enable xCAVO contract permissions for EXCV/ETH pair only\\n            IExcavoPair(pair).setCAVO(address(0), ICAVO(CAVOToken).xCAVOToken());\\n        }\\n        \\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    function initialize(address _router) external override {\\n        require(msg.sender == feeToSetter && router == address(0), 'Excavo: FORBIDDEN');\\n        router = _router;\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/ExcavoOracleLibrary.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport '../interfaces/IExcavoPair.sol';\\nimport './FixedPoint.sol';\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary ExcavoOracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IExcavoPair(pair).price0CumulativeLast();\\n        price1Cumulative = IExcavoPair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IExcavoPair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.6;\\n\\nimport './Babylonian.sol';\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n    uint private constant Q112 = uint(1) << RESOLUTION;\\n    uint private constant Q224 = Q112 << RESOLUTION;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n\\n    // take the reciprocal of a UQ112x112\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\\n        return uq112x112(uint224(Q224 / self._x));\\n    }\\n\\n    // square root of a UQ112x112\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Babylonian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.6;\\n\\n// computes square roots using the babylonian method\\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\\nlibrary Babylonian {\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n        // else z = 0\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/FixedPointTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libraries/FixedPoint.sol\\\";\\n\\ncontract FixedPointTest {\\n    function encode(uint112 x) external pure returns (FixedPoint.uq112x112 memory) {\\n        return FixedPoint.encode(x);\\n    }\\n\\n    function encode144(uint144 x) external pure returns (FixedPoint.uq144x112 memory) {\\n        return FixedPoint.encode144(x);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(FixedPoint.uq112x112 calldata self, uint112 y) external pure returns (FixedPoint.uq112x112 memory) {\\n        return FixedPoint.div(self, y);\\n    }\\n\\n    function fraction(uint112 numerator, uint112 denominator) external pure returns (FixedPoint.uq112x112 memory) {\\n        return FixedPoint.fraction(numerator, denominator);\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    function mul(FixedPoint.uq112x112 calldata self, uint y) external pure returns (FixedPoint.uq144x112 memory) {\\n        return FixedPoint.mul(self, y);\\n    }\\n\\n    // decode a UQ112x112 in a uint container into a uint by truncating after the radix point\\n    function decode(FixedPoint.uq112x112 calldata self) external pure returns (uint112) {\\n        return FixedPoint.decode(self);\\n    }\\n\\n    function decode144(FixedPoint.uq144x112 calldata self) external pure returns (uint144) {\\n        return FixedPoint.decode144(self);\\n    }\\n\\n    function reciprocal(FixedPoint.uq112x112 calldata self) external pure returns (FixedPoint.uq112x112 memory) {\\n        return FixedPoint.reciprocal(self);\\n    }\\n\\n    function sqrt(FixedPoint.uq112x112 calldata self) external pure returns (FixedPoint.uq112x112 memory) {\\n        return FixedPoint.sqrt(self);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/BabylonianTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.6;\\n\\nimport '../libraries/Babylonian.sol';\\n\\n// used for testing the logic of token naming\\ncontract BabylonianTest {\\n    function sqrt(uint num) public pure returns (uint)  {\\n        return Babylonian.sqrt(num);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CAVO.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport './PublicPresale.sol';\\nimport './xCAVO.sol';\\nimport './EXCV.sol';\\nimport './TeamDistribution.sol';\\nimport './PrivatePresale.sol';\\n\\ncontract CAVO is PublicPresale, PrivatePresale, TeamDistribution {\\n    \\n    uint private constant PUBLIC_PRESALE_DURATION_IN_BLOCKS = 7 * 6500;\\n    uint32 private constant PRESALE_VESTING_PERIOD_IN_BLOCKS = 7 * 6500;\\n    \\n    uint private constant PRIVATE_PRESALE_DISTRIBUTED_CAVO_IN_WEI = 1460.769 ether;\\n    \\n    address private constant PUBLIC_PRESALE_OWNER = 0xAb96C12881A2E9Ffa6706Ae68bCFA4EcD1A8bf21;\\n\\n    address[] private teamAddresses = [\\n        0x381657fdE9bfE7558837757aC54249Ef748CACB7, // A.M.\\n        0x564569020c298D2487445CCa5C5ef3eD8cd408A3, // Y.O.\\n        0xDfe2abc3d395a87a1476f5B707E77f5F23B1d88b, // A.\\n        0x8CF3329E378c6196F35f5cB7eea5040873f8AC8C, // D.B.\\n        0x8B9a2b2d9a41909D613C81F2f344E364cD62b63C, // Z.\\n        0x57B93A6b8954938DE455BE95c9AA7843b99D7DEa, // V.\\n        0xf0393FB1e988317ca6E3fb986874D019dE712c7d, // M.\\n        0x698f4a1f42c3601579A3E40a9e4D90C2032C443a  // X.\\n    ];\\n\\n    uint[] private teamAmounts = [\\n        40000 ether, // A.M.\\n        40000 ether, // Y.O.\\n        15000 ether, // A.\\n        10000 ether, // D.B.\\n        50000 ether, // Z.\\n        30000 ether, // V.\\n        10000 ether, // M.\\n        5000  ether  // X.\\n    ];\\n    \\n    constructor() \\n        public \\n        PublicPresale(PUBLIC_PRESALE_OWNER, PRESALE_VESTING_PERIOD_IN_BLOCKS, PUBLIC_PRESALE_DURATION_IN_BLOCKS) \\n        PrivatePresale(PRESALE_VESTING_PERIOD_IN_BLOCKS, PRIVATE_PRESALE_DISTRIBUTED_CAVO_IN_WEI) \\n        TeamDistribution(PRESALE_VESTING_PERIOD_IN_BLOCKS, teamAddresses, teamAmounts) \\n    {\\n        address _xCAVO;\\n        address _EXCV;\\n        bytes memory xCAVOBytecode = type(xCAVO).creationCode;\\n        bytes memory EXCVBytecode = type(EXCV).creationCode;\\n        bytes32 xCAVOSalt = keccak256(abi.encodePacked(\\\"xCAVO\\\"));\\n        bytes32 EXCVSalt = keccak256(abi.encodePacked(\\\"EXCV\\\"));\\n        assembly {\\n            _xCAVO := create2(0, add(xCAVOBytecode, 32), mload(xCAVOBytecode), xCAVOSalt)\\n            _EXCV := create2(0, add(EXCVBytecode, 32), mload(EXCVBytecode), EXCVSalt)\\n        }\\n        xCAVOToken = _xCAVO;\\n        EXCVToken = _EXCV;\\n\\n        _mint(address(this), totalTeamDistribution.add(totalPrivatePresaleDistribution));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TransferHelperTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.6;\\n\\nimport '../libraries/TransferHelper.sol';\\n\\n// test helper for transfers\\ncontract TransferHelperTest {\\n    function safeApprove(address token, address to, uint value) external {\\n        TransferHelper.safeApprove(token, to, value);\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) external {\\n        TransferHelper.safeTransfer(token, to, value);\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) external {\\n        TransferHelper.safeTransferFrom(token, from, to, value);\\n    }\\n\\n    function safeTransferETH(address to, uint value) external {\\n        TransferHelper.safeTransferETH(to, value);\\n    }\\n}\\n\\n// can revert on failure and returns true if successful\\ncontract TransferHelperTestFakeERC20Compliant {\\n    bool public success;\\n    bool public shouldRevert;\\n\\n    function setup(bool success_, bool shouldRevert_) public {\\n        success = success_;\\n        shouldRevert = shouldRevert_;\\n    }\\n\\n    function transfer(address, uint256) public view returns (bool) {\\n        require(!shouldRevert, 'REVERT');\\n        return success;\\n    }\\n\\n    function transferFrom(address, address, uint256) public view returns (bool) {\\n        require(!shouldRevert, 'REVERT');\\n        return success;\\n    }\\n\\n    function approve(address, uint256) public view returns (bool) {\\n        require(!shouldRevert, 'REVERT');\\n        return success;\\n    }\\n}\\n\\n// only reverts on failure, no return value\\ncontract TransferHelperTestFakeERC20Noncompliant {\\n    bool public shouldRevert;\\n\\n    function setup(bool shouldRevert_) public {\\n        shouldRevert = shouldRevert_;\\n    }\\n\\n    function transfer(address, uint256) view public {\\n        require(!shouldRevert);\\n    }\\n\\n    function transferFrom(address, address, uint256) view public {\\n        require(!shouldRevert);\\n    }\\n\\n    function approve(address, uint256) view public {\\n        require(!shouldRevert);\\n    }\\n}\\n\\ncontract TransferHelperTestFakeFallback {\\n    bool public shouldRevert;\\n\\n    function setup(bool shouldRevert_) public {\\n        shouldRevert = shouldRevert_;\\n    }\\n\\n    receive() external payable {\\n        require(!shouldRevert);\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/test/RouterEventEmitter.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\n\\nimport '../interfaces/IExcavoRouter.sol';\\n\\ncontract RouterEventEmitter {\\n    event Amounts(uint[] amounts);\\n\\n    receive() external payable {}\\n\\n    function swapExactTokensForTokens(\\n        address router,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external {\\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\\n            IExcavoRouter(router).swapExactTokensForTokens.selector, amountIn, amountOutMin, path, to, deadline\\n        ));\\n        assert(success);\\n        emit Amounts(abi.decode(returnData, (uint[])));\\n    }\\n\\n    function swapTokensForExactTokens(\\n        address router,\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external {\\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\\n            IExcavoRouter(router).swapTokensForExactTokens.selector, amountOut, amountInMax, path, to, deadline\\n        ));\\n        assert(success);\\n        emit Amounts(abi.decode(returnData, (uint[])));\\n    }\\n\\n    function swapExactETHForTokens(\\n        address router,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable {\\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\\n            IExcavoRouter(router).swapExactETHForTokens.selector, amountOutMin, path, to, deadline\\n        ));\\n        assert(success);\\n        emit Amounts(abi.decode(returnData, (uint[])));\\n    }\\n\\n    function swapTokensForExactETH(\\n        address router,\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external {\\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\\n            IExcavoRouter(router).swapTokensForExactETH.selector, amountOut, amountInMax, path, to, deadline\\n        ));\\n        assert(success);\\n        emit Amounts(abi.decode(returnData, (uint[])));\\n    }\\n\\n    function swapExactTokensForETH(\\n        address router,\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external {\\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\\n            IExcavoRouter(router).swapExactTokensForETH.selector, amountIn, amountOutMin, path, to, deadline\\n        ));\\n        assert(success);\\n        emit Amounts(abi.decode(returnData, (uint[])));\\n    }\\n\\n    function swapETHForExactTokens(\\n        address router,\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable {\\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\\n            IExcavoRouter(router).swapETHForExactTokens.selector, amountOut, path, to, deadline\\n        ));\\n        assert(success);\\n        emit Amounts(abi.decode(returnData, (uint[])));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PrivateDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PrivateDistributionInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PublicDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PublicPresalePurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TeamDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CREATOR_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXCVToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"availablePrivatePresaleAmountOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"availablePublicPresaleAmountOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"availableTeamMemberAmountOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"editDistributed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"privatePresaleClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"privatePresaleDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"publicPresaleClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPrivatePresaleDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPublicPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPublicPresaleDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTeamDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"teamMemberClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPrivatePresaleDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTeamDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"virtualBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xCAVOToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CAVO", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}