{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/estake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.8.21;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations.\\r\\n *\\r\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\r\\n * now has built in overflow checking.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c < a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b > a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n            // benefit is lost if 'b' is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b <= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n/** \\r\\n * @dev a library for sorting leaderboard\\r\\n * https://gist.github.com/taobun/198cb6b2d620f687cacf665a791375cc\\r\\n */\\r\\ncontract School is Ownable {\\r\\n    mapping(address => uint256) public scores;\\r\\n    mapping(address => address) _nextStudents;\\r\\n    uint256 public listSize;\\r\\n    address constant GUARD = address(1);\\r\\n\\r\\n    constructor() {\\r\\n        _nextStudents[GUARD] = GUARD;\\r\\n    }\\r\\n\\r\\n    function addStudent(address student, uint256 score) public onlyOwner {\\r\\n        require(_nextStudents[student] == address(0), \\\"addStudent\\\");\\r\\n        address index = _findIndex(score);\\r\\n        scores[student] = score;\\r\\n        _nextStudents[student] = _nextStudents[index];\\r\\n        _nextStudents[index] = student;\\r\\n        listSize++;\\r\\n    }\\r\\n\\r\\n    function increaseScore(address student, uint256 score) public onlyOwner {\\r\\n        updateScore(student, scores[student] + score);\\r\\n    }\\r\\n\\r\\n    function reduceScore(address student, uint256 score) public onlyOwner {\\r\\n        updateScore(student, scores[student] - score);\\r\\n    }\\r\\n\\r\\n    function updateScore(address student, uint256 newScore) public onlyOwner {\\r\\n        require(_nextStudents[student] != address(0), \\\"updateScore\\\");\\r\\n        address prevStudent = _findPrevStudent(student);\\r\\n        address nextStudent = _nextStudents[student];\\r\\n        if(_verifyIndex(prevStudent, newScore, nextStudent)){\\r\\n            scores[student] = newScore;\\r\\n        } else {\\r\\n            removeStudent(student);\\r\\n            addStudent(student, newScore);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeStudent(address student) public onlyOwner {\\r\\n        require(_nextStudents[student] != address(0), \\\"removeStudent\\\");\\r\\n        address prevStudent = _findPrevStudent(student);\\r\\n        _nextStudents[prevStudent] = _nextStudents[student];\\r\\n        _nextStudents[student] = address(0);\\r\\n        scores[student] = 0;\\r\\n        listSize--;\\r\\n    }\\r\\n\\r\\n    function getTop(uint256 k) public view returns(address[] memory) {\\r\\n        require(k <= listSize);\\r\\n        address[] memory studentLists = new address[](k);\\r\\n        address currentAddress = _nextStudents[GUARD];\\r\\n        for(uint256 i = 0; i < k; ++i) {\\r\\n            studentLists[i] = currentAddress;\\r\\n            currentAddress = _nextStudents[currentAddress];\\r\\n        }\\r\\n        return studentLists;\\r\\n    }\\r\\n\\r\\n    function _verifyIndex(address prevStudent, uint256 newValue, address nextStudent)\\r\\n        internal\\r\\n        view\\r\\n        returns(bool)\\r\\n    {\\r\\n        return (prevStudent == GUARD || scores[prevStudent] >= newValue) && \\r\\n            (nextStudent == GUARD || newValue > scores[nextStudent]);\\r\\n    }\\r\\n\\r\\n    function _findIndex(uint256 newValue) internal view returns(address) {\\r\\n        address candidateAddress = GUARD;\\r\\n        while(true) {\\r\\n            if(_verifyIndex(candidateAddress, newValue, _nextStudents[candidateAddress]))\\r\\n                return candidateAddress;\\r\\n            candidateAddress = _nextStudents[candidateAddress];\\r\\n        }\\r\\n        return address(0);\\r\\n    }\\r\\n\\r\\n    function _isPrevStudent(address student, address prevStudent) internal view returns(bool) {\\r\\n        return _nextStudents[prevStudent] == student;\\r\\n    }\\r\\n\\r\\n    function _findPrevStudent(address student) internal view returns(address) {\\r\\n        address currentAddress = GUARD;\\r\\n        while(_nextStudents[currentAddress] != GUARD) {\\r\\n            if(_isPrevStudent(student, currentAddress))\\r\\n                return currentAddress;\\r\\n            currentAddress = _nextStudents[currentAddress];\\r\\n        }\\r\\n        return address(0);\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a staking mechanism\\r\\n */\\r\\ncontract EFOLIOStake is Context, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping(address => uint256) public staked;\\r\\n    uint256 public stakedLength = 0;\\r\\n    mapping(address => uint256) public lastClaim;\\r\\n\\r\\n    uint256 public startSessionTime;\\r\\n    uint256 public endSessionTime;\\r\\n\\r\\n    IERC20 public token;\\r\\n    School public school;\\r\\n\\r\\n    bool public leaderboardEnabled = true;\\r\\n    uint256 public stakeWindowDuration = 1 days;\\r\\n    uint256 public rewardWindowDuration = 1 days;\\r\\n\\r\\n    uint256 public totalStaked;\\r\\n    uint256 public endTotalStaked;\\r\\n    uint256 public totalReward;\\r\\n\\r\\n    event SessionStarted(uint256 timestamp);\\r\\n    event SessionEnded(uint256 timestamp);\\r\\n    event Staked(address indexed account, uint256 amount);\\r\\n    event ClaimedReward(address indexed account, uint256 value);\\r\\n    event Unstaked(address indexed account, uint256 amount);\\r\\n    \\r\\n    constructor(address tokenAddr) {\\r\\n        token = IERC20(tokenAddr);\\r\\n        school = new School();\\r\\n    }\\r\\n\\r\\n    function enableLeaderboard(bool enabled) external onlyOwner {\\r\\n        leaderboardEnabled = enabled;\\r\\n    }\\r\\n\\r\\n    function updateStakeWindowDuration(uint256 duration) external onlyOwner {\\r\\n        stakeWindowDuration = duration * (1 days);\\r\\n    }\\r\\n\\r\\n    function updateRewardWindowDuration(uint256 duration) external onlyOwner {\\r\\n        rewardWindowDuration = duration * (1 days);\\r\\n    }\\r\\n\\r\\n    function startSession() external onlyOwner {\\r\\n        require(startSessionTime == 0, \\\"session is running\\\");\\r\\n\\r\\n        (bool sent, ) = owner().call{value: address(this).balance}(\\\"\\\");\\r\\n        require(sent, \\\"transfer remained ETH failed\\\");\\r\\n\\r\\n        startSessionTime = block.timestamp;\\r\\n        endSessionTime = 0;\\r\\n\\r\\n        totalReward = 0;\\r\\n        endTotalStaked = 0;\\r\\n\\r\\n        emit SessionStarted(startSessionTime);\\r\\n    }\\r\\n\\r\\n    function endSession() external payable onlyOwner {\\r\\n        require(endSessionTime == 0, \\\"no session\\\");\\r\\n        \\r\\n        startSessionTime = 0;\\r\\n        endSessionTime = block.timestamp;\\r\\n\\r\\n        totalReward = msg.value;\\r\\n        endTotalStaked = totalStaked;\\r\\n\\r\\n        emit SessionEnded(endSessionTime);\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) external {\\r\\n        require(amount > 0, \\\"zero stake\\\");\\r\\n        address sender = _msgSender();\\r\\n        require(sender != owner(), \\\"owner, it's you?\\\");\\r\\n        require(\\r\\n            block.timestamp <= startSessionTime + stakeWindowDuration || \\r\\n            (block.timestamp <= endSessionTime + rewardWindowDuration && lastClaim[sender] > endSessionTime), \\r\\n            \\\"you late, wait for next session\\\"\\r\\n        );\\r\\n\\r\\n        staked[sender] += amount;\\r\\n        totalStaked += amount;\\r\\n\\r\\n        if (leaderboardEnabled) {\\r\\n            try school.increaseScore(sender, amount) {\\r\\n            } catch {\\r\\n                school.addStudent(sender, amount);\\r\\n                stakedLength++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        token.transferFrom(sender, address(this), amount);\\r\\n        \\r\\n        emit Staked(sender, amount);\\r\\n    }\\r\\n\\r\\n    function claimReward() external {\\r\\n        require(endSessionTime > 0, \\\"reward window is not open\\\");\\r\\n        require(block.timestamp <= endSessionTime + rewardWindowDuration, \\\"you missed this reward, maybe another time\\\");\\r\\n        address sender = _msgSender();\\r\\n        require(lastClaim[sender] < endSessionTime, \\\"double claim\\\");\\r\\n\\r\\n        lastClaim[sender] = block.timestamp;\\r\\n        uint256 stakedAmount = staked[sender];\\r\\n        require(stakedAmount > 0, \\\"reward is only for stakers\\\");\\r\\n\\r\\n        // uint256 value = (totalReward * ((stakedAmount * 1e18) / endTotalStaked)) / 1e18;\\r\\n        uint256 value = totalReward.mul((stakedAmount * 1e18).div(endTotalStaked)).div(1e18);\\r\\n        (bool sent, ) = _msgSender().call{value: value}(\\\"\\\");\\r\\n        require(sent, \\\"transfer reward failed\\\");\\r\\n\\r\\n        emit ClaimedReward(_msgSender(), value);\\r\\n    }\\r\\n\\r\\n    function unstake(uint256 amount) external {\\r\\n        require(amount > 0, \\\"zero unstake\\\");\\r\\n        address sender = _msgSender();\\r\\n        require(\\r\\n            block.timestamp <= startSessionTime + stakeWindowDuration || \\r\\n            (block.timestamp <= endSessionTime + rewardWindowDuration && lastClaim[sender] > endSessionTime) ||\\r\\n            (endSessionTime > 0 && block.timestamp > endSessionTime + rewardWindowDuration), \\r\\n            \\\"session is started, wait till end\\\"\\r\\n        );\\r\\n        uint256 senderStaked = staked[sender];\\r\\n        require(senderStaked >= amount, \\\"amount exceeds staked\\\");\\r\\n        unchecked {\\r\\n            staked[sender] = senderStaked - amount;\\r\\n            totalStaked = totalStaked - amount;\\r\\n        }\\r\\n\\r\\n        if (leaderboardEnabled) {\\r\\n            if (staked[sender] == 0) {\\r\\n                school.removeStudent(sender);\\r\\n                stakedLength--;\\r\\n            } else {\\r\\n                school.reduceScore(sender, amount);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        token.transfer(sender, amount);\\r\\n\\r\\n        emit Staked(_msgSender(), amount);\\r\\n    }\\r\\n\\r\\n    function getTop(uint256 k) public view returns(address[] memory) {\\r\\n        return school.getTop(k);\\r\\n    }\\r\\n\\r\\n    function claimRemainedReward() external onlyOwner {\\r\\n        require(block.timestamp > endSessionTime + rewardWindowDuration, \\\"reward window is still open\\\");\\r\\n\\r\\n        (bool sent, ) = owner().call{value: address(this).balance}(\\\"\\\");\\r\\n        require(sent, \\\"transfer remained ETH failed\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ClaimedReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SessionEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SessionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimRemainedReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"enableLeaderboard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endSession\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endSessionTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTotalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"}],\"name\":\"getTop\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leaderboardEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardWindowDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"school\",\"outputs\":[{\"internalType\":\"contract School\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeWindowDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startSession\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startSessionTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"updateRewardWindowDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"updateStakeWindowDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EFOLIOStake", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f3bf9b3ef3867d20a5ee51244f8b374b9d5e019e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}