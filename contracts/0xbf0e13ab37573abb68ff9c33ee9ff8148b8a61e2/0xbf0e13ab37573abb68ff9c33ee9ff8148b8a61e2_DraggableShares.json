{"SourceCode": "{\"Acquisition.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity \\u003e=0.7;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @title Acquisition Attempt\\n * @author Benjamin Rickenbacher, b.rickenbacher@intergga.ch\\n * @author Luzius Meisser, luzius@meissereconomics.com\\n *\\n */\\n\\ncontract Acquisition {\\n\\n    using SafeMath for uint256;\\n\\n    uint256 public constant VOTING_PERIOD = 60 days;    // 2months/60days\\n    uint256 public constant VALIDITY_PERIOD = 90 days;  // 3months/90days\\n\\n    uint256 public quorum;                              // Percentage of votes needed to start drag-along process\\n\\n    address private parent;                             // the parent contract\\n    address payable public buyer;                       // the person who made the offer\\n    \\n    address public currency;\\n    uint256 public price;                               // the price offered per share\\n    uint256 public timestamp;                           // the timestamp of the block in which the acquisition was created\\n\\n    uint256 public noVotes;                             // number of tokens voting for no\\n    uint256 public yesVotes;                            // number of tokens voting for yes\\n\\n    enum Vote { NONE, YES, NO }                         // Used internally, represents not voted yet or yes/no vote.\\n    mapping (address =\\u003e Vote) private votes;            // Who votes what\\n\\n    event VotesChanged(uint256 newYesVotes, uint256 newNoVotes);\\n\\n    constructor (address payable buyer_, address currency_, uint256 price_, uint256 quorum_) {\\n        require(price_ \\u003e 0, \\\"invalid price\\\");\\n        parent = msg.sender;\\n        buyer = buyer_;\\n        currency = currency_;\\n        price = price_;\\n        quorum = quorum_;\\n        timestamp = block.timestamp;\\n    }\\n\\n    function isWellFunded(uint256 sharesToAcquire) public view returns (bool) {\\n        IERC20 cur = IERC20(currency);\\n        uint256 buyerBalance = cur.balanceOf(buyer);\\n        uint256 buyerAllowance = cur.allowance(buyer, parent);\\n        uint256 xchfNeeded = sharesToAcquire.mul(price);\\n        return xchfNeeded \\u003c= buyerBalance \\u0026\\u0026 xchfNeeded \\u003c= buyerAllowance;\\n    }\\n\\n    function isQuorumReached() public view returns (bool) {\\n        if (isVotingOpen()) {\\n            // is it already clear that 75% will vote yes even though the vote is not over yet?\\n            return yesVotes.mul(10000).div(IERC20(parent).totalSupply()) \\u003e= quorum;\\n        } else {\\n            // did 75% of all cast votes say \\u0027yes\\u0027?\\n            return yesVotes.mul(10000).div(yesVotes.add(noVotes)) \\u003e= quorum;\\n        }\\n    }\\n\\n    function quorumHasFailed() public view returns (bool) {\\n        if (isVotingOpen()) {\\n            // is it already clear that 25% will vote no even though the vote is not over yet?\\n            return (IERC20(parent).totalSupply().sub(noVotes)).mul(10000).div(IERC20(parent).totalSupply()) \\u003c quorum;\\n        } else {\\n            // did 25% of all cast votes say \\u0027no\\u0027?\\n            return yesVotes.mul(10000).div(yesVotes.add(noVotes)) \\u003c quorum;\\n        }\\n    }\\n\\n    function adjustVotes(address from, address to, uint256 value) public parentOnly() {\\n        if (isVotingOpen()) {\\n            Vote fromVoting = votes[from];\\n            Vote toVoting = votes[to];\\n            update(fromVoting, toVoting, value);\\n        }\\n    }\\n\\n    function update(Vote previousVote, Vote newVote, uint256 votes_) internal {\\n        if (previousVote != newVote) {\\n            if (previousVote == Vote.NO) {\\n                noVotes = noVotes.sub(votes_);\\n            } else if (previousVote == Vote.YES) {\\n                yesVotes = yesVotes.sub(votes_);\\n            }\\n            if (newVote == Vote.NO) {\\n                noVotes = noVotes.add(votes_);\\n            } else if (newVote == Vote.YES) {\\n                yesVotes = yesVotes.add(votes_);\\n            }\\n            emit VotesChanged(yesVotes, noVotes);\\n        }\\n    }\\n\\n    function isVotingOpen() public view returns (bool) {\\n        uint256 age = block.timestamp.sub(timestamp);\\n        return age \\u003c= VOTING_PERIOD;\\n    }\\n\\n    function hasExpired() public view returns (bool) {\\n        uint256 age = block.timestamp.sub(timestamp);\\n        return age \\u003e VALIDITY_PERIOD;\\n    }\\n\\n    modifier votingOpen() {\\n        require(isVotingOpen(), \\\"The vote has ended.\\\");\\n        _;\\n    }\\n\\n    function voteYes(address sender, uint256 votes_) public parentOnly() votingOpen() {\\n        vote(Vote.YES, votes_, sender);\\n    }\\n\\n    function voteNo(address sender, uint256 votes_) public parentOnly() votingOpen() {\\n        vote(Vote.NO, votes_, sender);\\n    }\\n\\n    function vote(Vote newVote, uint256 votes_, address voter) internal {\\n        Vote previousVote = votes[voter];\\n        votes[voter] = newVote;\\n        update(previousVote, newVote, votes_);\\n    }\\n\\n    function hasVotedYes(address voter) public view returns (bool) {\\n        return votes[voter] == Vote.YES;\\n    }\\n\\n    function hasVotedNo(address voter) public view returns (bool) {\\n        return votes[voter] == Vote.NO;\\n    }\\n\\n    function kill() public parentOnly() {\\n        selfdestruct(buyer);\\n    }\\n\\n    modifier parentOnly () {\\n        require(msg.sender == parent, \\\"not parent\\\");\\n        _;\\n    }\\n}\"},\"DraggableShares.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity \\u003e=0.7;\\n\\nimport \\\"./ERC20Recoverable.sol\\\";\\nimport \\\"./ERC20Draggable.sol\\\";\\n\\n/**\\n * @title Draggable CompanyName AG Shares\\n * @author Benjamin Rickenbacher, b.rickenbacher@intergga.ch\\n * @author Luzius Meisser, luzius@meissereconomics.com\\n *\\n * This is an ERC-20 token representing shares of CompanyName AG that are bound to\\n * a shareholder agreement that can be found at the URL defined in the constant \\u0027terms\\u0027.\\n * The shareholder agreement is partially enforced through this smart contract. The agreement\\n * is designed to facilitate a complete acquisition of the firm even if a minority of shareholders\\n * disagree with the acquisition, to protect the interest of the minority shareholders by requiring\\n * the acquirer to offer the same conditions to everyone when acquiring the company, and to\\n * facilitate an update of the shareholder agreement even if a minority of the shareholders that\\n * are bound to this agreement disagree. The name \\\"draggable\\\" stems from the convention of calling\\n * the right to drag a minority along with a sale of the company \\\"drag-along\\\" rights. The name is\\n * chosen to ensure that token holders are aware that they are bound to such an agreement.\\n *\\n * The percentage of token holders that must agree with an update of the terms is defined by the\\n * constant UPDATE_QUORUM. The precentage of yes-votes that is needed to successfully complete an\\n * acquisition is defined in the constant ACQUISITION_QUORUM. Note that the update quorum is based\\n * on the total number of tokens in circulation. In contrast, the acquisition quorum is based on the\\n * number of votes cast during the voting period, not taking into account those who did not bother\\n * to vote.\\n */\\n\\ncontract DraggableShares is ERC20Recoverable, ERC20Draggable {\\n\\n    using SafeMath for uint256;\\n\\n    string public terms;\\n\\n    /**\\n     * Designed to be used with the Crypto Franc as currency token. See also parent constructor.\\n     */\\n    constructor(string memory _terms, address wrappedToken, uint256 quorum)\\n        ERC20Draggable(wrappedToken, quorum, quorum) {\\n        IRecoverable(wrappedToken).setRecoverable(false);\\n        terms = _terms; // to update the terms, migrate to a new contract. That way it is ensured that the terms can only be updated when the quorom agrees.\\n    }\\n\\n    /* function _mint(address account, uint256 amount) virtual override(ERC20Draggable, ERC20) internal {\\n        super._mint(account, amount);\\n    } */\\n\\n    function _burn(address account, uint256 amount) virtual override(ERC20Draggable, ERC20) internal {\\n        super._burn(account, amount);\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) override(ERC20Draggable, ERC20) internal {\\n        super._transfer(from, to, value);\\n    }\\n\\n    function transfer(address to, uint256 value) override(ERC20Recoverable, ERC20) public returns (bool) {\\n        return super.transfer(to, value);\\n    }\\n\\n    function getClaimDeleter() public view override returns (address) {\\n        return IRecoverable(address(wrapped)).getClaimDeleter();\\n    }\\n\\n    function getCollateralRate(address collateralType) public view override returns (uint256) {\\n        uint256 rate = super.getCollateralRate(collateralType);\\n        if (rate \\u003e 0) {\\n            return rate;\\n        } else if (collateralType == address(wrapped)) {\\n            return unwrapConversionFactor;\\n        } else {\\n            // If the wrapped contract allows for a specific collateral, we should too.\\n            // If the wrapped contract is not IRecoverable, we will fail here, but would fail anyway.\\n            return IRecoverable(address(wrapped)).getCollateralRate(collateralType).mul(unwrapConversionFactor);\\n        }\\n    }\\n\\n}\\n\\nabstract contract IRecoverable {\\n    function setRecoverable(bool) public virtual;\\n    function getCollateralRate(address) public virtual view returns (uint256);\\n    function getClaimDeleter() public virtual view returns (address);\\n}\"},\"ERC20.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: MIT\\n*\\n* Copyright (c) 2016-2019 zOS Global Limited\\n*\\n* With modifications to support ERC-677\\n*/\\npragma solidity \\u003e=0.7;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC677Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the `IERC20` interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\n * For a generic mechanism see `ERC20Mintable`.\\n *\\n * *For a detailed writeup see our guide [How to implement supply\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See `IERC20.approve`.\\n */\\n\\nabstract contract ERC20 is IERC20 {\\n\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    uint8 public override decimals;\\n\\n    constructor(uint8 _decimals) {\\n        decimals = _decimals;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.totalSupply`.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.balanceOf`.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transfer`.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.allowance`.\\n     */\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.approve`.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public override returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transferFrom`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `value`.\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to `transfer`, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a `Transfer` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(recipient != address(0));\\n\\n        _balances[sender] = _balances[sender].sub(amount);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    // ERC-677 functionality, can be useful for Market Maker and also wrapping tokens\\n    function transferAndCall(address recipient, uint amount, bytes calldata data) public returns (bool) {\\n        bool success = transfer(recipient, amount);\\n        if (success){\\n            IERC677Receiver(recipient).onTokenTransfer(msg.sender, amount, data);\\n        }\\n        return success;\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a `Transfer` event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n     /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a `Transfer` event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 value) internal virtual {\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller\\u0027s allowance.\\n     *\\n     * See `_burn` and `_approve`.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\\n    }\\n}\"},\"ERC20Draggable.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity \\u003e=0.7;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./Acquisition.sol\\\";\\nimport \\\"./IMigratable.sol\\\";\\nimport \\\"./IERC677Receiver.sol\\\";\\n\\n/**\\n * @title CompanyName Shareholder Agreement\\n * @author Benjamin Rickenbacher, b.rickenbacher@intergga.ch\\n * @author Luzius Meisser, luzius@meissereconomics.com\\n * @dev These tokens are based on the ERC20 standard and the open-zeppelin library.\\n *\\n * This is an ERC-20 token representing shares of CompanyName AG that are bound to\\n * a shareholder agreement that can be found at the URL defined in the constant \\u0027terms\\u0027\\n * of the \\u0027DraggableCompanyNameShares\\u0027 contract. The agreement is partially enforced\\n * through the Swiss legal system, and partially enforced through this smart contract.\\n * In particular, this smart contract implements a drag-along clause which allows the\\n * majority of token holders to force the minority sell their shares along with them in\\n * case of an acquisition. That\\u0027s why the tokens are called \\\"Draggable CompanyName AG Shares.\\\"\\n */\\n\\ncontract ERC20Draggable is ERC20, IERC677Receiver {\\n\\n    using SafeMath for uint256;\\n\\n    IERC20 public wrapped;                        // The wrapped contract\\n\\n    // If the wrapped tokens got replaced in an acquisition, unwrapping might yield many currency tokens\\n    uint256 public unwrapConversionFactor = 1;\\n\\n    // The current acquisition attempt, if any. See initiateAcquisition to see the requirements to make a public offer.\\n    Acquisition public offer;\\n\\n    uint256 public migrationQuorum;        // Number of tokens that need to be migrated to complete migration\\n    uint256 public acquisitionQuorum;\\n\\n    uint256 constant MIN_OFFER_INCREMENT = 10500;  // New offer must be at least 105% of old offer\\n    uint256 constant MIN_DRAG_ALONG_QUOTA = 3000;  // 30% of the equity needs to be represented by drag along tokens for an offer to be made\\n\\n    bool public active = true;                     // True as long as this contract is legally binding and the wrapped tokens are locked.\\n\\n    event OfferCreated(address indexed buyer, uint256 pricePerShare, address currency, address offerContract);\\n    event OfferEnded(address indexed buyer, address sender, bool success, string message, address offerContract);\\n    event MigrationSucceeded(address newContractAddress);\\n\\n    /**\\n     * CurrencyAddress specifies the currency used in acquisitions. The currency must be\\n     * an ERC-20 token that returns true on successful transfers and throws an exception or\\n     * returns false on failure. It can only be updated later if the currency supports the\\n     * IMigratable interface.\\n     */\\n    constructor(\\n        address wrappedToken,\\n        uint256 migrationQuorumInBIPS_,\\n        uint256 acquisitionQuorum_\\n    ) ERC20(0) {\\n        wrapped = IERC20(wrappedToken);\\n        migrationQuorum = migrationQuorumInBIPS_;\\n        acquisitionQuorum = acquisitionQuorum_;\\n        IShares(wrappedToken).totalShares(); // check if wrapped token supports this method\\n    }\\n\\n    function name() public override view returns (string memory){\\n        return string(abi.encodePacked(\\\"Draggable \\\", wrapped.name()));\\n    }\\n\\n    function symbol() public override view returns (string memory){\\n        return string(abi.encodePacked(\\\"D\\\", wrapped.symbol()));\\n    }\\n\\n    function onTokenTransfer(address from, uint256 amount, bytes calldata) override public {\\n        require(msg.sender == address(wrapped));\\n        dowrap(from, amount);\\n    }\\n\\n    /** Increases the number of drag-along tokens. Requires minter to deposit an equal amount of share tokens */\\n    function wrap(address shareholder, uint256 amount) public noOfferPending() {\\n        require(wrapped.transferFrom(msg.sender, address(this), amount));\\n        dowrap(shareholder, amount);\\n    }\\n\\n    function dowrap(address shareholder, uint256 amount) internal noOfferPending() {\\n        require(active, \\\"not active\\\");\\n        _mint(shareholder, amount);\\n    }\\n\\n    /** Decrease the number of drag-along tokens. The user gets back their shares in return */\\n    function unwrap(uint256 amount) public returns (address, uint256) {\\n        require(!active, \\\"active\\\");\\n        _burn(msg.sender, amount);\\n        uint256 unwrappedTokens = amount.mul(unwrapConversionFactor);\\n        require(wrapped.transfer(msg.sender, unwrappedTokens));\\n        return (address(wrapped), unwrappedTokens); // Pre August 2020 version did not have a return value\\n    }\\n\\n    /**\\n     * Burns both the token itself as well as the wrapped token!\\n     * If you want to get out of the shareholder agreement, use unwrap after it has been\\n     * deactivated by a majority vote or acquisition.\\n     *\\n     * Burning only works if wrapped token supports burning. Also, the exact meaning of this\\n     * operation might depend on the circumstances. Burning and reussing the wrapped token\\n     * does not free the sender from the legal obligations of the shareholder agreement.\\n     */\\n    function burn(uint256 amount) public {\\n        _burn(msg.sender, amount);\\n        IBurnable(address(wrapped)).burn(amount.mul(unwrapConversionFactor));\\n    }\\n\\n  /** @dev Function to start drag-along procedure\\n   *  This can be called by anyone, but there is an upfront payment.\\n   */\\n    function initiateAcquisition(uint256 pricePerShare, address currency) public {\\n        require(active);\\n        uint256 totalEquity = IShares(address(wrapped)).totalShares();\\n        require(totalSupply() \\u003e= totalEquity.mul(MIN_DRAG_ALONG_QUOTA).div(10000), \\\"This contract does not represent enough equity\\\");\\n\\n        // License Fee to Aktionariat AG, also ensures that offer is serious\\n        0x29Fe8914e76da5cE2d90De98a64d0055f199d06D.transfer(3 ether);\\n\\n        Acquisition newOffer = new Acquisition(msg.sender, currency, pricePerShare, acquisitionQuorum);\\n        require(newOffer.isWellFunded(totalSupply() - balanceOf(msg.sender)), \\\"Insufficient funding\\\");\\n        if (offerExists()) {\\n            require(currency == offer.currency() \\u0026\\u0026 pricePerShare \\u003e= offer.price().mul(MIN_OFFER_INCREMENT).div(10000), \\\"New offers must be at least 5% higher than the pending offer\\\");\\n            killAcquisition(\\\"Offer replaced by higher bid\\\");\\n        }\\n        offer = newOffer;\\n\\n        emit OfferCreated(msg.sender, pricePerShare, currency, address(offer));\\n    }\\n\\n    function voteYes() public offerPending() {\\n        offer.voteYes(msg.sender, balanceOf(msg.sender));\\n    }\\n\\n    function voteNo() public offerPending() {\\n        offer.voteNo(msg.sender, balanceOf(msg.sender));\\n    }\\n\\n    function cancelAcquisition() public offerPending() {\\n        require(msg.sender == offer.buyer());\\n        killAcquisition(\\\"Cancelled\\\");\\n    }\\n\\n    function contestAcquisition() public offerPending() {\\n        if (offer.hasExpired()) {\\n            killAcquisition(\\\"Expired\\\");\\n        } else if (offer.quorumHasFailed()) {\\n            killAcquisition(\\\"Not enough support\\\");\\n        } else if (!offer.isWellFunded(totalSupply() - balanceOf(offer.buyer()))) {\\n            killAcquisition(\\\"Insufficient funds\\\");\\n        }\\n    }\\n\\n    function killAcquisition(string memory message) internal {\\n        address buyer = offer.buyer();\\n        emit OfferEnded(\\n            buyer,\\n            msg.sender,\\n            false,\\n            message,\\n            address(offer)\\n        );\\n        offer.kill();\\n        offer = Acquisition(address(0));\\n    }\\n\\n    function completeAcquisition() public offerPending() {\\n        require(msg.sender == offer.buyer());\\n        require(offer.isQuorumReached(), \\\"Insufficient support\\\");\\n        //not necessary to check funding, will fail anyway if not enough\\n        //require(offer.isWellFunded(totalSupply() - balanceOf(buyer)), \\\"insufficient funds\\\");\\n        invertHoldings(msg.sender, offer.currency(), offer.price());\\n        emit OfferEnded(\\n            msg.sender,\\n            msg.sender,\\n            true,\\n            \\\"Success\\\",\\n            address(offer)\\n        );\\n    }\\n\\n    function invertHoldings(address newOwner, address newWrapped, uint256 conversionRate) internal {\\n        uint256 buyerBalance = balanceOf(newOwner);\\n        uint256 initialSupply = totalSupply();\\n        active = false;\\n        unwrap(buyerBalance);\\n        uint256 remaining = initialSupply.sub(buyerBalance);\\n        require(wrapped.transfer(newOwner, remaining));\\n        wrapped = IERC20(newWrapped);\\n        unwrapConversionFactor = conversionRate;\\n        require(wrapped.transferFrom(newOwner, address(this), conversionRate.mul(remaining)));\\n    }\\n\\n    function migrate() public {\\n        require(active, \\\"not active\\\");\\n        address successor = msg.sender;\\n        require(balanceOf(successor) \\u003e= totalSupply().mul(migrationQuorum).div(10000), \\\"Quorum not reached\\\");\\n\\n        if (offerExists()) {\\n            voteNo(); // should shut down the offer\\n            contestAcquisition();\\n            assert(!offerExists());\\n        }\\n\\n        invertHoldings(successor, successor, 1);\\n        emit MigrationSucceeded(successor);\\n    }\\n\\n    // not needed in the default implementation as wrap requires no offer\\n    /* function _mint(address account, uint256 amount) virtual override internal {\\n        super._mint(account, amount);\\n        if (offerExists() \\u0026\\u0026 active) {\\n            offer.adjustVotes(address(0), account, amount);\\n        }\\n    } */\\n\\n    function _transfer(address from, address to, uint256 value) virtual override internal {\\n        super._transfer(from, to, value);\\n        if (offerExists() \\u0026\\u0026 active) {\\n            offer.adjustVotes(from, to, value);\\n        }\\n    }\\n\\n    function _burn(address account, uint256 amount) virtual override internal {\\n        super._burn(account, amount);\\n        if (offerExists() \\u0026\\u0026 active) {\\n            offer.adjustVotes(account, address(0), amount);\\n        }\\n    }\\n\\n    function offerExists() internal view returns (bool) {\\n        return address(offer) != address(0);\\n    }\\n\\n    modifier offerPending() {\\n        require(offerExists() \\u0026\\u0026 active, \\\"no pending offer\\\");\\n        _;\\n    }\\n\\n    modifier noOfferPending() {\\n        require(!offerExists(), \\\"offer pending\\\");\\n        _;\\n    }\\n\\n}\\n\\nabstract contract IShares {\\n    function totalShares() virtual public returns (uint256);\\n}\\n\\nabstract contract IBurnable {\\n    function burn(uint256) virtual public;\\n}\"},\"ERC20Recoverable.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity \\u003e=0.7;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @title Recoverable\\n * In case of tokens that represent real-world assets such as shares of a company, one needs a way\\n * to handle lost private keys. With physical certificates, courts can declare share certificates as\\n * invalid so the company can issue replacements. Here, we want a solution that does not depend on\\n * third parties to resolve such cases. Instead, when someone has lost a private key, he can use the\\n * declareLost function to post a deposit and claim that the shares assigned to a specific address are\\n * lost. To prevent front running, a commit reveal scheme is used. If he actually is the owner of the shares,\\n * he needs to wait for a certain period and can then reclaim the lost shares as well as the deposit.\\n * If he is an attacker trying to claim shares belonging to someone else, he risks losing the deposit\\n * as it can be claimed at anytime by the rightful owner.\\n * Furthermore, if \\\"getClaimDeleter\\\" is defined in the subclass, the returned address is allowed to\\n * delete claims, returning the collateral. This can help to prevent obvious cases of abuse of the claim\\n * function.\\n */\\n\\nabstract contract ERC20Recoverable is ERC20 {\\n\\n    using SafeMath for uint256;\\n\\n    // A struct that represents a claim made\\n    struct Claim {\\n        address claimant; // the person who created the claim\\n        uint256 collateral; // the amount of collateral deposited\\n        uint256 timestamp;  // the timestamp of the block in which the claim was made\\n        address currencyUsed; // The currency (XCHF) can be updated, we record the currency used for every request\\n    }\\n\\n    uint256 public claimPeriod = 180 days; // Default of 180 days;\\n\\n    mapping(address =\\u003e Claim) public claims; // there can be at most one claim per address, here address is claimed address\\n    mapping(address =\\u003e bool) public recoveryDisabled; // disable claimability (e.g. for long term storage)\\n\\n    // ERC-20 token that can be used as collateral or 0x0 if disabled\\n    address public customCollateralAddress;\\n    uint256 public customCollateralRate;\\n\\n    /**\\n     * Returns the collateral rate for the given collateral type and 0 if that type\\n     * of collateral is not accepted. By default, only the token itself is accepted at\\n     * a rate of 1:1.\\n     *\\n     * Subclasses should override this method if they want to add additional types of\\n     * collateral.\\n     */\\n    function getCollateralRate(address collateralType) public virtual view returns (uint256) {\\n        if (collateralType == address(this)) {\\n            return 1;\\n        } else if (collateralType == customCollateralAddress) {\\n            return customCollateralRate;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * Allows subclasses to set a custom collateral besides the token itself.\\n     * The collateral must be an ERC-20 token that returns true on successful transfers and\\n     * throws an exception or returns false on failure.\\n     * Also, do not forget to multiply the rate in accordance with the number of decimals of the collateral.\\n     * For example, rate should be 7*10**18 for 7 units of a collateral with 18 decimals.\\n     */\\n    function _setCustomClaimCollateral(address collateral, uint256 rate) internal {\\n        customCollateralAddress = collateral;\\n        if (customCollateralAddress == address(0)) {\\n            customCollateralRate = 0; // disabled\\n        } else {\\n            require(rate \\u003e 0, \\\"Collateral rate can\\u0027t be zero\\\");\\n            customCollateralRate = rate;\\n        }\\n        emit CustomClaimCollateralChanged(collateral, rate);\\n    }\\n\\n    function getClaimDeleter() virtual public view returns (address);\\n\\n    /**\\n     * Allows subclasses to change the claim period, but not to fewer than 90 days.\\n     */\\n    function _setClaimPeriod(uint256 claimPeriodInDays) internal {\\n        require(claimPeriodInDays \\u003e 90, \\\"Claim period must be at least 90 days\\\"); // must be at least 90 days\\n        uint256 claimPeriodInSeconds = claimPeriodInDays.mul(1 days);\\n        claimPeriod = claimPeriodInSeconds;\\n        emit ClaimPeriodChanged(claimPeriod);\\n    }\\n\\n    function setRecoverable(bool enabled) public {\\n        recoveryDisabled[msg.sender] = !enabled;\\n    }\\n\\n    /**\\n     * Some users might want to disable claims for their address completely.\\n     * For example if they use a deep cold storage solution or paper wallet.\\n     */\\n    function isRecoveryEnabled(address target) public view returns (bool) {\\n        return !recoveryDisabled[target];\\n    }\\n\\n    event ClaimMade(address indexed lostAddress, address indexed claimant, uint256 balance);\\n    event ClaimCleared(address indexed lostAddress, uint256 collateral);\\n    event ClaimDeleted(address indexed lostAddress, address indexed claimant, uint256 collateral);\\n    event ClaimResolved(address indexed lostAddress, address indexed claimant, uint256 collateral);\\n    event ClaimPeriodChanged(uint256 newClaimPeriodInDays);\\n    event CustomClaimCollateralChanged(address newCustomCollateralAddress, uint256 newCustomCollareralRate);\\n\\n  /** Anyone can declare that the private key to a certain address was lost by calling declareLost\\n    * providing a deposit/collateral. There are three possibilities of what can happen with the claim:\\n    * 1) The claim period expires and the claimant can get the deposit and the shares back by calling recover\\n    * 2) The \\\"lost\\\" private key is used at any time to call clearClaim. In that case, the claim is deleted and\\n    *    the deposit sent to the shareholder (the owner of the private key). It is recommended to call recover\\n    *    whenever someone transfers funds to let claims be resolved automatically when the \\\"lost\\\" private key is\\n    *    used again.\\n    * 3) The owner deletes the claim and assigns the deposit to the claimant. This is intended to be used to resolve\\n    *    disputes. Generally, using this function implies that you have to trust the issuer of the tokens to handle\\n    *    the situation well. As a rule of thumb, the contract owner should assume the owner of the lost address to be the\\n    *    rightful owner of the deposit.\\n    * It is highly recommended that the owner observes the claims made and informs the owners of the claimed addresses\\n    * whenever a claim is made for their address (this of course is only possible if they are known to the owner, e.g.\\n    * through a shareholder register).\\n    * To prevent frontrunning attacks, a claim can only be made if the information revealed when calling \\\"declareLost\\\"\\n    * was previously commited using the \\\"prepareClaim\\\" function.\\n    */\\n    function declareLost(address collateralType, address lostAddress) public {\\n        require(isRecoveryEnabled(lostAddress), \\\"Claims disabled for this address\\\");\\n        uint256 collateralRate = getCollateralRate(collateralType);\\n        require(collateralRate \\u003e 0, \\\"Unsupported collateral\\\");\\n        address claimant = msg.sender;\\n        uint256 balance = balanceOf(lostAddress);\\n        uint256 collateral = balance.mul(collateralRate);\\n        IERC20 currency = IERC20(collateralType);\\n        require(balance \\u003e 0, \\\"Claimed address holds no shares\\\");\\n        require(claims[lostAddress].collateral == 0, \\\"Address already claimed\\\");\\n        require(currency.transferFrom(claimant, address(this), collateral), \\\"Collateral transfer failed\\\");\\n\\n        claims[lostAddress] = Claim({\\n            claimant: claimant,\\n            collateral: collateral,\\n            timestamp: block.timestamp,\\n            currencyUsed: collateralType\\n        });\\n\\n        emit ClaimMade(lostAddress, claimant, balance);\\n    }\\n\\n    function getClaimant(address lostAddress) public view returns (address) {\\n        return claims[lostAddress].claimant;\\n    }\\n\\n    function getCollateral(address lostAddress) public view returns (uint256) {\\n        return claims[lostAddress].collateral;\\n    }\\n\\n    function getCollateralType(address lostAddress) public view returns (address) {\\n        return claims[lostAddress].currencyUsed;\\n    }\\n\\n    function getTimeStamp(address lostAddress) public view returns (uint256) {\\n        return claims[lostAddress].timestamp;\\n    }\\n\\n    function transfer(address recipient, uint256 amount) override virtual public returns (bool) {\\n        require(super.transfer(recipient, amount), \\\"Transfer failed\\\");\\n        clearClaim();\\n        return true;\\n    }\\n\\n    /**\\n     * Clears a claim after the key has been found again and assigns the collateral to the \\\"lost\\\" address.\\n     * This is the price an adverse claimer pays for filing a false claim and makes it risky to do so.\\n     */\\n    function clearClaim() public {\\n        if (claims[msg.sender].collateral != 0) {\\n            uint256 collateral = claims[msg.sender].collateral;\\n            IERC20 currency = IERC20(claims[msg.sender].currencyUsed);\\n            delete claims[msg.sender];\\n            require(currency.transfer(msg.sender, collateral), \\\"Collateral transfer failed\\\");\\n            emit ClaimCleared(msg.sender, collateral);\\n        }\\n    }\\n\\n   /**\\n    * After the claim period has passed, the claimant can call this function to send the\\n    * tokens on the lost address as well as the collateral to himself.\\n    */\\n    function recover(address lostAddress) public {\\n        Claim memory claim = claims[lostAddress];\\n        uint256 collateral = claim.collateral;\\n        IERC20 currency = IERC20(claim.currencyUsed);\\n        require(collateral != 0, \\\"No claim found\\\");\\n        require(claim.claimant == msg.sender, \\\"Only claimant can resolve claim\\\");\\n        require(claim.timestamp.add(claimPeriod) \\u003c= block.timestamp, \\\"Claim period not over yet\\\");\\n        address claimant = claim.claimant;\\n        delete claims[lostAddress];\\n        require(currency.transfer(claimant, collateral), \\\"Collateral transfer failed\\\");\\n        _transfer(lostAddress, claimant, balanceOf(lostAddress));\\n        emit ClaimResolved(lostAddress, claimant, collateral);\\n    }\\n\\n    /**\\n     * This function is to be executed by the claim deleter only in case a dispute needs to be resolved manually.\\n     */\\n    function deleteClaim(address lostAddress) public {\\n        require(msg.sender == getClaimDeleter(), \\\"You cannot delete claims\\\");\\n        Claim memory claim = claims[lostAddress];\\n        IERC20 currency = IERC20(claim.currencyUsed);\\n        require(claim.collateral != 0, \\\"No claim found\\\");\\n        delete claims[lostAddress];\\n        require(currency.transfer(claim.claimant, claim.collateral), \\\"Collateral transfer failed\\\");\\n        emit ClaimDeleted(lostAddress, claim.claimant, claim.collateral);\\n    }\\n\\n}\"},\"IERC20.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: MIT\\n*\\n* Copyright (c) 2016-2019 zOS Global Limited\\n*\\n*/\\npragma solidity \\u003e=0.7;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\n\\ninterface IERC20 {\\n\\n    // Optional functions\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"IERC677Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Copied from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router02.sol\\npragma solidity \\u003e=0.7;\\n\\ninterface IERC677Receiver {\\n\\n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external;\\n\\n}\"},\"IMigratable.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\n*\\n* MIT License with Automated License Fee Payments\\n*\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\n*\\n* Permission is hereby granted to any person obtaining a copy of this software\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\n* without restriction, including without limitation the rights to use, copy,\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\n* Software, and to permit persons to whom the Software is furnished to do so,\\n* subject to the following conditions:\\n*\\n* - The above copyright notice and this permission notice shall be included in\\n*   all copies or substantial portions of the Software.\\n* - All automated license fee payments integrated into this and related Software\\n*   are preserved.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\npragma solidity \\u003e=0.7;\\n\\nabstract contract IMigratable {\\n    function migrationToContract() public virtual returns (address);\\n}\"},\"SafeMath.sol\":{\"content\":\"/**\\n* SPDX-License-Identifier: MIT\\n*\\n* Copyright (c) 2016-2019 zOS Global Limited\\n*/\\npragma solidity \\u003e=0.7;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\n\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n        return a / b;\\n    }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c \\u003e= a);\\n        return c;\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_terms\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quorum\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"ClaimCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"ClaimDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"ClaimMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newClaimPeriodInDays\",\"type\":\"uint256\"}],\"name\":\"ClaimPeriodChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"ClaimResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCustomCollateralAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCustomCollareralRate\",\"type\":\"uint256\"}],\"name\":\"CustomClaimCollateralChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newContractAddress\",\"type\":\"address\"}],\"name\":\"MigrationSucceeded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pricePerShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"offerContract\",\"type\":\"address\"}],\"name\":\"OfferCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"offerContract\",\"type\":\"address\"}],\"name\":\"OfferEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acquisitionQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelAcquisition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currencyUsed\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completeAcquisition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contestAcquisition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customCollateralAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customCollateralRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"declareLost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"deleteClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimDeleter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getClaimant\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getCollateralRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getCollateralType\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pricePerShare\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"initiateAcquisition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"isRecoveryEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offer\",\"outputs\":[{\"internalType\":\"contract Acquisition\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"recoveryDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setRecoverable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"terms\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unwrap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unwrapConversionFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteNo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteYes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapped\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DraggableShares", "CompilerVersion": "v0.7.3+commit.9bfce1f6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000092858d98503b78c6a4b86c8f673f6c9556f38b770000000000000000000000000000000000000000000000000000000000001d4c00000000000000000000000000000000000000000000000000000000000000235465737420416b74696f6e617269617420414720447261676761626c65205465726d730000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0ce406a31e6032107987afee43bb56ad764eadf0920fb4b72165d75b8ca1405c"}