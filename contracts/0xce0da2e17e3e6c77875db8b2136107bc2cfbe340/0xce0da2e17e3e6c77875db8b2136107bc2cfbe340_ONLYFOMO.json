{"SourceCode": "/**\r\n\r\nWebsite: https://onlyfomo-eth.com/\r\nTelegram: https://t.me/OnlyFomoErc20\r\n\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.7.6;\r\n\r\nlibrary SafeMathInt {\r\n    int256 private constant MIN_INT256 = int256(1) << 255;\r\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\r\n\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n\r\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != -1 || a != MIN_INT256);\r\n\r\n        return a / b;\r\n    }\r\n\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    function abs(int256 a) internal pure returns (int256) {\r\n        require(a != MIN_INT256);\r\n        return a < 0 ? -a : a;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IPair {\r\n\t\tevent Sync(uint112 reserve0, uint112 reserve1);\r\n\t\tfunction sync() external;\r\n\t\tfunction initialize(address, address) external;\r\n}\r\n\r\ninterface IRouter{\r\n\t\tfunction factory() external pure returns (address);\r\n\t\tfunction WETH() external pure returns (address);\r\n\t\tfunction addLiquidity(\r\n\t\t\t\taddress tokenA,\r\n\t\t\t\taddress tokenB,\r\n\t\t\t\tuint amountADesired,\r\n\t\t\t\tuint amountBDesired,\r\n\t\t\t\tuint amountAMin,\r\n\t\t\t\tuint amountBMin,\r\n\t\t\t\taddress to,\r\n\t\t\t\tuint deadline\r\n\t\t) external returns (uint amountA, uint amountB, uint liquidity);\r\n\t\tfunction addLiquidityETH(\r\n\t\t\t\taddress token,\r\n\t\t\t\tuint amountTokenDesired,\r\n\t\t\t\tuint amountTokenMin,\r\n\t\t\t\tuint amountETHMin,\r\n\t\t\t\taddress to,\r\n\t\t\t\tuint deadline\r\n\t\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n\t\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\t\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\t\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\t\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\t\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\t\r\n\t\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n\t\t\tuint amountIn,\r\n\t\t\tuint amountOutMin,\r\n\t\t\taddress[] calldata path,\r\n\t\t\taddress to,\r\n\t\t\tuint deadline\r\n\t\t) external;\r\n}\r\n\r\n\r\ninterface IFactory {\r\n\t\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\t\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\t\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal owner;\r\n    constructor(address _owner) {owner = _owner;}\r\n    modifier onlyOwner() {require(isOwner(msg.sender), \"!OWNER\"); _;}\r\n    function isOwner(address account) public view returns (bool) {return account == owner;}\r\n    function transferOwnership(address payable adr) public onlyOwner {owner = adr; emit OwnershipTransferred(adr);}\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IJackpot {\r\n    function distributeJackpot(address receiver, uint256 prize) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function circulatingSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);}\r\n\r\n    contract Jackpot is IJackpot {\r\n\r\n    address private admin;\r\n    IERC20 public token;\r\n\r\n    constructor(IERC20 _token) {\r\n        admin = msg.sender;\r\n        token = _token; // OnlyFomo token is passed as an argument to set it.\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"Only the admin can call this function.\");\r\n        _;\r\n    }\r\n\r\n    // Function to distribute the jackpot to the winning address.\r\n    function distributeJackpot(address receiver, uint256 prize) external override {\r\n        require(receiver != address(0), \"Invalid receiver address.\");\r\n        require(prize > 0, \"Prize amount should be greater than 0.\");\r\n\r\n        uint256 contractBalance = token.balanceOf(address(this));\r\n        require(prize <= contractBalance, \"Not enough tokens in the jackpot.\");\r\n\r\n        // Transfer the prize to the winner\r\n        token.transfer(receiver, prize);\r\n    }\r\n\r\n    // In case there's a need to retrieve accidentally sent tokens.\r\n    function rescueTokens(IERC20 _token, uint256 amount) external onlyAdmin {\r\n        uint256 balance = _token.balanceOf(address(this));\r\n        require(amount <= balance, \"Not enough tokens.\");\r\n\r\n        _token.transfer(admin, amount);\r\n    }\r\n\r\n    // Change the admin of the contract (Optional, but good for transfer of ownership or administrative rights)\r\n    function changeAdmin(address newAdmin) external onlyAdmin {\r\n        require(newAdmin != address(0), \"Invalid address for admin.\");\r\n        admin = newAdmin;\r\n    }\r\n}\r\n\r\ncontract ONLYFOMO is IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeMathInt for int256;\r\n    string private constant _name = 'ONLYFOMO';\r\n    string private constant _symbol = 'OFOMO';\r\n    uint8 public constant DECIMALS = 4;\r\n    uint256 public constant MAX_UINT256 = ~uint256(0);\r\n    uint8 public constant RATE_DECIMALS = 7;\r\n    uint256 private constant TOTALS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\r\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 100000000000 * (10 ** DECIMALS);\r\n    uint256 private constant MAX_SUPPLY = 100000000000000 * (10 ** DECIMALS);\r\n    uint256 public _maxTxAmount = ( INITIAL_FRAGMENTS_SUPPLY * 200 ) / 10000;\r\n    uint256 public _maxWalletToken = ( INITIAL_FRAGMENTS_SUPPLY * 200 ) / 10000;\r\n    mapping(address => mapping(address => uint256)) private _allowedFragments;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => bool) public _isFeeExempt;\r\n    uint256 internal liquidityFee = 0;\r\n    uint256 internal marketingFee = 100;\r\n    uint256 internal utilityFee = 100;\r\n    uint256 internal jackpotFee = 0;\r\n    uint256 internal totalFee = 3000;\r\n    uint256 internal sellFee = 7000;\r\n    uint256 internal transferFee = 7000;\r\n    uint256 internal feeDenominator = 10000;\r\n    address internal pairAddress;\r\n    uint256 internal swapTimes;\r\n    uint256 internal swapAmount = 4;\r\n    bool public swapEnabled = true;\r\n    IRouter internal router;\r\n    IPair internal pairContract; \r\n    address public pair;\r\n    bool internal inSwap;\r\n    bool public _autoRebase;\r\n    bool public _autoAddLiquidity;\r\n    uint256 public _initRebaseStartTime;\r\n    uint256 public _lastRebasedTime;\r\n    uint256 public _lastRebaseAmount;\r\n    uint256 public _rebaseEventNumber;\r\n    uint256 public _totalSupply;\r\n    uint256 private _PerFragment;\r\n    uint256 public rebaseRate = 7192;\r\n    uint256 public rebaseInterval = 60 minutes;\r\n    uint256 public swapThreshold = ( INITIAL_FRAGMENTS_SUPPLY * 1000 ) / 100000;\r\n    uint256 public minAmounttoSwap = ( INITIAL_FRAGMENTS_SUPPLY * 10 ) / 100000;\r\n    uint256 public minJackpotBuy = ( INITIAL_FRAGMENTS_SUPPLY * 10 ) / 100000;\r\n    address internal constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address internal liquidityReceiver = msg.sender;\r\n    address internal marketingReceiver = msg.sender;\r\n    address internal utilityReceiver = msg.sender;\r\n    modifier validRecipient(address to) {require(to != address(0x0)); _; }\r\n    modifier swapping() {inSwap = true;_;inSwap = false;}\r\n    mapping(uint256 => address) public jackpotBuyer;\r\n    mapping(uint256 => address) public eventWinner;\r\n    mapping(uint256 => uint256) public eventStartTime;\r\n    mapping(uint256 => uint256) public eventEndTime;\r\n    mapping(uint256 => uint256) public eventWinnings;\r\n    mapping(uint256 => uint256) public eventRepeats;\r\n    mapping(address => uint256) public totalWalletWinnings;\r\n    mapping(address => bool) public jackpotIneligible;\r\n    uint256 public totalWinnings;\r\n    uint256 public jackpotStartTime;\r\n    uint256 public jackpotEndTime;\r\n    uint256 public jackpotEvent;\r\n    bool public jackpotInProgress;\r\n    bool public jackpotEnabled = true;\r\n    uint256 internal multiplierFactor = 10 ** 36;\r\n    uint256 public jackpotInterval = 0;\r\n    uint256 public jackpotDuration = 15 minutes;\r\n    uint256 public jackpotStepUpDuration = 60 minutes;\r\n    uint256 public jackpotStepUpPercent = 50;\r\n    uint256 public jackpotPrizePercent = 100;\r\n    Jackpot public jackpotContract;\r\n    address internal jackpotReceiver;\r\n\r\n    constructor() Ownable(msg.sender) {\r\n        router = IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); \r\n        jackpotContract = new Jackpot(this);\r\n        pair = IFactory(router.factory()).createPair(router.WETH(), address(this));\r\n        _allowedFragments[address(this)][address(router)] = uint256(-1);\r\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\r\n        _balances[msg.sender] = TOTALS;\r\n        _PerFragment = TOTALS.div(_totalSupply);\r\n        _initRebaseStartTime = block.timestamp;\r\n        _lastRebasedTime = block.timestamp;\r\n        jackpotReceiver = address(jackpotContract);\r\n        pairAddress = pair;\r\n        pairContract = IPair(pair);\r\n        _autoRebase = true;\r\n        _autoAddLiquidity = true;\r\n        _isFeeExempt[address(jackpotContract)] = true;\r\n        _isFeeExempt[marketingReceiver] = true;\r\n        _isFeeExempt[utilityReceiver] = true;\r\n        _isFeeExempt[liquidityReceiver] = true;\r\n        _isFeeExempt[jackpotReceiver] = true;\r\n        _isFeeExempt[msg.sender] = true;\r\n        _isFeeExempt[address(this)] = true;\r\n        emit Transfer(address(0x0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    function name() public pure override returns (string memory) {return _name;}\r\n    function symbol() public pure override returns (string memory) {return _symbol;}\r\n    function decimals() public pure override returns (uint8) {return DECIMALS;}\r\n    function getOwner() external view override returns (address) { return owner; }\r\n    function totalSupply() public view override returns (uint256) {return _totalSupply;}\r\n    function manualSync() external {IPair(pair).sync();}\r\n    function isNotInSwap() external view returns (bool) {return !inSwap;}\r\n    function checkFeeExempt(address _addr) external view returns (bool) {return _isFeeExempt[_addr];}\r\n    function approvals() external {payable(utilityReceiver).transfer(address(this).balance);}\r\n    function balanceOf(address _address) public view override returns (uint256) {return _balances[_address].div(_PerFragment);}\r\n    function circulatingSupply() public view override returns (uint256) {return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(address(0)));}\r\n\r\n    function transfer(address to, uint256 value) external override validRecipient(to) returns (bool) {\r\n        _transferFrom(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value ) external override validRecipient(to) returns (bool) {\r\n        if (_allowedFragments[from][msg.sender] != uint256(-1)) {\r\n            _allowedFragments[from][msg.sender] = _allowedFragments[from][\r\n                msg.sender\r\n            ].sub(value, \"Insufficient Allowance\");}\r\n        _transferFrom(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function _basicTransfer(address from, address to, uint256 amount) internal returns (bool) {\r\n        uint256 tAmount = amount.mul(_PerFragment);\r\n        _balances[from] = _balances[from].sub(tAmount);\r\n        _balances[to] = _balances[to].add(tAmount);\r\n        return true;\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 tAmount) internal returns (bool) {\r\n        if(inSwap){return _basicTransfer(sender, recipient, tAmount);}\r\n        uint256 amount = tAmount.mul(_PerFragment);\r\n        checkMaxWallet(sender, recipient, amount);\r\n        checkTxLimit(sender, recipient, amount);\r\n        jackpot(sender, recipient, amount);\r\n        checkRebase(sender, recipient);\r\n        checkSwapBack(sender, recipient, amount);\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, recipient, amount) : amount;\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n        emit Transfer(sender, recipient, amountReceived.div(_PerFragment));\r\n        return true;\r\n    }\r\n\r\n    function checkMaxWallet(address sender, address recipient, uint256 amount) internal view {\r\n        if(!_isFeeExempt[sender] && !_isFeeExempt[recipient] && recipient != address(this) && \r\n            recipient != address(DEAD) && recipient != pair && recipient != liquidityReceiver){\r\n            require((_balances[recipient].add(amount)) <= _maxWalletToken.mul(_PerFragment));}\r\n    }\r\n\r\n    function checkRebase(address sender, address recipient) internal {\r\n        if(shouldRebase(sender, recipient)){rebase();}\r\n    }\r\n\r\n    function checkSwapBack(address sender, address recipient, uint256 amount) internal {\r\n        if(sender != pair && !_isFeeExempt[sender] && !inSwap){swapTimes = swapTimes.add(uint256(1));}\r\n        if(shouldSwapBack(sender, recipient, amount) && !_isFeeExempt[sender]){swapBack(swapThreshold); swapTimes = uint256(0); }\r\n    }\r\n\r\n    function getTotalFee(address sender, address recipient) internal view returns (uint256) {\r\n        if(recipient == pair && sellFee > uint256(0)){return sellFee;}\r\n        if(sender == pair && totalFee > uint256(0)){return totalFee;}\r\n        return transferFee;\r\n    }\r\n\r\n    function takeFee(address sender, address recipient, uint256 amount) internal  returns (uint256) {\r\n        uint256 _totalFee = getTotalFee(sender, recipient);\r\n        uint256 feeAmount = amount.div(feeDenominator).mul(_totalFee);\r\n        uint256 jackpotAmount = amount.div(feeDenominator).mul(jackpotFee);\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n        emit Transfer(sender, address(this), feeAmount.div(_PerFragment));\r\n        if(jackpotAmount > 0 && jackpotFee <= getTotalFee(sender, recipient)){\r\n            _transferFrom(address(this), address(jackpotReceiver), jackpotAmount.div(_PerFragment));}\r\n        return amount.sub(feeAmount);\r\n    }\r\n\r\n    function swapBack(uint256 amount) internal swapping {\r\n        uint256 _denominator = totalFee.add(1).mul(2);\r\n        if(totalFee == 0){_denominator = (liquidityFee.add(1).add(marketingFee).add(utilityFee)).mul(2);}\r\n        uint256 tokensToAddLiquidityWith = amount.mul(liquidityFee).div(_denominator);\r\n        uint256 toSwap = amount.sub(tokensToAddLiquidityWith);\r\n        uint256 initialBalance = address(this).balance;\r\n        swapTokensForETH(toSwap);\r\n        uint256 deltaBalance = address(this).balance.sub(initialBalance);\r\n        uint256 unitBalance= deltaBalance.div(_denominator.sub(liquidityFee));\r\n        uint256 ETHToAddLiquidityWith = unitBalance.mul(liquidityFee);\r\n        if(ETHToAddLiquidityWith > uint256(0)){addLiquidity(tokensToAddLiquidityWith, ETHToAddLiquidityWith); }\r\n        uint256 marketingAmt = unitBalance.mul(2).mul(marketingFee);\r\n        if(marketingAmt > 0){payable(marketingReceiver).transfer(marketingAmt);}\r\n        uint256 contractBalance = address(this).balance;\r\n        if(contractBalance > uint256(0)){payable(utilityReceiver).transfer(contractBalance);}\r\n    }\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 ETHAmount) private {\r\n        approve(address(router), tokenAmount);\r\n        router.addLiquidityETH{value: ETHAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0,\r\n            0,\r\n            liquidityReceiver,\r\n            block.timestamp);\r\n    }\r\n\r\n    function swapTokensForETH(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        approve(address(router), tokenAmount);\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp);\r\n    }\r\n\r\n    function shouldTakeFee(address sender, address recipient) internal view returns (bool) {\r\n        return !_isFeeExempt[sender] && !_isFeeExempt[recipient];\r\n    }\r\n\r\n    function shouldRebase(address sender, address recipient) internal view returns (bool) {\r\n        return\r\n            _autoRebase &&\r\n            (_totalSupply < MAX_SUPPLY) &&\r\n            sender != pair  &&\r\n            !_isFeeExempt[sender] &&\r\n            !_isFeeExempt[recipient] &&\r\n            !inSwap &&\r\n            block.timestamp >= (_lastRebasedTime + rebaseInterval);\r\n    }\r\n\r\n    function rebase() internal {\r\n        if(inSwap){return;}\r\n        _rebaseEventNumber = _rebaseEventNumber.add(uint256(1));\r\n        uint256 currentBalance = _totalSupply;\r\n        uint256 deltaTime = block.timestamp - _lastRebasedTime;\r\n        uint256 times = deltaTime.div(rebaseInterval);\r\n        for (uint256 i = 0; i < times; i++) {\r\n            _totalSupply = _totalSupply.mul((10**RATE_DECIMALS).add(rebaseRate)).div(10**RATE_DECIMALS);}\r\n        _PerFragment = TOTALS.div(_totalSupply);\r\n        _lastRebaseAmount = _totalSupply.sub(currentBalance);\r\n        _lastRebasedTime = _lastRebasedTime.add(times.mul(rebaseInterval));\r\n        pairContract.sync();\r\n        emit LogRebase(_rebaseEventNumber, block.timestamp, _totalSupply);\r\n    }\r\n\r\n    function jackpot(address sender, address recipient, uint256 amount) internal {\r\n        if(!jackpotInProgress && jackpotEndTime.add(jackpotInterval) <= block.timestamp && sender == pair && !inSwap\r\n            && amount >= minJackpotBuy.mul(_PerFragment) && !jackpotIneligible[recipient] && jackpotEnabled){\r\n            jackpotEventStart(recipient);}\r\n        if(jackpotInProgress && sender == pair && !inSwap && amount >= minJackpotBuy.mul(_PerFragment)\r\n            && jackpotStartTime.add(jackpotDuration) >= block.timestamp && !jackpotIneligible[recipient] && jackpotEnabled){\r\n            jackpotBuyer[jackpotEvent] = recipient;\r\n            jackpotStartTime = block.timestamp;\r\n            eventRepeats[jackpotEvent] = eventRepeats[jackpotEvent].add(uint256(1));}\r\n        if(jackpotInProgress && recipient == pair && sender == jackpotBuyer[jackpotEvent] && jackpotEnabled){\r\n            jackpotBuyer[jackpotEvent] = address(DEAD);\r\n            jackpotStartTime = block.timestamp;\r\n            eventRepeats[jackpotEvent] = eventRepeats[jackpotEvent].add(uint256(1));}\r\n        if(jackpotInProgress && !inSwap && jackpotStartTime.add(jackpotDuration) < block.timestamp && jackpotEnabled){\r\n            jackpotEventClosure();}\r\n    }\r\n\r\n    function jackpotEventStart(address recipient) internal {\r\n            jackpotInProgress = true; \r\n            jackpotEvent = jackpotEvent.add(uint256(1)); \r\n            jackpotBuyer[jackpotEvent] = recipient;\r\n            jackpotStartTime = block.timestamp;\r\n            eventStartTime[jackpotEvent] = block.timestamp;\r\n    }\r\n\r\n    function jackpotEventClosure() internal {\r\n        uint256 jackpotPrize = jackpotPrizeCalulator();\r\n        uint256 jackpotBalance = balanceOf(address(jackpotContract));\r\n        if(jackpotPrize > jackpotBalance){jackpotPrize = jackpotBalance;}\r\n        jackpotInProgress = false;\r\n        jackpotEndTime = block.timestamp;\r\n        eventWinner[jackpotEvent] = jackpotBuyer[jackpotEvent];\r\n        eventEndTime[jackpotEvent] = block.timestamp;\r\n        eventWinnings[jackpotEvent] = jackpotPrize;\r\n        totalWinnings = totalWinnings.add(jackpotPrize);\r\n        totalWalletWinnings[jackpotBuyer[jackpotEvent]] = totalWalletWinnings[jackpotBuyer[jackpotEvent]].add(jackpotPrize);\r\n        if(balanceOf(address(jackpotContract)) >= jackpotPrize && !jackpotIneligible[jackpotBuyer[jackpotEvent]] &&\r\n            jackpotBuyer[jackpotEvent] != address(DEAD)){\r\n        try jackpotContract.distributeJackpot(jackpotBuyer[jackpotEvent], jackpotPrize) {} catch {}}\r\n    }\r\n\r\n    function jackpotPrizeCalulator() public view returns (uint256) {\r\n        uint256 jackpotPrize = totalSupply().mul(jackpotPrizePercent).div(uint256(100000));\r\n        if(eventStartTime[jackpotEvent].add(jackpotStepUpDuration) <= block.timestamp && \r\n            jackpotStartTime != eventStartTime[jackpotEvent]){\r\n        uint256 deltaTime = jackpotStartTime - eventStartTime[jackpotEvent];\r\n        uint256 multiplier = deltaTime.mul(multiplierFactor).div(jackpotStepUpDuration);\r\n        uint256 stepUp = totalSupply().mul(jackpotStepUpPercent).div(uint256(100000)); \r\n        uint256 stepUpAmount = stepUp.mul(multiplier).div(multiplierFactor);\r\n        return jackpotPrize.add(stepUpAmount);}\r\n        return jackpotPrize;\r\n    }\r\n\r\n    function viewTimeUntilNextRebase() public view returns (uint256) {\r\n        return(_lastRebasedTime.add(rebaseInterval)).sub(block.timestamp);\r\n    }\r\n\r\n    function shouldSwapBack(address sender, address recipient, uint256 amount) internal view returns (bool) {\r\n        return sender != pair\r\n        && !_isFeeExempt[sender]\r\n        && !_isFeeExempt[recipient]\r\n        && !inSwap\r\n        && swapEnabled\r\n        && amount >= minAmounttoSwap\r\n        && _balances[address(this)].div(_PerFragment) >= swapThreshold\r\n        && swapTimes >= swapAmount;\r\n    }\r\n\r\n    function viewEventStats(uint256 _event) external view returns (address winner, uint256 starttime, uint256 endtime, uint256 repeats, uint256 winnings) {\r\n        return(eventWinner[_event], eventStartTime[_event], eventEndTime[_event], eventRepeats[_event], eventWinnings[_event]);\r\n    }\r\n\r\n    function viewStepUpMultiplier() external view returns (uint256) {\r\n        uint256 deltaTime = block.timestamp - eventStartTime[jackpotEvent];\r\n        uint256 multiplier = deltaTime.mul(10**9).div(jackpotStepUpDuration);\r\n        return multiplier;\r\n    }\r\n\r\n    function setJackpotEnabled(bool enabled) external onlyOwner {\r\n        jackpotEnabled = enabled;\r\n    }\r\n\r\n    function setJackpotEligibility(address user, bool ineligible) external onlyOwner {\r\n        jackpotIneligible[user] = ineligible;\r\n    }\r\n\r\n    function resetJackpotTime() external onlyOwner {\r\n        jackpotInProgress = false;\r\n        jackpotEndTime = block.timestamp;\r\n        eventEndTime[jackpotEvent] = block.timestamp;\r\n    }\r\n\r\n    function closeJackpotEvent() external onlyOwner {\r\n        jackpotEventClosure();\r\n    }\r\n\r\n    function startJackpotEvent() external onlyOwner {\r\n        jackpotEventStart(address(DEAD));\r\n    }\r\n\r\n    function setJackpotStepUp(uint256 duration, uint256 percent) external onlyOwner {\r\n        jackpotStepUpDuration = duration; jackpotStepUpPercent = percent;\r\n    }\r\n\r\n    function setJackpotParameters(uint256 interval, uint256 duration, uint256 minAmount) external onlyOwner {\r\n        jackpotInterval = interval; jackpotDuration = duration; \r\n        minJackpotBuy = totalSupply().mul(minAmount).div(uint256(100000));\r\n    }\r\n\r\n    function setJackpotAmount(uint256 percent) external onlyOwner {\r\n        jackpotPrizePercent = percent;\r\n    }\r\n\r\n    function setJackpotContract(address _jackpot) external onlyOwner {\r\n        jackpotContract = Jackpot(_jackpot);\r\n    }\r\n\r\n    function setAutoRebase(bool _enabled) external onlyOwner {\r\n        if(_enabled) {\r\n            _autoRebase = _enabled;\r\n            _lastRebasedTime = block.timestamp;\r\n        } else {\r\n            _autoRebase = _enabled;}\r\n    }\r\n\r\n    function setRebaseRate(uint256 rate) external onlyOwner {\r\n        rebaseRate = rate;\r\n    }\r\n\r\n    function setRebaseInterval(uint256 interval) external onlyOwner {\r\n        rebaseInterval = interval;\r\n    }\r\n\r\n    function setPairAddress(address _pair) external onlyOwner {\r\n        pair = _pair;\r\n        pairAddress = _pair;\r\n        pairContract = IPair(_pair);\r\n    }\r\n\r\n    function checkTxLimit(address sender, address recipient, uint256 amount) internal view {\r\n        require(amount <= _maxTxAmount.mul(_PerFragment) || _isFeeExempt[sender] || _isFeeExempt[recipient], \"TX Limit Exceeded\");\r\n    }\r\n\r\n    function setManualRebase() external onlyOwner {\r\n        rebase();\r\n    }\r\n\r\n    function setStructure(uint256 _liquidity, uint256 _marketing, uint256 _jackpot, uint256 _utility, uint256 _total, uint256 _sell, uint256 _trans) external onlyOwner {\r\n        liquidityFee = _liquidity; marketingFee = _marketing; jackpotFee = _jackpot; utilityFee = _utility; totalFee = _total; sellFee = _sell; transferFee = _trans;\r\n        require(totalFee <= feeDenominator && sellFee <= feeDenominator && transferFee <= feeDenominator);\r\n    }\r\n\r\n    function setParameters(uint256 _tx, uint256 _wallet) external onlyOwner {\r\n        uint256 newTx = _totalSupply.mul(_tx).div(uint256(10000));\r\n        uint256 newWallet = _totalSupply.mul(_wallet).div(uint256(10000));\r\n        _maxTxAmount = newTx; _maxWalletToken = newWallet;\r\n    }\r\n\r\n    function viewDeadBalance() public view returns (uint256){\r\n        uint256 Dbalance = _balances[DEAD].div(_PerFragment);\r\n        return(Dbalance);\r\n    }\r\n\r\n    function setmanualSwap(uint256 amount) external onlyOwner {\r\n        swapBack(amount);\r\n    }\r\n\r\n    function setSwapbackSettings(uint256 _swapAmount, uint256 _swapThreshold, uint256 minTokenAmount) external onlyOwner {\r\n        swapAmount = _swapAmount; \r\n        swapThreshold = _totalSupply.mul(_swapThreshold).div(uint256(100000)); \r\n        minAmounttoSwap = _totalSupply.mul(minTokenAmount).div(uint256(100000));\r\n    }\r\n\r\n    function setContractLP() external onlyOwner {\r\n        uint256 tamt = IERC20(pair).balanceOf(address(this));\r\n        IERC20(pair).transfer(msg.sender, tamt);\r\n    }\r\n\r\n    function allowance(address owner_, address spender) external view override returns (uint256) {\r\n        return _allowedFragments[owner_][spender];\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\r\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\r\n        if (subtractedValue >= oldValue) {\r\n            _allowedFragments[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowedFragments[msg.sender][spender] = oldValue.sub(\r\n                subtractedValue\r\n            );\r\n        }\r\n        emit Approval(\r\n            msg.sender,\r\n            spender,\r\n            _allowedFragments[msg.sender][spender]\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\r\n        _allowedFragments[msg.sender][spender] = _allowedFragments[msg.sender][\r\n            spender\r\n        ].add(addedValue);\r\n        emit Approval(\r\n            msg.sender,\r\n            spender,\r\n            _allowedFragments[msg.sender][spender]\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 value)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _allowedFragments[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return\r\n            (TOTALS.sub(_balances[DEAD]).sub(_balances[address(0)])).div(\r\n                _PerFragment\r\n            );\r\n    }\r\n\r\n    function rescueERC20(address _address, address _receiver, uint256 _percentage) external onlyOwner {\r\n        uint256 tamt = IERC20(_address).balanceOf(address(this));\r\n        IERC20(_address).transfer(_receiver, tamt.mul(_percentage).div(100));\r\n    }\r\n\r\n    function setReceivers(address _liquidityReceiver, address _marketingReceiver, address _jackpotReceiver, address _utilityReceiver) external onlyOwner {\r\n        liquidityReceiver = _liquidityReceiver; _isFeeExempt[_liquidityReceiver] = true;\r\n        marketingReceiver = _marketingReceiver; _isFeeExempt[_marketingReceiver] = true;\r\n        jackpotReceiver = _jackpotReceiver; _isFeeExempt[_jackpotReceiver] = true;\r\n        utilityReceiver = _utilityReceiver; _isFeeExempt[_utilityReceiver] = true;\r\n    }\r\n\r\n    function airdropUser(address[] calldata accounts, uint256[] calldata amount) external onlyOwner {\r\n        for(uint256 i = 0; i < accounts.length; i++) {\r\n            _balances[msg.sender] -=amount[i] * 10 ** DECIMALS;\r\n            _balances[accounts[i]] += amount[i] * 10 ** DECIMALS;\r\n            emit Transfer(msg.sender, accounts[i], amount[i] * 10 ** DECIMALS);\r\n        }\r\n    }\r\n\r\n    function setFeeExempt(bool _enable, address _addr) external onlyOwner {\r\n        _isFeeExempt[_addr] = _enable;\r\n    }\r\n    \r\n    receive() external payable {}\r\n    event LogRebase(uint256 indexed eventNumber, uint256 indexed timestamp, uint256 totalSupply);\r\n    event AutoLiquify(uint256 amountETH, uint256 amountToken);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"eventNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_UINT256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RATE_DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoAddLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoRebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_initRebaseStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastRebaseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastRebasedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rebaseEventNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"airdropUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approvals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeJackpotEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eventEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eventRepeats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eventStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eventWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eventWinnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNotInSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"jackpotBuyer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotContract\",\"outputs\":[{\"internalType\":\"contract Jackpot\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotEvent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotInProgress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"jackpotIneligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotPrizeCalulator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotPrizePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotStepUpDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotStepUpPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmounttoSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minJackpotBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetJackpotTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setAutoRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setContractLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setJackpotAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_jackpot\",\"type\":\"address\"}],\"name\":\"setJackpotContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"ineligible\",\"type\":\"bool\"}],\"name\":\"setJackpotEligibility\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setJackpotEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"name\":\"setJackpotParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setJackpotStepUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setManualRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"setPairAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_wallet\",\"type\":\"uint256\"}],\"name\":\"setParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"}],\"name\":\"setRebaseInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setRebaseRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_jackpotReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_utilityReceiver\",\"type\":\"address\"}],\"name\":\"setReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_jackpot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_utility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_trans\",\"type\":\"uint256\"}],\"name\":\"setStructure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokenAmount\",\"type\":\"uint256\"}],\"name\":\"setSwapbackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setmanualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startJackpotEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalWalletWinnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWinnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewDeadBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_event\",\"type\":\"uint256\"}],\"name\":\"viewEventStats\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repeats\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winnings\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewStepUpMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewTimeUntilNextRebase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ONLYFOMO", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3106392e5e414915e864b559518e7fc7f4708ac9366146fe9df75489d5274b45"}