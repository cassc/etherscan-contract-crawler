{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AlienRunesGenerator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport './IAlienRunesGenerator.sol';\\nimport './IFilters.sol';\\nimport './SVG.sol';\\nimport './Catmull.sol';\\nimport './Shapes.sol';\\nimport './Traits.sol';\\nimport './Random.sol';\\nimport './Gradients.sol';\\n\\n\\n\\n/*\\n\\n                  \u2588\u2588\u2588\u2588\u2588                  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \\n                \u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588               \u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588 \\n               \u2588\u2588\u2588   \u2591\u2591\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2591\u2588\u2588\u2588    \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588    \u2591\u2588\u2588\u2588 \\n              \u2591\u2588\u2588\u2588    \u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \\n              \u2591\u2588\u2588\u2588    \u2591\u2588\u2588\u2588 \u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2591   \u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588 \\n              \u2591\u2591\u2588\u2588\u2588   \u2588\u2588\u2588   \u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588    \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588    \u2591\u2588\u2588\u2588 \\n               \u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2591   \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\\n                 \u2591\u2591\u2591\u2591\u2591\u2591   \u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591   \u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591   \u2591\u2591\u2591\u2591\u2591 \\n\\n\\n\\n                                \u2591\u2591                                              \\n                               \u2592\u2593\u2593\u2592                                             \\n                              \u2591\u2593\u2593\u2593\u2592                                             \\n                              \u2592\u2593\u2593\u2593\u2592                                             \\n                             \u2592\u2593\u2593\u2593\u2593\u2592                   \u2591\u2591\u2591                       \\n                    \u2591\u2591       \u2593\u2588\u2593\u2593\u2593\u2592     \u2591\u2592\u2591        \u2591\u2592\u2593\u2593\u2593\u2591                       \\n                   \u2591\u2592\u2593\u2592     \u2592\u2593\u2593\u2593\u2593\u2593\u2592    \u2592\u2592\u2593       \u2591\u2592\u2593\u2593\u2593\u2592\u2591                        \\n                   \u2591\u2592\u2593\u2593\u2591    \u2593\u2588\u2593\u2593\u2593\u2593\u2592   \u2591\u2592\u2592\u2591    \u2591\u2592\u2593\u2593\u2593\u2593\u2593\u2592            \u2591\u2591\u2591\u2591\u2591         \\n                    \u2592\u2593\u2593\u2592\u2591   \u2592\u2593\u2588\u2593\u2593\u2593\u2592  \u2591\u2591\u2591\u2591    \u2591\u2593\u2593\u2593\u2592\u2593\u2593\u2591     \u2591\u2591\u2591\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592         \\n                    \u2592\u2593\u2593\u2593\u2592   \u2591\u2593\u2588\u2593\u2593\u2588\u2593 \u2592\u2593\u2591\u2591\u2591   \u2591\u2593\u2593\u2593\u2593\u2593\u2592    \u2591\u2592\u2593\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2591          \\n                    \u2591\u2593\u2593\u2592\u2593\u2592   \u2592\u2588\u2588\u2593\u2588\u2593\u2591\u2593\u2593\u2592\u2592   \u2591\u2593\u2593\u2593\u2593\u2593\u2592   \u2591\u2592\u2593\u2588\u2593\u2593\u2593\u2592\u2592\u2593\u2593\u2592\u2592              \\n                    \u2591\u2593\u2593\u2593\u2593\u2593\u2591  \u2592\u2593\u2588\u2593\u2588\u2593\u2592\u2593\u2593\u2593\u2592  \u2591\u2593\u2593\u2593\u2593\u2593\u2591  \u2591\u2592\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2591                 \\n              \u2591      \u2592\u2593\u2593\u2593\u2593\u2593\u2591 \u2591\u2593\u2588\u2593\u2588\u2593\u2592\u2593\u2593\u2593\u2591  \u2592\u2593\u2593\u2593\u2593\u2591 \u2591\u2592\u2593\u2588\u2593\u2593\u2593\u2588\u2593\u2593\u2592\u2591                   \\n              \u2592\u2592\u2592     \u2592\u2593\u2593\u2593\u2593\u2593\u2591 \u2592\u2593\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2591 \u2592\u2593\u2593\u2593\u2593\u2591\u2591\u2592\u2593\u2588\u2588\u2593\u2588\u2593\u2593\u2592\u2591                      \\n  \u2591\u2592\u2592\u2591         \u2592\u2592\u2592\u2591    \u2591\u2593\u2593\u2593\u2593\u2593\u2591\u2591\u2593\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2591\u2592\u2593\u2593\u2593\u2592\u2591\u2592\u2593\u2588\u2588\u2588\u2593\u2593\u2593\u2592\u2591\u2592\u2593\u2593\u2592\u2591\u2592\u2592\u2592\u2592\u2592\u2593\u2592            \\n  \u2591\u2592\u2593\u2593\u2593\u2592\u2591\u2591      \u2591\u2591\u2591\u2591\u2591   \u2591\u2593\u2593\u2593\u2593\u2593\u2591\u2592\u2593\u2588\u2593\u2593\u2593\u2593\u2592\u2591\u2593\u2593\u2593\u2592\u2591\u2593\u2588\u2588\u2593\u2593\u2593\u2593\u2592\u2593\u2593\u2593\u2593\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591               \\n   \u2591\u2592\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2591    \u2591\u2592\u2591\u2591\u2592\u2591   \u2592\u2593\u2593\u2593\u2593\u2591\u2593\u2593\u2592 \u2592\u2592   \u2591   \u2592\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2591                      \\n     \u2591\u2593\u2593\u2593\u2593\u2592\u2593\u2593\u2592\u2592\u2591  \u2592\u2593\u2593\u2593\u2593\u2593\u2592  \u2592\u2593\u2593\u2593\u2592              \u2591\u2593\u2593\u2593\u2593\u2593\u2592\u2591                          \\n       \u2592\u2593\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2592\u2591\u2591\u2593\u2593\u2592                  \u2591\u2592\u2592\u2592\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2591\u2591          \\n         \u2592\u2593\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2588\u2593\u2593\u2593\u2592\u2592\u2593\u2593\u2593\u2593\u2593\u2591                   \u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2591\u2591      \\n          \u2591\u2592\u2593\u2593\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2588\u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2591                     \u2592\u2592\u2592\u2592\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2593\u2593\u2593\u2591    \\n               \u2591\u2592\u2593\u2593\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2591                      \u2591\u2593\u2593\u2593\u2593\u2592\u2591              \u2591\u2591\u2591     \\n      \u2591\u2591             \u2591\u2592\u2593\u2593\u2593\u2593\u2588\u2592                      \u2591\u2593\u2593\u2588\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2592\u2591                \\n    \u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2592\u2591                     \u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2588\u2588\u2593\u2593\u2588\u2588\u2588\u2588\u2593\u2593\u2593\u2592           \\n      \u2591\u2591\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592                   \u2591\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2593\u2593\u2593\u2588\u2593\u2593\u2593\u2593\u2593\u2588\u2588\u2593\u2592         \\n          \u2591\u2591\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2591                 \u2591\u2593\u2593\u2591\u2591\u2592\u2593\u2593\u2593\u2593\u2593\u2591\u2591\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2588\u2593\u2592       \\n               \u2591\u2591\u2591\u2591        \u2591\u2592\u2592\u2593\u2593\u2593\u2591              \u2591\u2593\u2593\u2593\u2592  \u2592\u2593\u2593\u2593\u2593\u2593\u2592  \u2591\u2592\u2593\u2593\u2593\u2592\u2593\u2593\u2593\u2593\u2591     \\n                      \u2591\u2592\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592       \u2591\u2592 \u2591\u2592\u2592\u2591\u2592\u2593\u2593\u2593\u2592\u2591  \u2591\u2592\u2591\u2591\u2592\u2591    \u2591\u2592\u2592\u2593\u2593\u2593\u2593\u2593\u2592\u2591   \\n                \u2591\u2591\u2591\u2591\u2591\u2591\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2588\u2588\u2593\u2592\u2591\u2592\u2593\u2593\u2591\u2591\u2593\u2593\u2592\u2593\u2588\u2593\u2593\u2591\u2593\u2593\u2593\u2593\u2593\u2591   \u2591\u2591\u2591\u2591\u2591      \u2591\u2592\u2592\u2593\u2593\u2593\u2592\u2591  \\n            \u2592\u2592\u2592\u2592\u2593\u2592\u2592\u2591\u2591\u2593\u2593\u2593\u2592\u2591\u2592\u2593\u2593\u2588\u2588\u2588\u2593\u2593\u2592\u2592\u2593\u2593\u2593\u2592 \u2592\u2593\u2593\u2593\u2593\u2588\u2588\u2593\u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2591    \u2591\u2592\u2592\u2592         \u2592\u2592\u2593\u2592  \\n                       \u2591\u2592\u2593\u2588\u2593\u2593\u2588\u2588\u2593\u2592 \u2592\u2593\u2593\u2593\u2593\u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2588\u2588\u2588\u2592 \u2591\u2593\u2593\u2593\u2593\u2593\u2592     \u2592\u2592\u2592\u2591             \\n                    \u2591\u2592\u2593\u2588\u2593\u2593\u2593\u2588\u2588\u2593\u2592 \u2591\u2592\u2593\u2593\u2593\u2593\u2591 \u2591\u2593\u2593\u2593\u2592\u2593\u2588\u2588\u2588\u2593\u2591 \u2591\u2593\u2593\u2593\u2593\u2593\u2593      \u2592\u2591             \\n                 \u2591\u2592\u2592\u2593\u2593\u2593\u2593\u2593\u2588\u2588\u2593\u2592   \u2593\u2593\u2593\u2593\u2593\u2592  \u2591\u2593\u2593\u2593\u2592\u2593\u2588\u2593\u2588\u2593\u2592  \u2591\u2593\u2593\u2593\u2593\u2593\u2591                    \\n              \u2591\u2592\u2592\u2593\u2593\u2592\u2593\u2593\u2593\u2588\u2588\u2593\u2592   \u2591\u2593\u2593\u2593\u2593\u2593\u2592   \u2592\u2592\u2593\u2593\u2591\u2592\u2588\u2593\u2593\u2588\u2593\u2591  \u2591\u2593\u2592\u2593\u2593\u2592                    \\n           \u2591\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2588\u2588\u2593\u2592    \u2591\u2593\u2593\u2593\u2593\u2593\u2592   \u2591\u2591\u2591\u2593\u2593 \u2592\u2588\u2593\u2593\u2588\u2593\u2591   \u2592\u2593\u2593\u2593\u2593                    \\n         \u2591\u2592\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2591\u2591    \u2591\u2592\u2593\u2592\u2593\u2593\u2593\u2592    \u2591\u2591\u2591\u2591  \u2592\u2593\u2593\u2593\u2593\u2588\u2593   \u2591\u2592\u2593\u2593\u2593                    \\n         \u2591\u2592\u2592\u2592\u2591\u2591           \u2591\u2592\u2593\u2593\u2593\u2593\u2593\u2591     \u2592\u2592\u2591   \u2591\u2593\u2593\u2593\u2593\u2588\u2593\u2591   \u2591\u2592\u2593\u2593\u2591                   \\n                         \u2591\u2593\u2592\u2593\u2593\u2592\u2591      \u2592\u2592\u2592    \u2591\u2593\u2593\u2593\u2593\u2588\u2593     \u2591\u2593\u2593\u2591                   \\n                        \u2592\u2593\u2593\u2592\u2591        \u2591\u2592\u2592     \u2591\u2593\u2593\u2593\u2593\u2593\u2591      \u2591\u2591                    \\n                        \u2592\u2592\u2591                  \u2591\u2593\u2593\u2593\u2593\u2592                             \\n                                             \u2591\u2593\u2593\u2593\u2593\u2591                             \\n                                             \u2591\u2593\u2593\u2593\u2592                              \\n                                             \u2591\u2593\u2593\u2592\u2591                              \\n                                              \u2592\u2592                                \\n    \\n*/\\n\\ncontract AlienRunesGenerator is IAlienRunesGenerator {\\n    IFilters filters;\\n\\n    constructor(IFilters _filters) {\\n        filters = _filters;\\n    }\\n\\n    function genRndAndTraits(uint256 _tokenId) private pure returns (RandomCtx memory rndCtx, Traits.TraitsCtx memory traits) {\\n        rndCtx = Random.initCtx(_tokenId);\\n        traits = Traits.generateTraitsCtx(rndCtx);\\n    }\\n\\n    function renderAsSvgInternal(uint256 _tokenId) private view returns (string memory result, Traits.TraitsCtx memory traits) {\\n        RandomCtx memory rndCtx;\\n\\n        (rndCtx, traits) = genRndAndTraits(_tokenId);\\n\\n        result = renderAsSvgInternalByTraits(traits, rndCtx);\\n    }\\n\\n    function renderAsSvgInternalByTraits(Traits.TraitsCtx memory traits, RandomCtx memory rndCtx) private view returns (string memory result) {\\n        string memory randomized;\\n        uint256 maxDistance;\\n\\n        (randomized, maxDistance) = Shapes.generateShape(rndCtx, traits);\\n\\n        string memory placed = \\\"\\\";\\n        string memory placedInDef = \\\"\\\";\\n\\n        (placed, placedInDef) = Shapes.shapePlacer(\\n            \\\"shape\\\",\\n            \\\"placedShape\\\",\\n            traits.shapePlacement\\n        );\\n\\n        placed = filters.applyAllFilters(traits.filter, placed);\\n\\n        result = string.concat(\\n            Svg.svgMainElement(maxDistance, traits.shape.viewBoxBuffer),\\n            Svg.defs(\\n                \\\"\\\",\\n                string.concat(\\n                    Gradients.createGradientMain(\\\"g1\\\", traits.gradient),\\n                    filters.generateAllFilterStrings(rndCtx, traits.filter),\\n                    Svg.g(Svg.prop(\\\"id\\\", \\\"shape\\\"), randomized),\\n                    placedInDef\\n                )\\n            ),\\n            placed,\\n            \\\"</svg>\\\"\\n        );\\n    }\\n\\n    function renderAsSvg(uint256 _tokenId) external view override returns (string memory) {\\n        string memory result;\\n\\n        (result, ) = renderAsSvgInternal(_tokenId);\\n\\n        return result;\\n    }\\n\\n    function renderAsSvgAndAttributes(uint256 _tokenId) external view override returns (string memory result, string memory attributes) {\\n        Traits.TraitsCtx memory traits;\\n\\n        (result, traits) = renderAsSvgInternal(_tokenId);\\n        attributes = Traits.getTraitsAsJsonString(traits);\\n\\n        return (result, attributes);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IAlienRunesGenerator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\ninterface IAlienRunesGenerator {\\n    function renderAsSvg(uint256 _tokenId) external view returns (string memory result);\\n    function renderAsSvgAndAttributes(uint256 _tokenId) external view returns (string memory svg, string memory attributes);\\n}\"\r\n    },\r\n    \"contracts/IFilters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport './FilterTraits.sol';\\nimport './RandomCtx.sol';\\n\\ninterface IFilters {\\n    function generateAllFilterStrings(RandomCtx memory rndCtx, FilterTraits memory filter) external view returns (string memory);\\n    function applyAllFilters(FilterTraits memory filter, string memory svgElement) external view returns (string memory);\\n}\"\r\n    },\r\n    \"contracts/SVG.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"./Utils.sol\\\";\\n\\n// Core SVG utilitiy library which helps us construct\\n// onchain SVG's with a simple, web-like API.\\nlibrary Svg {\\n    using Utils for uint256;\\n\\n    /* MAIN ELEMENTS */\\n    function g(string memory _props, string memory _children) internal pure returns (string memory) {\\n        return el('g', _props, _children);\\n    }\\n\\n    function symbol(string memory _props, string memory _children) internal pure returns (string memory) {\\n        return el('symbol', _props, _children);\\n    }\\n\\n    function defs(string memory _props, string memory _children) internal pure returns (string memory) {\\n        return el('defs', _props, _children);\\n    }\\n\\n    function use(string memory _props, string memory _children) internal pure returns (string memory) {\\n        return el('use', _props, _children);\\n    }\\n\\n    function path(string memory _props, string memory _children) internal pure returns (string memory) {\\n        return el('path', _props, _children);\\n    }\\n\\n    function text(string memory _props, string memory _children) internal pure returns (string memory) {\\n        return el('text', _props, _children);\\n    }\\n\\n    function line(string memory _props, string memory _children) internal pure returns (string memory) {\\n        return el('line', _props, _children);\\n    }\\n\\n    function circle(string memory _props, string memory _children) internal pure returns (string memory) {\\n        return el('circle', _props, _children);\\n    }\\n\\n    function circle(string memory _props) internal pure returns (string memory) {\\n        return el('circle', _props);\\n    }\\n\\n    function rect(string memory _props, string memory _children) internal pure returns (string memory) {\\n        return el('rect', _props, _children);\\n    }\\n\\n    function rect(string memory _props) internal pure returns (string memory) {\\n        return el('rect', _props);\\n    }\\n\\n    function filter(string memory _props, string memory _children) internal pure returns (string memory) {\\n        return el('filter', _props, _children);\\n    }\\n\\n    function feColorMatrix(string memory _props) internal pure returns (string memory) {\\n        return el('feColorMatrix', _props);\\n    }\\n\\n    function cdata(string memory _content) internal pure returns (string memory) {\\n        return string.concat('<![CDATA[', _content, ']]>');\\n    }\\n\\n    /* GRADIENTS */\\n    function radialGradient(string memory _props, string memory _children) internal pure returns (string memory) {\\n        return el('radialGradient', _props, _children);\\n    }\\n\\n    function linearGradient(string memory _props, string memory _children) internal pure returns (string memory) {\\n        return el('linearGradient', _props, _children);\\n    }\\n\\n    function gradientStop(string memory offset, string memory stopColor, string memory _props) internal pure returns (string memory) {\\n        return\\n            el(\\n                'stop',\\n                string.concat(\\n                    prop('stop-color', stopColor),\\n                    ' ',\\n                    prop('offset', string.concat(offset, '%')),\\n                    ' ',\\n                    _props\\n                )\\n            );\\n    }\\n\\n    function animateTransform(string memory _props) internal pure returns (string memory) {\\n        return el('animateTransform', _props);\\n    }\\n\\n    function image(string memory _href, string memory _props) internal pure returns (string memory) {\\n        return\\n            el(\\n                'image',\\n                string.concat(prop('href', _href), ' ', _props)\\n            );\\n    }\\n\\n    /* COMMON */\\n    // A generic element, can be used to construct any SVG (or HTML) element\\n    function el(bytes32 _tag, string memory _props, string memory _children) internal pure returns (string memory) {\\n        string memory strTag = Utils.toString(_tag);\\n        \\n        return\\n            string.concat(\\n                '<',\\n                strTag,\\n                ' ',\\n                _props,\\n                '>',\\n                _children,\\n                '</',\\n                strTag,\\n                '>'\\n            );\\n    }\\n\\n\\n    // A generic element, can be used to construct any SVG (or HTML) element without children\\n    function el(bytes32 _tag, string memory _props) internal pure returns (string memory) {\\n        return el(_tag, _props, \\\"\\\");\\n    }\\n\\n    // an SVG attribute\\n    function prop(bytes32 _key, string memory _val) internal pure returns (string memory) {\\n        return string.concat(Utils.toString(_key), '=', '\\\"', _val, '\\\" ');\\n    }\\n\\n    function svgMainElement(uint256 maxDistance, uint16 buffer) internal pure returns (string memory) { unchecked {\\n        maxDistance = 2 * maxDistance * buffer / 100; // 15% buffer;\\n        uint256 xy = maxDistance / 2;\\n    \\n        string memory xyStr = xy.toString();\\n        string memory maxDistStr = maxDistance.toString();\\n\\n        // xyStr = \\\"512\\\";\\n        // maxDistStr = \\\"1024\\\";\\n\\n        return \\n            string.concat(\\n                '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" '// width=\\\"512px\\\" height=\\\"512px\\\" '   // \\n                'viewBox=\\\"-', xyStr, ' -', xyStr, ' ', maxDistStr, ' ', maxDistStr, '\\\" ', \\n                'style=\\\"background:#eee\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">');\\n    }}\\n}\\n\"\r\n    },\r\n    \"contracts/Catmull.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport './Lib2D.sol';\\nimport './Utils.sol';\\n\\nlibrary Catmull {\\n    using Utils for int256;\\n\\n    // tenstion from 0 to 100 (0..1)\\n    function toBezierPath(Lib2D.Point[] memory points, bool isClosed, int256 tension) internal pure returns (string memory) { unchecked {\\n        //if (points.length <= 0) return \\\"M0,0\\\";\\n        string memory result = string.concat(\\\"M\\\", points[0].x.toString(), \\\" \\\", points[0].y.toString());\\n\\n        uint256 size = points.length;\\n\\n        if (!isClosed) {\\n            size -= 1;\\n        }\\n\\n        for (uint256 i=0; i<size; i++) {\\n            Lib2D.Point memory p0;\\n            Lib2D.Point memory p1;\\n            Lib2D.Point memory p2;\\n            Lib2D.Point memory p3;\\n\\n            if (isClosed) {\\n                p0 = points[(i + size - 1) % size];\\n                p1 = points[i];\\n                p2 = points[(i + 1) % size];\\n                p3 = points[(i + 2) % size];\\n            } else {\\n                p0 = i == 0 ? points[0] : points[i - 1];\\n                p1 = points[i];\\n                p2 = points[i + 1];\\n                p3 = i == size - 1 ? p2 : points[i + 2];\\n            }\\n\\n            int256 x1 = p1.x + (p2.x - p0.x) * tension / 600;\\n            int256 y1 = p1.y + (p2.y - p0.y) * tension / 600;\\n\\n            int256 x2 = p2.x - (p3.x - p1.x) * tension / 600;\\n            int256 y2 = p2.y - (p3.y - p1.y) * tension / 600;\\n\\n            result = string.concat(result, \\\"C \\\", x1.toString(), \\\" \\\", y1.toString(), \\\" \\\",\\n                                                x2.toString(), \\\" \\\", y2.toString(), \\\" \\\", \\n                                                p2.x.toString(), \\\" \\\", p2.y.toString(), \\\" \\\");\\n        }\\n\\n        if (isClosed) {\\n            result = string.concat(result, \\\"Z\\\");\\n        }\\n        \\n        return result;\\n    }}\\n}\"\r\n    },\r\n    \"contracts/Shapes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport './SVG.sol';\\nimport './Lib2D.sol';\\nimport './Catmull.sol';\\nimport './Division.sol';\\nimport './Filters.sol';\\nimport './Filters-generated.sol';\\nimport './Traits.sol';\\nimport './Random.sol';\\nimport './Utils.sol';\\n\\n\\nlibrary Shapes {\\n    using Utils for uint256;\\n\\n    function generatePoints(RandomCtx memory rndCtx, Traits.ShapeTraits memory shape) internal pure returns (Lib2D.Point[] memory) { unchecked {\\n        Lib2D.Point[] memory points = new Lib2D.Point[](shape.numPoints);\\n\\n        int256 distance = Random.randRange(rndCtx, 100, 200);\\n        int256 distanceSquared = distance ** 2;\\n\\n        if (shape.pointsMethod == Traits.ShapePointsMethod.RND_DISTANCE) {\\n            distance = Random.randRange(rndCtx, 120, 200);\\n            distanceSquared =  distance ** 2;\\n        }\\n\\n        for (uint8 i = 0; i < shape.numPoints; i++) {\\n            if (i == 0) {\\n                // placement for the first point\\n                points[i] = Lib2D.Point(Random.randRange(rndCtx, -100, 300), Random.randRange(rndCtx, -100, 300));\\n            } else {\\n                int256 deltaY = Random.randRange(rndCtx, 0, distance);\\n                int256 deltaYSquared = deltaY ** 2;\\n                int256 deltaXSquared = distanceSquared - deltaYSquared;\\n                int256 deltaX = 0;\\n                \\n\\n                if (deltaXSquared > 0) {\\n                    deltaX = int256(Utils.ceilSqrt(uint256(deltaXSquared)));\\n                    // if (deltaX < 40) deltaX = 40;\\n                } else {\\n                    // deltaX = 40;\\n                }\\n                \\n                deltaY = int256(Utils.ceilSqrt(uint256(deltaYSquared)));\\n                // if (deltaY < 40) deltaY = 40;\\n\\n                int256 xSign = Random.randSign(rndCtx, 50);\\n                if (shape.noXsignChange) {\\n                    xSign = 1;\\n                }\\n\\n                int256 ySign = Random.randSign(rndCtx, 50);\\n                if (shape.noYsignChange) {\\n                    ySign = 1;\\n                }\\n\\n                points[i] = Lib2D.Point(points[i-1].x + xSign * deltaX, \\n                                        points[i-1].y + ySign * deltaY);\\n\\n                if (i >= 2) {\\n                    uint256 distToPrevPrev = Utils.ceilSqrt(\\n                        uint256((points[i].x - points[i-2].x) ** 2) + uint256((points[i].y - points[i-2].y) ** 2)\\n                    );\\n\\n                    if (distToPrevPrev < 80) {\\n                        // change the sign of X\\n                        points[i] = Lib2D.Point(points[i-1].x + (-xSign) * deltaX, \\n                                                points[i-1].y + (-ySign) * deltaY);\\n\\n                        uint256 distToPrevPrev2 = Utils.ceilSqrt(\\n                            uint256((points[i].x - points[i-2].x) ** 2) + uint256((points[i].y - points[i-2].y) ** 2)\\n                        );\\n\\n                        if (distToPrevPrev > distToPrevPrev2) {\\n                            // doesn't make sence, revert to old version\\n                            points[i] = Lib2D.Point(points[i-1].x + xSign * deltaX, \\n                                                    points[i-1].y + ySign * deltaY);\\n                        }                                                \\n                    }\\n                }\\n\\n                if (shape.pointsMethod == Traits.ShapePointsMethod.RND_DISTANCE) {\\n                    distance = Random.randRange(rndCtx, 80, 200);\\n                    distanceSquared = distance ** 2;\\n                } else if (shape.pointsMethod == Traits.ShapePointsMethod.FIXED_DISTANCE) {\\n                    // do nothing, keep the same distance\\n                } else if (shape.pointsMethod == Traits.ShapePointsMethod.GOLDEN_RATIO_DISTANCE) {\\n                    distance = distance * int256(Utils.GOLDEN_RATIO) / int256(Utils.MULTIPLIER);\\n                    distanceSquared = distance ** 2; \\n                }\\n            }\\n        }\\n\\n        return points;\\n    }}\\n\\n    function findMaxDistance(Lib2D.Point[] memory points) internal pure returns (uint256) { unchecked {\\n        uint256 maxDistance = 0;\\n\\n        for (uint8 i = 0; i < points.length; i++) {\\n            uint256 currentDistance = uint256(points[i].x ** 2 + points[i].y ** 2);\\n            if (currentDistance > maxDistance) {\\n                maxDistance = currentDistance;\\n            }\\n        }\\n\\n        return maxDistance;\\n    }}\\n\\n    function fixLineWidth(RandomCtx memory rndCtx, uint256 maxDistance, Traits.ShapeTraits memory shape) internal pure {\\n        if (maxDistance < 100) {\\n            shape.wLineWidth = \\\"1\\\";\\n            shape.nLineWidth = \\\"1\\\";\\n\\n            if (Random.randBool(rndCtx, 20)) {\\n                shape.wLineWidth = \\\"2\\\";\\n                shape.nLineWidth = \\\"2\\\";   \\n            }    \\n        } else if (maxDistance < 300) {\\n            shape.wLineWidth = \\\"3\\\";\\n            shape.nLineWidth = \\\"2\\\";\\n\\n            if (Random.randBool(rndCtx, 20)) {\\n                shape.wLineWidth = \\\"5\\\";\\n                shape.nLineWidth = \\\"3\\\";   \\n            }      \\n        } else if (maxDistance < 500) {\\n            shape.wLineWidth = \\\"8\\\";\\n            shape.nLineWidth = \\\"4\\\";\\n\\n            if (Random.randBool(rndCtx, 20)) {\\n                shape.wLineWidth = \\\"10\\\";\\n                shape.nLineWidth = \\\"5\\\";   \\n            }         \\n        } else if (maxDistance < 1000) {\\n            shape.wLineWidth = \\\"18\\\";\\n            shape.nLineWidth = \\\"3\\\";   \\n\\n            if (Random.randBool(rndCtx, 20)) {\\n                shape.wLineWidth = \\\"25\\\";\\n                shape.nLineWidth = \\\"5\\\";   \\n            }         \\n        } else {\\n            shape.wLineWidth = Division.divisionStr(2, int256(maxDistance), Random.randRange(rndCtx, 40, 65));\\n            shape.nLineWidth = Division.divisionStr(2, int256(maxDistance), Random.randRange(rndCtx, 200, 600));\\n        }\\n    }\\n\\n    function generateStrokeAndOpacityString(RandomCtx memory rndCtx, Traits.TraitsCtx memory traits, uint256 hue, bool isWide) internal pure returns (string memory) {\\n        string memory stroke = \\\"\\\";\\n\\n        if (traits.shape.coloring == Traits.ShapeColoring.GRADIENT) {\\n            stroke = 'stroke=\\\"url(#g1)\\\" ';\\n        } else {\\n            stroke = Svg.prop('stroke', string.concat(\\\"hsl(\\\", hue.toString(),\\\",\\\", traits.gradient.saturationAndLightness,\\\")\\\"));\\n        }\\n        \\n        if (isWide) {\\n            uint256 opacity = uint256(Random.randRange(rndCtx, 80, 90));\\n            return string.concat(\\\" \\\", stroke, ' stroke-width=\\\"', traits.shape.wLineWidth,'\\\" opacity=\\\"', string.concat(opacity.toString(), '%\\\" '));\\n        } else {\\n            uint256 opacity = uint256(Random.randRange(rndCtx, 10, 13));\\n            return string.concat(\\\" \\\", stroke, 'stroke-width=\\\"', traits.shape.nLineWidth, '\\\" opacity=\\\"', string.concat(opacity.toString(), '%\\\" ')); \\n        }\\n    }\\n\\n    function generateShape(RandomCtx memory rndCtx, Traits.TraitsCtx memory traits) internal pure returns (string memory, uint256) { unchecked {\\n        Lib2D.Point[] memory points = generatePoints(rndCtx, traits.shape);\\n\\n        string memory randomized = \\\"\\\";\\n\\n        uint256 hue = traits.gradient.startingHue;\\n        uint256 maxDistance = Utils.ceilSqrt(findMaxDistance(points));\\n        \\n        fixLineWidth(rndCtx, maxDistance, traits.shape);\\n\\n        // randomized = appendPathElement(rndCtx, randomized, points, generateStrokeAndOpacityString(rndCtx, traits, hue, true, true), traits, 200, 200);\\n        \\n        for (uint8 k = 0; k < traits.shape.numLines1 + 1; k++) {\\n            string memory tmp = \\\"\\\";\\n            for (uint8 i = 0; i < traits.shape.numLines2; i++) {\\n                \\n                if (k == 0) {\\n                    if (i >= traits.shape.numWiderLines) break;\\n                }\\n\\n                string memory strokeAndOpacity;\\n\\n                if (hue > 360) {\\n                    hue %= 360;\\n                }\\n\\n                // check for widerLines\\n                if (k == 0) { \\n                    strokeAndOpacity = generateStrokeAndOpacityString(rndCtx, traits, hue, true);\\n\\n                    if (traits.shape.coloring == Traits.ShapeColoring.LINE_HUE_INC) {\\n                        hue += uint256(Random.randRange(rndCtx, 30, 50));\\n                    } else {\\n                        hue = traits.gradient.startingHue + uint256(Random.randRange(rndCtx, 0, 50));\\n                    }\\n                } else {\\n                    strokeAndOpacity = generateStrokeAndOpacityString(rndCtx, traits, hue, false);\\n                  \\n                    if (traits.shape.coloring == Traits.ShapeColoring.LINE_HUE_INC) {\\n                        hue += uint256(Random.randRange(rndCtx, 0, 4));\\n                    } else {\\n                        hue = traits.gradient.startingHue + uint256(Random.randRange(rndCtx, 0, 30));\\n                    }\\n                }\\n                                \\n                tmp = appendPathElement(rndCtx, tmp, points, strokeAndOpacity, traits, k, i);\\n            }\\n\\n            randomized = string.concat(randomized, tmp);\\n        }\\n\\n        return (randomized, maxDistance);\\n    }}\\n\\n    function appendPathElement(RandomCtx memory rndCtx, string memory toAppend, Lib2D.Point[] memory points, string memory strokeAndOpacity, Traits.TraitsCtx memory traits, uint8 k, uint8 i) internal pure returns (string memory) { unchecked {\\n        Lib2D.Point[] memory newPoints;\\n\\n        // if (k == 200) {\\n        //     // special case to go with originally selected points, no randomization or shifing\\n        //     newPoints = points;\\n        // } else \\n        \\n        if (traits.shape.randomLineDelta) {\\n            newPoints = Lib2D.randomizePoints(rndCtx, points, traits.shape.randomDeltaX, traits.shape.randomDeltaY, traits.shape.mergeMod);\\n        } else {\\n            int16 kint = 10 * (int16(uint16(k)) - 1);\\n            int16 iint = int16(uint16(i));\\n\\n            if (traits.shape.nonRandomCenter) {\\n                if (k % 2 == 0) {\\n                    kint = kint / 2;\\n                } else {\\n                    kint = -(kint / 2);\\n                }\\n            }\\n\\n            newPoints = Lib2D.shiftPoints(points, kint * traits.shape.nonRandomXMultiplier / 100 + iint, kint * traits.shape.nonRandomYMultiplier / 100 + iint, traits.shape.mergeMod);\\n        }\\n\\n        string memory newCatmull = Catmull.toBezierPath(newPoints, traits.shape.closed, traits.shape.catmullTension);\\n        \\n        string memory pathProps = string.concat(\\n            'd=\\\"', newCatmull,\\n            '\\\" fill=\\\"url(#g1)\\\" fill-opacity=\\\"', string.concat(uint256(traits.shape.fillOpacity).toString(),'%'),\\n            '\\\" stroke-linecap=\\\"round\\\" ',\\n            traits.shape.strokeDashArray,\\n            ' ',\\n            strokeAndOpacity\\n        );\\n\\n        return string.concat(toAppend, \\\"<path \\\", pathProps, \\\"/>\\\");\\n    }}\\n\\n    function shapePlacer(string memory shapeID, string memory newShapeID, Traits.ShapePlacementTraits memory shapePlacement) internal pure returns(string memory placed, string memory placedInDef) {\\n        placedInDef = mainShapePlacer(\\\"mainShapes\\\", shapeID, shapePlacement);\\n        placed = spiralShapePlacer(\\\"mainShapes\\\", newShapeID, shapePlacement);\\n    }\\n\\n    function createSpiralElement(string memory shapeID, Traits.ShapePlacementTraits memory shapePlacement, uint16 elementNumber, uint256 currentAngle, uint256 currentScale)  internal pure returns (string memory) {\\n        string memory scaleFormatted = Division.divisionStr(2, int256(currentScale), int256(Utils.MULTIPLIER));\\n        string memory currentElement = \\\"\\\";\\n\\n        int256 opacity = Utils.lerp(100, int256(uint256(shapePlacement.spiralEndOpacity)), 0, int256(uint256(shapePlacement.spiralCopies)), int256(uint256(elementNumber)));\\n        string memory opacityStr = Division.divisionStr(2, opacity, int256(Utils.MULTIPLIER * 100));\\n\\n        string memory style = \\\"\\\";\\n\\n        if (elementNumber % 2 == 0 && shapePlacement.replaceSpiralWithMirrorForEven) {\\n            currentElement = Svg.use(\\n                                string.concat(\\n                                    Svg.prop(\\\"href\\\", string.concat(\\\"#\\\", shapeID)),\\n                                    Svg.prop(\\\"xlink:href\\\", string.concat(\\\"#\\\", shapeID)),\\n                                    Svg.prop(\\\"transform\\\", string.concat(\\\"rotate(\\\", \\n                                        Division.divisionStr(2, int256(currentAngle), int256(Utils.MULTIPLIER)), \\n                                        \\\") scale (\\\", scaleFormatted,\\\",-\\\",scaleFormatted, \\\")\\\")),\\n                                    Svg.prop(\\\"opacity\\\", opacityStr),\\n                                    style\\n                                ),\\n                                \\\"\\\"\\n                            );\\n        } else {\\n            currentElement = Svg.use(\\n                                string.concat(\\n                                    Svg.prop(\\\"href\\\", string.concat(\\\"#\\\", shapeID)),\\n                                    Svg.prop(\\\"xlink:href\\\", string.concat(\\\"#\\\", shapeID)),\\n                                    Svg.prop(\\\"transform\\\", string.concat(\\\"rotate(\\\", \\n                                        Division.divisionStr(2, int256(currentAngle), int256(Utils.MULTIPLIER)), \\n                                        \\\") scale (\\\", scaleFormatted, \\\")\\\")),\\n                                    Svg.prop(\\\"opacity\\\", opacityStr),\\n                                    style\\n                                ),\\n                                \\\"\\\"\\n                            );\\n        }    \\n\\n        return currentElement;\\n    }\\n\\n    // return <g> with ID - newShapeId that must be placed in <defs>\\n    function spiralShapePlacer(string memory shapeID, string memory newShapeID, Traits.ShapePlacementTraits memory shapePlacement) internal pure returns (string memory) {\\n        string memory result = \\\"\\\";\\n\\n        uint256 currentAngle = shapePlacement.startAngle * Utils.MULTIPLIER; // to fix chrome bug with 180 rotation and gradient\\n        uint256 currentScale = shapePlacement.spiralStartScale;\\n        uint256 angleStep = Utils.MULTIPLIER * shapePlacement.spiralRotateAngle;\\n\\n        if (shapePlacement.spiralCopies == 0) {\\n            shapePlacement.spiralCopies = 1;\\n        }\\n\\n        for (uint16 i=0; i<shapePlacement.spiralCopies; i++) {\\n            string memory currentElement = createSpiralElement(shapeID, shapePlacement, i, currentAngle, currentScale);            \\n\\n            currentAngle += angleStep;\\n            currentScale = currentScale * Utils.MULTIPLIER / shapePlacement.spiralDivideFactor;\\n\\n            if (shapePlacement.spiralOuterOnTop) {\\n                result = string.concat(currentElement, result);\\n            } else {\\n                result = string.concat(result, currentElement);\\n            }\\n        }\\n\\n        result = Svg.g(\\n            Svg.prop(\\\"id\\\", newShapeID),\\n            result\\n        );\\n\\n        return result;\\n    }\\n\\n\\n    function mainShapePlacer(string memory placeID, string memory shapeReferenceID, Traits.ShapePlacementTraits memory shapePlacement) internal pure returns (string memory) {\\n        string memory symetry;\\n\\n        uint256 currentAngle = shapePlacement.startAngle * Utils.MULTIPLIER; // to fix chrome bug with 180 rotation and gradient\\n        uint256 angleStep = 360 * Utils.MULTIPLIER / shapePlacement.symetryPoints;\\n\\n        string memory mirrorScale = Division.divisionStr(2, int256(uint256(shapePlacement.mirrorScalePercentage)), 100);\\n\\n        string memory xyscale = string.concat(\\n            shapePlacement.mirrorX ? string.concat(\\\"-\\\", mirrorScale) : mirrorScale,\\n            \\\",\\\",\\n            shapePlacement.mirrorY ? string.concat(\\\"-\\\", mirrorScale) : mirrorScale\\n        );\\n\\n        for (uint16 i=0; i<shapePlacement.symetryPoints; i++) {\\n            string memory angleFormatted = Division.divisionStr(2, int256(currentAngle), int256(Utils.MULTIPLIER));\\n\\n            if (i % 2 == 0 && shapePlacement.repalceMainWithMirrorForEven) {\\n                symetry = string.concat(symetry,\\n                    Svg.use(\\n                        string.concat(\\n                            Svg.prop(\\\"href\\\", string.concat(\\\"#\\\", shapeReferenceID)),\\n                            Svg.prop(\\\"xlink:href\\\", string.concat(\\\"#\\\", shapeReferenceID)),\\n                            Svg.prop(\\\"transform\\\", string.concat(\\\"rotate(\\\", angleFormatted,  \\\") scale(\\\", mirrorScale,\\\",-\\\",mirrorScale,\\\")\\\"))\\n                        ),\\n                        \\\"\\\"\\n                    )\\n                );\\n            } else {\\n                string memory scaleStr = Division.divisionStr(2, Utils.lerp(100, shapePlacement.symetryEndScale, 0, int16(shapePlacement.symetryPoints), int16(i)), int256(Utils.MULTIPLIER * 100));\\n\\n                xyscale = string.concat(\\n                    shapePlacement.mirrorX ? string.concat(\\\"-\\\", scaleStr) : scaleStr,\\n                    \\\",\\\",\\n                    shapePlacement.mirrorY ? string.concat(\\\"-\\\", scaleStr) : scaleStr\\n                );\\n\\n                symetry = string.concat(symetry,\\n                    Svg.use(\\n                        string.concat(\\n                            Svg.prop(\\\"href\\\", string.concat(\\\"#\\\", shapeReferenceID)),\\n                            Svg.prop(\\\"xlink:href\\\", string.concat(\\\"#\\\", shapeReferenceID)),\\n                            Svg.prop(\\\"transform\\\", string.concat(\\\"rotate(\\\", angleFormatted, \\\") scale(\\\",scaleStr,\\\")\\\"))\\n                        ),\\n                        \\\"\\\"\\n                    )\\n                );\\n            }\\n\\n            if (shapePlacement.mirrorX || shapePlacement.mirrorY) {\\n                symetry = string.concat(symetry,\\n                    Svg.use(\\n                        string.concat(\\n                            Svg.prop(\\\"href\\\", string.concat(\\\"#\\\", shapeReferenceID)),\\n                            Svg.prop(\\\"xlink:href\\\", string.concat(\\\"#\\\", shapeReferenceID)),\\n                            Svg.prop(\\\"transform\\\", string.concat(\\\"rotate(\\\", angleFormatted, \\\") scale(\\\", xyscale ,\\\")\\\"))\\n                        ),\\n                        \\\"\\\"\\n                    )\\n                );\\n            }\\n\\n            currentAngle += angleStep * shapePlacement.angleMultiplier / shapePlacement.angleDivider;\\n        }\\n\\n        symetry = Svg.g(\\n            Svg.prop(\\\"id\\\", placeID),\\n            symetry\\n        );\\n\\n        return symetry;\\n    }\\n}\"\r\n    },\r\n    \"contracts/Traits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport './Random.sol';\\nimport './Utils.sol';\\nimport './FilterTraits.sol';\\n\\n\\nlibrary Traits {\\n    using Utils for uint256;\\n    using Utils for int256; \\n\\n    struct ShapePlacementTraits {\\n        uint16 symetryPoints;                // how many symetry points, around the center\\n        int16 symetryEndScale;               \\n        bool mirrorX;                        // do we mirror arround X axis\\n        bool mirrorY;                        // do we mirror arround Y axis \\n        uint16 spiralCopies;                 // how many spiral copies\\n        uint16 spiralRotateAngle;            // at what agle to rotate the spiral\\n        uint256 spiralStartScale;            // starting scale for spiral, usually 1 (but sometimes can be different);   Multiplied by 100000 == MULTIPLIER\\n        uint256 spiralDivideFactor;          // how to divide the spiralScale, multiplied by 100000 == MULTIPLIER\\n        uint16 startAngle;                   // start angle for both spiral and symetry\\n        bool spiralOuterOnTop;               // True - place outer elements on top - i.e. place them last\\n        uint16 spiralEndOpacity;             // opacity of the spiral at the end\\n        bool repalceMainWithMirrorForEven;   // mirror even shapes\\n        uint8 mirrorScalePercentage;         // mirror scale percentage, from 0 to 100\\n        bool replaceSpiralWithMirrorForEven; // mirror even layers of the spiral \\n        uint8 angleMultiplier;                \\n        uint8 angleDivider;                  \\n        bool non360rotation;                 // result is irregular runes, that does not fully cover the circle\\n    }\\n\\n    enum ShapePointsMethod { \\n        RND_DISTANCE,\\n        FIXED_DISTANCE,\\n        GOLDEN_RATIO_DISTANCE\\n    }\\n\\n    enum ShapeColoring {\\n        GRADIENT,\\n        LINE_HUE_RND,\\n        LINE_HUE_INC\\n    }\\n\\n    struct ShapeTraits {\\n        uint8 numPoints;                 // number of points of lines (for others )\\n        ShapePointsMethod pointsMethod;  // how to generate points\\n        bool noXsignChange;\\n        bool noYsignChange;\\n        uint8 numLines1;\\n        uint8 numLines2;\\n        uint8 numWiderLines;\\n        string wLineWidth;\\n        string nLineWidth;\\n        string strokeDashArray;\\n        ShapeColoring coloring;\\n        uint8 fillOpacity;              // percentage - from 0 to 100\\n        bool randomLineDelta;\\n        bool randomDeltaDiff;\\n        int8 randomDeltaX;\\n        int8 randomDeltaY;\\n        int16 nonRandomXMultiplier;     // 1 .. (numLines1 + 1) * 10, it is multiplied with 10 for better accurace\\n        int16 nonRandomYMultiplier;     // 1 .. (numLines1 + 1) * 10, it is multiplied with 10 for better accurace\\n        bool nonRandomCenter;\\n        uint8 mergeMod;\\n        bool closed;\\n        int16 catmullTension;\\n        uint16 viewBoxBuffer;\\n    }\\n\\n    enum GradientOpacityPattern {\\n        ALL_SAME,\\n        INCREASING,\\n        DECREASING,\\n        ZIG_ZAG\\n    }\\n\\n    enum GradientPalettePattern {\\n        TWO_COLORS,\\n        TWO_COLORS_ZZ,\\n        TWO_COLORS_X2,\\n        LINEAR,\\n        GOLDEN_ANGLE,\\n        RAINBOW\\n    }\\n\\n    struct GradientTraits {\\n        int256 angle;\\n        uint8 repeatCount;\\n        bool linear;\\n        bool reflect;\\n        bool discrete;\\n        uint8 discreteOffset;\\n        GradientOpacityPattern opacityPattern;\\n        uint8 beginOpacity;\\n        uint8 endOpacity;\\n        uint8 transparentFromBeginOffset;\\n        uint8 transparentToEndOffset;\\n        uint16 startingHue;\\n        uint8 paletteColors;\\n        uint16 paletteStep;\\n        GradientPalettePattern palettePattern;\\n        string saturationAndLightness;\\n        string saturationAndLightness2;\\n        string saturationAndLightness3;\\n    }\\n\\n    int8 internal constant NUM_FILTERS = 22;\\n\\n    \\n\\n    struct TraitsCtx {\\n        ShapePlacementTraits shapePlacement; \\n        ShapeTraits shape;\\n        GradientTraits gradient;\\n        FilterTraits filter;\\n    }\\n\\n    function generateTraitsCtx(RandomCtx memory rndCtx) internal pure returns (TraitsCtx memory) {\\n        TraitsCtx memory result;\\n\\n        result.shapePlacement = decideOnShapePlacementTraits(rndCtx);\\n        result.shape = decideOnShapeTraits(rndCtx);\\n        result.gradient = decideOnGradientTraitis(rndCtx);\\n        result.filter = decideOnFilterTraits(rndCtx);\\n\\n        fineTuneTraits(result);\\n\\n        return result;\\n    }\\n\\n    // shapePlacement\\n    function decideOnShapePlacementTraits(RandomCtx memory rndCtx) internal pure returns (ShapePlacementTraits memory) { unchecked {\\n        ShapePlacementTraits memory shapePlacementTraits = ShapePlacementTraits({\\n            symetryPoints: uint8(int8(Random.randRange(rndCtx, 2, 12))),\\n            symetryEndScale: 100 - int8(Random.randWithProbabilities(rndCtx, hex\\\"200101010206060606\\\")) * 10,\\n            mirrorX: false,\\n            mirrorY: false,\\n            spiralCopies: 0, \\n            spiralRotateAngle: 33,\\n            spiralStartScale: Utils.MULTIPLIER * 1,\\n            spiralDivideFactor: Utils.MULTIPLIER * 50 / uint256(Random.randRange(rndCtx, 20, 50)),\\n            startAngle: 1,\\n            spiralOuterOnTop: true,\\n            spiralEndOpacity: 0,\\n            repalceMainWithMirrorForEven: false,\\n            mirrorScalePercentage: (5 + Random.randWithProbabilities(rndCtx, hex\\\"010305070909\\\")) * 10,\\n            replaceSpiralWithMirrorForEven: Random.randBool(rndCtx, 30),\\n            angleMultiplier: 1,\\n            angleDivider: 1,\\n            non360rotation: false\\n        });\\n\\n        // 2% chance for non 360 rotation\\n        if (Random.randBool(rndCtx, 2)) {\\n            if (Random.randBool(rndCtx, 70)) {\\n                shapePlacementTraits.angleMultiplier = uint8(int8(Random.randRange(rndCtx, 50, 90)));\\n            } else {\\n                shapePlacementTraits.angleMultiplier = uint8(int8(Random.randRange(rndCtx, 20, 50)));\\n            }\\n            shapePlacementTraits.angleDivider = 100;//uint8(int8(Random.randRange(rndCtx, 1, 10)));\\n            shapePlacementTraits.non360rotation = true;\\n        }\\n\\n        if (shapePlacementTraits.symetryPoints <= 3) {\\n            shapePlacementTraits.spiralCopies = uint8(int8(Random.randRange(rndCtx, 2, 10)));\\n            shapePlacementTraits.spiralRotateAngle = uint16(int16(Random.randRange(rndCtx, 15, 30)));\\n            shapePlacementTraits.mirrorX = true;\\n        } else {\\n            shapePlacementTraits.spiralCopies = uint8(int8(Random.randRange(rndCtx, 0, 13 - int256(uint256(shapePlacementTraits.symetryPoints)))));\\n            shapePlacementTraits.mirrorX = Random.randBool(rndCtx, 50);\\n            shapePlacementTraits.spiralRotateAngle = uint16(int16(Random.randRange(rndCtx, 0, 45)));\\n        }\\n\\n        // // 5% chance to have spiralDivideFactor than cause increase in size\\n        if (shapePlacementTraits.spiralCopies > 1 && Random.randBool(rndCtx, 5)) {\\n            uint256 newSpiralFactor = Utils.MULTIPLIER * 50 / uint256(Random.randRange(rndCtx, 55, 63));\\n            newSpiralFactor += 1;\\n\\n            //shapePlacementTraits.spiralDivideFactor = newSpiralFactor\\n        }\\n\\n        //\\n        //\\n        // shapePlacementTraits.symetryPoints = 6;\\n        // shapePlacementTraits.mirrorX = true;\\n        // shapePlacementTraits.spiralCopies = 0;\\n        // shapePlacementTraits.spiralRotateAngle = 22;\\n        // shapePlacementTraits.spiralDivideFactor = Lib2D.MULTIPLIER * 50 / 40;\\n\\n\\n        if (!shapePlacementTraits.mirrorX && shapePlacementTraits.symetryPoints % 2 == 0) {\\n            shapePlacementTraits.repalceMainWithMirrorForEven = Random.randBool(rndCtx, 50);\\n        }\\n\\n        if (shapePlacementTraits.spiralCopies >= 12) {\\n            shapePlacementTraits.spiralEndOpacity = uint16(int16(Random.randRange(rndCtx, 1, 20)));\\n        } else if (shapePlacementTraits.spiralCopies >= 7) {\\n            shapePlacementTraits.spiralEndOpacity = uint16(int16(Random.randRange(rndCtx, 20, 40)));\\n        } else if (shapePlacementTraits.spiralCopies >= 4) {\\n            shapePlacementTraits.spiralEndOpacity = uint16(int16(Random.randRange(rndCtx, 20, 60)));\\n        } else {\\n            shapePlacementTraits.spiralEndOpacity = uint16(int16(Random.randRange(rndCtx, 40, 100)));\\n        }\\n\\n        // shapePlacementTraits.mirrorX = false;\\n        // shapePlacementTraits.symetryPoints = 6;\\n        // shapePlacementTraits.repalceMainWithMirrorForEven = false;\\n        // shapePlacementTraits.mirrorScalePercentage = 60;\\n        // shapePlacementTraits.spiralCopies = 2;\\n        // shapePlacementTraits.spiralEndOpacity = 30;\\n\\n        return shapePlacementTraits;\\n    }}\\n\\n    function decideOnShapeTraits(RandomCtx memory rndCtx) internal pure returns (ShapeTraits memory) { unchecked {\\n        ShapeTraits memory shapeTraits = ShapeTraits({\\n            numPoints: 3 + Random.randWithProbabilities(rndCtx, hex\\\"050A0C19140F050503\\\"),\\n            pointsMethod: ShapePointsMethod(Random.randWithProbabilities(rndCtx, hex\\\"3C190F\\\")),\\n            noXsignChange: Random.randBool(rndCtx, 10),\\n            noYsignChange: Random.randBool(rndCtx, 10),\\n            numLines1: 7,\\n            numLines2: 7,\\n            numWiderLines: uint8(int8(Random.randRange(rndCtx, 1, 5))),\\n            wLineWidth: \\\"18\\\",\\n            nLineWidth: \\\"3\\\",\\n            strokeDashArray: \\\"\\\",\\n            coloring: ShapeColoring(Random.randWithProbabilities(rndCtx, hex\\\"500F05\\\")),\\n            fillOpacity: uint8(int8(Random.randRange(rndCtx, 0, 4))),\\n            randomLineDelta: Random.randBool(rndCtx, 40),\\n            randomDeltaDiff: Random.randBool(rndCtx, 20),\\n            randomDeltaX: int8(Random.randRange(rndCtx, 3, 20)),\\n            randomDeltaY: int8(Random.randRange(rndCtx, 3, 20)),\\n            nonRandomXMultiplier: 7,\\n            nonRandomYMultiplier: 7,\\n            nonRandomCenter: true,\\n            mergeMod: Random.randWithProbabilities(rndCtx, hex\\\"0501050302\\\"),\\n            closed: Random.randBool(rndCtx, 50),\\n            catmullTension: int16(uint16(Random.randWithProbabilities(rndCtx, hex\\\"1505141E1E14030201\\\")) * 50),\\n            viewBoxBuffer: 140\\n        });\\n\\n        if (shapeTraits.mergeMod == 0) {\\n            shapeTraits.mergeMod = 200; // which means - no merging\\n        }\\n\\n        // 10% chance for dash array\\n        if (Random.randBool(rndCtx, 10)) {\\n            int256 dashType = Random.randRange(rndCtx, 0, 9);\\n\\n            if (dashType == 0) {\\n                shapeTraits.strokeDashArray = 'stroke-dasharray=\\\"0% 1%\\\"';    \\n            } else if (dashType == 1) {\\n                shapeTraits.strokeDashArray = 'stroke-dasharray=\\\"1% 2%\\\"';    \\n            } else if (dashType == 2) {\\n                shapeTraits.strokeDashArray = 'stroke-dasharray=\\\"5% 5%\\\"';    \\n            } else if (dashType == 3) {\\n                shapeTraits.strokeDashArray = 'stroke-dasharray=\\\"10% 5%\\\"';    \\n            } else if (dashType == 4) {\\n                shapeTraits.strokeDashArray = 'stroke-dasharray=\\\"4% 5%\\\"';    \\n            } else if (dashType == 5) {\\n                shapeTraits.strokeDashArray = 'stroke-dasharray=\\\"15% 5%\\\"';    \\n            } else if (dashType == 6) {\\n                shapeTraits.strokeDashArray = 'stroke-dasharray=\\\"20% 30%\\\"';   \\n            } else if (dashType == 7) {\\n                shapeTraits.strokeDashArray = 'stroke-dasharray=\\\"35% 8%\\\"';    \\n            } else if (dashType == 8) {\\n                shapeTraits.strokeDashArray = 'stroke-dasharray=\\\"2% 25% 8%\\\"';    \\n            } else if (dashType == 9) {\\n                shapeTraits.strokeDashArray = 'stroke-dasharray=\\\"12% 6% 13%\\\"';    \\n            }\\n        }\\n\\n        // shapeTraits.randomLineDelta = false;\\n\\n        if (shapeTraits.catmullTension == 0) {\\n            shapeTraits.catmullTension = 20;\\n        } else {\\n            shapeTraits.catmullTension = int16(Random.randSign(rndCtx, 10) * shapeTraits.catmullTension);\\n        }\\n\\n        // correct viewBoxBuffer\\n        if (shapeTraits.catmullTension <= 100) {\\n            shapeTraits.viewBoxBuffer = 125;\\n        } else if (shapeTraits.catmullTension <= 200) {\\n            shapeTraits.viewBoxBuffer = 130;\\n        } \\n\\n        if (!shapeTraits.randomDeltaDiff) {\\n            shapeTraits.randomDeltaY = shapeTraits.randomDeltaX;\\n        }\\n\\n        uint16 multiplier = (1 + Random.randWithProbabilities(rndCtx, hex\\\"0505231E0A\\\")) * 2;    \\n\\n        shapeTraits.nonRandomCenter = Random.randBool(rndCtx, 15);\\n        shapeTraits.nonRandomXMultiplier = int16(Random.randRange(rndCtx, int256(uint256(shapeTraits.numLines1)), int256(uint256(shapeTraits.numLines1 * multiplier))));\\n        shapeTraits.nonRandomYMultiplier = int16(Random.randRange(rndCtx, int256(uint256(shapeTraits.numLines1)), int256(uint256(shapeTraits.numLines1 * multiplier))));\\n\\n        if (!shapeTraits.nonRandomCenter) {\\n            shapeTraits.nonRandomXMultiplier = int16(Random.randSign(rndCtx, 50) * shapeTraits.nonRandomXMultiplier);\\n            shapeTraits.nonRandomYMultiplier = int16(Random.randSign(rndCtx, 50) * shapeTraits.nonRandomYMultiplier);\\n        }\\n\\n\\n        return shapeTraits;\\n    }}\\n\\n    // gradients\\n    function decideOnGradientTraitis(RandomCtx memory rndCtx) internal pure returns (GradientTraits memory) { unchecked {\\n        GradientTraits memory gradientTraits = GradientTraits({\\n            angle: Random.randRange(rndCtx, 0, 359),\\n            repeatCount: 1 + Random.randWithProbabilities(rndCtx, hex\\\"32140F0A05\\\"),\\n            linear: Random.randBool(rndCtx, 85),\\n            reflect: Random.randBool(rndCtx, 80),\\n            discrete: Random.randBool(rndCtx, 20),\\n            discreteOffset: uint8(int8(Random.randRange(rndCtx, 1, 10))),\\n            opacityPattern: GradientOpacityPattern(Random.randWithProbabilities(rndCtx, hex\\\"3214140A\\\")),\\n            beginOpacity: uint8(int8(Random.randRange(rndCtx, 20, 50))),\\n            endOpacity: 100,\\n            transparentFromBeginOffset: 5 * Random.randWithProbabilities(rndCtx, hex\\\"3C140A0A\\\"),\\n            transparentToEndOffset: 100 - 5 * Random.randWithProbabilities(rndCtx, hex\\\"3C140A0A\\\"),\\n            startingHue: uint16(int16(Random.randRange(rndCtx, 1, 359))),\\n            paletteColors: 2 + Random.randWithProbabilities(rndCtx, hex\\\"28140A0A0A0703\\\"),\\n            paletteStep: uint16(int16(Random.randRange(rndCtx, 20, 100))),\\n            palettePattern: GradientPalettePattern(Random.randWithProbabilities(rndCtx, hex\\\"14141E0A0A01\\\")),\\n            saturationAndLightness: \\\"100%, 50%\\\",\\n            saturationAndLightness2: \\\"100%, 60%\\\",\\n            saturationAndLightness3: \\\"80%, 50%\\\"\\n        });\\n\\n        if (!gradientTraits.linear) {\\n            gradientTraits.transparentFromBeginOffset = 0;\\n            gradientTraits.transparentToEndOffset = 100;\\n        }\\n\\n        return gradientTraits;\\n    }}\\n\\n\\n    function decideOnFilterTraits(RandomCtx memory rndCtx) internal pure returns (FilterTraits memory) { unchecked {\\n        FilterTraits memory filterTraits = FilterTraits({\\n            mainFilterType: FilterType(Random.randRange(rndCtx, 0, NUM_FILTERS-1)),\\n            additonalLighting: true\\n        });\\n        \\n        return filterTraits;\\n    }}\\n\\n    function fineTuneTraits(TraitsCtx memory traits) internal pure {\\n        // fine tune on saturation and lightness\\n        {\\n            FilterType filter = traits.filter.mainFilterType;\\n\\n            if (filter == FilterType.NONE ||\\n                filter == FilterType.SEPIA || \\n                filter == FilterType.WATERCOLOR_BRIGHT ||\\n                filter == FilterType.DISPLACEMENT ||\\n                filter == FilterType.FROZEN || \\n                filter == FilterType.INNER_OUTLINE ||\\n                filter == FilterType.CHALK) {\\n                traits.gradient.saturationAndLightness  = \\\"90%,40%\\\";\\n                traits.gradient.saturationAndLightness2 = \\\"90%,45%\\\";\\n                traits.gradient.saturationAndLightness3 = \\\"80%,50%\\\";\\n            }\\n\\n            // traits.shape.coloring != ShapeColoring.GRADIENT ||\\n            if ( \\n                filter == FilterType.GRAYSCALE || \\n                filter == FilterType.SMOKE || \\n                filter == FilterType.SPLASH ||\\n                filter == FilterType.GLASS ||\\n                filter == FilterType.SPREAD ||\\n                filter == FilterType.SPREAD_BRIGHT) {\\n                traits.gradient.saturationAndLightness  = \\\"80%,40%\\\";\\n                traits.gradient.saturationAndLightness2 = \\\"80%,45%\\\";\\n                traits.gradient.saturationAndLightness3 = \\\"70%,50%\\\";    \\n            }\\n\\n            if (filter == FilterType.HALF_TONE) {\\n                traits.gradient.saturationAndLightness  = \\\"30%,30%\\\";\\n                traits.gradient.saturationAndLightness2 = \\\"30%,35%\\\";\\n                traits.gradient.saturationAndLightness3 = \\\"30%,30%\\\"; \\n            }\\n\\n        }\\n\\n        // fix other properties based on filter\\n        if (traits.filter.mainFilterType == FilterType.SPREAD_BRIGHT ||\\n            traits.filter.mainFilterType == FilterType.SPREAD ||\\n            traits.filter.mainFilterType == FilterType.HALF_TONE ||\\n            traits.filter.mainFilterType == FilterType.RECOLORING || \\n            traits.filter.mainFilterType == FilterType.STONE ||\\n            traits.filter.mainFilterType == FilterType.WATERCOLOR_BRIGHT ||\\n            traits.filter.mainFilterType == FilterType.WATERCOLOR) {\\n            traits.shape.strokeDashArray = \\\"\\\";\\n        }\\n\\n        if (traits.filter.mainFilterType == FilterType.STONE) {\\n            traits.shape.numWiderLines = 4;\\n        }\\n\\n        if (traits.shape.numPoints + traits.shapePlacement.symetryPoints > 20 || traits.shape.numPoints >= 10) {\\n            traits.shape.numLines1 = 6;\\n            traits.shape.numLines2 = 6;\\n        } else if (traits.shape.numPoints + traits.shapePlacement.symetryPoints >= 18) {\\n            traits.shape.numLines1 = 7;\\n            traits.shape.numLines2 = 6;\\n        } else if (traits.shape.numWiderLines >= 5) {\\n            // traits.shape.numLines1 = 6;\\n            // traits.shape.numLines2 = 7;\\n        }\\n\\n        if (traits.shapePlacement.spiralDivideFactor <  Utils.MULTIPLIER) {\\n            traits.shape.viewBoxBuffer = 100;\\n        }\\n    }\\n\\n    function getTraitsAsJsonString(TraitsCtx memory traits) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            stringTrait(\\\"Shape Points\\\", uint256(traits.shape.numPoints).toString()),\\n            stringTrait(\\\"Points Generation Method\\\", toString(traits.shape.pointsMethod)),\\n            stringTrait(\\\"Shape Is Closed\\\", toString(traits.shape.closed)),\\n            stringTrait(\\\"Shape Wide Lines\\\", uint256(traits.shape.numWiderLines).toString()),\\n            stringTrait(\\\"Coloring\\\", toString(traits.shape.coloring)),\\n            stringTrait(\\\"Dashed\\\", toString(bytes(traits.shape.strokeDashArray).length > 0)),\\n            stringTrait(\\\"Catmull-Rom Tension\\\", int256(traits.shape.catmullTension).toString()),\\n            stringTrait(\\\"Gradient Palette\\\", toString(traits.gradient.palettePattern)),\\n            stringTrait(\\\"Symetry Points\\\", uint256(traits.shapePlacement.symetryPoints).toString())\\n        );\\n\\n        result = string.concat(result,\\n            stringTrait(\\\"Symetry End Scale\\\", int256(traits.shapePlacement.symetryEndScale).toString()),\\n            stringTrait(\\\"Additional Mirror\\\", toString(traits.shapePlacement.mirrorX || traits.shapePlacement.mirrorY)),\\n            stringTrait(\\\"Symetry Mirror Even\\\", toString(traits.shapePlacement.repalceMainWithMirrorForEven)),\\n            stringTrait(\\\"Non 360 rotation\\\", toString(traits.shapePlacement.non360rotation)),\\n            stringTrait(\\\"Rings\\\", uint256(traits.shapePlacement.spiralCopies).toString()),\\n            // stringTrait(\\\"Rings Scale Out\\\", toString(traits.shapePlacement.spiralDivideFactor < Utils.MULTIPLIER)),            \\n            stringTrait(\\\"Ring Mirror Even\\\", toString(traits.shapePlacement.replaceSpiralWithMirrorForEven)),\\n            stringTraitLast(\\\"Filter\\\", toString(traits.filter.mainFilterType))\\n        );\\n        \\n        return string.concat('\\\"attributes\\\":[', result, ']');\\n    }\\n\\n    function stringTrait(string memory traitName, string memory traitValue) internal pure returns (string memory) {\\n        return string.concat(stringTraitLast(traitName, traitValue),',');\\n    }\\n\\n    function stringTraitLast(string memory traitName, string memory traitValue) internal pure returns (string memory) {\\n        return string.concat('{\\\"trait_type\\\":\\\"', traitName,'\\\",\\\"value\\\":\\\"',traitValue, '\\\"}');\\n    }\\n\\n    function toString(bool b) internal pure returns (string memory) {\\n        return b ? \\\"Yes\\\" : \\\"No\\\";\\n    }\\n\\n    function toString(ShapePointsMethod method) internal pure returns (string memory) {\\n        if (method == ShapePointsMethod.RND_DISTANCE) {\\n            return \\\"Random Distance\\\";\\n        } else if (method == ShapePointsMethod.FIXED_DISTANCE) {\\n            return \\\"Fixed Distance\\\";\\n        }\\n\\n        // GOLDEN_RATIO_DISTANCE\\n        return \\\"Golden Ratio Distance\\\";\\n    }\\n\\n    function toString(ShapeColoring coloring) internal pure returns (string memory) {\\n        if (coloring == ShapeColoring.GRADIENT) {\\n            return \\\"Gradient\\\";\\n        } else if (coloring == ShapeColoring.LINE_HUE_RND) {\\n            return \\\"Line Hue Random\\\";\\n        }\\n\\n        // LINE_HUE_INC\\n        return \\\"Line Hue Increasing\\\";\\n    }\\n\\n    function toString(GradientPalettePattern gpp) internal pure returns (string memory) {\\n        if (gpp == GradientPalettePattern.TWO_COLORS) {\\n            return \\\"Two Colors\\\";\\n        } else if (gpp == GradientPalettePattern.TWO_COLORS_ZZ) {\\n            return \\\"Two Colors Zig-Zag\\\";\\n        } else if (gpp == GradientPalettePattern.TWO_COLORS_X2) {\\n            return \\\"Two Colors X2\\\";\\n        } else if (gpp == GradientPalettePattern.LINEAR) {\\n            return \\\"Linear Offset\\\";\\n        } else if (gpp == GradientPalettePattern.GOLDEN_ANGLE) {\\n            return \\\"Golden Angle Offset\\\";\\n        } \\n        \\n        // RAINBOW\\n        return \\\"Rainbow\\\";\\n    }\\n\\n    function toString(FilterType filter) internal pure returns (string memory) {\\n        if (filter == FilterType.GRAYSCALE) {\\n            return \\\"Grayscale\\\";\\n        } else if (filter == FilterType.SEPIA) {\\n            return \\\"Sepia\\\";\\n        } else if (filter == FilterType.WATERCOLOR) {\\n            return \\\"Watercolor\\\";\\n        } else if (filter == FilterType.WATERCOLOR_BRIGHT) {\\n            return \\\"Bright Watercolor\\\";\\n        } else if (filter == FilterType.STONE) {\\n            return \\\"Stone\\\";\\n        } else if (filter == FilterType.SMOKE) {\\n            return \\\"Smoke\\\";\\n        } else if (filter == FilterType.DISPLACEMENT) {\\n            return \\\"Displacement\\\";\\n        } else if (filter == FilterType.FROZEN) {\\n            return \\\"Frozen\\\";\\n        } else if (filter == FilterType.SPLASH) {\\n            return \\\"Splash\\\";\\n        } else if (filter == FilterType.RECOLORING) {\\n            return \\\"Recoloring\\\";\\n        } else if (filter == FilterType.SPARKS) {\\n            return \\\"Sparks\\\";\\n        } else if (filter == FilterType.GLASS) {\\n            return \\\"Glass\\\";\\n        } else if (filter == FilterType.SPREAD) {\\n            return \\\"Spread\\\";\\n        } else if (filter == FilterType.SPREAD_BRIGHT) {\\n            return \\\"Spread Bright\\\";\\n        } else if (filter == FilterType.INNER_OUTLINE) {\\n            return \\\"Inner Outline\\\";\\n        } else if (filter == FilterType.COLOR_OUTLINE) {\\n            return \\\"Color Outline\\\";\\n        } else if (filter == FilterType.NOISE_SHADOW) {\\n            return \\\"Noise Shadow\\\";\\n        } else if (filter == FilterType.RECOLORING2) {\\n            return \\\"Recoloring 2\\\";\\n        } else if (filter == FilterType.CHALK) {\\n            return \\\"Chalk\\\";\\n        } else if (filter == FilterType.BLACK_OUTLINE) {\\n            return \\\"Black Outline\\\";\\n        } else if (filter == FilterType.HALF_TONE) {\\n            return \\\"Halftone Noise\\\";\\n        }\\n  \\n        return \\\"none\\\";\\n    }\\n}\\n   \"\r\n    },\r\n    \"contracts/Random.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"./Division.sol\\\";\\nimport \\\"./RandomCtx.sol\\\";\\n\\nlibrary Random {\\n    function initCtx(uint256 startingSeed) internal pure returns (RandomCtx memory) {\\n        // some 10 digit prime numbers\\n        // 1024243321, 1024383257, 1028910301, 1111111231, 1111211111\\n        // 1317313771, 1500000001, 2999999929, 3333323333, 4332221111 \\n        // 5111111191, 6668999101, 7000000001, 8018018081, 9199999999\\n        return RandomCtx(startingSeed, 5111111191 * startingSeed);      \\n    }\\n\\n    function setSeed(RandomCtx memory ctx, uint256 startingSeed) internal pure {\\n        ctx.seed = startingSeed;\\n    } \\n\\n    // function setSeedFromConract(RandomCtx memory ctx, uint256 startingSeed) internal view {\\n    //     ctx.seed = uint256(keccak256(\\n    //         abi.encode(\\n    //             startingSeed,\\n    //             blockhash(block.number - 1),\\n    //             block.coinbase,\\n    //             block.prevrandao,\\n    //             block.timestamp\\n    //         )\\n    //     ));\\n    // }\\n\\n    function randInt(RandomCtx memory ctx) internal pure returns (uint256) {\\n        ctx.counter++;\\n\\n        ctx.seed = uint256(keccak256(\\n            abi.encode(\\n                ctx.seed, ctx.counter\\n            )\\n        ));\\n        \\n        return ctx.seed;\\n    }\\n\\n    function randUInt32(RandomCtx memory ctx) internal pure returns (uint32) {\\n        return uint32(int32(randRange(ctx, 0, 2147483647))); // positive only to accomodate SEED in SVG\\n    }\\n\\n    function randFloat(RandomCtx memory ctx, uint8 decimalPlaces, int256 from, int256 to, int256 denominator) internal pure returns (string memory result) {\\n        int256 rInt = randRange(ctx, from, to);\\n        result = Division.divisionStr(decimalPlaces, rInt, denominator);\\n    }\\n\\n    function randWithProbabilities(RandomCtx memory ctx, bytes memory probabilities) internal pure returns (uint8) { unchecked {\\n        uint256 probSum = 0;\\n\\n        for (uint8 i = 0; i < probabilities.length; i++) {\\n            probSum += uint256(uint8(probabilities[i]));\\n        }\\n\\n        int256 rnd = Random.randRange(ctx, 1, int256(probSum));\\n\\n        probSum = 0;\\n        for (uint8 i = 0; i < probabilities.length; i++) {\\n            probSum += uint256(uint8(probabilities[i]));\\n\\n            if (int256(probSum) >= rnd) {\\n                return i;\\n            }\\n        }\\n\\n        return 0;\\n    }}\\n\\n    function randRange(RandomCtx memory ctx, int256 from, int256 to) internal pure returns (int256) { unchecked {\\n        if (from > to) {\\n            to = from;\\n        }\\n        uint256 rnd = randInt(ctx);\\n\\n        return from + int256(rnd >> 1) % (to - from + 1);\\n    }}\\n\\n    /**\\n     * \\n     * @param ctx - context\\n     * @param minusProbability - 0 to 100 percents\\n     */\\n    function randSign(RandomCtx memory ctx, int256 minusProbability) internal pure returns (int256) {\\n        if (randRange(ctx, 1, 100) <= minusProbability) {\\n            return -1;\\n        }\\n        return 1;\\n    }\\n\\n\\n    /**\\n     * \\n     * @param ctx - context\\n     * @param trueProbability - 0 to 100 percents\\n     */\\n    function randBool(RandomCtx memory ctx, int256 trueProbability) internal pure returns (bool) {\\n        return (randRange(ctx, 1, 100) <= trueProbability);\\n    }\\n}\"\r\n    },\r\n    \"contracts/Gradients.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport './SVG.sol';\\nimport './Division.sol';\\nimport './Utils.sol';\\nimport './Traits.sol';\\n\\nlibrary Gradients {\\n    using Utils for int256;\\n    using Utils for uint256;\\n\\n    struct ColorStop {\\n        string color;\\n        string offset;\\n        string opacity;\\n    }\\n\\n    function createGradient(string memory id, ColorStop[] memory stops, Traits.GradientTraits memory traits) internal pure returns (string memory) { unchecked {\\n         \\n        string memory stopStr = \\\"\\\";\\n\\n        for (uint256 i=0; i < stops.length; i++) {\\n            stopStr = string.concat(stopStr, Svg.gradientStop(stops[i].offset, stops[i].color, Svg.prop(\\\"stop-opacity\\\", string.concat(stops[i].opacity, \\\"%\\\"))));\\n        }\\n\\n        if (traits.repeatCount == 0) traits.repeatCount = 1;\\n\\n        string memory calculatedPercentage;\\n\\n        (,,calculatedPercentage) = Division.division(2, 100, int8(traits.repeatCount));\\n\\n        string memory sm = \\\"reflect\\\";\\n\\n        if (!traits.reflect) {\\n            sm = \\\"repeat\\\";\\n        }\\n\\n        if (traits.linear) {\\n            return Svg.linearGradient(\\n                string.concat(\\n                    Svg.prop(\\\"id\\\", id),\\n                    Svg.prop(\\\"gradientTransform\\\", string.concat(\\\"rotate(\\\",traits.angle.toString(),\\\", 0.5, 0.5)\\\")),\\n                    '  x1=\\\"0%\\\" y1=\\\"0%\\\" x2=\\\"', calculatedPercentage,'%\\\" y2=\\\"',calculatedPercentage,'%\\\" spreadMethod=\\\"',sm,'\\\"'\\n                ),\\n                stopStr\\n            );\\n        } else {            \\n            // no spread method, there is a bug in Safari that does not rended correctly gradients with spreadMethod \\\"repeat\\\" or \\\"reflect\\\"\\n            return Svg.radialGradient(\\n                string.concat(\\n                    Svg.prop(\\\"id\\\", id),\\n                    Svg.prop(\\\"gradientTransform\\\", string.concat(\\\"rotate(\\\",traits.angle.toString(),\\\", 0.5, 0.5)\\\")),\\n                    ' fx=\\\"50%\\\" fy=\\\"50%\\\" cx=\\\"50%\\\" cy=\\\"50%\\\" r=\\\"',calculatedPercentage,'%\\\" '\\n                ),\\n                stopStr\\n            );\\n        }\\n    }}\\n\\n    function createGradientMain(string memory id, Traits.GradientTraits memory traits) internal pure returns (string memory) {\\n        if (traits.palettePattern == Traits.GradientPalettePattern.TWO_COLORS) {\\n            return createGradientTwoColors(id, hslColor(traits.startingHue, traits.saturationAndLightness2), hslColor(traits.startingHue + traits.paletteStep, traits.saturationAndLightness), traits);\\n        } if (traits.palettePattern == Traits.GradientPalettePattern.TWO_COLORS_X2) {\\n            return createGradientTwoColorsX2(id, hslColor(traits.startingHue, traits.saturationAndLightness), hslColor(traits.startingHue + traits.paletteStep, traits.saturationAndLightness), traits);\\n        }  else if (traits.palettePattern == Traits.GradientPalettePattern.TWO_COLORS_ZZ) {\\n            string[] memory p2 = new string[](3);\\n            p2[0] = hslColor(traits.startingHue, traits.saturationAndLightness);\\n            p2[1] = hslColor(traits.startingHue + traits.paletteStep, traits.saturationAndLightness);\\n            p2[2] = p2[0];\\n            return createGradientFromPalette(id, p2, traits);\\n        } else if (traits.palettePattern == Traits.GradientPalettePattern.RAINBOW) {\\n            return createFullRanbowGradient(id, traits);\\n        } else if (traits.palettePattern == Traits.GradientPalettePattern.LINEAR) {\\n            string[] memory p2 = generateLinearOffsetPalette(traits.startingHue, traits.paletteStep, traits.paletteColors, traits.saturationAndLightness);\\n            return createGradientFromPalette(id, p2, traits);\\n        } \\n\\n        // default - golden angle pattern\\n        string[] memory palette = generateGoldenAnglePalette(traits.startingHue, 5, traits.saturationAndLightness3);\\n        return createGradientFromPalette(id, palette, traits);\\n    }\\n\\n    function createGradientTwoColors(string memory id, string memory color1, string memory color2, Traits.GradientTraits memory traits) internal pure returns (string memory) {\\n        ColorStop[] memory stops = new ColorStop[](2);\\n        stops[0] = ColorStop({color: color1, offset: \\\"45\\\", opacity: \\\"100\\\"});\\n        stops[1] = ColorStop({color: color2, offset: \\\"55\\\", opacity: \\\"100\\\"});\\n        return createGradient(id, stops, traits);\\n    }\\n\\n    function createGradientTwoColorsX2(string memory id, string memory color1, string memory color2, Traits.GradientTraits memory traits) internal pure returns (string memory) {\\n        ColorStop[] memory stops = new ColorStop[](4);\\n        stops[0] = ColorStop({color: color1, offset: \\\"0\\\", opacity: \\\"100\\\"});\\n        stops[1] = ColorStop({color: color2, offset: \\\"33\\\", opacity: \\\"40\\\"});\\n        stops[2] = ColorStop({color: color1, offset: \\\"66\\\", opacity: \\\"40\\\"});\\n        stops[3] = ColorStop({color: color2, offset: \\\"100\\\", opacity: \\\"100\\\"});\\n        return createGradient(id, stops, traits);\\n    }\\n\\n    function createFullRanbowGradient(string memory id, Traits.GradientTraits memory traits) internal pure returns (string memory) {\\n        string[] memory palette;\\n        \\n        if (traits.discrete) {\\n            palette = generateLinearOffsetPalette(traits.startingHue, 20, 18, traits.saturationAndLightness);\\n        } else {\\n            palette = generateLinearOffsetPalette(traits.startingHue, 10, 36, traits.saturationAndLightness);\\n        }\\n        return createGradientFromPalette(id, palette, traits);\\n    }\\n\\n    function createGradientFromPalette(string memory id, string[] memory palette, Traits.GradientTraits memory traits) internal pure returns (string memory) { unchecked {\\n        uint8 arrayAddOn = 0;\\n        if (traits.transparentFromBeginOffset > 0) {\\n            arrayAddOn += 2;\\n        }\\n        if (traits.transparentToEndOffset > 0 && traits.transparentToEndOffset < 100) {\\n            arrayAddOn += 2;\\n        } else {\\n            traits.transparentToEndOffset = 100;\\n        }\\n        \\n        if (traits.discrete) {\\n            arrayAddOn += uint8(palette.length);\\n        }\\n\\n        ColorStop[] memory stops = new ColorStop[](palette.length + arrayAddOn);\\n        uint8 arrayIndex = 0;\\n\\n        if (traits.transparentFromBeginOffset > 0) {\\n            stops[arrayIndex++] = ColorStop({color: palette[0], offset: \\\"0\\\", opacity: \\\"0\\\"});\\n            stops[arrayIndex++] = ColorStop({color: palette[0], offset: uint256(traits.transparentFromBeginOffset).toString(), opacity: \\\"0\\\"});\\n        }\\n\\n        uint8 deltaOffset = 100;\\n\\n        deltaOffset -= traits.transparentFromBeginOffset;\\n        deltaOffset -= (100 - traits.transparentToEndOffset);\\n\\n        uint256 deltaOffsetStep = uint256(deltaOffset) * Utils.MULTIPLIER / (palette.length - 1 + (traits.discrete ? 1 : 0));\\n        uint256 offset = uint256(traits.transparentFromBeginOffset) * Utils.MULTIPLIER ;\\n\\n        uint256 discreteStep = traits.discreteOffset * Utils.MULTIPLIER;\\n        if (discreteStep > deltaOffsetStep) {\\n            discreteStep = deltaOffsetStep;\\n        }\\n\\n        uint256 deltaOpacityStep = uint256(traits.endOpacity - traits.beginOpacity) * Utils.MULTIPLIER / (palette.length - 1);\\n        uint256 opacity = uint256(traits.beginOpacity) * Utils.MULTIPLIER ;\\n\\n        for (uint8 i = 0; i < palette.length; i++) {\\n            uint256 currentOpacity;\\n\\n            if (traits.opacityPattern == Traits.GradientOpacityPattern.ALL_SAME) {\\n                currentOpacity = traits.endOpacity * Utils.MULTIPLIER;\\n            } else if (traits.opacityPattern == Traits.GradientOpacityPattern.INCREASING) {\\n                currentOpacity = opacity;\\n            } else if (traits.opacityPattern == Traits.GradientOpacityPattern.DECREASING) {\\n                currentOpacity = traits.endOpacity * Utils.MULTIPLIER - (opacity - traits.beginOpacity * Utils.MULTIPLIER);\\n            } else if (traits.opacityPattern == Traits.GradientOpacityPattern.ZIG_ZAG) {\\n                if (i % 2 == 0) {\\n                    currentOpacity = traits.beginOpacity * Utils.MULTIPLIER;\\n                } else {\\n                    currentOpacity = traits.endOpacity * Utils.MULTIPLIER;\\n                }\\n            }\\n\\n            stops[arrayIndex++] = ColorStop({color: palette[i], \\n                offset: Division.divisionStr(2, int256(offset), int256(Utils.MULTIPLIER)), \\n                opacity: Division.divisionStr(2, int256(currentOpacity), int256(Utils.MULTIPLIER))\\n            });\\n\\n            if (traits.discrete) {\\n                stops[arrayIndex++] = ColorStop({color: palette[i], \\n                    offset: Division.divisionStr(2, int256(offset + deltaOffsetStep - discreteStep), int256(Utils.MULTIPLIER)), \\n                    opacity: Division.divisionStr(2, int256(currentOpacity), int256(Utils.MULTIPLIER))\\n                });     \\n            }\\n\\n            offset += deltaOffsetStep;\\n            opacity += deltaOpacityStep;\\n        }\\n\\n        if (traits.transparentToEndOffset > 0 && traits.transparentToEndOffset < 100) {\\n            stops[arrayIndex++] = ColorStop({color: palette[palette.length-1], offset: uint256(traits.transparentToEndOffset).toString(), opacity: \\\"0\\\"});\\n            stops[arrayIndex++] = ColorStop({color: palette[palette.length-1], offset: \\\"100\\\", opacity: \\\"0\\\"});\\n        }\\n\\n        return createGradient(id, stops, traits);\\n    }}\\n\\n    function generateLinearOffsetPalette(uint256 startingHue, uint256 offset, uint256 steps, string memory saturationAndLightness) internal pure returns (string[] memory) {\\n        string[] memory result = new string[](steps);\\n\\n        for (uint8 i = 0; i < steps; i++) {\\n            result[i] = hslColor(startingHue, saturationAndLightness);\\n            startingHue = (startingHue + offset) % 360;\\n        }\\n\\n        return result;\\n    }\\n\\n    // multiply is multiplied by Lib2D, multiplier\\n    function generateMultiplyOffsetPalette(uint256 startingHue, uint256 multiply, uint256 steps, string memory saturationAndLightness) internal pure returns (string[] memory) {\\n        string[] memory result = new string[](steps);\\n\\n        for (uint8 i = 0; i < steps; i++) {\\n            result[i] = hslColor(startingHue, saturationAndLightness);\\n            startingHue = (startingHue * multiply / Utils.MULTIPLIER) % 360;\\n        }\\n\\n        return result;\\n    }\\n\\n    function generateGoldenAnglePalette(uint256 startingHue, uint256 steps, string memory saturationAndLightness) internal pure returns (string[] memory) {\\n        return generateMultiplyOffsetPalette(startingHue, 137 * Utils.MULTIPLIER, steps, saturationAndLightness);\\n    }\\n\\n    function hslColor(uint256 hue, string memory saturationAndLightness) internal pure returns (string memory) {\\n        hue = hue % 360;\\n        return string.concat(\\\"hsl(\\\", hue.toString(), \\\",\\\", saturationAndLightness, \\\")\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/FilterTraits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nenum FilterType {\\n    NONE,\\n    GRAYSCALE,\\n    SEPIA,\\n    WATERCOLOR,\\n    WATERCOLOR_BRIGHT,\\n    STONE,\\n    SMOKE,\\n    DISPLACEMENT,\\n    FROZEN,\\n    SPLASH,\\n    RECOLORING,\\n    SPARKS,\\n    GLASS, \\n    SPREAD,\\n    SPREAD_BRIGHT,\\n    INNER_OUTLINE,\\n    COLOR_OUTLINE,\\n    NOISE_SHADOW,\\n    RECOLORING2,\\n    CHALK,\\n    BLACK_OUTLINE,\\n    HALF_TONE\\n}\\n\\nstruct FilterTraits {\\n    FilterType mainFilterType;\\n    bool additonalLighting;\\n    //bool darken;\\n}\"\r\n    },\r\n    \"contracts/RandomCtx.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n    \\nstruct RandomCtx {\\n    uint256 seed;\\n    uint256 counter;\\n}\"\r\n    },\r\n    \"contracts/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nlibrary Utils {\\n    uint256 internal constant MULTIPLIER   = 100000;\\n    uint256 internal constant GOLDEN_RATIO = 161803;\\n\\n    /**\\n      * Compute the largest integer smaller than or equal to the square root of `n`\\n    */\\n    function floorSqrt(uint256 n) internal pure returns (uint256) { unchecked {\\n        if (n > 0) {\\n            uint256 x = n / 2 + 1;\\n            uint256 y = (x + n / x) / 2;\\n            while (x > y) {\\n                x = y;\\n                y = (x + n / x) / 2;\\n            }\\n            return x;\\n        }\\n        return 0;\\n    }}\\n\\n    /**\\n      * Compute the smallest integer larger than or equal to the square root of `n`\\n    */\\n    function ceilSqrt(uint256 n) internal pure returns (uint256) { unchecked {\\n        uint256 x = floorSqrt(n);\\n        return x ** 2 == n ? x : x + 1;\\n    }}\\n\\n    function lerp(int256 targetFrom, int256 targetTo, int256 currentFrom, int256 currentTo, int current) internal pure returns (int256) { unchecked {\\n        int256 t = 0;\\n        int256 divisor = currentTo - currentFrom - 1;\\n        \\n        if (divisor > 0) {\\n            t = (current - currentFrom) * int256(MULTIPLIER) / (divisor);\\n        }\\n\\n        return targetFrom * int256(MULTIPLIER) + t * (targetTo - targetFrom);\\n    }}\\n\\n    function toByteArray(bytes32 _bytes32) internal pure returns (bytes memory result) {\\n        uint8 i = 0;\\n        while(i < 32 && _bytes32[i] != 0) {\\n            i++;\\n        }\\n        bytes memory bytesArray = new bytes(i);\\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\\n            bytesArray[i] = _bytes32[i];\\n        }\\n        return bytesArray;\\n    }\\n\\n    function toString(bytes32 _bytes32) internal pure returns (string memory result) {\\n        return string(toByteArray(_bytes32));\\n    }\\n\\n    /*\\n\\n        Gas Efficient uint/int to string functions\\n        Copied from: https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol\\n\\n    */\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(uint256(-value));\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n\\n    // /// @dev Returns a concatenated string of `a` and `b`.\\n    // /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    // function concat(string memory a, string memory b)\\n    //     internal\\n    //     pure\\n    //     returns (string memory result)\\n    // {\\n    //     /// @solidity memory-safe-assembly\\n    //     assembly {\\n    //         let w := not(0x1f)\\n    //         result := mload(0x40)\\n    //         let aLength := mload(a)\\n    //         // Copy `a` one word at a time, backwards.\\n    //         for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n    //             mstore(add(result, o), mload(add(a, o)))\\n    //             o := add(o, w) // `sub(o, 0x20)`.\\n    //             if iszero(o) { break }\\n    //         }\\n    //         let bLength := mload(b)\\n    //         let output := add(result, aLength)\\n    //         // Copy `b` one word at a time, backwards.\\n    //         for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n    //             mstore(add(output, o), mload(add(b, o)))\\n    //             o := add(o, w) // `sub(o, 0x20)`.\\n    //             if iszero(o) { break }\\n    //         }\\n    //         let totalLength := add(aLength, bLength)\\n    //         let last := add(add(result, 0x20), totalLength)\\n    //         // Zeroize the slot after the string.\\n    //         mstore(last, 0)\\n    //         // Stores the length.\\n    //         mstore(result, totalLength)\\n    //         // Allocate memory for the length and the bytes,\\n    //         // rounded up to a multiple of 32.\\n    //         mstore(0x40, and(add(last, 0x1f), w))\\n    //     }\\n    // }\\n}\"\r\n    },\r\n    \"contracts/Lib2D.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"./Random.sol\\\";\\nimport \\\"./RandomCtx.sol\\\";\\n\\nlibrary Lib2D {\\n    struct Point {\\n        int256 x;\\n        int256 y;\\n    }\\n\\n    function randomizeSinglePoint(RandomCtx memory ctx, Point memory p, int16 deltaX, int16 deltaY) internal pure returns (Point memory) {\\n        int256 newX = p.x + int256(Random.randRange(ctx, -deltaX, deltaX));\\n        int256 newY = p.y + int256(Random.randRange(ctx, -deltaY, deltaY));\\n\\n        return Point(newX, newY); \\n    }\\n\\n    function randomizePoints(RandomCtx memory ctx, Point[] memory points, int16 deltaX, int16 deltaY, uint8 mergeMod) internal pure returns (Point[] memory) {\\n        Point[] memory newPoints = new Point[](points.length);\\n\\n        for (uint8 i = 0; i < points.length; i++) {\\n            \\n            if ((i + 1) % mergeMod == 0) {\\n                newPoints[i] = Point(points[i].x, points[i].y);\\n            } else {\\n                newPoints[i] = randomizeSinglePoint(ctx, points[i], deltaX, deltaY);\\n            }\\n        }\\n\\n        return newPoints;\\n    }\\n\\n    function copyPoints(Point[] memory points) internal pure returns (Point[] memory) {\\n        Point[] memory newPoints = new Point[](points.length);\\n\\n        for (uint8 i = 0; i < points.length; i++) {\\n            newPoints[i] = Point(points[i].x, points[i].y);\\n        }\\n\\n        return newPoints;\\n    }\\n\\n    function shiftPoints(Point[] memory points, int16 deltaX, int16 deltaY, uint8 mergeMod) internal pure returns (Point[] memory) {\\n        Point[] memory newPoints = new Point[](points.length);\\n\\n        for (uint8 i = 0; i < points.length; i++) {\\n\\n            if ((i + 1) % mergeMod == 0) {\\n                newPoints[i] = Point(points[i].x, points[i].y);\\n            } else {\\n                newPoints[i] = Point(points[i].x + deltaX, points[i].y + deltaY);\\n            }\\n        }\\n\\n        return newPoints;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/Division.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"./Utils.sol\\\";\\n\\nlibrary Division {\\n    using Utils for int256;\\n\\n    function division(uint8 decimalPlaces, int256 numerator, int256 denominator) pure internal returns(int256 quotient, int256 remainder, string memory result) { unchecked {\\n        int256 factor = int256(10**decimalPlaces);\\n        quotient  = numerator / denominator;\\n        bool rounding = 2 * ((numerator * factor) % denominator) >= denominator;\\n        remainder = (numerator * factor / denominator) % factor;\\n        if (rounding) {\\n            remainder += 1;\\n        }\\n        result = string(abi.encodePacked(quotient.toString(), '.', numToFixedLengthStr(decimalPlaces, remainder)));\\n    }}\\n\\n    function divisionStr(uint8 decimalPlaces, int256 numerator, int256 denominator) pure internal returns(string memory) {\\n        string memory result;\\n        (,,result) = division(decimalPlaces, numerator, denominator);\\n        return result;\\n    }\\n\\n    function numToFixedLengthStr(uint256 decimalPlaces, int256 num) pure internal returns(string memory result) { unchecked {\\n        bytes memory byteString;\\n        for (uint256 i = 0; i < decimalPlaces; i++) {\\n            int256 remainder = num % 10;\\n            byteString = abi.encodePacked(remainder.toString(), byteString);\\n            num = num/10;\\n        }\\n        result = string(byteString);\\n    }}\\n}\"\r\n    },\r\n    \"contracts/Filters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport './IFilters.sol';\\nimport './Filters-generated.sol';\\nimport './FilterTraits.sol';\\nimport './Random.sol';\\nimport './RandomCtx.sol';\\nimport './Utils.sol';\\n\\ncontract Filters is IFilters {\\n    using Utils for uint256; \\n\\n    function wrapInGandApplyFilter(string memory svgElement, string memory filterId) internal pure returns (string memory) {\\n        return  string.concat('<g filter=\\\"',string.concat('url(#', filterId, ')'),'\\\">', svgElement, '</g>');\\n    }\\n\\n    // function wrapInGandApplyFilter(string memory svgElement, Traits.FilterType filter) internal pure returns (string memory) {\\n    //     return wrapInGandApplyFilter(svgElement, getFilterId(filter));\\n    // }\\n\\n    // function getFilterId(Traits.FilterType filter) internal pure returns (string memory) {\\n    //     // TODO: replace with just returing enum ID to string\\n    //     if (filter == Traits.FilterType.NONE) return \\\"none\\\";\\n    //     if (filter == Traits.FilterType.GRAYSCALE) return \\\"grayscale\\\";\\n    //     if (filter == Traits.FilterType.SEPIA) return \\\"sepia\\\";\\n    //     return \\\"\\\";\\n    // }\\n    \\n    function randBlendMode(RandomCtx memory rndCtx, bool noDifference) internal pure returns (string memory) {\\n        int256 mode = int8(Random.randWithProbabilities(rndCtx, hex\\\"0A01010101\\\"));\\n\\n        if (mode == 1) return \\\"screen\\\";\\n        if (mode == 2) return \\\"multiply\\\";\\n        if (mode == 3) return \\\"color-burn\\\";\\n\\n        if (noDifference) return \\\"normal\\\";\\n\\n        if (mode == 4) return \\\"difference\\\";\\n\\n        return \\\"normal\\\";           \\n    }\\n\\n    function randomHtmlColor(RandomCtx memory rndCtx) internal pure returns (string memory) {\\n        int256 color = int8(Random.randWithProbabilities(rndCtx, hex\\\"0A01010101\\\"));\\n\\n        if (color == 1) return \\\"#F1E5AC\\\";\\n        if (color == 2) return \\\"#FAEDEB\\\";\\n        if (color == 3) return \\\"#FFE5B4\\\";\\n        if (color == 4) return \\\"#FCE8FF\\\";\\n\\n        return \\\"white\\\";                   \\n    }\\n\\n    // following are to workaround a bug with viaIR, causing Random.sol to be dynamically linked, instead of inlining it\\n    function randUInt32(RandomCtx memory ctx) internal pure returns (uint32) {\\n        return Random.randUInt32(ctx);\\n    }\\n\\n    function randFloat(RandomCtx memory ctx, uint8 decimalPlaces, int256 from, int256 to, int256 denominator) internal pure returns (string memory result) {\\n        return Random.randFloat(ctx, decimalPlaces, from, to, denominator);\\n    }\\n\\n    function randRange(RandomCtx memory ctx, int256 from, int256 to) internal pure returns (int256) {\\n        return Random.randRange(ctx, from, to);\\n    }\\n\\n    function randBool(RandomCtx memory ctx, int256 trueProbability) internal pure returns (bool) {\\n        return Random.randBool(ctx, trueProbability);\\n    }\\n\\n    function generateFilterString(RandomCtx memory rndCtx, FilterType filter, string memory filterId) internal pure returns (string memory) {               \\n        if (filter == FilterType.NONE) return \\\"\\\";\\n        if (filter == FilterType.GRAYSCALE) return FiltersGenerated.createFilter_grayscale(filterId);\\n        if (filter == FilterType.SEPIA) return FiltersGenerated.createFilter_sepia(filterId);\\n        if (filter == FilterType.WATERCOLOR) {\\n            return FiltersGenerated.createFilter_watercolor(filterId,\\n                uint256(randUInt32(rndCtx)).toString(),                // seed 1\\n                uint256(randUInt32(rndCtx)).toString(),                // seed 2\\n                uint256(randRange(rndCtx, 1, 2)).toString(),           // glowRaius\\n                \\\"out\\\",\\n                randFloat(rndCtx, 2, 12, 20, 10),                      // colorK1\\n                randFloat(rndCtx, 2, 30, 70, 100),                     // colorK3\\n                randFloat(rndCtx, 2, 14, 20, 10)\\n            );\\n        }\\n        if (filter == FilterType.WATERCOLOR_BRIGHT) {\\n            if (randBool(rndCtx, 70)) {\\n                string memory operator = \\\"atop\\\";\\n\\n                if (randBool(rndCtx, 50)) {\\n                    if (randBool(rndCtx, 50)) {\\n                        operator = \\\"atop\\\";\\n                    } else {\\n                        operator = \\\"in\\\";\\n                    }\\n                }\\n\\n                return FiltersGenerated.createFilter_watercolor(filterId,\\n                    uint256(randUInt32(rndCtx)).toString(),              // seed 1\\n                    uint256(randUInt32(rndCtx)).toString(),              // seed 2\\n                    uint256(randRange(rndCtx, 1, 4)).toString(),         // glowRaius\\n                    operator,\\n                    randFloat(rndCtx, 2, 25, 35, 10),                    // colorK1\\n                    randFloat(rndCtx, 2, 250, 300, 100),                 // colorK3\\n                    \\\"1.4\\\"\\n                );\\n            } else {\\n                string memory operator = \\\"in\\\";\\n\\n                if (randBool(rndCtx, 80)) {\\n                    operator = \\\"atop\\\";\\n                }\\n\\n                return FiltersGenerated.createFilter_watercolor(filterId,\\n                    uint256(randUInt32(rndCtx)).toString(),              // seed 1\\n                    uint256(randUInt32(rndCtx)).toString(),              // seed 2\\n                    uint256(randRange(rndCtx, 1, 5)).toString(),         // glowRaius\\n                    operator,\\n                    randFloat(rndCtx, 2, 70, 120, 10),                   // colorK1\\n                    randFloat(rndCtx, 2, 300, 500, 100),                 // colorK3\\n                    randFloat(rndCtx, 2, 7, 18, 10)\\n                );\\n\\n            }\\n        }\\n\\n        if (filter == FilterType.STONE) {\\n            return FiltersGenerated.createFilter_stoneSurface(filterId,\\n                uint256(randUInt32(rndCtx)).toString(),              // seed 1\\n                randFloat(rndCtx, 5, 5, 15, 10000),\\n                uint256(randRange(rndCtx, 3, 4)).toString(),  \\n                uint256(randRange(rndCtx, 4, 10)).toString(),  \\n                randomHtmlColor(rndCtx),\\n                uint256(randRange(rndCtx, 4, 10)).toString()\\n            );\\n        }\\n\\n        if (filter == FilterType.SMOKE) {\\n            return FiltersGenerated.createFilter_displacement2(filterId,\\n                uint256(randUInt32(rndCtx)).toString(),              // seed 1\\n                randFloat(rndCtx, 2, 2, 3, 100),                     // baseFreq\\n                uint256(randRange(rndCtx, 1, 4)).toString(),         // octaves\\n                uint256(randRange(rndCtx, 30, 50)).toString(),       // scale\\n                \\\"2\\\", \\n                uint256(randRange(rndCtx, 5, 25)).toString(), \\n                randBlendMode(rndCtx, false)\\n            );\\n        }\\n\\n        if (filter == FilterType.DISPLACEMENT) {\\n            return FiltersGenerated.createFilter_displacement3(filterId,\\n                uint256(randUInt32(rndCtx)).toString(),              // seed 1\\n                randFloat(rndCtx, 2, 1, 5, 100),                     // baseFreq\\n                \\\"5\\\",                                                 //octaves\\n                uint256(randRange(rndCtx, 1, 10)).toString(),        // blur\\n                uint256(randRange(rndCtx, 40, 80)).toString()        // scale\\n            );\\n        }\\n\\n        if (filter == FilterType.FROZEN) {\\n            return FiltersGenerated.createFilter_displacement2(filterId,\\n                uint256(randUInt32(rndCtx)).toString(),              // seed 1\\n                Random.randFloat(rndCtx, 2, 2, 3, 10),                     // baseFreq\\n                uint256(randRange(rndCtx, 1, 4)).toString(),         // octaves\\n                uint256(randRange(rndCtx, 20, 30)).toString(),       // scale\\n                \\\"1\\\", \\\"1\\\", \\n                randBlendMode(rndCtx, false)\\n            );\\n        }\\n\\n        if (filter == FilterType.SPLASH) {\\n            return FiltersGenerated.createFilter_displacement2(filterId,\\n                uint256(randUInt32(rndCtx)).toString(),              // seed 1\\n                \\\"0.05\\\",                                              // baseFreq\\n                uint256(randRange(rndCtx, 1, 4)).toString(),         // octaves\\n                uint256(randRange(rndCtx, 80, 100)).toString(),      // scale\\n                uint256(randRange(rndCtx, 1, 4)).toString(),  \\n                uint256(randRange(rndCtx, 3, 10)).toString(),  \\n                randBlendMode(rndCtx, false)\\n            );\\n        }\\n\\n        if (filter == FilterType.RECOLORING) {\\n            string memory fx = randFloat(rndCtx, 4, 1, 10, 1000);\\n            string memory fy = fx;\\n            \\n            // if (Random.randBool(rndCtx, 20)) {\\n            //     fy = Random.randFloat(rndCtx, 4, 1, 10, 1000);\\n            // }\\n\\n            return FiltersGenerated.createFilter_patternRecoloring(filterId,\\n                uint256(randUInt32(rndCtx)).toString(),              // seed 1\\n                fx,          \\n                fy\\n            );\\n        }\\n\\n        if (filter == FilterType.SPARKS) {\\n            return FiltersGenerated.createFilter_sparks(filterId,\\n                uint256(randUInt32(rndCtx)).toString(),              // seed 1\\n                randFloat(rndCtx, 4, 1, 10, 1000),          \\n                uint256(randRange(rndCtx, 1, 10)).toString(),\\n                randFloat(rndCtx, 4, 2, 20, 10)   \\n            );\\n        }\\n\\n        if (filter == FilterType.GLASS) {\\n            return FiltersGenerated.createFilter_glass(filterId);\\n        }\\n\\n        if (filter == FilterType.SPREAD) {\\n            return FiltersGenerated.createFilter_spread(filterId,\\n                uint256(randRange(rndCtx, 1, 10)).toString(),\\n                randBlendMode(rndCtx, true)\\n            );\\n        }\\n\\n        if (filter == FilterType.SPREAD_BRIGHT) {\\n            string memory offset = uint256(randRange(rndCtx, 1, 20)).toString();\\n            return FiltersGenerated.createFilter_spreadBright(filterId,\\n                uint256(randRange(rndCtx, 3, 10)).toString(),\\n                offset, offset\\n            );\\n        }\\n\\n        if (filter == FilterType.INNER_OUTLINE) {\\n            return FiltersGenerated.createFilter_innerOutline1(filterId);\\n        }\\n\\n        if (filter == FilterType.COLOR_OUTLINE) {\\n            return FiltersGenerated.createFilter_colorOutlineIn(filterId);\\n        }\\n\\n        if (filter == FilterType.NOISE_SHADOW) {\\n            return FiltersGenerated.createFilter_noiseShadow(filterId,\\n                uint256(randRange(rndCtx, 5, 25)).toString(),\\n                uint256(randRange(rndCtx, 4, 11)).toString()\\n            );\\n        }\\n\\n        if (filter == FilterType.RECOLORING2) {\\n            return FiltersGenerated.createFilter_recolor2(filterId,\\n                randFloat(rndCtx, 4, 1, 20, 1000),        \\n                uint256(randRange(rndCtx, 2, 6)).toString(),\\n                uint256(randUInt32(rndCtx)).toString()\\n            );\\n        }\\n\\n        if (filter == FilterType.CHALK) {\\n            return FiltersGenerated.createFilter_chalk(filterId);\\n        }\\n\\n        if (filter == FilterType.BLACK_OUTLINE) {\\n            return FiltersGenerated.createFilter_blackOutline(filterId,\\n                uint256(randRange(rndCtx, 1, 5)).toString(),\\n                uint256(randRange(rndCtx, 1, 3)).toString(),\\n                uint256(randRange(rndCtx, 8, 10)).toString()\\n            );\\n        }\\n\\n        if (filter == FilterType.HALF_TONE) {\\n            return FiltersGenerated.createFilter_halftone(filterId);\\n        }\\n\\n        return \\\"\\\";\\n    }\\n\\n    function generateAllFilterStrings(RandomCtx memory rndCtx, FilterTraits memory filter) external pure override returns (string memory) {\\n        string memory mainFilter = generateFilterString(rndCtx, filter.mainFilterType, \\\"mainF\\\");\\n\\n        string memory postFilter = filter.additonalLighting ? FiltersGenerated.createFilter_light(\\\"postF\\\"): \\\"\\\";\\n        //string memory darkenFilter = filter.darken ? FiltersGenerated.createFilter_brightnessAndSaturation(\\\"darkenF\\\", \\\"1\\\", \\\"1\\\"): \\\"\\\";\\n\\n        return string.concat(mainFilter, \\\" \\\", postFilter);//, \\\" \\\", darkenFilter);\\n    }\\n\\n    function applyAllFilters(FilterTraits memory filter, string memory svgElement) external pure override returns (string memory) {\\n        string memory result = svgElement;\\n        \\n        if (filter.mainFilterType != FilterType.NONE) {\\n            result = wrapInGandApplyFilter(result, \\\"mainF\\\");\\n        }\\n\\n        if (filter.additonalLighting) {\\n            result = wrapInGandApplyFilter(result, \\\"postF\\\");\\n        }\\n\\n        return result;\\n    }        \\n}\"\r\n    },\r\n    \"contracts/Filters-generated.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\nimport './SVG.sol';\\n\\n/** AUTOGENERATED - DO NOT MODIFY THIS FILE DIRECTLY */\\n\\nlibrary FiltersGenerated {\\n\\n    function createFilter_watercolor(string memory id, string memory seed1, string memory seed2, string memory glowRadius, string memory compositeOperator, string memory colorK1, string memory colorK3, string memory secondColorK3) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feTurbulence result=\\\"f0\\\" type=\\\"fractalNoise\\\" baseFrequency=\\\".04\\\" numOctaves=\\\"2\\\" seed=\\\"', seed1, '\\\"/>', \\n            '<feTurbulence result=\\\"f15\\\" type=\\\"fractalNoise\\\" baseFrequency=\\\".2\\\" numOctaves=\\\"3\\\" seed=\\\"', seed2, '\\\"/>', \\n            '<feComposite result=\\\"f17\\\" in=\\\"SourceGraphic\\\" in2=\\\"f0\\\" operator=\\\"arithmetic\\\" k1=\\\"0.5\\\" k2=\\\"0.6\\\" k4=\\\"-.07\\\"/>'\\n            '<feMorphology id=\\\"water\\\" result=\\\"f19\\\" in=\\\"f17\\\" operator=\\\"dilate\\\" radius=\\\"1\\\"/>'\\n            '<feDisplacementMap result=\\\"f19\\\" in=\\\"f19\\\" in2=\\\"f0\\\" xChannelSelector=\\\"R\\\" yChannelSelector=\\\"B\\\" scale=\\\"2\\\"/>'\\n            '<feDisplacementMap result=\\\"f19\\\" in=\\\"f19\\\" in2=\\\"f15\\\" xChannelSelector=\\\"R\\\" yChannelSelector=\\\"B\\\" scale=\\\"4\\\"/>'\\n            '<feDisplacementMap result=\\\"f16\\\" in=\\\"f19\\\" in2=\\\"f0\\\" xChannelSelector=\\\"A\\\" yChannelSelector=\\\"A\\\" scale=\\\"6\\\"/>'\\n            '<feGaussianBlur result=\\\"f16\\\" in=\\\"f16\\\" stdDeviation=\\\"1\\\"/>'\\n            '<feComposite result=\\\"f19\\\" in=\\\"f19\\\" in2=\\\"f16\\\" operator=\\\"arithmetic\\\" k1=\\\"1.2\\\" k2=\\\"-.25\\\" k3=\\\"-.25\\\" k4=\\\"0\\\"/>'\\n            '<feDisplacementMap result=\\\"f18\\\" in=\\\"f17\\\" in2=\\\"f0\\\" xChannelSelector=\\\"G\\\" yChannelSelector=\\\"R\\\" scale=\\\"4\\\"/>'\\n            '<feDisplacementMap result=\\\"f18\\\" in=\\\"f18\\\" in2=\\\"f15\\\" xChannelSelector=\\\"A\\\" yChannelSelector=\\\"G\\\" scale=\\\"2\\\"/>'\\n            '<feDisplacementMap result=\\\"f20\\\" in=\\\"f17\\\" in2=\\\"f0\\\" xChannelSelector=\\\"R\\\" yChannelSelector=\\\"A\\\" scale=\\\"16\\\"/>'\\n            '<feMorphology result=\\\"f7\\\" in=\\\"f20\\\" operator=\\\"erode\\\" radius=\\\"', glowRadius, '\\\"/>', \\n            '<feComposite result=\\\"f20\\\" in=\\\"f20\\\" in2=\\\"f7\\\" operator=\\\"', compositeOperator);\\n        result = string.concat(result, '\\\"/>', \\n            '<feGaussianBlur result=\\\"f20\\\" in=\\\"f20\\\" stdDeviation=\\\"1.6\\\"/>'\\n            '<feComposite id=\\\"color\\\" result=\\\"f18\\\" in=\\\"f18\\\" in2=\\\"f20\\\" operator=\\\"arithmetic\\\" k1=\\\"', colorK1, '\\\" k2=\\\"0\\\" k3=\\\"', colorK3, '\\\"/>', \\n            '<feComposite in=\\\"f19\\\" in2=\\\"f18\\\" operator=\\\"arithmetic\\\" k1=\\\"-0.8\\\" k2=\\\"0.8\\\" k3=\\\"', secondColorK3, '\\\"/>', \\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_displacement2(string memory id, string memory seed, string memory baseFreq, string memory octaves, string memory scale, string memory radius, string memory blur, string memory blendMode) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feTurbulence type=\\\"fractalNoise\\\" seed=\\\"', seed, '\\\" baseFrequency=\\\"', baseFreq, '\\\" numOctaves=\\\"', octaves, '\\\"/>', \\n            '<feDisplacementMap in=\\\"SourceGraphic\\\" xChannelSelector=\\\"G\\\" scale=\\\"', scale, '\\\" result=\\\"f8\\\"/>', \\n            '<feMorphology operator=\\\"dilate\\\" radius=\\\"');\\n        result = string.concat(result, radius, '\\\"/>', \\n            '<feGaussianBlur stdDeviation=\\\"', blur, '\\\"/>', \\n            '<feBlend in2=\\\"f8\\\" mode=\\\"', blendMode, '\\\"/>', \\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_displacement3(string memory id, string memory seed, string memory baseFreq, string memory octaves, string memory blur, string memory scale) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feTurbulence type=\\\"fractalNoise\\\" seed=\\\"', seed, '\\\" baseFrequency=\\\"', baseFreq, '\\\" numOctaves=\\\"', octaves, '\\\"/>', \\n            '<feGaussianBlur result=\\\"f9\\\" stdDeviation=\\\"', blur, '\\\"/>', \\n            '<feDisplacementMap in2=\\\"f9\\\" in=\\\"SourceGraphic\\\" xChannelSelector=\\\"R\\\" yChannelSelector=\\\"B\\\" scale=\\\"');\\n        result = string.concat(result, scale, '\\\"/>', \\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_patternRecoloring(string memory id, string memory seed, string memory freqX, string memory freqY) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feTurbulence seed=\\\"', seed, '\\\" baseFrequency=\\\"', freqX, ' ', freqY, '\\\"/>', \\n            '<feColorMatrix values=\\\"0 0 0 2.5 0 0 2.5 0 0 0 0 0 1.5 0 0 0 0 0 0 2.5\\\"/>'\\n            '<feComposite in2=\\\"SourceGraphic\\\" operator=\\\"in\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_stoneSurface(string memory id, string memory seed, string memory baseFreq, string memory diffuse, string memory surfaceScale, string memory color, string memory elevation) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feTurbulence type=\\\"fractalNoise\\\" seed=\\\"', seed, '\\\" baseFrequency=\\\"', baseFreq, '\\\" numOctaves=\\\"9\\\"/>', \\n            '<feComponentTransfer>'\\n            '<feFuncA type=\\\"table\\\" tableValues=\\\"0 .02 .1 .25 .2 .25 .3 .4 .5 .6 .7 .8\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feDiffuseLighting diffuseConstant=\\\"', diffuse, '\\\" surfaceScale=\\\"', surfaceScale, '\\\" lighting-color=\\\"', color);\\n        result = string.concat(result, '\\\">', \\n            '<feDistantLight elevation=\\\"', elevation, '\\\"/>', \\n            '</feDiffuseLighting>'\\n            '<feComposite in2=\\\"SourceGraphic\\\" operator=\\\"in\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_sparks(string memory id, string memory seed, string memory baseFreq, string memory octaves, string memory amplitude) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feTurbulence type=\\\"fractalNoise\\\" seed=\\\"', seed, '\\\" baseFrequency=\\\"', baseFreq, '\\\" numOctaves=\\\"', octaves, '\\\"/>', \\n            '<feComponentTransfer>'\\n            '<feFuncA type=\\\"table\\\" tableValues=\\\"0 1 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feColorMatrix values=\\\"0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1\\\"/>'\\n            '<feComponentTransfer>'\\n            '<feFuncR type=\\\"gamma\\\" exponent=\\\"8\\\"/>'\\n            '<feFuncG type=\\\"gamma\\\" amplitude=\\\"', amplitude, '\\\" exponent=\\\"32\\\"/>', \\n            '<feFuncB type=\\\"gamma\\\" amplitude=\\\".65\\\" exponent=\\\"64\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComposite in2=\\\"SourceGraphic\\\" operator=\\\"in\\\"/>'\\n            '<feBlend in2=\\\"SourceGraphic\\\" mode=\\\"normal\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_light(string memory id) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feGaussianBlur in=\\\"SourceAlpha\\\" stdDeviation=\\\"3\\\" result=\\\"f9\\\"/>'\\n            '<feSpecularLighting in=\\\"f9\\\" specularExponent=\\\"128\\\" result=\\\"f11\\\" lighting-color=\\\"white\\\">'\\n            '<feDistantLight azimuth=\\\"225\\\" elevation=\\\"70\\\"/>'\\n            '</feSpecularLighting>'\\n            '<feComposite in=\\\"f11\\\" in2=\\\"SourceAlpha\\\" operator=\\\"in\\\" result=\\\"f12\\\"/>'\\n            '<feComposite in=\\\"SourceGraphic\\\" in2=\\\"f12\\\" operator=\\\"arithmetic\\\" k2=\\\"1\\\" k3=\\\"1\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_sepia(string memory id) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" color-interpolation-filters=\\\"sRGB\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\">', \\n            '<feColorMatrix type=\\\"matrix\\\" values=\\\"0.393 0.769 0.189 0 0 0.349 0.686 0.168 0 0 0.272 0.534 0.131 0 0 0 0 0 1 0\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_grayscale(string memory id) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" color-interpolation-filters=\\\"sRGB\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\">', \\n            '<feColorMatrix type=\\\"matrix\\\" values=\\\"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_glass(string memory id) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feBlend result=\\\"f24\\\" mode=\\\"screen\\\" in2=\\\"SourceGraphic\\\"/>'\\n            '<feGaussianBlur stdDeviation=\\\"2\\\" result=\\\"f9\\\"/>'\\n            '<feComposite operator=\\\"xor\\\" in=\\\"f9\\\" in2=\\\"f24\\\" result=\\\"f25\\\"/>'\\n            '<feComposite result=\\\"f26\\\" in=\\\"f25\\\" operator=\\\"xor\\\" in2=\\\"f25\\\"/>'\\n            '<feGaussianBlur result=\\\"f9\\\" stdDeviation=\\\"3\\\" in=\\\"f26\\\"/>'\\n            '<feSpecularLighting result=\\\"f11\\\" specularExponent=\\\"55\\\" specularConstant=\\\"1.5\\\" surfaceScale=\\\"6\\\" in=\\\"f9\\\">'\\n            '<fePointLight z=\\\"20000\\\" y=\\\"-8000\\\" x=\\\"-5000\\\"/>'\\n            '</feSpecularLighting>'\\n            '<feComposite in=\\\"f9\\\" k3=\\\"1\\\" k2=\\\"1.5\\\" operator=\\\"arithmetic\\\" in2=\\\"SourceGraphic\\\" result=\\\"f25\\\"/>'\\n            '<feComposite in=\\\"f11\\\" operator=\\\"atop\\\" in2=\\\"f25\\\" result=\\\"f25\\\"/>'\\n            '<feBlend mode=\\\"multiply\\\" in2=\\\"f25\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_spread(string memory id, string memory blur, string memory blendMode) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feGaussianBlur result=\\\"f27\\\" stdDeviation=\\\"', blur, '\\\" in=\\\"SourceGraphic\\\"/>', \\n            '<feComposite result=\\\"f28\\\" operator=\\\"in\\\" in2=\\\"f27\\\" in=\\\"f27\\\"/>'\\n            '<feComposite result=\\\"f29\\\" operator=\\\"arithmetic\\\" k2=\\\"1\\\" in2=\\\"f28\\\" in=\\\"f28\\\"/>'\\n            '<feColorMatrix values=\\\"1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 10 0\\\" in=\\\"f29\\\"/>'\\n            '<feGaussianBlur result=\\\"f30\\\" stdDeviation=\\\"1\\\"/>'\\n            '<feColorMatrix result=\\\"f31\\\" values=\\\"1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 5 -1\\\" in=\\\"f30\\\"/>'\\n            '<feBlend result=\\\"f32\\\" mode=\\\"', blendMode, '\\\" in2=\\\"f31\\\" in=\\\"SourceGraphic\\\"/>', \\n            '<feComposite operator=\\\"in\\\" in2=\\\"f31\\\" in=\\\"f32\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_spreadBright(string memory id, string memory blur, string memory offsetX, string memory offsetY) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feGaussianBlur result=\\\"f9\\\" stdDeviation=\\\"', blur, '\\\"/>', \\n            '<feOffset result=\\\"f33\\\" dx=\\\"', offsetX, '\\\" dy=\\\"', offsetY, '\\\"/>', \\n            '<feComposite in2=\\\"f9\\\" operator=\\\"in\\\" in=\\\"f33\\\" result=\\\"f26\\\"/>'\\n            '<feBlend in2=\\\"f26\\\" mode=\\\"difference\\\" in=\\\"f26\\\" result=\\\"f24\\\"/>'\\n            '<feConvolveMatrix result=\\\"f25\\\" in=\\\"f24\\\" targetX=\\\"0\\\" bias=\\\"0\\\" divisor=\\\"2\\\" kernelMatrix=\\\"-2 0 2 0 4 0 2 0 2\\\" order=\\\"3 3\\\"/>'\\n            '<feComposite in2=\\\"f25\\\" operator=\\\"atop\\\" in=\\\"f26\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_innerOutline1(string memory id) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feGaussianBlur stdDeviation=\\\"2\\\" in=\\\"SourceAlpha\\\" result=\\\"f9\\\"/>'\\n            '<feComposite in2=\\\"f9\\\" operator=\\\"arithmetic\\\" k1=\\\"-1\\\" k2=\\\"3.2\\\" k4=\\\"-2\\\"/>'\\n            '<feColorMatrix values=\\\"0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 10 0\\\" result=\\\"f26\\\"/>'\\n            '<feComposite in2=\\\"f26\\\" operator=\\\"out\\\" in=\\\"SourceGraphic\\\" result=\\\"f34\\\"/>'\\n            '<feBlend in2=\\\"f34\\\" mode=\\\"darken\\\" in=\\\"f34\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_colorOutlineIn(string memory id) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feGaussianBlur stdDeviation=\\\"2\\\"/>'\\n            '<feColorMatrix values=\\\"1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 10 -9\\\" result=\\\"f26\\\"/>'\\n            '<feComposite in2=\\\"f26\\\" operator=\\\"in\\\" in=\\\"SourceGraphic\\\" result=\\\"f35\\\"/>'\\n            '<feFlood in=\\\"f35\\\"/>'\\n            '<feComposite in2=\\\"SourceGraphic\\\" operator=\\\"in\\\" result=\\\"f26\\\"/>'\\n            '<feBlend in2=\\\"f26\\\" mode=\\\"normal\\\" in=\\\"f35\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_recolor2(string memory id, string memory baseFreq, string memory octaves, string memory seed) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feGaussianBlur result=\\\"f9\\\" stdDeviation=\\\"5\\\"/>'\\n            '<feTurbulence baseFrequency=\\\"', baseFreq, '\\\" numOctaves=\\\"', octaves, '\\\" type=\\\"turbulence\\\" result=\\\"f36\\\" seed=\\\"', seed, '\\\"/>', \\n            '<feComposite in2=\\\"f9\\\" operator=\\\"in\\\" in=\\\"f9\\\" result=\\\"f25\\\"/>'\\n            '<feDisplacementMap in2=\\\"f25\\\" scale=\\\"120\\\" xChannelSelector=\\\"A\\\" yChannelSelector=\\\"A\\\" in=\\\"f36\\\" result=\\\"f37\\\"/>'\\n            '<feComposite in2=\\\"f37\\\" operator=\\\"arithmetic\\\" k1=\\\"2\\\" k2=\\\".25\\\" k3=\\\"2.5\\\" in=\\\"SourceGraphic\\\" result=\\\"f25\\\"/>'\\n            '<feComposite in2=\\\"SourceGraphic\\\" operator=\\\"in\\\" in=\\\"f25\\\" result=\\\"f25\\\"/>'\\n            '<feBlend in2=\\\"f25\\\" mode=\\\"screen\\\" result=\\\"f24\\\"/>'\\n            '<feBlend in2=\\\"f24\\\" mode=\\\"multiply\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_chalk(string memory id) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feTurbulence result=\\\"f36\\\" numOctaves=\\\"5\\\" seed=\\\"0\\\" type=\\\"fractalNoise\\\" baseFrequency=\\\".4\\\"/>'\\n            '<feOffset dy=\\\"-5\\\" dx=\\\"-5\\\"/>'\\n            '<feDisplacementMap in2=\\\"f36\\\" scale=\\\"30\\\" xChannelSelector=\\\"R\\\" yChannelSelector=\\\"G\\\" in=\\\"SourceGraphic\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_noiseShadow(string memory id, string memory stdDeviation, string memory slope) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-50%\\\" y=\\\"-50%\\\" width=\\\"200%\\\" height=\\\"200%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feOffset in=\\\"SourceAlpha\\\" dx=\\\"0\\\" dy=\\\"0\\\" result=\\\"f33\\\"/>'\\n            '<feGaussianBlur in=\\\"f33\\\" stdDeviation=\\\"', stdDeviation, '\\\" result=\\\"f9\\\"/>', \\n            '<feComponentTransfer in=\\\"f9\\\" result=\\\"f38\\\">'\\n            '<feFuncA type=\\\"table\\\" tableValues=\\\".65 .68 .75 .95 1 1 1\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComposite operator=\\\"in\\\" in=\\\"f9\\\" in2=\\\"f38\\\" result=\\\"f26\\\"/>'\\n            '<feComponentTransfer in=\\\"f26\\\" result=\\\"f38\\\">'\\n            '<feFuncA type=\\\"linear\\\" slope=\\\"', slope, '\\\"/>', \\n            '</feComponentTransfer>'\\n            '<feColorMatrix in=\\\"f38\\\" type=\\\"matrix\\\" values=\\\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.48 0\\\" result=\\\"f39\\\"/>'\\n            '<feTurbulence result=\\\"f40\\\" type=\\\"fractalNoise\\\" numOctaves=\\\"6\\\" baseFrequency=\\\"1.98\\\" seed=\\\"777\\\"/>'\\n            '<feColorMatrix in=\\\"f40\\\" type=\\\"matrix\\\" values=\\\"1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 7 -3\\\" result=\\\"f41\\\"/>'\\n            '<feComposite operator=\\\"arithmetic\\\" in=\\\"f39\\\" in2=\\\"f41\\\" k1=\\\"0.51\\\" k2=\\\"0.49\\\" result=\\\"f42\\\"/>'\\n            '<feMerge>'\\n            '<feMergeNode in=\\\"f42\\\"/>'\\n            '<feMergeNode in=\\\"SourceGraphic\\\"/>'\\n            '</feMerge>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_blackOutline(string memory id, string memory stdDeviation, string memory k2, string memory k3) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feGaussianBlur result=\\\"f9\\\" in=\\\"SourceAlpha\\\" stdDeviation=\\\"', stdDeviation, '\\\"/>', \\n            '<feComposite in2=\\\"f9\\\" operator=\\\"arithmetic\\\" k2=\\\"', k2, '\\\" k3=\\\"', k3, '\\\" in=\\\"SourceGraphic\\\" result=\\\"f26\\\"/>', \\n            '<feComposite in2=\\\"f26\\\" operator=\\\"in\\\" in=\\\"f26\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n\\n    function createFilter_halftone(string memory id) internal pure returns (string memory) {\\n        string memory result = string.concat(\\n            '<filter id=\\\"', id, '\\\" x=\\\"-10%\\\" y=\\\"-10%\\\" height=\\\"120%\\\" width=\\\"120%\\\" color-interpolation-filters=\\\"sRGB\\\">', \\n            '<feTurbulence type=\\\"fractalNoise\\\" baseFrequency=\\\"0.7\\\" numOctaves=\\\"8\\\"/>'\\n            '<feColorMatrix type=\\\"saturate\\\" values=\\\"0\\\"/>'\\n            '<feComponentTransfer result=\\\"f43\\\">'\\n            '<feFuncR type=\\\"discrete\\\" tableValues=\\\"0 0 0 0 0 0 0 0 1 1\\\"/>'\\n            '<feFuncG type=\\\"discrete\\\" tableValues=\\\"0 0 0 0 0 0 0 0 1 1\\\"/>'\\n            '<feFuncB type=\\\"discrete\\\" tableValues=\\\"0 0 0 0 0 0 0 0 1 1\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f43\\\">'\\n            '<feFuncA in=\\\"f43\\\" type=\\\"discrete\\\" tableValues=\\\"1 1 0 0 0 0 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer result=\\\"f44\\\">'\\n            '<feFuncA type=\\\"table\\\" tableValues=\\\"0 0 0 0 0 0 0 1\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f43\\\">'\\n            '<feFuncA in=\\\"f43\\\" type=\\\"discrete\\\" tableValues=\\\"1 1 1 1 0 0 0 0 0 0 0 0 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer result=\\\"f45\\\">'\\n            '<feFuncA type=\\\"table\\\" tableValues=\\\"0 0 0 0 0 0 0 1\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f43\\\">'\\n            '<feFuncA in=\\\"f43\\\" type=\\\"discrete\\\" tableValues=\\\"1 1 1 1 1 0 0 0 0 0 0 0 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer result=\\\"f46\\\">'\\n            '<feFuncA type=\\\"table\\\" tableValues=\\\"0 0 0 0 0 0 0 1\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f43\\\">'\\n            '<feFuncA in=\\\"f43\\\" type=\\\"discrete\\\" tableValues=\\\"1 1 1 1 1 1 0 0 0 0 0 0 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer result=\\\"f47\\\">'\\n            '<feFuncA type=\\\"table\\\" tableValues=\\\"0 0 0 0 0 0 0 1\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f43\\\">'\\n            '<feFuncA in=\\\"f43\\\" type=\\\"discrete\\\" tableValues=\\\"1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer result=\\\"f48\\\">'\\n            '<feFuncA type=\\\"table\\\" tableValues=\\\"0 0 0 0 0 0 0 1\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f43\\\">'\\n            '<feFuncA in=\\\"f43\\\" type=\\\"discrete\\\" tableValues=\\\"1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer result=\\\"f49\\\">'\\n            '<feFuncA type=\\\"table\\\" tableValues=\\\"0 0 0 0 0 0 0 1\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f43\\\">'\\n            '<feFuncA type=\\\"discrete\\\" tableValues=\\\"0 0 1 1 1 1 1\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer result=\\\"f50\\\">'\\n            '<feFuncA type=\\\"table\\\" tableValues=\\\"0 0 0 0 0 0 1\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feColorMatrix in=\\\"SourceGraphic\\\" type=\\\"luminanceToAlpha\\\" result=\\\"neg-lum-map\\\"/>'\\n            '<feComponentTransfer result=\\\"f51\\\">'\\n            '<feFuncA type=\\\"table\\\" tableValues=\\\"1 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f51\\\" result=\\\"f52\\\">'\\n            '<feFuncA type=\\\"discrete\\\" tableValues=\\\"0 1 0 0 0 0 0 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f51\\\" result=\\\"f53\\\">'\\n            '<feFuncA type=\\\"discrete\\\" tableValues=\\\"0 0 1 0 0 0 0 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f51\\\" result=\\\"f54\\\">'\\n            '<feFuncA type=\\\"discrete\\\" tableValues=\\\"0 0 0 1 0 0 0 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f51\\\" result=\\\"f55\\\">'\\n            '<feFuncA type=\\\"discrete\\\" tableValues=\\\"0 0 0 0 1 0 0 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f51\\\" result=\\\"f56\\\">'\\n            '<feFuncA type=\\\"discrete\\\" tableValues=\\\"0 0 0 0 0 1 0 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f51\\\" result=\\\"f57\\\">'\\n            '<feFuncA type=\\\"discrete\\\" tableValues=\\\"0 0 0 0 0 0 1 0\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComponentTransfer in=\\\"f51\\\" result=\\\"f58\\\">'\\n            '<feFuncA type=\\\"discrete\\\" tableValues=\\\"0 0 0 0 0 0 0 1\\\"/>'\\n            '</feComponentTransfer>'\\n            '<feComposite operator=\\\"in\\\" in=\\\"f52\\\" in2=\\\"f44\\\" result=\\\"f59\\\"/>'\\n            '<feComposite operator=\\\"in\\\" in=\\\"f53\\\" in2=\\\"f45\\\" result=\\\"f60\\\"/>'\\n            '<feComposite operator=\\\"in\\\" in=\\\"f54\\\" in2=\\\"f46\\\" result=\\\"f61\\\"/>'\\n            '<feComposite operator=\\\"in\\\" in=\\\"f55\\\" in2=\\\"f47\\\" result=\\\"f62\\\"/>'\\n            '<feComposite operator=\\\"in\\\" in=\\\"f56\\\" in2=\\\"f48\\\" result=\\\"f63\\\"/>'\\n            '<feComposite operator=\\\"in\\\" in=\\\"f57\\\" in2=\\\"f49\\\" result=\\\"f64\\\"/>'\\n            '<feComposite operator=\\\"in\\\" in=\\\"f58\\\" in2=\\\"f50\\\" result=\\\"f65\\\"/>'\\n            '<feMerge>'\\n            '<feMergeNode in=\\\"f65\\\"/>'\\n            '<feMergeNode in=\\\"f64\\\"/>'\\n            '<feMergeNode in=\\\"f63\\\"/>'\\n            '<feMergeNode in=\\\"f62\\\"/>'\\n            '<feMergeNode in=\\\"f61\\\"/>'\\n            '<feMergeNode in=\\\"f60\\\"/>'\\n            '<feMergeNode in=\\\"f59\\\"/>'\\n            '</feMerge>'\\n            '<feComposite operator=\\\"in\\\" in2=\\\"SourceGraphic\\\"/>'\\n            '</filter>');\\n        return result;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"erc721a/=node_modules/erc721a/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"inliner\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true,\r\n          \"optimizerSteps\": \"[fv][edjr]T[secxL]d[fv][edjr]T[secxL]d\"\r\n        }\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IFilters\",\"name\":\"_filters\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"renderAsSvg\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"renderAsSvgAndAttributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"attributes\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AlienRunesGenerator", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000e692a9ed3d01bd78d53dccb90366da614ff7720e", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}