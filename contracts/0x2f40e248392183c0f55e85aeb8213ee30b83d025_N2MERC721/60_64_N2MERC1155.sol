/** ---------------------------------------------------------------------------- //
 *                                                                               //
 *                                       .:::.                                   //
 *                                    .:::::::.                                  //
 *                                    ::::::::.                                  //
 *                                 .:::::::::.                                   //
 *                             ..:::.              ..                            //
 *                          .::::.                 ::::..                        //
 *                      ..:::..                    ::::::::.                     //
 *                   .::::.                        :::.  ..:::.                  //
 *               ..:::..                           :::.      .:::.               //
 *            .::::.                               :::.         .:::..           //
 *         .:::..               ..                 :::.            .::::.        //
 *     .::::.               ..:::=-                ::::               ..:::.     //
 *    :::.               .:::::::===:              ::::::.               .::::   //
 *   .::.            .:::::::::::=====.            ::::::::::.             .::.  //
 *   .::         .:::::::::::::::=======.          :::::::::::::..          ::.  //
 *   .::        .::::::::::::::::========-         :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==========:       :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::============:     :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==============.   :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::===============-. :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::=================::::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==================-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==================-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==================-::::::::::::::::        ::.  //
 *   .::        .:::::::::::::::::=================-::::::::::::::::        ::.  //
 *   .::        .:::::::::::::::: .-===============-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::   .==============-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::     :============-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::       :==========-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::        .-========-::::::::::::::::        ::.  //
 *   .::          .::::::::::::::          .=======-::::::::::::::.         ::.  //
 *   .::.             .::::::::::            .=====-::::::::::..            ::.  //
 *    :::..              ..::::::              :===-::::::..              .:::.  //
 *      .:::..               .:::                -=-:::.               .::::.    //
 *         .::::.            .:::                 ..                .::::.       //
 *            .::::.         .:::                               ..:::.           //
 *                .:::.      .:::                            .::::.              //
 *                   .:::..  .:::                        ..:::..                 //
 *                      .::::.:::                     .::::.                     //
 *                         ..::::                 ..:::..                        //
 *                             .:              .::::.                            //
 *                                     :::::.::::.                               //
 *                                    ::::::::.                                  //
 *                                    :::::::.                                   //
 *                                     .::::.                                    //
 *                                                                               //
 *                                                                               //
 *   Smart contract generated by https://nfts2me.com                             //
 *                                                                               //
 *   NFTs2Me. Make an NFT Collection.                                            //
 *   With ZERO Coding Skills.                                                    //
 *                                                                               //
 *   NFTs2Me is not associated or affiliated with this project.                  //
 *   NFTs2Me is not liable for any bugs or issues associated with this contract. //
 *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //
 * ----------------------------------------------------------------------------- */

/// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol";

import "./N2MTokenCommon.sol";

/// @title NFTs2Me.com Smart Contracts for ERC-1155.
/// @author The NFTs2Me Team
/// @notice Read our terms of service
/// @custom:security-contact [emailÂ protected]
/// @custom:terms-of-service https://nfts2me.com/terms-of-service/
/// @custom:website https://nfts2me.com/
contract N2MERC1155 is
    N2MTokenCommon,
    ERC1155Upgradeable,
    ERC1155SupplyUpgradeable
{
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor(address libraryAddress, address payable factoryAddress) N2MTokenCommon(libraryAddress, factoryAddress) {}

    string private _name;
    string public override symbol;

    mapping(address => uint256) private _balances;

    /// @notice To be called to create the collection. Can only be called once.
    function initialize(
        string memory tokenName,
        string memory tokenSymbol,
        uint256 iMintPrice,
        bytes32 baseURICIDHash,
        bytes32 placeholderImageCIDHash,
        RevenueAddress[] calldata revenueAddresses,
        address iErc20PaymentAddress,
        uint32 iTotalSupply,
        uint16 iRoyaltyFee,
        bool soulboundCollection,
        MintingType iMintingType
    ) public payable override initializer {

        _name = tokenName;
        symbol = tokenSymbol;

        if (iTotalSupply == 0) revert TotalSupplyMustBeGreaterThanZero();
        if (baseURICIDHash != 0 && placeholderImageCIDHash != 0) revert CantSetBaseURIAndPlaceholderAtTheSameTime();
        if (iRoyaltyFee > 10_00) revert RoyaltyFeeTooHigh();

        _collectionSize = iTotalSupply;
        if (baseURICIDHash == 0) {
            if (placeholderImageCIDHash == 0) {
                if (iMintingType != MintingType.CUSTOM_URI)
                    revert NoBaseURINorPlaceholderSet();
            } else {
                _placeholderImageCIDHash = placeholderImageCIDHash;
            }
        } else {
            _baseURICIDHash = baseURICIDHash;
        }

        _mintPrice = iMintPrice;
        _royaltyFee = iRoyaltyFee;
        if (iMintingType != MintingType.SEQUENTIAL) {
            _mintingType = iMintingType;
        }
        if (iErc20PaymentAddress != address(0)) {
            _isERC20Payment = true;
            _erc20PaymentAddress = iErc20PaymentAddress;
        }
        if (soulboundCollection == true) {
            _soulboundCollection = true;
        }

        if (revenueAddresses.length > 0) {
            uint256 revenuePercentageTotal;
            for (uint256 i; i < revenueAddresses.length; ) {
                revenuePercentageTotal += revenueAddresses[i].percentage;
                unchecked {
                    ++i;
                }
            }
            _revenueInfo = revenueAddresses;
            if (revenuePercentageTotal > 100_00 - N2M_FEE) revert InvalidRevenuePercentage();
        }

    }

    /// @notice alias for `uri`
    function tokenURI(uint256 tokenId)
        public
        view
        override
        returns (string memory)
    {
        return uri(tokenId);
    }

    /// @notice tokenURI of the given token
    /// @param tokenId of the token to ask for
    /// @return tokenURI for `tokenId`
    function uri(uint256 tokenId)
        public
        view
        override(ERC1155Upgradeable)
        returns (string memory)
    {
        return IN2MLibrary(address(this)).tokenURIImpl(tokenId);
    }

    function _exists(uint256 tokenId) internal view override returns (bool) {
        return exists(tokenId);
    }

    function _mint(address to, uint256 tokenId) internal override {
        super._mint(to, tokenId, 1, "");
    }

    /// @notice Collection name
    /// @return the collection name
    function name() public view override returns (string memory) {
        return _name;
    }

    /// @notice Balance of a given address for ERC-1155 (non-standard).
    /// @param owner to ask for the balance
    /// @return balance of the `owner`
    function balanceOf(address owner) public view override returns (uint256 balance) {
        if (owner == address(0)) revert();
        balance = _balances[owner];
        if (_mintingType == MintingType.RANDOM) {
            balance += _randomTickets[owner].amount;
        }
    }

    function _mintSequential(address to, uint256 amount) internal override {
        if (amount == 1) {
            unchecked {
                _mint(to, ++_soldTokens, 1, "");
            }
        } else {
            uint256[] memory ids = new uint256[](amount);
            uint256[] memory amounts = new uint256[](amount);

            for (uint256 i; i < amount; ) {
                unchecked {
                    ids[i] = ++_soldTokens;
                    amounts[i] = 1;
                    ++i;
                }
            }

            _mintBatch(to, ids, amounts, "");
        }
    }

    function _mintSpecify(address to, uint256[] memory tokenIds)
        internal
        override
    {
        uint32 amount = uint32(tokenIds.length);
        _soldTokens += amount;
        uint256[] memory amounts = new uint256[](amount);

        for (uint256 i; i < amount; ) {
            uint256 tokenId = tokenIds[i];
            amounts[i] = 1;
            if (_exists(tokenId)) revert TokenAlreadyMinted();
            if (tokenId <= 0 || tokenId > _collectionSize) revert InvalidTokenId();
            unchecked {
                ++i;
            }
        }
        _mintBatch(to, tokenIds, amounts, "");
    }

    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal override(ERC1155Upgradeable, ERC1155SupplyUpgradeable) {
        uint256 length = ids.length;
        for (uint256 i; i < length; ) {

            if (from != address(0)) {
                if (_soulbound[ids[i]] || _soulboundCollection) revert NonTransferrableSoulboundNFT();

                _balances[from] -= amounts[i];
            }

            if (to != address(0)) {

                _balances[to] += amounts[i];
            }

            unchecked {
                ++i;
            }
        }

        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);

        if (_maxPerAddress != 0) {

            if (balanceOf(to) > _maxPerAddress) revert MaxPerAddressExceeded();
        } 
    }

    /// @notice Query if a contract implements an interface
    /// @param interfaceId The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceId` and `interfaceId` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC1155Upgradeable, IERC165Upgradeable)
        returns (bool)
    {
        return (

        interfaceId == type(IERC2981Upgradeable).interfaceId || super.supportsInterface(interfaceId));
    }

    /// @notice Enable or disable approval for a third party ("operator") to manage all of the caller's tokens.
    /// @dev MUST emit the ApprovalForAll event on success.
    /// @param operator  Address to add to the set of authorized operators
    /// @param approved  True if the operator is approved, false to revoke approval
    function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {
        super.setApprovalForAll(operator, approved);
    }    

    /// @notice Queries the approval status of an operator for a given owner.
    /// @param owner     The owner of the tokens
    /// @param operator  Address of authorized operator
    /// @return          True if the operator is approved, false if not
    function isApprovedForAll(address owner, address operator)
    public
    view
    virtual
    override
    returns (bool)
    {

        if (operator == N2M_CONDUIT) return true;
        if (operator == OPENSEA_CONDUIT) return true;

        return super.isApprovedForAll(owner, operator);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public override onlyAllowedOperator() {
        super.safeTransferFrom(from, to, id, amount, data);
    }

    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public override onlyAllowedOperator() {
        super.safeBatchTransferFrom(from, to, ids, amounts, data);
    }

    // ////////

    // ////////

    function getSupplies(uint256 startId, uint256 endId)
        external
        view
        returns (
            uint256[] memory supplies,
            uint256 blockNumber,
            uint256 blockTimestamp
        )
    {
        blockNumber = block.number;
        blockTimestamp = block.timestamp;

        if (endId >= startId) {
            uint256 total = 1 + endId - startId;
            unchecked {
                supplies = new uint256[](total);
                for (uint256 i; i < total; i++) {
                    supplies[i] = totalSupply(startId + i);
                }
            }
        } else {
            uint256[] memory emptyArray;
            supplies = emptyArray;
        }
    }     

}