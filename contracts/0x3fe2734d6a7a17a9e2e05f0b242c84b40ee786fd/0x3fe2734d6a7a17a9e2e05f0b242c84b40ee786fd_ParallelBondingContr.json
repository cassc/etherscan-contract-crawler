{"SourceCode": "// File contracts/libraries/SafeMath.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function sqrrt(uint256 a) internal pure returns (uint c) {\r\n        if (a > 3) {\r\n            c = a;\r\n            uint b = add( div( a, 2), 1 );\r\n            while (b < c) {\r\n                c = b;\r\n                b = div( add( div( a, b ), b), 2 );\r\n            }\r\n        } else if (a != 0) {\r\n            c = 1;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/Address.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addressToString(address _address) internal pure returns(string memory) {\r\n        bytes32 _bytes = bytes32(uint256(_address));\r\n        bytes memory HEX = \"0123456789abcdef\";\r\n        bytes memory _addr = new bytes(42);\r\n\r\n        _addr[0] = '0';\r\n        _addr[1] = 'x';\r\n\r\n        for(uint256 i = 0; i < 20; i++) {\r\n            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\r\n            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\r\n        }\r\n\r\n        return string(_addr);\r\n\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC20.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/libraries/SafeERC20.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC165.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.7.5;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/mocks/ERC165.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.7.5;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC1155.sol\r\n\r\npragma solidity ^0.7.5;\r\n\r\n/**\r\n    @title ERC-1155 Multi Token Standard\r\n    @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md\r\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\r\n */\r\ninterface IERC1155 /* is ERC165 */ {\r\n    /**\r\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\r\n        The `_operator` argument MUST be msg.sender.\r\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\r\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\r\n        The `_id` argument MUST be the token type being transferred.\r\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\r\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\r\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\r\n    */\r\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\r\n\r\n    /**\r\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\r\n        The `_operator` argument MUST be msg.sender.\r\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\r\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\r\n        The `_ids` argument MUST be the list of tokens being transferred.\r\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\r\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\r\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\r\n    */\r\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\r\n\r\n    /**\r\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absense of an event assumes disabled).\r\n    */\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /**\r\n        @dev MUST emit when the URI is updated for a token ID.\r\n        URIs are defined in RFC 3986.\r\n        The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\r\n    */\r\n    event URI(string _value, uint256 indexed _id);\r\n\r\n    /**\r\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\r\n        MUST revert on any other error.\r\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\r\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\r\n        @param _from    Source address\r\n        @param _to      Target address\r\n        @param _id      ID of the token type\r\n        @param _value   Transfer amount\r\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\r\n    */\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if length of `_ids` is not the same as length of `_values`.\r\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\r\n        MUST revert on any other error.\r\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\r\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\r\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\r\n        @param _from    Source address\r\n        @param _to      Target address\r\n        @param _ids     IDs of each token type (order and length must match _values array)\r\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\r\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\r\n    */\r\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\r\n\r\n    /**\r\n        @notice Get the balance of an account's Tokens.\r\n        @param _owner  The address of the token holder\r\n        @param _id     ID of the Token\r\n        @return        The _owner's balance of the Token type requested\r\n     */\r\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the balance of multiple account/token pairs\r\n        @param _owners The addresses of the token holders\r\n        @param _ids    ID of the Tokens\r\n        @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\r\n     */\r\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\r\n\r\n    /**\r\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\r\n        @dev MUST emit the ApprovalForAll event on success.\r\n        @param _operator  Address to add to the set of authorized operators\r\n        @param _approved  True if the operator is approved, false to revoke approval\r\n    */\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /**\r\n        @notice Queries the approval status of an operator for a given owner.\r\n        @param _owner     The owner of the Tokens\r\n        @param _operator  Address of authorized operator\r\n        @return           True if the operator is approved, false if not\r\n    */\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/OP1155/IParagonBondingTreasury.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\ninterface IParagonBondingTreasury {\r\n    function sendPDT(uint _amountPayoutToken) external;\r\n    function valueOfToken( address _principalToken, uint _amount ) external view returns ( uint value_ );\r\n    function PDT() external view returns (address);\r\n}\r\n\r\n\r\n// File contracts/types/Ownable.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\ncontract Ownable {\r\n\r\n    address public policy;\r\n\r\n    constructor () {\r\n        policy = msg.sender;\r\n    }\r\n\r\n    modifier onlyPolicy() {\r\n        require( policy == msg.sender, \"Ownable: caller is not the owner\" );\r\n        _;\r\n    }\r\n    \r\n    function transferManagment(address _newOwner) external onlyPolicy() {\r\n        require( _newOwner != address(0) );\r\n        policy = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/OP1155/ParallelBondingContract.sol\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity 0.7.5;\r\n\r\n\r\n\r\n\r\n/// @title   Parallel Bonding Contract\r\n/// @author  JeffX\r\n/// @notice  Bonding Parallel ERC1155s in return for PDT tokens\r\ncontract ParallelBondingContract is Ownable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint;\r\n\r\n    \r\n    /// EVENTS ///\r\n\r\n    /// @notice Emitted when A bond is created\r\n    /// @param deposit Address of where bond is deposited to\r\n    /// @param payout Amount of PDT to be paid out\r\n    /// @param expires Block number bond will be fully redeemable\r\n    event BondCreated( uint deposit, uint payout, uint expires );\r\n\r\n    /// @notice Emitted when a bond is redeemed\r\n    /// @param recipient Address receiving PDT\r\n    /// @param payout Amount of PDT redeemed\r\n    /// @param remaining Amount of PDT left to be paid out\r\n    event BondRedeemed( address recipient, uint payout, uint remaining );\r\n\r\n    \r\n    /// STATE VARIABLES ///\r\n    \r\n    /// @notice Paragon DAO Token\r\n    IERC20 immutable public PDT;\r\n    /// @notice Parallel ERC1155\r\n    IERC1155 immutable public LL;\r\n    /// @notice Custom Treasury\r\n    IParagonBondingTreasury immutable public customTreasury;\r\n    /// @notice Olympus DAO address\r\n    address immutable public olympusDAO;\r\n    /// @notice Olympus treasury address\r\n    address public olympusTreasury;\r\n\r\n    /// @notice Total Parallel tokens that have been bonded\r\n    uint public totalPrincipalBonded;\r\n    /// @notice Total PDT tokens given as payout\r\n    uint public totalPayoutGiven;\r\n    /// @notice Vesting term in blocks\r\n    uint public vestingTerm;\r\n    /// @notice Percent fee that goes to Olympus\r\n    uint public immutable olympusFee = 33300;\r\n\r\n    /// @notice Array of IDs that have been bondable\r\n    uint[] public bondedIds;\r\n\r\n    /// @notice Bool if bond contract has been initialized\r\n    bool public initialized;\r\n\r\n    /// @notice Stores bond information for depositors\r\n    mapping( address => Bond ) public bondInfo;\r\n\r\n    /// @notice Stores bond information for a Parallel ID\r\n    mapping( uint => IdDetails ) public idDetails;\r\n\r\n    \r\n    /// STRUCTS ///\r\n\r\n    /// @notice           Details of an addresses current bond\r\n    /// @param payout     PDT tokens remaining to be paid\r\n    /// @param vesting    Blocks left to vest\r\n    /// @param lastBlock  Last interaction\r\n    struct Bond {\r\n        uint payout;\r\n        uint vesting;\r\n        uint lastBlock;\r\n    }\r\n\r\n    /// @notice                   Details of an ID that is to be bonded\r\n    /// @param bondPrice          Payout price of the ID\r\n    /// @param remainingToBeSold  Remaining amount of tokens that can be bonded\r\n    /// @param inArray            Bool if ID is in array that keeps track of IDs\r\n    struct IdDetails {\r\n        uint bondPrice;\r\n        uint remainingToBeSold;\r\n        bool inArray;\r\n    }\r\n\r\n    \r\n    /// CONSTRUCTOR ///\r\n\r\n    /// @param _customTreasury   Address of cusotm treasury\r\n    /// @param _LL               Address of the Parallel token\r\n    /// @param _olympusTreasury  Address of the Olympus treasury\r\n    /// @param _initialOwner     Address of the initial owner\r\n    /// @param _olympusDAO       Address of Olympus DAO\r\n    constructor(\r\n        address _customTreasury, \r\n        address _LL, \r\n        address _olympusTreasury,\r\n        address _initialOwner, \r\n        address _olympusDAO\r\n    ) {\r\n        require( _customTreasury != address(0) );\r\n        customTreasury = IParagonBondingTreasury( _customTreasury );\r\n        PDT = IERC20( IParagonBondingTreasury(_customTreasury).PDT() );\r\n        require( _LL != address(0) );\r\n        LL = IERC1155( _LL );\r\n        require( _olympusTreasury != address(0) );\r\n        olympusTreasury = _olympusTreasury;\r\n        require( _initialOwner != address(0) );\r\n        policy = _initialOwner;\r\n        require( _olympusDAO != address(0) );\r\n        olympusDAO = _olympusDAO;\r\n    }\r\n\r\n\r\n    /// POLICY FUNCTIONS ///\r\n\r\n    /// @notice              Initializes bond and sets vesting rate\r\n    /// @param _vestingTerm  Vesting term in blocks\r\n    function initializeBond(uint _vestingTerm) external onlyPolicy() {\r\n        require(!initialized, \"Already initialized\");\r\n        vestingTerm = _vestingTerm;\r\n        initialized = true;\r\n    }\r\n\r\n    /// @notice          Updates current vesting term\r\n    /// @param _vesting  New vesting in blocks\r\n    function setVesting( uint _vesting ) external onlyPolicy() {\r\n        require(initialized, \"Not initalized\");\r\n        vestingTerm = _vesting;\r\n    }\r\n\r\n    /// @notice           Set bond price and how many to be sold for each ID\r\n    /// @param _ids       Array of IDs that will be sold\r\n    /// @param _prices    PDT given to bond correspond ID in `_ids`\r\n    /// @param _toBeSold  Number of IDs looking to be acquired\r\n    function setIdDetails(uint[] calldata _ids, uint[] calldata _prices, uint _toBeSold) external onlyPolicy() {\r\n        require(_ids.length == _prices.length, \"Lengths do not match\");\r\n        for(uint i; i < _ids.length; i++) {\r\n            IdDetails memory idDetail = idDetails[_ids[i]];\r\n            idDetail.bondPrice = _prices[i];\r\n            idDetail.remainingToBeSold = _toBeSold;\r\n            if(!idDetail.inArray) {\r\n                bondedIds.push(_ids[i]);\r\n                idDetail.inArray = true;\r\n            }\r\n            idDetails[_ids[i]] = idDetail;\r\n\r\n        }\r\n    }\r\n\r\n    /// @notice                  Updates address to send Olympus fee to\r\n    /// @param _olympusTreasury  Address of new Olympus treasury\r\n    function changeOlympusTreasury(address _olympusTreasury) external {\r\n        require( msg.sender == olympusDAO, \"Only Olympus DAO\" );\r\n        olympusTreasury = _olympusTreasury;\r\n    }\r\n\r\n    /// USER FUNCTIONS ///\r\n    \r\n    /// @notice            Bond Parallel ERC1155 to get PDT tokens\r\n    /// @param _id         ID number that is being bonded\r\n    /// @param _amount     Amount of sepcific `_id` to bond\r\n    /// @param _depositor  Address that PDT tokens will be redeemable for\r\n    function deposit(uint _id, uint _amount, address _depositor) external returns (uint) {\r\n        require(initialized, \"Not initalized\");\r\n        require( idDetails[_id].bondPrice > 0 && idDetails[_id].remainingToBeSold >= _amount, \"Not bondable\");\r\n        require( _amount > 0, \"Cannot bond 0\" );\r\n        require( _depositor != address(0), \"Invalid address\" );\r\n\r\n        uint payout;\r\n        uint fee;\r\n\r\n        (payout, fee) = payoutFor( _id ); // payout and fee is computed\r\n\r\n        payout = payout.mul(_amount);\r\n        fee = fee.mul(_amount);\r\n                \r\n        // depositor info is stored\r\n        bondInfo[ _depositor ] = Bond({ \r\n            payout: bondInfo[ _depositor ].payout.add( payout ),\r\n            vesting: vestingTerm,\r\n            lastBlock: block.number\r\n        });\r\n\r\n        idDetails[_id].remainingToBeSold = idDetails[_id].remainingToBeSold.sub(_amount);\r\n\r\n        totalPrincipalBonded = totalPrincipalBonded.add(_amount); // total bonded increased\r\n        totalPayoutGiven = totalPayoutGiven.add(payout); // total payout increased\r\n\r\n        customTreasury.sendPDT( payout.add(fee) );\r\n\r\n        PDT.safeTransfer(olympusTreasury, fee);\r\n\r\n        LL.safeTransferFrom( msg.sender, address(customTreasury), _id, _amount, \"\" ); // transfer principal bonded to custom treasury\r\n\r\n        // indexed events are emitted\r\n        emit BondCreated( _id, payout, block.number.add( vestingTerm ) );\r\n\r\n        return payout; \r\n    }\r\n    \r\n    /// @notice            Redeem bond for `depositor`\r\n    /// @param _depositor  Address of depositor being redeemed\r\n    /// @return            Amount of PDT redeemed\r\n    function redeem(address _depositor) external returns (uint) {\r\n        Bond memory info = bondInfo[ _depositor ];\r\n        uint percentVested = percentVestedFor( _depositor ); // (blocks since last interaction / vesting term remaining)\r\n\r\n        if ( percentVested >= 10000 ) { // if fully vested\r\n            delete bondInfo[ _depositor ]; // delete user info\r\n            emit BondRedeemed( _depositor, info.payout, 0 ); // emit bond data\r\n            PDT.safeTransfer( _depositor, info.payout );\r\n            return info.payout;\r\n\r\n        } else { // if unfinished\r\n            // calculate payout vested\r\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\r\n\r\n            // store updated deposit info\r\n            bondInfo[ _depositor ] = Bond({\r\n                payout: info.payout.sub( payout ),\r\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\r\n                lastBlock: block.number\r\n            });\r\n\r\n            emit BondRedeemed( _depositor, payout, bondInfo[ _depositor ].payout );\r\n            PDT.safeTransfer( _depositor, payout );\r\n            return payout;\r\n        }\r\n        \r\n    }\r\n\r\n    /// VIEW FUNCTIONS ///\r\n    \r\n    /// @notice          Payout and fee for a specific bond ID\r\n    /// @param _id       ID to get payout and fee for\r\n    /// @return payout_  Amount of PDT user will recieve for bonding `_id`\r\n    /// @return fee_     Amount of PDT Olympus will recieve for the bonding of `_id`\r\n    function payoutFor( uint _id ) public view returns ( uint payout_, uint fee_) {\r\n        uint price = idDetails[_id].bondPrice;\r\n        fee_ = price.mul( olympusFee ).div( 1e6 );\r\n        payout_ = price.sub(fee_);\r\n    }\r\n\r\n    /// @notice                 Calculate how far into vesting `_depositor` is\r\n    /// @param _depositor       Address of depositor\r\n    /// @return percentVested_  Percent `_depositor` is into vesting\r\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\r\n        Bond memory bond = bondInfo[ _depositor ];\r\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\r\n        uint vesting = bond.vesting;\r\n\r\n        if ( vesting > 0 ) {\r\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\r\n        } else {\r\n            percentVested_ = 0;\r\n        }\r\n    }\r\n\r\n    /// @notice                 Calculate amount of payout token available for claim by `_depositor`\r\n    /// @param _depositor       Address of depositor\r\n    /// @return pendingPayout_  Pending payout for `_depositor`\r\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\r\n        uint percentVested = percentVestedFor( _depositor );\r\n        uint payout = bondInfo[ _depositor ].payout;\r\n\r\n        if ( percentVested >= 10000 ) {\r\n            pendingPayout_ = payout;\r\n        } else {\r\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\r\n        }\r\n    }\r\n\r\n    /// @notice  Returns all the ids that are bondable and the amounts that can be bonded for each\r\n    /// @return  Array of all IDs that are bondable\r\n    /// @return  Array of amount remaining to be bonded for each bondable ID\r\n    function bondableIds() external view returns (uint[] memory, uint[] memory) {\r\n        uint numberOfBondable;\r\n\r\n        for(uint i = 0; i < bondedIds.length; i++) {\r\n            uint id = bondedIds[i];\r\n            (bool active,) = canBeBonded(id);\r\n            if(active) numberOfBondable++;\r\n        }\r\n\r\n        uint256[] memory ids = new uint256[](numberOfBondable);\r\n        uint256[] memory leftToBond = new uint256[](numberOfBondable);\r\n\r\n        uint nonce;\r\n        for(uint i = 0; i < bondedIds.length; i++) {\r\n            uint id = bondedIds[i];\r\n            (bool active, uint amount) = canBeBonded(id);\r\n            if(active) {\r\n                ids[nonce] = id;\r\n                leftToBond[nonce] = amount;\r\n                nonce++;\r\n            }\r\n        }\r\n\r\n        return (ids, leftToBond);\r\n    }\r\n\r\n    /// @notice     Determines if `_id` can be bonded, and if so how much is left\r\n    /// @param _id  ID to check if can be bonded\r\n    /// @return     Bool if `_id` can be bonded\r\n    /// @return     Amount of tokens that be bonded for `_id`\r\n    function canBeBonded(uint _id) public view returns (bool, uint) {\r\n        IdDetails memory idDetail = idDetails[_id];\r\n        if(idDetail.bondPrice > 0 && idDetail.remainingToBeSold > 0) {\r\n            return (true, idDetail.remainingToBeSold);\r\n        } else {\r\n            return (false, 0);\r\n        }\r\n    }\r\n\r\n    \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_LL\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_olympusTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_initialOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_olympusDAO\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"}],\"name\":\"BondCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"name\":\"BondRedeemed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LL\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bondInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondableIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bondedIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"canBeBonded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_olympusTreasury\",\"type\":\"address\"}],\"name\":\"changeOlympusTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customTreasury\",\"outputs\":[{\"internalType\":\"contract IParagonBondingTreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bondPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingToBeSold\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"inArray\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vestingTerm\",\"type\":\"uint256\"}],\"name\":\"initializeBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"olympusDAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"olympusFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"olympusTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"payoutFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"pendingPayoutFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingPayout_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"percentVestedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percentVested_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_toBeSold\",\"type\":\"uint256\"}],\"name\":\"setIdDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vesting\",\"type\":\"uint256\"}],\"name\":\"setVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayoutGiven\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPrincipalBonded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferManagment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingTerm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ParallelBondingContract", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a9ab2478531dcc5597a91413b39d462b3413e47c00000000000000000000000076be3b62873462d2142405439777e971754e8e770000000000000000000000009a315bdf513367c0377fb36545857d12e85813ef00000000000000000000000012267aefd8bb461817df348ce16c933e76c1aa0d000000000000000000000000245cc372c84b3645bf0ffe6538620b04a217988b", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ec251c7447b645f5dfeb8f8b426504a9db90aede2ca0e8dd94114ef72f514706"}