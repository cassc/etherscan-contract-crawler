{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/lib/loans/MultiSourceLoan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"@delegate/IDelegateRegistry.sol\\\";\\nimport \\\"@solmate/tokens/ERC20.sol\\\";\\nimport \\\"@solmate/tokens/ERC721.sol\\\";\\nimport \\\"@solmate/utils/FixedPointMathLib.sol\\\";\\nimport \\\"@solmate/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@solmate/utils/SafeTransferLib.sol\\\";\\n\\nimport \\\"../../interfaces/INFTFlashAction.sol\\\";\\nimport \\\"../../interfaces/loans/IMultiSourceLoan.sol\\\";\\nimport \\\"../../interfaces/ILoanLiquidator.sol\\\";\\nimport \\\"../utils/Hash.sol\\\";\\nimport \\\"../utils/Interest.sol\\\";\\nimport \\\"../Multicall.sol\\\";\\nimport \\\"./WithCallbacks.sol\\\";\\n\\ncontract MultiSourceLoan is IMultiSourceLoan, Multicall, ReentrancyGuard, WithCallbacks {\\n    using FixedPointMathLib for uint256;\\n    using Hash for Loan;\\n    using Hash for SignableRepaymentData;\\n    using Hash for RenegotiationOffer;\\n    using Interest for uint256;\\n    using MessageHashUtils for bytes32;\\n    using SafeTransferLib for ERC20;\\n\\n    /// @notice Loan Id to hash\\n    mapping(uint256 => bytes32) private _loans;\\n\\n    /// @notice Maximum number of sources per loan\\n    uint256 private _maxSources;\\n\\n    /// @notice Min lock period for a source\\n    uint256 private _minLockPeriod;\\n\\n    /// @notice If we have N max sources, then the min principal of any given source\\n    /// at the time of repayment needs to be Total Principal / (N * _MAX_RATIO_SOURCE_MIN_PRINCIPAL)\\n    /// This is captured in _getMinSourcePrincipal.\\n    uint256 private constant _MAX_RATIO_SOURCE_MIN_PRINCIPAL = 2;\\n\\n    /// @notice delegate registry\\n    IDelegateRegistry private _delegateRegistry;\\n\\n    /// @notice Contract to execute flash actions.\\n    INFTFlashAction private _flashActionContract;\\n\\n    event MaxSourcesUpdated(uint256 newMax);\\n\\n    event LoanEmitted(uint256 loanId, uint256 offerId, Loan loan, address lender, address borrower, uint256 fee);\\n\\n    event LoanRefinanced(uint256 renegotiationId, uint256 oldLoanId, uint256 newLoanId, Loan loan, uint256 fee);\\n\\n    event LoanRepaid(uint256 loanId, uint256 totalRepayment, uint256 fee);\\n\\n    event DelegateRegistryUpdated(address newdelegateRegistry);\\n\\n    event Delegated(uint256 loanId, address delegate, bool value);\\n\\n    event FlashActionContractUpdated(address newFlashActionContract);\\n\\n    event FlashActionExecuted(uint256 loanId, address target, bytes data);\\n\\n    event RevokeDelegate(address delegate, address collection, uint256 tokenId);\\n\\n    event LoanExtended(uint256 oldLoanId, uint256 newLoanId, Loan loan, uint256 _extension);\\n\\n    event MinLockPeriodUpdated(uint256 minLockPeriod);\\n\\n    error InvalidMethodError();\\n\\n    error InvalidRenegotiationOfferError();\\n\\n    error TooManySourcesError(uint256 sources);\\n\\n    error MinLockPeriodTooHighError(uint256 minLockPeriod);\\n\\n    error PartialOfferCannotChangeDurationError();\\n\\n    error PartialOfferCannotHaveFeeError();\\n\\n    error LoanExpiredError();\\n\\n    error RefinanceFullError();\\n\\n    error LengthMismatchError();\\n\\n    error TargetPrincipalTooLowError(uint256 sourcePrincipal, uint256 loanPrincipal);\\n\\n    error NFTNotReturnedError();\\n\\n    error ExtensionNotAvailableError();\\n\\n    error SourceCannotBeRefinancedError(uint256 minTimestamp);\\n\\n    /// @param loanLiquidator Address of the liquidator contract.\\n    /// @param protocolFee Protocol fee charged on gains.\\n    /// @param currencyManager Address of the currency manager.\\n    /// @param collectionManager Address of the collection manager.\\n    /// @param maxSources Maximum number of sources per loan.\\n    /// @param delegateRegistry Address of the delegate registry (Delegate.xyz).\\n    /// @param flashActionContract Address of the flash action contract.\\n    constructor(\\n        address loanLiquidator,\\n        ProtocolFee memory protocolFee,\\n        address currencyManager,\\n        address collectionManager,\\n        uint256 maxSources,\\n        uint256 minLockPeriod,\\n        address delegateRegistry,\\n        address flashActionContract\\n    ) WithCallbacks(\\\"GONDI_MULTI_SOURCE_LOAN\\\", currencyManager, collectionManager) {\\n        _checkAddressNotZero(loanLiquidator);\\n\\n        _loanLiquidator = ILoanLiquidator(loanLiquidator);\\n        _protocolFee = protocolFee;\\n        _maxSources = maxSources;\\n        _minLockPeriod = minLockPeriod;\\n        _delegateRegistry = IDelegateRegistry(delegateRegistry);\\n        _flashActionContract = INFTFlashAction(flashActionContract);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function emitLoan(LoanExecutionData calldata _executionData) external nonReentrant returns (uint256, Loan memory) {\\n        address lender = _executionData.lender;\\n        address borrower = _executionData.borrower;\\n        LoanOffer calldata offer = _executionData.executionData.offer;\\n        address offerer = offer.lender == address(0) ? borrower : lender;\\n        _validateExecutionData(\\n            _executionData.executionData,\\n            lender,\\n            borrower,\\n            offerer,\\n            _executionData.lenderOfferSignature,\\n            _executionData.borrowerOfferSignature\\n        );\\n\\n        uint256 loanId = _getAndSetNewLoanId();\\n        uint256 amount = _executionData.executionData.amount;\\n\\n        Source[] memory source = new Source[](1);\\n        source[0] = Source(loanId, lender, amount, 0, block.timestamp, offer.aprBps);\\n        Loan memory loan = Loan(\\n            borrower,\\n            _executionData.executionData.tokenId,\\n            offer.nftCollateralAddress,\\n            offer.principalAddress,\\n            amount,\\n            block.timestamp,\\n            offer.duration,\\n            source\\n        );\\n\\n        _loans[loanId] = loan.hash();\\n        uint256 fee = offer.fee.mulDivUp(amount, offer.principalAmount);\\n        ProtocolFee memory protocolFee = _protocolFee;\\n        _handleProtocolFeeForFee(\\n            offer.principalAddress, lender, fee.mulDivUp(protocolFee.fraction, _PRECISION), protocolFee\\n        );\\n\\n        ERC20(offer.principalAddress).safeTransferFrom(lender, borrower, amount - fee);\\n\\n        /// @dev After sending the principal to the borrower, check if there's an action to be taken (eg: use it to buy the collateral).\\n        uint128 tax = _handleAfterPrincipalTransferCallback(loan, _executionData.executionData.callbackData, fee);\\n        if (tax > 0) {\\n            uint256 taxCost = amount.mulDivUp(tax, _PRECISION);\\n            uint256 feeTax = taxCost.mulDivUp(protocolFee.fraction, _PRECISION);\\n\\n            ERC20(offer.principalAddress).safeTransferFrom(borrower, lender, taxCost - feeTax);\\n            if (feeTax > 0) {\\n                ERC20(offer.principalAddress).safeTransferFrom(borrower, protocolFee.recipient, feeTax);\\n            }\\n        }\\n\\n        ERC721(offer.nftCollateralAddress).transferFrom(borrower, address(this), _executionData.executionData.tokenId);\\n\\n        emit LoanEmitted(loanId, offer.offerId, loan, lender, borrower, offer.fee);\\n\\n        if (offer.capacity > 0) {\\n            _used[offerer][offer.offerId] += amount;\\n        } else {\\n            isOfferCancelled[offerer][offer.offerId] = true;\\n        }\\n\\n        return (loanId, loan);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function refinanceFull(\\n        RenegotiationOffer calldata _renegotiationOffer,\\n        Loan memory _loan,\\n        bytes calldata _renegotiationOfferSignature\\n    ) external returns (uint256, Loan memory) {\\n        uint256 loanId = _renegotiationOffer.loanId;\\n        address sender = msg.sender;\\n        bool clearsInterest = false;\\n\\n        _baseLoanChecks(loanId, _loan);\\n\\n        _baseRenegotiationChecks(_renegotiationOffer, _loan);\\n\\n        bool strictImprovement = msg.sender == _renegotiationOffer.lender;\\n\\n        (uint256 totalDelta, uint256 totalAccruedInterest, uint256 totalNewSources, uint256 totalAnnualInterest) =\\n            _processOldSources(_renegotiationOffer, _loan, strictImprovement);\\n        if (totalNewSources > 1) {\\n            revert RefinanceFullError();\\n        }\\n        /// @dev If it's lender initiated, needs to be strictly better.\\n        if (strictImprovement) {\\n            _checkStrictlyBetter(\\n                _renegotiationOffer.principalAmount,\\n                totalDelta,\\n                _renegotiationOffer.duration + block.timestamp,\\n                _loan.duration + _loan.startTime,\\n                _renegotiationOffer.aprBps,\\n                totalAnnualInterest / _loan.principalAmount,\\n                _renegotiationOffer.fee\\n            );\\n        } else if (sender != _loan.borrower) {\\n            revert OnlyLenderOrBorrowerCallableError();\\n        } else {\\n            clearsInterest = true;\\n            _checkSignature(_renegotiationOffer.lender, _renegotiationOffer.hash(), _renegotiationOfferSignature);\\n        }\\n\\n        uint256 netNewLender = _renegotiationOffer.principalAmount - _renegotiationOffer.fee;\\n\\n        if (clearsInterest) {\\n            netNewLender -= totalAccruedInterest;\\n            totalAccruedInterest = 0;\\n        }\\n\\n        if (totalDelta > netNewLender) {\\n            ERC20(_loan.principalAddress).safeTransferFrom(\\n                _loan.borrower, _renegotiationOffer.lender, totalDelta - netNewLender\\n            );\\n        } else if (totalDelta < netNewLender) {\\n            ERC20(_loan.principalAddress).safeTransferFrom(\\n                _renegotiationOffer.lender, _loan.borrower, netNewLender - totalDelta\\n            );\\n        }\\n\\n        uint256 newLoanId = _getAndSetNewLoanId();\\n        Source[] memory newSources = new Source[](1);\\n\\n        newSources[0] = _getSourceFromOffer(_renegotiationOffer, totalAccruedInterest, newLoanId);\\n        _loan.source = newSources;\\n        _loan.duration = (block.timestamp - _loan.startTime) + _renegotiationOffer.duration;\\n        _loan.principalAmount = _renegotiationOffer.principalAmount;\\n\\n        _loans[newLoanId] = _loan.hash();\\n        delete _loans[loanId];\\n\\n        emit LoanRefinanced(_renegotiationOffer.renegotiationId, loanId, newLoanId, _loan, _renegotiationOffer.fee);\\n\\n        return (newLoanId, _loan);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function refinancePartial(RenegotiationOffer calldata _renegotiationOffer, Loan memory _loan)\\n        external\\n        returns (uint256, Loan memory)\\n    {\\n        uint256 loanId = _renegotiationOffer.loanId;\\n        if (_renegotiationOffer.principalAmount < _getMinSourcePrincipal(_loan.principalAmount)) {\\n            revert TargetPrincipalTooLowError(_renegotiationOffer.principalAmount, _loan.principalAmount);\\n        }\\n        if (msg.sender != _renegotiationOffer.lender) {\\n            revert OnlyLenderCallableError();\\n        }\\n\\n        _baseLoanChecks(loanId, _loan);\\n\\n        _baseRenegotiationChecks(_renegotiationOffer, _loan);\\n\\n        if (_renegotiationOffer.duration > 0) {\\n            revert PartialOfferCannotChangeDurationError();\\n        }\\n        if (_renegotiationOffer.fee > 0) {\\n            revert PartialOfferCannotHaveFeeError();\\n        }\\n\\n        (uint256 totalDelta, uint256 totalAccruedInterest, uint256 totalNewSources,) =\\n            _processOldSources(_renegotiationOffer, _loan, true);\\n\\n        if (totalDelta != _renegotiationOffer.principalAmount) {\\n            revert InvalidRenegotiationOfferError();\\n        }\\n        if (totalNewSources > _maxSources) {\\n            revert TooManySourcesError(totalNewSources);\\n        }\\n\\n        uint256 newLoanId = _getAndSetNewLoanId();\\n        Source[] memory newSources = new Source[](totalNewSources);\\n        newSources[0] = _getSourceFromOffer(_renegotiationOffer, totalAccruedInterest, newLoanId);\\n        /// @dev Index = 0 is taken by the new source\\n        uint256 j = 1;\\n        for (uint256 i = 0; i < _renegotiationOffer.targetPrincipal.length;) {\\n            if (_renegotiationOffer.targetPrincipal[i] > 0) {\\n                newSources[j] = _loan.source[i];\\n                newSources[j].principalAmount = _renegotiationOffer.targetPrincipal[i];\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        _loan.source = newSources;\\n\\n        _loans[newLoanId] = _loan.hash();\\n        delete _loans[loanId];\\n\\n        /// @dev Here fee is always 0\\n        emit LoanRefinanced(_renegotiationOffer.renegotiationId, loanId, newLoanId, _loan, 0);\\n\\n        return (newLoanId, _loan);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function extendLoan(uint256 _loanId, Loan memory _loan, uint256 _extension)\\n        external\\n        returns (uint256, Loan memory)\\n    {\\n        _baseLoanChecks(_loanId, _loan);\\n\\n        if (_loan.source.length > 1) {\\n            revert ExtensionNotAvailableError();\\n        }\\n        uint256 unlockedTime = _getUnlockedTime(_loan.source[0].startTime, _loan.startTime + _loan.duration);\\n        if (unlockedTime > block.timestamp) {\\n            revert SourceCannotBeRefinancedError(unlockedTime);\\n        }\\n        if (_loan.source[0].lender != msg.sender) {\\n            revert OnlyLenderCallableError();\\n        }\\n        _loan.duration += _extension;\\n        uint256 newLoanId = _getAndSetNewLoanId();\\n        _loans[newLoanId] = _loan.hash();\\n\\n        delete _loans[_loanId];\\n\\n        emit LoanExtended(_loanId, newLoanId, _loan, _extension);\\n\\n        return (newLoanId, _loan);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function repayLoan(LoanRepaymentData calldata _repaymentData) external override nonReentrant {\\n        uint256 loanId = _repaymentData.data.loanId;\\n        Loan calldata loan = _repaymentData.loan;\\n        /// @dev If the caller is not the borrower itself, check the signature to avoid someone else forcing an unwanted repayment.\\n        if (msg.sender != loan.borrower) {\\n            _checkSignature(loan.borrower, _repaymentData.data.hash(), _repaymentData.borrowerSignature);\\n        }\\n\\n        _baseLoanChecks(loanId, loan);\\n\\n        /// @dev Unlikely this is used outside of the callback with a seaport sell, but leaving here in case that's not correct.\\n        if (_repaymentData.data.shouldDelegate) {\\n            _delegateRegistry.delegateERC721(\\n                loan.borrower, loan.nftCollateralAddress, loan.nftCollateralTokenId, bytes32(\\\"\\\"), true\\n            );\\n        }\\n\\n        ERC721(loan.nftCollateralAddress).transferFrom(address(this), loan.borrower, loan.nftCollateralTokenId);\\n\\n        /// @dev After returning the NFT to the borrower, check if there's an action to be taken (eg: sell it to cover repayment).\\n        uint128 taxBps = _handleAfterNFTTransferCallback(loan, _repaymentData.data.callbackData);\\n\\n        /// @dev Bring to memory\\n        ProtocolFee memory protocolFee = _protocolFee;\\n        bool withProtocolFee = protocolFee.fraction > 0;\\n        uint256 totalProtocolFee = 0;\\n\\n        ERC20 asset = ERC20(loan.principalAddress);\\n        uint256 totalRepayment = 0;\\n        for (uint256 i = 0; i < loan.source.length;) {\\n            Source memory source = loan.source[i];\\n\\n            uint256 newInterest = source.principalAmount.getInterest(source.aprBps, block.timestamp - source.startTime);\\n            uint256 tax = source.principalAmount.mulDivUp(taxBps, _PRECISION);\\n\\n            uint256 thisProtocolFee = 0;\\n            uint256 thisTaxFee = 0;\\n            if (withProtocolFee) {\\n                thisProtocolFee = newInterest.mulDivUp(protocolFee.fraction, _PRECISION);\\n                thisTaxFee = tax.mulDivUp(protocolFee.fraction, _PRECISION);\\n                totalProtocolFee += thisProtocolFee + thisTaxFee;\\n            }\\n\\n            uint256 repayment =\\n                source.principalAmount + source.accruedInterest + newInterest - thisProtocolFee + tax - thisTaxFee;\\n            asset.safeTransferFrom(loan.borrower, source.lender, repayment);\\n\\n            totalRepayment += repayment;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit LoanRepaid(loanId, totalRepayment, totalProtocolFee);\\n\\n        if (withProtocolFee) {\\n            asset.safeTransferFrom(loan.borrower, protocolFee.recipient, totalProtocolFee);\\n        }\\n\\n        /// @dev Reclaim space.\\n        delete _loans[loanId];\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function liquidateLoan(uint256 _loanId, Loan calldata _loan)\\n        external\\n        override\\n        nonReentrant\\n        returns (bytes memory)\\n    {\\n        if (_loan.hash() != _loans[_loanId]) {\\n            revert InvalidLoanError(_loanId);\\n        }\\n        uint256 expirationTime = _loan.startTime + _loan.duration;\\n        address collateralAddress = _loan.nftCollateralAddress;\\n        ERC721 collateralCollection = ERC721(collateralAddress);\\n\\n        if (expirationTime > block.timestamp) {\\n            revert LoanNotDueError(expirationTime);\\n        }\\n        bytes memory liquidation;\\n        if (_loan.source.length == 1) {\\n            collateralCollection.transferFrom(address(this), _loan.source[0].lender, _loan.nftCollateralTokenId);\\n\\n            emit LoanForeclosed(_loanId);\\n\\n            /// @dev Reclaim space.\\n            delete _loans[_loanId];\\n        } else {\\n            collateralCollection.transferFrom(address(this), address(_loanLiquidator), _loan.nftCollateralTokenId);\\n            liquidation = _loanLiquidator.liquidateLoan(\\n                _loanId,\\n                collateralAddress,\\n                _loan.nftCollateralTokenId,\\n                _loan.principalAddress,\\n                _liquidationAuctionDuration,\\n                msg.sender\\n            );\\n\\n            emit LoanSentToLiquidator(_loanId, address(_loanLiquidator));\\n        }\\n        return liquidation;\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function loanLiquidated(uint256 _loanId, Loan calldata _loan) external override onlyLiquidator {\\n        if (_loan.hash() != _loans[_loanId]) {\\n            revert InvalidLoanError(_loanId);\\n        }\\n\\n        emit LoanLiquidated(_loanId);\\n\\n        /// @dev Reclaim space.\\n        delete _loans[_loanId];\\n    }\\n\\n    function getMinSourcePrincipal(uint256 _loanPrincipal) external view returns (uint256) {\\n        return _getMinSourcePrincipal(_loanPrincipal);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function delegate(uint256 _loanId, Loan calldata loan, address _delegate, bytes32 _rights, bool _value) external {\\n        if (loan.hash() != _loans[_loanId]) {\\n            revert InvalidLoanError(_loanId);\\n        }\\n        if (msg.sender != loan.borrower) {\\n            revert OnlyBorrowerCallableError();\\n        }\\n        _delegateRegistry.delegateERC721(\\n            _delegate, loan.nftCollateralAddress, loan.nftCollateralTokenId, _rights, _value\\n        );\\n\\n        emit Delegated(_loanId, _delegate, _value);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function revokeDelegate(address _delegate, address _collection, uint256 _tokenId) external {\\n        if (ERC721(_collection).ownerOf(_tokenId) == address(this)) {\\n            revert InvalidMethodError();\\n        }\\n\\n        _delegateRegistry.delegateERC721(_delegate, _collection, _tokenId, \\\"\\\", false);\\n\\n        emit RevokeDelegate(_delegate, _collection, _tokenId);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function getDelegateRegistry() external view returns (address) {\\n        return address(_delegateRegistry);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function setDelegateRegistry(address _newDelegateRegistry) external onlyOwner {\\n        _delegateRegistry = IDelegateRegistry(_newDelegateRegistry);\\n\\n        emit DelegateRegistryUpdated(_newDelegateRegistry);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function getMaxSources() external view returns (uint256) {\\n        return _maxSources;\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function setMaxSources(uint256 __maxSources) external onlyOwner {\\n        _maxSources = __maxSources;\\n\\n        emit MaxSourcesUpdated(__maxSources);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function getMinLockPeriod() external view returns (uint256) {\\n        return _minLockPeriod;\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function setMinLockPeriod(uint256 __minLockPeriod) external onlyOwner {\\n        _minLockPeriod = __minLockPeriod;\\n\\n        emit MinLockPeriodUpdated(__minLockPeriod);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function getLoanHash(uint256 _loanId) external view returns (bytes32) {\\n        return _loans[_loanId];\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function executeFlashAction(uint256 _loanId, Loan calldata _loan, address _target, bytes calldata _data) external {\\n        if (_loan.hash() != _loans[_loanId]) {\\n            revert InvalidLoanError(_loanId);\\n        }\\n        if (msg.sender != _loan.borrower) {\\n            revert OnlyBorrowerCallableError();\\n        }\\n\\n        ERC721(_loan.nftCollateralAddress).transferFrom(\\n            address(this), address(_flashActionContract), _loan.nftCollateralTokenId\\n        );\\n        _flashActionContract.execute(_loan.nftCollateralAddress, _loan.nftCollateralTokenId, _target, _data);\\n\\n        if (ERC721(_loan.nftCollateralAddress).ownerOf(_loan.nftCollateralTokenId) != address(this)) {\\n            revert NFTNotReturnedError();\\n        }\\n\\n        emit FlashActionExecuted(_loanId, _target, _data);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function getFlashActionContract() external view returns (address) {\\n        return address(_flashActionContract);\\n    }\\n\\n    /// @inheritdoc IMultiSourceLoan\\n    function setFlashActionContract(address _newFlashActionContract) external onlyOwner {\\n        _flashActionContract = INFTFlashAction(_newFlashActionContract);\\n\\n        emit FlashActionContractUpdated(_newFlashActionContract);\\n    }\\n\\n    /// @notice Update old sources and return the total delta, accrued interest, new sources and\\n    /// transfer the protocol fee.\\n    /// @param _renegotiationOffer The refinance offer.\\n    /// @param _loan The loan to be refinanced.\\n    /// @param _isStrictlyBetter Every source's apr needs to be improved.\\n    /// @return totalDelta The total delta is the sum of all deltas across existing sources. This must be equal\\n    /// to the new supplied (the total principal cannot change).\\n    /// @return totalAccruedInterest Total accrued interest across all sources paid.\\n    /// @return totalNewSources Total new sources, including new lender, left after the refinance.\\n    /// @return totalAnnualInterest Total annual interest across all sources.\\n    function _processOldSources(\\n        RenegotiationOffer calldata _renegotiationOffer,\\n        Loan memory _loan,\\n        bool _isStrictlyBetter\\n    )\\n        private\\n        returns (uint256 totalDelta, uint256 totalAccruedInterest, uint256 totalNewSources, uint256 totalAnnualInterest)\\n    {\\n        /// @dev Bring var to memory\\n        ProtocolFee memory protocolFee = _protocolFee;\\n\\n        uint256 totalProtocolFee = 0;\\n        if (protocolFee.fraction > 0 && _renegotiationOffer.fee > 0) {\\n            totalProtocolFee = _renegotiationOffer.fee.mulDivUp(protocolFee.fraction, _PRECISION);\\n        }\\n\\n        totalNewSources = 1;\\n        for (uint256 i = 0; i < _renegotiationOffer.targetPrincipal.length;) {\\n            Source memory source = _loan.source[i];\\n            uint256 targetPrincipal = _renegotiationOffer.targetPrincipal[i];\\n            (\\n                uint256 delta,\\n                uint256 accruedInterest,\\n                uint256 isNewSource,\\n                uint256 annualInterest,\\n                uint256 thisProtocolFee\\n            ) = _processOldSource(\\n                _renegotiationOffer.lender,\\n                _loan.principalAddress,\\n                source,\\n                _loan.startTime + _loan.duration,\\n                targetPrincipal,\\n                protocolFee\\n            );\\n\\n            _checkSourceStrictly(_isStrictlyBetter, delta, source.aprBps, _renegotiationOffer.aprBps, _minimum.interest);\\n\\n            totalAnnualInterest += annualInterest;\\n            totalDelta += delta;\\n            totalAccruedInterest += accruedInterest;\\n            totalProtocolFee += thisProtocolFee;\\n            totalNewSources += isNewSource;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        _handleProtocolFeeForFee(_loan.principalAddress, _renegotiationOffer.lender, totalProtocolFee, protocolFee);\\n    }\\n\\n    /// @notice Process the current source during a renegotiation.\\n    /// @param _lender The new lender.\\n    /// @param _principalAddress The principal address of the loan.\\n    /// @param _source The source to be processed.\\n    /// @param _endTime The end time of the loan.\\n    /// @param _targetPrincipal The target principal of the source.\\n    /// @param protocolFee The protocol fee.\\n    /// @return delta The delta between the old and new principal.\\n    /// @return accruedInterest The accrued interest paid.\\n    /// @return isNewSource Whether the source is kept.\\n    /// @return annualInterest The total annual interest paid (times 10000 since we have it in BPS)\\n    /// @return thisProtocolFee The protocol fee paid for this source.\\n    function _processOldSource(\\n        address _lender,\\n        address _principalAddress,\\n        Source memory _source,\\n        uint256 _endTime,\\n        uint256 _targetPrincipal,\\n        ProtocolFee memory protocolFee\\n    )\\n        private\\n        returns (\\n            uint256 delta,\\n            uint256 accruedInterest,\\n            uint256 isNewSource,\\n            uint256 annualInterest,\\n            uint256 thisProtocolFee\\n        )\\n    {\\n        uint256 unlockedTime = _getUnlockedTime(_source.startTime, _endTime);\\n        if (unlockedTime > block.timestamp) {\\n            revert SourceCannotBeRefinancedError(unlockedTime);\\n        }\\n        delta = _source.principalAmount - _targetPrincipal;\\n        annualInterest = _source.principalAmount * _source.aprBps;\\n        if (delta == 0) {\\n            return (0, 0, 1, annualInterest, 0);\\n        }\\n        accruedInterest = delta.getInterest(_source.aprBps, block.timestamp - _source.startTime);\\n\\n        if (protocolFee.fraction > 0) {\\n            thisProtocolFee = accruedInterest.mulDivUp(protocolFee.fraction, _PRECISION);\\n        }\\n\\n        uint256 proportionalAccrued = _source.accruedInterest.mulDivDown(delta, _source.principalAmount);\\n        if (_targetPrincipal > 0) {\\n            _source.accruedInterest -= proportionalAccrued;\\n            isNewSource = 1;\\n        }\\n\\n        accruedInterest += proportionalAccrued;\\n\\n        ERC20(_principalAddress).safeTransferFrom(_lender, _source.lender, delta + accruedInterest - thisProtocolFee);\\n    }\\n\\n    function _baseLoanChecks(uint256 _loanId, Loan memory _loan) private view {\\n        if (_loan.hash() != _loans[_loanId]) {\\n            revert InvalidLoanError(_loanId);\\n        }\\n        if (_loan.startTime + _loan.duration < block.timestamp) {\\n            revert LoanExpiredError();\\n        }\\n    }\\n\\n    function _baseRenegotiationChecks(RenegotiationOffer calldata _renegotiationOffer, Loan memory _loan)\\n        private\\n        view\\n    {\\n        if (\\n            (_renegotiationOffer.principalAmount == 0)\\n                || (_loan.source.length != _renegotiationOffer.targetPrincipal.length)\\n        ) {\\n            revert InvalidRenegotiationOfferError();\\n        }\\n        if (block.timestamp > _renegotiationOffer.expirationTime) {\\n            revert ExpiredRenegotiationOfferError(_renegotiationOffer.expirationTime);\\n        }\\n        uint256 renegotiationId = _renegotiationOffer.renegotiationId;\\n        address lender = _renegotiationOffer.lender;\\n        if (\\n            isRenegotiationOfferCancelled[lender][renegotiationId]\\n                || lenderMinRenegotiationOfferId[lender] >= renegotiationId\\n        ) {\\n            revert CancelledRenegotiationOfferError(lender, renegotiationId);\\n        }\\n    }\\n\\n    function _getSourceFromOffer(\\n        RenegotiationOffer memory _renegotiationOffer,\\n        uint256 _accruedInterest,\\n        uint256 _loanId\\n    ) private view returns (Source memory) {\\n        return Source({\\n            loanId: _loanId,\\n            lender: _renegotiationOffer.lender,\\n            principalAmount: _renegotiationOffer.principalAmount,\\n            accruedInterest: _accruedInterest,\\n            startTime: block.timestamp,\\n            aprBps: _renegotiationOffer.aprBps\\n        });\\n    }\\n\\n    function _getMinSourcePrincipal(uint256 _loanPrincipal) private view returns (uint256) {\\n        return _loanPrincipal / (_MAX_RATIO_SOURCE_MIN_PRINCIPAL * _maxSources);\\n    }\\n\\n    /// @notice Protocol fee for fees charged on offers/renegotationOffers.\\n    /// @param _principalAddress The principal address of the loan.\\n    /// @param _lender The lender of the loan.\\n    /// @param _fee The fee to be charged.\\n    /// @param protocolFee The protocol fee variable brought to memory.\\n    function _handleProtocolFeeForFee(\\n        address _principalAddress,\\n        address _lender,\\n        uint256 _fee,\\n        ProtocolFee memory protocolFee\\n    ) private {\\n        if (protocolFee.fraction > 0 && _fee > 0) {\\n            ERC20(_principalAddress).safeTransferFrom(_lender, protocolFee.recipient, _fee);\\n        }\\n    }\\n\\n    /// @notice Check condition for strictly better sources\\n    /// @param _isStrictlyBetter Whether the new source needs to be strictly better than the old one.\\n    /// @param _delta The delta between the old and new principal. 0 if unchanged.\\n    /// @param _currentAprBps The current apr of the source.\\n    /// @param _targetAprBps The target apr of the source.\\n    /// @param _minImprovement The minimum improvement required.\\n    function _checkSourceStrictly(\\n        bool _isStrictlyBetter,\\n        uint256 _delta,\\n        uint256 _currentAprBps,\\n        uint256 _targetAprBps,\\n        uint256 _minImprovement\\n    ) private pure {\\n        /// @dev If _isStrictlyBetter is set, and the new apr is higher, then it'll underflow.\\n        if (\\n            _isStrictlyBetter && _delta > 0\\n                && ((_currentAprBps - _targetAprBps).mulDivDown(_PRECISION, _currentAprBps) < _minImprovement)\\n        ) {\\n            revert InvalidRenegotiationOfferError();\\n        }\\n    }\\n\\n    function _getUnlockedTime(uint256 _sourceStartTime, uint256 _loanEndTime) private view returns (uint256) {\\n        return _sourceStartTime + (_loanEndTime - _sourceStartTime).mulDivUp(_minLockPeriod, _PRECISION);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/delegate-registry/src/IDelegateRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity >=0.8.13;\\n\\n/**\\n * @title IDelegateRegistry\\n * @custom:version 2.0\\n * @custom:author foobar (0xfoobar)\\n * @notice A standalone immutable registry storing delegated permissions from one address to another\\n */\\ninterface IDelegateRegistry {\\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\\n    enum DelegationType {\\n        NONE,\\n        ALL,\\n        CONTRACT,\\n        ERC721,\\n        ERC20,\\n        ERC1155\\n    }\\n\\n    /// @notice Struct for returning delegations\\n    struct Delegation {\\n        DelegationType type_;\\n        address to;\\n        address from;\\n        bytes32 rights;\\n        address contract_;\\n        uint256 tokenId;\\n        uint256 amount;\\n    }\\n\\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\\n\\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\\n    event DelegateContract(address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable);\\n\\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\\n    event DelegateERC721(address indexed from, address indexed to, address indexed contract_, uint256 tokenId, bytes32 rights, bool enable);\\n\\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\\n    event DelegateERC20(address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount);\\n\\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\\n    event DelegateERC1155(address indexed from, address indexed to, address indexed contract_, uint256 tokenId, bytes32 rights, uint256 amount);\\n\\n    /// @notice Thrown if multicall calldata is malformed\\n    error MulticallFailed();\\n\\n    /**\\n     * -----------  WRITE -----------\\n     */\\n\\n    /**\\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n     * @param data The encoded function data for each of the calls to make to this contract\\n     * @return results The results from each of the calls passed in via data\\n     */\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\\n     * @param to The address to act as delegate\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\\n     * @param to The address to act as delegate\\n     * @param contract_ The contract whose rights are being delegated\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\\n     * @param to The address to act as delegate\\n     * @param contract_ The contract whose rights are being delegated\\n     * @param tokenId The token id to delegate\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\\n     * @param to The address to act as delegate\\n     * @param contract_ The address for the fungible token contract\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\\n     * @param to The address to act as delegate\\n     * @param contract_ The address of the contract that holds the token\\n     * @param tokenId The token id to delegate\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * ----------- CHECKS -----------\\n     */\\n\\n    /**\\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\\n     * @param to The potential delegate address\\n     * @param from The potential address who delegated rights\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return valid Whether delegate is granted to act on the from's behalf\\n     */\\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\\n\\n    /**\\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\\n     * @param to The delegated address to check\\n     * @param contract_ The specific contract address being checked\\n     * @param from The cold wallet who issued the delegation\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\\n     */\\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights) external view returns (bool);\\n\\n    /**\\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\\n     * @param to The delegated address to check\\n     * @param contract_ The specific contract address being checked\\n     * @param tokenId The token id for the token to delegating\\n     * @param from The wallet that issued the delegation\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\\n     */\\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\\n     * @param to The delegated address to check\\n     * @param contract_ The address of the token contract\\n     * @param from The cold wallet who issued the delegation\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\\n     */\\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\\n     * @param to The delegated address to check\\n     * @param contract_ The address of the token contract\\n     * @param tokenId The token id to check the delegated amount of\\n     * @param from The cold wallet who issued the delegation\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\\n     */\\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights) external view returns (uint256);\\n\\n    /**\\n     * ----------- ENUMERATIONS -----------\\n     */\\n\\n    /**\\n     * @notice Returns all enabled delegations a given delegate has received\\n     * @param to The address to retrieve delegations for\\n     * @return delegations Array of Delegation structs\\n     */\\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns all enabled delegations an address has given out\\n     * @param from The address to retrieve delegations for\\n     * @return delegations Array of Delegation structs\\n     */\\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns all hashes associated with enabled delegations an address has received\\n     * @param to The address to retrieve incoming delegation hashes for\\n     * @return delegationHashes Array of delegation hashes\\n     */\\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\\n\\n    /**\\n     * @notice Returns all hashes associated with enabled delegations an address has given out\\n     * @param from The address to retrieve outgoing delegation hashes for\\n     * @return delegationHashes Array of delegation hashes\\n     */\\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\\n\\n    /**\\n     * @notice Returns the delegations for a given array of delegation hashes\\n     * @param delegationHashes is an array of hashes that correspond to delegations\\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\\n     */\\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes) external view returns (Delegation[] memory delegations);\\n\\n    /**\\n     * ----------- STORAGE ACCESS -----------\\n     */\\n\\n    /**\\n     * @notice Allows external contracts to read arbitrary storage slots\\n     */\\n    function readSlot(bytes32 location) external view returns (bytes32);\\n\\n    /**\\n     * @notice Allows external contracts to read an arbitrary array of storage slots\\n     */\\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/INFTFlashAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\ninterface INFTFlashAction {\\n    error InvalidOwnerError();\\n\\n    /// @notice Execute an arbitrary flash action on a given NFT. This contract owns it and must return it.\\n    /// @param _collection The NFT collection.\\n    /// @param _tokenId The NFT token ID.\\n    /// @param _target The target contract.\\n    /// @param _data The data to send to the target.\\n    function execute(address _collection, uint256 _tokenId, address _target, bytes calldata _data) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/loans/IMultiSourceLoan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"./IBaseLoan.sol\\\";\\n\\ninterface IMultiSourceLoan {\\n    /// @param executionData Execution data.\\n    /// @param lender Lender address.\\n    /// @param borrower Address that owns the NFT and will take over the loan.\\n    /// @param lenderOfferSignature Signature of the offer (signed by lender).\\n    /// @param borrowerOfferSignature Signature of the offer (signed by borrower).\\n    /// @param callbackData Whether to call the afterPrincipalTransfer callback\\n    struct LoanExecutionData {\\n        IBaseLoan.ExecutionData executionData;\\n        address lender;\\n        address borrower;\\n        bytes lenderOfferSignature;\\n        bytes borrowerOfferSignature;\\n    }\\n\\n    /// @param loanId Loan ID.\\n    /// @param callbackData Whether to call the afterNFTTransfer callback\\n    /// @param shouldDelegate Whether to delegate ownership of the NFT (avoid seaport flags).\\n    struct SignableRepaymentData {\\n        uint256 loanId;\\n        bytes callbackData;\\n        bool shouldDelegate;\\n    }\\n\\n    /// @param loan Loan.\\n    /// @param borrowerLoanSignature Signature of the loan (signed by borrower).\\n    struct LoanRepaymentData {\\n        SignableRepaymentData data;\\n        Loan loan;\\n        bytes borrowerSignature;\\n    }\\n\\n    /// @notice When a loan is initiated, there's one source, the original lender. After each refinance,\\n    /// a new source is created to represent the new lender, and potentially others dissapear (if a tranche\\n    /// is fully refinanced)\\n    /// @dev No need to have principal address here since it's the same across all, so it can live in the Loan.\\n    /// @param loanId Loan ID.\\n    /// @param lender Lender for this given source.\\n    /// @param principalAmount Principal Amount.\\n    /// @param accruedInterest Accrued Interest.\\n    /// @param startTime Start Time. Either the time at which the loan initiated / was refinanced.\\n    /// @param aprBps APR in basis points.\\n    struct Source {\\n        uint256 loanId;\\n        address lender;\\n        uint256 principalAmount;\\n        uint256 accruedInterest;\\n        uint256 startTime;\\n        uint256 aprBps;\\n    }\\n\\n    /// @dev Principal Amount is equal to the sum of all sources principalAmount.\\n    /// We keep it for caching purposes. Since we are not saving this on chain but the hash,\\n    /// it does not have a huge impact on gas.\\n    /// @param borrower Borrower.\\n    /// @param nftCollateralTokenId NFT Collateral Token ID.\\n    /// @param nftCollateralAddress NFT Collateral Address.\\n    /// @param principalAddress Principal Address.\\n    /// @param principalAmount Principal Amount.\\n    /// @param startTime Start Time.\\n    /// @param duration Duration.\\n    /// @param source Sources\\n    struct Loan {\\n        address borrower;\\n        uint256 nftCollateralTokenId;\\n        address nftCollateralAddress;\\n        address principalAddress;\\n        uint256 principalAmount;\\n        uint256 startTime;\\n        uint256 duration;\\n        Source[] source;\\n    }\\n\\n    struct RenegotiationOffer {\\n        uint256 renegotiationId;\\n        uint256 loanId;\\n        address lender;\\n        uint256 fee;\\n        uint256[] targetPrincipal;\\n        uint256 principalAmount;\\n        uint256 aprBps;\\n        uint256 expirationTime;\\n        uint256 duration;\\n    }\\n\\n    /// @notice Call by the borrower when emiting a new loan.\\n    /// @param _executionData Loan execution data.\\n    /// @return loanId Loan ID.\\n    /// @return loan Loan.\\n    function emitLoan(LoanExecutionData calldata _executionData) external returns (uint256, Loan memory);\\n\\n    /// @notice Refinance whole loan (leaving just one source).\\n    /// @param _renegotiationOffer Offer to refinance a loan.\\n    /// @param _loan Current loan.\\n    /// @param _renegotiationOfferSignature Signature of the offer.\\n    /// @return loanId New Loan Id, New Loan.\\n    function refinanceFull(\\n        RenegotiationOffer calldata _renegotiationOffer,\\n        Loan memory _loan,\\n        bytes calldata _renegotiationOfferSignature\\n    ) external returns (uint256, Loan memory);\\n\\n    /// @notice Refinance a loan partially. It can only be called by the new lender\\n    /// (they are always a strict improvement on apr).\\n    /// @param _renegotiationOffer Offer to refinance a loan partially.\\n    /// @param _loan Current loan.\\n    /// @return loanId New Loan Id, New Loan.\\n    function refinancePartial(RenegotiationOffer calldata _renegotiationOffer, Loan memory _loan)\\n        external\\n        returns (uint256, Loan memory);\\n\\n    /// @notice Repay loan. Interest is calculated pro-rata based on time. Lender is defined by nft ownership.\\n    /// @param _repaymentData Repayment data.\\n    function repayLoan(LoanRepaymentData calldata _repaymentData) external;\\n\\n    /// @notice Call when a loan is past its due date.\\n    /// @param _loanId Loan ID.\\n    /// @param _loan Loan.\\n    /// @return Liquidation Struct of the liquidation.\\n    function liquidateLoan(uint256 _loanId, Loan calldata _loan) external returns (bytes memory);\\n\\n    /// @return maxSources Max sources per loan.\\n    function getMaxSources() external view returns (uint256);\\n\\n    /// @notice Update the maximum number of sources per loan.\\n    /// @param maxSources Maximum number of sources.\\n    function setMaxSources(uint256 maxSources) external;\\n\\n    /// @notice Set min lock period (in BPS).\\n    /// @param _minLockPeriod Min lock period.\\n    function setMinLockPeriod(uint256 _minLockPeriod) external;\\n\\n    /// @notice Get min lock period (in BPS).\\n    /// @return minLockPeriod Min lock period.\\n    function getMinLockPeriod() external view returns (uint256);\\n\\n    /// @notice Get delegation registry.\\n    /// @return delegateRegistry Delegate registry.\\n    function getDelegateRegistry() external view returns (address);\\n\\n    /// @notice Update delegation registry.\\n    /// @param _newDelegationRegistry Delegation registry.\\n    function setDelegateRegistry(address _newDelegationRegistry) external;\\n\\n    /// @notice Delegate ownership.\\n    /// @param _loanId Loan ID.\\n    /// @param _loan Loan.\\n    /// @param _rights Delegation Rights. Empty for all.\\n    /// @param _delegate Delegate address.\\n    /// @param _value True if delegate, false if undelegate.\\n    function delegate(uint256 _loanId, Loan calldata _loan, address _delegate, bytes32 _rights, bool _value) external;\\n\\n    /// @notice Anyone can reveke a delegation on an NFT that's no longer in escrow.\\n    /// @param _delegate Delegate address.\\n    /// @param _collection Collection address.\\n    /// @param _tokenId Token ID.\\n    function revokeDelegate(address _delegate, address _collection, uint256 _tokenId) external;\\n\\n    /// @notice Get Flash Action Contract.\\n    /// @return flashActionContract Flash Action Contract.\\n    function getFlashActionContract() external view returns (address);\\n\\n    /// @notice Update Flash Action Contract.\\n    /// @param _newFlashActionContract Flash Action Contract.\\n    function setFlashActionContract(address _newFlashActionContract) external;\\n\\n    /// @notice Get Loan Hash.\\n    /// @param _loanId Loan ID.\\n    /// @return loanHash Loan Hash.\\n    function getLoanHash(uint256 _loanId) external view returns (bytes32);\\n\\n    /// @notice Transfer NFT to the flash action contract (expected use cases here are for airdrops and similar scenarios).\\n    /// The flash action contract would implement specific interactions with given contracts.\\n    /// Only the the borrower can call this function for a given loan. By the end of the transaction, the NFT must have\\n    /// been returned to escrow.\\n    /// @param _loanId Loan ID.\\n    /// @param _loan Loan.\\n    /// @param _target Target address for the flash action contract to interact with.\\n    /// @param _data Data to be passed to be passed to the ultimate contract.\\n    function executeFlashAction(uint256 _loanId, Loan calldata _loan, address _target, bytes calldata _data) external;\\n\\n    /// @notice Extend loan duration. Can only be called by the lender on loans that have just one source.\\n    /// @param _loanId Loan ID.\\n    /// @param _loan Loan.\\n    /// @param _extension Extension in seconds.\\n    /// @return newLoanId New Loan Id\\n    /// @return newLoan New Loan.\\n    function extendLoan(uint256 _loanId, Loan memory _loan, uint256 _extension)\\n        external\\n        returns (uint256, Loan memory);\\n\\n    /// @notice Called by the liquidator for accounting purposes.\\n    /// @param _loanId The id of the loan.\\n    /// @param _loan The loan object.\\n    function loanLiquidated(uint256 _loanId, Loan calldata _loan) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILoanLiquidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n/// @title Liquidates Collateral for Defaulted Loans\\n/// @author Florida St\\n/// @notice It liquidates collateral corresponding to defaulted loans\\n///         and sends back the proceeds to the loan contract for distribution.\\ninterface ILoanLiquidator {\\n    /// @notice Given a loan, it takes posession of the NFT and liquidates it.\\n    /// @param _loanId The loan id.\\n    /// @param _contract The loan contract address.\\n    /// @param _tokenId The NFT id.\\n    /// @param _asset The asset address.\\n    /// @param _duration The liquidation duration.\\n    /// @param _originator The address that trigger the liquidation.\\n    /// @return encodedAuction Encoded struct.\\n    function liquidateLoan(\\n        uint256 _loanId,\\n        address _contract,\\n        uint256 _tokenId,\\n        address _asset,\\n        uint96 _duration,\\n        address _originator\\n    ) external returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"src/lib/utils/Hash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"../../interfaces/loans/IMultiSourceLoan.sol\\\";\\nimport \\\"../../interfaces/loans/IBaseLoan.sol\\\";\\nimport \\\"../../interfaces/IAuctionLoanLiquidator.sol\\\";\\n\\nlibrary Hash {\\n    // keccak256(\\\"OfferValidator(address validator,bytes arguments)\\\")\\n    bytes32 private constant _VALIDATOR_HASH = 0x4def3e04bd42194484d5f8a5b268ec0df03b9d9d0402606fe3100023c5d79ac4;\\n\\n    // keccak256(\\\"LoanOffer(uint256 offerId,address lender,uint256 fee,address borrower,uint256 capacity,address nftCollateralAddress,uint256 nftCollateralTokenId,address principalAddress,uint256 principalAmount,uint256 aprBps,uint256 expirationTime,uint256 duration,OfferValidator[] validators)OfferValidator(address validator,bytes arguments)\\\")\\n    bytes32 private constant _LOAN_OFFER_HASH = 0x891e530ed2768a9decac48f4b7beec447f755ce23feeeeb952e429145b44ba91;\\n\\n    /// keccak256(\\\"ExecutionData(LoanOffer offer,uint256 tokenId,uint256 amount,uint256 expirationTime,bytes callbackData)LoanOffer(uint256 offerId,address lender,uint256 fee,address borrower,uint256 capacity,address nftCollateralAddress,uint256 nftCollateralTokenId,address principalAddress,uint256 principalAmount,uint256 aprBps,uint256 expirationTime,uint256 duration,OfferValidator[] validators)OfferValidator(address validator,bytes arguments)\\\")\\n    bytes32 private constant _EXECUTION_DATA_HASH = 0x7e90717662b6dd110797922ef6d6701d92bfd4164783966933e092ea21a74c5a;\\n\\n    /// keccak256(\\\"SignableRepaymentData(uint256 loanId,bytes callbackData,bool shouldDelegate)\\\")\\n    bytes32 private constant _SIGNABLE_REPAYMENT_DATA_HASH =\\n        0x41277b3c1cbe08ea7bbdd10a13f24dc956f3936bf46526f904c73697d9958e0c;\\n\\n    // keccak256(\\\"Loan(address borrower,uint256 nftCollateralTokenId,address nftCollateralAddress,address principalAddress,uint256 principalAmount,uint256 startTime,uint256 duration,Source[] source)Source(uint256 loanId,address lender,uint256 principalAmount,uint256 accruedInterest,uint256 startTime,uint256 aprBps)\\\")\\n    bytes32 private constant _MULTI_SOURCE_LOAN_HASH =\\n        0x35f73c5cb07b3fa605378d4f576769166fed212ec3813ac1f1d73ef1c537eb0e;\\n\\n    // keccak256(\\\"Source(uint256 loanId,address lender,uint256 principalAmount,uint256 accruedInterest,uint256 startTime,uint256 aprBps)\\\")\\n    bytes32 private constant _SOURCE_HASH = 0x8ca047c2f10359bf4a27bd2c623674be3801153b6b2646ba08593dc96ad7bb44;\\n\\n    /// keccak256(\\\"RenegotiationOffer(uint256 renegotiationId,uint256 loanId,address lender,uint256 fee,uint256[] targetPrincipal,uint256 principalAmount,uint256 aprBps,uint256 expirationTime,uint256 duration)\\\")\\n    bytes32 private constant _MULTI_RENEGOTIATION_OFFER_HASH =\\n        0xdb613ea3383336cd787d929ccfc21ab7cd87bf1d588780c80ce5f970dd79c348;\\n\\n    /// keccak256(\\\"Auction(address loanAddress,uint256 loanId,uint256 highestBid,uint256 triggerFee,address highestBidder,uint96 duration,address asset,uint96 startTime,address originator,uint96 lastBidTime)\\\")\\n    bytes32 private constant _AUCTION_HASH = 0xd1912299766a3d3ca1ad2e2135d884e08d798009860146382d22f8c389905b34;\\n\\n    function hash(IBaseLoan.LoanOffer memory _loanOffer) internal pure returns (bytes32) {\\n        bytes memory encodedValidators;\\n        for (uint256 i = 0; i < _loanOffer.validators.length;) {\\n            encodedValidators = abi.encodePacked(encodedValidators, _hashValidator(_loanOffer.validators[i]));\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return keccak256(\\n            abi.encode(\\n                _LOAN_OFFER_HASH,\\n                _loanOffer.offerId,\\n                _loanOffer.lender,\\n                _loanOffer.fee,\\n                _loanOffer.borrower,\\n                _loanOffer.capacity,\\n                _loanOffer.nftCollateralAddress,\\n                _loanOffer.nftCollateralTokenId,\\n                _loanOffer.principalAddress,\\n                _loanOffer.principalAmount,\\n                _loanOffer.aprBps,\\n                _loanOffer.expirationTime,\\n                _loanOffer.duration,\\n                keccak256(encodedValidators)\\n            )\\n        );\\n    }\\n\\n    function hash(IBaseLoan.ExecutionData memory _executionData) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                _EXECUTION_DATA_HASH,\\n                hash(_executionData.offer),\\n                _executionData.tokenId,\\n                _executionData.amount,\\n                _executionData.expirationTime,\\n                keccak256(_executionData.callbackData)\\n            )\\n        );\\n    }\\n\\n    function hash(IMultiSourceLoan.SignableRepaymentData memory _repaymentData) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                _SIGNABLE_REPAYMENT_DATA_HASH,\\n                _repaymentData.loanId,\\n                keccak256(_repaymentData.callbackData),\\n                _repaymentData.shouldDelegate\\n            )\\n        );\\n    }\\n\\n    function hash(IMultiSourceLoan.Loan memory _loan) internal pure returns (bytes32) {\\n        bytes memory sourceHashes;\\n        for (uint256 i = 0; i < _loan.source.length;) {\\n            sourceHashes = abi.encodePacked(sourceHashes, _hashSource(_loan.source[i]));\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return keccak256(\\n            abi.encode(\\n                _MULTI_SOURCE_LOAN_HASH,\\n                _loan.borrower,\\n                _loan.nftCollateralTokenId,\\n                _loan.nftCollateralAddress,\\n                _loan.principalAddress,\\n                _loan.principalAmount,\\n                _loan.startTime,\\n                _loan.duration,\\n                keccak256(sourceHashes)\\n            )\\n        );\\n    }\\n\\n    function hash(IMultiSourceLoan.RenegotiationOffer memory _refinanceOffer) internal pure returns (bytes32) {\\n        bytes memory encodedPrincipals;\\n        for (uint256 i = 0; i < _refinanceOffer.targetPrincipal.length;) {\\n            encodedPrincipals = abi.encodePacked(encodedPrincipals, _refinanceOffer.targetPrincipal[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return keccak256(\\n            abi.encode(\\n                _MULTI_RENEGOTIATION_OFFER_HASH,\\n                _refinanceOffer.renegotiationId,\\n                _refinanceOffer.loanId,\\n                _refinanceOffer.lender,\\n                _refinanceOffer.fee,\\n                keccak256(encodedPrincipals),\\n                _refinanceOffer.principalAmount,\\n                _refinanceOffer.aprBps,\\n                _refinanceOffer.expirationTime,\\n                _refinanceOffer.duration\\n            )\\n        );\\n    }\\n\\n    function hash(IAuctionLoanLiquidator.Auction memory _auction) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                _AUCTION_HASH,\\n                _auction.loanAddress,\\n                _auction.loanId,\\n                _auction.highestBid,\\n                _auction.triggerFee,\\n                _auction.highestBidder,\\n                _auction.duration,\\n                _auction.asset,\\n                _auction.startTime,\\n                _auction.originator,\\n                _auction.lastBidTime\\n            )\\n        );\\n    }\\n\\n    function _hashSource(IMultiSourceLoan.Source memory _source) private pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                _SOURCE_HASH,\\n                _source.lender,\\n                _source.principalAmount,\\n                _source.accruedInterest,\\n                _source.startTime,\\n                _source.aprBps\\n            )\\n        );\\n    }\\n\\n    function _hashValidator(IBaseLoan.OfferValidator memory _validator) private pure returns (bytes32) {\\n        return keccak256(abi.encode(_VALIDATOR_HASH, _validator.validator, keccak256(_validator.arguments)));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/utils/Interest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"@solmate/utils/FixedPointMathLib.sol\\\";\\nimport \\\"../../interfaces/loans/IMultiSourceLoan.sol\\\";\\nimport \\\"../../interfaces/loans/IBaseLoan.sol\\\";\\n\\nlibrary Interest {\\n    using FixedPointMathLib for uint256;\\n\\n    uint256 private constant _PRECISION = 10000;\\n\\n    uint256 private constant _SECONDS_PER_YEAR = 31536000;\\n\\n    function getInterest(IBaseLoan.LoanOffer memory _loanOffer) internal pure returns (uint256) {\\n        return _getInterest(_loanOffer.principalAmount, _loanOffer.aprBps, _loanOffer.duration);\\n    }\\n\\n    function getInterest(uint256 _amount, uint256 _aprBps, uint256 _duration) internal pure returns (uint256) {\\n        return _getInterest(_amount, _aprBps, _duration);\\n    }\\n\\n    function getTotalOwed(IMultiSourceLoan.Loan memory _loan, uint256 _timestamp) internal pure returns (uint256) {\\n        uint256 owed = 0;\\n        for (uint256 i = 0; i < _loan.source.length;) {\\n            IMultiSourceLoan.Source memory source = _loan.source[i];\\n            owed += source.principalAmount + source.accruedInterest\\n                + _getInterest(source.principalAmount, source.aprBps, _timestamp - source.startTime);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return owed;\\n    }\\n\\n    function _getInterest(uint256 _amount, uint256 _aprBps, uint256 _duration) private pure returns (uint256) {\\n        return _amount.mulDivUp(_aprBps * _duration, _PRECISION * _SECONDS_PER_YEAR);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"../interfaces/IMulticall.sol\\\";\\n\\n/// @title Multicall\\n/// @author Florida St\\n/// @notice Base implementation for multicall.\\nabstract contract Multicall is IMulticall {\\n    function multicall(bytes[] calldata data) external payable override returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        bool success;\\n        for (uint256 i = 0; i < data.length;) {\\n            //slither-disable-next-line calls-loop,delegatecall-loop\\n            (success, results[i]) = address(this).delegatecall(data[i]);\\n            if (!success) revert MulticallFailed(i, results[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/loans/WithCallbacks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"../../interfaces/callbacks/ILoanCallback.sol\\\";\\nimport \\\"./BaseLoan.sol\\\";\\n\\nabstract contract WithCallbacks is BaseLoan {\\n    struct Taxes {\\n        uint128 buyTax;\\n        uint128 sellTax;\\n    }\\n\\n    event WhitelistedCallbackContractAdded(address contractAdded, Taxes tax);\\n\\n    event WhitelistedCallbackContractRemoved(address contractRemoved);\\n\\n    mapping(address => Taxes) private _callbackTaxes;\\n\\n    constructor(string memory _name, address __currencyManager, address __collectionManager)\\n        BaseLoan(_name, __currencyManager, __collectionManager)\\n    {}\\n\\n    /// @notice Add a whitelisted callback contract / update an existing one with different taxes.\\n    /// @param _contract Address of the contract.\\n    function addWhitelistedCallbackContract(address _contract, Taxes calldata _tax) external onlyOwner {\\n        _checkAddressNotZero(_contract);\\n        if (_tax.buyTax > _PRECISION || _tax.sellTax > _PRECISION) {\\n            revert InvalidValueError();\\n        }\\n        _isWhitelistedCallbackContract[_contract] = true;\\n        _callbackTaxes[_contract] = _tax;\\n\\n        emit WhitelistedCallbackContractAdded(_contract, _tax);\\n    }\\n\\n    /// @notice Remove a whitelisted callback contract.\\n    /// @param _contract Address of the contract.\\n    function removeWhitelistedCallbackContract(address _contract) external onlyOwner {\\n        _isWhitelistedCallbackContract[_contract] = false;\\n        delete _callbackTaxes[_contract];\\n\\n        emit WhitelistedCallbackContractRemoved(_contract);\\n    }\\n\\n    /// @return Whether a callback contract is whitelisted\\n    function isWhitelistedCallbackContract(address _contract) external view returns (bool) {\\n        return _isWhitelistedCallbackContract[_contract];\\n    }\\n\\n    /// @notice Handle the afterPrincipalTransfer callback.\\n    /// @param _loan Loan.\\n    /// @param _callbackData Callback data.\\n    /// @param _fee Fee.\\n    /// @return buyTax\\n    function _handleAfterPrincipalTransferCallback(\\n        IMultiSourceLoan.Loan memory _loan,\\n        bytes memory _callbackData,\\n        uint256 _fee\\n    ) internal returns (uint128) {\\n        if (_noCallback(_callbackData)) {\\n            return 0;\\n        }\\n        if (\\n            !_isWhitelistedCallbackContract[msg.sender]\\n                || ILoanCallback(msg.sender).afterPrincipalTransfer(_loan, _fee, _callbackData)\\n                    != ILoanCallback.afterPrincipalTransfer.selector\\n        ) {\\n            revert ILoanCallback.InvalidCallbackError();\\n        }\\n        return _callbackTaxes[msg.sender].buyTax;\\n    }\\n\\n    /// @notice Handle the afterNFTTransfer callback.\\n    /// @param _loan Loan.\\n    /// @param _callbackData Callback data.\\n    /// @return sellTax\\n    function _handleAfterNFTTransferCallback(IMultiSourceLoan.Loan memory _loan, bytes calldata _callbackData)\\n        internal\\n        returns (uint128)\\n    {\\n        if (_noCallback(_callbackData)) {\\n            return 0;\\n        }\\n        if (\\n            !_isWhitelistedCallbackContract[msg.sender]\\n                || ILoanCallback(msg.sender).afterNFTTransfer(_loan, _callbackData)\\n                    != ILoanCallback.afterNFTTransfer.selector\\n        ) {\\n            revert ILoanCallback.InvalidCallbackError();\\n        }\\n        return _callbackTaxes[msg.sender].sellTax;\\n    }\\n\\n    function _noCallback(bytes memory _callbackData) private pure returns (bool) {\\n        return _callbackData.length == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/loans/IBaseLoan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"../../interfaces/ILoanLiquidator.sol\\\";\\n\\n/// @title Interface for Loans.\\n/// @author Florida St\\n/// @notice Basic Loan\\ninterface IBaseLoan {\\n    /// @notice Minimum improvement (in BPS) required for a strict improvement.\\n    /// @param principalAmount Minimum delta of principal amount.\\n    /// @param interest Minimum delta of interest.\\n    /// @param duration Minimum delta of duration.\\n    struct ImprovementMinimum {\\n        uint256 principalAmount;\\n        uint256 interest;\\n        uint256 duration;\\n    }\\n\\n    /// @notice Arbitrary contract to validate offers implementing `IBaseOfferValidator`.\\n    /// @param validator Address of the validator contract.\\n    /// @param arguments Arguments to pass to the validator.\\n    struct OfferValidator {\\n        address validator;\\n        bytes arguments;\\n    }\\n\\n    /// @notice Borrowers receive offers that are then validated.\\n    /// @dev Setting the nftCollateralTokenId to 0 triggers validation through `validators`.\\n    /// @param offerId Offer ID. Used for canceling/setting as executed.\\n    /// @param lender Lender of the offer.\\n    /// @param fee Origination fee.\\n    /// @param borrower Borrower of the offer. Can be set to 0 (any borrower).\\n    /// @param capacity Capacity of the offer.\\n    /// @param nftCollateralAddress Address of the NFT collateral.\\n    /// @param nftCollateralTokenId NFT collateral token ID.\\n    /// @param principalAddress Address of the principal.\\n    /// @param principalAmount Principal amount of the loan.\\n    /// @param aprBps APR in BPS.\\n    /// @param expirationTime Expiration time of the offer.\\n    /// @param duration Duration of the loan in seconds.\\n    /// @param validators Arbitrary contract to validate offers implementing `IBaseOfferValidator`.\\n    struct LoanOffer {\\n        uint256 offerId;\\n        address lender;\\n        uint256 fee;\\n        address borrower;\\n        uint256 capacity;\\n        address nftCollateralAddress;\\n        uint256 nftCollateralTokenId;\\n        address principalAddress;\\n        uint256 principalAmount;\\n        uint256 aprBps;\\n        uint256 expirationTime;\\n        uint256 duration;\\n        OfferValidator[] validators;\\n    }\\n\\n    /// @notice Offer + necessary fields to execute a specific loan. This has a separate expirationTime to avoid\\n    /// someone holding an offer and executing much later, without the borrower's awareness.\\n    /// @param offer Loan offer. It can be executed potentially for multiple ids / amounts < principalAmount.\\n    /// @param tokenId NFT collateral token ID.\\n    /// @param amount The amount the borrower is willing to take (must be <= _loanOffer principalAmount)\\n    /// @param expirationTime Expiration time of the signed offer by the borrower.\\n    /// @param callbackData Data to pass to the callback.\\n    struct ExecutionData {\\n        LoanOffer offer;\\n        uint256 tokenId;\\n        uint256 amount;\\n        uint256 expirationTime;\\n        bytes callbackData;\\n    }\\n\\n    /// @notice Recipient address and fraction of gains charged by the protocol.\\n    struct ProtocolFee {\\n        address recipient;\\n        uint256 fraction;\\n    }\\n\\n    /// @notice Total number of loans issued by this contract.\\n    function getTotalLoansIssued() external view returns (uint256);\\n\\n    /// @notice Cancel offer for `msg.sender`. Each lender has unique offerIds.\\n    /// @param _offerId Offer ID.\\n    function cancelOffer(uint256 _offerId) external;\\n\\n    /// @notice Cancel multiple offers.\\n    /// @param _offerIds Offer IDs.\\n    function cancelOffers(uint256[] calldata _offerIds) external;\\n\\n    /// @notice Cancell all offers with offerId < _minOfferId\\n    /// @param _minOfferId Minimum offer ID.\\n    function cancelAllOffers(uint256 _minOfferId) external;\\n\\n    /// @notice Cancel renegotiation offer. Similar to offers.\\n    /// @param _renegotiationId Renegotiation offer ID.\\n    function cancelRenegotiationOffer(uint256 _renegotiationId) external;\\n\\n    /// @notice Cancel multiple renegotiation offers.\\n    /// @param _renegotiationIds Renegotiation offer IDs.\\n    function cancelRenegotiationOffers(uint256[] calldata _renegotiationIds) external;\\n\\n    /// @notice Cancell all renegotiation offers with renegotiationId < _minRenegotiationId\\n    /// @param _minRenegotiationId Minimum renegotiation offer ID.\\n    function cancelAllRenegotiationOffers(uint256 _minRenegotiationId) external;\\n\\n    /// @return protocolFee The Protocol fee.\\n    function getProtocolFee() external view returns (ProtocolFee memory);\\n\\n    /// @return pendingProtocolFee The pending protocol fee.\\n    function getPendingProtocolFee() external view returns (ProtocolFee memory);\\n\\n    /// @return protocolFeeSetTime Time when the protocol fee was set to be changed.\\n    function getPendingProtocolFeeSetTime() external view returns (uint256);\\n\\n    /// @notice Kicks off the process to update the protocol fee.\\n    /// @param _newProtocolFee New protocol fee.\\n    function updateProtocolFee(ProtocolFee calldata _newProtocolFee) external;\\n\\n    /// @notice Set the protocol fee if enough notice has been given.\\n    function setProtocolFee() external;\\n\\n    /// @return Liquidator contract address\\n    function getLiquidator() external returns (address);\\n\\n    /// @notice Updates the liquidation contract.\\n    /// @param loanLiquidator New liquidation contract.\\n    function updateLiquidationContract(ILoanLiquidator loanLiquidator) external;\\n\\n    /// @notice Updates the auction duration for liquidations.\\n    /// @param _newDuration New auction duration.\\n    function updateLiquidationAuctionDuration(uint48 _newDuration) external;\\n\\n    /// @return auctionDuration Returns the auction's duration for liquidations.\\n    function getLiquidationAuctionDuration() external returns (uint48);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAuctionLoanLiquidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"./loans/IMultiSourceLoan.sol\\\";\\n\\n/// @title Liquidates Collateral for Defaulted Loans using English Auctions.\\n/// @author Florida St\\n/// @notice It liquidates collateral corresponding to defaulted loans\\n///         and sends back the proceeds to the loan contract for distribution.\\ninterface IAuctionLoanLiquidator {\\n    /// @notice The auction struct.\\n    /// @param loanAddress The loan contract address.\\n    /// @param loanId The loan id.\\n    /// @param highestBid The highest bid.\\n    /// @param highestBidder The highest bidder.\\n    /// @param duration The auction duration.\\n    /// @param asset The asset address.\\n    /// @param startTime The auction start time.\\n    /// @param originator The address that triggered the liquidation.\\n    /// @param lastBidTime The last bid time.\\n    struct Auction {\\n        address loanAddress;\\n        uint256 loanId;\\n        uint256 highestBid;\\n        uint256 triggerFee;\\n        address highestBidder;\\n        uint96 duration;\\n        address asset;\\n        uint96 startTime;\\n        address originator;\\n        uint96 lastBidTime;\\n    }\\n\\n    /// @notice Add a loan contract to the list of accepted contracts.\\n    /// @param _loanContract The loan contract to be added.\\n    function addLoanContract(address _loanContract) external;\\n\\n    /// @notice Remove a loan contract from the list of accepted contracts.\\n    /// @param _loanContract The loan contract to be removed.\\n    function removeLoanContract(address _loanContract) external;\\n\\n    /// @return The loan contracts that are accepted by this liquidator.\\n    function getValidLoanContracts() external view returns (address[] memory);\\n\\n    /// @notice Update liquidation distributor.\\n    /// @param _liquidationDistributor The new liquidation distributor.\\n    function updateLiquidationDistributor(address _liquidationDistributor) external;\\n\\n    /// @return liquidationDistributor The liquidation distributor address.\\n    function getLiquidationDistributor() external view returns (address);\\n\\n    /// @notice Called by the owner to update the trigger fee.\\n    /// @param triggerFee The new trigger fee.\\n    function updateTriggerFee(uint256 triggerFee) external;\\n\\n    /// @return triggerFee The trigger fee.\\n    function getTriggerFee() external view returns (uint256);\\n\\n    /// @notice When a bid is placed, the contract takes possesion of the bid, and\\n    ///         if there was a previous bid, it returns that capital to the original\\n    ///         bidder.\\n    /// @param _contract The nft contract address.\\n    /// @param _tokenId The nft id.\\n    /// @param _auction The auction struct.\\n    /// @param _bid The bid amount.\\n    /// @return auction The updated auction struct.\\n    function placeBid(address _contract, uint256 _tokenId, Auction memory _auction, uint256 _bid)\\n        external\\n        returns (Auction memory);\\n\\n    /// @notice On settlement, the NFT is sent to the highest bidder.\\n    ///         Calls loan liquidated for accounting purposes.\\n    /// @param _auction The auction struct.\\n    /// @param _loan The loan struct.\\n    function settleAuction(Auction calldata _auction, IMultiSourceLoan.Loan calldata _loan) external;\\n\\n    /// @notice The contract has hashes of all auctions to save space (not the actual struct)\\n    /// @param _contract The nft contract address.\\n    /// @param _tokenId The nft id.\\n    /// @return auctionHash The auction hash.\\n    function getAuctionHash(address _contract, uint256 _tokenId) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\ninterface IMulticall {\\n    error MulticallFailed(uint256 i, bytes returndata);\\n\\n    /// @notice Call multiple functions in the contract. Revert if one of them fails, return results otherwise.\\n    /// @param data Encoded function calls.\\n    /// @return results The results of the function calls.\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/callbacks/ILoanCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.20;\\n\\nimport \\\"../loans/IMultiSourceLoan.sol\\\";\\n\\ninterface ILoanCallback {\\n    error InvalidCallbackError();\\n\\n    /// @notice Called by the MSL contract after the principal of loan has been tranfered (when a loan is initiated)\\n    /// but before it tries to transfer the NFT into escrow.\\n    /// @param _loan The loan.\\n    /// @param _fee The origination fee.\\n    /// @param _executionData Execution data for purchase.\\n    /// @return The bytes4 magic value.\\n    function afterPrincipalTransfer(IMultiSourceLoan.Loan memory _loan, uint256 _fee, bytes calldata _executionData)\\n        external\\n        returns (bytes4);\\n\\n    /// @notice Call by the MSL contract after the NFT has been transfered to the borrower repaying the loan, but before\\n    /// transfering the principal to the lender.\\n    /// @param _loan The loan.\\n    /// @param _executionData Execution data for the offer.\\n    /// @return The bytes4 magic value.\\n    function afterNFTTransfer(IMultiSourceLoan.Loan memory _loan, bytes calldata _executionData)\\n        external\\n        returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"src/lib/loans/BaseLoan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/utils/cryptography/MessageHashUtils.sol\\\";\\nimport \\\"@openzeppelin/interfaces/IERC1271.sol\\\";\\nimport \\\"@solmate/tokens/ERC721.sol\\\";\\nimport \\\"@solmate/utils/FixedPointMathLib.sol\\\";\\n\\nimport \\\"../AddressManager.sol\\\";\\nimport \\\"../utils/Hash.sol\\\";\\nimport \\\"../../interfaces/loans/IBaseLoan.sol\\\";\\nimport \\\"../../interfaces/validators/IBaseOfferValidator.sol\\\";\\nimport \\\"../InputChecker.sol\\\";\\n\\n/// @title BaseLoan\\n/// @author Florida St\\n/// @notice Base implementation that we expect all loans to share. Offers can either be\\n///         for new loans or renegotiating existing ones.\\n///         Offers are signed off-chain.\\n///         Offers have a nonce associated that is used for cancelling and\\n///         marking as executed.\\nabstract contract BaseLoan is ERC721TokenReceiver, IBaseLoan, InputChecker, Owned {\\n    using FixedPointMathLib for uint256;\\n    using ECDSA for bytes32;\\n    using MessageHashUtils for bytes32;\\n    using Hash for LoanOffer;\\n    using Hash for ExecutionData;\\n\\n    /// @notice Used in compliance with EIP712\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n    bytes32 public immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    uint256 public constant MAX_PROTOCOL_FEE = 2500;\\n    uint256 public constant FEE_UPDATE_NOTICE = 30 days;\\n    uint48 public constant MIN_AUCTION_DURATION = 1 days;\\n    bytes4 private constant MAGICVALUE_1271 = 0x1626ba7e;\\n\\n    /// @notice Precision used for calculating interests.\\n    uint256 internal constant _PRECISION = 10000;\\n\\n    /// @notice Minimum improvement (in BPS) required for a strict improvement.\\n    ImprovementMinimum internal _minimum = ImprovementMinimum(500, 100, 100);\\n\\n    string public name;\\n\\n    /// @notice Duration of the auction when a loan defaults requires a liquidation.\\n    uint48 internal _liquidationAuctionDuration = 3 days;\\n\\n    /// @notice Liquidator used defaulted loans that requires liquidation.\\n    ILoanLiquidator internal _loanLiquidator;\\n\\n    /// @notice Protocol fee charged on gains.\\n    ProtocolFee internal _protocolFee;\\n    /// @notice Set as the target new protocol fee.\\n    ProtocolFee internal _pendingProtocolFee;\\n    /// @notice Set when the protocol fee updating mechanisms starts.\\n    uint256 internal _pendingProtocolFeeSetTime;\\n\\n    /// @notice Total number of loans issued. Given it's a serial value, we use it\\n    ///         as loan id.\\n    uint256 public override getTotalLoansIssued;\\n\\n    /// @notice Offer capacity\\n    mapping(address => mapping(uint256 => uint256)) internal _used;\\n\\n    /// @notice Used for validate off chain maker offers / canceling one\\n    mapping(address => mapping(uint256 => bool)) public isOfferCancelled;\\n    /// @notice Used for validating off chain maker offers / canceling all\\n    mapping(address => uint256) public minOfferId;\\n\\n    /// @notice Used in a similar way as `isOfferCancelled` to handle renegotiations.\\n    mapping(address => mapping(uint256 => bool)) public isRenegotiationOfferCancelled;\\n    /// @notice Used in a similar way as `minOfferId` to handle renegotiations.\\n    mapping(address => uint256) public lenderMinRenegotiationOfferId;\\n\\n    /// @notice Loans are only denominated in whitelisted addresses. Within each struct,\\n    ///         we save those as their `uint` representation.\\n    AddressManager internal immutable _currencyManager;\\n\\n    /// @notice Only whilteslited collections are accepted as collateral. Within each struct,\\n    ///         we save those as their `uint` representation.\\n    AddressManager internal immutable _collectionManager;\\n\\n    /// @notice For security reasons we only allow a whitelisted set of callback contracts.\\n    mapping(address => bool) internal _isWhitelistedCallbackContract;\\n\\n    event OfferCancelled(address lender, uint256 offerId);\\n\\n    event BorrowerOfferCancelled(address borrower, uint256 offerId);\\n\\n    event AllOffersCancelled(address lender, uint256 minOfferId);\\n\\n    event RenegotiationOfferCancelled(address lender, uint256 renegotiationId);\\n\\n    event AllRenegotiationOffersCancelled(address lender, uint256 minRenegotiationId);\\n\\n    event ProtocolFeeUpdated(ProtocolFee fee);\\n\\n    event ProtocolFeePendingUpdate(ProtocolFee fee);\\n\\n    event LoanSentToLiquidator(uint256 loanId, address liquidator);\\n\\n    event LoanLiquidated(uint256 loanId);\\n\\n    event LoanForeclosed(uint256 loanId);\\n\\n    event ImprovementMinimumUpdated(ImprovementMinimum minimum);\\n\\n    event LiquidationContractUpdated(address liquidator);\\n\\n    event LiquidationAuctionDurationUpdated(uint256 newDuration);\\n\\n    error InvalidValueError();\\n\\n    error LiquidatorOnlyError(address _liquidator);\\n\\n    error CancelledOrExecutedOfferError(address _lender, uint256 _offerId);\\n\\n    error CancelledRenegotiationOfferError(address _lender, uint256 _renegotiationId);\\n\\n    error ExpiredOfferError(uint256 _expirationTime);\\n\\n    error ExpiredRenegotiationOfferError(uint256 _expirationTime);\\n\\n    error LowOfferIdError(address _lender, uint256 _newMinOfferId, uint256 _minOfferId);\\n\\n    error LowRenegotiationOfferIdError(address _lender, uint256 _newMinRenegotiationOfferId, uint256 _minOfferId);\\n\\n    error CannotLiquidateError();\\n\\n    error LoanNotDueError(uint256 _expirationTime);\\n\\n    error InvalidLenderError();\\n\\n    error InvalidBorrowerError();\\n\\n    error ZeroDurationError();\\n\\n    error ZeroInterestError();\\n\\n    error InvalidSignatureError();\\n\\n    error InvalidLiquidationError();\\n\\n    error CurrencyNotWhitelistedError();\\n\\n    error CollectionNotWhitelistedError();\\n\\n    error InvalidProtocolFeeError(uint256 _fraction);\\n\\n    error TooEarlyError(uint256 _pendingProtocolFeeSetTime);\\n\\n    error MaxCapacityExceededError();\\n\\n    error InvalidLoanError(uint256 _loanId);\\n\\n    error InvalidCollateralIdError();\\n\\n    error OnlyLenderOrBorrowerCallableError();\\n\\n    error OnlyBorrowerCallableError();\\n\\n    error OnlyLenderCallableError();\\n\\n    error NotStrictlyImprovedError();\\n\\n    error InvalidAmountError(uint256 _amount, uint256 _principalAmount);\\n\\n    error InvalidDurationError();\\n\\n    constructor(string memory _name, address currencyManager, address collectionManager) Owned(tx.origin) {\\n        name = _name;\\n        _checkAddressNotZero(currencyManager);\\n        _checkAddressNotZero(collectionManager);\\n\\n        _currencyManager = AddressManager(currencyManager);\\n        _collectionManager = AddressManager(collectionManager);\\n        _pendingProtocolFeeSetTime = type(uint256).max;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\\n    }\\n\\n    modifier onlyLiquidator() {\\n        if (msg.sender != address(_loanLiquidator)) {\\n            revert LiquidatorOnlyError(address(_loanLiquidator));\\n        }\\n        _;\\n    }\\n\\n    /// @notice Get the domain separator requried to comply with EIP-712.\\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : _computeDomainSeparator();\\n    }\\n\\n    /// @return The minimum improvement for a loan to be considered strictly better.\\n    function getImprovementMinimum() external view returns (ImprovementMinimum memory) {\\n        return _minimum;\\n    }\\n\\n    /// @notice Updates the minimum improvement for a loan to be considered strictly better.\\n    ///         Only the owner can call this function.\\n    /// @param _newMinimum The new minimum improvement.\\n    function updateImprovementMinimum(ImprovementMinimum calldata _newMinimum) external onlyOwner {\\n        _minimum = _newMinimum;\\n\\n        emit ImprovementMinimumUpdated(_newMinimum);\\n    }\\n\\n    /// @return Address of the currency manager.\\n    function getCurrencyManager() external view returns (address) {\\n        return address(_currencyManager);\\n    }\\n\\n    /// @return Address of the collection manager.\\n    function getCollectionManager() external view returns (address) {\\n        return address(_collectionManager);\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function cancelOffer(uint256 _offerId) external {\\n        address user = msg.sender;\\n        isOfferCancelled[user][_offerId] = true;\\n\\n        emit OfferCancelled(user, _offerId);\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function cancelOffers(uint256[] calldata _offerIds) external virtual {\\n        address user = msg.sender;\\n        uint256 total = _offerIds.length;\\n        for (uint256 i = 0; i < total;) {\\n            uint256 offerId = _offerIds[i];\\n            isOfferCancelled[user][offerId] = true;\\n\\n            emit OfferCancelled(user, offerId);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function cancelAllOffers(uint256 _minOfferId) external virtual {\\n        address user = msg.sender;\\n        uint256 currentMinOfferId = minOfferId[user];\\n        if (currentMinOfferId >= _minOfferId) {\\n            revert LowOfferIdError(user, _minOfferId, currentMinOfferId);\\n        }\\n        minOfferId[user] = _minOfferId;\\n\\n        emit AllOffersCancelled(user, _minOfferId);\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function cancelRenegotiationOffer(uint256 _renegotiationId) external virtual {\\n        address lender = msg.sender;\\n        isRenegotiationOfferCancelled[lender][_renegotiationId] = true;\\n\\n        emit RenegotiationOfferCancelled(lender, _renegotiationId);\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function cancelRenegotiationOffers(uint256[] calldata _renegotiationIds) external virtual {\\n        address lender = msg.sender;\\n        uint256 total = _renegotiationIds.length;\\n        for (uint256 i = 0; i < total;) {\\n            uint256 renegotiationId = _renegotiationIds[i];\\n            isRenegotiationOfferCancelled[lender][renegotiationId] = true;\\n\\n            emit RenegotiationOfferCancelled(lender, renegotiationId);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function cancelAllRenegotiationOffers(uint256 _minRenegotiationId) external virtual {\\n        address lender = msg.sender;\\n        uint256 currentMinRenegotiationOfferId = lenderMinRenegotiationOfferId[lender];\\n        if (currentMinRenegotiationOfferId >= _minRenegotiationId) {\\n            revert LowRenegotiationOfferIdError(lender, _minRenegotiationId, currentMinRenegotiationOfferId);\\n        }\\n        lenderMinRenegotiationOfferId[lender] = _minRenegotiationId;\\n\\n        emit AllRenegotiationOffersCancelled(lender, _minRenegotiationId);\\n    }\\n\\n    /// @notice Returns the remaining capacity for a given loan offer.\\n    /// @param _lender The address of the lender.\\n    /// @param _offerId The id of the offer.\\n    /// @return The amount lent out.\\n    function getUsedCapacity(address _lender, uint256 _offerId) external view returns (uint256) {\\n        return _used[_lender][_offerId];\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function getProtocolFee() external view returns (ProtocolFee memory) {\\n        return _protocolFee;\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function getPendingProtocolFee() external view returns (ProtocolFee memory) {\\n        return _pendingProtocolFee;\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function getPendingProtocolFeeSetTime() external view returns (uint256) {\\n        return _pendingProtocolFeeSetTime;\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function setProtocolFee() external onlyOwner {\\n        if (block.timestamp < _pendingProtocolFeeSetTime + FEE_UPDATE_NOTICE) {\\n            revert TooEarlyError(_pendingProtocolFeeSetTime);\\n        }\\n        _protocolFee = _pendingProtocolFee;\\n\\n        emit ProtocolFeeUpdated(_pendingProtocolFee);\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function updateProtocolFee(ProtocolFee calldata _newProtocolFee) external onlyOwner {\\n        if (_newProtocolFee.fraction > MAX_PROTOCOL_FEE) {\\n            revert InvalidProtocolFeeError(_newProtocolFee.fraction);\\n        }\\n        _checkAddressNotZero(_newProtocolFee.recipient);\\n\\n        _pendingProtocolFee = _newProtocolFee;\\n        _pendingProtocolFeeSetTime = block.timestamp;\\n\\n        emit ProtocolFeePendingUpdate(_pendingProtocolFee);\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function getLiquidator() external view returns (address) {\\n        return address(_loanLiquidator);\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function updateLiquidationContract(ILoanLiquidator loanLiquidator) external onlyOwner {\\n        _checkAddressNotZero(address(loanLiquidator));\\n        _loanLiquidator = loanLiquidator;\\n\\n        emit LiquidationContractUpdated(address(loanLiquidator));\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function updateLiquidationAuctionDuration(uint48 _newDuration) external onlyOwner {\\n        if (_newDuration < MIN_AUCTION_DURATION) {\\n            revert InvalidDurationError();\\n        }\\n        _liquidationAuctionDuration = _newDuration;\\n\\n        emit LiquidationAuctionDurationUpdated(_newDuration);\\n    }\\n\\n    /// @inheritdoc IBaseLoan\\n    function getLiquidationAuctionDuration() external view returns (uint48) {\\n        return _liquidationAuctionDuration;\\n    }\\n\\n    /// @notice Call when issuing a new loan to get/set a unique serial id.\\n    /// @dev This id should never be 0.\\n    /// @return The new loan id.\\n    function _getAndSetNewLoanId() internal returns (uint256) {\\n        unchecked {\\n            return ++getTotalLoansIssued;\\n        }\\n    }\\n\\n    /// @notice Base ExecutionData Checks\\n    /// @dev Note that we do not validate fee < principalAmount since this is done in the child class in this case.\\n    /// @param _executionData Loan execution data.\\n    /// @param _lender The lender.\\n    /// @param _borrower The borrower.\\n    /// @param _offerer The offerrer (either lender or borrower)\\n    /// @param _lenderOfferSignature The signature of the lender of LoanOffer.\\n    /// @param _borrowerOfferSignature The signature of the borrower of ExecutionData.\\n    function _validateExecutionData(\\n        ExecutionData calldata _executionData,\\n        address _lender,\\n        address _borrower,\\n        address _offerer,\\n        bytes calldata _lenderOfferSignature,\\n        bytes calldata _borrowerOfferSignature\\n    ) internal {\\n        address lender = _executionData.offer.lender;\\n        address borrower = _executionData.offer.borrower;\\n        LoanOffer calldata offer = _executionData.offer;\\n        uint256 offerId = offer.offerId;\\n\\n        if (msg.sender != _lender) {\\n            _checkSignature(lender, offer.hash(), _lenderOfferSignature);\\n        }\\n        if (msg.sender != _borrower) {\\n            _checkSignature(_borrower, _executionData.hash(), _borrowerOfferSignature);\\n        }\\n\\n        if (block.timestamp > offer.expirationTime) {\\n            revert ExpiredOfferError(offer.expirationTime);\\n        }\\n        if (block.timestamp > _executionData.expirationTime) {\\n            revert ExpiredOfferError(_executionData.expirationTime);\\n        }\\n\\n        if (isOfferCancelled[_offerer][offerId] || (offerId <= minOfferId[_offerer])) {\\n            revert CancelledOrExecutedOfferError(_offerer, offerId);\\n        }\\n\\n        if (_executionData.amount > offer.principalAmount) {\\n            revert InvalidAmountError(_executionData.amount, offer.principalAmount);\\n        }\\n\\n        if (!_currencyManager.isWhitelisted(offer.principalAddress)) {\\n            revert CurrencyNotWhitelistedError();\\n        }\\n        if (!_collectionManager.isWhitelisted(offer.nftCollateralAddress)) {\\n            revert CollectionNotWhitelistedError();\\n        }\\n\\n        if (lender != address(0) && (lender != _lender)) {\\n            revert InvalidLenderError();\\n        }\\n        if (borrower != address(0) && (borrower != _borrower)) {\\n            revert InvalidBorrowerError();\\n        }\\n        if (offer.duration == 0) {\\n            revert ZeroDurationError();\\n        }\\n        if (offer.aprBps == 0) {\\n            revert ZeroInterestError();\\n        }\\n        if ((offer.capacity > 0) && (_used[_offerer][offer.offerId] + _executionData.amount > offer.capacity)) {\\n            revert MaxCapacityExceededError();\\n        }\\n\\n        _checkValidators(offer, _executionData.tokenId);\\n    }\\n\\n    /// @notice Check generic offer validators for a given offer or\\n    ///         an exact match if no validators are given. The validators\\n    ///         check is performed only if tokenId is set to 0.\\n    ///         Having one empty validator is used for collection offers (all IDs match).\\n    /// @param _loanOffer The loan offer to check.\\n    /// @param _tokenId The token ID to check.\\n    function _checkValidators(LoanOffer calldata _loanOffer, uint256 _tokenId) internal {\\n        uint256 offerTokenId = _loanOffer.nftCollateralTokenId;\\n        if (_loanOffer.nftCollateralTokenId != 0) {\\n            if (offerTokenId != _tokenId) {\\n                revert InvalidCollateralIdError();\\n            }\\n        } else {\\n            uint256 totalValidators = _loanOffer.validators.length;\\n            if (totalValidators == 0 && _tokenId != 0) {\\n                revert InvalidCollateralIdError();\\n            } else if ((totalValidators == 1) && (_loanOffer.validators[0].validator == address(0))) {\\n                return;\\n            }\\n            for (uint256 i = 0; i < totalValidators;) {\\n                OfferValidator memory thisValidator = _loanOffer.validators[i];\\n                IBaseOfferValidator(thisValidator.validator).validateOffer(\\n                    _loanOffer, _tokenId, thisValidator.arguments\\n                );\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Check a signature is valid given a hash and signer.\\n    /// @dev Comply with IERC1271 and EIP-712.\\n    function _checkSignature(address _signer, bytes32 _hash, bytes calldata _signature) internal view {\\n        bytes32 offerHash = DOMAIN_SEPARATOR().toTypedDataHash(_hash);\\n\\n        if (_signer.code.length > 0) {\\n            if (IERC1271(_signer).isValidSignature(offerHash, _signature) != MAGICVALUE_1271) {\\n                revert InvalidSignatureError();\\n            }\\n        } else {\\n            address recovered = offerHash.recover(_signature);\\n            if (_signer != recovered) {\\n                revert InvalidSignatureError();\\n            }\\n        }\\n    }\\n\\n    /// @dev Check whether an offer is strictly better than a loan/source.\\n    function _checkStrictlyBetter(\\n        uint256 _offerPrincipalAmount,\\n        uint256 _loanPrincipalAmount,\\n        uint256 _offerEndTime,\\n        uint256 _loanEndTime,\\n        uint256 _offerAprBps,\\n        uint256 _loanAprBps,\\n        uint256 _offerFee\\n    ) internal view {\\n        ImprovementMinimum memory minimum = _minimum;\\n\\n        /// @dev If principal is increased, then we need to check net daily interest is better.\\n        /// interestDelta = (_loanAprBps * _loanPrincipalAmount - _offerAprBps * _offerPrincipalAmount)\\n        /// We already checked that all sources are strictly better.\\n        /// We check that the duration is not decreased or the offer charges a fee.\\n        if (\\n            (\\n                (_offerPrincipalAmount - _loanPrincipalAmount > 0)\\n                    && (\\n                        (_loanAprBps * _loanPrincipalAmount - _offerAprBps * _offerPrincipalAmount).mulDivDown(\\n                            _PRECISION, _loanAprBps * _loanPrincipalAmount\\n                        ) < minimum.interest\\n                    )\\n            ) || (_offerFee > 0) || (_offerEndTime < _loanEndTime)\\n        ) {\\n            revert NotStrictlyImprovedError();\\n        }\\n    }\\n\\n    /// @notice Compute domain separator for EIP-712.\\n    /// @return The domain separator.\\n    function _computeDomainSeparator() private view returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(\\\"2\\\"),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS\\n    }\\n\\n    /**\\n     * @dev The signature derives the `address(0)`.\\n     */\\n    error ECDSAInvalidSignature();\\n\\n    /**\\n     * @dev The signature has an invalid length.\\n     */\\n    error ECDSAInvalidSignatureLength(uint256 length);\\n\\n    /**\\n     * @dev The signature has an S value that is in the upper half order.\\n     */\\n    error ECDSAInvalidSignatureS(bytes32 s);\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\n     * and a bytes32 providing additional information about the error.\\n     *\\n     * If no error is returned, then the address can be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\\n        unchecked {\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\n            return tryRecover(hash, v, r, s);\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError, bytes32) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\n        }\\n\\n        return (signer, RecoverError.NoError, bytes32(0));\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\n     */\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert ECDSAInvalidSignature();\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert ECDSAInvalidSignatureS(errorArg);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/MessageHashUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Strings} from \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\\n *\\n * The library provides methods for generating a hash of a message that conforms to the\\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\\n * specifications.\\n */\\nlibrary MessageHashUtils {\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\"` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\\n     * keccak256, although any bytes32 value can be safely used because the final digest will\\n     * be re-hashed.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\") // 32 is the bytes-length of messageHash\\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x45` (`personal_sign` messages).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `message` with\\n     * `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" + len(message)` and hashing the result. It corresponds with the\\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\\n        return\\n            keccak256(bytes.concat(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", bytes(Strings.toString(message.length)), message));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\\n     * `0x00` (data with intended validator).\\n     *\\n     * The digest is calculated by prefixing an arbitrary `data` with `\\\"\\\\x19\\\\x00\\\"` and the intended\\n     * `validator` address. Then hashing the result.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(hex\\\"19_00\\\", validator, data));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\\n     *\\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\\n     * `\\\\x19\\\\x01` and hashing the result. It corresponds to the hash signed by the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\\n     *\\n     * See {ECDSA-recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, hex\\\"19_01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            digest := keccak256(ptr, 0x42)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"src/lib/AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"@solmate/auth/Owned.sol\\\";\\nimport \\\"@solmate/utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./InputChecker.sol\\\";\\n\\n/// @title AddressManager\\n/// @notice A contract that handles a whitelist of addresses and their indexes.\\n/// @dev We assume no more than 65535 addresses will be added to the directory.\\ncontract AddressManager is InputChecker, Owned, ReentrancyGuard {\\n    event AddressAdded(address address_added);\\n\\n    event AddressRemovedFromWhitelist(address address_removed);\\n\\n    event AddressWhitelisted(address address_whitelisted);\\n\\n    error AddressAlreadyAddedError(address _address);\\n\\n    error AddressNotAddedError(address _address);\\n\\n    mapping(address => uint16) private _directory;\\n\\n    mapping(uint16 => address) private _inverseDirectory;\\n\\n    mapping(address => bool) private _whitelist;\\n\\n    uint16 private _lastAdded;\\n\\n    constructor(address[] memory _original) Owned(tx.origin) {\\n        uint256 total = _original.length;\\n        for (uint256 i; i < total;) {\\n            _add(_original[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice Adds an address to the directory. If it already exists,\\n    ///        reverts. It assumes it's whitelisted.\\n    function add(address _entry) external onlyOwner returns (uint16) {\\n        return _add(_entry);\\n    }\\n\\n    /// @notice Whitelist an address that's already part of the directory.\\n    function addToWhitelist(address _entry) external onlyOwner {\\n        if (_directory[_entry] == 0) {\\n            revert AddressNotAddedError(_entry);\\n        }\\n        _whitelist[_entry] = true;\\n\\n        emit AddressWhitelisted(_entry);\\n    }\\n\\n    /// @notice Removes an address from the whitelist. We still keep it\\n    ///         in the directory since this mapping is relevant across time.\\n    /// @param _entry The address to remove from the whitelist.\\n    function removeFromWhitelist(address _entry) external onlyOwner {\\n        _whitelist[_entry] = false;\\n\\n        emit AddressRemovedFromWhitelist(_entry);\\n    }\\n\\n    /// @param _address The address to get the index for.\\n    /// @return The index for a given address.\\n    function addressToIndex(address _address) external view returns (uint16) {\\n        return _directory[_address];\\n    }\\n\\n    /// @param _index The index to get the address for.\\n    /// @return The address for a given index.\\n    function indexToAddress(uint16 _index) external view returns (address) {\\n        return _inverseDirectory[_index];\\n    }\\n\\n    /// @param _entry The address to check if it's whitelisted.\\n    /// @return Whether the address is whitelisted or not.\\n    function isWhitelisted(address _entry) external view returns (bool) {\\n        return _whitelist[_entry];\\n    }\\n\\n    function _add(address _entry) private returns (uint16) {\\n        _checkAddressNotZero(_entry);\\n        if (_directory[_entry] != 0) {\\n            revert AddressAlreadyAddedError(_entry);\\n        }\\n        unchecked {\\n            ++_lastAdded;\\n        }\\n        _directory[_entry] = _lastAdded;\\n        _inverseDirectory[_lastAdded] = _entry;\\n        _whitelist[_entry] = true;\\n\\n        emit AddressAdded(_entry);\\n\\n        return _lastAdded;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/validators/IBaseOfferValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"../loans/IBaseLoan.sol\\\";\\n\\n/// @title Interface for  Loan Offer Validators.\\n/// @author Florida St\\n/// @notice Verify the given `_offer` is valid for `_tokenId` and `_validatorData`.\\ninterface IBaseOfferValidator {\\n    /// @notice Validate a loan offer.\\n    function validateOffer(IBaseLoan.LoanOffer calldata _offer, uint256 _tokenId, bytes calldata _validatorData)\\n        external;\\n}\\n\"\r\n    },\r\n    \"src/lib/InputChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\n/// @title InputChecker\\n/// @author Florida St\\n/// @notice Some basic input checks.\\nabstract contract InputChecker {\\n    error AddressZeroError();\\n\\n    function _checkAddressNotZero(address _address) internal pure {\\n        if (_address == address(0)) {\\n            revert AddressZeroError();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@solmate/=lib/solmate/src/\",\r\n      \"@zora/=lib/v3/contracts/\",\r\n      \"@chainlink/=lib/chainlink/contracts/src/v0.8/\",\r\n      \"@delegate/=lib/delegate-registry/src/\",\r\n      \"test/=test/\",\r\n      \"@manifoldxyz/=lib/v3/node_modules/@manifoldxyz/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@rari-capital/=lib/v3/node_modules/@rari-capital/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"delegate-registry/=lib/delegate-registry/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"murky/=lib/delegate-registry/lib/murky/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/delegate-registry/lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"v3/=lib/v3/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"viaIR\": true,\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loanLiquidator\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fraction\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseLoan.ProtocolFee\",\"name\":\"protocolFee\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"currencyManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collectionManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxSources\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minLockPeriod\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"delegateRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"flashActionContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AddressZeroError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"CancelledOrExecutedOfferError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_renegotiationId\",\"type\":\"uint256\"}],\"name\":\"CancelledRenegotiationOfferError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotLiquidateError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollectionNotWhitelistedError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CurrencyNotWhitelistedError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_expirationTime\",\"type\":\"uint256\"}],\"name\":\"ExpiredOfferError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_expirationTime\",\"type\":\"uint256\"}],\"name\":\"ExpiredRenegotiationOfferError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExtensionNotAvailableError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_principalAmount\",\"type\":\"uint256\"}],\"name\":\"InvalidAmountError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBorrowerError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCallbackError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCollateralIdError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDurationError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLenderError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLiquidationError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"}],\"name\":\"InvalidLoanError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMethodError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fraction\",\"type\":\"uint256\"}],\"name\":\"InvalidProtocolFeeError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRenegotiationOfferError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidValueError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthMismatchError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidator\",\"type\":\"address\"}],\"name\":\"LiquidatorOnlyError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LoanExpiredError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_expirationTime\",\"type\":\"uint256\"}],\"name\":\"LoanNotDueError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newMinOfferId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOfferId\",\"type\":\"uint256\"}],\"name\":\"LowOfferIdError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newMinRenegotiationOfferId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOfferId\",\"type\":\"uint256\"}],\"name\":\"LowRenegotiationOfferIdError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxCapacityExceededError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minLockPeriod\",\"type\":\"uint256\"}],\"name\":\"MinLockPeriodTooHighError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"returndata\",\"type\":\"bytes\"}],\"name\":\"MulticallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFTNotReturnedError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotStrictlyImprovedError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyBorrowerCallableError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyLenderCallableError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyLenderOrBorrowerCallableError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartialOfferCannotChangeDurationError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartialOfferCannotHaveFeeError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RefinanceFullError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minTimestamp\",\"type\":\"uint256\"}],\"name\":\"SourceCannotBeRefinancedError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sourcePrincipal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanPrincipal\",\"type\":\"uint256\"}],\"name\":\"TargetPrincipalTooLowError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pendingProtocolFeeSetTime\",\"type\":\"uint256\"}],\"name\":\"TooEarlyError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sources\",\"type\":\"uint256\"}],\"name\":\"TooManySourcesError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroDurationError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroInterestError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minOfferId\",\"type\":\"uint256\"}],\"name\":\"AllOffersCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minRenegotiationId\",\"type\":\"uint256\"}],\"name\":\"AllRenegotiationOffersCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"BorrowerOfferCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newdelegateRegistry\",\"type\":\"address\"}],\"name\":\"DelegateRegistryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"Delegated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFlashActionContract\",\"type\":\"address\"}],\"name\":\"FlashActionContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"FlashActionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IBaseLoan.ImprovementMinimum\",\"name\":\"minimum\",\"type\":\"tuple\"}],\"name\":\"ImprovementMinimumUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"LiquidationAuctionDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"LiquidationContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"loan\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LoanEmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLoanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLoanId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"loan\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_extension\",\"type\":\"uint256\"}],\"name\":\"LoanExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"LoanForeclosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"LoanLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"renegotiationId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLoanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLoanId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"loan\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LoanRefinanced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalRepayment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LoanRepaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"LoanSentToLiquidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"MaxSourcesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minLockPeriod\",\"type\":\"uint256\"}],\"name\":\"MinLockPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"}],\"name\":\"OfferCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fraction\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IBaseLoan.ProtocolFee\",\"name\":\"fee\",\"type\":\"tuple\"}],\"name\":\"ProtocolFeePendingUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fraction\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IBaseLoan.ProtocolFee\",\"name\":\"fee\",\"type\":\"tuple\"}],\"name\":\"ProtocolFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"renegotiationId\",\"type\":\"uint256\"}],\"name\":\"RenegotiationOfferCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"RevokeDelegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAdded\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"buyTax\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"sellTax\",\"type\":\"uint128\"}],\"indexed\":false,\"internalType\":\"struct WithCallbacks.Taxes\",\"name\":\"tax\",\"type\":\"tuple\"}],\"name\":\"WhitelistedCallbackContractAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractRemoved\",\"type\":\"address\"}],\"name\":\"WhitelistedCallbackContractRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_UPDATE_NOTICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PROTOCOL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_AUCTION_DURATION\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"buyTax\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"sellTax\",\"type\":\"uint128\"}],\"internalType\":\"struct WithCallbacks.Taxes\",\"name\":\"_tax\",\"type\":\"tuple\"}],\"name\":\"addWhitelistedCallbackContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minOfferId\",\"type\":\"uint256\"}],\"name\":\"cancelAllOffers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minRenegotiationId\",\"type\":\"uint256\"}],\"name\":\"cancelAllRenegotiationOffers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"cancelOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_offerIds\",\"type\":\"uint256[]\"}],\"name\":\"cancelOffers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_renegotiationId\",\"type\":\"uint256\"}],\"name\":\"cancelRenegotiationOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_renegotiationIds\",\"type\":\"uint256[]\"}],\"name\":\"cancelRenegotiationOffers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"loan\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_rights\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"capacity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"arguments\",\"type\":\"bytes\"}],\"internalType\":\"struct IBaseLoan.OfferValidator[]\",\"name\":\"validators\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IBaseLoan.LoanOffer\",\"name\":\"offer\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callbackData\",\"type\":\"bytes\"}],\"internalType\":\"struct IBaseLoan.ExecutionData\",\"name\":\"executionData\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"lenderOfferSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"borrowerOfferSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct IMultiSourceLoan.LoanExecutionData\",\"name\":\"_executionData\",\"type\":\"tuple\"}],\"name\":\"emitLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"_loan\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"executeFlashAction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"_loan\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_extension\",\"type\":\"uint256\"}],\"name\":\"extendLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollectionManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrencyManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDelegateRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFlashActionContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImprovementMinimum\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseLoan.ImprovementMinimum\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidationAuctionDuration\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"}],\"name\":\"getLoanHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxSources\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinLockPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanPrincipal\",\"type\":\"uint256\"}],\"name\":\"getMinSourcePrincipal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingProtocolFee\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fraction\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseLoan.ProtocolFee\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingProtocolFeeSetTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolFee\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fraction\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseLoan.ProtocolFee\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalLoansIssued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"getUsedCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isOfferCancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isRenegotiationOfferCancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"isWhitelistedCallbackContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lenderMinRenegotiationOfferId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"_loan\",\"type\":\"tuple\"}],\"name\":\"liquidateLoan\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"_loan\",\"type\":\"tuple\"}],\"name\":\"loanLiquidated\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minOfferId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"renegotiationId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"targetPrincipal\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.RenegotiationOffer\",\"name\":\"_renegotiationOffer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"_loan\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_renegotiationOfferSignature\",\"type\":\"bytes\"}],\"name\":\"refinanceFull\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"renegotiationId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"targetPrincipal\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.RenegotiationOffer\",\"name\":\"_renegotiationOffer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"_loan\",\"type\":\"tuple\"}],\"name\":\"refinancePartial\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"removeWhitelistedCallbackContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callbackData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"shouldDelegate\",\"type\":\"bool\"}],\"internalType\":\"struct IMultiSourceLoan.SignableRepaymentData\",\"name\":\"data\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprBps\",\"type\":\"uint256\"}],\"internalType\":\"struct IMultiSourceLoan.Source[]\",\"name\":\"source\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMultiSourceLoan.Loan\",\"name\":\"loan\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"borrowerSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct IMultiSourceLoan.LoanRepaymentData\",\"name\":\"_repaymentData\",\"type\":\"tuple\"}],\"name\":\"repayLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"revokeDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDelegateRegistry\",\"type\":\"address\"}],\"name\":\"setDelegateRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFlashActionContract\",\"type\":\"address\"}],\"name\":\"setFlashActionContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"__maxSources\",\"type\":\"uint256\"}],\"name\":\"setMaxSources\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"__minLockPeriod\",\"type\":\"uint256\"}],\"name\":\"setMinLockPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseLoan.ImprovementMinimum\",\"name\":\"_newMinimum\",\"type\":\"tuple\"}],\"name\":\"updateImprovementMinimum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"_newDuration\",\"type\":\"uint48\"}],\"name\":\"updateLiquidationAuctionDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILoanLiquidator\",\"name\":\"loanLiquidator\",\"type\":\"address\"}],\"name\":\"updateLiquidationContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fraction\",\"type\":\"uint256\"}],\"internalType\":\"struct IBaseLoan.ProtocolFee\",\"name\":\"_newProtocolFee\",\"type\":\"tuple\"}],\"name\":\"updateProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MultiSourceLoan", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "00000000000000000000000097d34635b605c2f1630d6b4c6c5d222b8a2ca47d000000000000000000000000d07a25e6a22e9158162699490aa6a9464e14c50a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000004150ded32a6d3bfecae76e7558af48019034492700000000000000000000000052ac424ef7b283aa5badb8c6254832e3280d7398000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000447e69651d841bd8d104bed4930000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://eba2315c8271639a56006b67768be0c0c6e366fb6841900f2b4b05edcbe1d258"}