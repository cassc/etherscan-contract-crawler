{"SourceCode": "/// SPDX-License-Identifier: MIT\r\n// File: @openzeppelin/contracts/utils/math/SignedMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n    /**\r\n     * @dev Returns the largest of two signed numbers.\r\n     */\r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two signed numbers.\r\n     */\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two signed numbers without overflow.\r\n     * The result is rounded towards zero.\r\n     */\r\n    function average(int256 a, int256 b) internal pure returns (int256) {\r\n        // Formula from the book \"Hacker's Delight\"\r\n        int256 x = (a & b) + ((a ^ b) >> 1);\r\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the absolute unsigned value of a signed value.\r\n     */\r\n    function abs(int256 n) internal pure returns (uint256) {\r\n        unchecked {\r\n            // must be unchecked in order to support `n = type(int256).min`\r\n            return uint256(n >= 0 ? n : -n);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/Math.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Muldiv operation overflow.\r\n     */\r\n    error MathOverflowedMulDiv();\r\n\r\n    enum Rounding {\r\n        Floor, // Toward negative infinity\r\n        Ceil, // Toward positive infinity\r\n        Trunc, // Toward zero\r\n        Expand // Away from zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds towards infinity instead\r\n     * of rounding towards zero.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b == 0) {\r\n            // Guarantee the same behavior as in a regular Solidity division.\r\n            return a / b;\r\n        }\r\n\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\r\n     * denominator == 0.\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\r\n     * Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            if (denominator <= prod1) {\r\n                revert MathOverflowedMulDiv();\r\n            }\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\r\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            uint256 twos = denominator & (0 - denominator);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\r\n            // works in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\r\n     * towards zero.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\r\n     */\r\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\r\n        return uint8(rounding) % 2 == 1;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\r\n    uint8 private constant ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev The `value` string doesn't fit in the specified `length`.\r\n     */\r\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toStringSigned(int256 value) internal pure returns (string memory) {\r\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        uint256 localValue = value;\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\r\n            localValue >>= 4;\r\n        }\r\n        if (localValue != 0) {\r\n            revert StringsInsufficientHexLength(value, length);\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\r\n     * representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two strings are equal.\r\n     */\r\n    function equal(string memory a, string memory b) internal pure returns (bool) {\r\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\r\n     * reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/interfaces/IERC721Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/ERC404C.sol\r\npragma solidity ^0.8.21;\r\n\r\n/**\r\n * @title ERC404C: Advanced ERC404 Standard for Gas-Efficient Hybrid Tokens\r\n * @dev Extends {Ownable} from OpenZeppelin for ownership management.\r\n * \r\n * ERC404C enhances the ERC404 framework by introducing optimizations and features that \r\n * aim to improve gas efficiency and expand functionality. It retains the innovative \r\n * combination of ERC20 and ERC721 token features, supporting liquidity, fractional \r\n * ownership, and seamless interoperability within the Ethereum ecosystem.\r\n * \r\n * Core Features Inherited from ERC404:\r\n * - Hybrid Functionality: Continues the integration of ERC20 fractionalization with ERC721 \r\n *   uniqueness, facilitating a versatile environment for tokens with dual characteristics.\r\n * - FILO Queue for NFT Spending: Preserves the First-In-Last-Out (FILO) mechanism for managing \r\n *   NFT usage in ERC20 transactions, ensuring a consistent and user-friendly approach.\r\n * \r\n * Unique Enhancements in ERC404C:\r\n * - Gas Efficiency: Introduces advanced storage optimization and token ID recycling techniques\r\n *   to significantly reduce gas consumption beyond the original ERC404 standard. By refining\r\n *   the storage structure and limiting the need for new token ID generation, ERC404C sets a \r\n *   new benchmark for contract efficiency.\r\n * - Customizable Burn Priority: Implements the `setLastOwnedTokenId(tokenId)` function, granting \r\n *   users the ability to determine the priority of NFTs to be burned within the FILO queue, thus \r\n *   offering strategic control over their digital assets.\r\n * - ERC20-Only Interaction Mode: Adds the `setWhitelist()` functionality, allowing users \r\n *   to opt for an ERC20-exclusive interaction mode. This irreversible setting optimizes gas fees \r\n *   for ERC20 transactions and prevents the wallet from engaging in ERC721 token receptions, \r\n *   emphasizing a streamlined focus on ERC20 token transactions.\r\n * \r\n * Implementation Considerations:\r\n * - Token ID Recycling: Emphasizes the efficient reuse of token IDs within the 2^32 collection size \r\n *   limit to maintain high levels of gas efficiency.\r\n * - Storage Optimization: Encodes token details into a single 256-bit word, drastically cutting \r\n *   storage costs and improving contract performance.\r\n * - Decimal Precision: Maintains the 18 decimal precision for ERC20 fractions, enabling precise \r\n *   and flexible token interactions.\r\n * \r\n * Note: ERC404C represents a significant advancement of the ERC404 standard, incorporating \r\n * experimental features to enhance efficiency and utility. Developers and users are encouraged \r\n * to conduct extensive testing in various settings to fully evaluate its capabilities and \r\n * compatibility with diverse applications.\r\n */\r\n\r\n\r\n\r\n abstract contract ERC404C is Ownable {\r\n\r\n    // Compiler will pack this into a single 256bit word.\r\n    struct TokenDetail {\r\n        // The address of the owner.\r\n        address owner;              \r\n        // Mapping from TokenID to index in _allToken list\r\n        uint32  allTokensIndex;     \r\n        // Mapping from TokenID to index in _ownedTokens list\r\n        uint32  ownedTokensIndex;   \r\n        // Reserved for other used;\r\n        bytes4  aux;    \r\n    }\r\n\r\n    // Events\r\n    event ERC20Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 amount\r\n    );\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed id\r\n    );\r\n    event ERC721Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 indexed id\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    // Errors\r\n    error NotFound();\r\n    error AlreadyExists();\r\n    error InvalidRecipient();\r\n    error InvalidSender();\r\n    error UnsafeRecipient();\r\n    error Unauthorized();\r\n\r\n    // Metadata\r\n    /// @dev Token name\r\n    string public name;\r\n\r\n    /// @dev Token symbol\r\n    string public symbol;\r\n\r\n    /// @dev Decimals for fractional representation\r\n    uint8 public immutable decimals;\r\n\r\n    /// @dev Decimals for conversion between fractional representation and native represetation\r\n    uint8 public immutable nativeDecimals;\r\n\r\n    /// @dev Total supply in fractionalized representation\r\n    uint256 public immutable totalSupply;\r\n\r\n    /// @dev Total native supply \r\n    uint256 public immutable totalNativeSupply;\r\n\r\n    /// @dev Current mint counter, monotonically increasing to ensure accurate ownership\r\n    uint256 public minted;\r\n\r\n    // Mappings\r\n    // @dev Mapping from token ID to token Detail \r\n    mapping(uint256 => TokenDetail) private _tokenDetail;\r\n\r\n    // @dev Mapping from owner to list of owned token IDs\r\n    mapping(address => uint32[]) private _ownedTokens;\r\n\r\n    /// @dev Balance of user in fractional representation\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    /// @dev Allowance of user in fractional representation\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /// @dev Approval in native representaion\r\n    mapping(uint256 => address) public getApproved;\r\n\r\n    /// @dev Approval for all in native representation\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n     /// @dev Addresses whitelisted from minting / burning for gas savings (pairs, routers, etc)\r\n    mapping(address => bool) public whitelist;\r\n   \r\n    // @dev Array with all token ids, used for enumeration\r\n    uint32[] private _allTokens; \r\n    uint32[] private _burntTokens;\r\n\r\n    // Constructor\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        uint8 _nativeDecimals,\r\n        uint256 _totalNativeSupply,\r\n        address _owner\r\n    ) Ownable(_owner) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        nativeDecimals = _nativeDecimals;\r\n        totalNativeSupply = _totalNativeSupply;\r\n        totalSupply = _totalNativeSupply * (10 ** nativeDecimals);\r\n        setWhitelist(_owner,true);\r\n        setWhitelist(address(0), true);\r\n    }\r\n\r\n    function _setWhiteList(address target, bool state) internal {\r\n        if (!whitelist[target] && state) {\r\n            whitelist[target] = true;\r\n            uint256 tokens_to_burn = balanceOf[target] / _getUnit();\r\n            for (uint i = 0; i < tokens_to_burn; i++) {\r\n                _burn(target);\r\n            }\r\n        } else if (whitelist[target] && !state) {\r\n            whitelist[target] = false;\r\n            uint256 tokens_to_mint = balanceOf[target] / _getUnit();\r\n            for (uint i = 0; i < tokens_to_mint; i++) {\r\n                _mint(target);\r\n            }\r\n        }    \r\n    }\r\n\r\n    /// @notice Initialization function to set pairs / etc\r\n    ///         saving gas by avoiding mint / burn on unnecessary targets\r\n    function setWhitelist(address target, bool state) public onlyOwner {\r\n        _setWhiteList(target, state);\r\n    }\r\n\r\n    /// @notice Allows a user to select mode for the wallet.\r\n    uint256 immutable whitelist_reset_cooldown = 10000; \r\n    mapping (address => uint256)  private _last_whitelist_reset_block; \r\n    function setWhitelist(bool state) public {   \t\r\n        if (!state && whitelist[msg.sender]) {\r\n            uint256 time_from_last_reset = block.number - _last_whitelist_reset_block[msg.sender];\r\n            require (time_from_last_reset > whitelist_reset_cooldown, \"Whitelsit cool down period is not ended\");\r\n            _last_whitelist_reset_block[msg.sender] = block.number;\r\n        }\r\n        _setWhiteList(msg.sender, state);\r\n    }\r\n\r\n    /// @notice Function to find owner of a given native token\r\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\r\n        owner = _tokenDetail[id].owner;\r\n        if (owner == address(0)) {\r\n            revert NotFound();\r\n        }\r\n    }\r\n\r\n    /// @notice tokenURI must be implemented by child contract\r\n    function tokenURI(uint256 id) public view virtual returns (string memory);\r\n\r\n    /// @notice Function for token approvals\r\n    /// @dev This function assumes id / native if amount less than or equal to current max id\r\n    function approve(\r\n        address spender,\r\n        uint256 amountOrId\r\n    ) public virtual returns (bool) {\r\n        if (amountOrId <= minted && amountOrId > 0) {\r\n            address owner = _tokenDetail[amountOrId].owner; \r\n\r\n            if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) {\r\n                revert Unauthorized();\r\n            }\r\n\r\n            getApproved[amountOrId] = spender;\r\n\r\n            emit Approval(owner, spender, amountOrId);\r\n        } else {\r\n            allowance[msg.sender][spender] = amountOrId;\r\n\r\n            emit Approval(msg.sender, spender, amountOrId);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Function native approvals\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /// @notice Function for mixed transfers\r\n    /// @dev This function assumes id / native if amount less than or equal to current max id\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amountOrId\r\n    ) public virtual {\r\n        if (amountOrId <= totalNativeSupply) {\r\n\r\n            // This is a ERC721 Transfer\r\n            if (from != _tokenDetail[amountOrId].owner) {\r\n                revert InvalidSender();\r\n            }\r\n\r\n            if (to == address(0) || whitelist[to]) { \r\n                revert InvalidRecipient();\r\n            }\r\n\r\n            if (\r\n                msg.sender != from &&\r\n                !isApprovedForAll[from][msg.sender] &&\r\n                msg.sender != getApproved[amountOrId]\r\n            ) {\r\n                revert Unauthorized();\r\n            }\r\n\r\n            balanceOf[from] -= _getUnit();\r\n\r\n            unchecked {\r\n                balanceOf[to] += _getUnit();\r\n            }\r\n\r\n            delete getApproved[amountOrId];\r\n\r\n            _tokenDetail[amountOrId].owner = to;\r\n        \r\n            // _removeTokenFromOwnerEnumeration(from, tokenId);        \r\n            uint32[] storage fromTokenList = _ownedTokens[from];\r\n            TokenDetail storage tokenDetail = _tokenDetail[amountOrId];\r\n            uint32 tokenIndex = tokenDetail.ownedTokensIndex;\r\n            uint32 lastToken = fromTokenList[fromTokenList.length - 1];\r\n            fromTokenList[tokenIndex] = lastToken;\r\n            _tokenDetail[lastToken].ownedTokensIndex = tokenIndex;\r\n            fromTokenList.pop();\r\n\r\n            // _addTokenToOwnerEnumeration(to, tokenId);\r\n            uint32[] storage toTokenList = _ownedTokens[to];\r\n            tokenDetail.ownedTokensIndex = uint32(toTokenList.length);\r\n            toTokenList.push(uint32(amountOrId));\r\n    \r\n            emit Transfer(from, to, amountOrId);\r\n            emit ERC20Transfer(from, to, _getUnit());\r\n        } else {\r\n            uint256 allowed = allowance[from][msg.sender];\r\n\r\n            if (allowed != type(uint256).max)\r\n                allowance[from][msg.sender] = allowed - amountOrId;\r\n\r\n            _transfer(from, to, amountOrId);\r\n        }\r\n    }\r\n\r\n    /// @notice Function for fractional transfers\r\n    function transfer(\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        return _transfer(msg.sender, to, amount);\r\n    }\r\n\r\n    /// @notice Function for native transfers with contract support\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id\r\n    ) public virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        if (\r\n            to.code.length != 0 &&\r\n            IERC721Receiver(to).onERC721Received(msg.sender, from, id, \"\") !=\r\n            IERC721Receiver.onERC721Received.selector\r\n        ) {\r\n            revert UnsafeRecipient();\r\n        }\r\n    }\r\n\r\n    /// @notice Function for native transfers with contract support and callback data\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        bytes calldata data\r\n    ) public virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        if (\r\n            to.code.length != 0 &&\r\n            IERC721Receiver(to).onERC721Received(msg.sender, from, id, data) !=\r\n            IERC721Receiver.onERC721Received.selector\r\n        ) {\r\n            revert UnsafeRecipient();\r\n        }\r\n    }\r\n\r\n    /// @notice Internal function for fractional transfers\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        uint256 unit = _getUnit();\r\n        uint256 balanceBeforeSender = balanceOf[from];\r\n        uint256 balanceBeforeReceiver = balanceOf[to];\r\n\r\n        _beforeTransfer(from, to, amount);\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        // Skip burn for certain addresses to save gas\r\n        if (!whitelist[from]) {\r\n            uint256 tokens_to_burn = (balanceBeforeSender / unit) - (balanceOf[from] / unit);\r\n            for (uint256 i = 0; i < tokens_to_burn; i++) {\r\n                _burn(from);\r\n            }\r\n        }\r\n\r\n        // Skip minting for certain addresses to save gas\r\n        if (!whitelist[to]) {\r\n            uint256 tokens_to_mint = (balanceOf[to] / unit) - (balanceBeforeReceiver / unit);\r\n            for (uint256 i = 0; i < tokens_to_mint; i++) {\r\n                _mint(to);\r\n            }\r\n        }\r\n\r\n        emit ERC20Transfer(from, to, amount);\r\n\r\n        _afterTransfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Internal utility logic\r\n    function _getUnit() internal view returns (uint256) {\r\n        return 10 ** nativeDecimals;\r\n    }\r\n\r\n    // get next tokenId for _mint\r\n    function _getNextTokenId() internal virtual returns (uint256) {\r\n        uint tokenId = minted;\r\n       if (tokenId > totalNativeSupply) {\r\n            // random tokenId from _burntToken\r\n            require (_burntTokens.length > 0, \"There is no available ID for minting\");\r\n            \r\n            uint256 slot = uint(keccak256(abi.encodePacked(minted,block.number))) % _burntTokens.length;\r\n\r\n            tokenId = _burntTokens[slot];\r\n\r\n            _burntTokens[slot] = _burntTokens[_burntTokens.length - 1];\r\n            _burntTokens.pop();             \r\n        } \r\n        return tokenId;\r\n    }\r\n\r\n    // befor_mint\r\n    function _afterMint(uint tokenId) internal virtual  { }\r\n    \r\n    function _beforeBurn(uint tokenId) internal virtual {\r\n        delete getApproved[tokenId];\r\n    }\r\n    function _afterBurn(uint tokenId) internal virtual { \r\n        _burntTokens.push(uint32(tokenId));\r\n    }\r\n    \r\n    function _beforeTransfer(address from, address to, uint256 amount) internal virtual {}\r\n    function _afterTransfer(address from, address to, uint256 amount) internal virtual {}\r\n\r\n\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n       if (to == address(0) || whitelist[to]) {\r\n            revert InvalidRecipient();\r\n        }\r\n\r\n        unchecked {\r\n            minted++;\r\n        }\r\n\r\n        if (_tokenDetail[tokenId].owner != address(0)) {\r\n            revert AlreadyExists();\r\n        }\r\n\r\n        uint32[] storage toTokenList = _ownedTokens[to];\r\n        TokenDetail storage tokenDetail = _tokenDetail[tokenId];\r\n\r\n        tokenDetail.owner = to;        \r\n        tokenDetail.ownedTokensIndex = uint32(toTokenList.length);\r\n        tokenDetail.allTokensIndex = uint32(_allTokens.length);\r\n\r\n        toTokenList.push(uint32(tokenId));\r\n        _allTokens.push(uint32(tokenId));\r\n\r\n        _afterMint(tokenId);                           \r\n \r\n        emit Transfer(address(0), to, tokenId); \r\n    }\r\n\r\n    function _mint(address to) internal virtual {\r\n        if (to == address(0) || whitelist[to]) {\r\n            revert InvalidRecipient();\r\n        }\r\n\r\n        unchecked {\r\n            minted++;\r\n        }\r\n\r\n        uint256 tokenId = _getNextTokenId();\r\n\r\n        // This cannot happend\r\n        if (_tokenDetail[tokenId].owner != address(0)) {\r\n            revert AlreadyExists();\r\n        }\r\n\r\n        uint32[] storage toTokenList = _ownedTokens[to];\r\n        TokenDetail storage tokenDetail = _tokenDetail[tokenId];\r\n\r\n        tokenDetail.owner = to;        \r\n        tokenDetail.ownedTokensIndex = uint32(toTokenList.length);\r\n        tokenDetail.allTokensIndex = uint32(_allTokens.length);\r\n\r\n        toTokenList.push(uint32(tokenId));\r\n        _allTokens.push(uint32(tokenId));\r\n\r\n        _afterMint(tokenId);                           \r\n \r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internally burns a token from a given owner's balance. This function removes the last\r\n     * token owned by the specified address, clears any approvals for this token, and updates the\r\n     * contract's internal state to reflect the burn. It is designed to support token management\r\n     * policies by allowing tokens to be effectively removed from circulation.\r\n     * \r\n     * The function performs several key operations:\r\n     * - Validates that the `from` address is not the zero address, to prevent burning from an\r\n     *   invalid address.\r\n     * - Clears the approval for the token being burned to ensure it cannot be transferred post-burn.\r\n     * - Updates internal mappings and arrays to remove the token from the owner's list of tokens\r\n     *   and the contract's overall enumeration of tokens.\r\n     * - Adjusts the token's details to reflect that it no longer has an owner and is no longer\r\n     *   part of the active token set.\r\n     * \r\n     * This mechanism is essential for maintaining the integrity of the token ownership and\r\n     * supply, allowing for tokens to be retired or removed in response to specific conditions\r\n     * or rules defined by the contract.\r\n     *\r\n     * @param from The address of the token owner from which the token will be burned. This address\r\n     * must currently own at least one token, and cannot be the zero address.\r\n     *\r\n     */\r\n    function _burn(address from) internal virtual {\r\n        if (from == address(0)) {\r\n            revert InvalidSender();\r\n        }\r\n\r\n        // Clear approvals\r\n        uint256 tokenId = _ownedTokens[from][_ownedTokens[from].length - 1];\r\n\r\n        _beforeBurn(tokenId);\r\n\r\n        TokenDetail storage tokenDetail = _tokenDetail[tokenId];\r\n        uint32[] storage fromTokenList = _ownedTokens[from];\r\n                \r\n        uint32 tokenIndex = tokenDetail.ownedTokensIndex;\r\n        uint32 lastToken = fromTokenList[fromTokenList.length - 1];\r\n        if (lastToken != tokenId) {\r\n            fromTokenList[tokenIndex] = lastToken;\r\n            _tokenDetail[lastToken].ownedTokensIndex = tokenIndex;\r\n        }\r\n        fromTokenList.pop();\r\n        \r\n        // _removeTokenFromALLTokensEnumeration\r\n        uint32 lastAllToken = _allTokens[_allTokens.length - 1];\r\n        uint32 allTokensIndex = tokenDetail.allTokensIndex;\r\n        _allTokens[allTokensIndex] = lastAllToken;\r\n        _tokenDetail[lastAllToken].allTokensIndex = allTokensIndex;\r\n\r\n        tokenDetail.owner  = address(0);       \r\n        tokenDetail.allTokensIndex = 0;\r\n        tokenDetail.ownedTokensIndex = 0;\r\n        \r\n        _allTokens.pop();\r\n\r\n        _afterBurn(tokenId);\r\n\r\n        emit Transfer(from, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _tokenDetail[tokenId].owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether 'tokenId' valid.\r\n     *\r\n     * TokenId must be fit inside uint32 (i.e. < 2**32) and between 1 and totalNativeSize\r\n     *\r\n     */\r\n    function _valid(uint256 tokenId) internal view virtual returns (bool) {\r\n        return (tokenId < 2**32) && (tokenId > 0) && (tokenId <= totalNativeSupply);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of active ERC721 token currently in circulation within the contract.\r\n     *\r\n     * This count excludes any tokens that have been burned, providing a precise measure of the\r\n     * net supply of ERC721 tokens that remain valid and owned by addresses.\r\n     */\r\n    function totalERC721Supply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the balance of ERC721 tokens owned by a specified address. This function\r\n    * calculates the owner's token balance based on the assumption that each token is \r\n    * represented as a unit in a larger balance, factoring in the contract's defined unit size.\r\n    * It is designed to provide compatibility with ERC721's standard `balanceOf` function by\r\n    * adapting it to a hybrid token model where ownership might be fractionalized or represented\r\n    * differently.\r\n    *\r\n    * If the owner's address is whitelisted, this function returns 0, under the assumption that\r\n    * whitelisted addresses cannot hold ERC721 token and only interct with ERC20 token.\r\n    *\r\n    * @param owner The address to query the balance of ERC721 tokens for.\r\n    * @return uint256 The number of ERC721 tokens owned by the specified address. This balance\r\n    * is calculated by dividing the total balance (which may represent fractional ownership in\r\n    * the contract) by the defined unit size, excluding whitelisted addresses by returning 0 for them.\r\n    */\r\n    function ERC721BalanceOf(address owner) public view returns (uint256) {\r\n        return whitelist[owner] ? 0 : (balanceOf[owner] / _getUnit());\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the token ID at a specific index of the tokens owned by a given address.\r\n    * This function is essential for enumerating tokens owned by an address when order or\r\n    * specific positioning of tokens is relevant. It allows for ordered access to an owner's\r\n    * tokens, facilitating operations like displaying tokens in a UI or performing actions on\r\n    * specific tokens based on their order in the owner's collection.\r\n    *\r\n    * The function checks that the requested index is valid for the owner's balance of tokens\r\n    * to prevent out-of-bounds access. This ensures that only existing tokens are queried,\r\n    * safeguarding against invalid requests and potential errors in calling contracts or \r\n    * applications.\r\n    *\r\n    * @param owner The address whose tokens are being queried. This address is used to identify\r\n    * the collection of tokens owned within the contract.\r\n    * @param index The zero-based index of the token to retrieve from the owner's list of tokens.\r\n    * This index must be less than the total number of tokens owned by the address, as returned\r\n    * by `ERC721BalanceOf`.\r\n    * @return uint256 The token ID located at the specified index within the owner's list of tokens.\r\n    * This ID represents a specific token owned by the address and can be used for further\r\n    * interactions or queries related to that token.\r\n    *\r\n    * Requirements:\r\n    * - The `index` must be within the range of the total tokens owned by the `owner`, as\r\n    *   determined by `ERC721BalanceOf`. If the index is out of bounds, the function reverts\r\n    *   with an \"Owner index out of bounds\" error.\r\n    */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n        require(index < ERC721BalanceOf(owner), \"Owner index out of bounds\");\r\n        return uint256(_ownedTokens[owner][index]);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Retrieves a list of ERC721 token IDs owned by a specified address. This function provides\r\n    * a comprehensive view of all active tokens currently associated with the owner's address,\r\n    * enabling external entities to query and interact with token ownership information.\r\n    *\r\n    * This is particularly useful for interfaces and applications that require a complete\r\n    * inventory of an address's holdings within this contract, such as wallets, marketplaces,\r\n    * or analytics tools. By returning an array of token IDs, it allows for easy integration\r\n    * and manipulation in client-side applications or other smart contracts that may need to\r\n    * interact with owned tokens.\r\n    *\r\n    * @param owner The address of the token owner whose token IDs are being queried.\r\n    * @return uint256[] An array containing the IDs of all tokens owned by the specified address.\r\n    * The array is dynamically sized based on the owner's current balance of tokens, ensuring\r\n    * an accurate and up-to-date listing of ownership.\r\n    */\r\n    function ownedBy(address owner) external view returns (uint256[] memory) {        \r\n        uint256 balance = ERC721BalanceOf(owner);              \r\n        uint256[] memory tokens = new uint256[](balance);\r\n        uint32[] storage ownedTokens = _ownedTokens[owner];\r\n        for (uint256 i=0; i < balance; i++) {\r\n            tokens[i] = uint256(ownedTokens[i]);\r\n        }\r\n        return tokens;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets a specific token as the last owned token for the calling user, affecting the order\r\n    * in which tokens are considered for burning due to the FILO (First-In-Last-Out) queue mechanism.\r\n    * This function allows users to strategically select which NFT will be burned first in transactions\r\n    * that involve token consumption.\r\n    * \r\n    * The operation swaps the positions of the specified token and the current last token in the user's\r\n    * ownership list. This is particularly useful in scenarios where the user wishes to preserve certain\r\n    * NFTs from being burned in the immediate next transaction that triggers a burn.\r\n    * \r\n    * Requirements:\r\n    * - The caller must be the owner of the `tokenId` specified.\r\n    * - `tokenId` must represent a valid and owned NFT within the contract.\r\n    * \r\n    * @param tokenId The unique identifier of the token to set as the last owned token. This token\r\n    * will be moved to the end of the caller's owned tokens list, making it the next in line to be\r\n    * burned in a FILO queue mechanism.\r\n    */   \r\n    function setLastOwnedTokenId(uint256 tokenId) external {\r\n        require (ownerOf(tokenId) == msg.sender, \"Token doesnot belong to sender\");\r\n        uint256 lastTokenId = getLastOwnedTokenId(msg.sender);\r\n        TokenDetail storage tokenDetail = _tokenDetail[tokenId];\r\n        TokenDetail storage lastDetail  = _tokenDetail[lastTokenId];\r\n\r\n        _ownedTokens[msg.sender][lastDetail.ownedTokensIndex] = uint32(tokenId);\r\n        _ownedTokens[msg.sender][tokenDetail.ownedTokensIndex] = uint32(lastTokenId);\r\n\r\n        lastDetail.ownedTokensIndex = tokenDetail.ownedTokensIndex;\r\n        tokenDetail.ownedTokensIndex = uint32(_ownedTokens[msg.sender].length - 1);\r\n    }\r\n\r\n    function setOwnedTokenIdByIndex(uint256 index, uint256 tokenId) external {\r\n        require (ownerOf(tokenId) == msg.sender, \"Token doesnot belong to sender\");\r\n        uint256 indexId = tokenOfOwnerByIndex(msg.sender, index);\r\n        TokenDetail storage tokenDetail = _tokenDetail[tokenId];\r\n        TokenDetail storage indexDetail = _tokenDetail[indexId];\r\n\r\n        _ownedTokens[msg.sender][indexDetail.ownedTokensIndex] = uint32(tokenId);\r\n        _ownedTokens[msg.sender][tokenDetail.ownedTokensIndex] = uint32(indexId);\r\n\r\n        indexDetail.ownedTokensIndex = tokenDetail.ownedTokensIndex;\r\n        tokenDetail.ownedTokensIndex = uint32(index);\r\n    }\r\n\r\n    /**\r\n    * @dev Publicly retrieves the ID of the last token owned by a specified address, following\r\n    * the FILO (First-In-Last-Out) queue logic. This function enables external entities, including\r\n    * users and other contracts, to identify the most recently acquired or assigned token for a\r\n    * given owner. It's particularly useful for understanding which token will be burnt based \r\n    * on the FILO queue mechanism.\r\n    *\r\n    * Requirements:\r\n    * - The `owner` must possess at least one token within this contract. If the queried owner\r\n    *   has no tokens, the function reverts with a \"Owner has no tokens\" error, ensuring calls\r\n    *   to this function are meaningful and pertain to actual owners.\r\n    *\r\n    * @param owner The address of the token owner whose last owned token ID is requested.\r\n    * @return uint256 The ID of the last token owned by the given address, providing insight\r\n    * on the owner's next token to be burnt based on the FILO queue mechanism.\r\n    *\r\n    */\r\n\tfunction getLastOwnedTokenId(address owner) public view returns (uint256) {\r\n\t\trequire(_ownedTokens[owner].length > 0, \"Owner has no tokens\");\r\n\t\treturn _ownedTokens[owner][_ownedTokens[owner].length - 1];\r\n\t}\r\n\r\n}\r\n// File: contracts/Cube404.sol\r\n\r\npragma solidity ^0.8.21;\r\n\r\n\r\n\r\ncontract Cube404 is ERC404C {\r\n\r\n    string public baseTokenURI = \"https://ipfs.io/ipfs/Qme1oy5af1RaCgxztACC8pbyuNR3HajRYcMAHRMyLQ39S7/\";\r\n\r\n    uint public immutable legendarySupply = 1; \r\n    uint public immutable epicSupply      = 9; \r\n    uint public immutable rareSupply      = 90; \r\n    uint public legendaryMinted;\r\n    uint public epicMinted;\r\n    uint public rareMinted;\r\n\r\n    uint public deckSize = 1000;\r\n\r\n    // variable for radom tokenId generation\r\n    uint private slotn; \r\n    mapping (uint256 => uint256) private slots;\r\n    mapping (uint256 => uint256) private legendarySlots;\r\n    mapping (uint256 => uint256) private epicSlots;\r\n    mapping (uint256 => uint256) private rareSlots;\r\n\r\n    constructor() ERC404C(\"Cube404\", \"CUBE\", 18, 21, deckSize, msg.sender) {\r\n        slotn = totalNativeSupply - customMintSupply();\r\n        balanceOf[msg.sender] = deckSize * _getUnit();\r\n        emit ERC20Transfer(address(0x0), msg.sender, deckSize * _getUnit());\r\n    }\r\n\r\n    function _beforeTransfer(address from, address to, uint256 amount) internal view override {\r\n        address _owner = owner();\r\n        if (from == _owner && to != _owner) {\r\n            // make sure that there is always enough token for reward distribution\r\n            uint256 balaceAfterTransfer = balanceOf[_owner] - amount;\r\n            require(balaceAfterTransfer >= customMintDemand() * _getUnit(), \"Not enough token\");\r\n        }\r\n    }\r\n\r\n    function customMintSupply() public pure returns (uint256) { return legendarySupply + epicSupply + rareSupply; }\r\n    function customMintMinted() public view returns (uint256) { return legendaryMinted + epicMinted + rareMinted; } \r\n    function customMintDemand() public view returns (uint256) { return customMintSupply() - customMintMinted(); }\r\n\r\n    function checkWhiteList(address addr) public view returns (bool) { return whitelist[addr]; }\r\n\r\n    function _afterBurn(uint256 tokenId) internal override {\r\n        // push burn tokenId into slots\r\n        slots[slotn] = tokenId;\r\n        slotn += 1;\r\n    }\r\n\r\n    function _getNextTokenId() internal override returns (uint256) {\r\n        // random id from slots\r\n        uint location = uint(keccak256(abi.encodePacked(minted,block.number))) % slotn; \r\n        uint id = slots[location];\r\n        if (id == 0) id = location + 1;\r\n        slotn -= 1;\r\n        slots[location] = (slots[slotn] == 0) ? (slotn + 1) : slots[slotn];       \r\n        return (id);\r\n    }\r\n\r\n    function mintRareTo(address to) public onlyOwner {\r\n        require(rareMinted < rareSupply, \"Rare is fully minted\");\r\n\r\n        uint256 _slotn    = rareSupply - rareMinted;\r\n        uint256 location = uint(keccak256(abi.encodePacked(minted,block.number))) % _slotn;\r\n        uint256 id = rareSlots[location];\r\n        if (id == 0) id = 900 + location + 1;\r\n        rareMinted += 1;\r\n\r\n        rareSlots[location] = (rareSlots[_slotn-1] == 0) \r\n                                ? 900 + _slotn\r\n                                : rareSlots[_slotn-1];\r\n\r\n        balanceOf[to] += _getUnit();\r\n        balanceOf[msg.sender] -= _getUnit();\r\n\r\n        _mint(to, id);        \r\n    }\r\n\r\n\r\n    function mintEpicTo(address to) public onlyOwner {\r\n        require(epicMinted < epicSupply, \"Epic is fully minted\");\r\n\r\n        uint256 _slotn    = epicSupply - epicMinted;\r\n        uint256 location = uint(keccak256(abi.encodePacked(minted,block.number))) % _slotn;\r\n        uint256 id = epicSlots[location];\r\n        if (id == 0) id = 990 + location + 1;\r\n        epicMinted += 1;\r\n\r\n        epicSlots[location] = (epicSlots[_slotn-1] == 0) \r\n                                ? 990 + _slotn\r\n                                : epicSlots[_slotn-1];\r\n\r\n        balanceOf[to] += _getUnit();\r\n        balanceOf[msg.sender] -= _getUnit();\r\n        _mint(to, id);\r\n    }\r\n\r\n    function mintLegendaryTo(address to) public onlyOwner {\r\n        require(legendaryMinted < legendarySupply, \"Legendary is fully minted\");\r\n        legendaryMinted += 1;\r\n        balanceOf[to] += _getUnit();\r\n        balanceOf[msg.sender] -= _getUnit();\r\n        _mint(to, 1000);\r\n    }\r\n\r\n    function setTokenURI(string memory _tokenURI) public onlyOwner {\r\n        baseTokenURI = _tokenURI;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        return string.concat(baseTokenURI, Strings.toString(tokenId), \".json\" );\r\n    }\r\n\r\n    /// @notice Function native approvals\r\n    /// provide option for Metamask user to call setApprovalForAll\r\n    function setApprovalForAllMetaMask(address operator, bool approved) public {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsafeRecipient\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ERC721Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721BalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customMintDemand\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customMintMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customMintSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deckSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epicMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epicSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getLastOwnedTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"legendaryMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"legendarySupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mintEpicTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mintLegendaryTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mintRareTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ownedBy\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rareMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rareSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAllMetaMask\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"setLastOwnedTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"setOwnedTokenIdByIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalERC721Supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNativeSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Cube404", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0b4f21d8b1d18945a879dc166eb017332345d4c92aa3b03821a263d467456bc9"}