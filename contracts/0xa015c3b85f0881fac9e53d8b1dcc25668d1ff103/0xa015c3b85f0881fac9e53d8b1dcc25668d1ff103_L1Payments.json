{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@layerzerolabs/solidity-examples/contracts/libraries/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\u00e7alo S\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\nlibrary BytesLib {\\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00), and(mload(mc), mask)))\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1, \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint _start) internal pure returns (uint) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                    // the next line is the loop condition:\\n                    // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {\\n\\n                        } eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\\n    function __AccessControl_init() internal onlyInitializing {\\n    }\\n\\n    function __AccessControl_init_unchained() internal onlyInitializing {\\n    }\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        StringsUpgradeable.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        StringsUpgradeable.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967Upgradeable {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1967Upgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMathUpgradeable {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/MathUpgradeable.sol\\\";\\nimport \\\"./math/SignedMathUpgradeable.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = MathUpgradeable.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMathUpgradeable.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Checkpoints.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Checkpoints.sol)\\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SafeCast.sol\\\";\\n\\n/**\\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\\n * time, and later looking up past values by block number. See {Votes} as an example.\\n *\\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\\n * checkpoint for the current transaction block using the {push} function.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Checkpoints {\\n    struct History {\\n        Checkpoint[] _checkpoints;\\n    }\\n\\n    struct Checkpoint {\\n        uint32 _blockNumber;\\n        uint224 _value;\\n    }\\n\\n    /**\\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\\n     * before it is returned, or zero otherwise. Because the number returned corresponds to that at the end of the\\n     * block, the requested block number must be in the past, excluding the current block.\\n     */\\n    function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\\n        require(blockNumber < block.number, \\\"Checkpoints: block not yet mined\\\");\\n        uint32 key = SafeCast.toUint32(blockNumber);\\n\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\\n     * before it is returned, or zero otherwise. Similar to {upperLookup} but optimized for the case when the searched\\n     * checkpoint is probably \\\"recent\\\", defined as being among the last sqrt(N) checkpoints where N is the number of\\n     * checkpoints.\\n     */\\n    function getAtProbablyRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\\n        require(blockNumber < block.number, \\\"Checkpoints: block not yet mined\\\");\\n        uint32 key = SafeCast.toUint32(blockNumber);\\n\\n        uint256 len = self._checkpoints.length;\\n\\n        uint256 low = 0;\\n        uint256 high = len;\\n\\n        if (len > 5) {\\n            uint256 mid = len - Math.sqrt(len);\\n            if (key < _unsafeAccess(self._checkpoints, mid)._blockNumber) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\\n\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\\n     *\\n     * Returns previous value and new value.\\n     */\\n    function push(History storage self, uint256 value) internal returns (uint256, uint256) {\\n        return _insert(self._checkpoints, SafeCast.toUint32(block.number), SafeCast.toUint224(value));\\n    }\\n\\n    /**\\n     * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\\n     * be set to `op(latest, delta)`.\\n     *\\n     * Returns previous value and new value.\\n     */\\n    function push(\\n        History storage self,\\n        function(uint256, uint256) view returns (uint256) op,\\n        uint256 delta\\n    ) internal returns (uint256, uint256) {\\n        return push(self, op(latest(self), delta));\\n    }\\n\\n    /**\\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\\n     */\\n    function latest(History storage self) internal view returns (uint224) {\\n        uint256 pos = self._checkpoints.length;\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\\n     * in the most recent checkpoint.\\n     */\\n    function latestCheckpoint(\\n        History storage self\\n    ) internal view returns (bool exists, uint32 _blockNumber, uint224 _value) {\\n        uint256 pos = self._checkpoints.length;\\n        if (pos == 0) {\\n            return (false, 0, 0);\\n        } else {\\n            Checkpoint memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\\n            return (true, ckpt._blockNumber, ckpt._value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the number of checkpoint.\\n     */\\n    function length(History storage self) internal view returns (uint256) {\\n        return self._checkpoints.length;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\\n     * or by updating the last one.\\n     */\\n    function _insert(Checkpoint[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\\n        uint256 pos = self.length;\\n\\n        if (pos > 0) {\\n            // Copying to memory is important here.\\n            Checkpoint memory last = _unsafeAccess(self, pos - 1);\\n\\n            // Checkpoint keys must be non-decreasing.\\n            require(last._blockNumber <= key, \\\"Checkpoint: decreasing keys\\\");\\n\\n            // Update or push new checkpoint\\n            if (last._blockNumber == key) {\\n                _unsafeAccess(self, pos - 1)._value = value;\\n            } else {\\n                self.push(Checkpoint({_blockNumber: key, _value: value}));\\n            }\\n\\n            return (last._value, value);\\n        } else {\\n            self.push(Checkpoint({_blockNumber: key, _value: value}));\\n            \\n            return (0, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _upperBinaryLookup(\\n        Checkpoint[] storage self,\\n        uint32 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._blockNumber > key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _lowerBinaryLookup(\\n        Checkpoint[] storage self,\\n        uint32 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._blockNumber < key) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(Checkpoint[] storage self, uint256 pos) private pure returns (Checkpoint storage result) {\\n        assembly {\\n            mstore(0, self.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n\\n    struct Trace224 {\\n        Checkpoint224[] _checkpoints;\\n    }\\n\\n    struct Checkpoint224 {\\n        uint32 _key;\\n        uint224 _value;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\\n     *\\n     * Returns previous value and new value.\\n     */\\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\\n        return _insert(self._checkpoints, key, value);\\n    }\\n\\n    /**\\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\\n     */\\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\\n     */\\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\\n     *\\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \\\"recent\\\" checkpoint (checkpoints with high keys).\\n     */\\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\\n        uint256 len = self._checkpoints.length;\\n\\n        uint256 low = 0;\\n        uint256 high = len;\\n\\n        if (len > 5) {\\n            uint256 mid = len - Math.sqrt(len);\\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\\n\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\\n     */\\n    function latest(Trace224 storage self) internal view returns (uint224) {\\n        uint256 pos = self._checkpoints.length;\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\\n     * in the most recent checkpoint.\\n     */\\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\\n        uint256 pos = self._checkpoints.length;\\n        if (pos == 0) {\\n            return (false, 0, 0);\\n        } else {\\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\\n            return (true, ckpt._key, ckpt._value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the number of checkpoint.\\n     */\\n    function length(Trace224 storage self) internal view returns (uint256) {\\n        return self._checkpoints.length;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\\n     * or by updating the last one.\\n     */\\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\\n        uint256 pos = self.length;\\n\\n        if (pos > 0) {\\n            // Copying to memory is important here.\\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\\n\\n            // Checkpoint keys must be non-decreasing.\\n            require(last._key <= key, \\\"Checkpoint: decreasing keys\\\");\\n\\n            // Update or push new checkpoint\\n            if (last._key == key) {\\n                _unsafeAccess(self, pos - 1)._value = value;\\n            } else {\\n                self.push(Checkpoint224({_key: key, _value: value}));\\n            }\\n            return (last._value, value);\\n        } else {\\n            self.push(Checkpoint224({_key: key, _value: value}));\\n            return (0, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _upperBinaryLookup(\\n        Checkpoint224[] storage self,\\n        uint32 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._key > key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _lowerBinaryLookup(\\n        Checkpoint224[] storage self,\\n        uint32 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._key < key) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(\\n        Checkpoint224[] storage self,\\n        uint256 pos\\n    ) private pure returns (Checkpoint224 storage result) {\\n        assembly {\\n            mstore(0, self.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n\\n    struct Trace160 {\\n        Checkpoint160[] _checkpoints;\\n    }\\n\\n    struct Checkpoint160 {\\n        uint96 _key;\\n        uint160 _value;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\\n     *\\n     * Returns previous value and new value.\\n     */\\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\\n        return _insert(self._checkpoints, key, value);\\n    }\\n\\n    /**\\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\\n     */\\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\\n     */\\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\\n     *\\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \\\"recent\\\" checkpoint (checkpoints with high keys).\\n     */\\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\\n        uint256 len = self._checkpoints.length;\\n\\n        uint256 low = 0;\\n        uint256 high = len;\\n\\n        if (len > 5) {\\n            uint256 mid = len - Math.sqrt(len);\\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\\n\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\\n     */\\n    function latest(Trace160 storage self) internal view returns (uint160) {\\n        uint256 pos = self._checkpoints.length;\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\\n     * in the most recent checkpoint.\\n     */\\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\\n        uint256 pos = self._checkpoints.length;\\n        if (pos == 0) {\\n            return (false, 0, 0);\\n        } else {\\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\\n            return (true, ckpt._key, ckpt._value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the number of checkpoint.\\n     */\\n    function length(Trace160 storage self) internal view returns (uint256) {\\n        return self._checkpoints.length;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\\n     * or by updating the last one.\\n     */\\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\\n        uint256 pos = self.length;\\n\\n        if (pos > 0) {\\n            // Copying to memory is important here.\\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\\n\\n            // Checkpoint keys must be non-decreasing.\\n            require(last._key <= key, \\\"Checkpoint: decreasing keys\\\");\\n\\n            // Update or push new checkpoint\\n            if (last._key == key) {\\n                _unsafeAccess(self, pos - 1)._value = value;\\n            } else {\\n                self.push(Checkpoint160({_key: key, _value: value}));\\n            }\\n            return (last._value, value);\\n        } else {\\n            self.push(Checkpoint160({_key: key, _value: value}));\\n            return (0, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _upperBinaryLookup(\\n        Checkpoint160[] storage self,\\n        uint96 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._key > key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _lowerBinaryLookup(\\n        Checkpoint160[] storage self,\\n        uint96 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._key < key) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(\\n        Checkpoint160[] storage self,\\n        uint256 pos\\n    ) private pure returns (Checkpoint160 storage result) {\\n        assembly {\\n            mstore(0, self.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/Common.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\n/// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\\n/// always operate with SD59x18 and UD60x18 numbers.\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                CUSTOM ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Emitted when the ending result in the fixed-point version of `mulDiv` would overflow uint256.\\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when the ending result in `mulDiv` would overflow uint256.\\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\\n\\n/// @notice Emitted when attempting to run `mulDiv` with one of the inputs `type(int256).min`.\\nerror PRBMath_MulDivSigned_InputTooSmall();\\n\\n/// @notice Emitted when the ending result in the signed version of `mulDiv` would overflow int256.\\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CONSTANTS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @dev The maximum value an uint128 number can have.\\nuint128 constant MAX_UINT128 = type(uint128).max;\\n\\n/// @dev The maximum value an uint40 number can have.\\nuint40 constant MAX_UINT40 = type(uint40).max;\\n\\n/// @dev How many trailing decimals can be represented.\\nuint256 constant UNIT = 1e18;\\n\\n/// @dev Largest power of two that is a divisor of `UNIT`.\\nuint256 constant UNIT_LPOTD = 262144;\\n\\n/// @dev The `UNIT` number inverted mod 2^256.\\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Finds the zero-based index of the first one in the binary representation of x.\\n/// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n///\\n/// Each of the steps in this implementation is equivalent to this high-level code:\\n///\\n/// ```solidity\\n/// if (x >= 2 ** 128) {\\n///     x >>= 128;\\n///     result += 128;\\n/// }\\n/// ```\\n///\\n/// Where 128 is swapped with each respective power of two factor. See the full high-level implementation here:\\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\\n///\\n/// A list of the Yul instructions used below:\\n/// - \\\"gt\\\" is \\\"greater than\\\"\\n/// - \\\"or\\\" is the OR bitwise operator\\n/// - \\\"shl\\\" is \\\"shift left\\\"\\n/// - \\\"shr\\\" is \\\"shift right\\\"\\n///\\n/// @param x The uint256 number for which to find the index of the most significant bit.\\n/// @return result The index of the most significant bit as an uint256.\\nfunction msb(uint256 x) pure returns (uint256 result) {\\n    // 2^128\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^64\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^32\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^16\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(4, gt(x, 0xFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^8\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(3, gt(x, 0xFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^4\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(2, gt(x, 0xF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^2\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(1, gt(x, 0x3))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^1\\n    // No need to shift x any more.\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := gt(x, 0x1)\\n        result := or(result, factor)\\n    }\\n}\\n\\n/// @notice Calculates floor(x*y\u00f7denominator) with full precision.\\n///\\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n///\\n/// Requirements:\\n/// - The denominator cannot be zero.\\n/// - The result must fit within uint256.\\n///\\n/// Caveats:\\n/// - This function does not work with fixed-point numbers.\\n///\\n/// @param x The multiplicand as an uint256.\\n/// @param y The multiplier as an uint256.\\n/// @param denominator The divisor as an uint256.\\n/// @return result The result as an uint256.\\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n    uint256 prod0; // Least significant 256 bits of the product\\n    uint256 prod1; // Most significant 256 bits of the product\\n    assembly (\\\"memory-safe\\\") {\\n        let mm := mulmod(x, y, not(0))\\n        prod0 := mul(x, y)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n    if (prod1 == 0) {\\n        unchecked {\\n            return prod0 / denominator;\\n        }\\n    }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n    if (prod1 >= denominator) {\\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\\n    }\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n    uint256 remainder;\\n    assembly (\\\"memory-safe\\\") {\\n        // Compute remainder using the mulmod Yul instruction.\\n        remainder := mulmod(x, y, denominator)\\n\\n        // Subtract 256 bit number from 512 bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n    }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n    // See https://cs.stackexchange.com/q/138556/92363.\\n    unchecked {\\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\\n        uint256 lpotdod = denominator & (~denominator + 1);\\n        assembly (\\\"memory-safe\\\") {\\n            // Divide denominator by lpotdod.\\n            denominator := div(denominator, lpotdod)\\n\\n            // Divide [prod1 prod0] by lpotdod.\\n            prod0 := div(prod0, lpotdod)\\n\\n            // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\n            lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n        }\\n\\n        // Shift in bits from prod1 into prod0.\\n        prod0 |= prod1 * lpotdod;\\n\\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n        // four bits. That is, denominator * inv = 1 mod 2^4.\\n        uint256 inverse = (3 * denominator) ^ 2;\\n\\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n        // in modular arithmetic, doubling the correct bits in each step.\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inverse;\\n    }\\n}\\n\\n/// @notice Calculates floor(x*y\u00f71e18) with full precision.\\n///\\n/// @dev Variant of `mulDiv` with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\n/// final result, we add 1 if `(x * y) % UNIT >= HALF_UNIT`. Without this adjustment, 6.6e-19 would be truncated to 0\\n/// instead of being rounded to 1e-18. See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\n///\\n/// Requirements:\\n/// - The result must fit within uint256.\\n///\\n/// Caveats:\\n/// - The body is purposely left uncommented; to understand how this works, see the NatSpec comments in `mulDiv`.\\n/// - It is assumed that the result can never be `type(uint256).max` when x and y solve the following two equations:\\n///     1. x * y = type(uint256).max * UNIT\\n///     2. (x * y) % UNIT >= UNIT / 2\\n///\\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\\n    uint256 prod0;\\n    uint256 prod1;\\n    assembly (\\\"memory-safe\\\") {\\n        let mm := mulmod(x, y, not(0))\\n        prod0 := mul(x, y)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    if (prod1 >= UNIT) {\\n        revert PRBMath_MulDiv18_Overflow(x, y);\\n    }\\n\\n    uint256 remainder;\\n    assembly (\\\"memory-safe\\\") {\\n        remainder := mulmod(x, y, UNIT)\\n    }\\n\\n    if (prod1 == 0) {\\n        unchecked {\\n            return prod0 / UNIT;\\n        }\\n    }\\n\\n    assembly (\\\"memory-safe\\\") {\\n        result := mul(\\n            or(\\n                div(sub(prod0, remainder), UNIT_LPOTD),\\n                mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\\n            ),\\n            UNIT_INVERSE\\n        )\\n    }\\n}\\n\\n/// @notice Calculates floor(x*y\u00f7denominator) with full precision.\\n///\\n/// @dev An extension of `mulDiv` for signed numbers. Works by computing the signs and the absolute values separately.\\n///\\n/// Requirements:\\n/// - None of the inputs can be `type(int256).min`.\\n/// - The result must fit within int256.\\n///\\n/// @param x The multiplicand as an int256.\\n/// @param y The multiplier as an int256.\\n/// @param denominator The divisor as an int256.\\n/// @return result The result as an int256.\\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n        revert PRBMath_MulDivSigned_InputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x, y and the denominator.\\n    uint256 absX;\\n    uint256 absY;\\n    uint256 absD;\\n    unchecked {\\n        absX = x < 0 ? uint256(-x) : uint256(x);\\n        absY = y < 0 ? uint256(-y) : uint256(y);\\n        absD = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n    }\\n\\n    // Compute the absolute value of (x*y)\u00f7denominator. The result must fit within int256.\\n    uint256 rAbs = mulDiv(absX, absY, absD);\\n    if (rAbs > uint256(type(int256).max)) {\\n        revert PRBMath_MulDivSigned_Overflow(x, y);\\n    }\\n\\n    // Get the signs of x, y and the denominator.\\n    uint256 sx;\\n    uint256 sy;\\n    uint256 sd;\\n    assembly (\\\"memory-safe\\\") {\\n        // This works thanks to two's complement.\\n        // \\\"sgt\\\" stands for \\\"signed greater than\\\" and \\\"sub(0,1)\\\" is max uint256.\\n        sx := sgt(x, sub(0, 1))\\n        sy := sgt(y, sub(0, 1))\\n        sd := sgt(denominator, sub(0, 1))\\n    }\\n\\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\\n    // If there are, the result should be negative. Otherwise, it should be positive.\\n    unchecked {\\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\\n    }\\n}\\n\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\n/// @dev Has to use 192.64-bit fixed-point numbers.\\n/// See https://ethereum.stackexchange.com/a/96594/24693.\\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\nfunction prbExp2(uint256 x) pure returns (uint256 result) {\\n    unchecked {\\n        // Start from 0.5 in the 192.64-bit fixed-point format.\\n        result = 0x800000000000000000000000000000000000000000000000;\\n\\n        // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n        // because the initial result is 2^191 and all magic factors are less than 2^65.\\n        if (x & 0xFF00000000000000 > 0) {\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF000000000000 > 0) {\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF0000000000 > 0) {\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF00000000 > 0) {\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF00000000 > 0) {\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF0000 > 0) {\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF00 > 0) {\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF > 0) {\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n        }\\n\\n        // We're doing two things at the same time:\\n        //\\n        //   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\n        //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\n        //      rather than 192.\\n        //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\n        //\\n        // This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\n        result *= UNIT;\\n        result >>= (191 - (x >> 64));\\n    }\\n}\\n\\n/// @notice Calculates the square root of x, rounding down if x is not a perfect square.\\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n/// Credits to OpenZeppelin for the explanations in code comments below.\\n///\\n/// Caveats:\\n/// - This function does not work with fixed-point numbers.\\n///\\n/// @param x The uint256 number for which to calculate the square root.\\n/// @return result The result as an uint256.\\nfunction prbSqrt(uint256 x) pure returns (uint256 result) {\\n    if (x == 0) {\\n        return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of x.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of x is a power of 2 such that we have:\\n    //\\n    // $$\\n    // msb(x) <= x <= 2*msb(x)$\\n    // $$\\n    //\\n    // We write $msb(x)$ as $2^k$ and we get:\\n    //\\n    // $$\\n    // k = log_2(x)\\n    // $$\\n    //\\n    // Thus we can write the initial inequality as:\\n    //\\n    // $$\\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\\\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\\\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\\n    // $$\\n    //\\n    // Consequently, $2^{log_2(x) /2}` is a good first approximation of sqrt(x) with at least one correct bit.\\n    uint256 xAux = uint256(x);\\n    result = 1;\\n    if (xAux >= 2 ** 128) {\\n        xAux >>= 128;\\n        result <<= 64;\\n    }\\n    if (xAux >= 2 ** 64) {\\n        xAux >>= 64;\\n        result <<= 32;\\n    }\\n    if (xAux >= 2 ** 32) {\\n        xAux >>= 32;\\n        result <<= 16;\\n    }\\n    if (xAux >= 2 ** 16) {\\n        xAux >>= 16;\\n        result <<= 8;\\n    }\\n    if (xAux >= 2 ** 8) {\\n        xAux >>= 8;\\n        result <<= 4;\\n    }\\n    if (xAux >= 2 ** 4) {\\n        xAux >>= 4;\\n        result <<= 2;\\n    }\\n    if (xAux >= 2 ** 2) {\\n        result <<= 1;\\n    }\\n\\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\\n    // most 128 bits, since  it is the square root of a uint256. Newton's method converges quadratically (precision\\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\\n    // precision into the expected uint128 result.\\n    unchecked {\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n\\n        // Round down the result in case x is not a perfect square.\\n        uint256 roundedDownResult = x / result;\\n        if (result >= roundedDownResult) {\\n            result = roundedDownResult;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/sd1x18/Casting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { MAX_UINT40 } from \\\"../Common.sol\\\";\\nimport { SD59x18 } from \\\"../sd59x18/ValueType.sol\\\";\\nimport { UD2x18 } from \\\"../ud2x18/ValueType.sol\\\";\\nimport { UD60x18 } from \\\"../ud60x18/ValueType.sol\\\";\\nimport {\\n    PRBMath_SD1x18_ToUD2x18_Underflow,\\n    PRBMath_SD1x18_ToUD60x18_Underflow,\\n    PRBMath_SD1x18_ToUint128_Underflow,\\n    PRBMath_SD1x18_ToUint256_Underflow,\\n    PRBMath_SD1x18_ToUint40_Overflow,\\n    PRBMath_SD1x18_ToUint40_Underflow\\n} from \\\"./Errors.sol\\\";\\nimport { SD1x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Casts an SD1x18 number into SD59x18.\\n/// @dev There is no overflow check because the domain of SD1x18 is a subset of SD59x18.\\nfunction intoSD59x18(SD1x18 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(int256(SD1x18.unwrap(x)));\\n}\\n\\n/// @notice Casts an SD1x18 number into UD2x18.\\n/// - x must be positive.\\nfunction intoUD2x18(SD1x18 x) pure returns (UD2x18 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMath_SD1x18_ToUD2x18_Underflow(x);\\n    }\\n    result = UD2x18.wrap(uint64(xInt));\\n}\\n\\n/// @notice Casts an SD1x18 number into UD60x18.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUD60x18(SD1x18 x) pure returns (UD60x18 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMath_SD1x18_ToUD60x18_Underflow(x);\\n    }\\n    result = UD60x18.wrap(uint64(xInt));\\n}\\n\\n/// @notice Casts an SD1x18 number into uint256.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUint256(SD1x18 x) pure returns (uint256 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMath_SD1x18_ToUint256_Underflow(x);\\n    }\\n    result = uint256(uint64(xInt));\\n}\\n\\n/// @notice Casts an SD1x18 number into uint128.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUint128(SD1x18 x) pure returns (uint128 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMath_SD1x18_ToUint128_Underflow(x);\\n    }\\n    result = uint128(uint64(xInt));\\n}\\n\\n/// @notice Casts an SD1x18 number into uint40.\\n/// @dev Requirements:\\n/// - x must be positive.\\n/// - x must be less than or equal to `MAX_UINT40`.\\nfunction intoUint40(SD1x18 x) pure returns (uint40 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMath_SD1x18_ToUint40_Underflow(x);\\n    }\\n    if (xInt > int64(uint64(MAX_UINT40))) {\\n        revert PRBMath_SD1x18_ToUint40_Overflow(x);\\n    }\\n    result = uint40(uint64(xInt));\\n}\\n\\n/// @notice Alias for the `wrap` function.\\nfunction sd1x18(int64 x) pure returns (SD1x18 result) {\\n    result = wrap(x);\\n}\\n\\n/// @notice Unwraps an SD1x18 number into int64.\\nfunction unwrap(SD1x18 x) pure returns (int64 result) {\\n    result = SD1x18.unwrap(x);\\n}\\n\\n/// @notice Wraps an int64 number into the SD1x18 value type.\\nfunction wrap(int64 x) pure returns (SD1x18 result) {\\n    result = SD1x18.wrap(x);\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/sd1x18/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { SD1x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @dev Euler's number as an SD1x18 number.\\nSD1x18 constant E = SD1x18.wrap(2_718281828459045235);\\n\\n/// @dev The maximum value an SD1x18 number can have.\\nint64 constant uMAX_SD1x18 = 9_223372036854775807;\\nSD1x18 constant MAX_SD1x18 = SD1x18.wrap(uMAX_SD1x18);\\n\\n/// @dev The maximum value an SD1x18 number can have.\\nint64 constant uMIN_SD1x18 = -9_223372036854775808;\\nSD1x18 constant MIN_SD1x18 = SD1x18.wrap(uMIN_SD1x18);\\n\\n/// @dev PI as an SD1x18 number.\\nSD1x18 constant PI = SD1x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit amount that implies how many trailing decimals can be represented.\\nSD1x18 constant UNIT = SD1x18.wrap(1e18);\\nint256 constant uUNIT = 1e18;\\n\"\r\n    },\r\n    \"@prb/math/src/sd1x18/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { SD1x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Emitted when trying to cast a SD1x18 number that doesn't fit in UD2x18.\\nerror PRBMath_SD1x18_ToUD2x18_Underflow(SD1x18 x);\\n\\n/// @notice Emitted when trying to cast a SD1x18 number that doesn't fit in UD60x18.\\nerror PRBMath_SD1x18_ToUD60x18_Underflow(SD1x18 x);\\n\\n/// @notice Emitted when trying to cast a SD1x18 number that doesn't fit in uint128.\\nerror PRBMath_SD1x18_ToUint128_Underflow(SD1x18 x);\\n\\n/// @notice Emitted when trying to cast a SD1x18 number that doesn't fit in uint256.\\nerror PRBMath_SD1x18_ToUint256_Underflow(SD1x18 x);\\n\\n/// @notice Emitted when trying to cast a SD1x18 number that doesn't fit in uint40.\\nerror PRBMath_SD1x18_ToUint40_Overflow(SD1x18 x);\\n\\n/// @notice Emitted when trying to cast a SD1x18 number that doesn't fit in uint40.\\nerror PRBMath_SD1x18_ToUint40_Underflow(SD1x18 x);\\n\"\r\n    },\r\n    \"@prb/math/src/sd1x18/ValueType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"./Casting.sol\\\" as C;\\n\\n/// @notice The signed 1.18-decimal fixed-point number representation, which can have up to 1 digit and up to 18 decimals.\\n/// The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity type int64.\\n/// This is useful when end users want to use int64 to save gas, e.g. with tight variable packing in contract storage.\\ntype SD1x18 is int64;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CASTING\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing { C.intoSD59x18, C.intoUD2x18, C.intoUD60x18, C.intoUint256, C.intoUint128, C.intoUint40, C.unwrap } for SD1x18 global;\\n\"\r\n    },\r\n    \"@prb/math/src/SD59x18.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"./sd59x18/Casting.sol\\\";\\nimport \\\"./sd59x18/Constants.sol\\\";\\nimport \\\"./sd59x18/Conversions.sol\\\";\\nimport \\\"./sd59x18/Errors.sol\\\";\\nimport \\\"./sd59x18/Helpers.sol\\\";\\nimport \\\"./sd59x18/Math.sol\\\";\\nimport \\\"./sd59x18/ValueType.sol\\\";\\n\"\r\n    },\r\n    \"@prb/math/src/sd59x18/Casting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { MAX_UINT128, MAX_UINT40 } from \\\"../Common.sol\\\";\\nimport { uMAX_SD1x18, uMIN_SD1x18 } from \\\"../sd1x18/Constants.sol\\\";\\nimport { SD1x18 } from \\\"../sd1x18/ValueType.sol\\\";\\nimport { uMAX_UD2x18 } from \\\"../ud2x18/Constants.sol\\\";\\nimport { UD2x18 } from \\\"../ud2x18/ValueType.sol\\\";\\nimport { UD60x18 } from \\\"../ud60x18/ValueType.sol\\\";\\nimport {\\n    PRBMath_SD59x18_IntoSD1x18_Overflow,\\n    PRBMath_SD59x18_IntoSD1x18_Underflow,\\n    PRBMath_SD59x18_IntoUD2x18_Overflow,\\n    PRBMath_SD59x18_IntoUD2x18_Underflow,\\n    PRBMath_SD59x18_IntoUD60x18_Underflow,\\n    PRBMath_SD59x18_IntoUint128_Overflow,\\n    PRBMath_SD59x18_IntoUint128_Underflow,\\n    PRBMath_SD59x18_IntoUint256_Underflow,\\n    PRBMath_SD59x18_IntoUint40_Overflow,\\n    PRBMath_SD59x18_IntoUint40_Underflow\\n} from \\\"./Errors.sol\\\";\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Casts an SD59x18 number into int256.\\n/// @dev This is basically a functional alias for the `unwrap` function.\\nfunction intoInt256(SD59x18 x) pure returns (int256 result) {\\n    result = SD59x18.unwrap(x);\\n}\\n\\n/// @notice Casts an SD59x18 number into SD1x18.\\n/// @dev Requirements:\\n/// - x must be greater than or equal to `uMIN_SD1x18`.\\n/// - x must be less than or equal to `uMAX_SD1x18`.\\nfunction intoSD1x18(SD59x18 x) pure returns (SD1x18 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < uMIN_SD1x18) {\\n        revert PRBMath_SD59x18_IntoSD1x18_Underflow(x);\\n    }\\n    if (xInt > uMAX_SD1x18) {\\n        revert PRBMath_SD59x18_IntoSD1x18_Overflow(x);\\n    }\\n    result = SD1x18.wrap(int64(xInt));\\n}\\n\\n/// @notice Casts an SD59x18 number into UD2x18.\\n/// @dev Requirements:\\n/// - x must be positive.\\n/// - x must be less than or equal to `uMAX_UD2x18`.\\nfunction intoUD2x18(SD59x18 x) pure returns (UD2x18 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMath_SD59x18_IntoUD2x18_Underflow(x);\\n    }\\n    if (xInt > int256(uint256(uMAX_UD2x18))) {\\n        revert PRBMath_SD59x18_IntoUD2x18_Overflow(x);\\n    }\\n    result = UD2x18.wrap(uint64(uint256(xInt)));\\n}\\n\\n/// @notice Casts an SD59x18 number into UD60x18.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUD60x18(SD59x18 x) pure returns (UD60x18 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMath_SD59x18_IntoUD60x18_Underflow(x);\\n    }\\n    result = UD60x18.wrap(uint256(xInt));\\n}\\n\\n/// @notice Casts an SD59x18 number into uint256.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUint256(SD59x18 x) pure returns (uint256 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMath_SD59x18_IntoUint256_Underflow(x);\\n    }\\n    result = uint256(xInt);\\n}\\n\\n/// @notice Casts an SD59x18 number into uint128.\\n/// @dev Requirements:\\n/// - x must be positive.\\n/// - x must be less than or equal to `uMAX_UINT128`.\\nfunction intoUint128(SD59x18 x) pure returns (uint128 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMath_SD59x18_IntoUint128_Underflow(x);\\n    }\\n    if (xInt > int256(uint256(MAX_UINT128))) {\\n        revert PRBMath_SD59x18_IntoUint128_Overflow(x);\\n    }\\n    result = uint128(uint256(xInt));\\n}\\n\\n/// @notice Casts an SD59x18 number into uint40.\\n/// @dev Requirements:\\n/// - x must be positive.\\n/// - x must be less than or equal to `MAX_UINT40`.\\nfunction intoUint40(SD59x18 x) pure returns (uint40 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMath_SD59x18_IntoUint40_Underflow(x);\\n    }\\n    if (xInt > int256(uint256(MAX_UINT40))) {\\n        revert PRBMath_SD59x18_IntoUint40_Overflow(x);\\n    }\\n    result = uint40(uint256(xInt));\\n}\\n\\n/// @notice Alias for the `wrap` function.\\nfunction sd(int256 x) pure returns (SD59x18 result) {\\n    result = wrap(x);\\n}\\n\\n/// @notice Alias for the `wrap` function.\\nfunction sd59x18(int256 x) pure returns (SD59x18 result) {\\n    result = wrap(x);\\n}\\n\\n/// @notice Unwraps an SD59x18 number into int256.\\nfunction unwrap(SD59x18 x) pure returns (int256 result) {\\n    result = SD59x18.unwrap(x);\\n}\\n\\n/// @notice Wraps an int256 number into the SD59x18 value type.\\nfunction wrap(int256 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(x);\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/sd59x18/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// NOTICE: the \\\"u\\\" prefix stands for \\\"unwrapped\\\".\\n\\n/// @dev Euler's number as an SD59x18 number.\\nSD59x18 constant E = SD59x18.wrap(2_718281828459045235);\\n\\n/// @dev Half the UNIT number.\\nint256 constant uHALF_UNIT = 0.5e18;\\nSD59x18 constant HALF_UNIT = SD59x18.wrap(uHALF_UNIT);\\n\\n/// @dev log2(10) as an SD59x18 number.\\nint256 constant uLOG2_10 = 3_321928094887362347;\\nSD59x18 constant LOG2_10 = SD59x18.wrap(uLOG2_10);\\n\\n/// @dev log2(e) as an SD59x18 number.\\nint256 constant uLOG2_E = 1_442695040888963407;\\nSD59x18 constant LOG2_E = SD59x18.wrap(uLOG2_E);\\n\\n/// @dev The maximum value an SD59x18 number can have.\\nint256 constant uMAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_792003956564819967;\\nSD59x18 constant MAX_SD59x18 = SD59x18.wrap(uMAX_SD59x18);\\n\\n/// @dev The maximum whole value an SD59x18 number can have.\\nint256 constant uMAX_WHOLE_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\nSD59x18 constant MAX_WHOLE_SD59x18 = SD59x18.wrap(uMAX_WHOLE_SD59x18);\\n\\n/// @dev The minimum value an SD59x18 number can have.\\nint256 constant uMIN_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\\nSD59x18 constant MIN_SD59x18 = SD59x18.wrap(uMIN_SD59x18);\\n\\n/// @dev The minimum whole value an SD59x18 number can have.\\nint256 constant uMIN_WHOLE_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\nSD59x18 constant MIN_WHOLE_SD59x18 = SD59x18.wrap(uMIN_WHOLE_SD59x18);\\n\\n/// @dev PI as an SD59x18 number.\\nSD59x18 constant PI = SD59x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit amount that implies how many trailing decimals can be represented.\\nint256 constant uUNIT = 1e18;\\nSD59x18 constant UNIT = SD59x18.wrap(1e18);\\n\\n/// @dev Zero as an SD59x18 number.\\nSD59x18 constant ZERO = SD59x18.wrap(0);\\n\"\r\n    },\r\n    \"@prb/math/src/sd59x18/Conversions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { uMAX_SD59x18, uMIN_SD59x18, uUNIT } from \\\"./Constants.sol\\\";\\nimport { PRBMath_SD59x18_Convert_Overflow, PRBMath_SD59x18_Convert_Underflow } from \\\"./Errors.sol\\\";\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Converts a simple integer to SD59x18 by multiplying it by `UNIT`.\\n///\\n/// @dev Requirements:\\n/// - x must be greater than or equal to `MIN_SD59x18` divided by `UNIT`.\\n/// - x must be less than or equal to `MAX_SD59x18` divided by `UNIT`.\\n///\\n/// @param x The basic integer to convert.\\n/// @param result The same number converted to SD59x18.\\nfunction convert(int256 x) pure returns (SD59x18 result) {\\n    if (x < uMIN_SD59x18 / uUNIT) {\\n        revert PRBMath_SD59x18_Convert_Underflow(x);\\n    }\\n    if (x > uMAX_SD59x18 / uUNIT) {\\n        revert PRBMath_SD59x18_Convert_Overflow(x);\\n    }\\n    unchecked {\\n        result = SD59x18.wrap(x * uUNIT);\\n    }\\n}\\n\\n/// @notice Converts an SD59x18 number to a simple integer by dividing it by `UNIT`. Rounds towards zero in the process.\\n/// @param x The SD59x18 number to convert.\\n/// @return result The same number as a simple integer.\\nfunction convert(SD59x18 x) pure returns (int256 result) {\\n    result = SD59x18.unwrap(x) / uUNIT;\\n}\\n\\n/// @notice Alias for the `convert` function defined above.\\n/// @dev Here for backward compatibility. Will be removed in V4.\\nfunction fromSD59x18(SD59x18 x) pure returns (int256 result) {\\n    result = convert(x);\\n}\\n\\n/// @notice Alias for the `convert` function defined above.\\n/// @dev Here for backward compatibility. Will be removed in V4.\\nfunction toSD59x18(int256 x) pure returns (SD59x18 result) {\\n    result = convert(x);\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/sd59x18/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Emitted when taking the absolute value of `MIN_SD59x18`.\\nerror PRBMath_SD59x18_Abs_MinSD59x18();\\n\\n/// @notice Emitted when ceiling a number overflows SD59x18.\\nerror PRBMath_SD59x18_Ceil_Overflow(SD59x18 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\\nerror PRBMath_SD59x18_Convert_Overflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\\nerror PRBMath_SD59x18_Convert_Underflow(int256 x);\\n\\n/// @notice Emitted when dividing two numbers and one of them is `MIN_SD59x18`.\\nerror PRBMath_SD59x18_Div_InputTooSmall();\\n\\n/// @notice Emitted when dividing two numbers and one of the intermediary unsigned results overflows SD59x18.\\nerror PRBMath_SD59x18_Div_Overflow(SD59x18 x, SD59x18 y);\\n\\n/// @notice Emitted when taking the natural exponent of a base greater than 133.084258667509499441.\\nerror PRBMath_SD59x18_Exp_InputTooBig(SD59x18 x);\\n\\n/// @notice Emitted when taking the binary exponent of a base greater than 192.\\nerror PRBMath_SD59x18_Exp2_InputTooBig(SD59x18 x);\\n\\n/// @notice Emitted when flooring a number underflows SD59x18.\\nerror PRBMath_SD59x18_Floor_Underflow(SD59x18 x);\\n\\n/// @notice Emitted when taking the geometric mean of two numbers and their product is negative.\\nerror PRBMath_SD59x18_Gm_NegativeProduct(SD59x18 x, SD59x18 y);\\n\\n/// @notice Emitted when taking the geometric mean of two numbers and multiplying them overflows SD59x18.\\nerror PRBMath_SD59x18_Gm_Overflow(SD59x18 x, SD59x18 y);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in SD1x18.\\nerror PRBMath_SD59x18_IntoSD1x18_Overflow(SD59x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in SD1x18.\\nerror PRBMath_SD59x18_IntoSD1x18_Underflow(SD59x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in UD2x18.\\nerror PRBMath_SD59x18_IntoUD2x18_Overflow(SD59x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in UD2x18.\\nerror PRBMath_SD59x18_IntoUD2x18_Underflow(SD59x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in UD60x18.\\nerror PRBMath_SD59x18_IntoUD60x18_Underflow(SD59x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint128.\\nerror PRBMath_SD59x18_IntoUint128_Overflow(SD59x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint128.\\nerror PRBMath_SD59x18_IntoUint128_Underflow(SD59x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint256.\\nerror PRBMath_SD59x18_IntoUint256_Underflow(SD59x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint40.\\nerror PRBMath_SD59x18_IntoUint40_Overflow(SD59x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint40.\\nerror PRBMath_SD59x18_IntoUint40_Underflow(SD59x18 x);\\n\\n/// @notice Emitted when taking the logarithm of a number less than or equal to zero.\\nerror PRBMath_SD59x18_Log_InputTooSmall(SD59x18 x);\\n\\n/// @notice Emitted when multiplying two numbers and one of the inputs is `MIN_SD59x18`.\\nerror PRBMath_SD59x18_Mul_InputTooSmall();\\n\\n/// @notice Emitted when multiplying two numbers and the intermediary absolute result overflows SD59x18.\\nerror PRBMath_SD59x18_Mul_Overflow(SD59x18 x, SD59x18 y);\\n\\n/// @notice Emitted when raising a number to a power and hte intermediary absolute result overflows SD59x18.\\nerror PRBMath_SD59x18_Powu_Overflow(SD59x18 x, uint256 y);\\n\\n/// @notice Emitted when taking the square root of a negative number.\\nerror PRBMath_SD59x18_Sqrt_NegativeInput(SD59x18 x);\\n\\n/// @notice Emitted when the calculating the square root overflows SD59x18.\\nerror PRBMath_SD59x18_Sqrt_Overflow(SD59x18 x);\\n\"\r\n    },\r\n    \"@prb/math/src/sd59x18/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { unwrap, wrap } from \\\"./Casting.sol\\\";\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Implements the checked addition operation (+) in the SD59x18 type.\\nfunction add(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    return wrap(unwrap(x) + unwrap(y));\\n}\\n\\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\\nfunction and(SD59x18 x, int256 bits) pure returns (SD59x18 result) {\\n    return wrap(unwrap(x) & bits);\\n}\\n\\n/// @notice Implements the equal (=) operation in the SD59x18 type.\\nfunction eq(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = unwrap(x) == unwrap(y);\\n}\\n\\n/// @notice Implements the greater than operation (>) in the SD59x18 type.\\nfunction gt(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = unwrap(x) > unwrap(y);\\n}\\n\\n/// @notice Implements the greater than or equal to operation (>=) in the SD59x18 type.\\nfunction gte(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = unwrap(x) >= unwrap(y);\\n}\\n\\n/// @notice Implements a zero comparison check function in the SD59x18 type.\\nfunction isZero(SD59x18 x) pure returns (bool result) {\\n    result = unwrap(x) == 0;\\n}\\n\\n/// @notice Implements the left shift operation (<<) in the SD59x18 type.\\nfunction lshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) << bits);\\n}\\n\\n/// @notice Implements the lower than operation (<) in the SD59x18 type.\\nfunction lt(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = unwrap(x) < unwrap(y);\\n}\\n\\n/// @notice Implements the lower than or equal to operation (<=) in the SD59x18 type.\\nfunction lte(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = unwrap(x) <= unwrap(y);\\n}\\n\\n/// @notice Implements the unchecked modulo operation (%) in the SD59x18 type.\\nfunction mod(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) % unwrap(y));\\n}\\n\\n/// @notice Implements the not equal operation (!=) in the SD59x18 type.\\nfunction neq(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = unwrap(x) != unwrap(y);\\n}\\n\\n/// @notice Implements the OR (|) bitwise operation in the SD59x18 type.\\nfunction or(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) | unwrap(y));\\n}\\n\\n/// @notice Implements the right shift operation (>>) in the SD59x18 type.\\nfunction rshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) >> bits);\\n}\\n\\n/// @notice Implements the checked subtraction operation (-) in the SD59x18 type.\\nfunction sub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) - unwrap(y));\\n}\\n\\n/// @notice Implements the unchecked addition operation (+) in the SD59x18 type.\\nfunction uncheckedAdd(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(unwrap(x) + unwrap(y));\\n    }\\n}\\n\\n/// @notice Implements the unchecked subtraction operation (-) in the SD59x18 type.\\nfunction uncheckedSub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(unwrap(x) - unwrap(y));\\n    }\\n}\\n\\n/// @notice Implements the unchecked unary minus operation (-) in the SD59x18 type.\\nfunction uncheckedUnary(SD59x18 x) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(-unwrap(x));\\n    }\\n}\\n\\n/// @notice Implements the XOR (^) bitwise operation in the SD59x18 type.\\nfunction xor(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) ^ unwrap(y));\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/sd59x18/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { MAX_UINT128, MAX_UINT40, msb, mulDiv, mulDiv18, prbExp2, prbSqrt } from \\\"../Common.sol\\\";\\nimport {\\n    uHALF_UNIT,\\n    uLOG2_10,\\n    uLOG2_E,\\n    uMAX_SD59x18,\\n    uMAX_WHOLE_SD59x18,\\n    uMIN_SD59x18,\\n    uMIN_WHOLE_SD59x18,\\n    UNIT,\\n    uUNIT,\\n    ZERO\\n} from \\\"./Constants.sol\\\";\\nimport {\\n    PRBMath_SD59x18_Abs_MinSD59x18,\\n    PRBMath_SD59x18_Ceil_Overflow,\\n    PRBMath_SD59x18_Div_InputTooSmall,\\n    PRBMath_SD59x18_Div_Overflow,\\n    PRBMath_SD59x18_Exp_InputTooBig,\\n    PRBMath_SD59x18_Exp2_InputTooBig,\\n    PRBMath_SD59x18_Floor_Underflow,\\n    PRBMath_SD59x18_Gm_Overflow,\\n    PRBMath_SD59x18_Gm_NegativeProduct,\\n    PRBMath_SD59x18_Log_InputTooSmall,\\n    PRBMath_SD59x18_Mul_InputTooSmall,\\n    PRBMath_SD59x18_Mul_Overflow,\\n    PRBMath_SD59x18_Powu_Overflow,\\n    PRBMath_SD59x18_Sqrt_NegativeInput,\\n    PRBMath_SD59x18_Sqrt_Overflow\\n} from \\\"./Errors.sol\\\";\\nimport { unwrap, wrap } from \\\"./Helpers.sol\\\";\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Calculate the absolute value of x.\\n///\\n/// @dev Requirements:\\n/// - x must be greater than `MIN_SD59x18`.\\n///\\n/// @param x The SD59x18 number for which to calculate the absolute value.\\n/// @param result The absolute value of x as an SD59x18 number.\\nfunction abs(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt == uMIN_SD59x18) {\\n        revert PRBMath_SD59x18_Abs_MinSD59x18();\\n    }\\n    result = xInt < 0 ? wrap(-xInt) : x;\\n}\\n\\n/// @notice Calculates the arithmetic average of x and y, rounding towards zero.\\n/// @param x The first operand as an SD59x18 number.\\n/// @param y The second operand as an SD59x18 number.\\n/// @return result The arithmetic average as an SD59x18 number.\\nfunction avg(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    int256 yInt = unwrap(y);\\n\\n    unchecked {\\n        // This is equivalent to \\\"x / 2 +  y / 2\\\" but faster.\\n        // This operation can never overflow.\\n        int256 sum = (xInt >> 1) + (yInt >> 1);\\n\\n        if (sum < 0) {\\n            // If at least one of x and y is odd, we add 1 to the result, since shifting negative numbers to the right rounds\\n            // down to infinity. The right part is equivalent to \\\"sum + (x % 2 == 1 || y % 2 == 1)\\\" but faster.\\n            assembly (\\\"memory-safe\\\") {\\n                result := add(sum, and(or(xInt, yInt), 1))\\n            }\\n        } else {\\n            // We need to add 1 if both x and y are odd to account for the double 0.5 remainder that is truncated after shifting.\\n            result = wrap(sum + (xInt & yInt & 1));\\n        }\\n    }\\n}\\n\\n/// @notice Yields the smallest whole SD59x18 number greater than or equal to x.\\n///\\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n///\\n/// Requirements:\\n/// - x must be less than or equal to `MAX_WHOLE_SD59x18`.\\n///\\n/// @param x The SD59x18 number to ceil.\\n/// @param result The least number greater than or equal to x, as an SD59x18 number.\\nfunction ceil(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt > uMAX_WHOLE_SD59x18) {\\n        revert PRBMath_SD59x18_Ceil_Overflow(x);\\n    }\\n\\n    int256 remainder = xInt % uUNIT;\\n    if (remainder == 0) {\\n        result = x;\\n    } else {\\n        unchecked {\\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n            int256 resultInt = xInt - remainder;\\n            if (xInt > 0) {\\n                resultInt += uUNIT;\\n            }\\n            result = wrap(resultInt);\\n        }\\n    }\\n}\\n\\n/// @notice Divides two SD59x18 numbers, returning a new SD59x18 number. Rounds towards zero.\\n///\\n/// @dev This is a variant of `mulDiv` that works with signed numbers. Works by computing the signs and the absolute values\\n/// separately.\\n///\\n/// Requirements:\\n/// - All from `Common.mulDiv`.\\n/// - None of the inputs can be `MIN_SD59x18`.\\n/// - The denominator cannot be zero.\\n/// - The result must fit within int256.\\n///\\n/// Caveats:\\n/// - All from `Common.mulDiv`.\\n///\\n/// @param x The numerator as an SD59x18 number.\\n/// @param y The denominator as an SD59x18 number.\\n/// @param result The quotient as an SD59x18 number.\\nfunction div(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    int256 yInt = unwrap(y);\\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\\n        revert PRBMath_SD59x18_Div_InputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x and y.\\n    uint256 xAbs;\\n    uint256 yAbs;\\n    unchecked {\\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\\n    }\\n\\n    // Compute the absolute value (x*UNIT)\u00f7y. The resulting value must fit within int256.\\n    uint256 resultAbs = mulDiv(xAbs, uint256(uUNIT), yAbs);\\n    if (resultAbs > uint256(uMAX_SD59x18)) {\\n        revert PRBMath_SD59x18_Div_Overflow(x, y);\\n    }\\n\\n    // Check if x and y have the same sign. This works thanks to two's complement; the left-most bit is the sign bit.\\n    bool sameSign = (xInt ^ yInt) > -1;\\n\\n    // If the inputs don't have the same sign, the result should be negative. Otherwise, it should be positive.\\n    unchecked {\\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\\n    }\\n}\\n\\n/// @notice Calculates the natural exponent of x.\\n///\\n/// @dev Based on the formula:\\n///\\n/// $$\\n/// e^x = 2^{x * log_2{e}}\\n/// $$\\n///\\n/// Requirements:\\n/// - All from `log2`.\\n/// - x must be less than 133.084258667509499441.\\n///\\n/// Caveats:\\n/// - All from `exp2`.\\n/// - For any x less than -41.446531673892822322, the result is zero.\\n///\\n/// @param x The exponent as an SD59x18 number.\\n/// @return result The result as an SD59x18 number.\\nfunction exp(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    // Without this check, the value passed to `exp2` would be less than -59.794705707972522261.\\n    if (xInt < -41_446531673892822322) {\\n        return ZERO;\\n    }\\n\\n    // Without this check, the value passed to `exp2` would be greater than 192.\\n    if (xInt >= 133_084258667509499441) {\\n        revert PRBMath_SD59x18_Exp_InputTooBig(x);\\n    }\\n\\n    unchecked {\\n        // Do the fixed-point multiplication inline to save gas.\\n        int256 doubleUnitProduct = xInt * uLOG2_E;\\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\\n    }\\n}\\n\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\n///\\n/// @dev Based on the formula:\\n///\\n/// $$\\n/// 2^{-x} = \\\\frac{1}{2^x}\\n/// $$\\n///\\n/// See https://ethereum.stackexchange.com/q/79903/24693.\\n///\\n/// Requirements:\\n/// - x must be 192 or less.\\n/// - The result must fit within `MAX_SD59x18`.\\n///\\n/// Caveats:\\n/// - For any x less than -59.794705707972522261, the result is zero.\\n///\\n/// @param x The exponent as an SD59x18 number.\\n/// @return result The result as an SD59x18 number.\\nfunction exp2(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt < 0) {\\n        // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\\n        if (xInt < -59_794705707972522261) {\\n            return ZERO;\\n        }\\n\\n        unchecked {\\n            // Do the fixed-point inversion $1/2^x$ inline to save gas. 1e36 is UNIT * UNIT.\\n            result = wrap(1e36 / unwrap(exp2(wrap(-xInt))));\\n        }\\n    } else {\\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\\n        if (xInt >= 192e18) {\\n            revert PRBMath_SD59x18_Exp2_InputTooBig(x);\\n        }\\n\\n        unchecked {\\n            // Convert x to the 192.64-bit fixed-point format.\\n            uint256 x_192x64 = uint256((xInt << 64) / uUNIT);\\n\\n            // It is safe to convert the result to int256 with no checks because the maximum input allowed in this function is 192.\\n            result = wrap(int256(prbExp2(x_192x64)));\\n        }\\n    }\\n}\\n\\n/// @notice Yields the greatest whole SD59x18 number less than or equal to x.\\n///\\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n///\\n/// Requirements:\\n/// - x must be greater than or equal to `MIN_WHOLE_SD59x18`.\\n///\\n/// @param x The SD59x18 number to floor.\\n/// @param result The greatest integer less than or equal to x, as an SD59x18 number.\\nfunction floor(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt < uMIN_WHOLE_SD59x18) {\\n        revert PRBMath_SD59x18_Floor_Underflow(x);\\n    }\\n\\n    int256 remainder = xInt % uUNIT;\\n    if (remainder == 0) {\\n        result = x;\\n    } else {\\n        unchecked {\\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n            int256 resultInt = xInt - remainder;\\n            if (xInt < 0) {\\n                resultInt -= uUNIT;\\n            }\\n            result = wrap(resultInt);\\n        }\\n    }\\n}\\n\\n/// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right.\\n/// of the radix point for negative numbers.\\n/// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\\n/// @param x The SD59x18 number to get the fractional part of.\\n/// @param result The fractional part of x as an SD59x18 number.\\nfunction frac(SD59x18 x) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) % uUNIT);\\n}\\n\\n/// @notice Calculates the geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n///\\n/// @dev Requirements:\\n/// - x * y must fit within `MAX_SD59x18`, lest it overflows.\\n/// - x * y must not be negative, since this library does not handle complex numbers.\\n///\\n/// @param x The first operand as an SD59x18 number.\\n/// @param y The second operand as an SD59x18 number.\\n/// @return result The result as an SD59x18 number.\\nfunction gm(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    int256 yInt = unwrap(y);\\n    if (xInt == 0 || yInt == 0) {\\n        return ZERO;\\n    }\\n\\n    unchecked {\\n        // Equivalent to \\\"xy / x != y\\\". Checking for overflow this way is faster than letting Solidity do it.\\n        int256 xyInt = xInt * yInt;\\n        if (xyInt / xInt != yInt) {\\n            revert PRBMath_SD59x18_Gm_Overflow(x, y);\\n        }\\n\\n        // The product must not be negative, since this library does not handle complex numbers.\\n        if (xyInt < 0) {\\n            revert PRBMath_SD59x18_Gm_NegativeProduct(x, y);\\n        }\\n\\n        // We don't need to multiply the result by `UNIT` here because the x*y product had picked up a factor of `UNIT`\\n        // during multiplication. See the comments within the `prbSqrt` function.\\n        uint256 resultUint = prbSqrt(uint256(xyInt));\\n        result = wrap(int256(resultUint));\\n    }\\n}\\n\\n/// @notice Calculates 1 / x, rounding toward zero.\\n///\\n/// @dev Requirements:\\n/// - x cannot be zero.\\n///\\n/// @param x The SD59x18 number for which to calculate the inverse.\\n/// @return result The inverse as an SD59x18 number.\\nfunction inv(SD59x18 x) pure returns (SD59x18 result) {\\n    // 1e36 is UNIT * UNIT.\\n    result = wrap(1e36 / unwrap(x));\\n}\\n\\n/// @notice Calculates the natural logarithm of x.\\n///\\n/// @dev Based on the formula:\\n///\\n/// $$\\n/// ln{x} = log_2{x} / log_2{e}$$.\\n/// $$\\n///\\n/// Requirements:\\n/// - All from `log2`.\\n///\\n/// Caveats:\\n/// - All from `log2`.\\n/// - This doesn't return exactly 1 for 2.718281828459045235, for that more fine-grained precision is needed.\\n///\\n/// @param x The SD59x18 number for which to calculate the natural logarithm.\\n/// @return result The natural logarithm as an SD59x18 number.\\nfunction ln(SD59x18 x) pure returns (SD59x18 result) {\\n    // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n    // can return is 195.205294292027477728.\\n    result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_E);\\n}\\n\\n/// @notice Calculates the common logarithm of x.\\n///\\n/// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n/// logarithm based on the formula:\\n///\\n/// $$\\n/// log_{10}{x} = log_2{x} / log_2{10}\\n/// $$\\n///\\n/// Requirements:\\n/// - All from `log2`.\\n///\\n/// Caveats:\\n/// - All from `log2`.\\n///\\n/// @param x The SD59x18 number for which to calculate the common logarithm.\\n/// @return result The common logarithm as an SD59x18 number.\\nfunction log10(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMath_SD59x18_Log_InputTooSmall(x);\\n    }\\n\\n    // Note that the `mul` in this block is the assembly mul operation, not the SD59x18 `mul`.\\n    // prettier-ignore\\n    assembly (\\\"memory-safe\\\") {\\n        switch x\\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\\n        case 1000000000000000000 { result := 0 }\\n        case 10000000000000000000 { result := uUNIT }\\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\\n        default {\\n            result := uMAX_SD59x18\\n        }\\n    }\\n\\n    if (unwrap(result) == uMAX_SD59x18) {\\n        unchecked {\\n            // Do the fixed-point division inline to save gas.\\n            result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_10);\\n        }\\n    }\\n}\\n\\n/// @notice Calculates the binary logarithm of x.\\n///\\n/// @dev Based on the iterative approximation algorithm.\\n/// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n///\\n/// Requirements:\\n/// - x must be greater than zero.\\n///\\n/// Caveats:\\n/// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n///\\n/// @param x The SD59x18 number for which to calculate the binary logarithm.\\n/// @return result The binary logarithm as an SD59x18 number.\\nfunction log2(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt <= 0) {\\n        revert PRBMath_SD59x18_Log_InputTooSmall(x);\\n    }\\n\\n    unchecked {\\n        // This works because of:\\n        //\\n        // $$\\n        // log_2{x} = -log_2{\\\\frac{1}{x}}\\n        // $$\\n        int256 sign;\\n        if (xInt >= uUNIT) {\\n            sign = 1;\\n        } else {\\n            sign = -1;\\n            // Do the fixed-point inversion inline to save gas. The numerator is UNIT * UNIT.\\n            xInt = 1e36 / xInt;\\n        }\\n\\n        // Calculate the integer part of the logarithm and add it to the result and finally calculate $y = x * 2^(-n)$.\\n        uint256 n = msb(uint256(xInt / uUNIT));\\n\\n        // This is the integer part of the logarithm as an SD59x18 number. The operation can't overflow\\n        // because n is maximum 255, UNIT is 1e18 and sign is either 1 or -1.\\n        int256 resultInt = int256(n) * uUNIT;\\n\\n        // This is $y = x * 2^{-n}$.\\n        int256 y = xInt >> n;\\n\\n        // If y is 1, the fractional part is zero.\\n        if (y == uUNIT) {\\n            return wrap(resultInt * sign);\\n        }\\n\\n        // Calculate the fractional part via the iterative approximation.\\n        // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n        int256 DOUBLE_UNIT = 2e18;\\n        for (int256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\\n            y = (y * y) / uUNIT;\\n\\n            // Is $y^2 > 2$ and so in the range [2,4)?\\n            if (y >= DOUBLE_UNIT) {\\n                // Add the 2^{-m} factor to the logarithm.\\n                resultInt = resultInt + delta;\\n\\n                // Corresponds to z/2 on Wikipedia.\\n                y >>= 1;\\n            }\\n        }\\n        resultInt *= sign;\\n        result = wrap(resultInt);\\n    }\\n}\\n\\n/// @notice Multiplies two SD59x18 numbers together, returning a new SD59x18 number.\\n///\\n/// @dev This is a variant of `mulDiv` that works with signed numbers and employs constant folding, i.e. the denominator\\n/// is always 1e18.\\n///\\n/// Requirements:\\n/// - All from `Common.mulDiv18`.\\n/// - None of the inputs can be `MIN_SD59x18`.\\n/// - The result must fit within `MAX_SD59x18`.\\n///\\n/// Caveats:\\n/// - To understand how this works in detail, see the NatSpec comments in `Common.mulDivSigned`.\\n///\\n/// @param x The multiplicand as an SD59x18 number.\\n/// @param y The multiplier as an SD59x18 number.\\n/// @return result The product as an SD59x18 number.\\nfunction mul(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    int256 yInt = unwrap(y);\\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\\n        revert PRBMath_SD59x18_Mul_InputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x and y.\\n    uint256 xAbs;\\n    uint256 yAbs;\\n    unchecked {\\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\\n    }\\n\\n    uint256 resultAbs = mulDiv18(xAbs, yAbs);\\n    if (resultAbs > uint256(uMAX_SD59x18)) {\\n        revert PRBMath_SD59x18_Mul_Overflow(x, y);\\n    }\\n\\n    // Check if x and y have the same sign. This works thanks to two's complement; the left-most bit is the sign bit.\\n    bool sameSign = (xInt ^ yInt) > -1;\\n\\n    // If the inputs have the same sign, the result should be negative. Otherwise, it should be positive.\\n    unchecked {\\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\\n    }\\n}\\n\\n/// @notice Raises x to the power of y.\\n///\\n/// @dev Based on the formula:\\n///\\n/// $$\\n/// x^y = 2^{log_2{x} * y}\\n/// $$\\n///\\n/// Requirements:\\n/// - All from `exp2`, `log2` and `mul`.\\n/// - x cannot be zero.\\n///\\n/// Caveats:\\n/// - All from `exp2`, `log2` and `mul`.\\n/// - Assumes 0^0 is 1.\\n///\\n/// @param x Number to raise to given power y, as an SD59x18 number.\\n/// @param y Exponent to raise x to, as an SD59x18 number\\n/// @return result x raised to power y, as an SD59x18 number.\\nfunction pow(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    int256 yInt = unwrap(y);\\n\\n    if (xInt == 0) {\\n        result = yInt == 0 ? UNIT : ZERO;\\n    } else {\\n        if (yInt == uUNIT) {\\n            result = x;\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n}\\n\\n/// @notice Raises x (an SD59x18 number) to the power y (unsigned basic integer) using the famous algorithm\\n/// algorithm \\\"exponentiation by squaring\\\".\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n///\\n/// Requirements:\\n/// - All from `abs` and `Common.mulDiv18`.\\n/// - The result must fit within `MAX_SD59x18`.\\n///\\n/// Caveats:\\n/// - All from `Common.mulDiv18`.\\n/// - Assumes 0^0 is 1.\\n///\\n/// @param x The base as an SD59x18 number.\\n/// @param y The exponent as an uint256.\\n/// @return result The result as an SD59x18 number.\\nfunction powu(SD59x18 x, uint256 y) pure returns (SD59x18 result) {\\n    uint256 xAbs = uint256(unwrap(abs(x)));\\n\\n    // Calculate the first iteration of the loop in advance.\\n    uint256 resultAbs = y & 1 > 0 ? xAbs : uint256(uUNIT);\\n\\n    // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n    uint256 yAux = y;\\n    for (yAux >>= 1; yAux > 0; yAux >>= 1) {\\n        xAbs = mulDiv18(xAbs, xAbs);\\n\\n        // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n        if (yAux & 1 > 0) {\\n            resultAbs = mulDiv18(resultAbs, xAbs);\\n        }\\n    }\\n\\n    // The result must fit within `MAX_SD59x18`.\\n    if (resultAbs > uint256(uMAX_SD59x18)) {\\n        revert PRBMath_SD59x18_Powu_Overflow(x, y);\\n    }\\n\\n    unchecked {\\n        // Is the base negative and the exponent an odd number?\\n        int256 resultInt = int256(resultAbs);\\n        bool isNegative = unwrap(x) < 0 && y & 1 == 1;\\n        if (isNegative) {\\n            resultInt = -resultInt;\\n        }\\n        result = wrap(resultInt);\\n    }\\n}\\n\\n/// @notice Calculates the square root of x, rounding down. Only the positive root is returned.\\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n///\\n/// Requirements:\\n/// - x cannot be negative, since this library does not handle complex numbers.\\n/// - x must be less than `MAX_SD59x18` divided by `UNIT`.\\n///\\n/// @param x The SD59x18 number for which to calculate the square root.\\n/// @return result The result as an SD59x18 number.\\nfunction sqrt(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMath_SD59x18_Sqrt_NegativeInput(x);\\n    }\\n    if (xInt > uMAX_SD59x18 / uUNIT) {\\n        revert PRBMath_SD59x18_Sqrt_Overflow(x);\\n    }\\n\\n    unchecked {\\n        // Multiply x by `UNIT` to account for the factor of `UNIT` that is picked up when multiplying two SD59x18\\n        // numbers together (in this case, the two numbers are both the square root).\\n        uint256 resultUint = prbSqrt(uint256(xInt * uUNIT));\\n        result = wrap(int256(resultUint));\\n    }\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/sd59x18/ValueType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"./Casting.sol\\\" as C;\\nimport \\\"./Helpers.sol\\\" as H;\\nimport \\\"./Math.sol\\\" as M;\\n\\n/// @notice The signed 59.18-decimal fixed-point number representation, which can have up to 59 digits and up to 18 decimals.\\n/// The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity type int256.\\ntype SD59x18 is int256;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CASTING\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    C.intoInt256,\\n    C.intoSD1x18,\\n    C.intoUD2x18,\\n    C.intoUD60x18,\\n    C.intoUint256,\\n    C.intoUint128,\\n    C.intoUint40,\\n    C.unwrap\\n} for SD59x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            MATHEMATICAL FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    M.abs,\\n    M.avg,\\n    M.ceil,\\n    M.div,\\n    M.exp,\\n    M.exp2,\\n    M.floor,\\n    M.frac,\\n    M.gm,\\n    M.inv,\\n    M.log10,\\n    M.log2,\\n    M.ln,\\n    M.mul,\\n    M.pow,\\n    M.powu,\\n    M.sqrt\\n} for SD59x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                HELPER FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    H.add,\\n    H.and,\\n    H.eq,\\n    H.gt,\\n    H.gte,\\n    H.isZero,\\n    H.lshift,\\n    H.lt,\\n    H.lte,\\n    H.mod,\\n    H.neq,\\n    H.or,\\n    H.rshift,\\n    H.sub,\\n    H.uncheckedAdd,\\n    H.uncheckedSub,\\n    H.uncheckedUnary,\\n    H.xor\\n} for SD59x18 global;\\n\"\r\n    },\r\n    \"@prb/math/src/ud2x18/Casting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { MAX_UINT40 } from \\\"../Common.sol\\\";\\nimport { uMAX_SD1x18 } from \\\"../sd1x18/Constants.sol\\\";\\nimport { SD1x18 } from \\\"../sd1x18/ValueType.sol\\\";\\nimport { SD59x18 } from \\\"../sd59x18/ValueType.sol\\\";\\nimport { UD2x18 } from \\\"../ud2x18/ValueType.sol\\\";\\nimport { UD60x18 } from \\\"../ud60x18/ValueType.sol\\\";\\nimport { PRBMath_UD2x18_IntoSD1x18_Overflow, PRBMath_UD2x18_IntoUint40_Overflow } from \\\"./Errors.sol\\\";\\nimport { UD2x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Casts an UD2x18 number into SD1x18.\\n/// - x must be less than or equal to `uMAX_SD1x18`.\\nfunction intoSD1x18(UD2x18 x) pure returns (SD1x18 result) {\\n    uint64 xUint = UD2x18.unwrap(x);\\n    if (xUint > uint64(uMAX_SD1x18)) {\\n        revert PRBMath_UD2x18_IntoSD1x18_Overflow(x);\\n    }\\n    result = SD1x18.wrap(int64(xUint));\\n}\\n\\n/// @notice Casts an UD2x18 number into SD59x18.\\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of SD59x18.\\nfunction intoSD59x18(UD2x18 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(int256(uint256(UD2x18.unwrap(x))));\\n}\\n\\n/// @notice Casts an UD2x18 number into UD60x18.\\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of UD60x18.\\nfunction intoUD60x18(UD2x18 x) pure returns (UD60x18 result) {\\n    result = UD60x18.wrap(UD2x18.unwrap(x));\\n}\\n\\n/// @notice Casts an UD2x18 number into uint128.\\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of uint128.\\nfunction intoUint128(UD2x18 x) pure returns (uint128 result) {\\n    result = uint128(UD2x18.unwrap(x));\\n}\\n\\n/// @notice Casts an UD2x18 number into uint256.\\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of uint256.\\nfunction intoUint256(UD2x18 x) pure returns (uint256 result) {\\n    result = uint256(UD2x18.unwrap(x));\\n}\\n\\n/// @notice Casts an UD2x18 number into uint40.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `MAX_UINT40`.\\nfunction intoUint40(UD2x18 x) pure returns (uint40 result) {\\n    uint64 xUint = UD2x18.unwrap(x);\\n    if (xUint > uint64(MAX_UINT40)) {\\n        revert PRBMath_UD2x18_IntoUint40_Overflow(x);\\n    }\\n    result = uint40(xUint);\\n}\\n\\n/// @notice Alias for the `wrap` function.\\nfunction ud2x18(uint64 x) pure returns (UD2x18 result) {\\n    result = wrap(x);\\n}\\n\\n/// @notice Unwrap an UD2x18 number into uint64.\\nfunction unwrap(UD2x18 x) pure returns (uint64 result) {\\n    result = UD2x18.unwrap(x);\\n}\\n\\n/// @notice Wraps an uint64 number into the UD2x18 value type.\\nfunction wrap(uint64 x) pure returns (UD2x18 result) {\\n    result = UD2x18.wrap(x);\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/ud2x18/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { UD2x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @dev Euler's number as an UD2x18 number.\\nUD2x18 constant E = UD2x18.wrap(2_718281828459045235);\\n\\n/// @dev The maximum value an UD2x18 number can have.\\nuint64 constant uMAX_UD2x18 = 18_446744073709551615;\\nUD2x18 constant MAX_UD2x18 = UD2x18.wrap(uMAX_UD2x18);\\n\\n/// @dev PI as an UD2x18 number.\\nUD2x18 constant PI = UD2x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit amount that implies how many trailing decimals can be represented.\\nuint256 constant uUNIT = 1e18;\\nUD2x18 constant UNIT = UD2x18.wrap(1e18);\\n\"\r\n    },\r\n    \"@prb/math/src/ud2x18/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { UD2x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Emitted when trying to cast a UD2x18 number that doesn't fit in SD1x18.\\nerror PRBMath_UD2x18_IntoSD1x18_Overflow(UD2x18 x);\\n\\n/// @notice Emitted when trying to cast a UD2x18 number that doesn't fit in uint40.\\nerror PRBMath_UD2x18_IntoUint40_Overflow(UD2x18 x);\\n\"\r\n    },\r\n    \"@prb/math/src/ud2x18/ValueType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"./Casting.sol\\\" as C;\\n\\n/// @notice The unsigned 2.18-decimal fixed-point number representation, which can have up to 2 digits and up to 18 decimals.\\n/// The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity type uint64.\\n/// This is useful when end users want to use uint64 to save gas, e.g. with tight variable packing in contract storage.\\ntype UD2x18 is uint64;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CASTING\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing { C.intoSD1x18, C.intoSD59x18, C.intoUD60x18, C.intoUint256, C.intoUint128, C.intoUint40, C.unwrap } for UD2x18 global;\\n\"\r\n    },\r\n    \"@prb/math/src/ud60x18/Casting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { MAX_UINT128, MAX_UINT40 } from \\\"../Common.sol\\\";\\nimport { uMAX_SD1x18 } from \\\"../sd1x18/Constants.sol\\\";\\nimport { SD1x18 } from \\\"../sd1x18/ValueType.sol\\\";\\nimport { uMAX_SD59x18 } from \\\"../sd59x18/Constants.sol\\\";\\nimport { SD59x18 } from \\\"../sd59x18/ValueType.sol\\\";\\nimport { uMAX_UD2x18 } from \\\"../ud2x18/Constants.sol\\\";\\nimport { UD2x18 } from \\\"../ud2x18/ValueType.sol\\\";\\nimport {\\n    PRBMath_UD60x18_IntoSD1x18_Overflow,\\n    PRBMath_UD60x18_IntoUD2x18_Overflow,\\n    PRBMath_UD60x18_IntoSD59x18_Overflow,\\n    PRBMath_UD60x18_IntoUint128_Overflow,\\n    PRBMath_UD60x18_IntoUint40_Overflow\\n} from \\\"./Errors.sol\\\";\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Casts an UD60x18 number into SD1x18.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `uMAX_SD1x18`.\\nfunction intoSD1x18(UD60x18 x) pure returns (SD1x18 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > uint256(int256(uMAX_SD1x18))) {\\n        revert PRBMath_UD60x18_IntoSD1x18_Overflow(x);\\n    }\\n    result = SD1x18.wrap(int64(uint64(xUint)));\\n}\\n\\n/// @notice Casts an UD60x18 number into UD2x18.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `uMAX_UD2x18`.\\nfunction intoUD2x18(UD60x18 x) pure returns (UD2x18 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > uMAX_UD2x18) {\\n        revert PRBMath_UD60x18_IntoUD2x18_Overflow(x);\\n    }\\n    result = UD2x18.wrap(uint64(xUint));\\n}\\n\\n/// @notice Casts an UD60x18 number into SD59x18.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `uMAX_SD59x18`.\\nfunction intoSD59x18(UD60x18 x) pure returns (SD59x18 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > uint256(uMAX_SD59x18)) {\\n        revert PRBMath_UD60x18_IntoSD59x18_Overflow(x);\\n    }\\n    result = SD59x18.wrap(int256(xUint));\\n}\\n\\n/// @notice Casts an UD60x18 number into uint128.\\n/// @dev This is basically a functional alias for the `unwrap` function.\\nfunction intoUint256(UD60x18 x) pure returns (uint256 result) {\\n    result = UD60x18.unwrap(x);\\n}\\n\\n/// @notice Casts an UD60x18 number into uint128.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `MAX_UINT128`.\\nfunction intoUint128(UD60x18 x) pure returns (uint128 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > MAX_UINT128) {\\n        revert PRBMath_UD60x18_IntoUint128_Overflow(x);\\n    }\\n    result = uint128(xUint);\\n}\\n\\n/// @notice Casts an UD60x18 number into uint40.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `MAX_UINT40`.\\nfunction intoUint40(UD60x18 x) pure returns (uint40 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > MAX_UINT40) {\\n        revert PRBMath_UD60x18_IntoUint40_Overflow(x);\\n    }\\n    result = uint40(xUint);\\n}\\n\\n/// @notice Alias for the `wrap` function.\\nfunction ud(uint256 x) pure returns (UD60x18 result) {\\n    result = wrap(x);\\n}\\n\\n/// @notice Alias for the `wrap` function.\\nfunction ud60x18(uint256 x) pure returns (UD60x18 result) {\\n    result = wrap(x);\\n}\\n\\n/// @notice Unwraps an UD60x18 number into uint256.\\nfunction unwrap(UD60x18 x) pure returns (uint256 result) {\\n    result = UD60x18.unwrap(x);\\n}\\n\\n/// @notice Wraps an uint256 number into the UD60x18 value type.\\nfunction wrap(uint256 x) pure returns (UD60x18 result) {\\n    result = UD60x18.wrap(x);\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/ud60x18/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @dev Euler's number as an UD60x18 number.\\nUD60x18 constant E = UD60x18.wrap(2_718281828459045235);\\n\\n/// @dev Half the UNIT number.\\nuint256 constant uHALF_UNIT = 0.5e18;\\nUD60x18 constant HALF_UNIT = UD60x18.wrap(uHALF_UNIT);\\n\\n/// @dev log2(10) as an UD60x18 number.\\nuint256 constant uLOG2_10 = 3_321928094887362347;\\nUD60x18 constant LOG2_10 = UD60x18.wrap(uLOG2_10);\\n\\n/// @dev log2(e) as an UD60x18 number.\\nuint256 constant uLOG2_E = 1_442695040888963407;\\nUD60x18 constant LOG2_E = UD60x18.wrap(uLOG2_E);\\n\\n/// @dev The maximum value an UD60x18 number can have.\\nuint256 constant uMAX_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_584007913129639935;\\nUD60x18 constant MAX_UD60x18 = UD60x18.wrap(uMAX_UD60x18);\\n\\n/// @dev The maximum whole value an UD60x18 number can have.\\nuint256 constant uMAX_WHOLE_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_000000000000000000;\\nUD60x18 constant MAX_WHOLE_UD60x18 = UD60x18.wrap(uMAX_WHOLE_UD60x18);\\n\\n/// @dev PI as an UD60x18 number.\\nUD60x18 constant PI = UD60x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit amount that implies how many trailing decimals can be represented.\\nuint256 constant uUNIT = 1e18;\\nUD60x18 constant UNIT = UD60x18.wrap(uUNIT);\\n\\n/// @dev Zero as an UD60x18 number.\\nUD60x18 constant ZERO = UD60x18.wrap(0);\\n\"\r\n    },\r\n    \"@prb/math/src/ud60x18/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Emitted when ceiling a number overflows UD60x18.\\nerror PRBMath_UD60x18_Ceil_Overflow(UD60x18 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows UD60x18.\\nerror PRBMath_UD60x18_Convert_Overflow(uint256 x);\\n\\n/// @notice Emitted when taking the natural exponent of a base greater than 133.084258667509499441.\\nerror PRBMath_UD60x18_Exp_InputTooBig(UD60x18 x);\\n\\n/// @notice Emitted when taking the binary exponent of a base greater than 192.\\nerror PRBMath_UD60x18_Exp2_InputTooBig(UD60x18 x);\\n\\n/// @notice Emitted when taking the geometric mean of two numbers and multiplying them overflows UD60x18.\\nerror PRBMath_UD60x18_Gm_Overflow(UD60x18 x, UD60x18 y);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in SD1x18.\\nerror PRBMath_UD60x18_IntoSD1x18_Overflow(UD60x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in SD59x18.\\nerror PRBMath_UD60x18_IntoSD59x18_Overflow(UD60x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in UD2x18.\\nerror PRBMath_UD60x18_IntoUD2x18_Overflow(UD60x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint128.\\nerror PRBMath_UD60x18_IntoUint128_Overflow(UD60x18 x);\\n\\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint40.\\nerror PRBMath_UD60x18_IntoUint40_Overflow(UD60x18 x);\\n\\n/// @notice Emitted when taking the logarithm of a number less than 1.\\nerror PRBMath_UD60x18_Log_InputTooSmall(UD60x18 x);\\n\\n/// @notice Emitted when calculating the square root overflows UD60x18.\\nerror PRBMath_UD60x18_Sqrt_Overflow(UD60x18 x);\\n\"\r\n    },\r\n    \"@prb/math/src/ud60x18/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { unwrap, wrap } from \\\"./Casting.sol\\\";\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Implements the checked addition operation (+) in the UD60x18 type.\\nfunction add(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(unwrap(x) + unwrap(y));\\n}\\n\\n/// @notice Implements the AND (&) bitwise operation in the UD60x18 type.\\nfunction and(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\\n    result = wrap(unwrap(x) & bits);\\n}\\n\\n/// @notice Implements the equal operation (==) in the UD60x18 type.\\nfunction eq(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = unwrap(x) == unwrap(y);\\n}\\n\\n/// @notice Implements the greater than operation (>) in the UD60x18 type.\\nfunction gt(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = unwrap(x) > unwrap(y);\\n}\\n\\n/// @notice Implements the greater than or equal to operation (>=) in the UD60x18 type.\\nfunction gte(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = unwrap(x) >= unwrap(y);\\n}\\n\\n/// @notice Implements a zero comparison check function in the UD60x18 type.\\nfunction isZero(UD60x18 x) pure returns (bool result) {\\n    // This wouldn't work if x could be negative.\\n    result = unwrap(x) == 0;\\n}\\n\\n/// @notice Implements the left shift operation (<<) in the UD60x18 type.\\nfunction lshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\\n    result = wrap(unwrap(x) << bits);\\n}\\n\\n/// @notice Implements the lower than operation (<) in the UD60x18 type.\\nfunction lt(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = unwrap(x) < unwrap(y);\\n}\\n\\n/// @notice Implements the lower than or equal to operation (<=) in the UD60x18 type.\\nfunction lte(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = unwrap(x) <= unwrap(y);\\n}\\n\\n/// @notice Implements the checked modulo operation (%) in the UD60x18 type.\\nfunction mod(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(unwrap(x) % unwrap(y));\\n}\\n\\n/// @notice Implements the not equal operation (!=) in the UD60x18 type\\nfunction neq(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = unwrap(x) != unwrap(y);\\n}\\n\\n/// @notice Implements the OR (|) bitwise operation in the UD60x18 type.\\nfunction or(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(unwrap(x) | unwrap(y));\\n}\\n\\n/// @notice Implements the right shift operation (>>) in the UD60x18 type.\\nfunction rshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\\n    result = wrap(unwrap(x) >> bits);\\n}\\n\\n/// @notice Implements the checked subtraction operation (-) in the UD60x18 type.\\nfunction sub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(unwrap(x) - unwrap(y));\\n}\\n\\n/// @notice Implements the unchecked addition operation (+) in the UD60x18 type.\\nfunction uncheckedAdd(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    unchecked {\\n        result = wrap(unwrap(x) + unwrap(y));\\n    }\\n}\\n\\n/// @notice Implements the unchecked subtraction operation (-) in the UD60x18 type.\\nfunction uncheckedSub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    unchecked {\\n        result = wrap(unwrap(x) - unwrap(y));\\n    }\\n}\\n\\n/// @notice Implements the XOR (^) bitwise operation in the UD60x18 type.\\nfunction xor(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(unwrap(x) ^ unwrap(y));\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/ud60x18/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { msb, mulDiv, mulDiv18, prbExp2, prbSqrt } from \\\"../Common.sol\\\";\\nimport { unwrap, wrap } from \\\"./Casting.sol\\\";\\nimport { uHALF_UNIT, uLOG2_10, uLOG2_E, uMAX_UD60x18, uMAX_WHOLE_UD60x18, UNIT, uUNIT, ZERO } from \\\"./Constants.sol\\\";\\nimport {\\n    PRBMath_UD60x18_Ceil_Overflow,\\n    PRBMath_UD60x18_Exp_InputTooBig,\\n    PRBMath_UD60x18_Exp2_InputTooBig,\\n    PRBMath_UD60x18_Gm_Overflow,\\n    PRBMath_UD60x18_Log_InputTooSmall,\\n    PRBMath_UD60x18_Sqrt_Overflow\\n} from \\\"./Errors.sol\\\";\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            MATHEMATICAL FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Calculates the arithmetic average of x and y, rounding down.\\n///\\n/// @dev Based on the formula:\\n///\\n/// $$\\n/// avg(x, y) = (x & y) + ((xUint ^ yUint) / 2)\\n/// $$\\n//\\n/// In English, what this formula does is:\\n///\\n/// 1. AND x and y.\\n/// 2. Calculate half of XOR x and y.\\n/// 3. Add the two results together.\\n///\\n/// This technique is known as SWAR, which stands for \\\"SIMD within a register\\\". You can read more about it here:\\n/// https://devblogs.microsoft.com/oldnewthing/20220207-00/?p=106223\\n///\\n/// @param x The first operand as an UD60x18 number.\\n/// @param y The second operand as an UD60x18 number.\\n/// @return result The arithmetic average as an UD60x18 number.\\nfunction avg(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    uint256 xUint = unwrap(x);\\n    uint256 yUint = unwrap(y);\\n    unchecked {\\n        result = wrap((xUint & yUint) + ((xUint ^ yUint) >> 1));\\n    }\\n}\\n\\n/// @notice Yields the smallest whole UD60x18 number greater than or equal to x.\\n///\\n/// @dev This is optimized for fractional value inputs, because for every whole value there are \\\"1e18 - 1\\\" fractional\\n/// counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n///\\n/// Requirements:\\n/// - x must be less than or equal to `MAX_WHOLE_UD60x18`.\\n///\\n/// @param x The UD60x18 number to ceil.\\n/// @param result The least number greater than or equal to x, as an UD60x18 number.\\nfunction ceil(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = unwrap(x);\\n    if (xUint > uMAX_WHOLE_UD60x18) {\\n        revert PRBMath_UD60x18_Ceil_Overflow(x);\\n    }\\n\\n    assembly (\\\"memory-safe\\\") {\\n        // Equivalent to \\\"x % UNIT\\\" but faster.\\n        let remainder := mod(x, uUNIT)\\n\\n        // Equivalent to \\\"UNIT - remainder\\\" but faster.\\n        let delta := sub(uUNIT, remainder)\\n\\n        // Equivalent to \\\"x + delta * (remainder > 0 ? 1 : 0)\\\" but faster.\\n        result := add(x, mul(delta, gt(remainder, 0)))\\n    }\\n}\\n\\n/// @notice Divides two UD60x18 numbers, returning a new UD60x18 number. Rounds towards zero.\\n///\\n/// @dev Uses `mulDiv` to enable overflow-safe multiplication and division.\\n///\\n/// Requirements:\\n/// - The denominator cannot be zero.\\n///\\n/// @param x The numerator as an UD60x18 number.\\n/// @param y The denominator as an UD60x18 number.\\n/// @param result The quotient as an UD60x18 number.\\nfunction div(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(mulDiv(unwrap(x), uUNIT, unwrap(y)));\\n}\\n\\n/// @notice Calculates the natural exponent of x.\\n///\\n/// @dev Based on the formula:\\n///\\n/// $$\\n/// e^x = 2^{x * log_2{e}}\\n/// $$\\n///\\n/// Requirements:\\n/// - All from `log2`.\\n/// - x must be less than 133.084258667509499441.\\n///\\n/// @param x The exponent as an UD60x18 number.\\n/// @return result The result as an UD60x18 number.\\nfunction exp(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = unwrap(x);\\n\\n    // Without this check, the value passed to `exp2` would be greater than 192.\\n    if (xUint >= 133_084258667509499441) {\\n        revert PRBMath_UD60x18_Exp_InputTooBig(x);\\n    }\\n\\n    unchecked {\\n        // We do the fixed-point multiplication inline rather than via the `mul` function to save gas.\\n        uint256 doubleUnitProduct = xUint * uLOG2_E;\\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\\n    }\\n}\\n\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\n///\\n/// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n///\\n/// Requirements:\\n/// - x must be 192 or less.\\n/// - The result must fit within `MAX_UD60x18`.\\n///\\n/// @param x The exponent as an UD60x18 number.\\n/// @return result The result as an UD60x18 number.\\nfunction exp2(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = unwrap(x);\\n\\n    // Numbers greater than or equal to 2^192 don't fit within the 192.64-bit format.\\n    if (xUint >= 192e18) {\\n        revert PRBMath_UD60x18_Exp2_InputTooBig(x);\\n    }\\n\\n    // Convert x to the 192.64-bit fixed-point format.\\n    uint256 x_192x64 = (xUint << 64) / uUNIT;\\n\\n    // Pass x to the `prbExp2` function, which uses the 192.64-bit fixed-point number representation.\\n    result = wrap(prbExp2(x_192x64));\\n}\\n\\n/// @notice Yields the greatest whole UD60x18 number less than or equal to x.\\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n/// @param x The UD60x18 number to floor.\\n/// @param result The greatest integer less than or equal to x, as an UD60x18 number.\\nfunction floor(UD60x18 x) pure returns (UD60x18 result) {\\n    assembly (\\\"memory-safe\\\") {\\n        // Equivalent to \\\"x % UNIT\\\" but faster.\\n        let remainder := mod(x, uUNIT)\\n\\n        // Equivalent to \\\"x - remainder * (remainder > 0 ? 1 : 0)\\\" but faster.\\n        result := sub(x, mul(remainder, gt(remainder, 0)))\\n    }\\n}\\n\\n/// @notice Yields the excess beyond the floor of x.\\n/// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\\n/// @param x The UD60x18 number to get the fractional part of.\\n/// @param result The fractional part of x as an UD60x18 number.\\nfunction frac(UD60x18 x) pure returns (UD60x18 result) {\\n    assembly (\\\"memory-safe\\\") {\\n        result := mod(x, uUNIT)\\n    }\\n}\\n\\n/// @notice Calculates the geometric mean of x and y, i.e. $$sqrt(x * y)$$, rounding down.\\n///\\n/// @dev Requirements:\\n/// - x * y must fit within `MAX_UD60x18`, lest it overflows.\\n///\\n/// @param x The first operand as an UD60x18 number.\\n/// @param y The second operand as an UD60x18 number.\\n/// @return result The result as an UD60x18 number.\\nfunction gm(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    uint256 xUint = unwrap(x);\\n    uint256 yUint = unwrap(y);\\n    if (xUint == 0 || yUint == 0) {\\n        return ZERO;\\n    }\\n\\n    unchecked {\\n        // Checking for overflow this way is faster than letting Solidity do it.\\n        uint256 xyUint = xUint * yUint;\\n        if (xyUint / xUint != yUint) {\\n            revert PRBMath_UD60x18_Gm_Overflow(x, y);\\n        }\\n\\n        // We don't need to multiply the result by `UNIT` here because the x*y product had picked up a factor of `UNIT`\\n        // during multiplication. See the comments in the `prbSqrt` function.\\n        result = wrap(prbSqrt(xyUint));\\n    }\\n}\\n\\n/// @notice Calculates 1 / x, rounding toward zero.\\n///\\n/// @dev Requirements:\\n/// - x cannot be zero.\\n///\\n/// @param x The UD60x18 number for which to calculate the inverse.\\n/// @return result The inverse as an UD60x18 number.\\nfunction inv(UD60x18 x) pure returns (UD60x18 result) {\\n    unchecked {\\n        // 1e36 is UNIT * UNIT.\\n        result = wrap(1e36 / unwrap(x));\\n    }\\n}\\n\\n/// @notice Calculates the natural logarithm of x.\\n///\\n/// @dev Based on the formula:\\n///\\n/// $$\\n/// ln{x} = log_2{x} / log_2{e}$$.\\n/// $$\\n///\\n/// Requirements:\\n/// - All from `log2`.\\n///\\n/// Caveats:\\n/// - All from `log2`.\\n/// - This doesn't return exactly 1 for 2.718281828459045235, for that more fine-grained precision is needed.\\n///\\n/// @param x The UD60x18 number for which to calculate the natural logarithm.\\n/// @return result The natural logarithm as an UD60x18 number.\\nfunction ln(UD60x18 x) pure returns (UD60x18 result) {\\n    unchecked {\\n        // We do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value\\n        // that `log2` can return is 196.205294292027477728.\\n        result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_E);\\n    }\\n}\\n\\n/// @notice Calculates the common logarithm of x.\\n///\\n/// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n/// logarithm based on the formula:\\n///\\n/// $$\\n/// log_{10}{x} = log_2{x} / log_2{10}\\n/// $$\\n///\\n/// Requirements:\\n/// - All from `log2`.\\n///\\n/// Caveats:\\n/// - All from `log2`.\\n///\\n/// @param x The UD60x18 number for which to calculate the common logarithm.\\n/// @return result The common logarithm as an UD60x18 number.\\nfunction log10(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = unwrap(x);\\n    if (xUint < uUNIT) {\\n        revert PRBMath_UD60x18_Log_InputTooSmall(x);\\n    }\\n\\n    // Note that the `mul` in this assembly block is the assembly multiplication operation, not the UD60x18 `mul`.\\n    // prettier-ignore\\n    assembly (\\\"memory-safe\\\") {\\n        switch x\\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\\n        case 1000000000000000000 { result := 0 }\\n        case 10000000000000000000 { result := uUNIT }\\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 59) }\\n        default {\\n            result := uMAX_UD60x18\\n        }\\n    }\\n\\n    if (unwrap(result) == uMAX_UD60x18) {\\n        unchecked {\\n            // Do the fixed-point division inline to save gas.\\n            result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_10);\\n        }\\n    }\\n}\\n\\n/// @notice Calculates the binary logarithm of x.\\n///\\n/// @dev Based on the iterative approximation algorithm.\\n/// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n///\\n/// Requirements:\\n/// - x must be greater than or equal to UNIT, otherwise the result would be negative.\\n///\\n/// Caveats:\\n/// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n///\\n/// @param x The UD60x18 number for which to calculate the binary logarithm.\\n/// @return result The binary logarithm as an UD60x18 number.\\nfunction log2(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = unwrap(x);\\n\\n    if (xUint < uUNIT) {\\n        revert PRBMath_UD60x18_Log_InputTooSmall(x);\\n    }\\n\\n    unchecked {\\n        // Calculate the integer part of the logarithm, add it to the result and finally calculate y = x * 2^(-n).\\n        uint256 n = msb(xUint / uUNIT);\\n\\n        // This is the integer part of the logarithm as an UD60x18 number. The operation can't overflow because n\\n        // n is maximum 255 and UNIT is 1e18.\\n        uint256 resultUint = n * uUNIT;\\n\\n        // This is $y = x * 2^{-n}$.\\n        uint256 y = xUint >> n;\\n\\n        // If y is 1, the fractional part is zero.\\n        if (y == uUNIT) {\\n            return wrap(resultUint);\\n        }\\n\\n        // Calculate the fractional part via the iterative approximation.\\n        // The \\\"delta.rshift(1)\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n        uint256 DOUBLE_UNIT = 2e18;\\n        for (uint256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\\n            y = (y * y) / uUNIT;\\n\\n            // Is y^2 > 2 and so in the range [2,4)?\\n            if (y >= DOUBLE_UNIT) {\\n                // Add the 2^{-m} factor to the logarithm.\\n                resultUint += delta;\\n\\n                // Corresponds to z/2 on Wikipedia.\\n                y >>= 1;\\n            }\\n        }\\n        result = wrap(resultUint);\\n    }\\n}\\n\\n/// @notice Multiplies two UD60x18 numbers together, returning a new UD60x18 number.\\n/// @dev See the documentation for the `Common.mulDiv18` function.\\n/// @param x The multiplicand as an UD60x18 number.\\n/// @param y The multiplier as an UD60x18 number.\\n/// @return result The product as an UD60x18 number.\\nfunction mul(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(mulDiv18(unwrap(x), unwrap(y)));\\n}\\n\\n/// @notice Raises x to the power of y.\\n///\\n/// @dev Based on the formula:\\n///\\n/// $$\\n/// x^y = 2^{log_2{x} * y}\\n/// $$\\n///\\n/// Requirements:\\n/// - All from `exp2`, `log2` and `mul`.\\n///\\n/// Caveats:\\n/// - All from `exp2`, `log2` and `mul`.\\n/// - Assumes 0^0 is 1.\\n///\\n/// @param x Number to raise to given power y, as an UD60x18 number.\\n/// @param y Exponent to raise x to, as an UD60x18 number.\\n/// @return result x raised to power y, as an UD60x18 number.\\nfunction pow(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    uint256 xUint = unwrap(x);\\n    uint256 yUint = unwrap(y);\\n\\n    if (xUint == 0) {\\n        result = yUint == 0 ? UNIT : ZERO;\\n    } else {\\n        if (yUint == uUNIT) {\\n            result = x;\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n}\\n\\n/// @notice Raises x (an UD60x18 number) to the power y (unsigned basic integer) using the famous algorithm\\n/// \\\"exponentiation by squaring\\\".\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n///\\n/// Requirements:\\n/// - The result must fit within `MAX_UD60x18`.\\n///\\n/// Caveats:\\n/// - All from \\\"Common.mulDiv18\\\".\\n/// - Assumes 0^0 is 1.\\n///\\n/// @param x The base as an UD60x18 number.\\n/// @param y The exponent as an uint256.\\n/// @return result The result as an UD60x18 number.\\nfunction powu(UD60x18 x, uint256 y) pure returns (UD60x18 result) {\\n    // Calculate the first iteration of the loop in advance.\\n    uint256 xUint = unwrap(x);\\n    uint256 resultUint = y & 1 > 0 ? xUint : uUNIT;\\n\\n    // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n    for (y >>= 1; y > 0; y >>= 1) {\\n        xUint = mulDiv18(xUint, xUint);\\n\\n        // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n        if (y & 1 > 0) {\\n            resultUint = mulDiv18(resultUint, xUint);\\n        }\\n    }\\n    result = wrap(resultUint);\\n}\\n\\n/// @notice Calculates the square root of x, rounding down.\\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n///\\n/// Requirements:\\n/// - x must be less than `MAX_UD60x18` divided by `UNIT`.\\n///\\n/// @param x The UD60x18 number for which to calculate the square root.\\n/// @return result The result as an UD60x18 number.\\nfunction sqrt(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = unwrap(x);\\n\\n    unchecked {\\n        if (xUint > uMAX_UD60x18 / uUNIT) {\\n            revert PRBMath_UD60x18_Sqrt_Overflow(x);\\n        }\\n        // Multiply x by `UNIT` to account for the factor of `UNIT` that is picked up when multiplying two UD60x18\\n        // numbers together (in this case, the two numbers are both the square root).\\n        result = wrap(prbSqrt(xUint * uUNIT));\\n    }\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/ud60x18/ValueType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"./Casting.sol\\\" as C;\\nimport \\\"./Helpers.sol\\\" as H;\\nimport \\\"./Math.sol\\\" as M;\\n\\n/// @notice The unsigned 60.18-decimal fixed-point number representation, which can have up to 60 digits and up to 18 decimals.\\n/// The values of this are bound by the minimum and the maximum values permitted by the Solidity type uint256.\\n/// @dev The value type is defined here so it can be imported in all other files.\\ntype UD60x18 is uint256;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CASTING\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing { C.intoSD1x18, C.intoUD2x18, C.intoSD59x18, C.intoUint128, C.intoUint256, C.intoUint40, C.unwrap } for UD60x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            MATHEMATICAL FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// The global \\\"using for\\\" directive makes the functions in this library callable on the UD60x18 type.\\nusing {\\n    M.avg,\\n    M.ceil,\\n    M.div,\\n    M.exp,\\n    M.exp2,\\n    M.floor,\\n    M.frac,\\n    M.gm,\\n    M.inv,\\n    M.ln,\\n    M.log10,\\n    M.log2,\\n    M.mul,\\n    M.pow,\\n    M.powu,\\n    M.sqrt\\n} for UD60x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                HELPER FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// The global \\\"using for\\\" directive makes the functions in this library callable on the UD60x18 type.\\nusing {\\n    H.add,\\n    H.and,\\n    H.eq,\\n    H.gt,\\n    H.gte,\\n    H.isZero,\\n    H.lshift,\\n    H.lt,\\n    H.lte,\\n    H.mod,\\n    H.neq,\\n    H.or,\\n    H.rshift,\\n    H.sub,\\n    H.uncheckedAdd,\\n    H.uncheckedSub,\\n    H.xor\\n} for UD60x18 global;\\n\"\r\n    },\r\n    \"contracts/v1/CreditBundle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\nimport \\\"./Governance/RebootFlexVotingClientUpgradeable.sol\\\";\\nimport \\\"./LayerZero/NonblockingLzAppUpgradeable.sol\\\";\\n\\nimport \\\"./Interfaces/ICreditBundle.sol\\\";\\nimport \\\"./Utils/DirectoryConsumerUpgradeable.sol\\\";\\n\\n/**\\n * @author Niftydude, Jack Chuma\\n */\\ncontract CreditBundle is\\n    DirectoryConsumerUpgradeable,\\n    RebootFlexVotingClientUpgradeable,\\n    NonblockingLzAppUpgradeable,\\n    UUPSUpgradeable,\\n    ICreditBundle\\n{\\n    uint256 public bundleCounter;\\n\\n    mapping(uint256 => CreditBundle) public bundle;\\n\\n    // bundle ID => player address => numnber of bundles purchased\\n    mapping(uint256 => mapping(address => uint256)) purchased;\\n\\n    mapping(address => uint256) public ethBalance;\\n\\n    function __CreditBundle_initialize(\\n        IDirectory _directory,\\n        address _endpoint,\\n        address _admin\\n    ) public initializer {\\n        __RebootFlexVotingClient_init(_directory.governorContract());\\n        __Directory_Consumer_init(_directory);\\n        __NonblockingLzApp_init(_endpoint, _admin);\\n\\n        directory.ggt().approve(\\n            address(directory.credits()),\\n            type(uint256).max\\n        );\\n    }\\n\\n    receive() external payable {}\\n\\n    /**\\n     * @notice withdraw eth balance to a given address\\n     *\\n     * @param _receiver the receiving address\\n     */\\n    function withdrawBalance(address _receiver) external {\\n        uint256 _oldBalance = ethBalance[msg.sender];\\n\\n        if (_oldBalance == 0) revert NothingToWithdraw();\\n\\n        ethBalance[msg.sender] = 0;\\n\\n        (bool sent, ) = _receiver.call{value: _oldBalance}(\\\"\\\");\\n        if (!sent) revert TransferFailed();\\n    }\\n\\n    function withdrawETH(\\n        address _receiver,\\n        uint256 _amount\\n    ) external onlyRole(ADMIN_ROLE) {\\n        if (address(this).balance < _amount) revert InsufficientBalance();\\n\\n        (bool sent, ) = _receiver.call{value: _amount}(\\\"\\\");\\n        if (!sent) revert TransferFailed();\\n    }\\n\\n    /**\\n     * @notice creates a new bundle\\n     *\\n     * @param _bundle id of the credit to configure discounts for\\n     */\\n    function createBundle(CreditBundle memory _bundle) external {\\n        uint256 _amount = _bundle.amountBundles *\\n            _bundle.amountPerBundle *\\n            directory.credits().creditGGTValue();\\n\\n        directory.ggt().transferFrom(msg.sender, address(this), _amount);\\n\\n        increaseRawBalance(msg.sender, _amount);\\n\\n        uint256 _currentId;\\n\\n        unchecked {\\n            _currentId = ++bundleCounter;\\n        }\\n\\n        _bundle.devWallet = msg.sender;\\n        bundle[_currentId] = _bundle;\\n\\n        emit BundleCreated(\\n            _currentId,\\n            _bundle.creditId,\\n            _bundle.amountBundles,\\n            _bundle.amountPerBundle,\\n            _bundle.discount,\\n            _bundle.active\\n        );\\n    }\\n\\n    function topUpBundle(uint256 _bundleId, uint128 _amountBundles) external {\\n        CreditBundle storage _bundle = bundle[_bundleId];\\n\\n        if (msg.sender != _bundle.devWallet) revert InvalidCaller();\\n\\n        uint256 _amount = _amountBundles *\\n            _bundle.amountPerBundle *\\n            directory.credits().creditGGTValue();\\n\\n        _bundle.amountBundles += _amountBundles;\\n\\n        directory.ggt().transferFrom(msg.sender, address(this), _amount);\\n\\n        increaseRawBalance(msg.sender, _amount);\\n\\n        emit BundleToppedUp(_bundleId, _amountBundles);\\n    }\\n\\n    /**\\n     * @notice activate or inactivate an existing bundle\\n     *\\n     * @param _bundleId id of the bundle to activate\\n     * @param _active true to anable, false to disable\\n     */\\n    function setBundleState(uint256 _bundleId, bool _active) external {\\n        CreditBundle storage _bundle = bundle[_bundleId];\\n\\n        if (msg.sender != _bundle.devWallet) revert InvalidCaller();\\n\\n        _bundle.active = _active;\\n\\n        emit BundleStateChanged(_bundleId, _active);\\n    }\\n\\n    /**\\n     * @notice activate inactive bundle\\n     *\\n     * @param _bundleId id of the bundle to activate\\n     */\\n    function deleteBundle(uint256 _bundleId) external {\\n        CreditBundle storage _bundle = bundle[_bundleId];\\n\\n        if (msg.sender != _bundle.devWallet) revert InvalidCaller();\\n\\n        uint256 _ggAmount = ((_bundle.amountBundles - _bundle.numPurchased) *\\n            _bundle.amountPerBundle) * directory.credits().creditGGTValue();\\n\\n        directory.ggt().transfer(_bundle.devWallet, _ggAmount);\\n        decreaseRawBalance(_bundle.devWallet, _ggAmount);\\n\\n        delete bundle[_bundleId];\\n\\n        emit BundleDeleted(_bundleId);\\n    }\\n\\n    /**\\n     * @notice Allows to batch claim bundles from an approved address\\n     *\\n     * @param _bundleIds - the IDs of the bundles to claim\\n     * @param _amounts - the amounts of bundles to claim\\n     * @param _mintTo - the address to mint the bundles to\\n     */\\n    function batchPurchase(\\n        uint256[] calldata _bundleIds,\\n        uint256[] calldata _amounts,\\n        address _mintTo\\n    ) external payable {\\n        if (_bundleIds.length != _amounts.length) revert InvalidParams();\\n\\n        for (uint256 i; i < _bundleIds.length; ) {\\n            purchaseBundle(_bundleIds[i], _amounts[i], _mintTo);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Allows a user to purchase a credit bundle\\n     *\\n     * @param _bundleId - the ID of the bundle to purchase\\n     * @param _amount - the amount of bundles to purchase\\n     * @param _mintTo - the address to mint the bundle to\\n     */\\n    function purchaseBundle(\\n        uint256 _bundleId,\\n        uint256 _amount,\\n        address _mintTo\\n    ) public payable {\\n        CreditBundle storage _bundle = bundle[_bundleId];\\n\\n        if (!_bundle.active) revert BundleInactive();\\n\\n        uint256 _totalCredits = _bundle.amountPerBundle * _amount;\\n        uint256 _finalPrice;\\n\\n        if (_bundle.numPurchased + _amount > _bundle.amountBundles)\\n            revert ExceededMaxSupply();\\n\\n        if (msg.sender != _bundle.approvedToClaim) {\\n            if (!_isAllowed(_mintTo, _bundle.permissionId))\\n                revert InvalidCaller();\\n            if (purchased[_bundleId][_mintTo] + _amount > _bundle.maxPerWallet)\\n                revert ExceededMaxPurchasable();\\n\\n            _finalPrice = _calculateFinalPrice(_totalCredits, _bundle.discount);\\n\\n            unchecked {\\n                if (_finalPrice > msg.value + ethBalance[msg.sender])\\n                    revert InsufficientPayment();\\n                _bundle.numPurchased += _amount;\\n            }\\n\\n            bool _sent = _processPayment(\\n                msg.sender,\\n                _bundle.devWallet,\\n                _finalPrice\\n            );\\n            if (!_sent) revert TransferFailed();\\n        }\\n\\n        _processBundleTransfer(\\n            _bundle.devWallet,\\n            _mintTo,\\n            _bundle.creditId,\\n            _totalCredits\\n        );\\n\\n        emit BundlePurchased(_bundleId, _amount, _mintTo, _finalPrice);\\n    }\\n\\n    function getPrice(\\n        uint256 _bundleId,\\n        uint256 _amount\\n    ) external view returns (uint256) {\\n        CreditBundle storage _bundle = bundle[_bundleId];\\n\\n        return\\n            _calculateFinalPrice(\\n                _bundle.amountPerBundle * _amount,\\n                _bundle.discount\\n            );\\n    }\\n\\n    function _nonblockingLzReceive(\\n        uint16,\\n        bytes memory,\\n        uint64,\\n        bytes memory _payload\\n    ) internal override {\\n        (\\n            uint256 _bundleId,\\n            uint256 _amount,\\n            address _mintTo,\\n            uint256 _maxPrice\\n        ) = abi.decode(_payload, (uint256, uint256, address, uint256));\\n\\n        CreditBundle storage _bundle = bundle[_bundleId];\\n\\n        uint256 _totalCredits = _bundle.amountPerBundle * _amount;\\n\\n        uint256 _finalPrice = _calculateFinalPrice(\\n            _totalCredits,\\n            _bundle.discount\\n        );\\n\\n        if (\\n            !_bundle.active ||\\n            _bundle.numPurchased + _amount > _bundle.amountBundles ||\\n            !_isAllowed(_mintTo, _bundle.permissionId) ||\\n            purchased[_bundleId][_mintTo] + _amount > _bundle.maxPerWallet ||\\n            _finalPrice > _maxPrice + ethBalance[_mintTo]\\n        ) {\\n            unchecked {\\n                ethBalance[_mintTo] += msg.value;\\n            }\\n\\n            emit CreditedPlayerWallet(_mintTo, msg.value);\\n            emit PurchaseFailed(_bundleId, _amount, _mintTo, _finalPrice);\\n        } else {\\n            unchecked {\\n                _bundle.numPurchased += _amount;\\n            }\\n\\n            bool _sent = _processPayment(\\n                _mintTo,\\n                _bundle.devWallet,\\n                _finalPrice\\n            );\\n\\n            if (!_sent) {\\n                unchecked {\\n                    ethBalance[_bundle.devWallet] += _finalPrice;\\n                }\\n\\n                emit CreditedDevWallet(_finalPrice);\\n            }\\n\\n            _processBundleTransfer(\\n                _bundle.devWallet,\\n                _mintTo,\\n                _bundle.creditId,\\n                _totalCredits\\n            );\\n\\n            emit BundlePurchased(_bundleId, _amount, _mintTo, _finalPrice);\\n        }\\n    }\\n\\n    function _isAllowed(\\n        address _mintTo,\\n        uint256 _permissionId\\n    ) internal view returns (bool) {\\n        if (_permissionId == 0) return true;\\n\\n        try\\n            directory.permissionRegistry().isAllowed(_mintTo, _permissionId)\\n        returns (bool result) {\\n            return result;\\n        } catch {\\n            return false;\\n        }\\n    }\\n\\n    function _calculateFinalPrice(\\n        uint256 _totalCredits,\\n        uint256 _discount\\n    ) private view returns (uint256 _finalPrice) {\\n        (, bytes memory _creditGGTValue) = address(directory.credits())\\n            .staticcall(abi.encodeWithSignature(\\\"creditGGTValue()\\\"));\\n\\n        uint256 _totalPrice = ((_totalCredits *\\n            abi.decode(_creditGGTValue, (uint256))) / 1e18) *\\n            directory.priceFeed().currentPrice(\\n                0x4747544554480000000000000000000000000000000000000000000000000000\\n            ); // bytes32 for GGTETH\\n        _finalPrice = _totalPrice - ((_totalPrice * _discount) / 1e18);\\n    }\\n\\n    function _processPayment(\\n        address _mintTo,\\n        address _devWallet,\\n        uint256 _finalPrice\\n    ) private returns (bool _sent) {\\n        unchecked {\\n            if (_finalPrice > msg.value) {\\n                uint256 _diff = _finalPrice - msg.value;\\n\\n                if (_diff > ethBalance[_mintTo]) return false;\\n                ethBalance[_mintTo] -= _diff;\\n            } else {\\n                uint256 _diff = msg.value - _finalPrice;\\n                if (_diff > 0) {\\n                    ethBalance[_mintTo] += _diff;\\n                    emit CreditedPlayerWallet(_mintTo, _diff);\\n                }\\n            }\\n        }\\n\\n        // send final price to bundle provider wallet\\n        (_sent, ) = _devWallet.call{value: _finalPrice}(\\\"\\\");\\n    }\\n\\n    /**\\n     * @notice responsible to transfer credits and voting power when purchasing a bundle\\n     *\\n     * @param _devWallet the wallet of the dev to extract votes from\\n     * @param _mintTo the wallet address to transfer votes and credits to\\n     * @param _creditId the id of the credit to mint\\n     * @param _totalCredits the total amount of credits to mint\\n     */\\n    function _processBundleTransfer(\\n        address _devWallet,\\n        address _mintTo,\\n        uint256 _creditId,\\n        uint256 _totalCredits\\n    ) private {\\n        ICredits _credits = directory.credits();\\n\\n        uint256 _ggAmount = _credits.creditGGTValue() * _totalCredits;\\n\\n        decreaseRawBalance(_devWallet, _ggAmount);\\n\\n        _credits.mintCredits(_creditId, _totalCredits, _mintTo);\\n    }\\n\\n    function _authorizeUpgrade(\\n        address newImplementation\\n    ) internal override onlyGov {}\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Governance/FlexVotingClientUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.10;\\n\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {Checkpoints} from \\\"@openzeppelin/contracts/utils/Checkpoints.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport {IFractionalGovernor} from \\\"flexible-voting/src/interfaces/IFractionalGovernor.sol\\\";\\nimport {IVotingToken} from \\\"flexible-voting/src/interfaces/IVotingToken.sol\\\";\\n\\n/// @notice This is an abstract contract designed to make it easy to build clients\\n/// for governance systems that inherit from GovernorCountingFractional, a.k.a.\\n/// Flexible Voting governors.\\n///\\n/// A \\\"client\\\" in this sense is a contract that:\\n\\n/// - (a) receives deposits of governance tokens from its users,\\n/// - (b) gives said depositors the ability to express their voting preferences\\n///   on governance proposals, and\\n/// - (c) casts votes on said proposals to flexible voting governors according\\n///   to the expressed preferences of its depositors.\\n///\\n/// This contract assumes that a child contract will implement a mechanism for\\n/// receiving and storing deposit balances, part (a). With that in place, this\\n/// contract supplies features (b) and (c).\\n///\\n/// A key concept here is that of a user's \\\"raw balance\\\". The raw balance is the\\n/// system's internal representation of a user's claim on the governance tokens\\n/// that it custodies. Since different systems might represent such claims in\\n/// different ways, this contract leaves the implementation of the `_rawBalance`\\n/// function to the child contract.\\n///\\n/// The simplest such representation would be to directly store the cumulative\\n/// balance of the governance token that the user has deposited. In such a\\n/// system, the amount that the user deposits is the amount that the user has\\n/// claim to. If the user has claim to 1e18 governance tokens, the internal\\n/// representation is just 1e18.\\n///\\n/// In many systems, however, the raw balance will not be equivalent to the\\n/// amount of governance tokens the user has claim to. In Aave, for example,\\n/// deposit amounts are scaled down by an ever-increasing index that represents\\n/// the cumulative amount of interest earned over the lifetime of deposits. The\\n/// \\\"raw balance\\\" of a user in Aave's case is this scaled down amount, since it\\n/// is the value that represents the user's claim on deposits. Thus for Aave, a\\n/// users's raw balance will always be less than the actual amount they have\\n/// claim to.\\n///\\n/// If the raw balance can be identified and defined for a system, and\\n/// `_rawBalance` can be implemented for it, then this contract will take care\\n/// of the rest.\\nabstract contract FlexVotingClientUpgradeable is Initializable {\\n    using SafeCast for uint256;\\n    using Checkpoints for Checkpoints.History;\\n\\n    /// @notice The voting options corresponding to those used in the Governor.\\n    enum VoteType {\\n        Against,\\n        For,\\n        Abstain\\n    }\\n\\n    /// @notice Data structure to store vote preferences expressed by depositors.\\n    struct ProposalVote {\\n        uint128 againstVotes;\\n        uint128 forVotes;\\n        uint128 abstainVotes;\\n    }\\n\\n    /// @dev Map proposalId to an address to whether they have voted on this proposal.\\n    mapping(uint256 => mapping(address => bool)) private proposalVotersHasVoted;\\n\\n    /// @notice Map proposalId to vote totals expressed on this proposal.\\n    mapping(uint256 => ProposalVote) public proposalVotes;\\n\\n    /// @notice The governor contract associated with this governance token. It\\n    /// must be one that supports fractional voting, e.g. GovernorCountingFractional.\\n    IFractionalGovernor public GOVERNOR;\\n\\n    /// @dev Mapping from address to the checkpoint history of raw balances\\n    /// of that address.\\n    mapping(address => Checkpoints.History) private balanceCheckpoints;\\n\\n    /// @dev History of the sum total of raw balances in the system. May or may\\n    /// not be equivalent to this contract's balance of `GOVERNOR`s token at a\\n    /// given time.\\n    Checkpoints.History internal totalBalanceCheckpoints;\\n\\n    function __FlexVotingClient_init(\\n        address _governor\\n    ) internal onlyInitializing {\\n        GOVERNOR = IFractionalGovernor(_governor);\\n    }\\n\\n    /// @dev Returns a representation of the current amount of `GOVERNOR`s\\n    /// token that `_user` has claim to in this system. It may or may not be\\n    /// equivalent to the withdrawable balance of `GOVERNOR`s token for `user`,\\n    /// e.g. if the internal representation of balance has been scaled down.\\n    function _rawBalanceOf(\\n        address _user\\n    ) internal view virtual returns (uint256);\\n\\n    /// @dev Used as the `reason` param when submitting a vote to `GOVERNOR`.\\n    function _castVoteReasonString() internal virtual returns (string memory) {\\n        return \\\"rolled-up vote from governance token holders\\\";\\n    }\\n\\n    /// @dev Delegates the present contract's voting rights with `GOVERNOR` to itself.\\n    function _selfDelegate() internal {\\n        IVotingToken(GOVERNOR.token()).delegate(address(this));\\n    }\\n\\n    /// @notice Allow the caller to express their voting preference for a given\\n    /// proposal. Their preference is recorded internally but not moved to the\\n    /// Governor until `castVote` is called.\\n    /// @param proposalId The proposalId in the associated Governor\\n    /// @param support The depositor's vote preferences in accordance with the `VoteType` enum.\\n    function expressVote(uint256 proposalId, uint8 support) external {\\n        uint256 weight = getPastRawBalance(\\n            msg.sender,\\n            GOVERNOR.proposalSnapshot(proposalId)\\n        );\\n        require(weight > 0, \\\"no weight\\\");\\n\\n        require(\\n            !proposalVotersHasVoted[proposalId][msg.sender],\\n            \\\"already voted\\\"\\n        );\\n        proposalVotersHasVoted[proposalId][msg.sender] = true;\\n\\n        if (support == uint8(VoteType.Against)) {\\n            proposalVotes[proposalId].againstVotes += SafeCast.toUint128(\\n                weight\\n            );\\n        } else if (support == uint8(VoteType.For)) {\\n            proposalVotes[proposalId].forVotes += SafeCast.toUint128(weight);\\n        } else if (support == uint8(VoteType.Abstain)) {\\n            proposalVotes[proposalId].abstainVotes += SafeCast.toUint128(\\n                weight\\n            );\\n        } else {\\n            revert(\\\"invalid support value, must be included in VoteType enum\\\");\\n        }\\n    }\\n\\n    /// @notice Causes this contract to cast a vote to the Governor for all of the\\n    /// accumulated votes expressed by users. Uses the sum of all raw balances to\\n    /// proportionally split its voting weight. Can be called by anyone. Can be\\n    /// called multiple times during the lifecycle of a given proposal.\\n    /// @param proposalId The ID of the proposal which the Pool will now vote on.\\n    function castVote(uint256 proposalId) external {\\n        ProposalVote storage _proposalVote = proposalVotes[proposalId];\\n        require(\\n            _proposalVote.forVotes +\\n                _proposalVote.againstVotes +\\n                _proposalVote.abstainVotes >\\n                0,\\n            \\\"no votes expressed\\\"\\n        );\\n        uint256 _proposalSnapshotBlockNumber = GOVERNOR.proposalSnapshot(\\n            proposalId\\n        );\\n\\n        // We use the snapshot of total raw balances to determine the weight with\\n        // which to vote. We do this for two reasons:\\n        //   (1) We cannot use the proposalVote numbers alone, since some people with\\n        //       balances at the snapshot might never express their preferences. If a\\n        //       large holder never expressed a preference, but this contract nevertheless\\n        //       cast votes to the governor with all of its weight, then other users may\\n        //       effectively have *increased* their voting weight because someone else\\n        //       didn't participate, which creates all kinds of bad incentives.\\n        //   (2) Other people might have already expressed their preferences on this\\n        //       proposal and had those preferences submitted to the governor by an\\n        //       earlier call to this function. The weight of those preferences\\n        //       should still be taken into consideration when determining how much\\n        //       weight to vote with this time.\\n        // Using the total raw balance to proportion votes in this way means that in\\n        // many circumstances this function will not cast votes with all of its\\n        // weight.\\n        uint256 _totalRawBalanceAtSnapshot = getPastTotalBalance(\\n            _proposalSnapshotBlockNumber\\n        );\\n\\n        // We need 256 bits because of the multiplication we're about to do.\\n        uint256 _votingWeightAtSnapshot = IVotingToken(\\n            address(GOVERNOR.token())\\n        ).getPastVotes(address(this), _proposalSnapshotBlockNumber);\\n\\n        //      forVotesRaw          forVoteWeight\\n        // --------------------- = ------------------\\n        //     totalRawBalance      totalVoteWeight\\n        //\\n        // forVoteWeight = forVotesRaw * totalVoteWeight / totalRawBalance\\n        uint128 _forVotesToCast = SafeCast.toUint128(\\n            (_votingWeightAtSnapshot * _proposalVote.forVotes) /\\n                _totalRawBalanceAtSnapshot\\n        );\\n        uint128 _againstVotesToCast = SafeCast.toUint128(\\n            (_votingWeightAtSnapshot * _proposalVote.againstVotes) /\\n                _totalRawBalanceAtSnapshot\\n        );\\n        uint128 _abstainVotesToCast = SafeCast.toUint128(\\n            (_votingWeightAtSnapshot * _proposalVote.abstainVotes) /\\n                _totalRawBalanceAtSnapshot\\n        );\\n\\n        // This param is ignored by the governor when voting with fractional\\n        // weights. It makes no difference what vote type this is.\\n        uint8 unusedSupportParam = uint8(VoteType.Abstain);\\n\\n        // Clear the stored votes so that we don't double-cast them.\\n        delete proposalVotes[proposalId];\\n\\n        bytes memory fractionalizedVotes = abi.encodePacked(\\n            _againstVotesToCast,\\n            _forVotesToCast,\\n            _abstainVotesToCast\\n        );\\n        GOVERNOR.castVoteWithReasonAndParams(\\n            proposalId,\\n            unusedSupportParam,\\n            _castVoteReasonString(),\\n            fractionalizedVotes\\n        );\\n    }\\n\\n    /// @dev Checkpoints the _user's current raw balance.\\n    function _checkpointRawBalanceOf(address _user) internal {\\n        balanceCheckpoints[_user].push(_rawBalanceOf(_user));\\n    }\\n\\n    /// @notice Returns the `_user`'s raw balance at `_blockNumber`.\\n    /// @param _user The account that's historical raw balance will be looked up.\\n    /// @param _blockNumber The block at which to lookup the _user's raw balance.\\n    function getPastRawBalance(\\n        address _user,\\n        uint256 _blockNumber\\n    ) public view returns (uint256) {\\n        return balanceCheckpoints[_user].getAtProbablyRecentBlock(_blockNumber);\\n    }\\n\\n    /// @notice Returns the sum total of raw balances of all users at `_blockNumber`.\\n    /// @param _blockNumber The block at which to lookup the total balance.\\n    function getPastTotalBalance(\\n        uint256 _blockNumber\\n    ) public view returns (uint256) {\\n        return totalBalanceCheckpoints.getAtProbablyRecentBlock(_blockNumber);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Governance/RebootFlexVotingClientUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./FlexVotingClientUpgradeable.sol\\\";\\n\\nabstract contract RebootFlexVotingClientUpgradeable is\\n    FlexVotingClientUpgradeable\\n{\\n    using Checkpoints for Checkpoints.History;\\n\\n    mapping(address => uint256) public rawBalanceOf;\\n    uint256 public totalRawBalance;\\n\\n    function __RebootFlexVotingClient_init(\\n        address _governor\\n    ) internal onlyInitializing {\\n        __FlexVotingClient_init(_governor);\\n        _selfDelegate();\\n    }\\n\\n    function increaseRawBalance(address _user, uint256 _amount) internal {\\n        unchecked {\\n            rawBalanceOf[_user] += _amount;\\n            totalRawBalance += _amount;\\n        }\\n        _writeCheckpoints(_user);\\n    }\\n\\n    function decreaseRawBalance(address _user, uint256 _amount) internal {\\n        unchecked {\\n            rawBalanceOf[_user] -= _amount;\\n            totalRawBalance -= _amount;\\n        }\\n        _writeCheckpoints(_user);\\n    }\\n\\n    function _writeCheckpoints(address _user) private {\\n        _checkpointRawBalanceOf(_user);\\n        totalBalanceCheckpoints.push(totalRawBalance);\\n    }\\n\\n    function _rawBalanceOf(\\n        address _user\\n    ) internal view override returns (uint256) {\\n        return rawBalanceOf[_user];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IAffiliateRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\n\\ninterface IAffiliateRegistry is IAccessControlUpgradeable {\\n    struct Affiliate {\\n        address receiver;\\n        uint256 uniqueWallets;\\n        uint256 lifetimeSales;\\n        uint256 lifetimeSessionValue;\\n        uint256 sessionShare;\\n        uint256 saleShare;\\n    }\\n\\n    error AlreadyRegistered();\\n    error NoSelfAffiliate();\\n    error AffiliateNotRegistered();\\n\\n    event AffiliateRegistered(uint256 indexed id, address indexed receiver);\\n    event ReceiverChanged(uint256 indexed id, address indexed receiver);\\n    event PlayerAssigned(uint256 indexed id, address indexed player);\\n    event SessionShareChanged(uint256 indexed id, uint256 newSessionShare);\\n    event SaleShareChanged(uint256 indexed id, uint256 newSaleShare);\\n    event DefaultSessionShareChanged(uint256 newSessionShare);\\n    event DefaultSaleShareChanged(uint256 newSaleShare);\\n\\n    function assignPlayer(address _player, uint256 _affiliateId) external;\\n\\n    function setDefaultSessionShare(uint256) external;\\n\\n    function setDefaultSaleShare(uint256) external;\\n\\n    function setAffiliateSessionShare(uint256, uint256) external;\\n\\n    function setAffiliateSaleShare(uint256, uint256) external;\\n\\n    function registerNewAffiliate(\\n        address _revenueReceiver\\n    ) external returns (uint256 _affiliateId);\\n\\n    function registerSale(\\n        address _player,\\n        uint256 _fees\\n    ) external returns (address, uint256);\\n\\n    function registerSession(\\n        address _player,\\n        uint256 _basePrice,\\n        uint256 _fees\\n    ) external returns (address, uint256);\\n\\n    function changeReceiver(\\n        uint256 _affiliateId,\\n        address _newReceiver\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IAMM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\nimport {SD59x18, eq} from \\\"@prb/math/src/SD59x18.sol\\\";\\n\\ninterface IAMM is IAccessControlUpgradeable {\\n    struct ExtractorCalc {\\n        address account;\\n        uint256 extractorId;\\n        uint256 payout;\\n        SD59x18 mu;\\n        SD59x18 phi;\\n        SD59x18 entryFee;\\n        address gameDev;\\n    }\\n\\n    struct FixedFeeSplit {\\n        uint64 matchMakerFeePercentage;\\n        uint64 validatorFeePercentage;\\n        uint64 gameDevFeePercentage;\\n        uint64 ecoFundFeePercentage;\\n    }\\n\\n    struct ExtractorWeights {\\n        SD59x18 payoutWeight;\\n        SD59x18 skillWeight;\\n        SD59x18 baseExtractorWeight;\\n    }\\n\\n    struct PayoutData {\\n        address account;\\n        uint256 payout;\\n        uint256 maxPayout;\\n        uint256 gameId;\\n        uint256 extractorId;\\n        SD59x18 mu;\\n        SD59x18 phi;\\n        uint256 entryFee;\\n        address gameDev;\\n    }\\n\\n    error PercentagesMustSumToOne();\\n    error PayoutTooHigh();\\n    error IncorrectMaxPayout();\\n    error InvalidPercentage();\\n    error InvalidReward();\\n\\n    event FixedFeeSplitSet(FixedFeeSplit feeSplit);\\n    event ExtractorWeightsUpdated(ExtractorWeights weights);\\n    event ExtractorCoefficientSet(SD59x18 newCoefficient);\\n    event FixedFeePercentageSet(uint256 newFee);\\n    event BaseFeeSet(uint256 newFee);\\n    event DevExtractorPercentSet(SD59x18 percentage);\\n\\n    function setExtractorWeights(ExtractorWeights calldata) external;\\n\\n    function setExtractorCoefficient(SD59x18) external;\\n\\n    function setFixedFeePercentage(uint256) external;\\n\\n    function setBaseFee(uint256) external;\\n\\n    function setDevExtractorPercent(SD59x18) external;\\n\\n    function fixedFeePercentage() external view returns (uint64);\\n\\n    function baseFee() external view returns (uint64);\\n\\n    function setFixedFeeSplit(FixedFeeSplit calldata) external;\\n\\n    function disperseFees(uint256, address, address, uint256) external;\\n\\n    function lockMaxPayout(uint256) external;\\n\\n    function payout(PayoutData memory) external returns (uint256, uint256);\\n\\n    function forfeit(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/ICommitmentPermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface ICommitmentPermissions {\\n    function isAllowed(address _contract) external returns (bool);\\n\\n    function setPermission(address, bool) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/ICommonOFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface of the IOFT core standard\\n */\\ninterface ICommonOFT is IERC165 {\\n\\n    struct LzCallParams {\\n        address payable refundAddress;\\n        address zroPaymentAddress;\\n        bytes adapterParams;\\n    }\\n\\n    /**\\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\\n     * _dstChainId - L0 defined chain id to send tokens too\\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\\n     * _amount - amount of the tokens to transfer\\n     * _useZro - indicates to use zro to pay L0 fees\\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\\n     */\\n    function estimateSendFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\\n\\n    function estimateSendAndCallFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes calldata _payload, uint64 _dstGasForCall, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\\n\\n    /**\\n     * @dev returns the circulating amount of tokens on current chain\\n     */\\n    function circulatingSupply() external view returns (uint);\\n\\n    /**\\n     * @dev returns the address of the ERC20 token\\n     */\\n    function token() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/ICreditBundle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface ICreditBundle {\\n    struct CreditBundle {\\n        uint128 creditId;\\n        uint128 discount;\\n        uint128 amountBundles;\\n        uint128 maxPerWallet;\\n        uint256 amountPerBundle;\\n        uint256 numPurchased;\\n        uint256 permissionId;\\n        address devWallet;\\n        address approvedToClaim;\\n        bool active;\\n    }\\n\\n    enum CompareOperator {\\n        EQUAL,\\n        GREATER,\\n        GREATER_OR_EQUAL,\\n        LOWER,\\n        LOWER_OR_EQUAL\\n    }\\n\\n    event BundleCreated(\\n        uint256 indexed bundleId,\\n        uint256 indexed creditId,\\n        uint256 amountBundles,\\n        uint256 creditsPerBundle,\\n        uint256 discount,\\n        bool active\\n    );\\n    event BundleToppedUp(uint256 indexed bundleId, uint256 amountBundles);\\n    event BundleDeleted(uint256 indexed id);\\n    event BundleStateChanged(uint256 indexed id, bool active);\\n\\n    event BundleClaimed(\\n        uint256 indexed bundleId,\\n        uint256 amount,\\n        address indexed mintTo\\n    );\\n\\n    event BundlePurchased(\\n        uint256 indexed bundleId,\\n        uint256 amount,\\n        address indexed mintTo,\\n        uint256 finalPrice\\n    );\\n\\n    event PurchaseFailed(\\n        uint256 indexed bundleId,\\n        uint256 amount,\\n        address indexed mintTo,\\n        uint256 finalPrice\\n    );\\n\\n    event CreditedPlayerWallet(address indexed player, uint256 amountToCredit);\\n\\n    event CreditedDevWallet(uint256 finalPrice);\\n\\n    error NothingToWithdraw();\\n    error InvalidCaller();\\n    error ExceededMaxPurchasable();\\n    error ExceededMaxSupply();\\n    error InsufficientPayment();\\n    error TransferFailed();\\n    error InvalidParams();\\n    error BundleInactive();\\n    error InsufficientBalance();\\n\\n    function createBundle(CreditBundle memory _bundle) external;\\n\\n    function withdrawBalance(address _receiver) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/ICredits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\n\\ninterface ICredits is IAccessControlUpgradeable {\\n    struct FailedTransfer {\\n        address sender;\\n        address user;\\n        uint256 amount;\\n    }\\n\\n    error BalanceTooLow();\\n    error ZeroAddress();\\n    error NoPermission();\\n    error InsufficientBalance();\\n\\n    error CannotMintZeroCredits();\\n    event GGWithdrawn(address holder, address receiver, uint256 amount);\\n    event CreditsPurchased(\\n        uint256 _amount,\\n        address indexed _mintTo,\\n        bool _ticketPay\\n    );\\n    event CreditsBurned(address account, uint256 creditId, uint256 amount);\\n    event CreditsConverted(\\n        address _account,\\n        uint256 _creditId,\\n        uint256 _convertAmount\\n    );\\n    event FailedTransfersRetrySuccess(uint256 from, uint256 to);\\n\\n    function creditGGTValue() external returns (uint256);\\n\\n    function creditForGame(address) external view returns (uint256);\\n\\n    function gameForCredit(uint256) external view returns (address);\\n\\n    function creditBalance(address, uint256) external view returns (uint256);\\n\\n    function purchaseCredits(\\n        uint256 _amount,\\n        address _payFrom,\\n        address _mintTo,\\n        uint256 _gameId,\\n        bool _ticketPay\\n    ) external;\\n\\n    function purchaseCreditsInGG(\\n        uint256 _amountGG,\\n        address _payFrom,\\n        address _mintTo\\n    ) external;\\n\\n    function mintCredits(\\n        uint256 _creditId,\\n        uint256 _amount,\\n        address _mintTo\\n    ) external;\\n\\n    function release(\\n        address _account,\\n        uint256 _amount\\n    ) external returns (uint256);\\n\\n    function registerCredit(address _game, uint256 _id) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IDirectory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./IGGT.sol\\\";\\nimport \\\"./ITokenMarket.sol\\\";\\nimport \\\"./ITickets.sol\\\";\\nimport \\\"./IExtractors.sol\\\";\\nimport \\\"./ICredits.sol\\\";\\nimport \\\"./IGameCard.sol\\\";\\nimport \\\"./IRebootBeacon.sol\\\";\\nimport \\\"./IPriceFeed.sol\\\";\\nimport \\\"./IProfileStorage.sol\\\";\\nimport \\\"./IAMM.sol\\\";\\nimport \\\"./IRegistry.sol\\\";\\nimport \\\"./ICommitmentPermissions.sol\\\";\\nimport \\\"./IAffiliateRegistry.sol\\\";\\nimport \\\"./IQRNGProvider.sol\\\";\\nimport \\\"./IStakingContracts.sol\\\";\\nimport \\\"./IGameFactory.sol\\\";\\nimport \\\"./IMItemsFactory.sol\\\";\\nimport \\\"./IRewardsPool.sol\\\";\\nimport \\\"./IFactoryController.sol\\\";\\nimport \\\"./IPartnerships.sol\\\";\\nimport \\\"./IPermissionRegistry.sol\\\";\\n\\ninterface IDirectory {\\n    error ZeroAddress();\\n    error InvalidCaller();\\n    error MustBeGreaterZero();\\n\\n    event ProtocolPauseToggled(bool isPaused);\\n    event AdminCouncilSet(address council);\\n    event GGTSet(address newAddr);\\n    event TicketsSet(address newAddr);\\n    event ExtractorsSet(address newAddr);\\n    event TokenMarketSet(address newAddr);\\n    event CreditsSet(address newAddr);\\n    event GameCardSet(address newAddr);\\n    event GameBeaconSet(address newAddr);\\n    event MItemBeaconSet(address newAddr);\\n    event UItemBeaconSet(address newAddr);\\n    event GItemBeaconSet(address newAddr);\\n    event ProfileStorageSet(address newAddr);\\n    event PriceFeedSet(address newAddr);\\n    event AMMSet(address newAddr);\\n    event MatchMakerRegistrySet(address newAddr);\\n    event ValidatorRegistrySet(address newAddr);\\n    event GovernorSet(address newAddr);\\n    event GovernorContractSet(address newAddr);\\n    event CommitmentPermissionsSet(address newAddr);\\n    event AffiliateRegistrySet(address newAddr);\\n    event NextProtocolDirectoryVersionSet(address newAddr);\\n    event RandomNumberProviderSet(address newAddr);\\n    event StakingContractsSet(address newAddr);\\n    event GameFactorySet(address newAddr);\\n    event MItemsFactorySet(address newAddr);\\n    event EcoFundSet(address newAddr);\\n    event FactoryControllerSet(address newAddr);\\n    event RewardsPoolSet(address newAddr);\\n    event PartnershipsSet(address newAddr);\\n    event GGVotesSet(address newAddr);\\n    event PermissionRegistrySet(address newAddr);\\n\\n    function paused() external view returns (bool);\\n\\n    function ggt() external view returns (IGGT);\\n\\n    function tickets() external view returns (ITickets);\\n\\n    function extractors() external view returns (IExtractors);\\n\\n    function tokenMarket() external view returns (ITokenMarket);\\n\\n    function gameBeacon() external view returns (IRebootBeacon);\\n\\n    function mItemBeacon() external view returns (IRebootBeacon);\\n\\n    function uItemBeacon() external view returns (IRebootBeacon);\\n\\n    function gItemBeacon() external view returns (IRebootBeacon);\\n\\n    function gameCard() external view returns (IGameCard);\\n\\n    function credits() external view returns (ICredits);\\n\\n    function priceFeed() external view returns (IPriceFeed);\\n\\n    function profileStorage() external view returns (IProfileStorage);\\n\\n    function permissionRegistry() external view returns (IPermissionRegistry);\\n\\n    function rewardsAMM() external view returns (IAMM);\\n\\n    function matchMakerRegistry() external view returns (IRegistry);\\n\\n    function validatorRegistry() external view returns (IRegistry);\\n\\n    function governor() external view returns (address);\\n\\n    function governorContract() external view returns (address);\\n\\n    function factoryController() external view returns (IFactoryController);\\n\\n    function commitmentPermissions()\\n        external\\n        view\\n        returns (ICommitmentPermissions);\\n\\n    function affiliateRegistry() external view returns (IAffiliateRegistry);\\n\\n    function rnProvider() external view returns (IQRNGProvider);\\n\\n    function nextProtocolDirectoryVersion() external view returns (address);\\n\\n    function protocolStakingContracts()\\n        external\\n        view\\n        returns (IStakingContracts);\\n\\n    function gameFactory() external view returns (IGameFactory);\\n\\n    function mItemsFactory() external view returns (IMItemsFactory);\\n\\n    function ecoFund() external view returns (address);\\n\\n    function rewardsPool() external view returns (IRewardsPool);\\n\\n    function partnerships() external view returns (IPartnerships);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IExtractors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\n\\ninterface IExtractors is IAccessControlUpgradeable {\\n    error MustHaveGGValue();\\n    error InvalidExtractorId();\\n    error ZeroLength();\\n    error GGPerExtractorTooHigh();\\n    error InvalidCaller();\\n\\n    event UriSet(string uri);\\n    event NewExtractorAdded(uint256 id, uint256 ggPerExtractor);\\n\\n    function setURI(string memory _uri) external;\\n\\n    function addNewExtractor(uint256 _id, uint256 _ggPerExtractor) external;\\n\\n    function getGGPerExtractor(uint256) external view returns (uint256);\\n\\n    function mintBatch(\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata\\n    ) external;\\n\\n    function mint(address, uint256, uint256) external;\\n\\n    function burn(address, uint256, uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IFactoryController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"../Libraries/Glicko.sol\\\";\\nimport \\\"./IAMM.sol\\\";\\n\\ninterface IFactoryController {\\n    struct GameConfig {\\n        address admin;\\n        Glicko.Config glickoConfig;\\n        IAMM rewardsAMM;\\n        string itemName;\\n        string itemSymbol;\\n        uint256 ticketsPerGG;\\n        uint256 ggPerExtractor;\\n    }\\n\\n    error AddressAlreadySet();\\n    error InvalidCaller();\\n    error ZeroAddress();\\n    error GameAlreadyApproved();\\n\\n    event GameCreated(\\n        address game,\\n        address admin,\\n        address gItems,\\n        address mItems,\\n        address uItems\\n    );\\n    event GameApproved(uint256 gameId, address gameAddress);\\n\\n    function gameAddress(uint256) external view returns (address);\\n\\n    function gameId(address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"../Libraries/Glicko.sol\\\";\\nimport \\\"./IAMM.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\ninterface IGame is IAccessControl {\\n    struct PayoutTable {\\n        uint256 maxStrength;\\n        mapping(uint256 => uint256) strengthVals;\\n    }\\n\\n    /**\\n     * @notice Data passed to initial session commitment\\n     *\\n     * @param playerWallet The Ethereum address of the user making the commitment\\n     * @param custodialAddress Optional custodial contract address\\n     * @param startupData A hash of Game specific startup data associated with this commitment\\n     * @param validatorTip A $GG tip to the validator to prioritize the transaction\\n     * @param protocolVersion A valid protocol version, that must match the most current public version\\n     * @param clientVersion A valid game client version, that must match the version used to generate the gameplay transcript\\n     * @param payoutId ID of payout table player is committing to\\n     */\\n    struct GameCommitment {\\n        address playerWallet;\\n        address custodialAddress;\\n        bytes32 startupData;\\n        uint256 validatorTip;\\n        uint256 matchMakerTip;\\n        uint256 creditId;\\n        string protocolVersion;\\n        string clientVersion;\\n        uint256 payoutId;\\n        uint256 maxCredits;\\n    }\\n\\n    /**\\n     * @notice Data stored on-chain for each game session.\\n     *\\n     * @param playerWallet The evm address of the player\\n     * @param maxPayout The maximum possible rewards payout set aside by the protocol\\n     * @param payoutAddress The address receiving the final payout\\n     * @param expiration The timestamp that the game session will expire at\\n     * @param entryFee Amount of GG paid as entry fee\\n     * @param entropy VRF entropy to be used for initial session data\\n     * @param startupData A hash of Game specific startup data associated with this commitment\\n     * @param protocolVersion A valid protocol version\\n     * @param clientVersion A valid game client version\\n     * @param payoutId ID of payout table player is committing to\\n     * @param playerGlicko Player's glicko rating at the time of game commitment\\n     * @param resolved Boolean value representing if game session has ended or not\\n     */\\n    struct Session {\\n        address playerWallet;\\n        address payoutAddress;\\n        uint256 maxPayout;\\n        uint256 expiration;\\n        uint256 validatorTip;\\n        uint256 matchMakerTipLeft;\\n        uint256 entryFee;\\n        uint256 entropy;\\n        uint256 entropyReqId;\\n        bytes32 startupData;\\n        string protocolVersion;\\n        string clientVersion;\\n        uint256 payoutId;\\n        Glicko.Profile playerGlicko;\\n        bool resolved;\\n    }\\n\\n    /**\\n     * @notice Data stored on-chain for each round.\\n     *\\n     * @param roundHash A hash of selected moves by the player for this round\\n     * @param entropy Random entropy generated by VRF roll for this round\\n     * @param opponentSessionId The commitment id for the opponent game session selected by the match maker\\n     * @param opponentRoundIdx The round index for the opponent round selected by the match maker\\n     */\\n    struct RoundData {\\n        bytes32 roundHash;\\n        uint256 entropy;\\n        uint256 entropyReqId;\\n        uint128 opponentSessionId;\\n        uint128 opponentRoundIdx;\\n    }\\n\\n    /**\\n     * @notice Game submission function.\\n     *\\n     * @param sessionId Session ID of game\\n     * @param player Player's wallet address\\n     * @param oppMus Array of opponent Glicko2 ratings\\n     * @param oppPhis Array of opponent Glicko2 rating deviations\\n     * @param outcomes Array of game outcomes (0 = loss, 0.5e18 = tie, 1e18 = win)\\n     * @param gameEventId Event ID of game outcome\\n     * @param validatorSig Signature from an approved validator address\\n     * @param extractorId ID of extractor token to mint\\n     * @param forfeit If true, update rating and send max payout back to rewards pool\\n     */\\n    struct SubmitData {\\n        uint256 sessionId;\\n        address player;\\n        SD59x18[] oppMus;\\n        SD59x18[] oppPhis;\\n        SD59x18[] outcomes;\\n        uint256 gameEventId;\\n        bytes validatorSig;\\n        uint256 extractorId;\\n        bool forfeit;\\n    }\\n\\n    /**\\n     * @notice Struct containing info for VRF requests.\\n     *\\n     * @param sessionId Session ID vrf request is for\\n     * @param roundIndex Index of rounds array for session\\n     */\\n    struct VRFRequest {\\n        bool forMatch;\\n        uint128 sessionId;\\n        uint128 roundIndex;\\n    }\\n\\n    error GameNotActive();\\n    error PlayerAlreadyRegistered();\\n    error PlayerMissingRating();\\n    error StartupDataRequired();\\n    error ValidatorHasActiveSession();\\n    error MatchMakerHasActiveSession();\\n    error CannotPlayYourself();\\n    error InvalidCaller();\\n    error ClientVersionRequired();\\n    error WrongRound();\\n    error SignatureInvalid();\\n    error MatchAlreadyRecorded();\\n    error ExceedsMaxSessions();\\n    error ProtocolVersionRequired();\\n    error InvalidPlayer();\\n    error SessionResolved();\\n    error GameExpired();\\n    error PreviousRoundOpen();\\n    error GameResolved();\\n    error InvalidSession(uint256 sessionId);\\n    error InvalidRound(uint256 sessionId, uint256 roundIndex);\\n    error LengthMismatch();\\n    error InvalidPayoutId();\\n    error RoundCountMismatch();\\n    error InvalidHash();\\n    error ZeroLength();\\n    error MaxRoundsReached();\\n    error ZeroAddress();\\n    error RoundsPerSessionRequired();\\n    error MissingPermission();\\n    error MaxCreditsExceeded();\\n\\n    event GameStatusChanged(bool active);\\n    event MaxGameDurationSet(uint256 timeInSeconds);\\n    event SessionPriceUSDSet(uint256 amount);\\n    event MaxActiveSessionsSet(uint256 sessions);\\n    event WhitelistUpdated(uint256 gameId, bool isWhitelisted);\\n\\n    event MaxRoundsPerSessionSet(uint256 rounds);\\n    event CommitmentRecorded(address indexed player, uint256 sessionId);\\n    event RoundCommitted(\\n        address indexed player,\\n        uint256 indexed sessionId,\\n        uint256 roundId\\n    );\\n    event MatchRecorded(\\n        uint256 sessionId,\\n        uint256 roundIndex,\\n        uint256 oppSessionId,\\n        uint256 oppRoundIndex\\n    );\\n    event RoundEntropy(uint256 sessionId, uint256 round, uint256 entropy);\\n    event SessionEntropy(uint256 sessionId, uint256 entropy);\\n    event PayoutTableAdded(\\n        uint256 id,\\n        uint256[] gameEventIds,\\n        uint256[] strengthVals\\n    );\\n    event GameSubmitted(\\n        uint256 sessionId,\\n        uint256 gameEventId,\\n        uint256 extractorPayout,\\n        uint256 ticketPayout\\n    );\\n\\n    function rewardsAMM() external view returns (IAMM);\\n\\n    function getGlicko2Rating(\\n        address _playerWallet\\n    ) external view returns (Glicko.Profile memory _rating);\\n\\n    function registerPlayer(address _player) external;\\n\\n    function calculateWinProbability(\\n        address _player,\\n        SD59x18 _oppRating,\\n        SD59x18 _oppRD\\n    ) external view returns (SD59x18);\\n\\n    function calculateWinProbabilityBatch(\\n        address _player,\\n        SD59x18[] calldata _oppRatings,\\n        SD59x18[] calldata _oppRDs\\n    ) external view returns (SD59x18[] memory);\\n\\n    function setMaxGameDuration(uint128 _maxDuration) external;\\n\\n    function isWhitelisted(uint256) external view returns (bool);\\n\\n    function setSessionPriceUSD(uint256 _sessionPriceUSD) external;\\n\\n    function setActive(bool _active) external;\\n\\n    function maxGameDuration() external view returns (uint128);\\n\\n    function getActiveSessionCount(\\n        address _player\\n    ) external view returns (uint256);\\n\\n    function active() external view returns (bool);\\n\\n    function sessionPriceUSD() external view returns (uint256);\\n\\n    function maxActiveSessions() external view returns (uint128);\\n\\n    function getRewardsAMM() external view returns (address);\\n\\n    function randomNumberCallback(\\n        bytes32 requestId,\\n        uint256 randomNumber\\n    ) external;\\n\\n    function submitGame(\\n        SubmitData calldata\\n    ) external returns (uint256, uint256);\\n\\n    function getSession(uint256) external view returns (Session memory);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IGameCard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"erc721a/contracts/extensions/IERC721AQueryable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\n\\ninterface IGameCard is IERC721AQueryable, IAccessControlUpgradeable {\\n    function mintCardIfRequired(address to) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IGameFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"../Libraries/Glicko.sol\\\";\\nimport \\\"./IAMM.sol\\\";\\nimport \\\"./IDirectory.sol\\\";\\n\\ninterface IGameFactory {\\n    error InvalidCaller();\\n    error ZeroAddress();\\n\\n    function deploy(\\n        address _adminWallet,\\n        Glicko.Config calldata _glickoConfig,\\n        IAMM _rewardsAmm,\\n        uint256 _gameId\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IGGT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IOFTV2.sol\\\";\\n\\ninterface IGGT is IERC20, IOFTV2 {\\n    function delegate(address delegatee) external;\\n\\n    function delegates(address account) external returns (address);\\n\\n    function grantRole(bytes32 role, address account) external;\\n\\n    function revokeRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IL1Payments.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IL1Payments {\\n    error InsufficientPayment();\\n    error InsufficientBalance();\\n    error TransferFailed();\\n\\n    event ETHWithdrawn(address sender, uint256 amount);\\n    event BundlePurchaseInitiated(\\n        uint256 indexed nonce,\\n        uint256 indexed bundleId,\\n        address mintTo,\\n        uint256 amount,\\n        uint256 maxPrice\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./ILayerZeroUserApplicationConfig.sol\\\";\\n\\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\\n\\t// @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n\\t// @param _dstChainId - the destination chain identifier\\n\\t// @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\n\\t// @param _payload - a custom bytes payload to send to the destination contract\\n\\t// @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\\n\\t// @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\n\\t// @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\\n\\tfunction send(\\n\\t\\tuint16 _dstChainId,\\n\\t\\tbytes calldata _destination,\\n\\t\\tbytes calldata _payload,\\n\\t\\taddress payable _refundAddress,\\n\\t\\taddress _zroPaymentAddress,\\n\\t\\tbytes calldata _adapterParams\\n\\t) external payable;\\n\\n\\t// @notice used by the messaging library to publish verified payload\\n\\t// @param _srcChainId - the source chain identifier\\n\\t// @param _srcAddress - the source contract (as bytes) at the source chain\\n\\t// @param _dstAddress - the address on destination chain\\n\\t// @param _nonce - the unbound message ordering nonce\\n\\t// @param _gasLimit - the gas limit for external contract execution\\n\\t// @param _payload - verified payload to send to the destination contract\\n\\tfunction receivePayload(\\n\\t\\tuint16 _srcChainId,\\n\\t\\tbytes calldata _srcAddress,\\n\\t\\taddress _dstAddress,\\n\\t\\tuint64 _nonce,\\n\\t\\tuint256 _gasLimit,\\n\\t\\tbytes calldata _payload\\n\\t) external;\\n\\n\\t// @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\\n\\t// @param _srcChainId - the source chain identifier\\n\\t// @param _srcAddress - the source chain contract address\\n\\tfunction getInboundNonce(\\n\\t\\tuint16 _srcChainId,\\n\\t\\tbytes calldata _srcAddress\\n\\t) external view returns (uint64);\\n\\n\\t// @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n\\t// @param _srcAddress - the source chain contract address\\n\\tfunction getOutboundNonce(\\n\\t\\tuint16 _dstChainId,\\n\\t\\taddress _srcAddress\\n\\t) external view returns (uint64);\\n\\n\\t// @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n\\t// @param _dstChainId - the destination chain identifier\\n\\t// @param _userApplication - the user app address on this EVM chain\\n\\t// @param _payload - the custom message to send over LayerZero\\n\\t// @param _payInZRO - if false, user app pays the protocol fee in native token\\n\\t// @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n\\tfunction estimateFees(\\n\\t\\tuint16 _dstChainId,\\n\\t\\taddress _userApplication,\\n\\t\\tbytes calldata _payload,\\n\\t\\tbool _payInZRO,\\n\\t\\tbytes calldata _adapterParam\\n\\t) external view returns (uint256 nativeFee, uint256 zroFee);\\n\\n\\t// @notice get this Endpoint's immutable source identifier\\n\\tfunction getChainId() external view returns (uint16);\\n\\n\\t// @notice the interface to retry failed message on this Endpoint destination\\n\\t// @param _srcChainId - the source chain identifier\\n\\t// @param _srcAddress - the source chain contract address\\n\\t// @param _payload - the payload to be retried\\n\\tfunction retryPayload(\\n\\t\\tuint16 _srcChainId,\\n\\t\\tbytes calldata _srcAddress,\\n\\t\\tbytes calldata _payload\\n\\t) external;\\n\\n\\t// @notice query if any STORED payload (message blocking) at the endpoint.\\n\\t// @param _srcChainId - the source chain identifier\\n\\t// @param _srcAddress - the source chain contract address\\n\\tfunction hasStoredPayload(\\n\\t\\tuint16 _srcChainId,\\n\\t\\tbytes calldata _srcAddress\\n\\t) external view returns (bool);\\n\\n\\t// @notice query if the _libraryAddress is valid for sending msgs.\\n\\t// @param _userApplication - the user app address on this EVM chain\\n\\tfunction getSendLibraryAddress(\\n\\t\\taddress _userApplication\\n\\t) external view returns (address);\\n\\n\\t// @notice query if the _libraryAddress is valid for receiving msgs.\\n\\t// @param _userApplication - the user app address on this EVM chain\\n\\tfunction getReceiveLibraryAddress(\\n\\t\\taddress _userApplication\\n\\t) external view returns (address);\\n\\n\\t// @notice query if the non-reentrancy guard for send() is on\\n\\t// @return true if the guard is on. false otherwise\\n\\tfunction isSendingPayload() external view returns (bool);\\n\\n\\t// @notice query if the non-reentrancy guard for receive() is on\\n\\t// @return true if the guard is on. false otherwise\\n\\tfunction isReceivingPayload() external view returns (bool);\\n\\n\\t// @notice get the configuration of the LayerZero messaging library of the specified version\\n\\t// @param _version - messaging library version\\n\\t// @param _chainId - the chainId for the pending config change\\n\\t// @param _userApplication - the contract address of the user application\\n\\t// @param _configType - type of configuration. every messaging library has its own convention.\\n\\tfunction getConfig(\\n\\t\\tuint16 _version,\\n\\t\\tuint16 _chainId,\\n\\t\\taddress _userApplication,\\n\\t\\tuint256 _configType\\n\\t) external view returns (bytes memory);\\n\\n\\t// @notice get the send() LayerZero messaging library version\\n\\t// @param _userApplication - the contract address of the user application\\n\\tfunction getSendVersion(\\n\\t\\taddress _userApplication\\n\\t) external view returns (uint16);\\n\\n\\t// @notice get the lzReceive() LayerZero messaging library version\\n\\t// @param _userApplication - the contract address of the user application\\n\\tfunction getReceiveVersion(\\n\\t\\taddress _userApplication\\n\\t) external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/ILayerZeroReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroReceiver {\\n\\t// @notice LayerZero endpoint will invoke this function to deliver the message on the destination\\n\\t// @param _srcChainId - the source endpoint identifier\\n\\t// @param _srcAddress - the source sending contract address from the source chain\\n\\t// @param _nonce - the ordered message nonce\\n\\t// @param _payload - the signed payload is the UA bytes has encoded to be sent\\n\\tfunction lzReceive(\\n\\t\\tuint16 _srcChainId,\\n\\t\\tbytes calldata _srcAddress,\\n\\t\\tuint64 _nonce,\\n\\t\\tbytes calldata _payload\\n\\t) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/ILayerZeroUserApplicationConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroUserApplicationConfig {\\n\\t// @notice set the configuration of the LayerZero messaging library of the specified version\\n\\t// @param _version - messaging library version\\n\\t// @param _chainId - the chainId for the pending config change\\n\\t// @param _configType - type of configuration. every messaging library has its own convention.\\n\\t// @param _config - configuration in the bytes. can encode arbitrary content.\\n\\tfunction setConfig(\\n\\t\\tuint16 _version,\\n\\t\\tuint16 _chainId,\\n\\t\\tuint256 _configType,\\n\\t\\tbytes calldata _config\\n\\t) external;\\n\\n\\t// @notice set the send() LayerZero messaging library version to _version\\n\\t// @param _version - new messaging library version\\n\\tfunction setSendVersion(uint16 _version) external;\\n\\n\\t// @notice set the lzReceive() LayerZero messaging library version to _version\\n\\t// @param _version - new messaging library version\\n\\tfunction setReceiveVersion(uint16 _version) external;\\n\\n\\t// @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n\\t// @param _srcChainId - the chainId of the source chain\\n\\t// @param _srcAddress - the contract address of the source contract at the source chain\\n\\tfunction forceResumeReceive(\\n\\t\\tuint16 _srcChainId,\\n\\t\\tbytes calldata _srcAddress\\n\\t) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IMItemsFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./IDirectory.sol\\\";\\nimport \\\"./IGame.sol\\\";\\n\\ninterface IMItemsFactory {\\n    error ZeroAddress();\\n    error InvalidCaller();\\n    error AddressAlreadySet();\\n\\n    event ValidMItemsSet(address mItems, bool isValid);\\n\\n    function deploy(\\n        string memory,\\n        string memory,\\n        address,\\n        address,\\n        IDirectory,\\n        address\\n    ) external returns (address, address);\\n\\n    function validMItems(address _mitemContract) external view returns (bool);\\n\\n    function setValidMItem(address _mItem, bool _valid) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IOFTV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./ICommonOFT.sol\\\";\\n\\n/**\\n * @dev Interface of the IOFT core standard\\n */\\ninterface IOFTV2 is ICommonOFT {\\n\\n    /**\\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\\n     * `_from` the owner of token\\n     * `_dstChainId` the destination chain identifier\\n     * `_toAddress` can be any size depending on the `dstChainId`.\\n     * `_amount` the quantity of tokens in wei\\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\\n     */\\n    function sendFrom(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, LzCallParams calldata _callParams) external payable;\\n\\n    function sendAndCall(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes calldata _payload, uint64 _dstGasForCall, LzCallParams calldata _callParams) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IPartnerships.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IPartnerships {\\n    error GameDoesNotExist();\\n\\n    function rewardsPermission(\\n        address game,\\n        uint256 gameId,\\n        uint256 ticketAmount,\\n        uint256 extractorId,\\n        uint256 extractorAmount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IPermissionRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IPermissionRegistry {\\n    struct Permission {\\n        bytes permissionPayload;\\n        bytes permissionFuncData;\\n        address permissionQueryContract;\\n        uint256 permissionCompareVal;\\n        CompareOperator permissionCompareOperator;\\n    }\\n\\n    enum CompareOperator {\\n        EQUAL,\\n        GREATER,\\n        GREATER_OR_EQUAL,\\n        LOWER,\\n        LOWER_OR_EQUAL\\n    }\\n\\n    error InvalidPermission();\\n    error CallFailed();\\n\\n    event PermissionCreated(uint256 indexed id);\\n\\n    function isAllowed(\\n        address _userWallet,\\n        uint256 _permissionId\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IPriceFeed {\\n    event PriceUpdated(bytes32 pair, uint256 price);\\n\\n    function currentPrice(bytes32 _pair) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IProfileStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"../Libraries/Glicko.sol\\\";\\n\\ninterface IProfileStorage {\\n    error PlayerAlreadyRegistered();\\n    error PlayerNotRegistered();\\n    error InvalidCaller();\\n\\n    event RatingUpdated(\\n        uint256 gameId,\\n        address player,\\n        SD59x18 mu,\\n        SD59x18 phi,\\n        SD59x18 volatility\\n    );\\n\\n    function updateProfile(\\n        address _player,\\n        Glicko.Profile calldata _profile\\n    ) external;\\n\\n    function profile(\\n        uint256 _gameId,\\n        address _player,\\n        uint256\\n    ) external view returns (Glicko.Profile memory);\\n\\n    function registerPlayer(\\n        address _player,\\n        Glicko.Config memory _glickoConfig\\n    ) external;\\n\\n    function getProfileUnknown(\\n        address _player,\\n        Glicko.Config memory _glickoConfig\\n    ) external returns (Glicko.Profile memory);\\n\\n    function getRatingPeriodsMissed(\\n        uint256,\\n        address,\\n        uint256\\n    ) external view returns (SD59x18);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IQRNGProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./IRandomNumberProvider.sol\\\";\\n\\ninterface IQRNGProvider is IRandomNumberProvider {\\n    struct GameSponsor {\\n        address sponsor;\\n        address sponsorWallet;\\n    }\\n\\n    error InvalidCaller();\\n    error RequestIdUnknown();\\n\\n    event RequestParametsSet(\\n        address airnode,\\n        bytes32 endpointIdUint256,\\n        bytes32 endpointIdUint256Array\\n    );\\n    event GameSponsorSet(\\n        address indexed game,\\n        address sponsor,\\n        address sponsorWallet\\n    );\\n\\n    function setRequestParameters(\\n        address _airnode,\\n        bytes32 _endpointIdUint256,\\n        bytes32 _endpointIdUint256Array\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IRandomNumberProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IRandomNumberProvider {\\n    function requestRN() external payable returns (bytes32);\\n}\\n\\ninterface IRandomizer {\\n    // Makes a Randomizer VRF callback request with a callback gas limit\\n    function request(uint256 callbackGasLimit) external returns (uint256);\\n\\n    // Estimates the VRF fee given a callback gas limit\\n    function estimateFee(uint256 callbackGasLimit) external returns (uint256);\\n\\n    // Deposits ETH to Randomizer for the client contract\\n    function clientDeposit(address client) external payable;\\n\\n    // Withdraws deposited ETH from the client contract to the destination address\\n    function clientWithdrawTo(address to, uint256 amount) external;\\n\\n    function getFeeStats(\\n        uint256 request\\n    ) external view returns (uint256[2] memory);\\n\\n    // Gets the amount of ETH deposited and reserved for the client contract\\n    function clientBalanceOf(\\n        address _client\\n    ) external view returns (uint256 deposit, uint256 reserved);\\n\\n    // Returns the request data\\n    function getRequest(\\n        uint256 request\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32 result,\\n            bytes32 dataHash,\\n            uint256 ethPaid,\\n            uint256 ethRefunded,\\n            bytes10[2] memory vrfHashes\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IRebootBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\ninterface IRebootBeacon is IAccessControl {\\n    function upgradeTo(address newImplementation) external;\\n\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IRegistry {\\n    error LengthMismatch();\\n    error ZeroLength();\\n\\n    event AddressApprovalUpdated(address validator, bool isApproved);\\n    event AddressApprovalBatchUpdated(address[] validators, bool[] areApproved);\\n\\n    function approvedAddresses(address) external view returns (bool);\\n\\n    function updateApprovedAddress(address, bool) external;\\n\\n    function updateApprovedAddressBatch(\\n        address[] calldata,\\n        bool[] calldata\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IRewardsPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IRewardsPool {\\n    error CallFailed(bytes data);\\n    error NoPermission();\\n    error InsufficientBalance();\\n    error TransferFailed();\\n    error ZeroAddress();\\n\\n    event GGWithdrawn(address sender, uint256 amount);\\n    event ETHWithdrawn(address sender, uint256 amount);\\n    event DepositedETH(address sender, uint256 amount);\\n    event SwappedETH(uint256 amountETH, uint256 minOut);\\n\\n    function requestGG(uint256) external;\\n\\n    function withdrawGG(address _receiver, uint256 _amount) external;\\n\\n    function withdrawETH(address _receiver, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/IStakingContracts.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IStakingContracts {\\n    function getVotes(address, uint256) external view returns (uint256);\\n\\n    function addStakingContract(address) external;\\n\\n    function removeStakingContract(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/ITickets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\n\\ninterface ITickets is IAccessControlUpgradeable {\\n    error InvalidContractAddress();\\n    error ZeroTokens();\\n    error MustHaveTicketPerGG();\\n    error InvalidParams();\\n    error TicketPerGGTooHigh();\\n    error GameValueAlreadySet();\\n    error ExtractorBlockedByGame();\\n    error InvalidId();\\n    error InvalidCaller();\\n    error MustUseExtractors();\\n\\n    event UriSet(string uri);\\n    event NovaChainIdSet(uint16 newId);\\n    event AdapterParamsSet(uint16 version, uint256 gasForDestination);\\n\\n    event TicketsPerGGSet(uint256 gameId, uint256 ticketsPerGG);\\n\\n    function ticketsPerGG(uint256) external view returns (uint256);\\n\\n    function setTicketsPerGG(uint256, uint256) external;\\n\\n    function mint(\\n        address to,\\n        address ggFrom,\\n        uint256 id,\\n        uint256 amount\\n    ) external;\\n\\n    function burn(\\n        address from,\\n        address ggTo,\\n        uint256 amount,\\n        uint256 gameId,\\n        uint256 extractorId\\n    ) external;\\n\\n    function burnAndTransferSaleShares(\\n        address from,\\n        uint256 gameId,\\n        uint256[3] calldata shares,\\n        address[4] calldata receivers,\\n        uint256 totalAmount\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Interfaces/ITokenMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface ITokenMarket {\\n    enum CurveType {\\n        NONE,\\n        LINEAR,\\n        LOGISTIC\\n    }\\n\\n    /// @notice Target price for a token, to be scaled according to sales pace.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n\\n    /// @dev Precomputed constant that allows us to rewrite a pow() as an exp().\\n    /// @dev Represented as an 18 decimal fixed point number.\\n\\n    /// @dev The maximum number of tokens of tokens to sell + 1. We add\\n    /// 1 because the logistic function will never fully reach its limit.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n\\n    /// @dev The maximum number of tokens of tokens to sell + 1 multiplied\\n    /// by 2. We could compute it on the fly each time but this saves gas.\\n    /// @dev Represented as a 36 decimal fixed point number.\\n\\n    /// @dev Time scale controls the steepness of the logistic curve,\\n    /// which affects how quickly we will reach the curve's asymptote.\\n    /// @dev Represented as an 18 decimal fixed point number.\\n    struct TokenSale {\\n        CurveType curveType;\\n        address devShareReceiver;\\n        int256 decayConstant;\\n        int256 maxSellable;\\n        int256 targetPrice;\\n        int256 time;\\n        uint256 startTime;\\n        // basis point share base on 10000 (permyriad)\\n        uint256 devShare;\\n        bool active;\\n        uint256 permissionId;\\n        uint256 startSupply;\\n    }\\n\\n    /// _targetPrice The target price for a token if sold on pace, scaled by 1e18.\\n    /// _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\\n    /// _perTimeUnit The number of tokens to target selling in 1 full unit of time, scaled by 1e18.\\n\\n    /// _targetPrice The target price for a token if sold on pace, scaled by 1e18.\\n    /// _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\\n    /// _maxSellable The maximum number of tokens to sell, scaled by 1e18.\\n    /// _timeScale The steepness of the logistic curve, scaled by 1e18.\\n    struct SaleDetails {\\n        CurveType curveType;\\n        address tokenAddress;\\n        address devShareReceiver;\\n        int256 targetPrice;\\n        int256 priceDecayPercent;\\n        uint256 maxSellable;\\n        int256 time;\\n        uint256 tokenId;\\n        // basis point share base on 10000 (permyriad)\\n        uint256 devShare;\\n        bool active;\\n        uint256 permissionId;\\n        bool reset;\\n    }\\n\\n    enum CompareOperator {\\n        EQUAL,\\n        GREATER,\\n        GREATER_OR_EQUAL,\\n        LOWER,\\n        LOWER_OR_EQUAL\\n    }\\n\\n    error CurveNotSupported();\\n    error InsufficientPayment();\\n    error NonNegativeDecayConstant();\\n    error PurchaseExceedsSupply();\\n    error NoActiveSale();\\n    error UnsupportedToken();\\n    error DevShareTooHigh();\\n    error MissingCurveType();\\n    error SaleDoesNotExist();\\n    error InvalidValue();\\n    error CallFailed();\\n    error InvalidParams();\\n    error WrongGameId();\\n\\n    event ProtocolFeeReceiverUpdated(address indexed newReceiver);\\n    event ProtocolFeeUpdated(uint256 newFee);\\n    event MaxDevShareUpdated(uint256 newFee);\\n\\n    event UpdatedSale(address indexed token, uint256 indexed tokenId);\\n\\n    event AllowedBuyerUpdated(\\n        address indexed token,\\n        uint256 tokenId,\\n        address indexed buyer,\\n        bool allowed\\n    );\\n    event TokenSaleStatusUpdated(\\n        address indexed token,\\n        uint256 tokenId,\\n        bool active\\n    );\\n    event AllowlistOnlyUpdated(\\n        address indexed token,\\n        uint256 tokenId,\\n        bool allowlistOnly\\n    );\\n    event DevShareUpdated(\\n        address indexed token,\\n        uint256 tokenId,\\n        address receiver,\\n        uint256 devShare\\n    );\\n    event Purchased(\\n        address indexed tokenAddress,\\n        address purchaser,\\n        uint256 tokenId,\\n        uint256 amount,\\n        uint256 totalPrice\\n    );\\n\\n    function purchase(\\n        address _tokenAddress,\\n        uint256 _tokenId,\\n        address _receivingAddress,\\n        uint256 _amount,\\n        uint256 _maxPrice,\\n        uint256 _gameId\\n    ) external;\\n\\n    function setProtocolFeeReceiver(address _protocolFeeReceiver) external;\\n\\n    function setProtocolFee(uint256 _protocolFee) external;\\n\\n    function setMaxDevShare(uint256 _maxDevShare) external;\\n\\n    function getVRGDAPrice(\\n        address _tokenAddress1155,\\n        uint256 _tokenId,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function getTokenSale(\\n        address _token,\\n        uint256 _tokenId\\n    ) external view returns (TokenSale memory);\\n\\n    function canPurchase(\\n        address _player,\\n        address _token,\\n        uint256 _tokenId\\n    ) external returns (bool);\\n\\n    function grantProtocolRole(address _contract) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/L1Payments.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"./Interfaces/IL1Payments.sol\\\";\\nimport \\\"./CreditBundle.sol\\\";\\nimport \\\"./LayerZero/LzApp.sol\\\";\\n\\n/**\\n * @title Execute ETH payments on mainnet and receive them on L2\\n *\\n * @author Niftydude, Jack Chuma\\n */\\ncontract L1Payments is LzApp, IL1Payments {\\n    uint16 public immutable L2_CHAIN_ID;\\n\\n    constructor(\\n        address _endpoint,\\n        address _admin,\\n        uint256 _l2ChainId\\n    ) LzApp(_admin) {\\n        if (_endpoint == address(0)) revert ZeroAddress();\\n\\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\\n\\n        L2_CHAIN_ID = uint16(_l2ChainId);\\n    }\\n\\n    function estimateFees(\\n        uint64 _bundleId,\\n        uint256 _amount,\\n        uint256 _maxPrice,\\n        uint256 _gasForDestinationLzReceive\\n    ) external view returns (uint256 messageFee) {\\n        bytes memory payload = abi.encode(\\n            _bundleId,\\n            _amount,\\n            msg.sender,\\n            _maxPrice\\n        );\\n\\n        uint16 version = 1;\\n        bytes memory adapterParams = abi.encodePacked(\\n            version,\\n            _gasForDestinationLzReceive\\n        );\\n\\n        (messageFee, ) = lzEndpoint.estimateFees(\\n            L2_CHAIN_ID,\\n            address(this),\\n            payload,\\n            false,\\n            adapterParams\\n        );\\n    }\\n\\n    function purchaseCreditBundle(\\n        uint64 _bundleId,\\n        uint256 _amount,\\n        uint256 _maxPrice,\\n        uint256 _gasForDestinationLzReceive\\n    ) external payable {\\n        if (msg.value <= _maxPrice) revert InsufficientPayment();\\n\\n        bytes memory payload = abi.encode(\\n            _bundleId,\\n            _amount,\\n            msg.sender,\\n            _maxPrice\\n        );\\n\\n        uint16 version = 1;\\n        bytes memory adapterParams = abi.encodePacked(\\n            version,\\n            _gasForDestinationLzReceive\\n        );\\n\\n        _lzSend(\\n            L2_CHAIN_ID,\\n            payload,\\n            payable(msg.sender),\\n            address(0x0),\\n            adapterParams,\\n            msg.value - _maxPrice\\n        );\\n\\n        uint256 _nonce = lzEndpoint.getOutboundNonce(\\n            L2_CHAIN_ID,\\n            address(this)\\n        );\\n\\n        emit BundlePurchaseInitiated(\\n            _nonce,\\n            _bundleId,\\n            msg.sender,\\n            _amount,\\n            msg.value\\n        );\\n    }\\n\\n    /**\\n     * @notice withdraw eth balance to a given address\\n     *\\n     * @param _receiver the receiving address\\n     * @param _amount amount to withdrawin wei\\n     */\\n    function withdrawETH(\\n        address _receiver,\\n        uint256 _amount\\n    ) external onlyRole(ADMIN_ROLE) {\\n        if (_receiver == address(0)) revert ZeroAddress();\\n        if (address(this).balance < _amount) revert InsufficientBalance();\\n\\n        (bool sent, ) = _receiver.call{value: _amount}(\\\"\\\");\\n        if (!sent) revert TransferFailed();\\n\\n        emit ETHWithdrawn(_receiver, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/LayerZero/BaseLzApp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../Interfaces/ILayerZeroReceiver.sol\\\";\\nimport \\\"../Interfaces/ILayerZeroUserApplicationConfig.sol\\\";\\nimport \\\"../Interfaces/ILayerZeroEndpoint.sol\\\";\\n\\nimport \\\"@layerzerolabs/solidity-examples/contracts/libraries/BytesLib.sol\\\";\\n\\nabstract contract BaseLzApp is\\n    ILayerZeroReceiver,\\n    ILayerZeroUserApplicationConfig\\n{\\n    using BytesLib for bytes;\\n\\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\\n    uint public constant DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\\n\\n    ILayerZeroEndpoint public lzEndpoint;\\n    mapping(uint16 => bytes) public trustedRemoteLookup;\\n    mapping(uint16 => mapping(uint256 => uint256)) public minDstGasLookup;\\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\\n    address public precrime;\\n\\n    error Blocked();\\n\\n    event SetPrecrime(address precrime);\\n    event SetTrustedRemote(uint16 _srcChainId, bytes _srcAddress);\\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\\n    event SetMinDstGas(\\n        uint16 _dstChainId,\\n        uint256 _type,\\n        uint256 _dstGasAmount\\n    );\\n\\n    function lzReceive(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        uint64 _nonce,\\n        bytes calldata _payload\\n    ) public virtual override {\\n        // lzReceive must be called by the endpoint for security\\n        require(\\n            msg.sender == address(lzEndpoint),\\n            \\\"LzApp: invalid endpoint caller\\\"\\n        );\\n\\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\\n        require(\\n            _srcAddress.length == trustedRemote.length &&\\n                trustedRemote.length > 0 &&\\n                keccak256(_srcAddress) == keccak256(trustedRemote),\\n            \\\"LzApp: invalid source sending contract\\\"\\n        );\\n\\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\\n    }\\n\\n    function _blockingLzReceive(\\n        uint16,\\n        bytes memory,\\n        uint64,\\n        bytes memory\\n    ) internal virtual {\\n        revert Blocked();\\n    }\\n\\n    function _lzSend(\\n        uint16 _dstChainId,\\n        bytes memory _payload,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes memory _adapterParams,\\n        uint256 _nativeFee\\n    ) internal virtual {\\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\\n        require(\\n            trustedRemote.length != 0,\\n            \\\"LzApp: destination chain is not a trusted source\\\"\\n        );\\n        _checkPayloadSize(_dstChainId, _payload.length);\\n        lzEndpoint.send{ value: _nativeFee }(\\n            _dstChainId,\\n            trustedRemote,\\n            _payload,\\n            _refundAddress,\\n            _zroPaymentAddress,\\n            _adapterParams\\n        );\\n    }\\n\\n    function _checkGasLimit(\\n        uint16 _dstChainId,\\n        uint16 _type,\\n        bytes memory _adapterParams,\\n        uint _extraGas\\n    ) internal view virtual {\\n        uint providedGasLimit = _getGasLimit(_adapterParams);\\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type];\\n\\n        require(minGasLimit > 0, \\\"LzApp: minGasLimit not set\\\");\\n        require(\\n            providedGasLimit >= minGasLimit + _extraGas,\\n            \\\"LzApp: gas limit is too low\\\"\\n        );\\n    }\\n\\n    function _getGasLimit(\\n        bytes memory _adapterParams\\n    ) internal pure virtual returns (uint gasLimit) {\\n        require(_adapterParams.length >= 34, \\\"LzApp: invalid adapterParams\\\");\\n        assembly {\\n            gasLimit := mload(add(_adapterParams, 34))\\n        }\\n    }\\n\\n    function _checkPayloadSize(\\n        uint16 _dstChainId,\\n        uint _payloadSize\\n    ) internal view virtual {\\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\\n        if (payloadSizeLimit == 0) {\\n            // use default if not set\\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\\n        }\\n        require(\\n            _payloadSize <= payloadSizeLimit,\\n            \\\"LzApp: payload size is too large\\\"\\n        );\\n    }\\n\\n    function getConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        address,\\n        uint256 _configType\\n    ) external view returns (bytes memory) {\\n        return\\n            lzEndpoint.getConfig(\\n                _version,\\n                _chainId,\\n                address(this),\\n                _configType\\n            );\\n    }\\n\\n    function getTrustedRemoteAddress(\\n        uint16 _remoteChainId\\n    ) external view returns (bytes memory) {\\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\\n        require(path.length != 0, \\\"LzApp: no trusted path record\\\");\\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\\n    }\\n\\n    function isTrustedRemote(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress\\n    ) external view returns (bool) {\\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\\n        return keccak256(trustedSource) == keccak256(_srcAddress);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/LayerZero/ExcessivelySafeCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.7.6;\\n\\nlibrary ExcessivelySafeCall {\\n    uint256 constant LOW_28_MASK =\\n        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    /// @notice Use when you _really_ really _really_ don't trust the called\\n    /// contract. This prevents the called contract from causing reversion of\\n    /// the caller in as many ways as we can.\\n    /// @dev The main difference between this and a solidity low-level call is\\n    /// that we limit the number of bytes that the callee can cause to be\\n    /// copied to caller memory. This prevents stupid things like malicious\\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\\n    /// to memory.\\n    /// @param _target The address to call\\n    /// @param _gas The amount of gas to forward to the remote contract\\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\\n    /// to memory.\\n    /// @param _calldata The data to send to the remote contract\\n    /// @return success and returndata, as `.call()`. Returndata is capped to\\n    /// `_maxCopy` bytes.\\n    function excessivelySafeCall(\\n        address _target,\\n        uint256 _gas,\\n        uint16 _maxCopy,\\n        bytes memory _calldata\\n    ) internal returns (bool, bytes memory) {\\n        // set up for assembly call\\n        uint256 _toCopy;\\n        bool _success;\\n        bytes memory _returnData = new bytes(_maxCopy);\\n        // dispatch message to recipient\\n        // by assembly calling \\\"handle\\\" function\\n        // we call via assembly to avoid memcopying a very large returndata\\n        // returned by a malicious contract\\n        assembly {\\n            _success := call(\\n                _gas, // gas\\n                _target, // recipient\\n                0, // ether value\\n                add(_calldata, 0x20), // inloc\\n                mload(_calldata), // inlen\\n                0, // outloc\\n                0 // outlen\\n            )\\n            // limit our copy to 256 bytes\\n            _toCopy := returndatasize()\\n            if gt(_toCopy, _maxCopy) {\\n                _toCopy := _maxCopy\\n            }\\n            // Store the length of the copied bytes\\n            mstore(_returnData, _toCopy)\\n            // copy the bytes from returndata[0:_toCopy]\\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\\n        }\\n        return (_success, _returnData);\\n    }\\n\\n    /// @notice Use when you _really_ really _really_ don't trust the called\\n    /// contract. This prevents the called contract from causing reversion of\\n    /// the caller in as many ways as we can.\\n    /// @dev The main difference between this and a solidity low-level call is\\n    /// that we limit the number of bytes that the callee can cause to be\\n    /// copied to caller memory. This prevents stupid things like malicious\\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\\n    /// to memory.\\n    /// @param _target The address to call\\n    /// @param _gas The amount of gas to forward to the remote contract\\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\\n    /// to memory.\\n    /// @param _calldata The data to send to the remote contract\\n    /// @return success and returndata, as `.call()`. Returndata is capped to\\n    /// `_maxCopy` bytes.\\n    function excessivelySafeStaticCall(\\n        address _target,\\n        uint256 _gas,\\n        uint16 _maxCopy,\\n        bytes memory _calldata\\n    ) internal view returns (bool, bytes memory) {\\n        // set up for assembly call\\n        uint256 _toCopy;\\n        bool _success;\\n        bytes memory _returnData = new bytes(_maxCopy);\\n        // dispatch message to recipient\\n        // by assembly calling \\\"handle\\\" function\\n        // we call via assembly to avoid memcopying a very large returndata\\n        // returned by a malicious contract\\n        assembly {\\n            _success := staticcall(\\n                _gas, // gas\\n                _target, // recipient\\n                add(_calldata, 0x20), // inloc\\n                mload(_calldata), // inlen\\n                0, // outloc\\n                0 // outlen\\n            )\\n            // limit our copy to 256 bytes\\n            _toCopy := returndatasize()\\n            if gt(_toCopy, _maxCopy) {\\n                _toCopy := _maxCopy\\n            }\\n            // Store the length of the copied bytes\\n            mstore(_returnData, _toCopy)\\n            // copy the bytes from returndata[0:_toCopy]\\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\\n        }\\n        return (_success, _returnData);\\n    }\\n\\n    /**\\n     * @notice Swaps function selectors in encoded contract calls\\n     * @dev Allows reuse of encoded calldata for functions with identical\\n     * argument types but different names. It simply swaps out the first 4 bytes\\n     * for the new selector. This function modifies memory in place, and should\\n     * only be used with caution.\\n     * @param _newSelector The new 4-byte selector\\n     * @param _buf The encoded contract args\\n     */\\n    function swapSelector(\\n        bytes4 _newSelector,\\n        bytes memory _buf\\n    ) internal pure {\\n        require(_buf.length >= 4);\\n        uint256 _mask = LOW_28_MASK;\\n        assembly {\\n            // load the first word of\\n            let _word := mload(add(_buf, 0x20))\\n            // mask out the top 4 bytes\\n            // /x\\n            _word := and(_word, _mask)\\n            _word := or(_newSelector, _word)\\n            mstore(add(_buf, 0x20), _word)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/LayerZero/LzApp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./BaseLzApp.sol\\\";\\nimport \\\"../Utils/ContractRoles.sol\\\";\\n\\n/*\\n * a generic LzReceiver implementation\\n */\\nabstract contract LzApp is BaseLzApp, ContractRoles {\\n    constructor(address _admin) ContractRoles(_admin) {\\n        _grantRole(ADMIN_ROLE, _admin);\\n    }\\n\\n    function setConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        uint256 _configType,\\n        bytes calldata _config\\n    ) external override onlyRole(ADMIN_ROLE) {\\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\\n    }\\n\\n    function setSendVersion(\\n        uint16 _version\\n    ) external override onlyRole(ADMIN_ROLE) {\\n        lzEndpoint.setSendVersion(_version);\\n    }\\n\\n    function setReceiveVersion(\\n        uint16 _version\\n    ) external override onlyRole(ADMIN_ROLE) {\\n        lzEndpoint.setReceiveVersion(_version);\\n    }\\n\\n    function setLzEndpoint(address _lzEndpoint) external onlyRole(ADMIN_ROLE) {\\n        lzEndpoint = ILayerZeroEndpoint(_lzEndpoint);\\n    }\\n\\n    function forceResumeReceive(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress\\n    ) external override onlyRole(ADMIN_ROLE) {\\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\\n    }\\n\\n    // allow owner to set it multiple times.\\n    function setTrustedRemote(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress\\n    ) external onlyRole(ADMIN_ROLE) {\\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\\n    }\\n\\n    function setTrustedRemoteAddress(\\n        uint16 _remoteChainId,\\n        bytes calldata _remoteAddress\\n    ) external onlyRole(ADMIN_ROLE) {\\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(\\n            _remoteAddress,\\n            address(this)\\n        );\\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\\n    }\\n\\n    function setPrecrime(address _precrime) external onlyRole(ADMIN_ROLE) {\\n        precrime = _precrime;\\n        emit SetPrecrime(_precrime);\\n    }\\n\\n    function setMinDstGas(\\n        uint16 _dstChainId,\\n        uint16 _packetType,\\n        uint _minGas\\n    ) external onlyRole(ADMIN_ROLE) {\\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\\n    }\\n\\n    // if the size is 0, it means default size limit\\n    function setPayloadSizeLimit(\\n        uint16 _dstChainId,\\n        uint _size\\n    ) external onlyRole(ADMIN_ROLE) {\\n        payloadSizeLimitLookup[_dstChainId] = _size;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/LayerZero/LzAppUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./BaseLzApp.sol\\\";\\nimport \\\"../Utils/ContractRolesUpgradeable.sol\\\";\\n\\n/*\\n * a generic LzReceiver implementation\\n */\\nabstract contract LzAppUpgradeable is BaseLzApp, ContractRolesUpgradeable {\\n    function __LzApp_init(\\n        address _endpoint,\\n        address _admin\\n    ) public onlyInitializing {\\n        __ContractRoles_init(_admin);\\n\\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\\n\\n        _grantRole(ADMIN_ROLE, _admin);\\n    }\\n\\n    // generic config for LayerZero user Application\\n    function setConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        uint256 _configType,\\n        bytes calldata _config\\n    ) external override onlyRole(ADMIN_ROLE) {\\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\\n    }\\n\\n    function setSendVersion(\\n        uint16 _version\\n    ) external override onlyRole(ADMIN_ROLE) {\\n        lzEndpoint.setSendVersion(_version);\\n    }\\n\\n    function setReceiveVersion(\\n        uint16 _version\\n    ) external override onlyRole(ADMIN_ROLE) {\\n        lzEndpoint.setReceiveVersion(_version);\\n    }\\n\\n    function setLzEndpoint(address _lzEndpoint) external onlyRole(ADMIN_ROLE) {\\n        lzEndpoint = ILayerZeroEndpoint(_lzEndpoint);\\n    }\\n\\n    function forceResumeReceive(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress\\n    ) external override onlyRole(ADMIN_ROLE) {\\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\\n    }\\n\\n    // allow owner to set it multiple times.\\n    function setTrustedRemote(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress\\n    ) external onlyRole(ADMIN_ROLE) {\\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\\n    }\\n\\n    function setTrustedRemoteAddress(\\n        uint16 _remoteChainId,\\n        bytes calldata _remoteAddress\\n    ) external onlyRole(ADMIN_ROLE) {\\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(\\n            _remoteAddress,\\n            address(this)\\n        );\\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\\n    }\\n\\n    function setPrecrime(address _precrime) external onlyRole(ADMIN_ROLE) {\\n        precrime = _precrime;\\n        emit SetPrecrime(_precrime);\\n    }\\n\\n    function setMinDstGas(\\n        uint16 _dstChainId,\\n        uint16 _packetType,\\n        uint _minGas\\n    ) external onlyRole(ADMIN_ROLE) {\\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\\n    }\\n\\n    // if the size is 0, it means default size limit\\n    function setPayloadSizeLimit(\\n        uint16 _dstChainId,\\n        uint _size\\n    ) external onlyRole(ADMIN_ROLE) {\\n        payloadSizeLimitLookup[_dstChainId] = _size;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/LayerZero/NonblockingLzAppUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"./ExcessivelySafeCall.sol\\\";\\nimport \\\"./LzAppUpgradeable.sol\\\";\\n\\nabstract contract NonblockingLzAppUpgradeable is LzAppUpgradeable {\\n    using ExcessivelySafeCall for address;\\n\\n    function __NonblockingLzApp_init(\\n        address _endpoint,\\n        address _admin\\n    ) public initializer {\\n        __LzApp_init(_endpoint, _admin);\\n    }\\n\\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32)))\\n        public failedMessages;\\n\\n    event MessageFailed(\\n        uint16 _srcChainId,\\n        bytes _srcAddress,\\n        uint64 _nonce,\\n        bytes _payload,\\n        bytes _reason\\n    );\\n    event RetryMessageSuccess(\\n        uint16 _srcChainId,\\n        bytes _srcAddress,\\n        uint64 _nonce,\\n        bytes32 _payloadHash\\n    );\\n\\n    // overriding the virtual function in LzReceiver\\n    function _blockingLzReceive(\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint64 _nonce,\\n        bytes memory _payload\\n    ) internal virtual override {\\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(\\n            gasleft(),\\n            150,\\n            abi.encodeWithSelector(\\n                this.nonblockingLzReceive.selector,\\n                _srcChainId,\\n                _srcAddress,\\n                _nonce,\\n                _payload\\n            )\\n        );\\n        if (!success) {\\n            _storeFailedMessage(\\n                _srcChainId,\\n                _srcAddress,\\n                _nonce,\\n                _payload,\\n                reason\\n            );\\n        }\\n    }\\n\\n    function _storeFailedMessage(\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint64 _nonce,\\n        bytes memory _payload,\\n        bytes memory _reason\\n    ) internal virtual {\\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\\n    }\\n\\n    function nonblockingLzReceive(\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint64 _nonce,\\n        bytes memory _payload\\n    ) public virtual {\\n        // only internal transactio\\n        require(\\n            _msgSender() == address(this),\\n            \\\"NonblockingLzApp: caller must be LzApp\\\"\\n        );\\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\\n    }\\n\\n    //@notice override this function\\n    function _nonblockingLzReceive(\\n        uint16 _srcChainId,\\n        bytes memory _srcAddress,\\n        uint64 _nonce,\\n        bytes memory _payload\\n    ) internal virtual;\\n\\n    function retryMessage(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        uint64 _nonce,\\n        bytes calldata _payload\\n    ) public payable virtual {\\n        // assert there is message to retry\\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\\n        require(\\n            payloadHash != bytes32(0),\\n            \\\"NonblockingLzApp: no stored message\\\"\\n        );\\n        require(\\n            keccak256(_payload) == payloadHash,\\n            \\\"NonblockingLzApp: invalid payload\\\"\\n        );\\n        // clear the stored message\\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\\n        // execute the message. revert if it fails again\\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Libraries/Glicko.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport { SD59x18, convert, exp, sub, div, mul, sqrt, add, unwrap, wrap, inv, ln, gt, lt, abs, isZero, intoUint256, ZERO, UNIT } from \\\"@prb/math/src/SD59x18.sol\\\";\\n\\n/**\\n * @title Glicko Contract\\n *\\n * @author Jack Chuma\\n *\\n * @notice Library implementation of the Glicko2 rating system\\n */\\nlibrary Glicko {\\n    SD59x18 constant PI_SQUARED = SD59x18.wrap(9.869604401089358618e18);\\n    SD59x18 constant EPSILON = SD59x18.wrap(0.000001e18);\\n    SD59x18 constant TWO = SD59x18.wrap(2e18);\\n    SD59x18 constant THREE = SD59x18.wrap(3e18);\\n\\n    struct Profile {\\n        SD59x18 mu;\\n        SD59x18 phi;\\n        SD59x18 volatility;\\n    }\\n\\n    struct Config {\\n        SD59x18 defaultMu;\\n        SD59x18 defaultPhi;\\n        SD59x18 defaultVolatility;\\n        SD59x18 tau;\\n        SD59x18 idealConvergenceThreshold;\\n        uint256 epochDuration;\\n    }\\n\\n    struct GlickoInstance {\\n        Memo memo;\\n        SD59x18 playerMu;\\n        SD59x18 playerPhiSquared;\\n        SD59x18[] oppPhisSquared;\\n        SD59x18 v;\\n        SD59x18 delta;\\n        SD59x18 phiStarSquared;\\n        SD59x18 phiPrime;\\n        SD59x18 muPrime;\\n    }\\n\\n    struct Memo {\\n        SD59x18[] gPhis;\\n        SD59x18[] Ecalcs;\\n        SD59x18 gSMinusESum;\\n    }\\n\\n    error LengthMismatch();\\n    error ZeroLength();\\n\\n    /**\\n     * @notice Calculates probability of a player winning a skill-based game based on glicko ratings.\\n     *\\n     * @param _oppMu Glicko rating of opponent in Glicko2 scale\\n     * @param _oppRD Rating deviation of opponent in Glicko2 scale\\n     */\\n    function calculateWinProbability(\\n        Profile memory _playerRating,\\n        SD59x18 _oppMu,\\n        SD59x18 _oppRD\\n    ) external pure returns (SD59x18) {\\n        return _winProb(_playerRating.mu, _playerRating.phi, _oppMu, _oppRD);\\n    }\\n\\n    /**\\n     * @notice Calculates probability of a player winning a batch of skill-based games based on glicko ratings.\\n     *\\n     * @param _oppRatings Array of opponent ratings\\n     * @param _oppRDs Array of opponent rating deviations\\n     */\\n    function calculateWinProbabilityBatch(\\n        Profile memory _playerRating,\\n        SD59x18[] calldata _oppRatings,\\n        SD59x18[] calldata _oppRDs\\n    ) external pure returns (SD59x18[] memory) {\\n        if (_oppRatings.length == 0) revert ZeroLength();\\n        if (_oppRatings.length != _oppRDs.length) revert LengthMismatch();\\n\\n        // Initiate array to hold win probabilities\\n        SD59x18[] memory _winProbs = new SD59x18[](_oppRatings.length);\\n        // Loop through oppRatings array\\n        for (uint256 i; i < _oppRatings.length; ) {\\n            // Calculate win probability and store in _winProbs array\\n            _winProbs[i] = _winProb(\\n                _playerRating.mu,\\n                _playerRating.phi,\\n                _oppRatings[i],\\n                _oppRDs[i]\\n            );\\n            // Increment loop iterator without checking for overflow\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return _winProbs;\\n    }\\n\\n    /**\\n     * @dev Private helper function containing glicko rating update math\\n     */\\n    function update(\\n        Profile memory _player,\\n        SD59x18[] calldata _oppMus,\\n        SD59x18[] calldata _oppPhis,\\n        SD59x18[] calldata _outcomes,\\n        SD59x18 _tau,\\n        SD59x18 _ratingPeriodsMissed\\n    ) external pure returns (Profile memory _newRating) {\\n        if (_oppMus.length == 0) revert ZeroLength();\\n        if (\\n            _oppMus.length != _outcomes.length ||\\n            _oppMus.length != _oppPhis.length\\n        ) revert LengthMismatch();\\n        // Initiate a glicko instance structure to contain inter-calculation values\\n        GlickoInstance memory _instance;\\n\\n        SD59x18 _adjustedPhi = _adjustPhi(\\n            _player.phi,\\n            _player.volatility,\\n            _ratingPeriodsMissed\\n        );\\n\\n        // Convert rating and rating deviations to glicko scale for player and opponents\\n        _instance.playerMu = _player.mu;\\n        _instance.playerPhiSquared = mul(_adjustedPhi, _adjustedPhi);\\n\\n        _instance.oppPhisSquared = new SD59x18[](_oppMus.length);\\n        _instance.memo.gPhis = new SD59x18[](_oppMus.length);\\n        _instance.memo.Ecalcs = new SD59x18[](_oppMus.length);\\n\\n        // Compute the estimated variance of the player's rating based only on game outcomes\\n        _instance = _calculateV(_instance, _oppMus, _oppPhis);\\n\\n        // Compute the estimated change in rating based only on game outcomes\\n        (_instance.delta, _instance.memo.gSMinusESum) = _calculateDelta(\\n            _instance.v,\\n            _oppMus,\\n            _instance.memo.gPhis,\\n            _instance.memo.Ecalcs,\\n            _outcomes\\n        );\\n\\n        // Compute the updated volatility for the player\\n        _newRating.volatility = _calculateVolatility(\\n            _tau,\\n            _player.volatility,\\n            _instance.delta,\\n            _instance.playerPhiSquared,\\n            _instance.v\\n        );\\n\\n        // Update the rating deviation to the new pre-rating period value\\n        _instance.phiStarSquared = add(\\n            _instance.playerPhiSquared,\\n            mul(_newRating.volatility, _newRating.volatility)\\n        );\\n\\n        // Update the new glicko rating deviation\\n        _instance.phiPrime = inv(\\n            sqrt(add(inv(_instance.phiStarSquared), inv(_instance.v)))\\n        );\\n\\n        // Update the new glicko rating\\n        _instance.muPrime = _calculateMuPrime(\\n            _instance.playerMu,\\n            _instance.phiPrime,\\n            _instance.memo.gSMinusESum\\n        );\\n\\n        _newRating.mu = _instance.muPrime;\\n        _newRating.phi = _instance.phiPrime;\\n    }\\n\\n    /**\\n     * @dev Private helper function to compute estimated variance of player's rating.\\n     * Also memoizes g and E calculations for oppPhis.\\n     */\\n    function _calculateV(\\n        GlickoInstance memory _instance,\\n        SD59x18[] calldata _oppMus,\\n        SD59x18[] calldata _oppPhis\\n    ) private pure returns (GlickoInstance memory) {\\n        SD59x18 gPhi;\\n        SD59x18 currE;\\n\\n        for (uint256 i; i < _oppMus.length; ) {\\n            _instance.oppPhisSquared[i] = mul(_oppPhis[i], _oppPhis[i]);\\n            gPhi = g(_instance.oppPhisSquared[i]);\\n            _instance.memo.gPhis[i] = gPhi;\\n            currE = E(_instance.playerMu, _oppMus[i], gPhi);\\n            _instance.memo.Ecalcs[i] = currE;\\n            _instance.v = add(\\n                _instance.v,\\n                mul(mul(mul(gPhi, gPhi), currE), sub(UNIT, currE))\\n            );\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        _instance.v = inv(_instance.v);\\n        return _instance;\\n    }\\n\\n    /**\\n     * @dev Private helper function that calculates estimated rating change as\\n     * outlined in glicko2 specification.\\n     */\\n    function _calculateDelta(\\n        SD59x18 _v,\\n        SD59x18[] calldata _oppMus,\\n        SD59x18[] memory _gPhis,\\n        SD59x18[] memory _Ecalcs,\\n        SD59x18[] memory _outcomes\\n    ) private pure returns (SD59x18 _delta, SD59x18 _gSMinusESum) {\\n        for (uint256 i; i < _oppMus.length; ) {\\n            _delta = add(_delta, mul(_gPhis[i], sub(_outcomes[i], _Ecalcs[i])));\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        _gSMinusESum = _delta;\\n        _delta = mul(_delta, _v);\\n    }\\n\\n    /**\\n     * @dev Private helper function that calculates updated volatility as outlined\\n     * in glicko2 specification.\\n     */\\n    function _calculateVolatility(\\n        SD59x18 _tau,\\n        SD59x18 _volatility,\\n        SD59x18 _delta,\\n        SD59x18 _playerPhiSquared,\\n        SD59x18 _v\\n    ) private pure returns (SD59x18 _sigmaPrime) {\\n        SD59x18 a = ln(mul(_volatility, _volatility));\\n        SD59x18 _deltaSquared = mul(_delta, _delta);\\n        SD59x18 A = a;\\n        SD59x18 B = _selectB(_tau, _deltaSquared, _playerPhiSquared, _v, a);\\n        SD59x18 C;\\n        SD59x18 fC;\\n        SD59x18 fA = f(_tau, A, _deltaSquared, _playerPhiSquared, _v, a);\\n        SD59x18 fB = f(_tau, B, _deltaSquared, _playerPhiSquared, _v, a);\\n        while (gt(abs(sub(B, A)), EPSILON)) {\\n            C = add(A, div(mul(sub(A, B), fA), sub(fB, fA)));\\n            fC = f(_tau, C, _deltaSquared, _playerPhiSquared, _v, a);\\n            if (!gt(mul(fC, fB), ZERO)) {\\n                A = B;\\n                fA = fB;\\n            } else {\\n                fA = div(fA, TWO);\\n            }\\n            B = C;\\n            fB = fC;\\n        }\\n        _sigmaPrime = exp(div(A, TWO));\\n    }\\n\\n    /**\\n     * @dev Private helper function that calculates new player rating on glicko\\n     * scale.\\n     */\\n    function _calculateMuPrime(\\n        SD59x18 _playerMu,\\n        SD59x18 _phiPrime,\\n        SD59x18 _gSMinusESum\\n    ) private pure returns (SD59x18 _muPrime) {\\n        _muPrime = add(_playerMu, mul(_gSMinusESum, mul(_phiPrime, _phiPrime)));\\n    }\\n\\n    function _adjustPhi(\\n        SD59x18 _phi,\\n        SD59x18 _vol,\\n        SD59x18 _ratingPeriodsMissed\\n    ) public pure returns (SD59x18) {\\n        if (isZero(_ratingPeriodsMissed)) {\\n            return _phi;\\n        }\\n\\n        SD59x18 _phiSquared = mul(_phi, _phi);\\n        SD59x18 _volSquared = mul(_vol, _vol);\\n        return sqrt(add(_phiSquared, mul(_ratingPeriodsMissed, _volSquared)));\\n    }\\n\\n    /**\\n     * @dev Selects starting B value in volatility calculation above.\\n     */\\n    function _selectB(\\n        SD59x18 _tau,\\n        SD59x18 _deltaSquared,\\n        SD59x18 _playerPhiSquared,\\n        SD59x18 _v,\\n        SD59x18 a\\n    ) private pure returns (SD59x18) {\\n        SD59x18 B;\\n        SD59x18 _phiSquaredPlusV = add(_playerPhiSquared, _v);\\n        if (gt(_deltaSquared, _phiSquaredPlusV)) {\\n            B = ln(sub(_deltaSquared, _phiSquaredPlusV));\\n        } else {\\n            SD59x18 k = UNIT;\\n            while (\\n                lt(\\n                    f(\\n                        _tau,\\n                        x(a, k, _tau),\\n                        _deltaSquared,\\n                        _playerPhiSquared,\\n                        _v,\\n                        a\\n                    ),\\n                    ZERO\\n                )\\n            ) {\\n                k = add(k, UNIT);\\n            }\\n            B = x(a, k, _tau);\\n        }\\n        return B;\\n    }\\n\\n    /**\\n     * @dev Calculates `x` input for `f` equation when selecting `B`.\\n     */\\n    function x(\\n        SD59x18 _a,\\n        SD59x18 _k,\\n        SD59x18 _tau\\n    ) private pure returns (SD59x18) {\\n        return sub(_a, mul(_k, _tau));\\n    }\\n\\n    /**\\n     * @dev Implementation of glicko2 `g` equation.\\n     */\\n    function g(SD59x18 _phiSquared) private pure returns (SD59x18) {\\n        return inv(sqrt(add(UNIT, div(mul(THREE, _phiSquared), PI_SQUARED))));\\n    }\\n\\n    /**\\n     * @dev Implementation of glicko2 `E` equation.\\n     */\\n    function E(\\n        SD59x18 _playerMu,\\n        SD59x18 _oppMu,\\n        SD59x18 _gPhi\\n    ) private pure returns (SD59x18) {\\n        return inv(add(UNIT, exp(mul(_gPhi, sub(_oppMu, _playerMu)))));\\n    }\\n\\n    /**\\n     * @dev Calculates win probability based on player rating and rating deviation compared to opponent.\\n     */\\n    function _winProb(\\n        SD59x18 _playerMu,\\n        SD59x18 _playerPhi,\\n        SD59x18 _oppMu,\\n        SD59x18 _oppPhi\\n    ) private pure returns (SD59x18) {\\n        SD59x18 _gPhi = g(\\n            add(mul(_playerPhi, _playerPhi), mul(_oppPhi, _oppPhi))\\n        );\\n        return E(_playerMu, _oppMu, _gPhi);\\n    }\\n\\n    /**\\n     * @dev Implementation of glicko2 `f` equation.\\n     */\\n    function f(\\n        SD59x18 _tau,\\n        SD59x18 _x,\\n        SD59x18 _deltaSquared,\\n        SD59x18 _phiSquared,\\n        SD59x18 _v,\\n        SD59x18 _a\\n    ) private pure returns (SD59x18) {\\n        SD59x18 _exp = exp(_x);\\n        SD59x18 _helper = add(_phiSquared, add(_v, _exp));\\n        return\\n            sub(\\n                div(\\n                    mul(_exp, sub(_deltaSquared, _helper)),\\n                    mul(TWO, mul(_helper, _helper))\\n                ),\\n                div(sub(_x, _a), mul(_tau, _tau))\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Utils/BaseContractRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nabstract contract BaseContractRoles {\\n    bytes32 public constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\n    bytes32 public constant PROTOCOL_ROLE = keccak256(\\\"PROTOCOL_ROLE\\\");\\n    bytes32 public constant CONTROLLER_ROLE = keccak256(\\\"CONTROLLER_ROLE\\\");\\n    bytes32 public constant RELAYER_ROLE = keccak256(\\\"RELAYER_ROLE\\\");\\n    bytes32 public constant CREDIT_MINTER_ROLE =\\n        keccak256(\\\"CREDIT_MINTER_ROLE\\\");\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Utils/BaseDirectoryConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"../Interfaces/IDirectory.sol\\\";\\n\\nabstract contract BaseDirectoryConsumer {\\n    IDirectory public directory;\\n\\n    event ProtocolDirectorySet(address directory);\\n\\n    error MustUpdateAddress();\\n    error ZeroDirectoryAddress();\\n    error OnlyGovernanceCanCall();\\n    error ProtocolPaused();\\n\\n    /**\\n     * @dev Reverts if tx does not originate from governance\\n     */\\n    modifier onlyGov() {\\n        if (\\n            msg.sender != address(directory) &&\\n            msg.sender != directory.governor()\\n        ) revert OnlyGovernanceCanCall();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if protocol is paused\\n     */\\n    modifier protocolActive() {\\n        if (directory.paused()) revert ProtocolPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Config function to store new Protocol Directory.\\n     *\\n     * @dev Callable by anyone.\\n     */\\n    function updateProtocolDirectoryAddress() external {\\n        address _newDirectory = directory.nextProtocolDirectoryVersion();\\n        if (_newDirectory == address(directory)) revert MustUpdateAddress();\\n        if (_newDirectory == address(0)) revert ZeroDirectoryAddress();\\n        directory = IDirectory(_newDirectory);\\n        emit ProtocolDirectorySet(address(_newDirectory));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Utils/ContractRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\nimport \\\"./BaseContractRoles.sol\\\";\\n\\ncontract ContractRoles is BaseContractRoles, AccessControl {\\n    error ZeroAddress();\\n    error NoPermission();\\n\\n    constructor(address _adminWallet) {\\n        if (_adminWallet == address(0)) revert ZeroAddress();\\n        _grantRole(DEFAULT_ADMIN_ROLE, _adminWallet);\\n    }\\n\\n    /**\\n     * @notice Reverts is msg sender does not equal address param and sender has not role param\\n     *\\n     * @param _player the address of the player verify\\n     * @param _role the role to verify\\n     */\\n    modifier onlySelfOrRole(address _player, bytes32 _role) {\\n        if (_player != _msgSender() && !hasRole(_role, _msgSender()))\\n            revert NoPermission();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Utils/ContractRolesUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"./BaseContractRoles.sol\\\";\\n\\ncontract ContractRolesUpgradeable is\\n    BaseContractRoles,\\n    Initializable,\\n    AccessControlUpgradeable\\n{\\n    error ZeroAddress();\\n    error NoPermission();\\n\\n    function __ContractRoles_init(\\n        address _adminWallet\\n    ) internal onlyInitializing {\\n        if (_adminWallet == address(0)) revert ZeroAddress();\\n        _grantRole(DEFAULT_ADMIN_ROLE, _adminWallet);\\n    }\\n\\n    /**\\n     * @notice Reverts is msg sender does not equal address param and sender has not role param\\n     *\\n     * @param _player the address of the player verify\\n     * @param _role the role to verify\\n     */\\n    modifier onlySelfOrRole(address _player, bytes32 _role) {\\n        if (_player != _msgSender() && !hasRole(_role, _msgSender()))\\n            revert NoPermission();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/Utils/DirectoryConsumerUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"../Interfaces/IDirectory.sol\\\";\\nimport \\\"./BaseDirectoryConsumer.sol\\\";\\n\\nimport \\\"erc721a-upgradeable/contracts/ERC721A__Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nabstract contract DirectoryConsumerUpgradeable is\\n    BaseDirectoryConsumer,\\n    ERC721A__Initializable,\\n    Initializable\\n{\\n    function __Directory_Consumer_ERC721A_init(\\n        IDirectory _directory\\n    ) internal onlyInitializingERC721A {\\n        _init(_directory);\\n    }\\n\\n    function __Directory_Consumer_init(\\n        IDirectory _directory\\n    ) internal onlyInitializing {\\n        _init(_directory);\\n    }\\n\\n    function _init(IDirectory _directory) internal {\\n        if (address(_directory) == address(0)) revert ZeroDirectoryAddress();\\n        directory = _directory;\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a-upgradeable/contracts/ERC721A__Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable diamond facet contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\n\\nimport {ERC721A__InitializableStorage} from './ERC721A__InitializableStorage.sol';\\n\\nabstract contract ERC721A__Initializable {\\n    using ERC721A__InitializableStorage for ERC721A__InitializableStorage.Layout;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializerERC721A() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(\\n            ERC721A__InitializableStorage.layout()._initializing\\n                ? _isConstructor()\\n                : !ERC721A__InitializableStorage.layout()._initialized,\\n            'ERC721A__Initializable: contract is already initialized'\\n        );\\n\\n        bool isTopLevelCall = !ERC721A__InitializableStorage.layout()._initializing;\\n        if (isTopLevelCall) {\\n            ERC721A__InitializableStorage.layout()._initializing = true;\\n            ERC721A__InitializableStorage.layout()._initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            ERC721A__InitializableStorage.layout()._initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializingERC721A() {\\n        require(\\n            ERC721A__InitializableStorage.layout()._initializing,\\n            'ERC721A__Initializable: contract is not initializing'\\n        );\\n        _;\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        address self = address(this);\\n        uint256 cs;\\n        assembly {\\n            cs := extcodesize(self)\\n        }\\n        return cs == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a-upgradeable/contracts/ERC721A__InitializableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base storage for the  initialization function for upgradeable diamond facet contracts\\n **/\\n\\nlibrary ERC721A__InitializableStorage {\\n    struct Layout {\\n        /*\\n         * Indicates that the contract has been initialized.\\n         */\\n        bool _initialized;\\n        /*\\n         * Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256('ERC721A.contracts.storage.initializable.facet');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryable is IERC721A {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"flexible-voting/src/interfaces/IFractionalGovernor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.10;\\n\\n/// @dev The interface that flexible voting-compatible governors are expected to support.\\ninterface IFractionalGovernor {\\n  function token() external returns (address);\\n  function proposalSnapshot(uint256 proposalId) external view returns (uint256);\\n  function proposalDeadline(uint256 proposalId) external view returns (uint256);\\n  function castVoteWithReasonAndParams(\\n    uint256 proposalId,\\n    uint8 support,\\n    string calldata reason,\\n    bytes memory params\\n  ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"flexible-voting/src/interfaces/IVotingToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.10;\\n\\n/// @dev The interface that flexible voting-compatible voting tokens are expected to support.\\ninterface IVotingToken {\\n  function transfer(address to, uint256 amount) external returns (bool);\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n  function delegate(address delegatee) external;\\n  function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_endpoint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_l2ChainId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Blocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientPayment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoPermission\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bundleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mintTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"BundlePurchaseInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ETHWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_dstGasAmount\",\"type\":\"uint256\"}],\"name\":\"SetMinDstGas\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"precrime\",\"type\":\"address\"}],\"name\":\"SetPrecrime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"SetTrustedRemote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_remoteChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_remoteAddress\",\"type\":\"bytes\"}],\"name\":\"SetTrustedRemoteAddress\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONTROLLER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CREDIT_MINTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_PAYLOAD_SIZE_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L2_CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROTOCOL_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RELAYER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_bundleId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasForDestinationLzReceive\",\"type\":\"uint256\"}],\"name\":\"estimateFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"messageFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"forceResumeReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_remoteChainId\",\"type\":\"uint16\"}],\"name\":\"getTrustedRemoteAddress\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"isTrustedRemote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lzEndpoint\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"minDstGasLookup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"payloadSizeLimitLookup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"precrime\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_bundleId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasForDestinationLzReceive\",\"type\":\"uint256\"}],\"name\":\"purchaseCreditBundle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_config\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lzEndpoint\",\"type\":\"address\"}],\"name\":\"setLzEndpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_packetType\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_minGas\",\"type\":\"uint256\"}],\"name\":\"setMinDstGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"}],\"name\":\"setPayloadSizeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_precrime\",\"type\":\"address\"}],\"name\":\"setPrecrime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"setReceiveVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"setSendVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"setTrustedRemote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_remoteChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_remoteAddress\",\"type\":\"bytes\"}],\"name\":\"setTrustedRemoteAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"trustedRemoteLookup\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "L1Payments", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "00000000000000000000000066a71dcef29a0ffbdbe3c6a460a3b5bc225cd6750000000000000000000000009980fedf494f722887dd5d7eaee55efe354789c600000000000000000000000000000000000000000000000000000000000000af", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}