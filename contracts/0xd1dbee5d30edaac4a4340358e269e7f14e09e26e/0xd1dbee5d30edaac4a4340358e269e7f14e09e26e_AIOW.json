{"SourceCode": "// Sources flattened with hardhat v2.6.0 https://hardhat.org\r\n\r\n// File contracts/helpers/Ownable.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File contracts/token/AIOW.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.7;\r\n\r\ncontract AIOW is Ownable {\r\n    \r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint256 public totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    \r\n    uint256 constant PERC_BASE = 10000; // = 100.00 %\r\n    uint256 public constant SECONDS_IN_ONE_DAY = 86400;\r\n\r\n    mapping(address => TransferRuleOutbound) public transferRulesOutbound;\r\n    mapping(address => TransferRuleInbound[]) public transferRulesInbound;\r\n    enum TransferRuleType { inbound, outbound }\r\n    uint256 private ruleIdCounter;\r\n    \r\n    struct TransferRuleOutbound {\r\n        uint8 id;\r\n        uint32 timelockUntil;        \r\n        uint16 vestingDurationDays;\r\n        uint16 vestingStartsAfterDays;\r\n        uint16 percUnlockedAtTimeUnlock;\r\n    }\r\n    \r\n    struct TransferRuleInbound {\r\n        uint8 id;\r\n        uint32 timelockUntil;\r\n        uint16 vestingDurationDays;\r\n        uint16 vestingStartsAfterDays;\r\n        uint16 percUnlockedAtTimeUnlock;\r\n        uint96 tokens;\r\n        bool isPool;\r\n    }\r\n    \r\n    event TransferRuleInboundRegistered(address addr, TransferRuleInbound rule);  \r\n    event TransferRuleOutboundRegistered(address addr, TransferRuleOutbound rule);  \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    \r\n    constructor(uint256 totalSupply_) {\r\n        name = \"AIOW\";\r\n        symbol = \"AIOW\";\r\n        decimals = 18;\r\n        \r\n        // mint the total supply to the deployer\r\n        totalSupply += totalSupply_;\r\n        _balances[msg.sender] += totalSupply_;\r\n        emit Transfer(address(0), msg.sender, totalSupply_);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from_, address to_, uint256 amount_) internal virtual {\r\n        // apply all the rules to verify the transferred amount is not above the total amount of unlocked tokens\r\n        require(amount_ <= calcBalanceUnlocked(from_), \"insufficient unlocked tokens\");\r\n        \r\n        // if the recipient is a pool, transfer the tokens to the inbound rule of the pool\r\n        if (transferRulesInbound[to_].length >= 1 && transferRulesInbound[to_][0].isPool) {\r\n            transferRulesInbound[to_][0].tokens += uint96(amount_);\r\n            return;\r\n        }\r\n        \r\n        // if there is an outbound rule we need to apply the outbound rule\r\n        if (transferRulesOutbound[from_].id != 0) {\r\n        \r\n            TransferRuleOutbound memory trFromOutbound = transferRulesOutbound[from_];\r\n                        \r\n            bool foundMatchingToRule = false;\r\n            \r\n            // check if this outbound rule already exists inside the inbound rules of the recipient\r\n            for (uint256 i = 0; i < transferRulesInbound[to_].length; i++) {\r\n                if (trFromOutbound.id == transferRulesInbound[to_][i].id) {\r\n                    // if so increment the balance inside that rule\r\n                    foundMatchingToRule = true;\r\n                    transferRulesInbound[to_][i].tokens += uint96(amount_);\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            // if we didnt find a matching rule, create it for the recipient\r\n            if (!foundMatchingToRule) {\r\n                transferRulesInbound[to_].push(TransferRuleInbound({\r\n                    id: trFromOutbound.id,\r\n                    timelockUntil: trFromOutbound.timelockUntil,\r\n                    vestingStartsAfterDays: trFromOutbound.vestingStartsAfterDays,\r\n                    vestingDurationDays: trFromOutbound.vestingDurationDays,\r\n                    percUnlockedAtTimeUnlock: trFromOutbound.percUnlockedAtTimeUnlock,\r\n                    tokens: uint96(amount_),\r\n                    isPool: false\r\n                })); \r\n            }  \r\n        }\r\n    }\r\n\r\n    function calcBalanceUnlocked(address account_) public view returns (uint) {\r\n        return _balances[account_] - calcBalanceLocked(account_);\r\n    }\r\n    \r\n    function calcBalanceLockedOfInboundRule(TransferRuleInbound memory trInbound) internal view returns (uint) {\r\n        if (trInbound.timelockUntil > uint32(block.timestamp)) {\r\n            // the tokens of this rule are still all locked\r\n            return trInbound.tokens;\r\n        }\r\n        \r\n        if (trInbound.percUnlockedAtTimeUnlock > 0) {\r\n            // deduct the immediately unlocked amount of tokens from the rule's amount of locked tokens\r\n            trInbound.tokens -= uint96(trInbound.tokens * trInbound.percUnlockedAtTimeUnlock / PERC_BASE);\r\n        }\r\n        \r\n        if (trInbound.vestingDurationDays > 0) {\r\n            uint256 daysPassedSinceUnlock = (uint32(block.timestamp) - trInbound.timelockUntil) / SECONDS_IN_ONE_DAY;\r\n            if (daysPassedSinceUnlock <= trInbound.vestingStartsAfterDays) {\r\n                // vesting didnt yet start\r\n                return trInbound.tokens;\r\n            }\r\n            \r\n            uint256 daysPassedSinceVestingStart = daysPassedSinceUnlock - trInbound.vestingStartsAfterDays;\r\n            \r\n            if (daysPassedSinceVestingStart >= trInbound.vestingDurationDays) {\r\n                // the entire vesting period has ended, so all tokens of this rule are unlocked\r\n                // this also ensures the last day's tokens pays out all the remaining tokens\r\n                // since due to integer floor division the per day amount might be slightly less than the\r\n                // total amount\r\n                return 0;\r\n            }\r\n            \r\n            // calculate how many of the tokens are still locked\r\n            uint256 amountUnlockedPerDay = trInbound.tokens / trInbound.vestingDurationDays;\r\n            uint256 totalUnlocked = daysPassedSinceVestingStart * amountUnlockedPerDay;\r\n            return trInbound.tokens - totalUnlocked;\r\n        } \r\n        \r\n        // this can only mean there is no vesting, and the timelock already passed, so all tokens are unlocked\r\n        return 0;\r\n    }\r\n    \r\n    function calcBalanceLocked(address account_) public view returns (uint) {\r\n        uint256 lockedTokens = 0;\r\n        \r\n        // check the amount of locked tokens for each of the inbound rules on this account\r\n        for (uint256 i = 0; i < transferRulesInbound[account_].length; i++) {\r\n            TransferRuleInbound memory trFromInbound = transferRulesInbound[account_][i];\r\n            lockedTokens += calcBalanceLockedOfInboundRule(trFromInbound);\r\n        }\r\n\r\n        return lockedTokens;\r\n    }\r\n    \r\n    function registerTransferRule(\r\n        address account_, \r\n        TransferRuleType ruleType, \r\n        uint32 timelockUntil_, \r\n        uint16 vestingStartsAfterDays_,\r\n        uint16 vestingDurationDays_, \r\n        uint16 percUnlockedAtTimeUnlock_, \r\n        bool isPool_\r\n    ) public onlyOwner {\r\n        require(account_ != address(0), 'account is address zero');\r\n        require(timelockUntil_ > uint32(block.timestamp), 'timelockUntil already passed');\r\n        require(percUnlockedAtTimeUnlock_ > 0 || vestingDurationDays_ > 0, 'percUnlockedAtTimeUnlock and vestingDurationDays are zero');\r\n        require(percUnlockedAtTimeUnlock_ <= uint16(PERC_BASE), 'percUnlockedAtTimeUnlock above 100%');\r\n        \r\n        if (ruleType == TransferRuleType.outbound) {\r\n            require(transferRulesOutbound[account_].id == 0, 'account already has outbound rule');\r\n            \r\n            transferRulesOutbound[account_] = TransferRuleOutbound({\r\n                id: uint8(++ruleIdCounter), // first rule will get id 1\r\n                timelockUntil: timelockUntil_,\r\n                vestingDurationDays: vestingDurationDays_,\r\n                vestingStartsAfterDays: vestingStartsAfterDays_,\r\n                percUnlockedAtTimeUnlock: percUnlockedAtTimeUnlock_\r\n            });\r\n\r\n            emit TransferRuleOutboundRegistered(account_, transferRulesOutbound[account_]);\r\n        }\r\n        else { // ruleType == TransferRuleType.inbound\r\n            transferRulesInbound[account_].push(TransferRuleInbound({\r\n                id: uint8(++ruleIdCounter), // first rule will get id 1\r\n                timelockUntil: timelockUntil_,\r\n                vestingDurationDays: vestingDurationDays_,\r\n                vestingStartsAfterDays: vestingStartsAfterDays_,                \r\n                percUnlockedAtTimeUnlock: percUnlockedAtTimeUnlock_,\r\n                tokens: 0,\r\n                isPool: isPool_\r\n            }));\r\n\r\n            emit TransferRuleInboundRegistered(account_, transferRulesInbound[account_][transferRulesInbound[account_].length - 1]);\r\n        }\r\n    }\r\n        \r\n    function balanceOf(address account_) public view returns (uint256) {\r\n        return _balances[account_];\r\n    }\r\n    \r\n    function allowance(address owner_, address spender_) public view returns (uint256) {\r\n        return _allowances[owner_][spender_];\r\n    }\r\n    \r\n    function transfer(address recipient_, uint256 amount_) public returns (bool) {\r\n        _transfer(msg.sender, recipient_, amount_);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address sender_, address recipient_, uint256 amount_) public returns (bool) {\r\n        _transfer(sender_, recipient_, amount_);\r\n        uint256 currentAllowance = _allowances[sender_][msg.sender];\r\n        require(currentAllowance >= amount_, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender_, msg.sender, currentAllowance - amount_);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender_, address recipient_, uint256 amount_) internal {\r\n        require(sender_ != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient_ != address(0), \"ERC20: transfer to the zero address\");\r\n        _beforeTokenTransfer(sender_, recipient_, amount_);\r\n        uint256 senderBalance = _balances[sender_];\r\n        require(senderBalance >= amount_, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender_] = senderBalance - amount_;\r\n        _balances[recipient_] += amount_;\r\n        emit Transfer(sender_, recipient_, amount_);\r\n    }\r\n    \r\n    function approve(address spender_, uint256 amount_) public returns (bool) {\r\n        _approve(msg.sender, spender_, amount_);\r\n        return true;\r\n    }\r\n    \r\n    function increaseAllowance(address spender_, uint256 addedValue_) public returns (bool) {\r\n        _approve(msg.sender, spender_, _allowances[msg.sender][spender_] + addedValue_);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender_, uint256 subtractedValue_) public returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender_];\r\n        require(currentAllowance >= subtractedValue_, \"ERC20: decreased allowance below zero\");\r\n        _approve(msg.sender, spender_, currentAllowance - subtractedValue_);\r\n        return true;\r\n    }\r\n    \r\n    function _approve(address owner_, address spender_, uint256 amount_) internal {\r\n        require(owner_ != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender_ != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner_][spender_] = amount_;\r\n        emit Approval(owner_, spender_, amount_);\r\n    }\r\n    \r\n    function balanceStatsOf(address account_) public view returns (\r\n        uint256 balanceTotal, \r\n        uint256 balanceLocked, \r\n        uint256 balanceUnlocked\r\n    ) {\r\n        return (\r\n            _balances[account_],\r\n            calcBalanceLocked(account_),\r\n            calcBalanceUnlocked(account_)\r\n        );\r\n    }\r\n    \r\n    // gives incorrect results if percUnlockedAtUnlock > 0, i.e. do not use if percUnlockedAtUnlock > 0\r\n    function inboundRuleStatsOf(address account_, uint256 ruleId_) public view returns (\r\n        uint256 ruleBalanceTotal,\r\n        uint256 ruleBalanceLocked,\r\n        uint256 ruleBalanceUnlocked\r\n    ) {\r\n        for (uint256 i = 0; i < transferRulesInbound[account_].length; i++) {\r\n            if (transferRulesInbound[account_][i].id == ruleId_) {\r\n                TransferRuleInbound memory trFromInbound = transferRulesInbound[account_][i];\r\n                uint lockedTokens = calcBalanceLockedOfInboundRule(trFromInbound);\r\n                uint unlockedTokens = trFromInbound.tokens - lockedTokens;\r\n                return (trFromInbound.tokens, lockedTokens, unlockedTokens);\r\n            }\r\n        }\r\n        revert('didnt find matching rule');\r\n    }\r\n    \r\n    function getInboundTransferRules(address _a) external view returns (TransferRuleInbound[] memory) {\r\n        return transferRulesInbound[_a];\r\n    }    \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"timelockUntil\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"vestingDurationDays\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"vestingStartsAfterDays\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percUnlockedAtTimeUnlock\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"tokens\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"isPool\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct AIOW.TransferRuleInbound\",\"name\":\"rule\",\"type\":\"tuple\"}],\"name\":\"TransferRuleInboundRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"timelockUntil\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"vestingDurationDays\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"vestingStartsAfterDays\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percUnlockedAtTimeUnlock\",\"type\":\"uint16\"}],\"indexed\":false,\"internalType\":\"struct AIOW.TransferRuleOutbound\",\"name\":\"rule\",\"type\":\"tuple\"}],\"name\":\"TransferRuleOutboundRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SECONDS_IN_ONE_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender_\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"balanceStatsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balanceTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceUnlocked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"calcBalanceLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"calcBalanceUnlocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue_\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"getInboundTransferRules\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"timelockUntil\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"vestingDurationDays\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"vestingStartsAfterDays\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percUnlockedAtTimeUnlock\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"tokens\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"isPool\",\"type\":\"bool\"}],\"internalType\":\"struct AIOW.TransferRuleInbound[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ruleId_\",\"type\":\"uint256\"}],\"name\":\"inboundRuleStatsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ruleBalanceTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ruleBalanceLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ruleBalanceUnlocked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue_\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"enum AIOW.TransferRuleType\",\"name\":\"ruleType\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"timelockUntil_\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"vestingStartsAfterDays_\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"vestingDurationDays_\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percUnlockedAtTimeUnlock_\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isPool_\",\"type\":\"bool\"}],\"name\":\"registerTransferRule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferRulesInbound\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"timelockUntil\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"vestingDurationDays\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"vestingStartsAfterDays\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percUnlockedAtTimeUnlock\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"tokens\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"isPool\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferRulesOutbound\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"timelockUntil\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"vestingDurationDays\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"vestingStartsAfterDays\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percUnlockedAtTimeUnlock\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AIOW", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000000000000000000000019d971e4fe8401e74000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ff17f2975cab8cfa42cd30bdae6633ee9d9134cf301bd6a1088cbbfde6b62a7d"}