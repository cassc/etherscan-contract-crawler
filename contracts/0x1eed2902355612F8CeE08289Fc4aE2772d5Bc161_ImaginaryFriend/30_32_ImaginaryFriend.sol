// SPDX-License-Identifier: UNLICENSED
// Copyright (c) 2022 divergence.xyz
pragma solidity >=0.8.0 <0.9.0;

import "@divergencetech/ethier/contracts/erc721/ERC721ACommon.sol";
import "@divergencetech/ethier/contracts/erc721/BaseTokenURI.sol";
import "@divergencetech/ethier/contracts/crypto/SignatureChecker.sol";
import "@divergencetech/ethier/contracts/sales/FixedPriceSeller.sol";
import "@openzeppelin/contracts/token/common/ERC2981.sol";

import "./Common.sol";
import "./Serializer.sol";
import "./IMetadataRenderer.sol";

contract ImaginaryFriend is
    ERC721ACommon,
    FixedPriceSeller,
    BaseTokenURI,
    ERC2981
{
    using EnumerableSet for EnumerableSet.AddressSet;
    using SignatureChecker for EnumerableSet.AddressSet;
    using Deserializer for FeaturesSerialized;
    using Serializer for Features;

    uint256 private constant MAX_NUM_TOKENS = 3000;

    /// @notice Set of addresses that are approved to issue early access.
    /// allowances.
    EnumerableSet.AddressSet private _signersEarlyAccess;

    /// @notice Set of addresses that are approved to issue quiz allowances.
    EnumerableSet.AddressSet private _signersQuiz;

    /// @notice Stores the number of tokens minted from am allowance during the
    /// early access stage.
    /// @dev Used in `mintEarlyAccess`
    mapping(bytes32 => uint256) public numMintedFrom;

    /// @notice Contains quiz results for the tokens.
    /// @dev Null corresponds to the quiz not being answered.
    /// @dev Storing a serialized version of the data was needed to enable a
    /// more efficient handling in memory.
    mapping(uint256 => FeaturesSerialized) private _tokenFeatures;

    /// @notice The metadata renderer
    IMetadataRenderer public renderer;

    /// @notice Flag to disable use of setRenderer().
    bool private rendererLocked;

    /// @notice The different minting states of the collection.
    /// @dev This is used to enable/disable the respective minting methods.
    /// Closed = no minting
    /// EarlyAccess = mint using signatures, see `mintEarlyAccess`
    /// Public = public minting, see `mintPublic`
    enum MintingStage {
        Closed,
        EarlyAccess1,
        EarlyAccess2,
        EarlyAccess3,
        EarlyAccess4,
        Public
    }

    /// @notice The current minting stage of the contract.
    MintingStage public mintingStage;

    /// @notice The different states of the quiz.
    /// @dev This is used to control the behavior of `setQuizAnswers`,
    /// `_tokenFeatures` and `tokenURI`.
    /// Closed = quiz answers cannot be set in the contract. All tokenURIs
    /// point to the fallback URL.
    /// Open = quiz answers can be stored using `setQuizAnswers`. The
    /// corresponding token metadata and image URI will be returned.
    /// Finished = quiz answers can no longer be stored. Token metadata, etc.
    /// of the unanswered tokens will be autogenerated.
    enum QuizStage {
        Closed,
        Open,
        Finished
    }

    /// @notice The current state of the quiz.
    QuizStage public quizStage;

    constructor(
        address signerEarlyAccess,
        address signerQuiz,
        address payable paymentSplitter,
        address payable royaltyReceiver,
        string memory baseURI
    )
        ERC721ACommon("My Imaginary Friend by Kai", "KAIIF")
        FixedPriceSeller(
            0.5 ether,
            Seller.SellerConfig({
                totalInventory: MAX_NUM_TOKENS,
                maxPerAddress: 1,
                maxPerTx: 1,
                freeQuota: 300,
                reserveFreeQuota: true,
                lockFreeQuota: false,
                lockTotalInventory: true
            }),
            paymentSplitter
        )
        BaseTokenURI(baseURI)
    {
        _signersEarlyAccess.add(signerEarlyAccess);
        _signersQuiz.add(signerQuiz);

        _setDefaultRoyalty(royaltyReceiver, _feeDenominator() / 10); // 10 %
    }

    // -------------------------------------------------------------------------
    //
    //  Minting
    //
    // -------------------------------------------------------------------------

    /// @notice Minting interface for wallets on the early-access lists.
    /// @dev Only active during early-access `mintingStage`.
    /// @dev The minter might be different than the receiver.
    /// @param to Token receiver
    /// @param num Number of tokens to be minted.
    /// @param numMax Max number of tokens that can be minted to the receiver.
    /// @param nonce additional signature salt.
    /// @param signature to prove that the receiver is allowed to get mints.
    /// @dev The signed messages is generated by concatenating
    /// `address(this) || stage || to || numMax || nonce`.
    function mintEarlyAccess(
        MintingStage stage,
        address to,
        uint16 num,
        uint16 numMax,
        uint128 nonce,
        bytes calldata signature
    )
        external
        payable
        onlyBetweenMintingStages(MintingStage.EarlyAccess1, MintingStage.Public)
        bypassSellerLimits
    {
        if (mintingStage < stage) revert WrongStage();
        bytes32 message = SignatureChecker.generateMessage(
            abi.encodePacked(address(this), stage, to, numMax, nonce)
        );

        if (num + numMintedFrom[message] > numMax)
            revert TooManyMintsRequested();

        _signersEarlyAccess.requireValidSignature(message, signature);
        numMintedFrom[message] += num;

        _purchase(to, num);
    }

    /// @notice Public minting interface.
    /// @dev Only active during public `mintingStage`.
    /// @param num Number of tokens to be minted.
    function mintPublic(uint16 num)
        external
        payable
        onlyDuringMintingStage(MintingStage.Public)
    {
        _purchase(msg.sender, num);
    }

    /// @notice Mints tokens with the given sets of features.
    /// @dev Can only be called by the owner. Draws from the pool of free mints.
    /// @param to The token receiver.
    /// @param features Array of features that the minted tokens should have.
    function mintWithFeatures(address to, Features[] calldata features)
        external
        onlyOwner
    {
        uint256 num = features.length;
        uint256 nextId = totalSupply();
        purchaseFreeOfCharge(to, num);
        for (uint256 idx = 0; idx < num; ++idx) {
            _setFeatures(nextId, features[idx]);
            ++nextId;
        }
    }

    /// @notice Callback to handle purchasing logic.
    /// @dev The `freeOfCharge` boolean flag is deliberately ignored.
    function _handlePurchase(
        address to,
        uint256 num,
        bool
    ) internal override {
        _safeMint(to, num);
    }

    // -------------------------------------------------------------------------
    //
    //  Quiz
    //
    // -------------------------------------------------------------------------

    /// @notice Stores the `feature`s for a given token that resulted from the
    /// quiz.
    /// @dev Only active during open `quizState`.
    /// @dev The golden propperty of the `features` argument is ignored.
    /// @dev Can only be called once per token by either the token owner or
    /// approved wallets.
    /// @param tokenId The tokenId for which the results will be stored.
    /// @param features The quiz results to be stored.
    /// @param signature To prove that the caller is allowed to set the given
    /// features.
    function setQuizResults(
        uint256 tokenId,
        Features calldata features,
        bytes calldata signature
    ) external onlyWhileQuizOpen onlyApprovedOrOwner(tokenId) {
        if (_tokenFeatures[tokenId].isSet()) revert QuizResultsAlreadySet();

        bytes32 message = SignatureChecker.generateMessage(
            abi.encodePacked(
                address(this),
                tokenId,
                features.background,
                features.body,
                features.mouth,
                features.eyes,
                features.special
            )
        );
        _signersQuiz.requireValidSignature(message, signature);
        _setFeatures(tokenId, features);
    }

    /// @notice Checks if the quiz has already been answered for a given token.
    /// @dev Reverts if the token doesn't exist.
    /// @param tokenId The token of interest.
    function hasQuizResults(uint256 tokenId)
        external
        view
        tokenExists(tokenId)
        returns (bool)
    {
        return _tokenFeatures[tokenId].isSet();
    }

    /// @notice Sets the features for a given token.
    /// @dev Ensures that only the genesis token is golden.
    function _setFeatures(uint256 tokenId, Features memory features) internal {
        features.golden = (tokenId == 0);
        _validateFeatures(features);
        _tokenFeatures[tokenId] = features.serialize();
    }

    /// @notice Checks if token features are valid.
    /// @dev Reverts on invalid features.
    function _validateFeatures(Features memory results) internal pure {
        if (
            results.background > 0 &&
            results.body > 0 &&
            results.mouth > 0 &&
            results.eyes > 0 &&
            results.background <= NUM_BACKGROUNDS &&
            results.body <= NUM_BODIES &&
            results.mouth <= NUM_MOUTHS &&
            results.eyes <= NUM_EYES &&
            results.special <= Special.Both
        ) return;

        revert InvalidTokenFeatures();
    }

    // -------------------------------------------------------------------------
    //
    //  Signature validataion
    //
    // -------------------------------------------------------------------------

    /// @notice Removes and adds addresses to the set of allowed signers for
    /// early access mint allowances.
    /// @dev Removal is performed before addition.
    function changeSignersEarlyAccess(
        address[] calldata delSigners,
        address[] calldata addSigners
    ) external onlyOwner {
        _changeSigners(_signersEarlyAccess, delSigners, addSigners);
    }

    /// @notice Returns the signer addresses that are approved to issue
    /// allowances for the early-access minting.
    function getSignersEarlyAccess() external view returns (address[] memory) {
        return _getSigners(_signersEarlyAccess);
    }

    /// @notice Removes and adds addresses to the set of allowed signers for
    /// quiz results.
    /// @dev Removal is performed before addition.
    function changeSignersQuiz(
        address[] calldata delSigners,
        address[] calldata addSigners
    ) external onlyOwner {
        _changeSigners(_signersQuiz, delSigners, addSigners);
    }

    /// @notice Returns the signer addresses that are approved to issue
    /// allowances for the early-access minting.
    function getSignersQuiz() external view returns (address[] memory) {
        return _getSigners(_signersQuiz);
    }

    /// @notice Removes and adds addresses to the set of allowed signers.
    /// @dev Removal is performed before addition.
    function _changeSigners(
        EnumerableSet.AddressSet storage signers,
        address[] calldata delSigners,
        address[] calldata addSigners
    ) internal {
        for (uint256 idx; idx < delSigners.length; ++idx) {
            signers.remove(delSigners[idx]);
        }
        for (uint256 idx; idx < addSigners.length; ++idx) {
            signers.add(addSigners[idx]);
        }
    }

    /// @notice Returns the signer addresses in a given set.
    function _getSigners(EnumerableSet.AddressSet storage signers)
        internal
        view
        returns (address[] memory)
    {
        uint256 len = signers.length();
        address[] memory signers_ = new address[](len);
        for (uint256 idx = 0; idx < len; ++idx) {
            signers_[idx] = signers.at(idx);
        }
        return signers_;
    }

    // -------------------------------------------------------------------------
    //
    //  Metadata
    //
    // -------------------------------------------------------------------------

    /// @notice Sets the address of the rendering contract.
    function setRenderer(IMetadataRenderer renderer_) public onlyOwner {
        if (rendererLocked) revert RendererLocked();
        renderer = renderer_;
    }

    /// @notice Permanently disables `setRenderer`
    function lockRenderer() external onlyOwner {
        rendererLocked = true;
    }

    /// @notice Retrieves the features of an existing token.
    /// @param tokenId The token of interest.
    /// @dev Forwards the call to the metadata render.
    function tokenFeatures(uint256 tokenId)
        external
        view
        tokenExists(tokenId)
        returns (Features memory)
    {
        FeaturesSerialized data = _tokenFeatures[tokenId];
        FeaturesSerialized[] memory all = _loadAllTokenFeatures();
        bool autogenerate = (quizStage == QuizStage.Finished);

        (Features memory features, ) = renderer.tokenFeatures(
            tokenId,
            data,
            all,
            autogenerate
        );

        return features;
    }

    /// @notice Retrieves the data-uri encoded metadata json for an existing
    /// token.
    /// @param tokenId The token of interest.
    /// @dev Forwards the call to the metadata render.
    function tokenURI(uint256 tokenId)
        public
        view
        override
        tokenExists(tokenId)
        returns (string memory)
    {
        FeaturesSerialized data = _tokenFeatures[tokenId];
        FeaturesSerialized[] memory all = _loadAllTokenFeatures();
        bool autogenerate = (quizStage == QuizStage.Finished);

        return
            renderer.tokenURI(
                tokenId,
                data,
                _baseURI(),
                all,
                autogenerate,
                countSiblings
            );
    }

    /// @notice Loads all token features to memory.
    /// @dev This also loads data for unminted tokens (which will be zeroes).
    /// This ensures that the entropy derived therefrom can only be affected by
    /// actual quiz answers. Hence, allowing tokens to be safely minted even
    /// after the quiz was already finished without affecting the
    /// randomized autogeneration.
    function _loadAllTokenFeatures()
        private
        view
        returns (FeaturesSerialized[] memory)
    {
        FeaturesSerialized[] memory all = new FeaturesSerialized[](
            MAX_NUM_TOKENS
        );
        for (uint256 idx = 0; idx < MAX_NUM_TOKENS; idx++) {
            all[idx] = _tokenFeatures[idx];
        }
        return all;
    }

    // -------------------------------------------------------------------------
    //
    //  Royalties
    //
    // -------------------------------------------------------------------------

    /// @notice Sets the royalty receiver and percentage (in units of 0.01%).
    function setDefaultRoyalty(address receiver, uint96 feeNumerator)
        external
        onlyOwner
    {
        _setDefaultRoyalty(receiver, feeNumerator);
    }

    // -------------------------------------------------------------------------
    //
    //  Internals
    //
    // -------------------------------------------------------------------------

    /// @notice Sets the contract to a given minting stage.
    /// @dev Imposes minting limits when switching to public minting.
    function setMintingStage(MintingStage stage) external onlyOwner {
        mintingStage = stage;
    }

    /// @notice Sets the progress of the quiz to a given state.
    function setQuizStage(QuizStage stage) external onlyOwner {
        quizStage = stage;
    }

    /// @notice Sets limitations for minting.
    /// @dev This is a convenience interface for `setSellerConfig`.
    /// It is intended to eventuallty relax minting limits for the public
    /// minting stage.
    function setMintingLimits(uint256 maxPerAddress, uint256 maxPerTx)
        external
        onlyOwner
    {
        sellerConfig.maxPerAddress = maxPerAddress;
        sellerConfig.maxPerTx = maxPerTx;
    }

    /// @notice Determines if siblings are counted.
    bool private countSiblings;

    /// @notice Toggles `countSiblings`
    function setCountSiblings(bool toggle) external onlyOwner {
        countSiblings = toggle;
    }

    /// @notice Ensures that a method can only be called during a certain
    /// minting stage.
    modifier onlyDuringMintingStage(MintingStage stage) {
        if (mintingStage != stage) revert WrongStage();
        _;
    }

    /// @notice Ensures that a method can only be called between certain
    /// minting stages.
    modifier onlyBetweenMintingStages(MintingStage from, MintingStage to) {
        if (mintingStage < from || to < mintingStage) revert WrongStage();
        _;
    }

    /// @notice Ensures that a method can only be called while the quiz is open.
    modifier onlyWhileQuizOpen() {
        if (quizStage != QuizStage.Open) revert WrongStage();
        _;
    }

    /// @notice Bypasses ethiers Seller limits for a given method.
    modifier bypassSellerLimits() {
        SellerConfig memory savedConfig = sellerConfig;
        sellerConfig.maxPerTx = 0;
        sellerConfig.maxPerAddress = 0;
        _;
        sellerConfig.maxPerTx = savedConfig.maxPerTx;
        sellerConfig.maxPerAddress = savedConfig.maxPerAddress;
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721ACommon, ERC2981)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function _baseURI()
        internal
        view
        override(ERC721A, BaseTokenURI)
        returns (string memory)
    {
        return BaseTokenURI._baseURI();
    }

    // -------------------------------------------------------------------------
    //
    //  Errors
    //
    // -------------------------------------------------------------------------

    error TooManyMintsRequested();
    error RendererLocked();
    error WrongStage();
    error InvalidTokenFeatures();
    error TokenNotYetRevealed();
    error QuizResultsAlreadySet();
}