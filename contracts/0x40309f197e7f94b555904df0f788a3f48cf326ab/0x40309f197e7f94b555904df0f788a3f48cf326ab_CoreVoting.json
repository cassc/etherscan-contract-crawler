{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/council/CoreVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\nimport \\\"./interfaces/IVotingVault.sol\\\";\\nimport \\\"./libraries/Authorizable.sol\\\";\\nimport \\\"./libraries/ReentrancyBlock.sol\\\";\\nimport \\\"./interfaces/ICoreVoting.sol\\\";\\n\\ncontract CoreVoting is Authorizable, ReentrancyBlock, ICoreVoting {\\n    // if a function selector does not have a set quorum we use this default quorum\\n    uint256 public baseQuorum;\\n\\n    // Assumes avg block time of 13.3 seconds. May be longer or shorter due\\n    // to ice ages or short term changes in hash power.\\n    uint256 public constant DAY_IN_BLOCKS = 6496;\\n\\n    // minimum time a proposal must be active for before executing\\n    // Default to 3 days, this avoids weekend surprise proposals\\n    uint256 public lockDuration = DAY_IN_BLOCKS * 3;\\n\\n    // The number of blocks after the proposal is unlocked during which\\n    // voting can continue. Max vote time = lockDuration + extraVoteTime\\n    // Default to ~5 days of blocks, ie 8 days max vote time\\n    uint256 public extraVoteTime = DAY_IN_BLOCKS * 5;\\n\\n    // minimum amount of voting power required to submit a proposal\\n    uint256 public minProposalPower;\\n\\n    // number of proposals created\\n    uint256 public proposalCount;\\n\\n    // mapping of address and selector to quorum\\n    mapping(address => mapping(bytes4 => uint256)) private _quorums;\\n\\n    /// @notice Override of the getter for the 'quorums' mapping which returns the default\\n    ///         quorum when the quorum is not set.\\n    /// @param target the contract for which the quorum is set\\n    /// @param functionSelector the function which is callable\\n    /// @return The quorum needed to pass the function at this point in time\\n    function quorums(address target, bytes4 functionSelector)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 storedQuorum = _quorums[target][functionSelector];\\n\\n        if (storedQuorum == 0) {\\n            return baseQuorum;\\n        } else {\\n            return storedQuorum;\\n        }\\n    }\\n\\n    // stores approved voting vaults\\n    mapping(address => bool) public override approvedVaults;\\n\\n    // proposal storage with the proposalID as key\\n    mapping(uint256 => Proposal) public proposals;\\n\\n    // mapping of addresses and proposalIDs to vote struct representing\\n    // the voting actions taken for each proposal\\n    mapping(address => mapping(uint256 => Vote)) public votes;\\n\\n    enum Ballot { YES, NO, MAYBE }\\n\\n    struct Proposal {\\n        // hash of this proposal's intended function calls\\n        bytes32 proposalHash;\\n        // block of the proposal creation\\n        uint128 created;\\n        // timestamp when the proposal can execute\\n        uint128 unlock;\\n        // expiration time of a proposal\\n        uint128 expiration;\\n        // the quorum required for the proposal to execute\\n        uint128 quorum;\\n        // [yes, no, maybe] voting power\\n        uint128[3] votingPower;\\n        // Timestamp after which if the call has not been executed it cannot be executed\\n        uint128 lastCall;\\n    }\\n\\n    struct Vote {\\n        // voting power of the vote\\n        uint128 votingPower;\\n        // direction of the vote\\n        Ballot castBallot;\\n    }\\n\\n    event ProposalCreated(\\n        uint256 proposalId,\\n        uint256 created,\\n        uint256 execution,\\n        uint256 expiration\\n    );\\n\\n    event ProposalExecuted(uint256 proposalId);\\n\\n    event Voted(address indexed voter, uint256 indexed proposalId, Vote vote);\\n\\n    /// @notice constructor\\n    /// @param _timelock Timelock contract.\\n    /// @param _baseQuorum Default quorum for all functions with no set quorum.\\n    /// @param _minProposalPower Minimum voting power needed to submit a proposal.\\n    /// @param _gsc governance steering committee contract.\\n    /// @param votingVaults Initial voting vaults to approve.\\n    constructor(\\n        address _timelock,\\n        uint256 _baseQuorum,\\n        uint256 _minProposalPower,\\n        address _gsc,\\n        address[] memory votingVaults\\n    ) Authorizable() {\\n        baseQuorum = _baseQuorum;\\n        minProposalPower = _minProposalPower;\\n        for (uint256 i = 0; i < votingVaults.length; i++) {\\n            approvedVaults[votingVaults[i]] = true;\\n        }\\n        setOwner(address(_timelock));\\n        _authorize(_gsc);\\n    }\\n\\n    /// @notice Create a new proposal\\n    /// @dev all provided votingVaults must be approved vaults `approvedVaults`.\\n    /// @param votingVaults voting vaults to draw voting power from.\\n    /// @param extraVaultData an encoded list of extra data to provide to vaults\\n    /// @param targets list of target addresses the timelock contract will interact with.\\n    /// @param calldatas execution calldata for each target.\\n    /// @param lastCall timestamp after which this cannot be executed, note should be\\n    ///                 more than the voting time period\\n    /// @param ballot vote direction (yes, no, maybe)\\n    function proposal(\\n        address[] calldata votingVaults,\\n        bytes[] calldata extraVaultData,\\n        address[] calldata targets,\\n        bytes[] calldata calldatas,\\n        uint256 lastCall,\\n        Ballot ballot\\n    ) external {\\n        require(targets.length == calldatas.length, \\\"array length mismatch\\\");\\n        require(targets.length != 0, \\\"empty proposal\\\");\\n\\n        // the hash is only used to verify the proposal data, proposals are tracked by ID\\n        // so there is no need to hash with proposalCount nonce.\\n        bytes32 proposalHash = keccak256(abi.encode(targets, calldatas));\\n\\n        // get the quorum requirement for this proposal. The quorum requirement is equal to\\n        // the greatest quorum item in the proposal\\n        uint256 quorum;\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            // function selector should be the first 4 bytes of the calldata\\n            bytes4 selector = _getSelector(calldatas[i]);\\n            uint256 unitQuorum = _quorums[targets[i]][selector];\\n\\n            // don't assume baseQuorum is the highest\\n            unitQuorum = unitQuorum == 0 ? baseQuorum : unitQuorum;\\n            if (unitQuorum > quorum) {\\n                quorum = unitQuorum;\\n            }\\n        }\\n\\n        // We check that the expiration is possibly valid\\n        require(\\n            lastCall > block.number + lockDuration + extraVoteTime,\\n            \\\"expires before voting ends\\\"\\n        );\\n\\n        proposals[proposalCount] = Proposal(\\n            proposalHash,\\n            // Note we use blocknumber - 1 here as a flash loan mitigation.\\n            uint128(block.number - 1),\\n            uint128(block.number + lockDuration),\\n            uint128(block.number + lockDuration + extraVoteTime),\\n            uint128(quorum),\\n            proposals[proposalCount].votingPower,\\n            uint128(lastCall)\\n        );\\n\\n        uint256 votingPower =\\n            vote(votingVaults, extraVaultData, proposalCount, ballot);\\n\\n        // the proposal quorum is the lowest of minProposalPower and the proposal quorum\\n        // because it is awkward for the proposal to require more voting power than\\n        // the execution\\n        uint256 minPower =\\n            quorum <= minProposalPower ? quorum : minProposalPower;\\n        // the GSC (governance steering comity) contract does not have a voting power requirement\\n        // to submit a proposal\\n        if (!isAuthorized(msg.sender)) {\\n            require(votingPower >= minPower, \\\"insufficient voting power\\\");\\n        }\\n\\n        emit ProposalCreated(\\n            proposalCount,\\n            block.number,\\n            block.number + lockDuration,\\n            block.number + lockDuration + extraVoteTime\\n        );\\n\\n        proposalCount += 1;\\n    }\\n\\n    /// @notice Votes for a new proposal.\\n    /// @dev all provided votingVaults must be approved vaults `approvedVaults`.\\n    /// Addresses can re-vote, but the previous vote's effect will be negated.\\n    /// @param votingVaults voting vaults to draw voting power from.\\n    /// @param extraVaultData extra bytes data to give to each vault\\n    /// @param proposalId proposal identifier.\\n    /// @param ballot vote direction (yes, no, maybe)\\n    /// @return the user's voting power\\n    function vote(\\n        address[] memory votingVaults,\\n        bytes[] memory extraVaultData,\\n        uint256 proposalId,\\n        Ballot ballot\\n    ) public returns (uint256) {\\n        // No votes after the vote period is over\\n        require(proposals[proposalId].created != 0, \\\"proposal does not exist\\\");\\n        require(block.number <= proposals[proposalId].expiration, \\\"Expired\\\");\\n\\n        uint128 votingPower;\\n\\n        for (uint256 i = 0; i < votingVaults.length; i++) {\\n            // ensure there are no voting vault duplicates\\n            for (uint256 j = i + 1; j < votingVaults.length; j++) {\\n                require(votingVaults[i] != votingVaults[j], \\\"duplicate vault\\\");\\n            }\\n            require(approvedVaults[votingVaults[i]], \\\"unverified vault\\\");\\n            votingPower += uint128(\\n                IVotingVault(votingVaults[i]).queryVotePower(\\n                    msg.sender,\\n                    proposals[proposalId].created,\\n                    extraVaultData[i]\\n                )\\n            );\\n        }\\n\\n        // if a user has already voted, undo their previous vote.\\n        // NOTE: A new vote can have less voting power\\n        if (votes[msg.sender][proposalId].votingPower > 0) {\\n            proposals[proposalId].votingPower[\\n                uint256(votes[msg.sender][proposalId].castBallot)\\n            ] -= votes[msg.sender][proposalId].votingPower;\\n        }\\n        votes[msg.sender][proposalId] = Vote(votingPower, ballot);\\n\\n        proposals[proposalId].votingPower[uint256(ballot)] += votingPower;\\n\\n        // Emit an event to track this info\\n        emit Voted(msg.sender, proposalId, votes[msg.sender][proposalId]);\\n\\n        return votingPower;\\n    }\\n\\n    /// @notice Execute a proposal.\\n    /// @param proposalId proposal identifier.\\n    /// @param targets list of target addresses the timelock contract will interact with.\\n    /// @param calldatas execution calldata for each target.\\n    function execute(\\n        uint256 proposalId,\\n        address[] memory targets,\\n        bytes[] memory calldatas\\n    ) external nonReentrant {\\n        // We have to execute after min voting period\\n        require(block.number >= proposals[proposalId].unlock, \\\"not unlocked\\\");\\n        // If executed the proposal will be deleted and this will be zero\\n        require(proposals[proposalId].unlock != 0, \\\"Previously executed\\\");\\n        // We cannot execute if the proposal has expired\\n        require(\\n            block.number < proposals[proposalId].lastCall,\\n            \\\"past last call timestamp\\\"\\n        );\\n\\n        // ensure the data matches the hash\\n        require(\\n            keccak256(abi.encode(targets, calldatas)) ==\\n                proposals[proposalId].proposalHash,\\n            \\\"hash mismatch\\\"\\n        );\\n\\n        uint128[3] memory results = proposals[proposalId].votingPower;\\n        // if there are enough votes to meet quorum and there are more yes votes than no votes\\n        // then the proposal is executed\\n        bool passesQuorum =\\n            results[0] + results[1] + results[2] >=\\n                proposals[proposalId].quorum;\\n        bool majorityInFavor = results[0] > results[1];\\n\\n        require(passesQuorum && majorityInFavor, \\\"Cannot execute\\\");\\n\\n        // Execute a package of low level calls\\n        // NOTE - All of them must succeed for the package to succeed.\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            (bool success, ) = targets[i].call(calldatas[i]);\\n            require(success, \\\"Call failed\\\");\\n        }\\n        // Notification of proposal execution\\n        emit ProposalExecuted(proposalId);\\n\\n        // delete proposal for some gas savings,\\n        // Proposals are only deleted when they are actually executed, failed proposals\\n        // are never deleted\\n        delete proposals[proposalId];\\n    }\\n\\n    /// @notice gets the current voting power for a proposal\\n    /// @param proposalId The proposal's ID.\\n    function getProposalVotingPower(uint256 proposalId)\\n        external\\n        view\\n        returns (uint128[3] memory)\\n    {\\n        return proposals[proposalId].votingPower;\\n    }\\n\\n    /// @notice Sets a quorum for a specific address and selector.\\n    /// @param target Target contract address.\\n    /// @param selector Function selector.\\n    /// @param quorum Fraction to set quorum to.\\n    function setCustomQuorum(\\n        address target,\\n        bytes4 selector,\\n        uint256 quorum\\n    ) external onlyOwner {\\n        _quorums[target][selector] = quorum;\\n    }\\n\\n    /// @notice Updates the status of a voting vault.\\n    /// @param vault Address of the voting vault.\\n    /// @param isValid True to be valid, false otherwise.\\n    function changeVaultStatus(address vault, bool isValid) external onlyOwner {\\n        approvedVaults[vault] = isValid;\\n    }\\n\\n    /// @notice Updates the default quorum.\\n    /// @param quorum New base quorum.\\n    function setDefaultQuorum(uint256 quorum) external onlyOwner {\\n        baseQuorum = quorum;\\n    }\\n\\n    /// @notice Updates the minimum voting power needed to submit a proposal.\\n    /// @param _minProposalPower Minimum voting power needed to submit a proposal.\\n    function setMinProposalPower(uint256 _minProposalPower) external onlyOwner {\\n        minProposalPower = _minProposalPower;\\n    }\\n\\n    /// @notice Updates the lock duration of a proposal.\\n    /// @param _lockDuration New lock duration.\\n    function setLockDuration(uint256 _lockDuration) external onlyOwner {\\n        lockDuration = _lockDuration;\\n    }\\n\\n    /// @notice Updates the extra voting period\\n    /// @param _extraVoteTime New extra voting time\\n    function changeExtraVotingTime(uint256 _extraVoteTime) external onlyOwner {\\n        extraVoteTime = _extraVoteTime;\\n    }\\n\\n    /// @notice Internal helper function to get the function selector of a calldata string.\\n    function _getSelector(bytes memory _calldata)\\n        internal\\n        pure\\n        returns (bytes4 out)\\n    {\\n        assembly {\\n            out := and(\\n                mload(add(_calldata, 32)),\\n                0xFFFFFFFFF0000000000000000000000000000000000000000000000000000000\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/council/interfaces/IVotingVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\ninterface IVotingVault {\\n    /// @notice Attempts to load the voting power of a user\\n    /// @param user The address we want to load the voting power of\\n    /// @param blockNumber the block number we want the user's voting power at\\n    /// @param extraData Abi encoded optional extra data used by some vaults, such as merkle proofs\\n    /// @return the number of votes\\n    function queryVotePower(\\n        address user,\\n        uint256 blockNumber,\\n        bytes calldata extraData\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/council/libraries/Authorizable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.7.0;\\n\\ncontract Authorizable {\\n    // This contract allows a flexible authorization scheme\\n\\n    // The owner who can change authorization status\\n    address public owner;\\n    // A mapping from an address to its authorization status\\n    mapping(address => bool) public authorized;\\n\\n    /// @dev We set the deployer to the owner\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /// @dev This modifier checks if the msg.sender is the owner\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Sender not owner\\\");\\n        _;\\n    }\\n\\n    /// @dev This modifier checks if an address is authorized\\n    modifier onlyAuthorized() {\\n        require(isAuthorized(msg.sender), \\\"Sender not Authorized\\\");\\n        _;\\n    }\\n\\n    /// @dev Returns true if an address is authorized\\n    /// @param who the address to check\\n    /// @return true if authorized false if not\\n    function isAuthorized(address who) public view returns (bool) {\\n        return authorized[who];\\n    }\\n\\n    /// @dev Privileged function authorize an address\\n    /// @param who the address to authorize\\n    function authorize(address who) external onlyOwner() {\\n        _authorize(who);\\n    }\\n\\n    /// @dev Privileged function to de authorize an address\\n    /// @param who The address to remove authorization from\\n    function deauthorize(address who) external onlyOwner() {\\n        authorized[who] = false;\\n    }\\n\\n    /// @dev Function to change owner\\n    /// @param who The new owner address\\n    function setOwner(address who) public onlyOwner() {\\n        owner = who;\\n    }\\n\\n    /// @dev Inheritable function which authorizes someone\\n    /// @param who the address to authorize\\n    function _authorize(address who) internal {\\n        authorized[who] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/council/libraries/ReentrancyBlock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\ncontract ReentrancyBlock {\\n    // A storage slot for the reentrancy flag\\n    bool private _entered;\\n    // Will use a state flag to prevent this function from being called back into\\n    modifier nonReentrant() {\\n        // Check the state variable before the call is entered\\n        require(!_entered, \\\"Reentrancy\\\");\\n        // Store that the function has been entered\\n        _entered = true;\\n        // Run the function code\\n        _;\\n        // Clear the state\\n        _entered = false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/council/interfaces/ICoreVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\ninterface ICoreVoting {\\n    /// @notice A method auto generated from a public storage mapping, looks\\n    ///         up which vault addresses are approved by core voting\\n    /// @param vault the address to check if it is an approved vault\\n    /// @return true if approved false if not approved\\n    function approvedVaults(address vault) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_timelock\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_baseQuorum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minProposalPower\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_gsc\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"votingVaults\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"created\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"execution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"votingPower\",\"type\":\"uint128\"},{\"internalType\":\"enum CoreVoting.Ballot\",\"name\":\"castBallot\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct CoreVoting.Vote\",\"name\":\"vote\",\"type\":\"tuple\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAY_IN_BLOCKS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedVaults\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseQuorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_extraVoteTime\",\"type\":\"uint256\"}],\"name\":\"changeExtraVotingTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"name\":\"changeVaultStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"deauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraVoteTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposalVotingPower\",\"outputs\":[{\"internalType\":\"uint128[3]\",\"name\":\"\",\"type\":\"uint128[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minProposalPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"votingVaults\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"extraVaultData\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"lastCall\",\"type\":\"uint256\"},{\"internalType\":\"enum CoreVoting.Ballot\",\"name\":\"ballot\",\"type\":\"uint8\"}],\"name\":\"proposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"created\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"unlock\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"expiration\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"quorum\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lastCall\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"}],\"name\":\"quorums\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"quorum\",\"type\":\"uint256\"}],\"name\":\"setCustomQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quorum\",\"type\":\"uint256\"}],\"name\":\"setDefaultQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockDuration\",\"type\":\"uint256\"}],\"name\":\"setLockDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minProposalPower\",\"type\":\"uint256\"}],\"name\":\"setMinProposalPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"votingVaults\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"extraVaultData\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"enum CoreVoting.Ballot\",\"name\":\"ballot\",\"type\":\"uint8\"}],\"name\":\"vote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"votes\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"votingPower\",\"type\":\"uint128\"},{\"internalType\":\"enum CoreVoting.Ballot\",\"name\":\"castBallot\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CoreVoting", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000422494292e7a9dda8778bb4ea05c2779a3d60f5d00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}