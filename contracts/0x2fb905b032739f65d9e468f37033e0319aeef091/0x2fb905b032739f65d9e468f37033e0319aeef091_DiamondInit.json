{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/access/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @notice This emits when ownership of a contract changes.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function owner() external view returns (address owner_);\\n    function transferOwnership(address _newOwner) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/diamond-core/IDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IDiamond {\\n    enum FacetCutAction {\\n        Add,     // 0\\n        Replace, // 1\\n        Remove   // 2\\n    }\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    struct DiamondArgs {\\n        address owner;\\n        address init;\\n        bytes initCalldata;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/diamond-core/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport {IDiamond} from \\\"./IDiamond.sol\\\";\\n\\n/**\\n * @title DiamondCutFacet\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @notice Required function selector modification to support EIP-2535\\n */\\ninterface IDiamondCut is IDiamond {\\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/diamond-core/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/**\\n * @title IDiamondLoupe\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @notice Required introspection functions for EIP-2535 Diamond Standard\\n */\\n interface IDiamondLoupe {\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    function facets() external view returns (Facet[] memory facets_);\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"src/libraries/diamond-core/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport {IDiamond} from \\\"src/interfaces/diamond-core/IDiamond.sol\\\";\\n\\nerror NoSelectorsGivenToAdd();\\nerror NotContractOwner(address _user, address _contractOwner);\\nerror NoSelectorsProvidedForFacetForCut(address _facetAddress);\\nerror CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\\nerror NoBytecodeAtAddress(address _contractAddress, string _message);\\nerror IncorrectFacetCutAction(uint8 _action);\\nerror CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\\nerror CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\\nerror CannotReplaceImmutableFunction(bytes4 _selector);\\nerror CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);\\nerror CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\\nerror RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\\nerror CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\\nerror CannotRemoveImmutableFunction(bytes4 _selector);\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\n/**\\n * @title LibDiamond\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @notice Library of Diamond Functions\\n */\\nlibrary LibDiamond {\\n\\n    struct FacetAddressAndSelectorPosition {\\n        address facetAddress;\\n        uint16 selectorPosition;\\n    }\\n\\n    struct DiamondStorage {\\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\\n        bytes4[] selectors;\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        address contractOwner;\\n    }\\n\\n    /// @dev Standard storage slot for the shared diamond storage\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    /// @notice Emitted when Ownership of the diamond is transferred\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a DiamondCut takes place\\n    event DiamondCut(IDiamond.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n\\n    /// @dev Returns data stored at the `DIAMOND_STORAGE_POSITION`\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the diamond to the provided owner\\n     *\\n     * @dev    Throws if caller is not the current owner\\n     *\\n     * @dev    <h4>Postconditions</h4>\\n     * @dev    1. The provided address is the new owner\\n     * @dev    2. The previous owner is no longer the owner\\n     *\\n     * @param  _newOwner address of the new owner\\n     */\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    /// @dev Returns the contract owner of the Diamond\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    /// @dev Internal function version of diamondCut\\n    function diamondCut(IDiamond.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex].functionSelectors;\\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\\n            if (functionSelectors.length == 0) {\\n                revert NoSelectorsProvidedForFacetForCut(facetAddress);\\n            }\\n            IDiamond.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamond.FacetCutAction.Add) {\\n                addFunctions(facetAddress, functionSelectors);\\n            } else if (action == IDiamond.FacetCutAction.Replace) {\\n                replaceFunctions(facetAddress, functionSelectors);\\n            } else if (action == IDiamond.FacetCutAction.Remove) {\\n                removeFunctions(facetAddress, functionSelectors);\\n            } else {\\n                revert IncorrectFacetCutAction(uint8(action));\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    /**\\n     * @dev Associates a facet address with an array of function selectors\\n     *\\n     * @dev Throws if the facet address is address(0)\\n     * @dev Throws if the facet address does not contain code\\n     * @dev Throws if the function selector is already assigned a facet\\n     *\\n     * @dev <h4>Postconditions</h4>\\n     * @dev 1. The facet address is associated with the list of function selectors\\n     */\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        if (_facetAddress == address(0)) {\\n            revert CannotAddSelectorsToZeroAddress(_functionSelectors);\\n        }\\n        DiamondStorage storage ds = diamondStorage();\\n        uint16 selectorCount = uint16(ds.selectors.length);\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            if (oldFacetAddress != address(0)) {\\n                revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\\n            }\\n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(_facetAddress, selectorCount);\\n            ds.selectors.push(selector);\\n            selectorCount++;\\n        }\\n    }\\n\\n    /**\\n     * @dev Replaces an array of function selectors with a new facet address\\n     *\\n     * @dev Throws if the provided facet address is the zero address\\n     * @dev Throws if the provided facet address does not contain code\\n     * @dev Throws if trying to replace an immutable function selector\\n     * @dev Throws if trying to replace with the same facet address and function selector\\n     * @dev Throws if any function selector in the `_functionSelectors` array does not exist\\n     *\\n     * @dev <h4>Postconditions</h4>\\n     * @dev 1. The list of function selectors are replaced with the new facet address\\n     */\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        if (_facetAddress == address(0)) {\\n            revert CannotReplaceFunctionsFromFacetWithZeroAddress(_functionSelectors);\\n        }\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            // can't replace immutable functions -- functions defined directly in the diamond in this case\\n            if (oldFacetAddress == address(this)) {\\n                revert CannotReplaceImmutableFunction(selector);\\n            }\\n            if (oldFacetAddress == _facetAddress) {\\n                revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(selector);\\n            }\\n            if (oldFacetAddress == address(0)) {\\n                revert CannotReplaceFunctionThatDoesNotExists(selector);\\n            }\\n            // replace old facet address\\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes functions from the Diamond\\n     *\\n     * @dev Throws if the provided facet address is not address(0)\\n     * @dev Throws if any function in the `_functionSelectors` does not exist\\n     * @dev Throws if any function in the `_functionSelectors` array is immutable\\n     *\\n     * @dev <h4>Postconditions</h4>\\n     * @dev 1. The provided array of function selectors have been removed from the Diamond\\n     */\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 selectorCount = ds.selectors.length;\\n        if (_facetAddress != address(0)) {\\n            revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition =\\n                ds.facetAddressAndSelectorPosition[selector];\\n            if (oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\\n                revert CannotRemoveFunctionThatDoesNotExist(selector);\\n            }\\n\\n            // can't remove immutable functions -- functions defined directly in the diamond\\n            if (oldFacetAddressAndSelectorPosition.facetAddress == address(this)) {\\n                revert CannotRemoveImmutableFunction(selector);\\n            }\\n            // replace selector with last selector\\n            selectorCount--;\\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\\n                bytes4 lastSelector = ds.selectors[selectorCount];\\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\\n                ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition =\\n                    oldFacetAddressAndSelectorPosition.selectorPosition;\\n            }\\n            // delete last selector\\n            ds.selectors.pop();\\n            delete ds.facetAddressAndSelectorPosition[selector];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calls the initialization address with the provide abi encoded calldata\\n     *\\n     * @dev Throws if invalid calldata is provided\\n     *\\n     * @dev <h4>Postconditions</h4>\\n     * @dev 1. The initialization address has performed any updates in the provided calldata\\n     */\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up error\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }\\n    }\\n\\n    /// @dev Enforces the msg.sender is the contract owner, reverts if not\\n    function requireContractOwner() internal view {\\n        if (msg.sender != diamondStorage().contractOwner) {\\n            revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\\n        }\\n    }\\n\\n    /// @dev Enforces the provided address has code, reverts if not \\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        if (contractSize == 0) {\\n            revert NoBytecodeAtAddress(_contract, _errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/upgradeInitializers/DiamondInit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport {LibDiamond} from \\\"src/libraries/diamond-core/LibDiamond.sol\\\";\\nimport {IDiamondLoupe} from \\\"src/interfaces/diamond-core/IDiamondLoupe.sol\\\";\\nimport {IDiamondCut} from \\\"src/interfaces/diamond-core/IDiamondCut.sol\\\";\\nimport {IERC173} from \\\"src/interfaces/access/IERC173.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\n/**\\n * @title DiamondInit\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @notice Initialization contract called to set required state variables\\n */\\ncontract DiamondInit {\\n\\n    /**\\n     * @notice Initializes the diamond\\n     *\\n     * @dev    <h4>Postconditions</h4>\\n     * @dev    1. The diamond's supported interfaces are set\\n     * @dev    2. Any other state variables are set\\n     */\\n    function init() external {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\n        ds.supportedInterfaces[type(IAccessControl).interfaceId] = true;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@limit-break/=lib/limit-break-contracts/contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"limit-break-contracts/=lib/limit-break-contracts/contracts/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solidity-stringutils/=lib/solidity-stringutils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DiamondInit", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}