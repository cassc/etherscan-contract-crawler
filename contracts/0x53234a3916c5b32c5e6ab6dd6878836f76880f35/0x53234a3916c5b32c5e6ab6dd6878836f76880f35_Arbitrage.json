{"SourceCode": "{\"Arbitrage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003c=0.8.10;\\n\\nimport \\\"./IUniswapV2Router02.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface Structs {\\n    struct Val {\\n        uint256 value;\\n    }\\n\\n    enum ActionType {\\n        Deposit, // supply tokens\\n        Withdraw, // borrow tokens\\n        Transfer, // transfer balance between accounts\\n        Buy, // buy an amount of some token (externally)\\n        Sell, // sell an amount of some token (externally)\\n        Trade, // trade tokens against another account\\n        Liquidate, // liquidate an undercollateralized or expiring account\\n        Vaporize, // use excess tokens to zero-out a completely negative account\\n        Call // send arbitrary data to an address\\n    }\\n\\n    enum AssetDenomination {\\n        Wei // the amount is denominated in wei\\n    }\\n\\n    enum AssetReference {\\n        Delta // the amount is given as a delta from the current value\\n    }\\n\\n    struct AssetAmount {\\n        bool sign; // true if positive\\n        AssetDenomination denomination;\\n        AssetReference ref;\\n        uint256 value;\\n    }\\n\\n    struct ActionArgs {\\n        ActionType actionType;\\n        uint256 accountId;\\n        AssetAmount amount;\\n        uint256 primaryMarketId;\\n        uint256 secondaryMarketId;\\n        address otherAddress;\\n        uint256 otherAccountId;\\n        bytes data;\\n    }\\n\\n    struct Info {\\n        address owner; // The address that owns the account\\n        uint256 number; // A nonce that allows a single address to control many accounts\\n    }\\n\\n    struct Wei {\\n        bool sign; // true if positive\\n        uint256 value;\\n    }\\n}\\n\\nabstract contract DyDxPool is Structs {\\n    function getAccountWei(Info memory account, uint256 marketId)\\n        public\\n        view\\n        virtual\\n        returns (Wei memory);\\n\\n    function operate(Info[] memory, ActionArgs[] memory) public virtual;\\n}\\n\\ncontract DyDxFlashLoan is Structs {\\n    DyDxPool pool = DyDxPool(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\\n\\n    address public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    mapping(address =\\u003e uint256) public currencies;\\n\\n    constructor() {\\n        currencies[WETH] = 1;\\n    }\\n\\n    modifier onlyPool() {\\n        require(\\n            msg.sender == address(pool),\\n            \\\"FlashLoan: could be called by DyDx pool only\\\"\\n        );\\n        _;\\n    }\\n\\n    function tokenToMarketId(address token) public view returns (uint256) {\\n        uint256 marketId = currencies[token];\\n        require(marketId != 0, \\\"FlashLoan: Unsupported token\\\");\\n        return marketId - 1;\\n    }\\n\\n    // the DyDx will call `callFunction(address sender, Info memory accountInfo, bytes memory data) public` after during `operate` call\\n    function flashloan(\\n        address token,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal {\\n        IERC20(token).approve(address(pool), amount + 1);\\n        Info[] memory infos = new Info[](1);\\n        ActionArgs[] memory args = new ActionArgs[](3);\\n\\n        infos[0] = Info(address(this), 0);\\n\\n        AssetAmount memory wamt = AssetAmount(\\n            false,\\n            AssetDenomination.Wei,\\n            AssetReference.Delta,\\n            amount\\n        );\\n        ActionArgs memory withdraw;\\n        withdraw.actionType = ActionType.Withdraw;\\n        withdraw.accountId = 0;\\n        withdraw.amount = wamt;\\n        withdraw.primaryMarketId = tokenToMarketId(token);\\n        withdraw.otherAddress = address(this);\\n\\n        args[0] = withdraw;\\n\\n        ActionArgs memory call;\\n        call.actionType = ActionType.Call;\\n        call.accountId = 0;\\n        call.otherAddress = address(this);\\n        call.data = data;\\n\\n        args[1] = call;\\n\\n        ActionArgs memory deposit;\\n        AssetAmount memory damt = AssetAmount(\\n            true,\\n            AssetDenomination.Wei,\\n            AssetReference.Delta,\\n            amount + 1\\n        );\\n        deposit.actionType = ActionType.Deposit;\\n        deposit.accountId = 0;\\n        deposit.amount = damt;\\n        deposit.primaryMarketId = tokenToMarketId(token);\\n        deposit.otherAddress = address(this);\\n\\n        args[2] = deposit;\\n\\n        pool.operate(infos, args);\\n    }\\n}\\n\\ncontract Arbitrage is DyDxFlashLoan {\\n    IUniswapV2Router02 public immutable sRouter;\\n    IUniswapV2Router02 public immutable uRouter;\\n\\n    address public owner;\\n\\n    constructor(address _sRouter, address _uRouter) {\\n        sRouter = IUniswapV2Router02(_sRouter); // Sushiswap\\n        uRouter = IUniswapV2Router02(_uRouter); // Uniswap\\n        owner = msg.sender;\\n    }\\n\\n    function executeTrade(\\n        bool _startOnUniswap,\\n        address _token0,\\n        address _token1,\\n        uint256 _flashAmount\\n    ) external {\\n        uint256 balanceBefore = IERC20(_token0).balanceOf(address(this));\\n\\n        bytes memory data = abi.encode(\\n            _startOnUniswap,\\n            _token0,\\n            _token1,\\n            _flashAmount,\\n            balanceBefore\\n        );\\n\\n        flashloan(_token0, _flashAmount, data); // execution goes to `callFunction`\\n    }\\n\\n    function callFunction(\\n        address, /* sender */\\n        Info calldata, /* accountInfo */\\n        bytes calldata data\\n    ) external onlyPool {\\n        (\\n            bool startOnUniswap,\\n            address token0,\\n            address token1,\\n            uint256 flashAmount,\\n            uint256 balanceBefore\\n        ) = abi.decode(data, (bool, address, address, uint256, uint256));\\n\\n        uint256 balanceAfter = IERC20(token0).balanceOf(address(this));\\n\\n        require(\\n            balanceAfter - balanceBefore == flashAmount,\\n            \\\"contract did not get the loan\\\"\\n        );\\n\\n        // Use the money here!\\n        address[] memory path = new address[](2);\\n\\n        path[0] = token0;\\n        path[1] = token1;\\n\\n        if (startOnUniswap) {\\n            _swapOnUniswap(path, flashAmount, 0);\\n\\n            path[0] = token1;\\n            path[1] = token0;\\n\\n            _swapOnSushiswap(\\n                path,\\n                IERC20(token1).balanceOf(address(this)),\\n                (flashAmount + 1)\\n            );\\n        } else {\\n            _swapOnSushiswap(path, flashAmount, 0);\\n\\n            path[0] = token1;\\n            path[1] = token0;\\n\\n            _swapOnUniswap(\\n                path,\\n                IERC20(token1).balanceOf(address(this)),\\n                (flashAmount + 1)\\n            );\\n        }\\n\\n        IERC20(token0).transfer(\\n            owner,\\n            IERC20(token0).balanceOf(address(this)) - (flashAmount + 1)\\n        );\\n    }\\n\\n    // -- INTERNAL FUNCTIONS -- //\\n\\n    function _swapOnUniswap(\\n        address[] memory _path,\\n        uint256 _amountIn,\\n        uint256 _amountOut\\n    ) internal {\\n        require(\\n            IERC20(_path[0]).approve(address(uRouter), _amountIn),\\n            \\\"Uniswap approval failed.\\\"\\n        );\\n\\n        uRouter.swapExactTokensForTokens(\\n            _amountIn,\\n            _amountOut,\\n            _path,\\n            address(this),\\n            (block.timestamp + 1200)\\n        );\\n    }\\n\\n    function _swapOnSushiswap(\\n        address[] memory _path,\\n        uint256 _amountIn,\\n        uint256 _amountOut\\n    ) internal {\\n        require(\\n            IERC20(_path[0]).approve(address(sRouter), _amountIn),\\n            \\\"Sushiswap approval failed.\\\"\\n        );\\n\\n        sRouter.swapExactTokensForTokens(\\n            _amountIn,\\n            _amountOut,\\n            _path,\\n            address(this),\\n            (block.timestamp + 1200)\\n        );\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IUniswapV2Router01.sol\":{\"content\":\"pragma solidity \\u003e=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"},\"IUniswapV2Router02.sol\":{\"content\":\"pragma solidity \\u003e=0.6.2;\\n\\nimport \\u0027./IUniswapV2Router01.sol\\u0027;\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.4.22 \\u003c0.9.0;\\n\\ncontract Migrations {\\n  address public owner = msg.sender;\\n  uint public last_completed_migration;\\n\\n  modifier restricted() {\\n    require(\\n      msg.sender == owner,\\n      \\\"This function is restricted to the contract\\u0027s owner\\\"\\n    );\\n    _;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.Info\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"currencies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_startOnUniswap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_flashAmount\",\"type\":\"uint256\"}],\"name\":\"executeTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenToMarketId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Arbitrage", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e5d4c75045b07d67d0c933de202b7645fa977a823f91816f5bb0d19709a0866c"}