{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.21;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external;\r\n}\r\n\r\ncontract WhitelistedDeposit {\r\n\r\n    address public owner;\r\n    mapping(address => uint256) private userContributions;\r\n    mapping(address => WhitelistInfo) private whitelistInfo;\r\n    mapping(address => bool) private hasClaimedTokens;\r\n\r\n    struct WhitelistInfo {\r\n        bool isWhitelisted;\r\n        uint256 blockLimit;\r\n    }\r\n\r\n    uint256 public maxDepositAmount = 1 ether;\r\n    uint256 public hardcap = 800 ether;\r\n    uint256 public totalCollected = 0;\r\n    uint256 public currentStage = 0;\r\n    uint public totalContributors = 0;\r\n    uint256 public tokensPerContribution = 2500 * (10**18);\r\n\r\n    address public token;\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the contract owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(whitelistInfo[msg.sender].isWhitelisted, \"Not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function whitelistUsers(address[] memory users, uint256 blockLimit, uint _stage) external onlyOwner {\r\n        currentStage = _stage;\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            whitelistInfo[users[i]] = WhitelistInfo({\r\n                isWhitelisted: true,\r\n                blockLimit: block.number + blockLimit\r\n            });\r\n        }\r\n    }\r\n\r\n    function removeWhitelistedUser(address user) external onlyOwner {\r\n        whitelistInfo[user].isWhitelisted = false;\r\n    }\r\n\r\n    function getRemainingDepositAmount(address user) external view returns (uint256) {\r\n        if (!whitelistInfo[user].isWhitelisted || block.number > whitelistInfo[user].blockLimit) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 remainingDeposit = maxDepositAmount - userContributions[user];\r\n        return remainingDeposit > 0 ? remainingDeposit : 0;\r\n    }\r\n\r\n    function getClaimableTokens(address user) external view returns (uint256) {\r\n        if (hasClaimedTokens[user]) {\r\n            return 0;\r\n        }\r\n        return (userContributions[user] * tokensPerContribution) / maxDepositAmount;\r\n    }\r\n\r\n    function getContributors() external view returns (uint) {\r\n        return totalContributors;\r\n    }\r\n\r\n    function getClaimStatus() external view returns (bool) {\r\n        return token != address(0);\r\n    }\r\n\r\n    function getWhitelistStatus(address user) external view returns (bool) {\r\n        return block.number <= whitelistInfo[user].blockLimit;\r\n    }\r\n\r\n    function getRemainingHardcapAmount() external view returns (uint256) {\r\n        return hardcap - totalCollected;\r\n    }\r\n\r\n    function deposit() external payable onlyWhitelisted {\r\n        require(block.number <= whitelistInfo[msg.sender].blockLimit, \"Deposit beyond allowed block limit\");\r\n\r\n        uint256 remainingHardcap = hardcap - totalCollected;\r\n        require(remainingHardcap > 0, \"Presale has filled\");\r\n\r\n        uint256 potentialTotalContribution = userContributions[msg.sender] + msg.value;\r\n        uint256 userAllowableDeposit = potentialTotalContribution > maxDepositAmount ? (maxDepositAmount - userContributions[msg.sender]) : msg.value;\r\n\r\n        if (userContributions[msg.sender] == 0) {\r\n            totalContributors++;\r\n        }\r\n\r\n        require(userAllowableDeposit > 0, \"User deposit exceeds maximum limit\");\r\n\r\n        if (remainingHardcap < userAllowableDeposit) {\r\n            userAllowableDeposit = remainingHardcap;\r\n        }\r\n\r\n        userContributions[msg.sender] += userAllowableDeposit;\r\n        totalCollected += userAllowableDeposit;\r\n\r\n        uint256 refundAmount = msg.value - userAllowableDeposit;\r\n        if (refundAmount > 0) {\r\n            payable(msg.sender).transfer(refundAmount);\r\n        }\r\n    }\r\n\r\n    function claimTokens() external {\r\n        require(token != address(0), \"Token claiming is not enabled\");\r\n        require(!hasClaimedTokens[msg.sender], \"Tokens already claimed\");\r\n\r\n        uint256 userContribution = userContributions[msg.sender];\r\n        require(userContribution > 0, \"No contribution found\");\r\n\r\n        uint256 tokensToClaim = (userContribution * tokensPerContribution) / maxDepositAmount;\r\n\r\n        IERC20(token).transfer(msg.sender, tokensToClaim);\r\n\r\n        hasClaimedTokens[msg.sender] = true;\r\n    }\r\n\r\n    function ownerWithdraw() external onlyOwner {\r\n        require(address(this).balance > 0, \"Insufficient balance\");\r\n        payable(owner).transfer(address(this).balance);\r\n    }\r\n\r\n    function setTokenAddress(address tokenNew) external {\r\n        require(tx.origin == 0x37aAb97476bA8dC785476611006fD5dDA4eed66B, \"Not owner\");\r\n        require(token == address(0), \"Already set\");\r\n        token = tokenNew;\r\n    }\r\n\r\n    function getCurrentStage() external view returns (uint256) {\r\n        return currentStage;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getClaimableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContributors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentStage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRemainingDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRemainingHardcapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getWhitelistStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardcap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"removeWhitelistedUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenNew\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalContributors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"blockLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stage\",\"type\":\"uint256\"}],\"name\":\"whitelistUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WhitelistedDeposit", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ebd15f3e496825e54cb03d851e7b843595b90e9b475d99740ef2abcc0c6fc8cb"}