/* SPDX-License-Identifier: MIT


                       []
[][][][][]]      [][][][][][][]    [][][][][]]
[][][][][][]     [][][][][][][]    [][][][][][]
[][]     [][]    [][]  []  [][]    [][]     [][]
[][]     [][]    [][]  []          [][]     [][]
[][][][][][]     [][][][][][][]    [][][][][][]
[][][][][][]     [][][][][][][]    [][][][][][]
[][]     [][]          []  [][]    [][]     [][]
[][]     [][]    [][]  []  [][]    [][]     [][]
[][][][][][]     [][][][][][][]    [][][][][][]
[][][][][]]      [][][][][][][]    [][][][][]]
                       []


* Generated by Cyberscape Labs
* Email [emailÂ protected] for your NFT launch needs


*/


pragma solidity ^0.8.13;

import "@openzeppelin/contracts/access/Ownable.sol";
import '@openzeppelin/contracts/utils/Strings.sol';
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "erc721a/contracts/ERC721A.sol";


/*//////////////////////////////////////
                ERRORS
//////////////////////////////////////*/
/// @notice Thrown when completing transaction will exceed collection supply
error ExceededMintSupply();
/// @notice Thrown when transaction sender is not on whitelist
error NotOnMintList();
/// @notice Thrown when the attempted sale is not actve
error SaleNotActive();
/// @notice Thrown when the message value is less than the required amount
error ValueTooLow();
/// @notice Thrown when the amount minted exceeds max allowed per txn
error MintingTooMany();
/// @notice Thrown when the input address is 0
error ZeroAddress();
/// @notice Thrown when input does not match what's provided from the website
error InvalidData();



/**
    @title Billionaire Space Babies
    @author @0x_digitalnommad with Cyberscape Labs
*/

contract BsbNFT is ERC721A, Ownable, ReentrancyGuard { 

    using Strings for uint256;

    /*//////////////////////////////////////
                STATE VARIABLES
    //////////////////////////////////////*/
    enum MintStatus {
        CLOSED,
        PRESALE,
        PUBLIC,
        SOLDOUT
    }
    MintStatus public mintStatus = MintStatus.CLOSED;

    uint256 public collectionSize;
    uint256 public maxPerTxn;
    uint256 public presalePrice = 0.17 ether;
    uint256 public salePrice = 0.2 ether;
    uint256 private mintData;
    string private baseURI;
    string private unrevealedURI;
    bool public wlEnabled = false;
    bool public revealed = false;

    mapping(address => bool) private mintList;

    bytes32 public merkleRoot = 
        0xabdfb9ba2690ab68ec73f7a8567586413293817709a77d893cf14d357aee0e8a;

    address private devWallet;
    address private uiWallet;
    address private mlWallet;


    /*//////////////////////////////////////
                EVENTS
    //////////////////////////////////////*/
    event ChangeBaseURI(string _baseURI);
    event UpdateSaleState(string _sale);
    event Mint(address _minter, uint256 _amount, string _type);

    /*//////////////////////////////////////
                CONSTRUCTOR
    //////////////////////////////////////*/
    constructor(
        uint collectionSize_,
        uint maxTxn_,
        uint mintData_,
        address devWallet_,
        address mlWallet_,
        address uiWallet_
    ) ERC721A("Billionaire Space Babies", "BSB") {  // "Billionaire Space Babies", "BSB"
        collectionSize = collectionSize_;
        maxPerTxn = maxTxn_;
        mintData = mintData_;
        devWallet = devWallet_;
        mlWallet = mlWallet_;
        uiWallet = uiWallet_;
    }

    /*//////////////////////////////////////
                MODIFIERS
    //////////////////////////////////////*/
    modifier callerIsUser() {
        require(tx.origin == msg.sender, "Caller is another contract");
        _;
    }

    /*//////////////////////////////////////
                MINTING FUNCTIONS
    //////////////////////////////////////*/

    /**
        Dev mint function to reserve a supply for giveaways, collaborations, and marketing
        @param _address The address to mint to
        @param _amount The amount to mint
    */
    function devMint(address _address, uint256 _amount)
        external
        onlyOwner
    {
        if (_address == address(0)) revert ZeroAddress();
        if (_amount + totalSupply() > collectionSize) revert ExceededMintSupply();

        _safeMint(_address, _amount);
        emit Mint(_address, _amount, "Dev");
    }

    /**
        Presale mint function using merkle proofs
        @param _proof An array of bytes representing the merkle proof for the sender's address
        @param _amount The amount to mint
    */
    function mintPresale(bytes32[] memory _proof, uint256 _amount)
        external
        payable
        callerIsUser
        nonReentrant
    {
        if (mintStatus != MintStatus.PRESALE) revert SaleNotActive();
        if (_amount > maxPerTxn) revert MintingTooMany();
        if (_amount + totalSupply() > collectionSize) revert ExceededMintSupply();
        if (!MerkleProof.verify(_proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert NotOnMintList();
        if (msg.value != presalePrice * _amount) revert ValueTooLow();

        _safeMint(msg.sender, _amount);
        emit Mint(msg.sender, _amount, "Presale");
    }

    /**
        Public and presale minting function
        @param _amount The amount to mint
        @param _data Private data required to mint
    */
    function mint(uint256 _amount, uint256 _data)
        external
        payable
        callerIsUser
        nonReentrant
    {
        if (mintStatus != MintStatus.PRESALE && mintStatus != MintStatus.PUBLIC) revert SaleNotActive();
        if (_data != mintData) revert InvalidData();
        if (_amount > maxPerTxn) revert MintingTooMany();
        if (_amount + totalSupply() > collectionSize) revert ExceededMintSupply();

        if (mintStatus == MintStatus.PRESALE) {
            if (wlEnabled && !mintList[msg.sender]) revert NotOnMintList();
            if (msg.value != presalePrice * _amount) revert ValueTooLow();

            _safeMint(msg.sender, _amount);
            emit Mint(msg.sender, _amount, "Presale");
        } else /* if (mintStatus == MintStatus.PUBLIC) */ {
            if (msg.value != salePrice * _amount) revert ValueTooLow();

            _safeMint(msg.sender, _amount);
            emit Mint(msg.sender, _amount, "Public");
        }
    }

    
    /*//////////////////////////////////////
                SETTERS
    //////////////////////////////////////*/
    /**
        Set the URI for preview image prior to reveal
    */
    function setUnrevealedURI(string calldata _unrevealedURI)
        external
        onlyOwner
    {
        unrevealedURI = _unrevealedURI;
    }

    /**
        Set the base URI for all tokens post reveal
    */
    function setBaseURI(string calldata _tokenBaseURI)
        external
        onlyOwner
    {
        baseURI = _tokenBaseURI;
        emit ChangeBaseURI(_tokenBaseURI);
    }

    /**
        Update the price for the public sale or presale.
        @param _saleType Either "presale" for presalePrice or "public" for salePrice
        @param _price The new price in gwei
    */
    function setPrice(string calldata _saleType, uint256 _price)
        external
        onlyOwner
    {
        if (keccak256(abi.encodePacked(_saleType)) == keccak256(abi.encodePacked("presale"))) {
            presalePrice = _price;
        } else if (keccak256(abi.encodePacked(_saleType)) == keccak256(abi.encodePacked("public"))) {
            salePrice = _price;
        } else {
            revert InvalidData();
        }
    }

    function setMaxTxn(uint256 _max)
        external
        onlyOwner
    {
        maxPerTxn = _max;
    }

    function setMintData(uint256 _data)
        external
        onlyOwner
    {
        mintData = _data;
    }

    function setMerkleRoot(bytes32 _merkleRoot)
        external
        onlyOwner
    {
        merkleRoot = _merkleRoot;
    }

    /*//////////////////////////////////////
                GETTERS
    //////////////////////////////////////*/
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(_exists(tokenId), "URI query for nonexistent token");
        
        if (revealed == false) {
            return unrevealedURI;
        } else {
            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';
        }
    }

    function getMintStatus()
        external
        view
        returns(string memory)
    {
        if (mintStatus == MintStatus.CLOSED) {
            return "Closed";
        } else if (mintStatus == MintStatus.PRESALE){
            return "Presale";
        } else if (mintStatus == MintStatus.PUBLIC) {
            return "Public Sale";
        } else /* if (mintStatus == MintStatus.SOLDOUT) */ {
            return "Sold Out";
        }
    }

    function getMintList(address _addr)
        external
        view
        returns(bool)
    {
        return mintList[_addr];
    }

    /*//////////////////////////////////////
                MISC
    //////////////////////////////////////*/
    function addToMintList(address[] calldata _addresses)
        external
        onlyOwner
    {
        for (uint i = 0; i < _addresses.length; i++) {
            if (_addresses[i] == address(0)) revert ZeroAddress();
            mintList[_addresses[i]] = true;
        }
    }

    function removeFromMintList(address[] calldata _addresses)
        external
        onlyOwner
    {
        for (uint i = 0; i < _addresses.length; i++) {
            if (_addresses[i] == address(0)) revert ZeroAddress();
            mintList[_addresses[i]] = false;
        }
    }
    
    function reveal() external onlyOwner {
        revealed = !revealed;
    }

    function closeSale() external onlyOwner {
        if (totalSupply() == collectionSize) {
            mintStatus = MintStatus.SOLDOUT;
            emit UpdateSaleState("Sold Out");
        } else {
            mintStatus = MintStatus.CLOSED;
            emit UpdateSaleState("Closed");
        }
    }

    function startPresale() external onlyOwner {
        mintStatus = MintStatus.PRESALE;
        emit UpdateSaleState("Presale");
    }

    function startPublicSale() external onlyOwner {
        mintStatus = MintStatus.PUBLIC;
        emit UpdateSaleState("Public");
    }

    function enableWhitelist() external onlyOwner {
        wlEnabled = !wlEnabled;
    }

    function withdrawl() external onlyOwner {
        uint totalBalance = address(this).balance;
        payable(devWallet).transfer(totalBalance * 60 / 1000);
        payable(mlWallet).transfer(totalBalance * 30 / 1000);
        payable(uiWallet).transfer(totalBalance * 10 / 1000);
        uint remainingBalance = totalBalance * 900 / 1000;
        
        payable(msg.sender).transfer(remainingBalance);
    }
}