{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/v1Pool/LendingPool/LendingPool.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\\n\\n/**\\n* @title WadRayMath library\\n* @author Aave\\n* @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n**/\\n\\nlibrary WadRayMath {\\n    using SafeMath for uint256;\\n\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant halfWAD = WAD / 2;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant halfRAY = RAY / 2;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    /**\\n    * @return one ray, 1e27\\n    **/\\n    function ray() internal pure returns (uint256) {\\n        return RAY;\\n    }\\n\\n    /**\\n    * @return one wad, 1e18\\n    **/\\n\\n    function wad() internal pure returns (uint256) {\\n        return WAD;\\n    }\\n\\n    /**\\n    * @return half ray, 1e27/2\\n    **/\\n    function halfRay() internal pure returns (uint256) {\\n        return halfRAY;\\n    }\\n\\n    /**\\n    * @return half ray, 1e18/2\\n    **/\\n    function halfWad() internal pure returns (uint256) {\\n        return halfWAD;\\n    }\\n\\n    /**\\n    * @dev multiplies two wad, rounding half up to the nearest wad\\n    * @param a wad\\n    * @param b wad\\n    * @return the result of a*b, in wad\\n    **/\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return halfWAD.add(a.mul(b)).div(WAD);\\n    }\\n\\n    /**\\n    * @dev divides two wad, rounding half up to the nearest wad\\n    * @param a wad\\n    * @param b wad\\n    * @return the result of a/b, in wad\\n    **/\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 halfB = b / 2;\\n\\n        return halfB.add(a.mul(WAD)).div(b);\\n    }\\n\\n    /**\\n    * @dev multiplies two ray, rounding half up to the nearest ray\\n    * @param a ray\\n    * @param b ray\\n    * @return the result of a*b, in ray\\n    **/\\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return halfRAY.add(a.mul(b)).div(RAY);\\n    }\\n\\n    /**\\n    * @dev divides two ray, rounding half up to the nearest ray\\n    * @param a ray\\n    * @param b ray\\n    * @return the result of a/b, in ray\\n    **/\\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 halfB = b / 2;\\n\\n        return halfB.add(a.mul(RAY)).div(b);\\n    }\\n\\n    /**\\n    * @dev casts ray down to wad\\n    * @param a ray\\n    * @return a casted to wad, rounded half up to the nearest wad\\n    **/\\n    function rayToWad(uint256 a) internal pure returns (uint256) {\\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\\n\\n        return halfRatio.add(a).div(WAD_RAY_RATIO);\\n    }\\n\\n    /**\\n    * @dev convert wad up to ray\\n    * @param a wad\\n    * @return a converted in ray\\n    **/\\n    function wadToRay(uint256 a) internal pure returns (uint256) {\\n        return a.mul(WAD_RAY_RATIO);\\n    }\\n\\n    /**\\n    * @dev calculates base^exp. The code uses the ModExp precompile\\n    * @return base^exp, in ray\\n    */\\n    //solium-disable-next-line\\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rayMul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rayMul(z, x);\\n            }\\n        }\\n    }\\n\\n}\\n\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\\n * available, which can be aplied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n */\\ncontract ReentrancyGuard {\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    constructor () internal {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(localCounter == _guardCounter, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n}\\n\\n\\n\\n/**\\n * @dev Collection of functions related to the address type,\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract's constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * > It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n}\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * > Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n/**\\n * @dev Implementation of the `IERC20` interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\n * For a generic mechanism see `ERC20Mintable`.\\n *\\n * *For a detailed writeup see our guide [How to implement supply\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See `IERC20.approve`.\\n */\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See `IERC20.totalSupply`.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.balanceOf`.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transfer`.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.allowance`.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.approve`.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transferFrom`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `value`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to `transfer`, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a `Transfer` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a `Transfer` event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n     /**\\n     * @dev Destoys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a `Transfer` event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See `_burn` and `_approve`.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\\n    }\\n}\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * > Note that this information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * `IERC20.balanceOf` and `IERC20.transfer`.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\n/**\\n * @title VersionedInitializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n *\\n * @author Aave, inspired by the OpenZeppelin Initializable contract\\n */\\ncontract VersionedInitializable {\\n    /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n    uint256 private lastInitializedRevision = 0;\\n\\n    /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n    bool private initializing;\\n\\n    /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n    modifier initializer() {\\n        uint256 revision = getRevision();\\n        require(initializing || isConstructor() || revision > lastInitializedRevision, \\\"Contract instance has already been initialized\\\");\\n\\n        bool isTopLevelCall = !initializing;\\n        if (isTopLevelCall) {\\n            initializing = true;\\n            lastInitializedRevision = revision;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            initializing = false;\\n        }\\n    }\\n\\n    /// @dev returns the revision number of the contract.\\n    /// Needs to be defined in the inherited class as a constant.\\n    function getRevision() internal pure returns(uint256);\\n\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function isConstructor() private view returns (bool) {\\n        // extcodesize checks the size of the code stored in an address, and\\n        // address returns the current address. Since the code is still not\\n        // deployed when running a constructor, any checks on its code size will\\n        // yield zero, making it an effective way to detect if a contract is\\n        // under construction or not.\\n        uint256 cs;\\n        //solium-disable-next-line\\n        assembly {\\n            cs := extcodesize(address)\\n        }\\n        return cs == 0;\\n    }\\n\\n    // Reserved storage space to allow for layout changes in the future.\\n    uint256[50] private ______gap;\\n}\\n\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * > Note: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\n/**\\n * @title Proxy\\n * @dev Implements delegation of calls to other contracts, with proper\\n * forwarding of return values and bubbling of failures.\\n * It defines a fallback function that delegates all calls to the address\\n * returned by the abstract _implementation() internal function.\\n */\\ncontract Proxy {\\n    /**\\n   * @dev Fallback function.\\n   * Implemented entirely in `_fallback`.\\n   */\\n    function() external payable {\\n        _fallback();\\n    }\\n\\n    /**\\n   * @return The Address of the implementation.\\n   */\\n    function _implementation() internal view returns (address);\\n\\n    /**\\n   * @dev Delegates execution to an implementation contract.\\n   * This is a low level function that doesn't return to its internal call site.\\n   * It will return to the external caller whatever the implementation returns.\\n   * @param implementation Address to delegate.\\n   */\\n    function _delegate(address implementation) internal {\\n        //solium-disable-next-line\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize)\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize)\\n\\n            switch result\\n                // delegatecall returns 0 on error.\\n                case 0 {\\n                    revert(0, returndatasize)\\n                }\\n                default {\\n                    return(0, returndatasize)\\n                }\\n        }\\n    }\\n\\n    /**\\n   * @dev Function that is run as the first thing in the fallback function.\\n   * Can be redefined in derived contracts to add functionality.\\n   * Redefinitions must call super._willFallback().\\n   */\\n    function _willFallback() internal {}\\n\\n    /**\\n   * @dev fallback implementation.\\n   * Extracted to enable manual triggering.\\n   */\\n    function _fallback() internal {\\n        _willFallback();\\n        _delegate(_implementation());\\n    }\\n}\\n\\n/**\\n * @title BaseUpgradeabilityProxy\\n * @dev This contract implements a proxy that allows to change the\\n * implementation address to which it will delegate.\\n * Such a change is called an implementation upgrade.\\n */\\ncontract BaseUpgradeabilityProxy is Proxy {\\n    /**\\n   * @dev Emitted when the implementation is upgraded.\\n   * @param implementation Address of the new implementation.\\n   */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n   * @dev Storage slot with the address of the current implementation.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n   * @dev Returns the current implementation.\\n   * @return Address of the current implementation\\n   */\\n    function _implementation() internal view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        //solium-disable-next-line\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n   * @dev Upgrades the proxy to a new implementation.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n   * @dev Sets the implementation address of the proxy.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n    function _setImplementation(address newImplementation) internal {\\n        require(\\n            Address.isContract(newImplementation),\\n            \\\"Cannot set a proxy implementation to a non-contract address\\\"\\n        );\\n\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n\\n        //solium-disable-next-line\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n}\\n\\n\\n\\n/**\\n * @title BaseAdminUpgradeabilityProxy\\n * @dev This contract combines an upgradeability proxy with an authorization\\n * mechanism for administrative tasks.\\n * All external functions in this contract must be guarded by the\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\n * feature proposal that would enable this to be done automatically.\\n */\\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\\n    /**\\n   * @dev Emitted when the administration has been transferred.\\n   * @param previousAdmin Address of the previous admin.\\n   * @param newAdmin Address of the new admin.\\n   */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n   * @dev Storage slot with the admin of the contract.\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n   * validated in the constructor.\\n   */\\n\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n   * @dev Modifier to check whether the `msg.sender` is the admin.\\n   * If it is, it will run the function. Otherwise, it will delegate the call\\n   * to the implementation.\\n   */\\n    modifier ifAdmin() {\\n        if (msg.sender == _admin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n   * @return The address of the proxy admin.\\n   */\\n    function admin() external ifAdmin returns (address) {\\n        return _admin();\\n    }\\n\\n    /**\\n   * @return The address of the implementation.\\n   */\\n    function implementation() external ifAdmin returns (address) {\\n        return _implementation();\\n    }\\n\\n    /**\\n   * @dev Changes the admin of the proxy.\\n   * Only the current admin can call this function.\\n   * @param newAdmin Address to transfer proxy administration to.\\n   */\\n    function changeAdmin(address newAdmin) external ifAdmin {\\n        require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\n        emit AdminChanged(_admin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n   * @dev Upgrade the backing implementation of the proxy.\\n   * Only the admin can call this function.\\n   * @param newImplementation Address of the new implementation.\\n   */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeTo(newImplementation);\\n    }\\n\\n    /**\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\n   * on the new implementation.\\n   * This is useful to initialize the proxied contract.\\n   * @param newImplementation Address of the new implementation.\\n   * @param data Data to send as msg.data in the low level call.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\n        _upgradeTo(newImplementation);\\n        (bool success, ) = newImplementation.delegatecall(data);\\n        require(success);\\n    }\\n\\n    /**\\n   * @return The admin slot.\\n   */\\n    function _admin() internal view returns (address adm) {\\n        bytes32 slot = ADMIN_SLOT;\\n        //solium-disable-next-line\\n        assembly {\\n            adm := sload(slot)\\n        }\\n    }\\n\\n    /**\\n   * @dev Sets the address of the proxy admin.\\n   * @param newAdmin Address of the new proxy admin.\\n   */\\n    function _setAdmin(address newAdmin) internal {\\n        bytes32 slot = ADMIN_SLOT;\\n        //solium-disable-next-line\\n        assembly {\\n            sstore(slot, newAdmin)\\n        }\\n    }\\n\\n    /**\\n   * @dev Only fall back when the sender is not the admin.\\n   */\\n    function _willFallback() internal {\\n        require(msg.sender != _admin(), \\\"Cannot call fallback function from the proxy admin\\\");\\n        super._willFallback();\\n    }\\n}\\n\\n/**\\n * @title UpgradeabilityProxy\\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\\n * implementation and init data.\\n */\\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\\n    /**\\n   * @dev Contract constructor.\\n   * @param _logic Address of the initial implementation.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n    constructor(address _logic, bytes memory _data) public payable {\\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _setImplementation(_logic);\\n        if (_data.length > 0) {\\n            (bool success, ) = _logic.delegatecall(_data);\\n            require(success);\\n        }\\n    }\\n}\\n\\n\\n\\n\\n/**\\n * @title AdminUpgradeabilityProxy\\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for\\n * initializing the implementation, admin, and init data.\\n */\\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\\n    /**\\n   * Contract constructor.\\n   * @param _logic address of the initial implementation.\\n   * @param _admin Address of the proxy administrator.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n    constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeabilityProxy(_logic, _data) {\\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _setAdmin(_admin);\\n    }\\n}\\n\\n\\n\\n/**\\n * @title InitializableUpgradeabilityProxy\\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\\n * implementation and init data.\\n */\\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\\n    /**\\n   * @dev Contract initializer.\\n   * @param _logic Address of the initial implementation.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n    function initialize(address _logic, bytes memory _data) public payable {\\n        require(_implementation() == address(0));\\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _setImplementation(_logic);\\n        if (_data.length > 0) {\\n            (bool success, ) = _logic.delegatecall(_data);\\n            require(success);\\n        }\\n    }\\n}\\n\\ncontract AddressStorage {\\n    mapping(bytes32 => address) private addresses;\\n\\n    function getAddress(bytes32 _key) public view returns (address) {\\n        return addresses[_key];\\n    }\\n\\n    function _setAddress(bytes32 _key, address _value) internal {\\n        addresses[_key] = _value;\\n    }\\n\\n}\\n\\n/**\\n * @title InitializableAdminUpgradeabilityProxy\\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for\\n * initializing the implementation, admin, and init data.\\n */\\ncontract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\\n    /**\\n   * Contract initializer.\\n   * @param _logic address of the initial implementation.\\n   * @param _admin Address of the proxy administrator.\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\n   * It should include the signature and the parameters of the function to be called, as described in\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\n   */\\n    function initialize(address _logic, address _admin, bytes memory _data) public payable {\\n        require(_implementation() == address(0));\\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _setAdmin(_admin);\\n    }\\n}\\n\\n\\n\\n/**\\n@title ILendingPoolAddressesProvider interface\\n@notice provides the interface to fetch the LendingPoolCore address\\n */\\n\\ncontract ILendingPoolAddressesProvider {\\n\\n    function getLendingPool() public view returns (address);\\n    function setLendingPoolImpl(address _pool) public;\\n\\n    function getLendingPoolCore() public view returns (address payable);\\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public;\\n\\n    function getLendingPoolConfigurator() public view returns (address);\\n    function setLendingPoolConfiguratorImpl(address _configurator) public;\\n\\n    function getLendingPoolDataProvider() public view returns (address);\\n    function setLendingPoolDataProviderImpl(address _provider) public;\\n\\n    function getLendingPoolParametersProvider() public view returns (address);\\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public;\\n\\n    function getTokenDistributor() public view returns (address);\\n    function setTokenDistributor(address _tokenDistributor) public;\\n\\n\\n    function getFeeProvider() public view returns (address);\\n    function setFeeProviderImpl(address _feeProvider) public;\\n\\n    function getLendingPoolLiquidationManager() public view returns (address);\\n    function setLendingPoolLiquidationManager(address _manager) public;\\n\\n    function getLendingPoolManager() public view returns (address);\\n    function setLendingPoolManager(address _lendingPoolManager) public;\\n\\n    function getPriceOracle() public view returns (address);\\n    function setPriceOracle(address _priceOracle) public;\\n\\n    function getLendingRateOracle() public view returns (address);\\n    function setLendingRateOracle(address _lendingRateOracle) public;\\n\\n}\\n\\n\\n\\n\\n/**\\n* @title LendingPoolAddressesProvider contract\\n* @notice Is the main registry of the protocol. All the different components of the protocol are accessible\\n* through the addresses provider.\\n* @author Aave\\n**/\\n\\ncontract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider, AddressStorage {\\n    //events\\n    event LendingPoolUpdated(address indexed newAddress);\\n    event LendingPoolCoreUpdated(address indexed newAddress);\\n    event LendingPoolParametersProviderUpdated(address indexed newAddress);\\n    event LendingPoolManagerUpdated(address indexed newAddress);\\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\\n    event LendingPoolLiquidationManagerUpdated(address indexed newAddress);\\n    event LendingPoolDataProviderUpdated(address indexed newAddress);\\n    event EthereumAddressUpdated(address indexed newAddress);\\n    event PriceOracleUpdated(address indexed newAddress);\\n    event LendingRateOracleUpdated(address indexed newAddress);\\n    event FeeProviderUpdated(address indexed newAddress);\\n    event TokenDistributorUpdated(address indexed newAddress);\\n\\n    event ProxyCreated(bytes32 id, address indexed newAddress);\\n\\n    bytes32 private constant LENDING_POOL = \\\"LENDING_POOL\\\";\\n    bytes32 private constant LENDING_POOL_CORE = \\\"LENDING_POOL_CORE\\\";\\n    bytes32 private constant LENDING_POOL_CONFIGURATOR = \\\"LENDING_POOL_CONFIGURATOR\\\";\\n    bytes32 private constant LENDING_POOL_PARAMETERS_PROVIDER = \\\"PARAMETERS_PROVIDER\\\";\\n    bytes32 private constant LENDING_POOL_MANAGER = \\\"LENDING_POOL_MANAGER\\\";\\n    bytes32 private constant LENDING_POOL_LIQUIDATION_MANAGER = \\\"LIQUIDATION_MANAGER\\\";\\n    bytes32 private constant LENDING_POOL_FLASHLOAN_PROVIDER = \\\"FLASHLOAN_PROVIDER\\\";\\n    bytes32 private constant DATA_PROVIDER = \\\"DATA_PROVIDER\\\";\\n    bytes32 private constant ETHEREUM_ADDRESS = \\\"ETHEREUM_ADDRESS\\\";\\n    bytes32 private constant PRICE_ORACLE = \\\"PRICE_ORACLE\\\";\\n    bytes32 private constant LENDING_RATE_ORACLE = \\\"LENDING_RATE_ORACLE\\\";\\n    bytes32 private constant FEE_PROVIDER = \\\"FEE_PROVIDER\\\";\\n    bytes32 private constant WALLET_BALANCE_PROVIDER = \\\"WALLET_BALANCE_PROVIDER\\\";\\n    bytes32 private constant TOKEN_DISTRIBUTOR = \\\"TOKEN_DISTRIBUTOR\\\";\\n\\n\\n    /**\\n    * @dev returns the address of the LendingPool proxy\\n    * @return the lending pool proxy address\\n    **/\\n    function getLendingPool() public view returns (address) {\\n        return getAddress(LENDING_POOL);\\n    }\\n\\n\\n    /**\\n    * @dev updates the implementation of the lending pool\\n    * @param _pool the new lending pool implementation\\n    **/\\n    function setLendingPoolImpl(address _pool) public onlyOwner {\\n        updateImplInternal(LENDING_POOL, _pool);\\n        emit LendingPoolUpdated(_pool);\\n    }\\n\\n    /**\\n    * @dev returns the address of the LendingPoolCore proxy\\n    * @return the lending pool core proxy address\\n     */\\n    function getLendingPoolCore() public view returns (address payable) {\\n        address payable core = address(uint160(getAddress(LENDING_POOL_CORE)));\\n        return core;\\n    }\\n\\n    /**\\n    * @dev updates the implementation of the lending pool core\\n    * @param _lendingPoolCore the new lending pool core implementation\\n    **/\\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public onlyOwner {\\n        updateImplInternal(LENDING_POOL_CORE, _lendingPoolCore);\\n        emit LendingPoolCoreUpdated(_lendingPoolCore);\\n    }\\n\\n    /**\\n    * @dev returns the address of the LendingPoolConfigurator proxy\\n    * @return the lending pool configurator proxy address\\n    **/\\n    function getLendingPoolConfigurator() public view returns (address) {\\n        return getAddress(LENDING_POOL_CONFIGURATOR);\\n    }\\n\\n    /**\\n    * @dev updates the implementation of the lending pool configurator\\n    * @param _configurator the new lending pool configurator implementation\\n    **/\\n    function setLendingPoolConfiguratorImpl(address _configurator) public onlyOwner {\\n        updateImplInternal(LENDING_POOL_CONFIGURATOR, _configurator);\\n        emit LendingPoolConfiguratorUpdated(_configurator);\\n    }\\n\\n    /**\\n    * @dev returns the address of the LendingPoolDataProvider proxy\\n    * @return the lending pool data provider proxy address\\n     */\\n    function getLendingPoolDataProvider() public view returns (address) {\\n        return getAddress(DATA_PROVIDER);\\n    }\\n\\n    /**\\n    * @dev updates the implementation of the lending pool data provider\\n    * @param _provider the new lending pool data provider implementation\\n    **/\\n    function setLendingPoolDataProviderImpl(address _provider) public onlyOwner {\\n        updateImplInternal(DATA_PROVIDER, _provider);\\n        emit LendingPoolDataProviderUpdated(_provider);\\n    }\\n\\n    /**\\n    * @dev returns the address of the LendingPoolParametersProvider proxy\\n    * @return the address of the Lending pool parameters provider proxy\\n    **/\\n    function getLendingPoolParametersProvider() public view returns (address) {\\n        return getAddress(LENDING_POOL_PARAMETERS_PROVIDER);\\n    }\\n\\n    /**\\n    * @dev updates the implementation of the lending pool parameters provider\\n    * @param _parametersProvider the new lending pool parameters provider implementation\\n    **/\\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public onlyOwner {\\n        updateImplInternal(LENDING_POOL_PARAMETERS_PROVIDER, _parametersProvider);\\n        emit LendingPoolParametersProviderUpdated(_parametersProvider);\\n    }\\n\\n    /**\\n    * @dev returns the address of the FeeProvider proxy\\n    * @return the address of the Fee provider proxy\\n    **/\\n    function getFeeProvider() public view returns (address) {\\n        return getAddress(FEE_PROVIDER);\\n    }\\n\\n    /**\\n    * @dev updates the implementation of the FeeProvider proxy\\n    * @param _feeProvider the new lending pool fee provider implementation\\n    **/\\n    function setFeeProviderImpl(address _feeProvider) public onlyOwner {\\n        updateImplInternal(FEE_PROVIDER, _feeProvider);\\n        emit FeeProviderUpdated(_feeProvider);\\n    }\\n\\n    /**\\n    * @dev returns the address of the LendingPoolLiquidationManager. Since the manager is used\\n    * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\\n    * the addresses are changed directly.\\n    * @return the address of the Lending pool liquidation manager\\n    **/\\n\\n    function getLendingPoolLiquidationManager() public view returns (address) {\\n        return getAddress(LENDING_POOL_LIQUIDATION_MANAGER);\\n    }\\n\\n    /**\\n    * @dev updates the address of the Lending pool liquidation manager\\n    * @param _manager the new lending pool liquidation manager address\\n    **/\\n    function setLendingPoolLiquidationManager(address _manager) public onlyOwner {\\n        _setAddress(LENDING_POOL_LIQUIDATION_MANAGER, _manager);\\n        emit LendingPoolLiquidationManagerUpdated(_manager);\\n    }\\n\\n    /**\\n    * @dev the functions below are storing specific addresses that are outside the context of the protocol\\n    * hence the upgradable proxy pattern is not used\\n    **/\\n\\n\\n    function getLendingPoolManager() public view returns (address) {\\n        return getAddress(LENDING_POOL_MANAGER);\\n    }\\n\\n    function setLendingPoolManager(address _lendingPoolManager) public onlyOwner {\\n        _setAddress(LENDING_POOL_MANAGER, _lendingPoolManager);\\n        emit LendingPoolManagerUpdated(_lendingPoolManager);\\n    }\\n\\n    function getPriceOracle() public view returns (address) {\\n        return getAddress(PRICE_ORACLE);\\n    }\\n\\n    function setPriceOracle(address _priceOracle) public onlyOwner {\\n        _setAddress(PRICE_ORACLE, _priceOracle);\\n        emit PriceOracleUpdated(_priceOracle);\\n    }\\n\\n    function getLendingRateOracle() public view returns (address) {\\n        return getAddress(LENDING_RATE_ORACLE);\\n    }\\n\\n    function setLendingRateOracle(address _lendingRateOracle) public onlyOwner {\\n        _setAddress(LENDING_RATE_ORACLE, _lendingRateOracle);\\n        emit LendingRateOracleUpdated(_lendingRateOracle);\\n    }\\n\\n\\n    function getTokenDistributor() public view returns (address) {\\n        return getAddress(TOKEN_DISTRIBUTOR);\\n    }\\n\\n    function setTokenDistributor(address _tokenDistributor) public onlyOwner {\\n        _setAddress(TOKEN_DISTRIBUTOR, _tokenDistributor);\\n        emit TokenDistributorUpdated(_tokenDistributor);\\n    }\\n\\n\\n    /**\\n    * @dev internal function to update the implementation of a specific component of the protocol\\n    * @param _id the id of the contract to be updated\\n    * @param _newAddress the address of the new implementation\\n    **/\\n    function updateImplInternal(bytes32 _id, address _newAddress) internal {\\n        address payable proxyAddress = address(uint160(getAddress(_id)));\\n\\n        InitializableAdminUpgradeabilityProxy proxy = InitializableAdminUpgradeabilityProxy(proxyAddress);\\n        bytes memory params = abi.encodeWithSignature(\\\"initialize(address)\\\", address(this));\\n\\n        if (proxyAddress == address(0)) {\\n            proxy = new InitializableAdminUpgradeabilityProxy();\\n            proxy.initialize(_newAddress, address(this), params);\\n            _setAddress(_id, address(proxy));\\n            emit ProxyCreated(_id, address(proxy));\\n        } else {\\n            proxy.upgradeToAndCall(_newAddress, params);\\n        }\\n\\n    }\\n}\\n\\ncontract UintStorage {\\n    mapping(bytes32 => uint256) private uints;\\n\\n    function getUint(bytes32 _key) public view returns (uint256) {\\n        return uints[_key];\\n    }\\n\\n    function _setUint(bytes32 _key, uint256 _value) internal {\\n        uints[_key] = _value;\\n    }\\n\\n}\\n\\n\\n/**\\n* @title LendingPoolParametersProvider\\n* @author Aave\\n* @notice stores the configuration parameters of the Lending Pool contract\\n**/\\n\\ncontract LendingPoolParametersProvider is VersionedInitializable {\\n\\n    uint256 private constant MAX_STABLE_RATE_BORROW_SIZE_PERCENT = 25;\\n    uint256 private constant REBALANCE_DOWN_RATE_DELTA = (1e27)/5;\\n    uint256 private constant FLASHLOAN_FEE_TOTAL = 35;\\n    uint256 private constant FLASHLOAN_FEE_PROTOCOL = 3000;\\n\\n    uint256 constant private DATA_PROVIDER_REVISION = 0x1;\\n\\n    function getRevision() internal pure returns(uint256) {\\n        return DATA_PROVIDER_REVISION;\\n    }\\n\\n    /**\\n    * @dev initializes the LendingPoolParametersProvider after it's added to the proxy\\n    * @param _addressesProvider the address of the LendingPoolAddressesProvider\\n    */\\n    function initialize(address _addressesProvider) public initializer {\\n    }\\n    /**\\n    * @dev returns the maximum stable rate borrow size, in percentage of the available liquidity.\\n    **/\\n    function getMaxStableRateBorrowSizePercent() external pure returns (uint256)  {\\n        return MAX_STABLE_RATE_BORROW_SIZE_PERCENT;\\n    }\\n\\n    /**\\n    * @dev returns the delta between the current stable rate and the user stable rate at\\n    *      which the borrow position of the user will be rebalanced (scaled down)\\n    **/\\n    function getRebalanceDownRateDelta() external pure returns (uint256) {\\n        return REBALANCE_DOWN_RATE_DELTA;\\n    }\\n\\n    /**\\n    * @dev returns the fee applied to a flashloan and the portion to redirect to the protocol, in basis points.\\n    **/\\n    function getFlashLoanFeesInBips() external pure returns (uint256, uint256) {\\n        return (FLASHLOAN_FEE_TOTAL, FLASHLOAN_FEE_PROTOCOL);\\n    }\\n}\\n\\n\\n/**\\n* @title CoreLibrary library\\n* @author Aave\\n* @notice Defines the data structures of the reserves and the user data\\n**/\\nlibrary CoreLibrary {\\n    using SafeMath for uint256;\\n    using WadRayMath for uint256;\\n\\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\\n\\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n\\n    struct UserReserveData {\\n        //principal amount borrowed by the user.\\n        uint256 principalBorrowBalance;\\n        //cumulated variable borrow index for the user. Expressed in ray\\n        uint256 lastVariableBorrowCumulativeIndex;\\n        //origination fee cumulated by the user\\n        uint256 originationFee;\\n        // stable borrow rate at which the user has borrowed. Expressed in ray\\n        uint256 stableBorrowRate;\\n        uint40 lastUpdateTimestamp;\\n        //defines if a specific deposit should or not be used as a collateral in borrows\\n        bool useAsCollateral;\\n    }\\n\\n    struct ReserveData {\\n        /**\\n        * @dev refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\n        **/\\n        //the liquidity index. Expressed in ray\\n        uint256 lastLiquidityCumulativeIndex;\\n        //the current supply rate. Expressed in ray\\n        uint256 currentLiquidityRate;\\n        //the total borrows of the reserve at a stable rate. Expressed in the currency decimals\\n        uint256 totalBorrowsStable;\\n        //the total borrows of the reserve at a variable rate. Expressed in the currency decimals\\n        uint256 totalBorrowsVariable;\\n        //the current variable borrow rate. Expressed in ray\\n        uint256 currentVariableBorrowRate;\\n        //the current stable borrow rate. Expressed in ray\\n        uint256 currentStableBorrowRate;\\n        //the current average stable borrow rate (weighted average of all the different stable rate loans). Expressed in ray\\n        uint256 currentAverageStableBorrowRate;\\n        //variable borrow index. Expressed in ray\\n        uint256 lastVariableBorrowCumulativeIndex;\\n        //the ltv of the reserve. Expressed in percentage (0-100)\\n        uint256 baseLTVasCollateral;\\n        //the liquidation threshold of the reserve. Expressed in percentage (0-100)\\n        uint256 liquidationThreshold;\\n        //the liquidation bonus of the reserve. Expressed in percentage\\n        uint256 liquidationBonus;\\n        //the decimals of the reserve asset\\n        uint256 decimals;\\n        /**\\n        * @dev address of the aToken representing the asset\\n        **/\\n        address aTokenAddress;\\n        /**\\n        * @dev address of the interest rate strategy contract\\n        **/\\n        address interestRateStrategyAddress;\\n        uint40 lastUpdateTimestamp;\\n        // borrowingEnabled = true means users can borrow from this reserve\\n        bool borrowingEnabled;\\n        // usageAsCollateralEnabled = true means users can use this reserve as collateral\\n        bool usageAsCollateralEnabled;\\n        // isStableBorrowRateEnabled = true means users can borrow at a stable rate\\n        bool isStableBorrowRateEnabled;\\n        // isActive = true means the reserve has been activated and properly configured\\n        bool isActive;\\n        // isFreezed = true means the reserve only allows repays and redeems, but not deposits, new borrowings or rate swap\\n        bool isFreezed;\\n    }\\n\\n    /**\\n    * @dev returns the ongoing normalized income for the reserve.\\n    * a value of 1e27 means there is no income. As time passes, the income is accrued.\\n    * A value of 2*1e27 means that the income of the reserve is double the initial amount.\\n    * @param _reserve the reserve object\\n    * @return the normalized income. expressed in ray\\n    **/\\n    function getNormalizedIncome(CoreLibrary.ReserveData storage _reserve)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 cumulated = calculateLinearInterest(\\n            _reserve\\n                .currentLiquidityRate,\\n            _reserve\\n                .lastUpdateTimestamp\\n        )\\n            .rayMul(_reserve.lastLiquidityCumulativeIndex);\\n\\n        return cumulated;\\n\\n    }\\n\\n    /**\\n    * @dev Updates the liquidity cumulative index Ci and variable borrow cumulative index Bvc. Refer to the whitepaper for\\n    * a formal specification.\\n    * @param _self the reserve object\\n    **/\\n    function updateCumulativeIndexes(ReserveData storage _self) internal {\\n        uint256 totalBorrows = getTotalBorrows(_self);\\n\\n        if (totalBorrows > 0) {\\n            //only cumulating if there is any income being produced\\n            uint256 cumulatedLiquidityInterest = calculateLinearInterest(\\n                _self.currentLiquidityRate,\\n                _self.lastUpdateTimestamp\\n            );\\n\\n            _self.lastLiquidityCumulativeIndex = cumulatedLiquidityInterest.rayMul(\\n                _self.lastLiquidityCumulativeIndex\\n            );\\n\\n            uint256 cumulatedVariableBorrowInterest = calculateCompoundedInterest(\\n                _self.currentVariableBorrowRate,\\n                _self.lastUpdateTimestamp\\n            );\\n            _self.lastVariableBorrowCumulativeIndex = cumulatedVariableBorrowInterest.rayMul(\\n                _self.lastVariableBorrowCumulativeIndex\\n            );\\n        }\\n    }\\n\\n    /**\\n    * @dev accumulates a predefined amount of asset to the reserve as a fixed, one time income. Used for example to accumulate\\n    * the flashloan fee to the reserve, and spread it through the depositors.\\n    * @param _self the reserve object\\n    * @param _totalLiquidity the total liquidity available in the reserve\\n    * @param _amount the amount to accomulate\\n    **/\\n    function cumulateToLiquidityIndex(\\n        ReserveData storage _self,\\n        uint256 _totalLiquidity,\\n        uint256 _amount\\n    ) internal {\\n        uint256 amountToLiquidityRatio = _amount.wadToRay().rayDiv(_totalLiquidity.wadToRay());\\n\\n        uint256 cumulatedLiquidity = amountToLiquidityRatio.add(WadRayMath.ray());\\n\\n        _self.lastLiquidityCumulativeIndex = cumulatedLiquidity.rayMul(\\n            _self.lastLiquidityCumulativeIndex\\n        );\\n    }\\n\\n    /**\\n    * @dev initializes a reserve\\n    * @param _self the reserve object\\n    * @param _aTokenAddress the address of the overlying atoken contract\\n    * @param _decimals the number of decimals of the underlying asset\\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\\n    **/\\n    function init(\\n        ReserveData storage _self,\\n        address _aTokenAddress,\\n        uint256 _decimals,\\n        address _interestRateStrategyAddress\\n    ) external {\\n        require(_self.aTokenAddress == address(0), \\\"Reserve has already been initialized\\\");\\n\\n        if (_self.lastLiquidityCumulativeIndex == 0) {\\n            //if the reserve has not been initialized yet\\n            _self.lastLiquidityCumulativeIndex = WadRayMath.ray();\\n        }\\n\\n        if (_self.lastVariableBorrowCumulativeIndex == 0) {\\n            _self.lastVariableBorrowCumulativeIndex = WadRayMath.ray();\\n        }\\n\\n        _self.aTokenAddress = _aTokenAddress;\\n        _self.decimals = _decimals;\\n\\n        _self.interestRateStrategyAddress = _interestRateStrategyAddress;\\n        _self.isActive = true;\\n        _self.isFreezed = false;\\n\\n    }\\n\\n    /**\\n    * @dev enables borrowing on a reserve\\n    * @param _self the reserve object\\n    * @param _stableBorrowRateEnabled true if the stable borrow rate must be enabled by default, false otherwise\\n    **/\\n    function enableBorrowing(ReserveData storage _self, bool _stableBorrowRateEnabled) external {\\n        require(_self.borrowingEnabled == false, \\\"Reserve is already enabled\\\");\\n\\n        _self.borrowingEnabled = true;\\n        _self.isStableBorrowRateEnabled = _stableBorrowRateEnabled;\\n\\n    }\\n\\n    /**\\n    * @dev disables borrowing on a reserve\\n    * @param _self the reserve object\\n    **/\\n    function disableBorrowing(ReserveData storage _self) external {\\n        _self.borrowingEnabled = false;\\n    }\\n\\n    /**\\n    * @dev enables a reserve to be used as collateral\\n    * @param _self the reserve object\\n    * @param _baseLTVasCollateral the loan to value of the asset when used as collateral\\n    * @param _liquidationThreshold the threshold at which loans using this asset as collateral will be considered undercollateralized\\n    * @param _liquidationBonus the bonus liquidators receive to liquidate this asset\\n    **/\\n    function enableAsCollateral(\\n        ReserveData storage _self,\\n        uint256 _baseLTVasCollateral,\\n        uint256 _liquidationThreshold,\\n        uint256 _liquidationBonus\\n    ) external {\\n        require(\\n            _self.usageAsCollateralEnabled == false,\\n            \\\"Reserve is already enabled as collateral\\\"\\n        );\\n\\n        _self.usageAsCollateralEnabled = true;\\n        _self.baseLTVasCollateral = _baseLTVasCollateral;\\n        _self.liquidationThreshold = _liquidationThreshold;\\n        _self.liquidationBonus = _liquidationBonus;\\n\\n        if (_self.lastLiquidityCumulativeIndex == 0)\\n            _self.lastLiquidityCumulativeIndex = WadRayMath.ray();\\n\\n    }\\n\\n    /**\\n    * @dev disables a reserve as collateral\\n    * @param _self the reserve object\\n    **/\\n    function disableAsCollateral(ReserveData storage _self) external {\\n        _self.usageAsCollateralEnabled = false;\\n    }\\n\\n\\n\\n    /**\\n    * @dev calculates the compounded borrow balance of a user\\n    * @param _self the userReserve object\\n    * @param _reserve the reserve object\\n    * @return the user compounded borrow balance\\n    **/\\n    function getCompoundedBorrowBalance(\\n        CoreLibrary.UserReserveData storage _self,\\n        CoreLibrary.ReserveData storage _reserve\\n    ) internal view returns (uint256) {\\n        if (_self.principalBorrowBalance == 0) return 0;\\n\\n        uint256 principalBorrowBalanceRay = _self.principalBorrowBalance.wadToRay();\\n        uint256 compoundedBalance = 0;\\n        uint256 cumulatedInterest = 0;\\n\\n        if (_self.stableBorrowRate > 0) {\\n            cumulatedInterest = calculateCompoundedInterest(\\n                _self.stableBorrowRate,\\n                _self.lastUpdateTimestamp\\n            );\\n        } else {\\n            //variable interest\\n            cumulatedInterest = calculateCompoundedInterest(\\n                _reserve\\n                    .currentVariableBorrowRate,\\n                _reserve\\n                    .lastUpdateTimestamp\\n            )\\n                .rayMul(_reserve.lastVariableBorrowCumulativeIndex)\\n                .rayDiv(_self.lastVariableBorrowCumulativeIndex);\\n        }\\n\\n        compoundedBalance = principalBorrowBalanceRay.rayMul(cumulatedInterest).rayToWad();\\n\\n        if (compoundedBalance == _self.principalBorrowBalance) {\\n            //solium-disable-next-line\\n            if (_self.lastUpdateTimestamp != block.timestamp) {\\n                //no interest cumulation because of the rounding - we add 1 wei\\n                //as symbolic cumulated interest to avoid interest free loans.\\n\\n                return _self.principalBorrowBalance.add(1 wei);\\n            }\\n        }\\n\\n        return compoundedBalance;\\n    }\\n\\n    /**\\n    * @dev increases the total borrows at a stable rate on a specific reserve and updates the\\n    * average stable rate consequently\\n    * @param _reserve the reserve object\\n    * @param _amount the amount to add to the total borrows stable\\n    * @param _rate the rate at which the amount has been borrowed\\n    **/\\n    function increaseTotalBorrowsStableAndUpdateAverageRate(\\n        ReserveData storage _reserve,\\n        uint256 _amount,\\n        uint256 _rate\\n    ) internal {\\n\\n        if(_amount == 0) {\\n            return;\\n        }\\n\\n        uint256 previousTotalBorrowStable = _reserve.totalBorrowsStable;\\n        //updating reserve borrows stable\\n        _reserve.totalBorrowsStable = _reserve.totalBorrowsStable.add(_amount);\\n\\n        //update the average stable rate\\n        //weighted average of all the borrows\\n        uint256 weightedLastBorrow = _amount.wadToRay().rayMul(_rate);\\n        uint256 weightedPreviousTotalBorrows = previousTotalBorrowStable.wadToRay().rayMul(\\n            _reserve.currentAverageStableBorrowRate\\n        );\\n\\n        _reserve.currentAverageStableBorrowRate = weightedLastBorrow\\n            .add(weightedPreviousTotalBorrows)\\n            .rayDiv(_reserve.totalBorrowsStable.wadToRay());\\n    }\\n\\n    /**\\n    * @dev decreases the total borrows at a stable rate on a specific reserve and updates the\\n    * average stable rate consequently\\n    * @param _reserve the reserve object\\n    * @param _amount the amount to substract to the total borrows stable\\n    * @param _rate the rate at which the amount has been repaid\\n    **/\\n    function decreaseTotalBorrowsStableAndUpdateAverageRate(\\n        ReserveData storage _reserve,\\n        uint256 _amount,\\n        uint256 _rate\\n    ) internal {\\n\\n        uint256 previousTotalBorrowStable = _reserve.totalBorrowsStable;\\n\\n       if (previousTotalBorrowStable == 0 || _amount >= previousTotalBorrowStable) {\\n            _reserve.totalBorrowsStable = 0;\\n            _reserve.currentAverageStableBorrowRate = 0; // no income if there are no stable rate borrows\\n            return;\\n        }\\n\\n        //updating reserve borrows stable\\n        _reserve.totalBorrowsStable = _reserve.totalBorrowsStable.sub(_amount);\\n\\n        //update the average stable rate\\n        //weighted average of all the borrows\\n        uint256 weightedLastBorrow = _amount.wadToRay().rayMul(_rate);\\n        uint256 weightedPreviousTotalBorrows = previousTotalBorrowStable.wadToRay().rayMul(\\n            _reserve.currentAverageStableBorrowRate\\n        );\\n\\n        if(\\n            weightedPreviousTotalBorrows <= weightedLastBorrow\\n        ) {\\n            _reserve.totalBorrowsStable = 0;\\n            _reserve.currentAverageStableBorrowRate = 0; // no income if there are no stable rate borrows\\n            return;\\n        }\\n\\n        _reserve.currentAverageStableBorrowRate = weightedPreviousTotalBorrows\\n            .sub(weightedLastBorrow)\\n            .rayDiv(_reserve.totalBorrowsStable.wadToRay());\\n    }\\n\\n    /**\\n    * @dev increases the total borrows at a variable rate\\n    * @param _reserve the reserve object\\n    * @param _amount the amount to add to the total borrows variable\\n    **/\\n    function increaseTotalBorrowsVariable(ReserveData storage _reserve, uint256 _amount) internal {\\n        _reserve.totalBorrowsVariable = _reserve.totalBorrowsVariable.add(_amount);\\n    }\\n\\n    /**\\n    * @dev decreases the total borrows at a variable rate\\n    * @param _reserve the reserve object\\n    * @param _amount the amount to substract to the total borrows variable\\n    **/\\n    function decreaseTotalBorrowsVariable(ReserveData storage _reserve, uint256 _amount) internal {\\n        require(\\n            _reserve.totalBorrowsVariable >= _amount,\\n            \\\"The amount that is being subtracted from the variable total borrows is incorrect\\\"\\n        );\\n        _reserve.totalBorrowsVariable = _reserve.totalBorrowsVariable.sub(_amount);\\n    }\\n\\n    /**\\n    * @dev function to calculate the interest using a linear interest rate formula\\n    * @param _rate the interest rate, in ray\\n    * @param _lastUpdateTimestamp the timestamp of the last update of the interest\\n    * @return the interest rate linearly accumulated during the timeDelta, in ray\\n    **/\\n\\n    function calculateLinearInterest(uint256 _rate, uint40 _lastUpdateTimestamp)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        //solium-disable-next-line\\n        uint256 timeDifference = block.timestamp.sub(uint256(_lastUpdateTimestamp));\\n\\n        uint256 timeDelta = timeDifference.wadToRay().rayDiv(SECONDS_PER_YEAR.wadToRay());\\n\\n        return _rate.rayMul(timeDelta).add(WadRayMath.ray());\\n    }\\n\\n    /**\\n    * @dev function to calculate the interest using a compounded interest rate formula\\n    * @param _rate the interest rate, in ray\\n    * @param _lastUpdateTimestamp the timestamp of the last update of the interest\\n    * @return the interest rate compounded during the timeDelta, in ray\\n    **/\\n    function calculateCompoundedInterest(uint256 _rate, uint40 _lastUpdateTimestamp)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        //solium-disable-next-line\\n        uint256 timeDifference = block.timestamp.sub(uint256(_lastUpdateTimestamp));\\n\\n        uint256 ratePerSecond = _rate.div(SECONDS_PER_YEAR);\\n\\n        return ratePerSecond.add(WadRayMath.ray()).rayPow(timeDifference);\\n    }\\n\\n    /**\\n    * @dev returns the total borrows on the reserve\\n    * @param _reserve the reserve object\\n    * @return the total borrows (stable + variable)\\n    **/\\n    function getTotalBorrows(CoreLibrary.ReserveData storage _reserve)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _reserve.totalBorrowsStable.add(_reserve.totalBorrowsVariable);\\n    }\\n\\n}\\n\\n\\n\\n\\n/**\\n* @title IPriceOracleGetter interface\\n* @notice Interface for the Aave price oracle.\\n**/\\n\\ninterface IPriceOracleGetter {\\n    /**\\n    * @dev returns the asset price in ETH\\n    * @param _asset the address of the asset\\n    * @return the ETH price of the asset\\n    **/\\n    function getAssetPrice(address _asset) external view returns (uint256);\\n}\\n\\n/**\\n* @title IFeeProvider interface\\n* @notice Interface for the Aave fee provider.\\n**/\\n\\ninterface IFeeProvider {\\n    function calculateLoanOriginationFee(address _user, uint256 _amount) external view returns (uint256);\\n    function getLoanOriginationFeePercentage() external view returns (uint256);\\n}\\n\\n/**\\n* @title LendingPoolDataProvider contract\\n* @author Aave\\n* @notice Implements functions to fetch data from the core, and aggregate them in order to allow computation\\n* on the compounded balances and the account balances in ETH\\n**/\\ncontract LendingPoolDataProvider is VersionedInitializable {\\n    using SafeMath for uint256;\\n    using WadRayMath for uint256;\\n\\n    LendingPoolCore public core;\\n    LendingPoolAddressesProvider public addressesProvider;\\n\\n    /**\\n    * @dev specifies the health factor threshold at which the user position is liquidated.\\n    * 1e18 by default, if the health factor drops below 1e18, the loan can be liquidated.\\n    **/\\n    uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18;\\n\\n    uint256 public constant DATA_PROVIDER_REVISION = 0x1;\\n\\n    function getRevision() internal pure returns (uint256) {\\n        return DATA_PROVIDER_REVISION;\\n    }\\n\\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\\n        addressesProvider = _addressesProvider;\\n        core = LendingPoolCore(_addressesProvider.getLendingPoolCore());\\n    }\\n\\n    /**\\n    * @dev struct to hold calculateUserGlobalData() local computations\\n    **/\\n    struct UserGlobalDataLocalVars {\\n        uint256 reserveUnitPrice;\\n        uint256 tokenUnit;\\n        uint256 compoundedLiquidityBalance;\\n        uint256 compoundedBorrowBalance;\\n        uint256 reserveDecimals;\\n        uint256 baseLtv;\\n        uint256 liquidationThreshold;\\n        uint256 originationFee;\\n        bool usageAsCollateralEnabled;\\n        bool userUsesReserveAsCollateral;\\n        address currentReserve;\\n    }\\n\\n    /**\\n    * @dev calculates the user data across the reserves.\\n    * this includes the total liquidity/collateral/borrow balances in ETH,\\n    * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\\n    * @param _user the address of the user\\n    * @return the total liquidity, total collateral, total borrow balances of the user in ETH.\\n    * also the average Ltv, liquidation threshold, and the health factor\\n    **/\\n    function calculateUserGlobalData(address _user)\\n        public\\n        view\\n        returns (\\n            uint256 totalLiquidityBalanceETH,\\n            uint256 totalCollateralBalanceETH,\\n            uint256 totalBorrowBalanceETH,\\n            uint256 totalFeesETH,\\n            uint256 currentLtv,\\n            uint256 currentLiquidationThreshold,\\n            uint256 healthFactor,\\n            bool healthFactorBelowThreshold\\n        )\\n    {\\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\\n\\n        // Usage of a memory struct of vars to avoid \\\"Stack too deep\\\" errors due to local variables\\n        UserGlobalDataLocalVars memory vars;\\n\\n        address[] memory reserves = core.getReserves();\\n\\n        for (uint256 i = 0; i < reserves.length; i++) {\\n            vars.currentReserve = reserves[i];\\n\\n            (\\n                vars.compoundedLiquidityBalance,\\n                vars.compoundedBorrowBalance,\\n                vars.originationFee,\\n                vars.userUsesReserveAsCollateral\\n            ) = core.getUserBasicReserveData(vars.currentReserve, _user);\\n\\n            if (vars.compoundedLiquidityBalance == 0 && vars.compoundedBorrowBalance == 0) {\\n                continue;\\n            }\\n\\n            //fetch reserve data\\n            (\\n                vars.reserveDecimals,\\n                vars.baseLtv,\\n                vars.liquidationThreshold,\\n                vars.usageAsCollateralEnabled\\n            ) = core.getReserveConfiguration(vars.currentReserve);\\n\\n            vars.tokenUnit = 10 ** vars.reserveDecimals;\\n            vars.reserveUnitPrice = oracle.getAssetPrice(vars.currentReserve);\\n\\n            //liquidity and collateral balance\\n            if (vars.compoundedLiquidityBalance > 0) {\\n                uint256 liquidityBalanceETH = vars\\n                    .reserveUnitPrice\\n                    .mul(vars.compoundedLiquidityBalance)\\n                    .div(vars.tokenUnit);\\n                totalLiquidityBalanceETH = totalLiquidityBalanceETH.add(liquidityBalanceETH);\\n\\n                if (vars.usageAsCollateralEnabled && vars.userUsesReserveAsCollateral) {\\n                    totalCollateralBalanceETH = totalCollateralBalanceETH.add(liquidityBalanceETH);\\n                    currentLtv = currentLtv.add(liquidityBalanceETH.mul(vars.baseLtv));\\n                    currentLiquidationThreshold = currentLiquidationThreshold.add(\\n                        liquidityBalanceETH.mul(vars.liquidationThreshold)\\n                    );\\n                }\\n            }\\n\\n            if (vars.compoundedBorrowBalance > 0) {\\n                totalBorrowBalanceETH = totalBorrowBalanceETH.add(\\n                    vars.reserveUnitPrice.mul(vars.compoundedBorrowBalance).div(vars.tokenUnit)\\n                );\\n                totalFeesETH = totalFeesETH.add(\\n                    vars.originationFee.mul(vars.reserveUnitPrice).div(vars.tokenUnit)\\n                );\\n            }\\n        }\\n\\n        currentLtv = totalCollateralBalanceETH > 0 ? currentLtv.div(totalCollateralBalanceETH) : 0;\\n        currentLiquidationThreshold = totalCollateralBalanceETH > 0\\n            ? currentLiquidationThreshold.div(totalCollateralBalanceETH)\\n            : 0;\\n\\n        healthFactor = calculateHealthFactorFromBalancesInternal(\\n            totalCollateralBalanceETH,\\n            totalBorrowBalanceETH,\\n            totalFeesETH,\\n            currentLiquidationThreshold\\n        );\\n        healthFactorBelowThreshold = healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\\n\\n    }\\n\\n    struct balanceDecreaseAllowedLocalVars {\\n        uint256 decimals;\\n        uint256 collateralBalanceETH;\\n        uint256 borrowBalanceETH;\\n        uint256 totalFeesETH;\\n        uint256 currentLiquidationThreshold;\\n        uint256 reserveLiquidationThreshold;\\n        uint256 amountToDecreaseETH;\\n        uint256 collateralBalancefterDecrease;\\n        uint256 liquidationThresholdAfterDecrease;\\n        uint256 healthFactorAfterDecrease;\\n        bool reserveUsageAsCollateralEnabled;\\n    }\\n\\n    /**\\n    * @dev check if a specific balance decrease is allowed (i.e. doesn't bring the user borrow position health factor under 1e18)\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user\\n    * @param _amount the amount to decrease\\n    * @return true if the decrease of the balance is allowed\\n    **/\\n\\n    function balanceDecreaseAllowed(address _reserve, address _user, uint256 _amount)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        // Usage of a memory struct of vars to avoid \\\"Stack too deep\\\" errors due to local variables\\n        balanceDecreaseAllowedLocalVars memory vars;\\n\\n        (\\n            vars.decimals,\\n            ,\\n            vars.reserveLiquidationThreshold,\\n            vars.reserveUsageAsCollateralEnabled\\n        ) = core.getReserveConfiguration(_reserve);\\n\\n        if (\\n            !vars.reserveUsageAsCollateralEnabled ||\\n            !core.isUserUseReserveAsCollateralEnabled(_reserve, _user)\\n        ) {\\n            return true; //if reserve is not used as collateral, no reasons to block the transfer\\n        }\\n\\n        (\\n            ,\\n            vars.collateralBalanceETH,\\n            vars.borrowBalanceETH,\\n            vars.totalFeesETH,\\n            ,\\n            vars.currentLiquidationThreshold,\\n            ,\\n\\n        ) = calculateUserGlobalData(_user);\\n\\n        if (vars.borrowBalanceETH == 0) {\\n            return true; //no borrows - no reasons to block the transfer\\n        }\\n\\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\\n\\n        vars.amountToDecreaseETH = oracle.getAssetPrice(_reserve).mul(_amount).div(\\n            10 ** vars.decimals\\n        );\\n\\n        vars.collateralBalancefterDecrease = vars.collateralBalanceETH.sub(\\n            vars.amountToDecreaseETH\\n        );\\n\\n        //if there is a borrow, there can't be 0 collateral\\n        if (vars.collateralBalancefterDecrease == 0) {\\n            return false;\\n        }\\n\\n        vars.liquidationThresholdAfterDecrease = vars\\n            .collateralBalanceETH\\n            .mul(vars.currentLiquidationThreshold)\\n            .sub(vars.amountToDecreaseETH.mul(vars.reserveLiquidationThreshold))\\n            .div(vars.collateralBalancefterDecrease);\\n\\n        uint256 healthFactorAfterDecrease = calculateHealthFactorFromBalancesInternal(\\n            vars.collateralBalancefterDecrease,\\n            vars.borrowBalanceETH,\\n            vars.totalFeesETH,\\n            vars.liquidationThresholdAfterDecrease\\n        );\\n\\n        return healthFactorAfterDecrease > HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\\n\\n    }\\n\\n    /**\\n   * @notice calculates the amount of collateral needed in ETH to cover a new borrow.\\n   * @param _reserve the reserve from which the user wants to borrow\\n   * @param _amount the amount the user wants to borrow\\n   * @param _fee the fee for the amount that the user needs to cover\\n   * @param _userCurrentBorrowBalanceTH the current borrow balance of the user (before the borrow)\\n   * @param _userCurrentLtv the average ltv of the user given his current collateral\\n   * @return the total amount of collateral in ETH to cover the current borrow balance + the new amount + fee\\n   **/\\n    function calculateCollateralNeededInETH(\\n        address _reserve,\\n        uint256 _amount,\\n        uint256 _fee,\\n        uint256 _userCurrentBorrowBalanceTH,\\n        uint256 _userCurrentFeesETH,\\n        uint256 _userCurrentLtv\\n    ) external view returns (uint256) {\\n        uint256 reserveDecimals = core.getReserveDecimals(_reserve);\\n\\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\\n\\n        uint256 requestedBorrowAmountETH = oracle\\n            .getAssetPrice(_reserve)\\n            .mul(_amount.add(_fee))\\n            .div(10 ** reserveDecimals); //price is in ether\\n\\n        //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\\n        uint256 collateralNeededInETH = _userCurrentBorrowBalanceTH\\n            .add(_userCurrentFeesETH)\\n            .add(requestedBorrowAmountETH)\\n            .mul(100)\\n            .div(_userCurrentLtv); //LTV is calculated in percentage\\n\\n        return collateralNeededInETH;\\n\\n    }\\n\\n    /**\\n    * @dev calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the\\n    * average Loan To Value.\\n    * @param collateralBalanceETH the total collateral balance\\n    * @param borrowBalanceETH the total borrow balance\\n    * @param totalFeesETH the total fees\\n    * @param ltv the average loan to value\\n    * @return the amount available to borrow in ETH for the user\\n    **/\\n\\n    function calculateAvailableBorrowsETHInternal(\\n        uint256 collateralBalanceETH,\\n        uint256 borrowBalanceETH,\\n        uint256 totalFeesETH,\\n        uint256 ltv\\n    ) internal view returns (uint256) {\\n        uint256 availableBorrowsETH = collateralBalanceETH.mul(ltv).div(100); //ltv is in percentage\\n\\n        if (availableBorrowsETH < borrowBalanceETH) {\\n            return 0;\\n        }\\n\\n        availableBorrowsETH = availableBorrowsETH.sub(borrowBalanceETH.add(totalFeesETH));\\n        //calculate fee\\n        uint256 borrowFee = IFeeProvider(addressesProvider.getFeeProvider())\\n            .calculateLoanOriginationFee(msg.sender, availableBorrowsETH);\\n        return availableBorrowsETH.sub(borrowFee);\\n    }\\n\\n    /**\\n    * @dev calculates the health factor from the corresponding balances\\n    * @param collateralBalanceETH the total collateral balance in ETH\\n    * @param borrowBalanceETH the total borrow balance in ETH\\n    * @param totalFeesETH the total fees in ETH\\n    * @param liquidationThreshold the avg liquidation threshold\\n    **/\\n    function calculateHealthFactorFromBalancesInternal(\\n        uint256 collateralBalanceETH,\\n        uint256 borrowBalanceETH,\\n        uint256 totalFeesETH,\\n        uint256 liquidationThreshold\\n    ) internal pure returns (uint256) {\\n        if (borrowBalanceETH == 0) return uint256(-1);\\n\\n        return\\n            (collateralBalanceETH.mul(liquidationThreshold).div(100)).wadDiv(\\n                borrowBalanceETH.add(totalFeesETH)\\n            );\\n    }\\n\\n    /**\\n    * @dev returns the health factor liquidation threshold\\n    **/\\n    function getHealthFactorLiquidationThreshold() public pure returns (uint256) {\\n        return HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\\n    }\\n\\n    /**\\n    * @dev accessory functions to fetch data from the lendingPoolCore\\n    **/\\n    function getReserveConfigurationData(address _reserve)\\n        external\\n        view\\n        returns (\\n            uint256 ltv,\\n            uint256 liquidationThreshold,\\n            uint256 liquidationBonus,\\n            address rateStrategyAddress,\\n            bool usageAsCollateralEnabled,\\n            bool borrowingEnabled,\\n            bool stableBorrowRateEnabled,\\n            bool isActive\\n        )\\n    {\\n        (, ltv, liquidationThreshold, usageAsCollateralEnabled) = core.getReserveConfiguration(\\n            _reserve\\n        );\\n        stableBorrowRateEnabled = core.getReserveIsStableBorrowRateEnabled(_reserve);\\n        borrowingEnabled = core.isReserveBorrowingEnabled(_reserve);\\n        isActive = core.getReserveIsActive(_reserve);\\n        liquidationBonus = core.getReserveLiquidationBonus(_reserve);\\n\\n        rateStrategyAddress = core.getReserveInterestRateStrategyAddress(_reserve);\\n    }\\n\\n    function getReserveData(address _reserve)\\n        external\\n        view\\n        returns (\\n            uint256 totalLiquidity,\\n            uint256 availableLiquidity,\\n            uint256 totalBorrowsStable,\\n            uint256 totalBorrowsVariable,\\n            uint256 liquidityRate,\\n            uint256 variableBorrowRate,\\n            uint256 stableBorrowRate,\\n            uint256 averageStableBorrowRate,\\n            uint256 utilizationRate,\\n            uint256 liquidityIndex,\\n            uint256 variableBorrowIndex,\\n            address aTokenAddress,\\n            uint40 lastUpdateTimestamp\\n        )\\n    {\\n        totalLiquidity = core.getReserveTotalLiquidity(_reserve);\\n        availableLiquidity = core.getReserveAvailableLiquidity(_reserve);\\n        totalBorrowsStable = core.getReserveTotalBorrowsStable(_reserve);\\n        totalBorrowsVariable = core.getReserveTotalBorrowsVariable(_reserve);\\n        liquidityRate = core.getReserveCurrentLiquidityRate(_reserve);\\n        variableBorrowRate = core.getReserveCurrentVariableBorrowRate(_reserve);\\n        stableBorrowRate = core.getReserveCurrentStableBorrowRate(_reserve);\\n        averageStableBorrowRate = core.getReserveCurrentAverageStableBorrowRate(_reserve);\\n        utilizationRate = core.getReserveUtilizationRate(_reserve);\\n        liquidityIndex = core.getReserveLiquidityCumulativeIndex(_reserve);\\n        variableBorrowIndex = core.getReserveVariableBorrowsCumulativeIndex(_reserve);\\n        aTokenAddress = core.getReserveATokenAddress(_reserve);\\n        lastUpdateTimestamp = core.getReserveLastUpdate(_reserve);\\n    }\\n\\n    function getUserAccountData(address _user)\\n        external\\n        view\\n        returns (\\n            uint256 totalLiquidityETH,\\n            uint256 totalCollateralETH,\\n            uint256 totalBorrowsETH,\\n            uint256 totalFeesETH,\\n            uint256 availableBorrowsETH,\\n            uint256 currentLiquidationThreshold,\\n            uint256 ltv,\\n            uint256 healthFactor\\n        )\\n    {\\n        (\\n            totalLiquidityETH,\\n            totalCollateralETH,\\n            totalBorrowsETH,\\n            totalFeesETH,\\n            ltv,\\n            currentLiquidationThreshold,\\n            healthFactor,\\n\\n        ) = calculateUserGlobalData(_user);\\n\\n        availableBorrowsETH = calculateAvailableBorrowsETHInternal(\\n            totalCollateralETH,\\n            totalBorrowsETH,\\n            totalFeesETH,\\n            ltv\\n        );\\n    }\\n\\n    function getUserReserveData(address _reserve, address _user)\\n        external\\n        view\\n        returns (\\n            uint256 currentATokenBalance,\\n            uint256 currentBorrowBalance,\\n            uint256 principalBorrowBalance,\\n            uint256 borrowRateMode,\\n            uint256 borrowRate,\\n            uint256 liquidityRate,\\n            uint256 originationFee,\\n            uint256 variableBorrowIndex,\\n            uint256 lastUpdateTimestamp,\\n            bool usageAsCollateralEnabled\\n        )\\n    {\\n        currentATokenBalance = AToken(core.getReserveATokenAddress(_reserve)).balanceOf(_user);\\n        CoreLibrary.InterestRateMode mode = core.getUserCurrentBorrowRateMode(_reserve, _user);\\n        (principalBorrowBalance, currentBorrowBalance, ) = core.getUserBorrowBalances(\\n            _reserve,\\n            _user\\n        );\\n\\n        //default is 0, if mode == CoreLibrary.InterestRateMode.NONE\\n        if (mode == CoreLibrary.InterestRateMode.STABLE) {\\n            borrowRate = core.getUserCurrentStableBorrowRate(_reserve, _user);\\n        } else if (mode == CoreLibrary.InterestRateMode.VARIABLE) {\\n            borrowRate = core.getReserveCurrentVariableBorrowRate(_reserve);\\n        }\\n\\n        borrowRateMode = uint256(mode);\\n        liquidityRate = core.getReserveCurrentLiquidityRate(_reserve);\\n        originationFee = core.getUserOriginationFee(_reserve, _user);\\n        variableBorrowIndex = core.getUserVariableBorrowCumulativeIndex(_reserve, _user);\\n        lastUpdateTimestamp = core.getUserLastUpdate(_reserve, _user);\\n        usageAsCollateralEnabled = core.isUserUseReserveAsCollateralEnabled(_reserve, _user);\\n    }\\n}\\n\\n\\n/**\\n * @title Aave ERC20 AToken\\n *\\n * @dev Implementation of the interest bearing token for the DLP protocol.\\n * @author Aave\\n */\\ncontract AToken is ERC20, ERC20Detailed {\\n    using WadRayMath for uint256;\\n\\n    uint256 public constant UINT_MAX_VALUE = uint256(-1);\\n\\n    /**\\n    * @dev emitted after the redeem action\\n    * @param _from the address performing the redeem\\n    * @param _value the amount to be redeemed\\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\\n    * @param _fromIndex the last index of the user\\n    **/\\n    event Redeem(\\n        address indexed _from,\\n        uint256 _value,\\n        uint256 _fromBalanceIncrease,\\n        uint256 _fromIndex\\n    );\\n\\n    /**\\n    * @dev emitted after the mint action\\n    * @param _from the address performing the mint\\n    * @param _value the amount to be minted\\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\\n    * @param _fromIndex the last index of the user\\n    **/\\n    event MintOnDeposit(\\n        address indexed _from,\\n        uint256 _value,\\n        uint256 _fromBalanceIncrease,\\n        uint256 _fromIndex\\n    );\\n\\n    /**\\n    * @dev emitted during the liquidation action, when the liquidator reclaims the underlying\\n    * asset\\n    * @param _from the address from which the tokens are being burned\\n    * @param _value the amount to be burned\\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\\n    * @param _fromIndex the last index of the user\\n    **/\\n    event BurnOnLiquidation(\\n        address indexed _from,\\n        uint256 _value,\\n        uint256 _fromBalanceIncrease,\\n        uint256 _fromIndex\\n    );\\n\\n    /**\\n    * @dev emitted during the transfer action\\n    * @param _from the address from which the tokens are being transferred\\n    * @param _to the adress of the destination\\n    * @param _value the amount to be minted\\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\\n    * @param _toBalanceIncrease the cumulated balance since the last update of the destination\\n    * @param _fromIndex the last index of the user\\n    * @param _toIndex the last index of the liquidator\\n    **/\\n    event BalanceTransfer(\\n        address indexed _from,\\n        address indexed _to,\\n        uint256 _value,\\n        uint256 _fromBalanceIncrease,\\n        uint256 _toBalanceIncrease,\\n        uint256 _fromIndex,\\n        uint256 _toIndex\\n    );\\n\\n    /**\\n    * @dev emitted when the accumulation of the interest\\n    * by an user is redirected to another user\\n    * @param _from the address from which the interest is being redirected\\n    * @param _to the adress of the destination\\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\\n    * @param _fromIndex the last index of the user\\n    **/\\n    event InterestStreamRedirected(\\n        address indexed _from,\\n        address indexed _to,\\n        uint256 _redirectedBalance,\\n        uint256 _fromBalanceIncrease,\\n        uint256 _fromIndex\\n    );\\n\\n    /**\\n    * @dev emitted when the redirected balance of an user is being updated\\n    * @param _targetAddress the address of which the balance is being updated\\n    * @param _targetBalanceIncrease the cumulated balance since the last update of the target\\n    * @param _targetIndex the last index of the user\\n    * @param _redirectedBalanceAdded the redirected balance being added\\n    * @param _redirectedBalanceRemoved the redirected balance being removed\\n    **/\\n    event RedirectedBalanceUpdated(\\n        address indexed _targetAddress,\\n        uint256 _targetBalanceIncrease,\\n        uint256 _targetIndex,\\n        uint256 _redirectedBalanceAdded,\\n        uint256 _redirectedBalanceRemoved\\n    );\\n\\n    event InterestRedirectionAllowanceChanged(\\n        address indexed _from,\\n        address indexed _to\\n    );\\n\\n    address public underlyingAssetAddress;\\n\\n    mapping (address => uint256) private userIndexes;\\n    mapping (address => address) private interestRedirectionAddresses;\\n    mapping (address => uint256) private redirectedBalances;\\n    mapping (address => address) private interestRedirectionAllowances;\\n\\n    LendingPoolAddressesProvider private addressesProvider;\\n    LendingPoolCore private core;\\n    LendingPool private pool;\\n    LendingPoolDataProvider private dataProvider;\\n\\n    modifier onlyLendingPool {\\n        require(\\n            msg.sender == address(pool),\\n            \\\"The caller of this function must be a lending pool\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier whenTransferAllowed(address _from, uint256 _amount) {\\n        require(isTransferAllowed(_from, _amount), \\\"Transfer cannot be allowed.\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        LendingPoolAddressesProvider _addressesProvider,\\n        address _underlyingAsset,\\n        uint8 _underlyingAssetDecimals,\\n        string memory _name,\\n        string memory _symbol\\n    ) public ERC20Detailed(_name, _symbol, _underlyingAssetDecimals) {\\n\\n        addressesProvider = _addressesProvider;\\n        core = LendingPoolCore(addressesProvider.getLendingPoolCore());\\n        pool = LendingPool(addressesProvider.getLendingPool());\\n        dataProvider = LendingPoolDataProvider(addressesProvider.getLendingPoolDataProvider());\\n        underlyingAssetAddress = _underlyingAsset;\\n    }\\n\\n    /**\\n     * @notice ERC20 implementation internal function backing transfer() and transferFrom()\\n     * @dev validates the transfer before allowing it. NOTE: This is not standard ERC20 behavior\\n     **/\\n    function _transfer(address _from, address _to, uint256 _amount) internal whenTransferAllowed(_from, _amount) {\\n\\n        executeTransferInternal(_from, _to, _amount);\\n    }\\n\\n\\n    /**\\n    * @dev redirects the interest generated to a target address.\\n    * when the interest is redirected, the user balance is added to\\n    * the recepient redirected balance.\\n    * @param _to the address to which the interest will be redirected\\n    **/\\n    function redirectInterestStream(address _to) external {\\n        redirectInterestStreamInternal(msg.sender, _to);\\n    }\\n\\n    /**\\n    * @dev redirects the interest generated by _from to a target address.\\n    * when the interest is redirected, the user balance is added to\\n    * the recepient redirected balance. The caller needs to have allowance on\\n    * the interest redirection to be able to execute the function.\\n    * @param _from the address of the user whom interest is being redirected\\n    * @param _to the address to which the interest will be redirected\\n    **/\\n    function redirectInterestStreamOf(address _from, address _to) external {\\n        require(\\n            msg.sender == interestRedirectionAllowances[_from],\\n            \\\"Caller is not allowed to redirect the interest of the user\\\"\\n        );\\n        redirectInterestStreamInternal(_from,_to);\\n    }\\n\\n    /**\\n    * @dev gives allowance to an address to execute the interest redirection\\n    * on behalf of the caller.\\n    * @param _to the address to which the interest will be redirected. Pass address(0) to reset\\n    * the allowance.\\n    **/\\n    function allowInterestRedirectionTo(address _to) external {\\n        require(_to != msg.sender, \\\"User cannot give allowance to himself\\\");\\n        interestRedirectionAllowances[msg.sender] = _to;\\n        emit InterestRedirectionAllowanceChanged(\\n            msg.sender,\\n            _to\\n        );\\n    }\\n\\n    /**\\n    * @dev redeems aToken for the underlying asset\\n    * @param _amount the amount being redeemed\\n    **/\\n    function redeem(uint256 _amount) external {\\n\\n        require(_amount > 0, \\\"Amount to redeem needs to be > 0\\\");\\n\\n        //cumulates the balance of the user\\n        (,\\n        uint256 currentBalance,\\n        uint256 balanceIncrease,\\n        uint256 index) = cumulateBalanceInternal(msg.sender);\\n\\n        uint256 amountToRedeem = _amount;\\n\\n        //if amount is equal to uint(-1), the user wants to redeem everything\\n        if(_amount == UINT_MAX_VALUE){\\n            amountToRedeem = currentBalance;\\n        }\\n\\n        require(amountToRedeem <= currentBalance, \\\"User cannot redeem more than the available balance\\\");\\n\\n        //check that the user is allowed to redeem the amount\\n        require(isTransferAllowed(msg.sender, amountToRedeem), \\\"Transfer cannot be allowed.\\\");\\n\\n        //if the user is redirecting his interest towards someone else,\\n        //we update the redirected balance of the redirection address by adding the accrued interest,\\n        //and removing the amount to redeem\\n        updateRedirectedBalanceOfRedirectionAddressInternal(msg.sender, balanceIncrease, amountToRedeem);\\n\\n        // burns tokens equivalent to the amount requested\\n        _burn(msg.sender, amountToRedeem);\\n\\n        bool userIndexReset = false;\\n        //reset the user data if the remaining balance is 0\\n        if(currentBalance.sub(amountToRedeem) == 0){\\n            userIndexReset = resetDataOnZeroBalanceInternal(msg.sender);\\n        }\\n\\n        // executes redeem of the underlying asset\\n        pool.redeemUnderlying(\\n            underlyingAssetAddress,\\n            msg.sender,\\n            amountToRedeem,\\n            currentBalance.sub(amountToRedeem)\\n        );\\n\\n        emit Redeem(msg.sender, amountToRedeem, balanceIncrease, userIndexReset ? 0 : index);\\n    }\\n\\n    /**\\n     * @dev mints token in the event of users depositing the underlying asset into the lending pool\\n     * only lending pools can call this function\\n     * @param _account the address receiving the minted tokens\\n     * @param _amount the amount of tokens to mint\\n     */\\n    function mintOnDeposit(address _account, uint256 _amount) external onlyLendingPool {\\n\\n        //cumulates the balance of the user\\n        (,\\n        ,\\n        uint256 balanceIncrease,\\n        uint256 index) = cumulateBalanceInternal(_account);\\n\\n         //if the user is redirecting his interest towards someone else,\\n        //we update the redirected balance of the redirection address by adding the accrued interest\\n        //and the amount deposited\\n        updateRedirectedBalanceOfRedirectionAddressInternal(_account, balanceIncrease.add(_amount), 0);\\n\\n        //mint an equivalent amount of tokens to cover the new deposit\\n        _mint(_account, _amount);\\n\\n        emit MintOnDeposit(_account, _amount, balanceIncrease, index);\\n    }\\n\\n    /**\\n     * @dev burns token in the event of a borrow being liquidated, in case the liquidators reclaims the underlying asset\\n     * Transfer of the liquidated asset is executed by the lending pool contract.\\n     * only lending pools can call this function\\n     * @param _account the address from which burn the aTokens\\n     * @param _value the amount to burn\\n     **/\\n    function burnOnLiquidation(address _account, uint256 _value) external onlyLendingPool {\\n\\n        //cumulates the balance of the user being liquidated\\n        (,uint256 accountBalance,uint256 balanceIncrease,uint256 index) = cumulateBalanceInternal(_account);\\n\\n        //adds the accrued interest and substracts the burned amount to\\n        //the redirected balance\\n        updateRedirectedBalanceOfRedirectionAddressInternal(_account, balanceIncrease, _value);\\n\\n        //burns the requested amount of tokens\\n        _burn(_account, _value);\\n\\n        bool userIndexReset = false;\\n        //reset the user data if the remaining balance is 0\\n        if(accountBalance.sub(_value) == 0){\\n            userIndexReset = resetDataOnZeroBalanceInternal(_account);\\n        }\\n\\n        emit BurnOnLiquidation(_account, _value, balanceIncrease, userIndexReset ? 0 : index);\\n    }\\n\\n    /**\\n     * @dev transfers tokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\\n     *      only lending pools can call this function\\n     * @param _from the address from which transfer the aTokens\\n     * @param _to the destination address\\n     * @param _value the amount to transfer\\n     **/\\n    function transferOnLiquidation(address _from, address _to, uint256 _value) external onlyLendingPool {\\n\\n        //being a normal transfer, the Transfer() and BalanceTransfer() are emitted\\n        //so no need to emit a specific event here\\n        executeTransferInternal(_from, _to, _value);\\n    }\\n\\n    /**\\n    * @dev calculates the balance of the user, which is the\\n    * principal balance + interest generated by the principal balance + interest generated by the redirected balance\\n    * @param _user the user for which the balance is being calculated\\n    * @return the total balance of the user\\n    **/\\n    function balanceOf(address _user) public view returns(uint256) {\\n\\n        //current principal balance of the user\\n        uint256 currentPrincipalBalance = super.balanceOf(_user);\\n        //balance redirected by other users to _user for interest rate accrual\\n        uint256 redirectedBalance = redirectedBalances[_user];\\n\\n        if(currentPrincipalBalance == 0 && redirectedBalance == 0){\\n            return 0;\\n        }\\n        //if the _user is not redirecting the interest to anybody, accrues\\n        //the interest for himself\\n\\n        if(interestRedirectionAddresses[_user] == address(0)){\\n\\n            //accruing for himself means that both the principal balance and\\n            //the redirected balance partecipate in the interest\\n            return calculateCumulatedBalanceInternal(\\n                _user,\\n                currentPrincipalBalance.add(redirectedBalance)\\n                )\\n                .sub(redirectedBalance);\\n        }\\n        else {\\n            //if the user redirected the interest, then only the redirected\\n            //balance generates interest. In that case, the interest generated\\n            //by the redirected balance is added to the current principal balance.\\n            return currentPrincipalBalance.add(\\n                calculateCumulatedBalanceInternal(\\n                    _user,\\n                    redirectedBalance\\n                )\\n                .sub(redirectedBalance)\\n            );\\n        }\\n    }\\n\\n    /**\\n    * @dev returns the principal balance of the user. The principal balance is the last\\n    * updated stored balance, which does not consider the perpetually accruing interest.\\n    * @param _user the address of the user\\n    * @return the principal balance of the user\\n    **/\\n    function principalBalanceOf(address _user) external view returns(uint256) {\\n        return super.balanceOf(_user);\\n    }\\n\\n\\n    /**\\n    * @dev calculates the total supply of the specific aToken\\n    * since the balance of every single user increases over time, the total supply\\n    * does that too.\\n    * @return the current total supply\\n    **/\\n    function totalSupply() public view returns(uint256) {\\n\\n        uint256 currentSupplyPrincipal = super.totalSupply();\\n\\n        if(currentSupplyPrincipal == 0){\\n            return 0;\\n        }\\n\\n        return currentSupplyPrincipal\\n            .wadToRay()\\n            .rayMul(core.getReserveNormalizedIncome(underlyingAssetAddress))\\n            .rayToWad();\\n    }\\n\\n\\n    /**\\n     * @dev Used to validate transfers before actually executing them.\\n     * @param _user address of the user to check\\n     * @param _amount the amount to check\\n     * @return true if the _user can transfer _amount, false otherwise\\n     **/\\n    function isTransferAllowed(address _user, uint256 _amount) public view returns (bool) {\\n        return dataProvider.balanceDecreaseAllowed(underlyingAssetAddress, _user, _amount);\\n    }\\n\\n    /**\\n    * @dev returns the last index of the user, used to calculate the balance of the user\\n    * @param _user address of the user\\n    * @return the last user index\\n    **/\\n    function getUserIndex(address _user) external view returns(uint256) {\\n        return userIndexes[_user];\\n    }\\n\\n\\n    /**\\n    * @dev returns the address to which the interest is redirected\\n    * @param _user address of the user\\n    * @return 0 if there is no redirection, an address otherwise\\n    **/\\n    function getInterestRedirectionAddress(address _user) external view returns(address) {\\n        return interestRedirectionAddresses[_user];\\n    }\\n\\n    /**\\n    * @dev returns the redirected balance of the user. The redirected balance is the balance\\n    * redirected by other accounts to the user, that is accrueing interest for him.\\n    * @param _user address of the user\\n    * @return the total redirected balance\\n    **/\\n    function getRedirectedBalance(address _user) external view returns(uint256) {\\n        return redirectedBalances[_user];\\n    }\\n\\n    /**\\n    * @dev accumulates the accrued interest of the user to the principal balance\\n    * @param _user the address of the user for which the interest is being accumulated\\n    * @return the previous principal balance, the new principal balance, the balance increase\\n    * and the new user index\\n    **/\\n    function cumulateBalanceInternal(address _user)\\n        internal\\n        returns(uint256, uint256, uint256, uint256) {\\n\\n        uint256 previousPrincipalBalance = super.balanceOf(_user);\\n\\n        //calculate the accrued interest since the last accumulation\\n        uint256 balanceIncrease = balanceOf(_user).sub(previousPrincipalBalance);\\n        //mints an amount of tokens equivalent to the amount accumulated\\n        _mint(_user, balanceIncrease);\\n        //updates the user index\\n        uint256 index = userIndexes[_user] = core.getReserveNormalizedIncome(underlyingAssetAddress);\\n        return (\\n            previousPrincipalBalance,\\n            previousPrincipalBalance.add(balanceIncrease),\\n            balanceIncrease,\\n            index\\n        );\\n    }\\n\\n    /**\\n    * @dev updates the redirected balance of the user. If the user is not redirecting his\\n    * interest, nothing is executed.\\n    * @param _user the address of the user for which the interest is being accumulated\\n    * @param _balanceToAdd the amount to add to the redirected balance\\n    * @param _balanceToRemove the amount to remove from the redirected balance\\n    **/\\n    function updateRedirectedBalanceOfRedirectionAddressInternal(\\n        address _user,\\n        uint256 _balanceToAdd,\\n        uint256 _balanceToRemove\\n    ) internal {\\n\\n        address redirectionAddress = interestRedirectionAddresses[_user];\\n        //if there isn't any redirection, nothing to be done\\n        if(redirectionAddress == address(0)){\\n            return;\\n        }\\n\\n        //compound balances of the redirected address\\n        (,,uint256 balanceIncrease, uint256 index) = cumulateBalanceInternal(redirectionAddress);\\n\\n        //updating the redirected balance\\n        redirectedBalances[redirectionAddress] = redirectedBalances[redirectionAddress]\\n            .add(_balanceToAdd)\\n            .sub(_balanceToRemove);\\n\\n        //if the interest of redirectionAddress is also being redirected, we need to update\\n        //the redirected balance of the redirection target by adding the balance increase\\n        address targetOfRedirectionAddress = interestRedirectionAddresses[redirectionAddress];\\n\\n        if(targetOfRedirectionAddress != address(0)){\\n            redirectedBalances[targetOfRedirectionAddress] = redirectedBalances[targetOfRedirectionAddress].add(balanceIncrease);\\n        }\\n\\n        emit RedirectedBalanceUpdated(\\n            redirectionAddress,\\n            balanceIncrease,\\n            index,\\n            _balanceToAdd,\\n            _balanceToRemove\\n        );\\n    }\\n\\n    /**\\n    * @dev calculate the interest accrued by _user on a specific balance\\n    * @param _user the address of the user for which the interest is being accumulated\\n    * @param _balance the balance on which the interest is calculated\\n    * @return the interest rate accrued\\n    **/\\n    function calculateCumulatedBalanceInternal(\\n        address _user,\\n        uint256 _balance\\n    ) internal view returns (uint256) {\\n        return _balance\\n            .wadToRay()\\n            .rayMul(core.getReserveNormalizedIncome(underlyingAssetAddress))\\n            .rayDiv(userIndexes[_user])\\n            .rayToWad();\\n    }\\n\\n    /**\\n    * @dev executes the transfer of aTokens, invoked by both _transfer() and\\n    *      transferOnLiquidation()\\n    * @param _from the address from which transfer the aTokens\\n    * @param _to the destination address\\n    * @param _value the amount to transfer\\n    **/\\n    function executeTransferInternal(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) internal {\\n\\n        require(_value > 0, \\\"Transferred amount needs to be greater than zero\\\");\\n\\n        //cumulate the balance of the sender\\n        (,\\n        uint256 fromBalance,\\n        uint256 fromBalanceIncrease,\\n        uint256 fromIndex\\n        ) = cumulateBalanceInternal(_from);\\n\\n        //cumulate the balance of the receiver\\n        (,\\n        ,\\n        uint256 toBalanceIncrease,\\n        uint256 toIndex\\n        ) = cumulateBalanceInternal(_to);\\n\\n        //if the sender is redirecting his interest towards someone else,\\n        //adds to the redirected balance the accrued interest and removes the amount\\n        //being transferred\\n        updateRedirectedBalanceOfRedirectionAddressInternal(_from, fromBalanceIncrease, _value);\\n\\n        //if the receiver is redirecting his interest towards someone else,\\n        //adds to the redirected balance the accrued interest and the amount\\n        //being transferred\\n        updateRedirectedBalanceOfRedirectionAddressInternal(_to, toBalanceIncrease.add(_value), 0);\\n\\n        //performs the transfer\\n        super._transfer(_from, _to, _value);\\n\\n        bool fromIndexReset = false;\\n        //reset the user data if the remaining balance is 0\\n        if(fromBalance.sub(_value) == 0){\\n            fromIndexReset = resetDataOnZeroBalanceInternal(_from);\\n        }\\n\\n        emit BalanceTransfer(\\n            _from,\\n            _to,\\n            _value,\\n            fromBalanceIncrease,\\n            toBalanceIncrease,\\n            fromIndexReset ? 0 : fromIndex,\\n            toIndex\\n        );\\n    }\\n\\n    /**\\n    * @dev executes the redirection of the interest from one address to another.\\n    * immediately after redirection, the destination address will start to accrue interest.\\n    * @param _from the address from which transfer the aTokens\\n    * @param _to the destination address\\n    **/\\n    function redirectInterestStreamInternal(\\n        address _from,\\n        address _to\\n    ) internal {\\n\\n        address currentRedirectionAddress = interestRedirectionAddresses[_from];\\n\\n        require(_to != currentRedirectionAddress, \\\"Interest is already redirected to the user\\\");\\n\\n        //accumulates the accrued interest to the principal\\n        (uint256 previousPrincipalBalance,\\n        uint256 fromBalance,\\n        uint256 balanceIncrease,\\n        uint256 fromIndex) = cumulateBalanceInternal(_from);\\n\\n        require(fromBalance > 0, \\\"Interest stream can only be redirected if there is a valid balance\\\");\\n\\n        //if the user is already redirecting the interest to someone, before changing\\n        //the redirection address we substract the redirected balance of the previous\\n        //recipient\\n        if(currentRedirectionAddress != address(0)){\\n            updateRedirectedBalanceOfRedirectionAddressInternal(_from,0, previousPrincipalBalance);\\n        }\\n\\n        //if the user is redirecting the interest back to himself,\\n        //we simply set to 0 the interest redirection address\\n        if(_to == _from) {\\n            interestRedirectionAddresses[_from] = address(0);\\n            emit InterestStreamRedirected(\\n                _from,\\n                address(0),\\n                fromBalance,\\n                balanceIncrease,\\n                fromIndex\\n            );\\n            return;\\n        }\\n\\n        //first set the redirection address to the new recipient\\n        interestRedirectionAddresses[_from] = _to;\\n\\n        //adds the user balance to the redirected balance of the destination\\n        updateRedirectedBalanceOfRedirectionAddressInternal(_from,fromBalance,0);\\n\\n        emit InterestStreamRedirected(\\n            _from,\\n            _to,\\n            fromBalance,\\n            balanceIncrease,\\n            fromIndex\\n        );\\n    }\\n\\n    /**\\n    * @dev function to reset the interest stream redirection and the user index, if the\\n    * user has no balance left.\\n    * @param _user the address of the user\\n    * @return true if the user index has also been reset, false otherwise. useful to emit the proper user index value\\n    **/\\n    function resetDataOnZeroBalanceInternal(address _user) internal returns(bool) {\\n\\n        //if the user has 0 principal balance, the interest stream redirection gets reset\\n        interestRedirectionAddresses[_user] = address(0);\\n\\n        //emits a InterestStreamRedirected event to notify that the redirection has been reset\\n        emit InterestStreamRedirected(_user, address(0),0,0,0);\\n\\n        //if the redirected balance is also 0, we clear up the user index\\n        if(redirectedBalances[_user] == 0){\\n            userIndexes[_user] = 0;\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n\\n/**\\n* @title IFlashLoanReceiver interface\\n* @notice Interface for the Aave fee IFlashLoanReceiver.\\n* @author Aave\\n* @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\\n**/\\ninterface IFlashLoanReceiver {\\n\\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;\\n}\\n\\n/**\\n* @title ILendingRateOracle interface\\n* @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be used as a base for the stable borrow rate calculations\\n**/\\n\\ninterface ILendingRateOracle {\\n    /**\\n    @dev returns the market borrow rate in ray\\n    **/\\n    function getMarketBorrowRate(address _asset) external view returns (uint256);\\n\\n    /**\\n    @dev sets the market borrow rate. Rate value must be in ray\\n    **/\\n    function setMarketBorrowRate(address _asset, uint256 _rate) external;\\n}\\n\\n/**\\n@title IReserveInterestRateStrategyInterface interface\\n@notice Interface for the calculation of the interest rates.\\n*/\\n\\ninterface IReserveInterestRateStrategy {\\n\\n    /**\\n    * @dev returns the base variable borrow rate, in rays\\n    */\\n\\n    function getBaseVariableBorrowRate() external view returns (uint256);\\n    /**\\n    * @dev calculates the liquidity, stable, and variable rates depending on the current utilization rate\\n    *      and the base parameters\\n    *\\n    */\\n    function calculateInterestRates(\\n        address _reserve,\\n        uint256 _utilizationRate,\\n        uint256 _totalBorrowsStable,\\n        uint256 _totalBorrowsVariable,\\n        uint256 _averageStableBorrowRate)\\n    external\\n    view\\n    returns (uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate);\\n}\\n\\nlibrary EthAddressLib {\\n\\n    /**\\n    * @dev returns the address used within the protocol to identify ETH\\n    * @return the address assigned to ETH\\n     */\\n    function ethAddress() internal pure returns(address) {\\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    }\\n}\\n\\n/**\\n* @title LendingPool contract\\n* @notice Implements the actions of the LendingPool, and exposes accessory methods to fetch the users and reserve data\\n* @author Aave\\n **/\\n\\ncontract LendingPool is ReentrancyGuard, VersionedInitializable {\\n    using SafeMath for uint256;\\n    using WadRayMath for uint256;\\n    using Address for address;\\n    using SafeERC20 for ERC20;\\n\\n    LendingPoolAddressesProvider public addressesProvider;\\n    LendingPoolCore public core;\\n    LendingPoolDataProvider public dataProvider;\\n    LendingPoolParametersProvider public parametersProvider;\\n    IFeeProvider feeProvider;\\n\\n    /**\\n    * @dev emitted on deposit\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user\\n    * @param _amount the amount to be deposited\\n    * @param _referral the referral number of the action\\n    * @param _timestamp the timestamp of the action\\n    **/\\n    event Deposit(\\n        address indexed _reserve,\\n        address indexed _user,\\n        uint256 _amount,\\n        uint16 indexed _referral,\\n        uint256 _timestamp\\n    );\\n\\n    /**\\n    * @dev emitted during a redeem action.\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user\\n    * @param _amount the amount to be deposited\\n    * @param _timestamp the timestamp of the action\\n    **/\\n    event RedeemUnderlying(\\n        address indexed _reserve,\\n        address indexed _user,\\n        uint256 _amount,\\n        uint256 _timestamp\\n    );\\n\\n    /**\\n    * @dev emitted on borrow\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user\\n    * @param _amount the amount to be deposited\\n    * @param _borrowRateMode the rate mode, can be either 1-stable or 2-variable\\n    * @param _borrowRate the rate at which the user has borrowed\\n    * @param _originationFee the origination fee to be paid by the user\\n    * @param _borrowBalanceIncrease the balance increase since the last borrow, 0 if it's the first time borrowing\\n    * @param _referral the referral number of the action\\n    * @param _timestamp the timestamp of the action\\n    **/\\n    event Borrow(\\n        address indexed _reserve,\\n        address indexed _user,\\n        uint256 _amount,\\n        uint256 _borrowRateMode,\\n        uint256 _borrowRate,\\n        uint256 _originationFee,\\n        uint256 _borrowBalanceIncrease,\\n        uint16 indexed _referral,\\n        uint256 _timestamp\\n    );\\n\\n    /**\\n    * @dev emitted on repay\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user for which the repay has been executed\\n    * @param _repayer the address of the user that has performed the repay action\\n    * @param _amountMinusFees the amount repaid minus fees\\n    * @param _fees the fees repaid\\n    * @param _borrowBalanceIncrease the balance increase since the last action\\n    * @param _timestamp the timestamp of the action\\n    **/\\n    event Repay(\\n        address indexed _reserve,\\n        address indexed _user,\\n        address indexed _repayer,\\n        uint256 _amountMinusFees,\\n        uint256 _fees,\\n        uint256 _borrowBalanceIncrease,\\n        uint256 _timestamp\\n    );\\n\\n    /**\\n    * @dev emitted when a user performs a rate swap\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user executing the swap\\n    * @param _newRateMode the new interest rate mode\\n    * @param _newRate the new borrow rate\\n    * @param _borrowBalanceIncrease the balance increase since the last action\\n    * @param _timestamp the timestamp of the action\\n    **/\\n    event Swap(\\n        address indexed _reserve,\\n        address indexed _user,\\n        uint256 _newRateMode,\\n        uint256 _newRate,\\n        uint256 _borrowBalanceIncrease,\\n        uint256 _timestamp\\n    );\\n\\n    /**\\n    * @dev emitted when a user enables a reserve as collateral\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user\\n    **/\\n    event ReserveUsedAsCollateralEnabled(address indexed _reserve, address indexed _user);\\n\\n    /**\\n    * @dev emitted when a user disables a reserve as collateral\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user\\n    **/\\n    event ReserveUsedAsCollateralDisabled(address indexed _reserve, address indexed _user);\\n\\n    /**\\n    * @dev emitted when the stable rate of a user gets rebalanced\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user for which the rebalance has been executed\\n    * @param _newStableRate the new stable borrow rate after the rebalance\\n    * @param _borrowBalanceIncrease the balance increase since the last action\\n    * @param _timestamp the timestamp of the action\\n    **/\\n    event RebalanceStableBorrowRate(\\n        address indexed _reserve,\\n        address indexed _user,\\n        uint256 _newStableRate,\\n        uint256 _borrowBalanceIncrease,\\n        uint256 _timestamp\\n    );\\n\\n    /**\\n    * @dev emitted when a flashloan is executed\\n    * @param _target the address of the flashLoanReceiver\\n    * @param _reserve the address of the reserve\\n    * @param _amount the amount requested\\n    * @param _totalFee the total fee on the amount\\n    * @param _protocolFee the part of the fee for the protocol\\n    * @param _timestamp the timestamp of the action\\n    **/\\n    event FlashLoan(\\n        address indexed _target,\\n        address indexed _reserve,\\n        uint256 _amount,\\n        uint256 _totalFee,\\n        uint256 _protocolFee,\\n        uint256 _timestamp\\n    );\\n\\n    /**\\n    * @dev these events are not emitted directly by the LendingPool\\n    * but they are declared here as the LendingPoolLiquidationManager\\n    * is executed using a delegateCall().\\n    * This allows to have the events in the generated ABI for LendingPool.\\n    **/\\n\\n    /**\\n    * @dev emitted when a borrow fee is liquidated\\n    * @param _collateral the address of the collateral being liquidated\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user being liquidated\\n    * @param _feeLiquidated the total fee liquidated\\n    * @param _liquidatedCollateralForFee the amount of collateral received by the protocol in exchange for the fee\\n    * @param _timestamp the timestamp of the action\\n    **/\\n    event OriginationFeeLiquidated(\\n        address indexed _collateral,\\n        address indexed _reserve,\\n        address indexed _user,\\n        uint256 _feeLiquidated,\\n        uint256 _liquidatedCollateralForFee,\\n        uint256 _timestamp\\n    );\\n\\n    /**\\n    * @dev emitted when a borrower is liquidated\\n    * @param _collateral the address of the collateral being liquidated\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user being liquidated\\n    * @param _purchaseAmount the total amount liquidated\\n    * @param _liquidatedCollateralAmount the amount of collateral being liquidated\\n    * @param _accruedBorrowInterest the amount of interest accrued by the borrower since the last action\\n    * @param _liquidator the address of the liquidator\\n    * @param _receiveAToken true if the liquidator wants to receive aTokens, false otherwise\\n    * @param _timestamp the timestamp of the action\\n    **/\\n    event LiquidationCall(\\n        address indexed _collateral,\\n        address indexed _reserve,\\n        address indexed _user,\\n        uint256 _purchaseAmount,\\n        uint256 _liquidatedCollateralAmount,\\n        uint256 _accruedBorrowInterest,\\n        address _liquidator,\\n        bool _receiveAToken,\\n        uint256 _timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted during the token rescue\\n     * @param tokenRescued The token which is being rescued\\n     * @param receiver The recipient which will receive the rescued token\\n     * @param amountRescued The amount being rescued\\n     **/\\n    event TokensRescued(\\n        address indexed tokenRescued,\\n        address indexed receiver,\\n        uint256 amountRescued\\n    );\\n\\n    /**\\n    * @dev functions affected by this modifier can only be invoked by the\\n    * aToken.sol contract\\n    * @param _reserve the address of the reserve\\n    **/\\n    modifier onlyOverlyingAToken(address _reserve) {\\n        require(\\n            msg.sender == core.getReserveATokenAddress(_reserve),\\n            \\\"The caller of this function can only be the aToken contract of this reserve\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n    * @dev functions affected by this modifier can only be invoked if the reserve is active\\n    * @param _reserve the address of the reserve\\n    **/\\n    modifier onlyActiveReserve(address _reserve) {\\n        requireReserveActiveInternal(_reserve);\\n        _;\\n    }\\n\\n    /**\\n    * @dev functions affected by this modifier can only be invoked if the reserve is not freezed.\\n    * A freezed reserve only allows redeems, repays, rebalances and liquidations.\\n    * @param _reserve the address of the reserve\\n    **/\\n    modifier onlyUnfreezedReserve(address _reserve) {\\n        requireReserveNotFreezedInternal(_reserve);\\n        _;\\n    }\\n\\n    /**\\n    * @dev functions affected by this modifier can only be invoked if the provided _amount input parameter\\n    * is not zero.\\n    * @param _amount the amount provided\\n    **/\\n    modifier onlyAmountGreaterThanZero(uint256 _amount) {\\n        requireAmountGreaterThanZeroInternal(_amount);\\n        _;\\n    }\\n\\n    modifier onlyAddressesProviderOwner() {\\n        require(\\n            msg.sender == addressesProvider.owner(),\\n            \\\"The caller of this function can only be the addressesProvider owner\\\"\\n        );\\n        _;\\n    }\\n\\n    uint256 public constant UINT_MAX_VALUE = uint256(-1);\\n\\n    uint256 public constant LENDINGPOOL_REVISION = 0x6;\\n\\n    function getRevision() internal pure returns (uint256) {\\n        return LENDINGPOOL_REVISION;\\n    }\\n\\n    /**\\n    * @dev this function is invoked by the proxy contract when the LendingPool contract is added to the\\n    * AddressesProvider.\\n    * @param _addressesProvider the address of the LendingPoolAddressesProvider registry\\n    **/\\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\\n        addressesProvider = _addressesProvider;\\n        core = LendingPoolCore(addressesProvider.getLendingPoolCore());\\n        dataProvider = LendingPoolDataProvider(addressesProvider.getLendingPoolDataProvider());\\n        parametersProvider = LendingPoolParametersProvider(\\n            addressesProvider.getLendingPoolParametersProvider()\\n        );\\n        feeProvider = IFeeProvider(addressesProvider.getFeeProvider());\\n    }\\n\\n    /**\\n    * @dev deposits The underlying asset into the reserve. A corresponding amount of the overlying asset (aTokens)\\n    * is minted.\\n    * @param _reserve the address of the reserve\\n    * @param _amount the amount to be deposited\\n    * @param _referralCode integrators are assigned a referral code and can potentially receive rewards.\\n    **/\\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode)\\n        external\\n        payable\\n        nonReentrant\\n        onlyActiveReserve(_reserve)\\n        onlyUnfreezedReserve(_reserve)\\n        onlyAmountGreaterThanZero(_amount)\\n    {\\n        AToken aToken = AToken(core.getReserveATokenAddress(_reserve));\\n\\n        bool isFirstDeposit = aToken.balanceOf(msg.sender) == 0;\\n\\n        core.updateStateOnDeposit(_reserve, msg.sender, _amount, isFirstDeposit);\\n\\n        //minting AToken to user 1:1 with the specific exchange rate\\n        aToken.mintOnDeposit(msg.sender, _amount);\\n\\n        //transfer to the core contract\\n        core.transferToReserve.value(msg.value)(_reserve, msg.sender, _amount);\\n\\n        //solium-disable-next-line\\n        emit Deposit(_reserve, msg.sender, _amount, _referralCode, block.timestamp);\\n\\n    }\\n\\n    /**\\n    * @dev Redeems the underlying amount of assets requested by _user.\\n    * This function is executed by the overlying aToken contract in response to a redeem action.\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user performing the action\\n    * @param _amount the underlying amount to be redeemed\\n    **/\\n    function redeemUnderlying(\\n        address _reserve,\\n        address payable _user,\\n        uint256 _amount,\\n        uint256 _aTokenBalanceAfterRedeem\\n    )\\n        external\\n        nonReentrant\\n        onlyOverlyingAToken(_reserve)\\n        onlyActiveReserve(_reserve)\\n        onlyAmountGreaterThanZero(_amount)\\n    {\\n        uint256 currentAvailableLiquidity = core.getReserveAvailableLiquidity(_reserve);\\n        require(\\n            currentAvailableLiquidity >= _amount,\\n            \\\"There is not enough liquidity available to redeem\\\"\\n        );\\n\\n        core.updateStateOnRedeem(_reserve, _user, _amount, _aTokenBalanceAfterRedeem == 0);\\n\\n        core.transferToUser(_reserve, _user, _amount);\\n\\n        //solium-disable-next-line\\n        emit RedeemUnderlying(_reserve, _user, _amount, block.timestamp);\\n\\n    }\\n\\n    /**\\n    * @dev data structures for local computations in the borrow() method.\\n    */\\n\\n    struct BorrowLocalVars {\\n        uint256 principalBorrowBalance;\\n        uint256 currentLtv;\\n        uint256 currentLiquidationThreshold;\\n        uint256 borrowFee;\\n        uint256 requestedBorrowAmountETH;\\n        uint256 amountOfCollateralNeededETH;\\n        uint256 userCollateralBalanceETH;\\n        uint256 userBorrowBalanceETH;\\n        uint256 userTotalFeesETH;\\n        uint256 borrowBalanceIncrease;\\n        uint256 currentReserveStableRate;\\n        uint256 availableLiquidity;\\n        uint256 reserveDecimals;\\n        uint256 finalUserBorrowRate;\\n        CoreLibrary.InterestRateMode rateMode;\\n        bool healthFactorBelowThreshold;\\n    }\\n\\n    /**\\n    * @dev Allows users to borrow a specific amount of the reserve currency, provided that the borrower\\n    * already deposited enough collateral.\\n    * @param _reserve the address of the reserve\\n    * @param _amount the amount to be borrowed\\n    * @param _interestRateMode the interest rate mode at which the user wants to borrow. Can be 0 (STABLE) or 1 (VARIABLE)\\n    **/\\n    function borrow(\\n        address _reserve,\\n        uint256 _amount,\\n        uint256 _interestRateMode,\\n        uint16 _referralCode\\n    )\\n        external\\n        nonReentrant\\n        onlyActiveReserve(_reserve)\\n        onlyUnfreezedReserve(_reserve)\\n        onlyAmountGreaterThanZero(_amount)\\n    {\\n        // Usage of a memory struct of vars to avoid \\\"Stack too deep\\\" errors due to local variables\\n        BorrowLocalVars memory vars;\\n\\n        //check that the reserve is enabled for borrowing\\n        require(core.isReserveBorrowingEnabled(_reserve), \\\"Reserve is not enabled for borrowing\\\");\\n        //validate interest rate mode\\n        require(\\n            uint256(CoreLibrary.InterestRateMode.VARIABLE) == _interestRateMode ||\\n                uint256(CoreLibrary.InterestRateMode.STABLE) == _interestRateMode,\\n            \\\"Invalid interest rate mode selected\\\"\\n        );\\n\\n        //cast the rateMode to coreLibrary.interestRateMode\\n        vars.rateMode = CoreLibrary.InterestRateMode(_interestRateMode);\\n\\n        //check that the amount is available in the reserve\\n        vars.availableLiquidity = core.getReserveAvailableLiquidity(_reserve);\\n\\n        require(\\n            vars.availableLiquidity >= _amount,\\n            \\\"There is not enough liquidity available in the reserve\\\"\\n        );\\n\\n        (\\n            ,\\n            vars.userCollateralBalanceETH,\\n            vars.userBorrowBalanceETH,\\n            vars.userTotalFeesETH,\\n            vars.currentLtv,\\n            vars.currentLiquidationThreshold,\\n            ,\\n            vars.healthFactorBelowThreshold\\n        ) = dataProvider.calculateUserGlobalData(msg.sender);\\n\\n        require(vars.userCollateralBalanceETH > 0, \\\"The collateral balance is 0\\\");\\n\\n        require(\\n            !vars.healthFactorBelowThreshold,\\n            \\\"The borrower can already be liquidated so he cannot borrow more\\\"\\n        );\\n\\n        //calculating fees\\n        vars.borrowFee = feeProvider.calculateLoanOriginationFee(msg.sender, _amount);\\n\\n        require(vars.borrowFee > 0, \\\"The amount to borrow is too small\\\");\\n\\n        vars.amountOfCollateralNeededETH = dataProvider.calculateCollateralNeededInETH(\\n            _reserve,\\n            _amount,\\n            vars.borrowFee,\\n            vars.userBorrowBalanceETH,\\n            vars.userTotalFeesETH,\\n            vars.currentLtv\\n        );\\n\\n        require(\\n            vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\\n            \\\"There is not enough collateral to cover a new borrow\\\"\\n        );\\n\\n        /**\\n        * Following conditions need to be met if the user is borrowing at a stable rate:\\n        * 1. Reserve must be enabled for stable rate borrowing\\n        * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\\n        *    they are borrowing, to prevent abuses.\\n        * 3. Users will be able to borrow only a relatively small, configurable amount of the total\\n        *    liquidity\\n        **/\\n\\n        if (vars.rateMode == CoreLibrary.InterestRateMode.STABLE) {\\n            //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\\n            require(\\n                core.isUserAllowedToBorrowAtStable(_reserve, msg.sender, _amount),\\n                \\\"User cannot borrow the selected amount with a stable rate\\\"\\n            );\\n\\n            //calculate the max available loan size in stable rate mode as a percentage of the\\n            //available liquidity\\n            uint256 maxLoanPercent = parametersProvider.getMaxStableRateBorrowSizePercent();\\n            uint256 maxLoanSizeStable = vars.availableLiquidity.mul(maxLoanPercent).div(100);\\n\\n            require(\\n                _amount <= maxLoanSizeStable,\\n                \\\"User is trying to borrow too much liquidity at a stable rate\\\"\\n            );\\n        }\\n\\n        //all conditions passed - borrow is accepted\\n        (vars.finalUserBorrowRate, vars.borrowBalanceIncrease) = core.updateStateOnBorrow(\\n            _reserve,\\n            msg.sender,\\n            _amount,\\n            vars.borrowFee,\\n            vars.rateMode\\n        );\\n\\n        //if we reached this point, we can transfer\\n        core.transferToUser(_reserve, msg.sender, _amount);\\n\\n        emit Borrow(\\n            _reserve,\\n            msg.sender,\\n            _amount,\\n            _interestRateMode,\\n            vars.finalUserBorrowRate,\\n            vars.borrowFee,\\n            vars.borrowBalanceIncrease,\\n            _referralCode,\\n            //solium-disable-next-line\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n    * @notice repays a borrow on the specific reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\\n    * @dev the target user is defined by _onBehalfOf. If there is no repayment on behalf of another account,\\n    * _onBehalfOf must be equal to msg.sender.\\n    * @param _reserve the address of the reserve on which the user borrowed\\n    * @param _amount the amount to repay, or uint256(-1) if the user wants to repay everything\\n    * @param _onBehalfOf the address for which msg.sender is repaying.\\n    **/\\n\\n    struct RepayLocalVars {\\n        uint256 principalBorrowBalance;\\n        uint256 compoundedBorrowBalance;\\n        uint256 borrowBalanceIncrease;\\n        bool isETH;\\n        uint256 paybackAmount;\\n        uint256 paybackAmountMinusFees;\\n        uint256 currentStableRate;\\n        uint256 originationFee;\\n    }\\n\\n    function repay(address _reserve, uint256 _amount, address payable _onBehalfOf)\\n        external\\n        payable\\n        nonReentrant\\n        onlyActiveReserve(_reserve)\\n        onlyAmountGreaterThanZero(_amount)\\n    {\\n        // Usage of a memory struct of vars to avoid \\\"Stack too deep\\\" errors due to local variables\\n        RepayLocalVars memory vars;\\n\\n        (\\n            vars.principalBorrowBalance,\\n            vars.compoundedBorrowBalance,\\n            vars.borrowBalanceIncrease\\n        ) = core.getUserBorrowBalances(_reserve, _onBehalfOf);\\n\\n        vars.originationFee = core.getUserOriginationFee(_reserve, _onBehalfOf);\\n        vars.isETH = EthAddressLib.ethAddress() == _reserve;\\n\\n        require(vars.compoundedBorrowBalance > 0, \\\"The user does not have any borrow pending\\\");\\n\\n        require(\\n            _amount != UINT_MAX_VALUE || msg.sender == _onBehalfOf,\\n            \\\"To repay on behalf of an user an explicit amount to repay is needed.\\\"\\n        );\\n\\n        //default to max amount\\n        vars.paybackAmount = vars.compoundedBorrowBalance.add(vars.originationFee);\\n\\n        if (_amount != UINT_MAX_VALUE && _amount < vars.paybackAmount) {\\n            vars.paybackAmount = _amount;\\n        }\\n\\n        require(\\n            !vars.isETH || msg.value >= vars.paybackAmount,\\n            \\\"Invalid msg.value sent for the repayment\\\"\\n        );\\n\\n        //if the amount is smaller than the origination fee, just transfer the amount to the fee destination address\\n        if (vars.paybackAmount <= vars.originationFee) {\\n            core.updateStateOnRepay(\\n                _reserve,\\n                _onBehalfOf,\\n                0,\\n                vars.paybackAmount,\\n                vars.borrowBalanceIncrease,\\n                false\\n            );\\n\\n            core.transferToFeeCollectionAddress.value(vars.isETH ? vars.paybackAmount : 0)(\\n                _reserve,\\n                msg.sender,\\n                vars.paybackAmount,\\n                addressesProvider.getTokenDistributor()\\n            );\\n\\n            emit Repay(\\n                _reserve,\\n                _onBehalfOf,\\n                msg.sender,\\n                0,\\n                vars.paybackAmount,\\n                vars.borrowBalanceIncrease,\\n                //solium-disable-next-line\\n                block.timestamp\\n            );\\n            return;\\n        }\\n\\n        vars.paybackAmountMinusFees = vars.paybackAmount.sub(vars.originationFee);\\n\\n        core.updateStateOnRepay(\\n            _reserve,\\n            _onBehalfOf,\\n            vars.paybackAmountMinusFees,\\n            vars.originationFee,\\n            vars.borrowBalanceIncrease,\\n            vars.compoundedBorrowBalance == vars.paybackAmountMinusFees\\n        );\\n\\n        //if the user didn't repay the origination fee, transfer the fee to the fee collection address\\n        if(vars.originationFee > 0) {\\n            core.transferToFeeCollectionAddress.value(vars.isETH ? vars.originationFee : 0)(\\n                _reserve,\\n                msg.sender,\\n                vars.originationFee,\\n                addressesProvider.getTokenDistributor()\\n            );\\n        }\\n\\n        //sending the total msg.value if the transfer is ETH.\\n        //the transferToReserve() function will take care of sending the\\n        //excess ETH back to the caller\\n        core.transferToReserve.value(vars.isETH ? msg.value.sub(vars.originationFee) : 0)(\\n            _reserve,\\n            msg.sender,\\n            vars.paybackAmountMinusFees\\n        );\\n\\n        emit Repay(\\n            _reserve,\\n            _onBehalfOf,\\n            msg.sender,\\n            vars.paybackAmountMinusFees,\\n            vars.originationFee,\\n            vars.borrowBalanceIncrease,\\n            //solium-disable-next-line\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n    * @dev borrowers can user this function to swap between stable and variable borrow rate modes.\\n    * @param _reserve the address of the reserve on which the user borrowed\\n    **/\\n    function swapBorrowRateMode(address _reserve)\\n        external\\n        nonReentrant\\n        onlyActiveReserve(_reserve)\\n        onlyUnfreezedReserve(_reserve)\\n    {\\n        (uint256 principalBorrowBalance, uint256 compoundedBorrowBalance, uint256 borrowBalanceIncrease) = core\\n            .getUserBorrowBalances(_reserve, msg.sender);\\n\\n        require(\\n            compoundedBorrowBalance > 0,\\n            \\\"User does not have a borrow in progress on this reserve\\\"\\n        );\\n\\n        CoreLibrary.InterestRateMode currentRateMode = core.getUserCurrentBorrowRateMode(\\n            _reserve,\\n            msg.sender\\n        );\\n\\n        if (currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\\n            /**\\n            * user wants to swap to stable, before swapping we need to ensure that\\n            * 1. stable borrow rate is enabled on the reserve\\n            * 2. user is not trying to abuse the reserve by depositing\\n            * more collateral than he is borrowing, artificially lowering\\n            * the interest rate, borrowing at variable, and switching to stable\\n            **/\\n            require(\\n                core.isUserAllowedToBorrowAtStable(_reserve, msg.sender, compoundedBorrowBalance),\\n                \\\"User cannot borrow the selected amount at stable\\\"\\n            );\\n        }\\n\\n        (CoreLibrary.InterestRateMode newRateMode, uint256 newBorrowRate) = core\\n            .updateStateOnSwapRate(\\n            _reserve,\\n            msg.sender,\\n            principalBorrowBalance,\\n            compoundedBorrowBalance,\\n            borrowBalanceIncrease,\\n            currentRateMode\\n        );\\n\\n        emit Swap(\\n            _reserve,\\n            msg.sender,\\n            uint256(newRateMode),\\n            newBorrowRate,\\n            borrowBalanceIncrease,\\n            //solium-disable-next-line\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n    * @dev rebalances the stable interest rate of a user if current liquidity rate > user stable rate.\\n    * this is regulated by Aave to ensure that the protocol is not abused, and the user is paying a fair\\n    * rate. The rebalance mechanism is updated in the context of the V1 -> V2 transition to automatically switch the user to variable.\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user to be rebalanced\\n    **/\\n    function rebalanceStableBorrowRate(address _reserve, address _user)\\n        external\\n        nonReentrant\\n        onlyActiveReserve(_reserve)\\n    {\\n        (uint256 principalBalance, uint256 compoundedBalance, uint256 borrowBalanceIncrease) = core.getUserBorrowBalances(\\n            _reserve,\\n            _user\\n        );\\n\\n        require(compoundedBalance > 0, \\\"User does not have any borrow for this reserve\\\");\\n\\n        CoreLibrary.InterestRateMode rateMode = core.getUserCurrentBorrowRateMode(_reserve, _user);\\n        require(\\n            rateMode ==\\n                CoreLibrary.InterestRateMode.STABLE,\\n            \\\"The user borrow is variable and cannot be rebalanced\\\"\\n        );\\n\\n        uint256 userCurrentStableRate = core.getUserCurrentStableBorrowRate(_reserve, _user);\\n        uint256 liquidityRate = core.getReserveCurrentLiquidityRate(_reserve);\\n        if (userCurrentStableRate < liquidityRate) {\\n\\n         (CoreLibrary.InterestRateMode newRateMode, uint256 newBorrowRate) = core\\n            .updateStateOnSwapRate(\\n            _reserve,\\n            _user,\\n            principalBalance,\\n            compoundedBalance,\\n            borrowBalanceIncrease,\\n            rateMode\\n        );\\n\\n        emit Swap(\\n            _reserve,\\n            _user,\\n            uint256(newRateMode),\\n            newBorrowRate,\\n            borrowBalanceIncrease,\\n            //solium-disable-next-line\\n            block.timestamp\\n        );\\n\\n        return;\\n\\n        }\\n\\n        revert(\\\"Interest rate rebalance conditions were not met\\\");\\n    }\\n\\n    /**\\n    * @dev allows depositors to enable or disable a specific deposit as collateral.\\n    * @param _reserve the address of the reserve\\n    * @param _useAsCollateral true if the user wants to user the deposit as collateral, false otherwise.\\n    **/\\n    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral)\\n        external\\n        nonReentrant\\n        onlyActiveReserve(_reserve)\\n        onlyUnfreezedReserve(_reserve)\\n    {\\n        uint256 underlyingBalance = core.getUserUnderlyingAssetBalance(_reserve, msg.sender);\\n\\n        require(underlyingBalance > 0, \\\"User does not have any liquidity deposited\\\");\\n\\n        require(\\n            dataProvider.balanceDecreaseAllowed(_reserve, msg.sender, underlyingBalance),\\n            \\\"User deposit is already being used as collateral\\\"\\n        );\\n\\n        core.setUserUseReserveAsCollateral(_reserve, msg.sender, _useAsCollateral);\\n\\n        if (_useAsCollateral) {\\n            emit ReserveUsedAsCollateralEnabled(_reserve, msg.sender);\\n        } else {\\n            emit ReserveUsedAsCollateralDisabled(_reserve, msg.sender);\\n        }\\n    }\\n\\n    /**\\n    * @dev users can invoke this function to liquidate an undercollateralized position.\\n    * @param _reserve the address of the collateral to liquidated\\n    * @param _reserve the address of the principal reserve\\n    * @param _user the address of the borrower\\n    * @param _purchaseAmount the amount of principal that the liquidator wants to repay\\n    * @param _receiveAToken true if the liquidators wants to receive the aTokens, false if\\n    * he wants to receive the underlying asset directly\\n    **/\\n    function liquidationCall(\\n        address _collateral,\\n        address _reserve,\\n        address _user,\\n        uint256 _purchaseAmount,\\n        bool _receiveAToken\\n    ) external payable nonReentrant onlyActiveReserve(_reserve) onlyActiveReserve(_collateral) {\\n        address liquidationManager = addressesProvider.getLendingPoolLiquidationManager();\\n\\n        //solium-disable-next-line\\n        (bool success, bytes memory result) = liquidationManager.delegatecall(\\n            abi.encodeWithSignature(\\n                \\\"liquidationCall(address,address,address,uint256,bool)\\\",\\n                _collateral,\\n                _reserve,\\n                _user,\\n                _purchaseAmount,\\n                _receiveAToken\\n            )\\n        );\\n        require(success, \\\"Liquidation call failed\\\");\\n\\n        (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\\n\\n        if (returnCode != 0) {\\n            //error found\\n            revert(string(abi.encodePacked(\\\"Liquidation failed: \\\", returnMessage)));\\n        }\\n    }\\n\\n    /**\\n    * @dev allows smartcontracts to access the liquidity of the pool within one transaction,\\n    * as long as the amount taken plus a fee is returned. NOTE There are security concerns for developers of flashloan receiver contracts\\n    * that must be kept into consideration. For further details please visit https://developers.aave.com\\n    * @param _receiver The address of the contract receiving the funds. The receiver should implement the IFlashLoanReceiver interface.\\n    * @param _reserve the address of the principal reserve\\n    * @param _amount the amount requested for this flashloan\\n    **/\\n    function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes memory _params)\\n        public\\n        nonReentrant\\n        onlyActiveReserve(_reserve)\\n        onlyAmountGreaterThanZero(_amount)\\n    {\\n        //check that the reserve has enough available liquidity\\n        //we avoid using the getAvailableLiquidity() function in LendingPoolCore to save gas\\n        uint256 availableLiquidityBefore = _reserve == EthAddressLib.ethAddress()\\n            ? address(core).balance\\n            : IERC20(_reserve).balanceOf(address(core));\\n\\n        require(\\n            availableLiquidityBefore >= _amount,\\n            \\\"There is not enough liquidity available to borrow\\\"\\n        );\\n\\n        (uint256 totalFeeBips, uint256 protocolFeeBips) = parametersProvider\\n            .getFlashLoanFeesInBips();\\n        //calculate amount fee\\n        uint256 amountFee = _amount.mul(totalFeeBips).div(10000);\\n\\n        //protocol fee is the part of the amountFee reserved for the protocol - the rest goes to depositors\\n        uint256 protocolFee = amountFee.mul(protocolFeeBips).div(10000);\\n        require(\\n            amountFee > 0 && protocolFee > 0,\\n            \\\"The requested amount is too small for a flashLoan.\\\"\\n        );\\n\\n        //get the FlashLoanReceiver instance\\n        IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);\\n\\n        address payable userPayable = address(uint160(_receiver));\\n\\n        //transfer funds to the receiver\\n        core.transferToUser(_reserve, userPayable, _amount);\\n\\n        //execute action of the receiver\\n        receiver.executeOperation(_reserve, _amount, amountFee, _params);\\n\\n        //check that the actual balance of the core contract includes the returned amount\\n        uint256 availableLiquidityAfter = _reserve == EthAddressLib.ethAddress()\\n            ? address(core).balance\\n            : IERC20(_reserve).balanceOf(address(core));\\n\\n        require(\\n            availableLiquidityAfter == availableLiquidityBefore.add(amountFee),\\n            \\\"The actual balance of the protocol is inconsistent\\\"\\n        );\\n\\n        core.updateStateOnFlashLoan(\\n            _reserve,\\n            availableLiquidityBefore,\\n            amountFee.sub(protocolFee),\\n            protocolFee\\n        );\\n\\n        //solium-disable-next-line\\n        emit FlashLoan(_receiver, _reserve, _amount, amountFee, protocolFee, block.timestamp);\\n    }\\n\\n    function rescueTokens(address token, address to, uint256 amount) external onlyAddressesProviderOwner {\\n        ERC20(token).safeTransfer(to, amount);\\n        emit TokensRescued(token, to, amount);\\n    }\\n\\n    /**\\n    * @dev accessory functions to fetch data from the core contract\\n    **/\\n\\n    function getReserveConfigurationData(address _reserve)\\n        external\\n        view\\n        returns (\\n            uint256 ltv,\\n            uint256 liquidationThreshold,\\n            uint256 liquidationBonus,\\n            address interestRateStrategyAddress,\\n            bool usageAsCollateralEnabled,\\n            bool borrowingEnabled,\\n            bool stableBorrowRateEnabled,\\n            bool isActive\\n        )\\n    {\\n        return dataProvider.getReserveConfigurationData(_reserve);\\n    }\\n\\n    function getReserveData(address _reserve)\\n        external\\n        view\\n        returns (\\n            uint256 totalLiquidity,\\n            uint256 availableLiquidity,\\n            uint256 totalBorrowsStable,\\n            uint256 totalBorrowsVariable,\\n            uint256 liquidityRate,\\n            uint256 variableBorrowRate,\\n            uint256 stableBorrowRate,\\n            uint256 averageStableBorrowRate,\\n            uint256 utilizationRate,\\n            uint256 liquidityIndex,\\n            uint256 variableBorrowIndex,\\n            address aTokenAddress,\\n            uint40 lastUpdateTimestamp\\n        )\\n    {\\n        return dataProvider.getReserveData(_reserve);\\n    }\\n\\n    function getUserAccountData(address _user)\\n        external\\n        view\\n        returns (\\n            uint256 totalLiquidityETH,\\n            uint256 totalCollateralETH,\\n            uint256 totalBorrowsETH,\\n            uint256 totalFeesETH,\\n            uint256 availableBorrowsETH,\\n            uint256 currentLiquidationThreshold,\\n            uint256 ltv,\\n            uint256 healthFactor\\n        )\\n    {\\n        return dataProvider.getUserAccountData(_user);\\n    }\\n\\n    function getUserReserveData(address _reserve, address _user)\\n        external\\n        view\\n        returns (\\n            uint256 currentATokenBalance,\\n            uint256 currentBorrowBalance,\\n            uint256 principalBorrowBalance,\\n            uint256 borrowRateMode,\\n            uint256 borrowRate,\\n            uint256 liquidityRate,\\n            uint256 originationFee,\\n            uint256 variableBorrowIndex,\\n            uint256 lastUpdateTimestamp,\\n            bool usageAsCollateralEnabled\\n        )\\n    {\\n        return dataProvider.getUserReserveData(_reserve, _user);\\n    }\\n\\n    function getReserves() external view returns (address[] memory) {\\n        return core.getReserves();\\n    }\\n\\n    /**\\n    * @dev internal function to save on code size for the onlyActiveReserve modifier\\n    **/\\n    function requireReserveActiveInternal(address _reserve) internal view {\\n        require(core.getReserveIsActive(_reserve), \\\"Action requires an active reserve\\\");\\n    }\\n\\n    /**\\n    * @notice internal function to save on code size for the onlyUnfreezedReserve modifier\\n    **/\\n    function requireReserveNotFreezedInternal(address _reserve) internal view {\\n        require(!core.getReserveIsFreezed(_reserve), \\\"Action requires an unfreezed reserve\\\");\\n    }\\n\\n    /**\\n    * @notice internal function to save on code size for the onlyAmountGreaterThanZero modifier\\n    **/\\n    function requireAmountGreaterThanZeroInternal(uint256 _amount) internal pure {\\n        require(_amount > 0, \\\"Amount must be greater than 0\\\");\\n    }\\n}\\n\\n/**\\n* @title LendingPoolCore contract\\n* @author Aave\\n* @notice Holds the state of the lending pool and all the funds deposited\\n* @dev NOTE: The core does not enforce security checks on the update of the state\\n* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).\\n* The check that an action can be performed is a duty of the overlying LendingPool contract.\\n**/\\n\\ncontract LendingPoolCore is VersionedInitializable {\\n    using SafeMath for uint256;\\n    using WadRayMath for uint256;\\n    using CoreLibrary for CoreLibrary.ReserveData;\\n    using CoreLibrary for CoreLibrary.UserReserveData;\\n    using SafeERC20 for ERC20;\\n    using Address for address payable;\\n\\n    /**\\n    * @dev Emitted when the state of a reserve is updated\\n    * @param reserve the address of the reserve\\n    * @param liquidityRate the new liquidity rate\\n    * @param stableBorrowRate the new stable borrow rate\\n    * @param variableBorrowRate the new variable borrow rate\\n    * @param liquidityIndex the new liquidity index\\n    * @param variableBorrowIndex the new variable borrow index\\n    **/\\n    event ReserveUpdated(\\n        address indexed reserve,\\n        uint256 liquidityRate,\\n        uint256 stableBorrowRate,\\n        uint256 variableBorrowRate,\\n        uint256 liquidityIndex,\\n        uint256 variableBorrowIndex\\n    );\\n\\n    address public lendingPoolAddress;\\n\\n    LendingPoolAddressesProvider public addressesProvider;\\n\\n    /**\\n    * @dev only lending pools can use functions affected by this modifier\\n    **/\\n    modifier onlyLendingPool {\\n        require(lendingPoolAddress == msg.sender, \\\"The caller must be a lending pool contract\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev only lending pools configurator can use functions affected by this modifier\\n    **/\\n    modifier onlyLendingPoolConfigurator {\\n        require(\\n            addressesProvider.getLendingPoolConfigurator() == msg.sender,\\n            \\\"The caller must be a lending pool configurator contract\\\"\\n        );\\n        _;\\n    }\\n\\n    mapping(address => CoreLibrary.ReserveData) internal reserves;\\n    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;\\n\\n    address[] public reservesList;\\n\\n    uint256 public constant CORE_REVISION = 0x7;\\n\\n    /**\\n    * @dev returns the revision number of the contract\\n    **/\\n    function getRevision() internal pure returns (uint256) {\\n        return CORE_REVISION;\\n    }\\n\\n    /**\\n    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider\\n    * @param _addressesProvider the addressesProvider contract\\n    **/\\n\\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\\n        addressesProvider = _addressesProvider;\\n        refreshConfigInternal();\\n    }\\n\\n    /**\\n    * @dev updates the state of the core as a result of a deposit action\\n    * @param _reserve the address of the reserve in which the deposit is happening\\n    * @param _user the address of the the user depositing\\n    * @param _amount the amount being deposited\\n    * @param _isFirstDeposit true if the user is depositing for the first time\\n    **/\\n\\n    function updateStateOnDeposit(\\n        address _reserve,\\n        address _user,\\n        uint256 _amount,\\n        bool _isFirstDeposit\\n    ) external onlyLendingPool {\\n        reserves[_reserve].updateCumulativeIndexes();\\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);\\n\\n        if (_isFirstDeposit) {\\n            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral\\n            setUserUseReserveAsCollateral(_reserve, _user, true);\\n        }\\n    }\\n\\n    /**\\n    * @dev updates the state of the core as a result of a redeem action\\n    * @param _reserve the address of the reserve in which the redeem is happening\\n    * @param _user the address of the the user redeeming\\n    * @param _amountRedeemed the amount being redeemed\\n    * @param _userRedeemedEverything true if the user is redeeming everything\\n    **/\\n    function updateStateOnRedeem(\\n        address _reserve,\\n        address _user,\\n        uint256 _amountRedeemed,\\n        bool _userRedeemedEverything\\n    ) external onlyLendingPool {\\n        //compound liquidity and variable borrow interests\\n        reserves[_reserve].updateCumulativeIndexes();\\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);\\n\\n        //if user redeemed everything the useReserveAsCollateral flag is reset\\n        if (_userRedeemedEverything) {\\n            setUserUseReserveAsCollateral(_reserve, _user, false);\\n        }\\n    }\\n\\n    /**\\n    * @dev updates the state of the core as a result of a flashloan action\\n    * @param _reserve the address of the reserve in which the flashloan is happening\\n    * @param _income the income of the protocol as a result of the action\\n    **/\\n    function updateStateOnFlashLoan(\\n        address _reserve,\\n        uint256 _availableLiquidityBefore,\\n        uint256 _income,\\n        uint256 _protocolFee\\n    ) external onlyLendingPool {\\n        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);\\n\\n        //compounding the cumulated interest\\n        reserves[_reserve].updateCumulativeIndexes();\\n\\n        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(\\n            getReserveTotalBorrows(_reserve)\\n        );\\n\\n        //compounding the received fee into the reserve\\n        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);\\n\\n        //refresh interest rates\\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);\\n    }\\n\\n    /**\\n    * @dev updates the state of the core as a consequence of a borrow action.\\n    * @param _reserve the address of the reserve on which the user is borrowing\\n    * @param _user the address of the borrower\\n    * @param _amountBorrowed the new amount borrowed\\n    * @param _borrowFee the fee on the amount borrowed\\n    * @param _rateMode the borrow rate mode (stable, variable)\\n    * @return the new borrow rate for the user\\n    **/\\n    function updateStateOnBorrow(\\n        address _reserve,\\n        address _user,\\n        uint256 _amountBorrowed,\\n        uint256 _borrowFee,\\n        CoreLibrary.InterestRateMode _rateMode\\n    ) external onlyLendingPool returns (uint256, uint256) {\\n        // getting the previous borrow data of the user\\n        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(\\n            _reserve,\\n            _user\\n        );\\n\\n        updateReserveStateOnBorrowInternal(\\n            _reserve,\\n            _user,\\n            principalBorrowBalance,\\n            balanceIncrease,\\n            _amountBorrowed,\\n            _rateMode\\n        );\\n\\n        updateUserStateOnBorrowInternal(\\n            _reserve,\\n            _user,\\n            _amountBorrowed,\\n            balanceIncrease,\\n            _borrowFee,\\n            _rateMode\\n        );\\n\\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);\\n\\n        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);\\n    }\\n\\n    /**\\n    * @dev updates the state of the core as a consequence of a repay action.\\n    * @param _reserve the address of the reserve on which the user is repaying\\n    * @param _user the address of the borrower\\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\\n    * @param _balanceIncrease the accrued interest on the borrowed amount\\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\\n    **/\\n\\n    function updateStateOnRepay(\\n        address _reserve,\\n        address _user,\\n        uint256 _paybackAmountMinusFees,\\n        uint256 _originationFeeRepaid,\\n        uint256 _balanceIncrease,\\n        bool _repaidWholeLoan\\n    ) external onlyLendingPool {\\n        updateReserveStateOnRepayInternal(\\n            _reserve,\\n            _user,\\n            _paybackAmountMinusFees,\\n            _balanceIncrease\\n        );\\n        updateUserStateOnRepayInternal(\\n            _reserve,\\n            _user,\\n            _paybackAmountMinusFees,\\n            _originationFeeRepaid,\\n            _balanceIncrease,\\n            _repaidWholeLoan\\n        );\\n\\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);\\n    }\\n\\n    /**\\n    * @dev updates the state of the core as a consequence of a swap rate action.\\n    * @param _reserve the address of the reserve on which the user is repaying\\n    * @param _user the address of the borrower\\n    * @param _principalBorrowBalance the amount borrowed by the user\\n    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest\\n    * @param _balanceIncrease the accrued interest on the borrowed amount\\n    * @param _currentRateMode the current interest rate mode for the user\\n    **/\\n    function updateStateOnSwapRate(\\n        address _reserve,\\n        address _user,\\n        uint256 _principalBorrowBalance,\\n        uint256 _compoundedBorrowBalance,\\n        uint256 _balanceIncrease,\\n        CoreLibrary.InterestRateMode _currentRateMode\\n    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {\\n        updateReserveStateOnSwapRateInternal(\\n            _reserve,\\n            _user,\\n            _principalBorrowBalance,\\n            _compoundedBorrowBalance,\\n            _currentRateMode\\n        );\\n\\n        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(\\n            _reserve,\\n            _user,\\n            _balanceIncrease,\\n            _currentRateMode\\n        );\\n\\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\\n\\n        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));\\n    }\\n\\n    /**\\n    * @dev updates the state of the core as a consequence of a liquidation action.\\n    * @param _principalReserve the address of the principal reserve that is being repaid\\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\\n    * @param _user the address of the borrower\\n    * @param _amountToLiquidate the amount being repaid by the liquidator\\n    * @param _collateralToLiquidate the amount of collateral being liquidated\\n    * @param _feeLiquidated the amount of origination fee being liquidated\\n    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus\\n    * @param _balanceIncrease the accrued interest on the borrowed amount\\n    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise\\n    **/\\n    function updateStateOnLiquidation(\\n        address _principalReserve,\\n        address _collateralReserve,\\n        address _user,\\n        uint256 _amountToLiquidate,\\n        uint256 _collateralToLiquidate,\\n        uint256 _feeLiquidated,\\n        uint256 _liquidatedCollateralForFee,\\n        uint256 _balanceIncrease,\\n        bool _liquidatorReceivesAToken\\n    ) external onlyLendingPool {\\n        updatePrincipalReserveStateOnLiquidationInternal(\\n            _principalReserve,\\n            _user,\\n            _amountToLiquidate,\\n            _balanceIncrease\\n        );\\n\\n        updateCollateralReserveStateOnLiquidationInternal(\\n            _collateralReserve\\n        );\\n\\n        updateUserStateOnLiquidationInternal(\\n            _principalReserve,\\n            _user,\\n            _amountToLiquidate,\\n            _feeLiquidated,\\n            _balanceIncrease\\n        );\\n\\n        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);\\n\\n        if (!_liquidatorReceivesAToken) {\\n            updateReserveInterestRatesAndTimestampInternal(\\n                _collateralReserve,\\n                0,\\n                _collateralToLiquidate.add(_liquidatedCollateralForFee)\\n            );\\n        }\\n\\n    }\\n\\n    /**\\n    * @dev updates the state of the core as a consequence of a stable rate rebalance\\n    * @param _reserve the address of the principal reserve where the user borrowed\\n    * @param _user the address of the borrower\\n    * @param _balanceIncrease the accrued interest on the borrowed amount\\n    * @return the new stable rate for the user\\n    **/\\n    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)\\n        external\\n        onlyLendingPool\\n        returns (uint256)\\n    {\\n        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\\n\\n        //update user data and rebalance the rate\\n        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\\n        return usersReserveData[_user][_reserve].stableBorrowRate;\\n    }\\n\\n    /**\\n    * @dev enables or disables a reserve as collateral\\n    * @param _reserve the address of the principal reserve where the user deposited\\n    * @param _user the address of the depositor\\n    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral\\n    **/\\n    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)\\n        public\\n        onlyLendingPool\\n    {\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n        user.useAsCollateral = _useAsCollateral;\\n    }\\n\\n    /**\\n    * @notice ETH/token transfer functions\\n    **/\\n\\n    /**\\n    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers\\n    **/\\n    function() external payable {\\n        //only contracts can send ETH to the core\\n        require(msg.sender.isContract(), \\\"Only contracts can send ether to the Lending pool core\\\");\\n\\n    }\\n\\n    /**\\n    * @dev transfers to the user a specific amount from the reserve.\\n    * @param _reserve the address of the reserve where the transfer is happening\\n    * @param _user the address of the user receiving the transfer\\n    * @param _amount the amount being transferred\\n    **/\\n    function transferToUser(address _reserve, address payable _user, uint256 _amount)\\n        external\\n        onlyLendingPool\\n    {\\n        if (_reserve != EthAddressLib.ethAddress()) {\\n            ERC20(_reserve).safeTransfer(_user, _amount);\\n        } else {\\n            //solium-disable-next-line\\n            (bool result, ) = _user.call.value(_amount).gas(50000)(\\\"\\\");\\n            require(result, \\\"Transfer of ETH failed\\\");\\n        }\\n    }\\n\\n    /**\\n    * @dev transfers the protocol fees to the fees collection address\\n    * @param _token the address of the token being transferred\\n    * @param _user the address of the user from where the transfer is happening\\n    * @param _amount the amount being transferred\\n    * @param _destination the fee receiver address\\n    **/\\n\\n    function transferToFeeCollectionAddress(\\n        address _token,\\n        address _user,\\n        uint256 _amount,\\n        address _destination\\n    ) external payable onlyLendingPool {\\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\\n\\n        if (_token != EthAddressLib.ethAddress()) {\\n            require(\\n                msg.value == 0,\\n                \\\"User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction\\\"\\n            );\\n            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);\\n        } else {\\n            require(msg.value >= _amount, \\\"The amount and the value sent to deposit do not match\\\");\\n            //solium-disable-next-line\\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)(\\\"\\\");\\n            require(result, \\\"Transfer of ETH failed\\\");\\n        }\\n    }\\n\\n    /**\\n    * @dev transfers the fees to the fees collection address in the case of liquidation\\n    * @param _token the address of the token being transferred\\n    * @param _amount the amount being transferred\\n    * @param _destination the fee receiver address\\n    **/\\n    function liquidateFee(\\n        address _token,\\n        uint256 _amount,\\n        address _destination\\n    ) external payable onlyLendingPool {\\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\\n        require(\\n            msg.value == 0,\\n            \\\"Fee liquidation does not require any transfer of value\\\"\\n        );\\n\\n        if (_token != EthAddressLib.ethAddress()) {\\n            ERC20(_token).safeTransfer(feeAddress, _amount);\\n        } else {\\n            //solium-disable-next-line\\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)(\\\"\\\");\\n            require(result, \\\"Transfer of ETH failed\\\");\\n        }\\n    }\\n\\n    /**\\n    * @dev transfers an amount from a user to the destination reserve\\n    * @param _reserve the address of the reserve where the amount is being transferred\\n    * @param _user the address of the user from where the transfer is happening\\n    * @param _amount the amount being transferred\\n    **/\\n    function transferToReserve(address _reserve, address payable _user, uint256 _amount)\\n        external\\n        payable\\n        onlyLendingPool\\n    {\\n        if (_reserve != EthAddressLib.ethAddress()) {\\n            require(msg.value == 0, \\\"User is sending ETH along with the ERC20 transfer.\\\");\\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\\n\\n        } else {\\n            require(msg.value >= _amount, \\\"The amount and the value sent to deposit do not match\\\");\\n\\n            if (msg.value > _amount) {\\n                //send back excess ETH\\n                uint256 excessAmount = msg.value.sub(_amount);\\n                //solium-disable-next-line\\n                (bool result, ) = _user.call.value(excessAmount).gas(50000)(\\\"\\\");\\n                require(result, \\\"Transfer of ETH failed\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice data access functions\\n    **/\\n\\n    /**\\n    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)\\n    * needed to calculate the global account data in the LendingPoolDataProvider\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user\\n    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not\\n    **/\\n    function getUserBasicReserveData(address _reserve, address _user)\\n        external\\n        view\\n        returns (uint256, uint256, uint256, bool)\\n    {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n\\n        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);\\n\\n        if (user.principalBorrowBalance == 0) {\\n            return (underlyingBalance, 0, 0, user.useAsCollateral);\\n        }\\n\\n        return (\\n            underlyingBalance,\\n            user.getCompoundedBorrowBalance(reserve),\\n            user.originationFee,\\n            user.useAsCollateral\\n        );\\n    }\\n\\n    /**\\n    * @dev checks if a user is allowed to borrow at a stable rate\\n    * @param _reserve the reserve address\\n    * @param _user the user\\n    * @param _amount the amount the the user wants to borrow\\n    * @return true if the user is allowed to borrow at a stable rate, false otherwise\\n    **/\\n\\n    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n\\n        if (!reserve.isStableBorrowRateEnabled) return false;\\n\\n        return\\n            !user.useAsCollateral ||\\n            !reserve.usageAsCollateralEnabled ||\\n            _amount > getUserUnderlyingAssetBalance(_reserve, _user);\\n    }\\n\\n    /**\\n    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.\\n    * @param _reserve the reserve address\\n    * @param _user the user address\\n    * @return the underlying deposit balance of the user\\n    **/\\n\\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        AToken aToken = AToken(reserves[_reserve].aTokenAddress);\\n        return aToken.balanceOf(_user);\\n\\n    }\\n\\n    /**\\n    * @dev gets the interest rate strategy contract address for the reserve\\n    * @param _reserve the reserve address\\n    * @return the address of the interest rate strategy contract\\n    **/\\n    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.interestRateStrategyAddress;\\n    }\\n\\n    /**\\n    * @dev gets the aToken contract address for the reserve\\n    * @param _reserve the reserve address\\n    * @return the address of the aToken contract\\n    **/\\n\\n    function getReserveATokenAddress(address _reserve) public view returns (address) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.aTokenAddress;\\n    }\\n\\n    /**\\n    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract\\n    * @param _reserve the reserve address\\n    * @return the available liquidity\\n    **/\\n    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {\\n        uint256 balance = 0;\\n\\n        if (_reserve == EthAddressLib.ethAddress()) {\\n            balance = address(this).balance;\\n        } else {\\n            balance = IERC20(_reserve).balanceOf(address(this));\\n        }\\n        return balance;\\n    }\\n\\n    /**\\n    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows\\n    * @param _reserve the reserve address\\n    * @return the total liquidity\\n    **/\\n    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());\\n    }\\n\\n    /**\\n    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there\\n    * there has been 100% income.\\n    * @param _reserve the reserve address\\n    * @return the reserve normalized income\\n    **/\\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.getNormalizedIncome();\\n    }\\n\\n    /**\\n    * @dev gets the reserve total borrows\\n    * @param _reserve the reserve address\\n    * @return the total borrows (stable + variable)\\n    **/\\n    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {\\n        return reserves[_reserve].getTotalBorrows();\\n    }\\n\\n    /**\\n    * @dev gets the reserve total borrows stable\\n    * @param _reserve the reserve address\\n    * @return the total borrows stable\\n    **/\\n    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.totalBorrowsStable;\\n    }\\n\\n    /**\\n    * @dev gets the reserve total borrows variable\\n    * @param _reserve the reserve address\\n    * @return the total borrows variable\\n    **/\\n\\n    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.totalBorrowsVariable;\\n    }\\n\\n    /**\\n    * @dev gets the reserve liquidation threshold\\n    * @param _reserve the reserve address\\n    * @return the reserve liquidation threshold\\n    **/\\n\\n    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.liquidationThreshold;\\n    }\\n\\n    /**\\n    * @dev gets the reserve liquidation bonus\\n    * @param _reserve the reserve address\\n    * @return the reserve liquidation bonus\\n    **/\\n\\n    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.liquidationBonus;\\n    }\\n\\n    /**\\n    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty\\n    * @param _reserve the reserve address\\n    * @return the reserve current variable borrow rate\\n    **/\\n\\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n\\n        if (reserve.currentVariableBorrowRate == 0) {\\n            return\\n                IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\\n                .getBaseVariableBorrowRate();\\n        }\\n        return reserve.currentVariableBorrowRate;\\n    }\\n\\n    /**\\n    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty\\n    * @param _reserve the reserve address\\n    * @return the reserve current stable borrow rate\\n    **/\\n\\n    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());\\n\\n        if (reserve.currentStableBorrowRate == 0) {\\n            //no stable rate borrows yet\\n            return oracle.getMarketBorrowRate(_reserve);\\n        }\\n\\n        return reserve.currentStableBorrowRate;\\n    }\\n\\n    /**\\n    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average\\n    * of all the loans taken at stable rate.\\n    * @param _reserve the reserve address\\n    * @return the reserve current average borrow rate\\n    **/\\n    function getReserveCurrentAverageStableBorrowRate(address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.currentAverageStableBorrowRate;\\n    }\\n\\n    /**\\n    * @dev gets the reserve liquidity rate\\n    * @param _reserve the reserve address\\n    * @return the reserve liquidity rate\\n    **/\\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.currentLiquidityRate;\\n    }\\n\\n    /**\\n    * @dev gets the reserve liquidity cumulative index\\n    * @param _reserve the reserve address\\n    * @return the reserve liquidity cumulative index\\n    **/\\n    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.lastLiquidityCumulativeIndex;\\n    }\\n\\n    /**\\n    * @dev gets the reserve variable borrow index\\n    * @param _reserve the reserve address\\n    * @return the reserve variable borrow index\\n    **/\\n    function getReserveVariableBorrowsCumulativeIndex(address _reserve)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.lastVariableBorrowCumulativeIndex;\\n    }\\n\\n    /**\\n    * @dev this function aggregates the configuration parameters of the reserve.\\n    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid\\n    * multiple external contract calls to fetch the same data.\\n    * @param _reserve the reserve address\\n    * @return the reserve decimals\\n    * @return the base ltv as collateral\\n    * @return the liquidation threshold\\n    * @return if the reserve is used as collateral or not\\n    **/\\n    function getReserveConfiguration(address _reserve)\\n        external\\n        view\\n        returns (uint256, uint256, uint256, bool)\\n    {\\n        uint256 decimals;\\n        uint256 baseLTVasCollateral;\\n        uint256 liquidationThreshold;\\n        bool usageAsCollateralEnabled;\\n\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        decimals = reserve.decimals;\\n        baseLTVasCollateral = reserve.baseLTVasCollateral;\\n        liquidationThreshold = reserve.liquidationThreshold;\\n        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;\\n\\n        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);\\n    }\\n\\n    /**\\n    * @dev returns the decimals of the reserve\\n    * @param _reserve the reserve address\\n    * @return the reserve decimals\\n    **/\\n    function getReserveDecimals(address _reserve) external view returns (uint256) {\\n        return reserves[_reserve].decimals;\\n    }\\n\\n    /**\\n    * @dev returns true if the reserve is enabled for borrowing\\n    * @param _reserve the reserve address\\n    * @return true if the reserve is enabled for borrowing, false otherwise\\n    **/\\n\\n    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.borrowingEnabled;\\n    }\\n\\n    /**\\n    * @dev returns true if the reserve is enabled as collateral\\n    * @param _reserve the reserve address\\n    * @return true if the reserve is enabled as collateral, false otherwise\\n    **/\\n\\n    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.usageAsCollateralEnabled;\\n    }\\n\\n    /**\\n    * @dev returns true if the stable rate is enabled on reserve\\n    * @param _reserve the reserve address\\n    * @return true if the stable rate is enabled on reserve, false otherwise\\n    **/\\n    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.isStableBorrowRateEnabled;\\n    }\\n\\n    /**\\n    * @dev returns true if the reserve is active\\n    * @param _reserve the reserve address\\n    * @return true if the reserve is active, false otherwise\\n    **/\\n    function getReserveIsActive(address _reserve) external view returns (bool) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.isActive;\\n    }\\n\\n    /**\\n    * @notice returns if a reserve is freezed\\n    * @param _reserve the reserve for which the information is needed\\n    * @return true if the reserve is freezed, false otherwise\\n    **/\\n\\n    function getReserveIsFreezed(address _reserve) external view returns (bool) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        return reserve.isFreezed;\\n    }\\n\\n    /**\\n    * @notice returns the timestamp of the last action on the reserve\\n    * @param _reserve the reserve for which the information is needed\\n    * @return the last updated timestamp of the reserve\\n    **/\\n\\n    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        timestamp = reserve.lastUpdateTimestamp;\\n    }\\n\\n    /**\\n    * @dev returns the utilization rate U of a specific reserve\\n    * @param _reserve the reserve for which the information is needed\\n    * @return the utilization rate in ray\\n    **/\\n\\n    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n\\n        uint256 totalBorrows = reserve.getTotalBorrows();\\n\\n        if (totalBorrows == 0) {\\n            return 0;\\n        }\\n\\n        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);\\n\\n        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\\n    }\\n\\n    /**\\n    * @return the array of reserves configured on the core\\n    **/\\n    function getReserves() external view returns (address[] memory) {\\n        return reservesList;\\n    }\\n\\n    /**\\n    * @param _reserve the address of the reserve for which the information is needed\\n    * @param _user the address of the user for which the information is needed\\n    * @return true if the user has chosen to use the reserve as collateral, false otherwise\\n    **/\\n    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n        return user.useAsCollateral;\\n    }\\n\\n    /**\\n    * @param _reserve the address of the reserve for which the information is needed\\n    * @param _user the address of the user for which the information is needed\\n    * @return the origination fee for the user\\n    **/\\n    function getUserOriginationFee(address _reserve, address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n        return user.originationFee;\\n    }\\n\\n    /**\\n    * @dev users with no loans in progress have NONE as borrow rate mode\\n    * @param _reserve the address of the reserve for which the information is needed\\n    * @param _user the address of the user for which the information is needed\\n    * @return the borrow rate mode for the user,\\n    **/\\n\\n    function getUserCurrentBorrowRateMode(address _reserve, address _user)\\n        public\\n        view\\n        returns (CoreLibrary.InterestRateMode)\\n    {\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n\\n        if (user.principalBorrowBalance == 0) {\\n            return CoreLibrary.InterestRateMode.NONE;\\n        }\\n\\n        return\\n            user.stableBorrowRate > 0\\n            ? CoreLibrary.InterestRateMode.STABLE\\n            : CoreLibrary.InterestRateMode.VARIABLE;\\n    }\\n\\n    /**\\n    * @dev gets the current borrow rate of the user\\n    * @param _reserve the address of the reserve for which the information is needed\\n    * @param _user the address of the user for which the information is needed\\n    * @return the borrow rate for the user,\\n    **/\\n    function getUserCurrentBorrowRate(address _reserve, address _user)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);\\n\\n        if (rateMode == CoreLibrary.InterestRateMode.NONE) {\\n            return 0;\\n        }\\n\\n        return\\n            rateMode == CoreLibrary.InterestRateMode.STABLE\\n            ? usersReserveData[_user][_reserve].stableBorrowRate\\n            : reserves[_reserve].currentVariableBorrowRate;\\n    }\\n\\n    /**\\n    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all\\n    * @param _reserve the address of the reserve for which the information is needed\\n    * @param _user the address of the user for which the information is needed\\n    * @return the user stable rate\\n    **/\\n    function getUserCurrentStableBorrowRate(address _reserve, address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n        return user.stableBorrowRate;\\n    }\\n\\n    /**\\n    * @dev calculates and returns the borrow balances of the user\\n    * @param _reserve the address of the reserve\\n    * @param _user the address of the user\\n    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance\\n    **/\\n\\n    function getUserBorrowBalances(address _reserve, address _user)\\n        public\\n        view\\n        returns (uint256, uint256, uint256)\\n    {\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n        if (user.principalBorrowBalance == 0) {\\n            return (0, 0, 0);\\n        }\\n\\n        uint256 principal = user.principalBorrowBalance;\\n        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(\\n            user,\\n            reserves[_reserve]\\n        );\\n        return (principal, compoundedBalance, compoundedBalance.sub(principal));\\n    }\\n\\n    /**\\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\\n    * @param _reserve the address of the reserve for which the information is needed\\n    * @param _user the address of the user for which the information is needed\\n    * @return the variable borrow index for the user\\n    **/\\n\\n    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n        return user.lastVariableBorrowCumulativeIndex;\\n    }\\n\\n    /**\\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\\n    * @param _reserve the address of the reserve for which the information is needed\\n    * @param _user the address of the user for which the information is needed\\n    * @return the variable borrow index for the user\\n    **/\\n\\n    function getUserLastUpdate(address _reserve, address _user)\\n        external\\n        view\\n        returns (uint256 timestamp)\\n    {\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n        timestamp = user.lastUpdateTimestamp;\\n    }\\n\\n    /**\\n    * @dev updates the lending pool core configuration\\n    **/\\n    function refreshConfiguration() external onlyLendingPoolConfigurator {\\n        refreshConfigInternal();\\n    }\\n\\n    /**\\n    * @dev initializes a reserve\\n    * @param _reserve the address of the reserve\\n    * @param _aTokenAddress the address of the overlying aToken contract\\n    * @param _decimals the decimals of the reserve currency\\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\\n    **/\\n    function initReserve(\\n        address _reserve,\\n        address _aTokenAddress,\\n        uint256 _decimals,\\n        address _interestRateStrategyAddress\\n    ) external onlyLendingPoolConfigurator {\\n        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);\\n        addReserveToListInternal(_reserve);\\n\\n    }\\n\\n\\n\\n    /**\\n    * @dev removes the last added reserve in the reservesList array\\n    * @param _reserveToRemove the address of the reserve\\n    **/\\n    function removeLastAddedReserve(address _reserveToRemove)\\n     external onlyLendingPoolConfigurator {\\n\\n        address lastReserve = reservesList[reservesList.length-1];\\n\\n        require(lastReserve == _reserveToRemove, \\\"Reserve being removed is different than the reserve requested\\\");\\n\\n        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed\\n        require(getReserveTotalBorrows(lastReserve) == 0, \\\"Cannot remove a reserve with liquidity deposited\\\");\\n\\n        reserves[lastReserve].isActive = false;\\n        reserves[lastReserve].aTokenAddress = address(0);\\n        reserves[lastReserve].decimals = 0;\\n        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;\\n        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;\\n        reserves[lastReserve].borrowingEnabled = false;\\n        reserves[lastReserve].usageAsCollateralEnabled = false;\\n        reserves[lastReserve].baseLTVasCollateral = 0;\\n        reserves[lastReserve].liquidationThreshold = 0;\\n        reserves[lastReserve].liquidationBonus = 0;\\n        reserves[lastReserve].interestRateStrategyAddress = address(0);\\n\\n        reservesList.pop();\\n    }\\n\\n    /**\\n    * @dev updates the address of the interest rate strategy contract\\n    * @param _reserve the address of the reserve\\n    * @param _rateStrategyAddress the address of the interest rate strategy contract\\n    **/\\n\\n    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\\n        external\\n        onlyLendingPoolConfigurator\\n    {\\n        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;\\n    }\\n\\n    /**\\n    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing\\n    * @param _reserve the address of the reserve\\n    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise\\n    **/\\n\\n    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\\n        external\\n        onlyLendingPoolConfigurator\\n    {\\n        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);\\n    }\\n\\n    /**\\n    * @dev disables borrowing on a reserve\\n    * @param _reserve the address of the reserve\\n    **/\\n\\n    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {\\n        reserves[_reserve].disableBorrowing();\\n    }\\n\\n    /**\\n    * @dev enables a reserve to be used as collateral\\n    * @param _reserve the address of the reserve\\n    **/\\n    function enableReserveAsCollateral(\\n        address _reserve,\\n        uint256 _baseLTVasCollateral,\\n        uint256 _liquidationThreshold,\\n        uint256 _liquidationBonus\\n    ) external onlyLendingPoolConfigurator {\\n        reserves[_reserve].enableAsCollateral(\\n            _baseLTVasCollateral,\\n            _liquidationThreshold,\\n            _liquidationBonus\\n        );\\n    }\\n\\n    /**\\n    * @dev disables a reserve to be used as collateral\\n    * @param _reserve the address of the reserve\\n    **/\\n    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {\\n        reserves[_reserve].disableAsCollateral();\\n    }\\n\\n    /**\\n    * @dev enable the stable borrow rate mode on a reserve\\n    * @param _reserve the address of the reserve\\n    **/\\n    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        reserve.isStableBorrowRateEnabled = true;\\n    }\\n\\n    /**\\n    * @dev disable the stable borrow rate mode on a reserve\\n    * @param _reserve the address of the reserve\\n    **/\\n    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        reserve.isStableBorrowRateEnabled = false;\\n    }\\n\\n    /**\\n    * @dev activates a reserve\\n    * @param _reserve the address of the reserve\\n    **/\\n    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n\\n        require(\\n            reserve.lastLiquidityCumulativeIndex > 0 &&\\n                reserve.lastVariableBorrowCumulativeIndex > 0,\\n            \\\"Reserve has not been initialized yet\\\"\\n        );\\n        reserve.isActive = true;\\n    }\\n\\n    /**\\n    * @dev deactivates a reserve\\n    * @param _reserve the address of the reserve\\n    **/\\n    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        reserve.isActive = false;\\n    }\\n\\n    /**\\n    * @notice allows the configurator to freeze the reserve.\\n    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.\\n    * @param _reserve the address of the reserve\\n    **/\\n    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        reserve.isFreezed = true;\\n    }\\n\\n    /**\\n    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.\\n    * @param _reserve the address of the reserve\\n    **/\\n    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        reserve.isFreezed = false;\\n    }\\n\\n    /**\\n    * @notice allows the configurator to update the loan to value of a reserve\\n    * @param _reserve the address of the reserve\\n    * @param _ltv the new loan to value\\n    **/\\n    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\\n        external\\n        onlyLendingPoolConfigurator\\n    {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        reserve.baseLTVasCollateral = _ltv;\\n    }\\n\\n    /**\\n    * @notice allows the configurator to update the liquidation threshold of a reserve\\n    * @param _reserve the address of the reserve\\n    * @param _threshold the new liquidation threshold\\n    **/\\n    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\\n        external\\n        onlyLendingPoolConfigurator\\n    {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        reserve.liquidationThreshold = _threshold;\\n    }\\n\\n    /**\\n    * @notice allows the configurator to update the liquidation bonus of a reserve\\n    * @param _reserve the address of the reserve\\n    * @param _bonus the new liquidation bonus\\n    **/\\n    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\\n        external\\n        onlyLendingPoolConfigurator\\n    {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        reserve.liquidationBonus = _bonus;\\n    }\\n\\n    /**\\n    * @notice allows the configurator to update the reserve decimals\\n    * @param _reserve the address of the reserve\\n    * @param _decimals the decimals of the reserve\\n    **/\\n    function setReserveDecimals(address _reserve, uint256 _decimals)\\n        external\\n        onlyLendingPoolConfigurator\\n    {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        reserve.decimals = _decimals;\\n    }\\n\\n    /**\\n    * @notice internal functions\\n    **/\\n\\n    /**\\n    * @dev updates the state of a reserve as a consequence of a borrow action.\\n    * @param _reserve the address of the reserve on which the user is borrowing\\n    * @param _user the address of the borrower\\n    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action\\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\\n    * @param _amountBorrowed the new amount borrowed\\n    * @param _rateMode the borrow rate mode (stable, variable)\\n    **/\\n\\n    function updateReserveStateOnBorrowInternal(\\n        address _reserve,\\n        address _user,\\n        uint256 _principalBorrowBalance,\\n        uint256 _balanceIncrease,\\n        uint256 _amountBorrowed,\\n        CoreLibrary.InterestRateMode _rateMode\\n    ) internal {\\n        reserves[_reserve].updateCumulativeIndexes();\\n\\n        //increasing reserve total borrows to account for the new borrow balance of the user\\n        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa\\n\\n        updateReserveTotalBorrowsByRateModeInternal(\\n            _reserve,\\n            _user,\\n            _principalBorrowBalance,\\n            _balanceIncrease,\\n            _amountBorrowed,\\n            _rateMode\\n        );\\n    }\\n\\n    /**\\n    * @dev updates the state of a user as a consequence of a borrow action.\\n    * @param _reserve the address of the reserve on which the user is borrowing\\n    * @param _user the address of the borrower\\n    * @param _amountBorrowed the amount borrowed\\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\\n    * @param _rateMode the borrow rate mode (stable, variable)\\n    * @return the final borrow rate for the user. Emitted by the borrow() event\\n    **/\\n\\n    function updateUserStateOnBorrowInternal(\\n        address _reserve,\\n        address _user,\\n        uint256 _amountBorrowed,\\n        uint256 _balanceIncrease,\\n        uint256 _fee,\\n        CoreLibrary.InterestRateMode _rateMode\\n    ) internal {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n\\n        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {\\n            //stable\\n            //reset the user variable index, and update the stable rate\\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\\n            user.lastVariableBorrowCumulativeIndex = 0;\\n        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {\\n            //variable\\n            //reset the user stable rate, and store the new borrow index\\n            user.stableBorrowRate = 0;\\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\\n        } else {\\n            revert(\\\"Invalid borrow rate mode\\\");\\n        }\\n        //increase the principal borrows and the origination fee\\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(\\n            _balanceIncrease\\n        );\\n        user.originationFee = user.originationFee.add(_fee);\\n\\n        //solium-disable-next-line\\n        user.lastUpdateTimestamp = uint40(block.timestamp);\\n\\n    }\\n\\n    /**\\n    * @dev updates the state of the reserve as a consequence of a repay action.\\n    * @param _reserve the address of the reserve on which the user is repaying\\n    * @param _user the address of the borrower\\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\\n    * @param _balanceIncrease the accrued interest on the borrowed amount\\n    **/\\n\\n    function updateReserveStateOnRepayInternal(\\n        address _reserve,\\n        address _user,\\n        uint256 _paybackAmountMinusFees,\\n        uint256 _balanceIncrease\\n    ) internal {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n\\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);\\n\\n        //update the indexes\\n        reserves[_reserve].updateCumulativeIndexes();\\n\\n        //compound the cumulated interest to the borrow balance and then subtracting the payback amount\\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\\n                _balanceIncrease,\\n                user.stableBorrowRate\\n            );\\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\\n                _paybackAmountMinusFees,\\n                user.stableBorrowRate\\n            );\\n        } else {\\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\\n            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);\\n        }\\n    }\\n\\n    /**\\n    * @dev updates the state of the user as a consequence of a repay action.\\n    * @param _reserve the address of the reserve on which the user is repaying\\n    * @param _user the address of the borrower\\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\\n    * @param _balanceIncrease the accrued interest on the borrowed amount\\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\\n    **/\\n    function updateUserStateOnRepayInternal(\\n        address _reserve,\\n        address _user,\\n        uint256 _paybackAmountMinusFees,\\n        uint256 _originationFeeRepaid,\\n        uint256 _balanceIncrease,\\n        bool _repaidWholeLoan\\n    ) internal {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n\\n        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount\\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\\n            _paybackAmountMinusFees\\n        );\\n        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\\n\\n        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)\\n        //and the rate mode is stable, we reset the interest rate mode of the user\\n        if (_repaidWholeLoan) {\\n            user.stableBorrowRate = 0;\\n            user.lastVariableBorrowCumulativeIndex = 0;\\n        }\\n        user.originationFee = user.originationFee.sub(_originationFeeRepaid);\\n\\n        //solium-disable-next-line\\n        user.lastUpdateTimestamp = uint40(block.timestamp);\\n\\n    }\\n\\n    /**\\n    * @dev updates the state of the user as a consequence of a swap rate action.\\n    * @param _reserve the address of the reserve on which the user is performing the rate swap\\n    * @param _user the address of the borrower\\n    * @param _principalBorrowBalance the the principal amount borrowed by the user\\n    * @param _compoundedBorrowBalance the principal amount plus the accrued interest\\n    * @param _currentRateMode the rate mode at which the user borrowed\\n    **/\\n    function updateReserveStateOnSwapRateInternal(\\n        address _reserve,\\n        address _user,\\n        uint256 _principalBorrowBalance,\\n        uint256 _compoundedBorrowBalance,\\n        CoreLibrary.InterestRateMode _currentRateMode\\n    ) internal {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n\\n        //compounding reserve indexes\\n        reserve.updateCumulativeIndexes();\\n\\n        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\\n            uint256 userCurrentStableRate = user.stableBorrowRate;\\n\\n            //swap to variable\\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\\n                _principalBorrowBalance,\\n                userCurrentStableRate\\n            ); //decreasing stable from old principal balance\\n            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows\\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\\n            //swap to stable\\n            uint256 currentStableRate = reserve.currentStableBorrowRate;\\n            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);\\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\\n                _compoundedBorrowBalance,\\n                currentStableRate\\n            );\\n\\n        } else {\\n            revert(\\\"Invalid rate mode received\\\");\\n        }\\n    }\\n\\n    /**\\n    * @dev updates the state of the user as a consequence of a swap rate action.\\n    * @param _reserve the address of the reserve on which the user is performing the swap\\n    * @param _user the address of the borrower\\n    * @param _balanceIncrease the accrued interest on the borrowed amount\\n    * @param _currentRateMode the current rate mode of the user\\n    **/\\n\\n    function updateUserStateOnSwapRateInternal(\\n        address _reserve,\\n        address _user,\\n        uint256 _balanceIncrease,\\n        CoreLibrary.InterestRateMode _currentRateMode\\n    ) internal returns (CoreLibrary.InterestRateMode) {\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n\\n        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;\\n\\n        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\\n            //switch to stable\\n            newMode = CoreLibrary.InterestRateMode.STABLE;\\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\\n            user.lastVariableBorrowCumulativeIndex = 0;\\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\\n            newMode = CoreLibrary.InterestRateMode.VARIABLE;\\n            user.stableBorrowRate = 0;\\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\\n        } else {\\n            revert(\\\"Invalid interest rate mode received\\\");\\n        }\\n        //compounding cumulated interest\\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\\n        //solium-disable-next-line\\n        user.lastUpdateTimestamp = uint40(block.timestamp);\\n\\n        return newMode;\\n    }\\n\\n    /**\\n    * @dev updates the state of the principal reserve as a consequence of a liquidation action.\\n    * @param _principalReserve the address of the principal reserve that is being repaid\\n    * @param _user the address of the borrower\\n    * @param _amountToLiquidate the amount being repaid by the liquidator\\n    * @param _balanceIncrease the accrued interest on the borrowed amount\\n    **/\\n\\n    function updatePrincipalReserveStateOnLiquidationInternal(\\n        address _principalReserve,\\n        address _user,\\n        uint256 _amountToLiquidate,\\n        uint256 _balanceIncrease\\n    ) internal {\\n        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];\\n\\n        //update principal reserve data\\n        reserve.updateCumulativeIndexes();\\n\\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(\\n            _principalReserve,\\n            _user\\n        );\\n\\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\\n            //increase the total borrows by the compounded interest\\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\\n                _balanceIncrease,\\n                user.stableBorrowRate\\n            );\\n\\n            //decrease by the actual amount to liquidate\\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\\n                _amountToLiquidate,\\n                user.stableBorrowRate\\n            );\\n\\n        } else {\\n            //increase the total borrows by the compounded interest\\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\\n\\n            //decrease by the actual amount to liquidate\\n            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);\\n        }\\n\\n    }\\n\\n    /**\\n    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.\\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\\n    **/\\n    function updateCollateralReserveStateOnLiquidationInternal(\\n        address _collateralReserve\\n    ) internal {\\n        //update collateral reserve\\n        reserves[_collateralReserve].updateCumulativeIndexes();\\n\\n    }\\n\\n    /**\\n    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.\\n    * @param _reserve the address of the principal reserve that is being repaid\\n    * @param _user the address of the borrower\\n    * @param _amountToLiquidate the amount being repaid by the liquidator\\n    * @param _feeLiquidated the amount of origination fee being liquidated\\n    * @param _balanceIncrease the accrued interest on the borrowed amount\\n    **/\\n    function updateUserStateOnLiquidationInternal(\\n        address _reserve,\\n        address _user,\\n        uint256 _amountToLiquidate,\\n        uint256 _feeLiquidated,\\n        uint256 _balanceIncrease\\n    ) internal {\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        //first increase by the compounded interest, then decrease by the liquidated amount\\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\\n            _amountToLiquidate\\n        );\\n\\n        if (\\n            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE\\n        ) {\\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\\n        }\\n\\n        if(_feeLiquidated > 0){\\n            user.originationFee = user.originationFee.sub(_feeLiquidated);\\n        }\\n\\n        //solium-disable-next-line\\n        user.lastUpdateTimestamp = uint40(block.timestamp);\\n    }\\n\\n    /**\\n    * @dev updates the state of the reserve as a consequence of a stable rate rebalance\\n    * DEPRECATED FOR THE V1 -> V2 migration\\n    * @param _reserve the address of the principal reserve where the user borrowed\\n    * @param _user the address of the borrower\\n    * @param _balanceIncrease the accrued interest on the borrowed amount\\n    **/\\n\\n    function updateReserveStateOnRebalanceInternal(\\n        address _reserve,\\n        address _user,\\n        uint256 _balanceIncrease\\n    ) internal {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n\\n        reserve.updateCumulativeIndexes();\\n\\n        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\\n            _balanceIncrease,\\n            user.stableBorrowRate\\n        );\\n\\n    }\\n\\n    /**\\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\\n    * @param _reserve the address of the principal reserve where the user borrowed\\n    * @param _user the address of the borrower\\n    * @param _balanceIncrease the accrued interest on the borrowed amount\\n    **/\\n\\n    function updateUserStateOnRebalanceInternal(\\n        address _reserve,\\n        address _user,\\n        uint256 _balanceIncrease\\n    ) internal {\\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n\\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\\n        user.stableBorrowRate = reserve.currentStableBorrowRate;\\n\\n        //solium-disable-next-line\\n        user.lastUpdateTimestamp = uint40(block.timestamp);\\n    }\\n\\n    /**\\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\\n    * @param _reserve the address of the principal reserve where the user borrowed\\n    * @param _user the address of the borrower\\n    * @param _balanceIncrease the accrued interest on the borrowed amount\\n    * @param _amountBorrowed the accrued interest on the borrowed amount\\n    **/\\n    function updateReserveTotalBorrowsByRateModeInternal(\\n        address _reserve,\\n        address _user,\\n        uint256 _principalBalance,\\n        uint256 _balanceIncrease,\\n        uint256 _amountBorrowed,\\n        CoreLibrary.InterestRateMode _newBorrowRateMode\\n    ) internal {\\n        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\\n            _reserve,\\n            _user\\n        );\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n\\n        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {\\n            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\\n                _principalBalance,\\n                user.stableBorrowRate\\n            );\\n        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\\n            reserve.decreaseTotalBorrowsVariable(_principalBalance);\\n        }\\n\\n        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);\\n        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\\n                newPrincipalAmount,\\n                reserve.currentStableBorrowRate\\n            );\\n        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\\n            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);\\n        } else {\\n            revert(\\\"Invalid new borrow rate mode\\\");\\n        }\\n    }\\n\\n    /**\\n    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\\n    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\\n    * @param _reserve the address of the reserve to be updated\\n    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\\n    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\\n    **/\\n\\n    function updateReserveInterestRatesAndTimestampInternal(\\n        address _reserve,\\n        uint256 _liquidityAdded,\\n        uint256 _liquidityTaken\\n    ) internal {\\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\\n        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(\\n            reserve\\n                .interestRateStrategyAddress\\n        )\\n            .calculateInterestRates(\\n            _reserve,\\n            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),\\n            reserve.totalBorrowsStable,\\n            reserve.totalBorrowsVariable,\\n            reserve.currentAverageStableBorrowRate\\n        );\\n\\n        reserve.currentLiquidityRate = newLiquidityRate;\\n        reserve.currentStableBorrowRate = newStableRate;\\n        reserve.currentVariableBorrowRate = newVariableRate;\\n\\n        //solium-disable-next-line\\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\\n\\n        emit ReserveUpdated(\\n            _reserve,\\n            newLiquidityRate,\\n            newStableRate,\\n            newVariableRate,\\n            reserve.lastLiquidityCumulativeIndex,\\n            reserve.lastVariableBorrowCumulativeIndex\\n        );\\n    }\\n\\n    /**\\n    * @dev transfers to the protocol fees of a flashloan to the fees collection address\\n    * @param _token the address of the token being transferred\\n    * @param _amount the amount being transferred\\n    **/\\n\\n    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {\\n        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));\\n\\n        if (_token != EthAddressLib.ethAddress()) {\\n            ERC20(_token).safeTransfer(receiver, _amount);\\n        } else {\\n            //solium-disable-next-line\\n            (bool result, ) = receiver.call.value(_amount)(\\\"\\\");\\n            require(result, \\\"Transfer to token distributor failed\\\");\\n        }\\n    }\\n\\n    /**\\n    * @dev updates the internal configuration of the core\\n    **/\\n    function refreshConfigInternal() internal {\\n        lendingPoolAddress = addressesProvider.getLendingPool();\\n    }\\n\\n    /**\\n    * @dev adds a reserve to the array of the reserves address\\n    **/\\n    function addReserveToListInternal(address _reserve) internal {\\n        bool reserveAlreadyAdded = false;\\n        for (uint256 i = 0; i < reservesList.length; i++)\\n            if (reservesList[i] == _reserve) {\\n                reserveAlreadyAdded = true;\\n            }\\n        if (!reserveAlreadyAdded) reservesList.push(_reserve);\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"solidity-utils/=lib/solidity-utils/src/\",\r\n      \"aave-address-bool/=lib/aave-address-bool/\",\r\n      \"rescue-mission-phase-1/=lib/rescue-mission-phase-1/src/\",\r\n      \"@aave/core-v3/=lib/aave-address-book/lib/aave-v3-core/\",\r\n      \"@aave/periphery-v3/=lib/aave-address-book/lib/aave-v3-periphery/\",\r\n      \"aave-address-book/=lib/aave-address-book/src/\",\r\n      \"aave-autonomous-proposal/=lib/rescue-mission-phase-1/lib/aave-autonomous-proposal/\",\r\n      \"aave-helpers/=lib/rescue-mission-phase-1/lib/aave-helpers/src/\",\r\n      \"aave-v3-core/=lib/aave-address-book/lib/aave-v3-core/\",\r\n      \"aave-v3-periphery/=lib/aave-address-book/lib/aave-v3-periphery/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_borrowRateMode\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_borrowRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_originationFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_borrowBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"_referral\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"_referral\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"FlashLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_purchaseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_liquidatedCollateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_accruedBorrowInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_receiveAToken\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"LiquidationCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_feeLiquidated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_liquidatedCollateralForFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"OriginationFeeLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newStableRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_borrowBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"RebalanceStableBorrowRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"RedeemUnderlying\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_repayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountMinusFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_borrowBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Repay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"ReserveUsedAsCollateralDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"ReserveUsedAsCollateralEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newRateMode\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_borrowBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenRescued\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountRescued\",\"type\":\"uint256\"}],\"name\":\"TokensRescued\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"LENDINGPOOL_REVISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_MAX_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressesProvider\",\"outputs\":[{\"internalType\":\"contract LendingPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestRateMode\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_referralCode\",\"type\":\"uint16\"}],\"name\":\"borrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"core\",\"outputs\":[{\"internalType\":\"contract LendingPoolCore\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dataProvider\",\"outputs\":[{\"internalType\":\"contract LendingPoolDataProvider\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_referralCode\",\"type\":\"uint16\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"}],\"name\":\"getReserveConfigurationData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationBonus\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"interestRateStrategyAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"usageAsCollateralEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"borrowingEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"stableBorrowRateEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"}],\"name\":\"getReserveData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowsStable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowsVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variableBorrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableBorrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"averageStableBorrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variableBorrowIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"aTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint40\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserAccountData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalLiquidityETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateralETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowsETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFeesETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableBorrowsETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentLiquidationThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"healthFactor\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserReserveData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentATokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentBorrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalBorrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRateMode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originationFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variableBorrowIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"usageAsCollateralEnabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract LendingPoolAddressesProvider\",\"name\":\"_addressesProvider\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_purchaseAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_receiveAToken\",\"type\":\"bool\"}],\"name\":\"liquidationCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"parametersProvider\",\"outputs\":[{\"internalType\":\"contract LendingPoolParametersProvider\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"rebalanceStableBorrowRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_aTokenBalanceAfterRedeem\",\"type\":\"uint256\"}],\"name\":\"redeemUnderlying\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_onBehalfOf\",\"type\":\"address\"}],\"name\":\"repay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_useAsCollateral\",\"type\":\"bool\"}],\"name\":\"setUserUseReserveAsCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"}],\"name\":\"swapBorrowRateMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LendingPool", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}