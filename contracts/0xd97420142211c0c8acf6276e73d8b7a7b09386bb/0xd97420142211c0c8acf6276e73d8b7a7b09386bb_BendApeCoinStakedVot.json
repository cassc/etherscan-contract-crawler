{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC4626Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\\n *\\n * _Available since v4.7._\\n */\\ninterface IERC4626Upgradeable is IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC721EnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/extensions/IERC721MetadataUpgradeable.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721ReceiverUpgradeable.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IApeCoinStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\ninterface IApeCoinStaking {\\n    struct SingleNft {\\n        uint32 tokenId;\\n        uint224 amount;\\n    }\\n\\n    struct PairNft {\\n        uint128 mainTokenId;\\n        uint128 bakcTokenId;\\n    }\\n\\n    struct PairNftDepositWithAmount {\\n        uint32 mainTokenId;\\n        uint32 bakcTokenId;\\n        uint184 amount;\\n    }\\n    struct PairNftWithdrawWithAmount {\\n        uint32 mainTokenId;\\n        uint32 bakcTokenId;\\n        uint184 amount;\\n        bool isUncommit;\\n    }\\n    struct Position {\\n        uint256 stakedAmount;\\n        int256 rewardsDebt;\\n    }\\n\\n    struct Pool {\\n        uint48 lastRewardedTimestampHour;\\n        uint16 lastRewardsRangeIndex;\\n        uint96 stakedAmount;\\n        uint96 accumulatedRewardsPerShare;\\n        TimeRange[] timeRanges;\\n    }\\n\\n    struct TimeRange {\\n        uint48 startTimestampHour;\\n        uint48 endTimestampHour;\\n        uint96 rewardsPerHour;\\n        uint96 capPerPosition;\\n    }\\n\\n    struct PoolWithoutTimeRange {\\n        uint48 lastRewardedTimestampHour;\\n        uint16 lastRewardsRangeIndex;\\n        uint96 stakedAmount;\\n        uint96 accumulatedRewardsPerShare;\\n    }\\n\\n    struct DashboardStake {\\n        uint256 poolId;\\n        uint256 tokenId;\\n        uint256 deposited;\\n        uint256 unclaimed;\\n        uint256 rewards24hr;\\n        DashboardPair pair;\\n    }\\n\\n    struct DashboardPair {\\n        uint256 mainTokenId;\\n        uint256 mainTypePoolId;\\n    }\\n\\n    struct PoolUI {\\n        uint256 poolId;\\n        uint256 stakedAmount;\\n        TimeRange currentTimeRange;\\n    }\\n\\n    struct PairingStatus {\\n        uint248 tokenId;\\n        bool isPaired;\\n    }\\n\\n    function mainToBakc(uint256 poolId_, uint256 mainTokenId_) external view returns (PairingStatus memory);\\n\\n    function bakcToMain(uint256 poolId_, uint256 bakcTokenId_) external view returns (PairingStatus memory);\\n\\n    function nftContracts(uint256 poolId_) external view returns (address);\\n\\n    function rewardsBy(uint256 poolId_, uint256 from_, uint256 to_) external view returns (uint256, uint256);\\n\\n    function apeCoin() external view returns (address);\\n\\n    function getCurrentTimeRangeIndex(Pool memory pool_) external view returns (uint256);\\n\\n    function getTimeRangeBy(uint256 poolId_, uint256 index_) external view returns (TimeRange memory);\\n\\n    function getPoolsUI() external view returns (PoolUI memory, PoolUI memory, PoolUI memory, PoolUI memory);\\n\\n    function getSplitStakes(address address_) external view returns (DashboardStake[] memory);\\n\\n    function stakedTotal(address addr_) external view returns (uint256);\\n\\n    function pools(uint256 poolId_) external view returns (PoolWithoutTimeRange memory);\\n\\n    function nftPosition(uint256 poolId_, uint256 tokenId_) external view returns (Position memory);\\n\\n    function addressPosition(address addr_) external view returns (Position memory);\\n\\n    function pendingRewards(uint256 poolId_, address address_, uint256 tokenId_) external view returns (uint256);\\n\\n    function depositBAYC(SingleNft[] calldata nfts_) external;\\n\\n    function depositMAYC(SingleNft[] calldata nfts_) external;\\n\\n    function depositBAKC(\\n        PairNftDepositWithAmount[] calldata baycPairs_,\\n        PairNftDepositWithAmount[] calldata maycPairs_\\n    ) external;\\n\\n    function depositSelfApeCoin(uint256 amount_) external;\\n\\n    function claimSelfApeCoin() external;\\n\\n    function claimBAYC(uint256[] calldata nfts_, address recipient_) external;\\n\\n    function claimMAYC(uint256[] calldata nfts_, address recipient_) external;\\n\\n    function claimBAKC(PairNft[] calldata baycPairs_, PairNft[] calldata maycPairs_, address recipient_) external;\\n\\n    function withdrawBAYC(SingleNft[] calldata nfts_, address recipient_) external;\\n\\n    function withdrawMAYC(SingleNft[] calldata nfts_, address recipient_) external;\\n\\n    function withdrawBAKC(\\n        PairNftWithdrawWithAmount[] calldata baycPairs_,\\n        PairNftWithdrawWithAmount[] calldata maycPairs_\\n    ) external;\\n\\n    function withdrawSelfApeCoin(uint256 amount_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBNFTRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\ninterface IBNFTRegistry {\\n    function getBNFTAddresses(address nftAsset) external view returns (address bNftProxy, address bNftImpl);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICoinPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport {IERC4626Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC4626Upgradeable.sol\\\";\\n\\ninterface ICoinPool is IERC4626Upgradeable {\\n    event RewardDistributed(uint256 rewardAmount);\\n\\n    function mintSelf(uint256 shares) external returns (uint256);\\n\\n    function depositSelf(uint256 assets) external returns (uint256);\\n\\n    function withdrawSelf(uint256 assets) external returns (uint256);\\n\\n    function redeemSelf(uint256 shares) external returns (uint256);\\n\\n    function pendingApeCoin() external view returns (uint256);\\n\\n    function assetBalanceOf(address account_) external view returns (uint256);\\n\\n    function pullApeCoin(uint256 amount_) external;\\n\\n    function receiveApeCoin(uint256 principalAmount, uint256 rewardsAmount_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INftPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\nimport {IApeCoinStaking} from \\\"./IApeCoinStaking.sol\\\";\\nimport {IStakeManager} from \\\"./IStakeManager.sol\\\";\\nimport {IStakedNft} from \\\"./IStakedNft.sol\\\";\\n\\ninterface INftPool {\\n    event NftRewardDistributed(address indexed nft, uint256 rewardAmount);\\n\\n    event NftRewardClaimed(\\n        address indexed nft,\\n        uint256[] tokenIds,\\n        address indexed receiver,\\n        uint256 amount,\\n        uint256 rewardsDebt\\n    );\\n\\n    event NftDeposited(address indexed nft, uint256[] tokenIds, address indexed owner);\\n\\n    event NftWithdrawn(address indexed nft, uint256[] tokenIds, address indexed owner);\\n\\n    struct PoolState {\\n        IStakedNft stakedNft;\\n        uint256 accumulatedRewardsPerNft;\\n        mapping(uint256 => uint256) rewardsDebt;\\n        uint256 pendingApeCoin;\\n    }\\n\\n    struct PoolUI {\\n        uint256 totalStakedNft;\\n        uint256 accumulatedRewardsPerNft;\\n        uint256 pendingApeCoin;\\n    }\\n\\n    function claimable(address[] calldata nfts_, uint256[][] calldata tokenIds_) external view returns (uint256);\\n\\n    function staker() external view returns (IStakeManager);\\n\\n    function deposit(address[] calldata nfts_, uint256[][] calldata tokenIds_) external;\\n\\n    function withdraw(address[] calldata nfts_, uint256[][] calldata tokenIds_) external;\\n\\n    function claim(address[] calldata nfts_, uint256[][] calldata tokenIds_) external;\\n\\n    function receiveApeCoin(address nft_, uint256 rewardsAmount_) external;\\n\\n    function compoundApeCoin(address nft_) external;\\n\\n    function pendingApeCoin(address nft_) external view returns (uint256);\\n\\n    function getPoolStateUI(address nft_) external view returns (PoolUI memory);\\n\\n    function getNftStateUI(address nft_, uint256 tokenId) external view returns (uint256 rewardsDebt);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewardsStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\ninterface IRewardsStrategy {\\n    function getNftRewardsShare() external view returns (uint256 nftShare);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakedNft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport {IERC721MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol\\\";\\nimport {IERC721ReceiverUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol\\\";\\nimport {IERC721EnumerableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC721EnumerableUpgradeable.sol\\\";\\n\\ninterface IStakedNft is IERC721MetadataUpgradeable, IERC721ReceiverUpgradeable, IERC721EnumerableUpgradeable {\\n    event Minted(address indexed to, uint256[] tokenId);\\n    event Burned(address indexed from, uint256[] tokenId);\\n\\n    function authorise(address addr_, bool authorized_) external;\\n\\n    function mint(address to, uint256[] calldata tokenIds) external;\\n\\n    function burn(uint256[] calldata tokenIds) external;\\n\\n    /**\\n     * @dev Returns the staker of the `tokenId` token.\\n     */\\n    function stakerOf(uint256 tokenId) external view returns (address);\\n\\n    /**\\n     * @dev Returns a token ID owned by `staker` at a given `index` of its token list.\\n     * Use along with {totalStaked} to enumerate all of ``staker``'s tokens.\\n     */\\n\\n    function tokenOfStakerByIndex(address staker, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total staked amount of tokens for staker.\\n     */\\n    function totalStaked(address staker) external view returns (uint256);\\n\\n    function underlyingAsset() external view returns (address);\\n\\n    function setBnftRegistry(address bnftRegistry_) external;\\n\\n    function setDelegateCash(address delegate, uint256[] calldata tokenIds, bool value) external;\\n\\n    function hasDelegateCash(address delegate, uint256[] calldata tokenIds) external view returns (bool[] memory);\\n\\n    function getDelegateCashForToken(uint256[] calldata tokenIds_) external view returns (address[][] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\nimport {IApeCoinStaking} from \\\"./IApeCoinStaking.sol\\\";\\nimport {IRewardsStrategy} from \\\"./IRewardsStrategy.sol\\\";\\nimport {IWithdrawStrategy} from \\\"./IWithdrawStrategy.sol\\\";\\nimport {IStakedNft} from \\\"./IStakedNft.sol\\\";\\n\\ninterface IStakeManager {\\n    event FeeRatioChanged(uint256 newRatio);\\n    event FeeRecipientChanged(address newRecipient);\\n    event BotAdminChanged(address newAdmin);\\n    event RewardsStrategyChanged(address nft, address newStrategy);\\n    event WithdrawStrategyChanged(address newStrategy);\\n    event Compounded(bool isClaimCoinPool, uint256 claimedNfts);\\n\\n    function stBayc() external view returns (IStakedNft);\\n\\n    function stMayc() external view returns (IStakedNft);\\n\\n    function stBakc() external view returns (IStakedNft);\\n\\n    function totalStakedApeCoin() external view returns (uint256);\\n\\n    function totalPendingRewards() external view returns (uint256);\\n\\n    function totalRefund() external view returns (uint256 principal, uint256 reward);\\n\\n    function refundOf(address nft_) external view returns (uint256 principal, uint256 reward);\\n\\n    function stakedApeCoin(uint256 poolId_) external view returns (uint256);\\n\\n    function pendingRewards(uint256 poolId_) external view returns (uint256);\\n\\n    function pendingFeeAmount() external view returns (uint256);\\n\\n    function fee() external view returns (uint256);\\n\\n    function feeRecipient() external view returns (address);\\n\\n    function updateFee(uint256 fee_) external;\\n\\n    function updateFeeRecipient(address recipient_) external;\\n\\n    // bot\\n    function updateBotAdmin(address bot_) external;\\n\\n    // strategy\\n    function updateRewardsStrategy(address nft_, IRewardsStrategy rewardsStrategy_) external;\\n\\n    function rewardsStrategies(address nft_) external view returns (IRewardsStrategy);\\n\\n    function getNftRewardsShare(address nft_) external view returns (uint256 nftShare);\\n\\n    function updateWithdrawStrategy(IWithdrawStrategy withdrawStrategy_) external;\\n\\n    function withdrawApeCoin(uint256 required) external returns (uint256);\\n\\n    function mintStNft(IStakedNft stNft_, address to_, uint256[] calldata tokenIds_) external;\\n\\n    // staking\\n    function calculateFee(uint256 rewardsAmount_) external view returns (uint256 feeAmount);\\n\\n    function stakeApeCoin(uint256 amount_) external;\\n\\n    function unstakeApeCoin(uint256 amount_) external;\\n\\n    function claimApeCoin() external;\\n\\n    function stakeBayc(uint256[] calldata tokenIds_) external;\\n\\n    function unstakeBayc(uint256[] calldata tokenIds_) external;\\n\\n    function claimBayc(uint256[] calldata tokenIds_) external;\\n\\n    function stakeMayc(uint256[] calldata tokenIds_) external;\\n\\n    function unstakeMayc(uint256[] calldata tokenIds_) external;\\n\\n    function claimMayc(uint256[] calldata tokenIds_) external;\\n\\n    function stakeBakc(\\n        IApeCoinStaking.PairNft[] calldata baycPairs_,\\n        IApeCoinStaking.PairNft[] calldata maycPairs_\\n    ) external;\\n\\n    function unstakeBakc(\\n        IApeCoinStaking.PairNft[] calldata baycPairs_,\\n        IApeCoinStaking.PairNft[] calldata maycPairs_\\n    ) external;\\n\\n    function claimBakc(\\n        IApeCoinStaking.PairNft[] calldata baycPairs_,\\n        IApeCoinStaking.PairNft[] calldata maycPairs_\\n    ) external;\\n\\n    function withdrawRefund(address nft_) external;\\n\\n    function withdrawTotalRefund() external;\\n\\n    struct NftArgs {\\n        uint256[] bayc;\\n        uint256[] mayc;\\n        IApeCoinStaking.PairNft[] baycPairs;\\n        IApeCoinStaking.PairNft[] maycPairs;\\n    }\\n\\n    struct CompoundArgs {\\n        bool claimCoinPool;\\n        NftArgs claim;\\n        NftArgs unstake;\\n        NftArgs stake;\\n        uint256 coinStakeThreshold;\\n    }\\n\\n    function compound(CompoundArgs calldata args_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWithdrawStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\ninterface IWithdrawStrategy {\\n    function withdrawApeCoin(uint256 required) external returns (uint256 withdrawn);\\n}\\n\"\r\n    },\r\n    \"contracts/misc/BendApeCoinStakedVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport {IERC721Enumerable} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\nimport {IBNFTRegistry} from \\\"../interfaces/IBNFTRegistry.sol\\\";\\n\\nimport {ICoinPool} from \\\"../interfaces/ICoinPool.sol\\\";\\nimport {INftPool, IStakedNft} from \\\"../interfaces/INftPool.sol\\\";\\nimport {IStakeManager} from \\\"../interfaces/IStakeManager.sol\\\";\\n\\n/**\\n * @title BendDAO Staked ApeCoin's Voting Contract\\n * @notice Provides a comprehensive vote count across all pools in the ApeCoinStaking contract\\n */\\ncontract BendApeCoinStakedVoting {\\n    ICoinPool public immutable coinPool;\\n    INftPool public immutable nftPool;\\n    IStakeManager public immutable staker;\\n    IBNFTRegistry public immutable bnftRegistry;\\n\\n    constructor(ICoinPool coinPool_, INftPool nftPool_, IStakeManager staker_, IBNFTRegistry bnftRegistry_) {\\n        coinPool = coinPool_;\\n        nftPool = nftPool_;\\n        staker = staker_;\\n        bnftRegistry = bnftRegistry_;\\n    }\\n\\n    /**\\n     * @notice Returns a vote count across all pools in the ApeCoinStaking contract for a given address\\n     * @param userAddress The address to return votes for\\n     */\\n    function getVotes(address userAddress) public view returns (uint256 votes) {\\n        votes += getVotesInCoinPool(userAddress);\\n        votes += getVotesInAllNftPool(userAddress);\\n    }\\n\\n    function getVotesInCoinPool(address userAddress) public view returns (uint256 votes) {\\n        votes = coinPool.assetBalanceOf(userAddress);\\n    }\\n\\n    function getVotesInAllNftPool(address userAddress) public view returns (uint256 votes) {\\n        votes += getVotesInOneNftPool(staker.stBayc(), userAddress);\\n        votes += getVotesInOneNftPool(staker.stMayc(), userAddress);\\n        votes += getVotesInOneNftPool(staker.stBakc(), userAddress);\\n    }\\n\\n    function getVotesInOneNftPool(IStakedNft stnft_, address userAddress) public view returns (uint256 votes) {\\n        // Check user balance\\n        uint256 stnftBalance = stnft_.balanceOf(userAddress);\\n        uint256 bnftBalance;\\n        (address bnftProxy, ) = bnftRegistry.getBNFTAddresses(address(stnft_));\\n        if (bnftProxy != address(0)) {\\n            bnftBalance += IERC721Enumerable(bnftProxy).balanceOf(userAddress);\\n        }\\n        if (bnftBalance == 0 && stnftBalance == 0) {\\n            return 0;\\n        }\\n\\n        // Get all tokenIds\\n        uint256[] memory allTokenIds = new uint256[](stnftBalance + bnftBalance);\\n        uint256 allIdSize = 0;\\n\\n        for (uint256 i = 0; i < stnftBalance; i++) {\\n            uint256 tokenId = stnft_.tokenOfOwnerByIndex(userAddress, i);\\n            if (stnft_.stakerOf(tokenId) == address(staker)) {\\n                allTokenIds[allIdSize] = tokenId;\\n                allIdSize++;\\n            }\\n        }\\n\\n        if (bnftProxy != address(0)) {\\n            IERC721Enumerable bnft = IERC721Enumerable(bnftProxy);\\n            for (uint256 i = 0; i < bnftBalance; i++) {\\n                uint256 tokenId = bnft.tokenOfOwnerByIndex(userAddress, i);\\n                if (stnft_.stakerOf(tokenId) == address(staker)) {\\n                    allTokenIds[allIdSize] = tokenId;\\n                    allIdSize++;\\n                }\\n            }\\n        }\\n\\n        // Get votes from claimable rewards\\n        address[] memory claimNfts = new address[](1);\\n        claimNfts[0] = stnft_.underlyingAsset();\\n\\n        uint256[][] memory claimTokenIds = new uint256[][](1);\\n        claimTokenIds[0] = new uint256[](allIdSize);\\n        for (uint256 i = 0; i < allIdSize; i++) {\\n            claimTokenIds[0][i] = allTokenIds[i];\\n        }\\n\\n        votes = nftPool.claimable(claimNfts, claimTokenIds);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ICoinPool\",\"name\":\"coinPool_\",\"type\":\"address\"},{\"internalType\":\"contract INftPool\",\"name\":\"nftPool_\",\"type\":\"address\"},{\"internalType\":\"contract IStakeManager\",\"name\":\"staker_\",\"type\":\"address\"},{\"internalType\":\"contract IBNFTRegistry\",\"name\":\"bnftRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"bnftRegistry\",\"outputs\":[{\"internalType\":\"contract IBNFTRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinPool\",\"outputs\":[{\"internalType\":\"contract ICoinPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getVotesInAllNftPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getVotesInCoinPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStakedNft\",\"name\":\"stnft_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getVotesInOneNftPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftPool\",\"outputs\":[{\"internalType\":\"contract INftPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staker\",\"outputs\":[{\"internalType\":\"contract IStakeManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BendApeCoinStakedVoting", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000086862445f58f50382c421a7bcecbcd971cc253670000000000000000000000009da9571389ba2316ad98f695210ad5fb0363cded0000000000000000000000009d1833becb105405a8305f775f0af3157d12b33c00000000000000000000000079d922dd382e42a156bc0a354861cdbc4f09110d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}