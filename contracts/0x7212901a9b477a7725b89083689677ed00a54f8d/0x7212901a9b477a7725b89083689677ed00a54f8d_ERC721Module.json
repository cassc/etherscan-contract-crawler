{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/ERC721Module.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"../interfaces/core/IModule.sol\\\";\\nimport \\\"../core/Lockers.sol\\\" as Lockers;\\nimport \\\"../helpers/Utils.sol\\\";\\n\\n/// @title Cyan Wallet ERC721 Module - A Cyan wallet's ERC721 token handling module.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\ncontract ERC721Module is IModule {\\n    bytes4 private constant ERC721_APPROVE = IERC721.approve.selector;\\n    bytes4 private constant ERC721_SET_APPROVAL_FOR_ALL = IERC721.setApprovalForAll.selector;\\n    bytes4 private constant ERC721_TRANSFER_FROM = IERC721.transferFrom.selector;\\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM = bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256)\\\"));\\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM_BYTES =\\n        bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256,bytes)\\\"));\\n\\n    event SetLockedERC721Token(address collection, uint256 tokenId, bool isLocked);\\n\\n    /// @inheritdoc IModule\\n    function handleTransaction(\\n        address collection,\\n        uint256 value,\\n        bytes calldata data\\n    ) public payable virtual override returns (bytes memory) {\\n        bytes4 funcHash = Utils.parseFunctionSelector(data);\\n        if (\\n            funcHash == ERC721_TRANSFER_FROM ||\\n            funcHash == ERC721_SAFE_TRANSFER_FROM ||\\n            funcHash == ERC721_SAFE_TRANSFER_FROM_BYTES\\n        ) {\\n            uint256 tokenId = Utils.getUint256At(data, 0x44);\\n            require(!getIsLocked(collection, tokenId), \\\"Cannot perform this action on locked token.\\\");\\n        }\\n        if (funcHash == ERC721_APPROVE) {\\n            uint256 tokenId = Utils.getUint256At(data, 0x24);\\n            require(!getIsLocked(collection, tokenId), \\\"Cannot perform this action on locked token.\\\");\\n        }\\n        require(funcHash != ERC721_SET_APPROVAL_FOR_ALL, \\\"Cannot perform this action.\\\");\\n\\n        return Utils._execute(collection, value, data);\\n    }\\n\\n    function getIsLocked(address collection, uint256 tokenId) internal view virtual returns (bool) {\\n        return Lockers.isLockedByCyanPlanERC721(collection, tokenId);\\n    }\\n\\n    /// @notice Allows operators to lock/unlock the token.\\n    /// @param collection Collection address.\\n    /// @param tokenId Token id.\\n    /// @param isLocked Boolean represents lock/unlock.\\n    function setLockedERC721Token(\\n        address collection,\\n        uint256 tokenId,\\n        bool isLocked\\n    ) public {\\n        Lockers.CyanPlanLockerERC721 storage locker = Lockers.getCyanPlanLockerERC721();\\n        require(locker.tokens[collection][tokenId] != isLocked, \\\"Token already in given state.\\\");\\n\\n        locker.tokens[collection][tokenId] = isLocked;\\n        if (isLocked) {\\n            ++locker.count[collection];\\n        } else {\\n            --locker.count[collection];\\n        }\\n        emit SetLockedERC721Token(collection, tokenId, isLocked);\\n    }\\n\\n    /// @notice Allows operators to transfer out non locked ERC721 tokens.\\n    ///     Note: Can only transfer if token is not locked.\\n    /// @param collection Collection address.\\n    /// @param tokenId Token ID.\\n    /// @param to Receiver address.\\n    function transferNonLockedERC721(\\n        address collection,\\n        uint256 tokenId,\\n        address to\\n    ) external returns (bytes memory) {\\n        require(!Lockers.isLockedERC721(collection, tokenId), \\\"Cannot perform this action on locked token.\\\");\\n\\n        bytes memory data = abi.encodeWithSelector(ERC721_SAFE_TRANSFER_FROM, address(this), to, tokenId);\\n        return Utils._execute(collection, 0, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nlibrary Utils {\\n    /// @notice Executes a transaction to the given address.\\n    /// @param to Target address.\\n    /// @param value Native token value to be sent to the address.\\n    /// @param data Data to be sent to the address.\\n    /// @return result Result of the transaciton.\\n    function _execute(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal returns (bytes memory result) {\\n        assembly {\\n            let success := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\\n\\n            mstore(result, returndatasize())\\n            returndatacopy(add(result, 0x20), 0, returndatasize())\\n\\n            if eq(success, 0) {\\n                revert(add(result, 0x20), returndatasize())\\n            }\\n        }\\n    }\\n\\n    /// @notice Recover signer address from signature.\\n    /// @param signedHash Arbitrary length data signed on the behalf of the wallet.\\n    /// @param signature Signature byte array associated with signedHash.\\n    /// @return Recovered signer address.\\n    function recoverSigner(bytes32 signedHash, bytes memory signature) internal pure returns (address) {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n        require(v == 27 || v == 28, \\\"Bad v value in signature.\\\");\\n\\n        address recoveredAddress = ecrecover(signedHash, v, r, s);\\n        require(recoveredAddress != address(0), \\\"ecrecover returned 0.\\\");\\n        return recoveredAddress;\\n    }\\n\\n    /// @notice Helper method to parse the function selector from data.\\n    /// @param data Any data to be parsed, mostly calldata of transaction.\\n    /// @return result Parsed function sighash.\\n    function parseFunctionSelector(bytes memory data) internal pure returns (bytes4 result) {\\n        require(data.length >= 4, \\\"Invalid data.\\\");\\n        assembly {\\n            result := mload(add(data, 0x20))\\n        }\\n    }\\n\\n    /// @notice Parse uint256 from given data.\\n    /// @param data Any data to be parsed, mostly calldata of transaction.\\n    /// @param position Position in the data.\\n    /// @return result Uint256 parsed from given data.\\n    function getUint256At(bytes memory data, uint8 position) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mload(add(data, add(position, 0x20)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/core/IModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IModule {\\n    /// @notice Executes given transaction data to given address.\\n    /// @param to Target contract address.\\n    /// @param value Value of the given transaction.\\n    /// @param data Calldata of the transaction.\\n    /// @return Result of the execution.\\n    function handleTransaction(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/core/Lockers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n// keccak256(\\\"wallet.YugaModule.lockedApe\\\")\\nbytes32 constant APE_PLAN_LOCKER_SLOT = 0x010881fa8a1edce184936a8e4e08060bba49cb5145c9b396e6e80c0c6b0e1269;\\n\\n// keccak256(\\\"wallet.ERC721Module.lockedERC721\\\")\\nbytes32 constant CYAN_PLAN_LOCKER_SLOT_ERC721 = 0x25888debd3e1e584ccaebe1162c7763ec457a94078c5d0d9a1d32a926ff9973c;\\n\\n// keccak256(\\\"wallet.ERC1155Module.lockedERC1155\\\")\\nbytes32 constant CYAN_PLAN_LOCKER_SLOT_ERC1155 = 0xdcc609ac7fc3b6a216ce1445788736c9dbe88a58b25a13af71623e6da931efa0;\\n\\n// keccak256(\\\"wallet.CryptoPunksModule.lockedCryptoPunks\\\")\\nbytes32 constant CRYPTO_PUNKS_PLAN_LOCKER_SLOT = 0x67ae504a494a1bd5120fdcd8b3565de046d61ac7bb95311090f1976ec179a99a;\\n\\nstruct ApePlanLocker {\\n    /// @notice Map of the locked tokens.\\n    ///     Note: Collection Address => Token ID => Lock state\\n    mapping(address => mapping(uint256 => uint8)) tokens;\\n}\\n\\nstruct CyanPlanLockerERC721 {\\n    /// @notice Locked tokens count of the collection.\\n    ///     Note: Collection Address => Number of locked tokens\\n    mapping(address => uint256) count;\\n    /// @notice Map of the locked tokens.\\n    ///     Note: Collection Address => Token ID => isLocked\\n    mapping(address => mapping(uint256 => bool)) tokens;\\n}\\n\\nstruct CyanPlanLockerCryptoPunks {\\n    /// @notice Locked tokens count of the CryptoPunks.\\n    ///     Note: Number of locked tokens\\n    uint256 count;\\n    /// @notice Map of the locked tokens.\\n    ///     Note: CryptoPunk index => isLocked\\n    mapping(uint256 => bool) tokens;\\n}\\n\\nstruct CyanPlanLockerERC1155 {\\n    /// @notice Map of the locked ERC1155 tokens.\\n    ///     Note: Collection Address => Token ID => amount\\n    mapping(address => mapping(uint256 => uint256)) tokens;\\n}\\n\\n/// @notice Checks whether the NFT is locked or not. This method checks both ERC721 lock and ApePlan lock.\\n/// @param collection Collection address.\\n/// @param tokenId Token ID.\\n/// @return isLocked Whether the token is locked or not.\\nfunction isLockedERC721(address collection, uint256 tokenId) view returns (bool) {\\n    return isLockedByCyanPlanERC721(collection, tokenId) || isLockedByApePlan(collection, tokenId);\\n}\\n\\n/// @notice Checks whether the ERC721 token is locked or not.\\n/// @param collection Collection address.\\n/// @param tokenId Token ID.\\n/// @return isLocked Whether the token is locked or not.\\nfunction isLockedByCyanPlanERC721(address collection, uint256 tokenId) view returns (bool) {\\n    return getCyanPlanLockerERC721().tokens[collection][tokenId];\\n}\\n\\n/// @notice Checks whether the CryptoPunks token is locked or not.\\n/// @param tokenId Token ID.\\n/// @return isLocked Whether the token is locked or not.\\nfunction isLockedByCryptoPunkPlan(uint256 tokenId) view returns (bool) {\\n    return getCyanPlanLockerCryptoPunks().tokens[tokenId];\\n}\\n\\n/// @notice Checks whether the BAYC, MAYC or BAKC token is locked or not.\\n/// @param collection Ape collection address.\\n/// @param tokenId Token ID.\\n/// @return isLocked Whether the token is ape locked or not.\\nfunction isLockedByApePlan(address collection, uint256 tokenId) view returns (bool) {\\n    return getApePlanLocker().tokens[collection][tokenId] != 0;\\n}\\n\\n/// @notice Returns amount of locked ERC1155Token items.\\n/// @param collection Collection address.\\n/// @param tokenId Token ID.\\n/// @return isLocked Whether the token is locked or not.\\nfunction getLockedERC1155Amount(address collection, uint256 tokenId) view returns (uint256) {\\n    return getCyanPlanLockerERC1155().tokens[collection][tokenId];\\n}\\n\\n/// @notice Returns ape lock state.\\n/// @param collection Ape collection address.\\n/// @param tokenId Token ID.\\n/// @return Ape locks state.\\nfunction getApeLockState(address collection, uint256 tokenId) view returns (uint8) {\\n    return getApePlanLocker().tokens[collection][tokenId];\\n}\\n\\n/// @dev Returns the map of the locked ERC721 tokens.\\n/// @return result CyanPlanLockerERC721 struct of the locked tokens.\\n///     Note: Collection Address => Token ID => isLocked\\nfunction getCyanPlanLockerERC721() pure returns (CyanPlanLockerERC721 storage result) {\\n    assembly {\\n        result.slot := CYAN_PLAN_LOCKER_SLOT_ERC721\\n    }\\n}\\n\\n/// @dev Returns the map of the locked ERC1155 tokens.\\n/// @return result CyanPlanERC1155Locker struct of the locked tokens.\\n///     Note: Collection Address => Token ID => locked amount\\nfunction getCyanPlanLockerERC1155() pure returns (CyanPlanLockerERC1155 storage result) {\\n    assembly {\\n        result.slot := CYAN_PLAN_LOCKER_SLOT_ERC1155\\n    }\\n}\\n\\n/// @dev Returns the map of the locked Crypto Punks.\\n/// @return result CryptoPunksPlanLocker struct of the locked tokens.\\n///     Note: CryptoPunk index => isLocked\\nfunction getCyanPlanLockerCryptoPunks() pure returns (CyanPlanLockerCryptoPunks storage result) {\\n    assembly {\\n        result.slot := CRYPTO_PUNKS_PLAN_LOCKER_SLOT\\n    }\\n}\\n\\n/// @dev Returns the map of the locked tokens.\\n/// @return result ApePlanLocker struct of the locked tokens.\\n///     Note: Collection Address => Token ID => Lock state\\nfunction getApePlanLocker() pure returns (ApePlanLocker storage result) {\\n    assembly {\\n        result.slot := APE_PLAN_LOCKER_SLOT\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isLocked\",\"type\":\"bool\"}],\"name\":\"SetLockedERC721Token\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"handleTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLocked\",\"type\":\"bool\"}],\"name\":\"setLockedERC721Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferNonLockedERC721\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC721Module", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}