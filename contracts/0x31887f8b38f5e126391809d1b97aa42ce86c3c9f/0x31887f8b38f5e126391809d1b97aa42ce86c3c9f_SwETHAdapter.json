{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/adapters/swell/SwETHAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.13;\\n\\nimport { IERC20 } from \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport { MutexLock } from \\\"../../base/MutexLock.sol\\\";\\nimport { Unauthorized, UnsupportedOperation } from \\\"../../base/ErrorMessages.sol\\\";\\n\\nimport { SafeERC20 } from \\\"../../libraries/SafeERC20.sol\\\";\\n\\nimport { ITokenAdapter } from \\\"../../interfaces/ITokenAdapter.sol\\\";\\nimport { IWETH9 } from \\\"../../interfaces/external/IWETH9.sol\\\";\\nimport { IswETH } from \\\"./../../interfaces/external/swell/IswETH.sol\\\";\\nimport { IPool as IMaverickPool } from \\\"../../interfaces/external/maverick/IPool.sol\\\";\\nimport { ISwapRouter as IMaverickSwapRouter } from \\\"../../interfaces/external/maverick/ISwapRouter.sol\\\";\\n\\nstruct InitializationParams {\\n    address zeroliquid;\\n    address token;\\n    address underlyingToken;\\n    address maverickPool;\\n    address maverickRouter;\\n}\\n\\ncontract SwETHAdapter is ITokenAdapter, MutexLock {\\n    string public override version = \\\"1.0.0\\\";\\n\\n    address public immutable zeroliquid;\\n    address public immutable override token;\\n    address public immutable override underlyingToken;\\n    address public immutable maverickPool;\\n    address public immutable maverickRouter;\\n\\n    constructor(InitializationParams memory params) {\\n        zeroliquid = params.zeroliquid;\\n        token = params.token;\\n        underlyingToken = params.underlyingToken;\\n        maverickPool = params.maverickPool;\\n        maverickRouter = params.maverickRouter;\\n    }\\n\\n    /// @dev Checks that the message sender is the zeroliquid contract that the adapter is bound to.\\n    modifier onlyZeroLiquid() {\\n        if (msg.sender != zeroliquid) {\\n            revert Unauthorized(\\\"Not ZeroLiquid\\\");\\n        }\\n        _;\\n    }\\n\\n    receive() external payable {\\n        if (msg.sender != underlyingToken) {\\n            revert Unauthorized(\\\"Payments only permitted from WETH\\\");\\n        }\\n    }\\n\\n    /// @inheritdoc ITokenAdapter\\n    function price() external view returns (uint256) {\\n        return IswETH(token).swETHToETHRate();\\n    }\\n\\n    /// @inheritdoc ITokenAdapter\\n    function wrap(uint256 amount, address recipient) external onlyZeroLiquid returns (uint256) {\\n        // Transfer the tokens from the message sender.\\n        SafeERC20.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\\n\\n        // Unwrap the WETH into ETH.\\n        IWETH9(underlyingToken).withdraw(amount);\\n\\n        uint256 startingSwETHBalance = IERC20(token).balanceOf(address(this));\\n        IswETH(token).deposit{ value: amount }();\\n        uint256 mintedSwETH = IERC20(token).balanceOf(address(this)) - startingSwETHBalance;\\n\\n        // Transfer the minted wstETH to the recipient.\\n        SafeERC20.safeTransfer(token, recipient, mintedSwETH);\\n\\n        return mintedSwETH;\\n    }\\n\\n    // @inheritdoc ITokenAdapter\\n    function unwrap(uint256 amount, address recipient) external lock onlyZeroLiquid returns (uint256) {\\n        // Transfer the tokens from the message sender.\\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), amount);\\n\\n        SafeERC20.safeApprove(token, maverickRouter, amount);\\n\\n        IMaverickSwapRouter.ExactInputSingleParams memory params = IMaverickSwapRouter.ExactInputSingleParams({\\n            tokenIn: token,\\n            tokenOut: underlyingToken,\\n            pool: IMaverickPool(maverickPool),\\n            recipient: address(this),\\n            deadline: block.timestamp,\\n            amountIn: amount,\\n            amountOutMinimum: 0,\\n            sqrtPriceLimitD18: 0\\n        });\\n\\n        uint256 receivedWETH = IMaverickSwapRouter(maverickRouter).exactInputSingle(params);\\n\\n        // Transfer the tokens to the recipient.\\n        SafeERC20.safeTransfer(underlyingToken, recipient, receivedWETH);\\n\\n        return receivedWETH;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/base/MutexLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.13;\\n\\nimport { IllegalState } from \\\"./ErrorMessages.sol\\\";\\n\\n/// @title  Mutex\\n/// @author ZeroLiquid\\n///\\n/// @notice Provides a mutual exclusion lock for implementing contracts.\\nabstract contract MutexLock {\\n    enum State {\\n        RESERVED,\\n        UNLOCKED,\\n        LOCKED\\n    }\\n\\n    /// @notice The lock state.\\n    State private _lockState = State.UNLOCKED;\\n\\n    /// @dev A modifier which acquires the mutex.\\n    modifier lock() {\\n        _claimLock();\\n\\n        _;\\n\\n        _freeLock();\\n    }\\n\\n    /// @dev Gets if the mutex is locked.\\n    ///\\n    /// @return if the mutex is locked.\\n    function _isLocked() internal view returns (bool) {\\n        return _lockState == State.LOCKED;\\n    }\\n\\n    /// @dev Claims the lock. If the lock is already claimed, then this will revert.\\n    function _claimLock() internal {\\n        // Check that the lock has not been claimed yet.\\n        if (_lockState != State.UNLOCKED) {\\n            revert IllegalState(\\\"Lock already claimed\\\");\\n        }\\n\\n        // Claim the lock.\\n        _lockState = State.LOCKED;\\n    }\\n\\n    /// @dev Frees the lock.\\n    function _freeLock() internal {\\n        _lockState = State.UNLOCKED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/base/ErrorMessages.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.4;\\n\\n/// @notice An error used to indicate that an argument passed to a function is illegal or\\n///         inappropriate.\\n///\\n/// @param message The error message.\\nerror IllegalArgument(string message);\\n\\n/// @notice An error used to indicate that a function has encountered an unrecoverable state.\\n///\\n/// @param message The error message.\\nerror IllegalState(string message);\\n\\n/// @notice An error used to indicate that an operation is unsupported.\\n///\\n/// @param message The error message.\\nerror UnsupportedOperation(string message);\\n\\n/// @notice An error used to indicate that a message sender tried to execute a privileged function.\\n///\\n/// @param message The error message.\\nerror Unauthorized(string message);\\n\"\r\n    },\r\n    \"src/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.4;\\n\\nimport { IERC20 } from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport { IllegalState } from \\\"../base/ErrorMessages.sol\\\";\\n\\nimport { IERC20Metadata } from \\\"../interfaces/IERC20Metadata.sol\\\";\\n\\n/// @title  SafeERC20\\n/// @author ZeroLiquid\\nlibrary SafeERC20 {\\n    /// @notice An error used to indicate that a call to an ERC20 contract failed.\\n    ///\\n    /// @param target  The target address.\\n    /// @param success If the call to the token was a success.\\n    /// @param data    The resulting data from the call. This is error data when the call was not a\\n    ///                success. Otherwise, this is malformed data when the call was a success.\\n    error ERC20CallFailed(address target, bool success, bytes data);\\n\\n    /// @dev A safe function to get the decimals of an ERC20 token.\\n    ///\\n    /// @dev Reverts with a {CallFailed} error if execution of the query fails or returns an\\n    ///      unexpected value.\\n    ///\\n    /// @param token The target token.\\n    ///\\n    /// @return The amount of decimals of the token.\\n    function expectDecimals(address token) internal view returns (uint8) {\\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20Metadata.decimals.selector));\\n\\n        if (!success || data.length < 32) {\\n            revert ERC20CallFailed(token, success, data);\\n        }\\n\\n        return abi.decode(data, (uint8));\\n    }\\n\\n    /// @dev Transfers tokens to another address.\\n    ///\\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer failed or returns an\\n    ///      unexpected value.\\n    ///\\n    /// @param token     The token to transfer.\\n    /// @param recipient The address of the recipient.\\n    /// @param amount    The amount of tokens to transfer.\\n    function safeTransfer(address token, address recipient, uint256 amount) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transfer.selector, recipient, amount));\\n\\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\\n            revert ERC20CallFailed(token, success, data);\\n        }\\n    }\\n\\n    /// @dev Approves tokens for the smart contract.\\n    ///\\n    /// @dev Reverts with a {CallFailed} error if execution of the approval fails or returns an\\n    ///      unexpected value.\\n    ///\\n    /// @param token   The token to approve.\\n    /// @param spender The contract to spend the tokens.\\n    /// @param value   The amount of tokens to approve.\\n    function safeApprove(address token, address spender, uint256 value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, spender, value));\\n\\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\\n            revert ERC20CallFailed(token, success, data);\\n        }\\n    }\\n\\n    /// @dev Transfer tokens from one address to another address.\\n    ///\\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer fails or returns an\\n    ///      unexpected value.\\n    ///\\n    /// @param token     The token to transfer.\\n    /// @param owner     The address of the owner.\\n    /// @param recipient The address of the recipient.\\n    /// @param amount    The amount of tokens to transfer.\\n    function safeTransferFrom(address token, address owner, address recipient, uint256 amount) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, owner, recipient, amount));\\n\\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\\n            revert ERC20CallFailed(token, success, data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITokenAdapter.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\n/// @title  ITokenAdapter\\n/// @author ZeroLiquid\\ninterface ITokenAdapter {\\n    /// @notice Gets the current version.\\n    ///\\n    /// @return The version.\\n    function version() external view returns (string memory);\\n\\n    /// @notice Gets the address of the yield token that this adapter supports.\\n    ///\\n    /// @return The address of the yield token.\\n    function token() external view returns (address);\\n\\n    /// @notice Gets the address of the underlying token that the yield token wraps.\\n    ///\\n    /// @return The address of the underlying token.\\n    function underlyingToken() external view returns (address);\\n\\n    /// @notice Gets the number of underlying tokens that a single whole yield token is redeemable\\n    ///         for.\\n    ///\\n    /// @return The price.\\n    function price() external view returns (uint256);\\n\\n    /// @notice Wraps `amount` underlying tokens into the yield token.\\n    ///\\n    /// @param amount    The amount of the underlying token to wrap.\\n    /// @param recipient The address which will receive the yield tokens.\\n    ///\\n    /// @return amountYieldTokens The amount of yield tokens minted to `recipient`.\\n    function wrap(uint256 amount, address recipient) external returns (uint256 amountYieldTokens);\\n\\n    /// @notice Unwraps `amount` yield tokens into the underlying token.\\n    ///\\n    /// @param amount    The amount of yield-tokens to redeem.\\n    /// @param recipient The recipient of the resulting underlying-tokens.\\n    ///\\n    /// @return amountUnderlyingTokens The amount of underlying tokens unwrapped to `recipient`.\\n    function unwrap(uint256 amount, address recipient) external returns (uint256 amountUnderlyingTokens);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/IWETH9.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport \\\"../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../IERC20Metadata.sol\\\";\\n\\n/// @title IWETH9\\ninterface IWETH9 is IERC20, IERC20Metadata {\\n    /// @notice Deposits `msg.value` ethereum into the contract and mints `msg.value` tokens.\\n    function deposit() external payable;\\n\\n    /// @notice Burns `amount` tokens to retrieve `amount` ethereum from the contract.\\n    ///\\n    /// @dev This version of WETH utilizes the `transfer` function which hard codes the amount of gas\\n    ///      that is allowed to be utilized to be exactly 2300 when receiving ethereum.\\n    ///\\n    /// @param amount The amount of tokens to burn.\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/swell/IswETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\ninterface IswETH {\\n    function swETHToETHRate() external view returns (uint256);\\n    function deposit() external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/maverick/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IFactory.sol\\\";\\n\\ninterface IPool {\\n    event Swap(\\n        address sender,\\n        address recipient,\\n        bool tokenAIn,\\n        bool exactOutput,\\n        uint256 amountIn,\\n        uint256 amountOut,\\n        int32 activeTick\\n    );\\n    event AddLiquidity(address indexed sender, uint256 indexed tokenId, BinDelta[] binDeltas);\\n    event MigrateBinsUpStack(address indexed sender, uint128 binId, uint32 maxRecursion);\\n    event TransferLiquidity(uint256 fromTokenId, uint256 toTokenId, RemoveLiquidityParams[] params);\\n    event RemoveLiquidity(\\n        address indexed sender, address indexed recipient, uint256 indexed tokenId, BinDelta[] binDeltas\\n    );\\n    event BinMerged(uint128 indexed binId, uint128 reserveA, uint128 reserveB, uint128 mergeId);\\n    event BinMoved(uint128 indexed binId, int128 previousTick, int128 newTick);\\n    event ProtocolFeeCollected(uint256 protocolFee, bool isTokenA);\\n    event SetProtocolFeeRatio(uint256 protocolFee);\\n    /// @notice return parameters for Add/Remove liquidity\\n    /// @param binId of the bin that changed\\n    /// @param kind one of the 4 Kinds (0=static, 1=right, 2=left, 3=both)\\n    /// @param isActive bool to indicate whether the bin is still active\\n    /// @param lowerTick is the lower price tick of the bin in its current state\\n    /// @param deltaA amount of A token that has been added or removed\\n    /// @param deltaB amount of B token that has been added or removed\\n    /// @param deltaLpToken amount of LP balance that has increase (add) or decreased (remove)\\n\\n    struct BinDelta {\\n        uint128 deltaA;\\n        uint128 deltaB;\\n        uint256 deltaLpBalance;\\n        uint128 binId;\\n        uint8 kind;\\n        int32 lowerTick;\\n        bool isActive;\\n    }\\n    /// @notice time weighted average state\\n    /// @param twa the twa at the last update instant\\n    /// @param value the new value that was passed in at the last update\\n    /// @param lastTimestamp timestamp of the last update in seconds\\n    /// @param lookback time in seconds\\n\\n    struct TwaState {\\n        int96 twa;\\n        int96 value;\\n        uint64 lastTimestamp;\\n    }\\n    /// @notice bin state parameters\\n    /// @param kind one of the 4 Kinds (0=static, 1=right, 2=left, 3=both)\\n    /// @param lowerTick is the lower price tick of the bin in its current state\\n    /// @param mergeId binId of the bin that this bin has merged in to\\n    /// @param reserveA amount of A token in bin\\n    /// @param reserveB amount of B token in bin\\n    /// @param totalSupply total amount of LP tokens in this bin\\n    /// @param mergeBinBalance LP token balance that this bin posseses of the merge bin\\n\\n    struct BinState {\\n        uint128 reserveA;\\n        uint128 reserveB;\\n        uint128 mergeBinBalance;\\n        uint128 mergeId;\\n        uint128 totalSupply;\\n        uint8 kind;\\n        int32 lowerTick;\\n    }\\n    /// @notice Parameters for each bin that will get new liquidity\\n    /// @param kind one of the 4 Kinds (0=static, 1=right, 2=left, 3=both)\\n    /// @param pos bin position\\n    /// @param isDelta bool that indicates whether the bin position is relative\\n    //to the current bin or an absolute position\\n    /// @param deltaA amount of A token to add\\n    /// @param deltaB amount of B token to add\\n\\n    struct AddLiquidityParams {\\n        uint8 kind;\\n        int32 pos;\\n        bool isDelta;\\n        uint128 deltaA;\\n        uint128 deltaB;\\n    }\\n    /// @notice Parameters for each bin that will have liquidity removed\\n    /// @param binId index of the bin losing liquidity\\n    /// @param amount LP balance amount to remove\\n\\n    struct RemoveLiquidityParams {\\n        uint128 binId;\\n        uint128 amount;\\n    }\\n    /// @notice State of the pool\\n    /// @param activeTick  current bin position that contains the active bins\\n    /// @param status pool status.  e.g. locked or unlocked; status values\\n    //defined in Pool.sol\\n    /// @param binCounter index of the last bin created\\n    /// @param protocolFeeRatio ratio of the swap fee that is kept for the\\n    //protocol\\n\\n    struct State {\\n        int32 activeTick;\\n        uint8 status;\\n        uint128 binCounter;\\n        uint64 protocolFeeRatio;\\n    }\\n    /// @notice fee for pool in 18 decimal format\\n\\n    function fee() external view returns (uint256);\\n    /// @notice tickSpacing of pool where 1.0001^tickSpacing is the bin width\\n    function tickSpacing() external view returns (uint256);\\n    /// @notice address of token A\\n    function tokenA() external view returns (IERC20);\\n    /// @notice address of token B\\n    function tokenB() external view returns (IERC20);\\n    /// @notice address of Factory\\n    function factory() external view returns (IFactory);\\n    /// @notice bitmap of active bins\\n    function binMap(int32 tick) external view returns (uint256);\\n    /// @notice mapping of tick/kind to binId\\n    function binPositions(int32 tick, uint256 kind) external view returns (uint128);\\n    /// @notice internal accounting of the sum tokenA balance across bins\\n    function binBalanceA() external view returns (uint128);\\n    /// @notice internal accounting of the sum tokenB balance across bins\\n    function binBalanceB() external view returns (uint128);\\n    /// @notice Twa state values\\n    function getTwa() external view returns (TwaState memory);\\n    /// @notice log base binWidth of the time weighted average price\\n    function getCurrentTwa() external view returns (int256);\\n    /// @notice pool state\\n    function getState() external view returns (State memory);\\n    /// @notice Add liquidity to a pool.\\n    /// @param tokenId NFT token ID that will hold the position\\n    /// @param params array of AddLiquidityParams that specify the mode and\\n    //position of the liquidity\\n    /// @param data callback function that addLiquidity will call so that the\\n    //caller can transfer tokens\\n    function addLiquidity(\\n        uint256 tokenId,\\n        AddLiquidityParams[] calldata params,\\n        bytes calldata data\\n    )\\n        external\\n        returns (uint256 tokenAAmount, uint256 tokenBAmount, BinDelta[] memory binDeltas);\\n    /// @notice Transfer liquidity in an array of bins from one nft tokenId\\n    //to another\\n    /// @param fromTokenId NFT token ID that holds the position being transferred\\n    /// @param toTokenId NFT token ID that is receiving liquidity\\n    /// @param params array of binIds and amounts to transfer\\n    function transferLiquidity(\\n        uint256 fromTokenId,\\n        uint256 toTokenId,\\n        RemoveLiquidityParams[] calldata params\\n    )\\n        external;\\n    /// @notice Remove liquidity from a pool.\\n    /// @param recipient address that will receive the removed tokens\\n    /// @param tokenId NFT token ID that holds the position being removed\\n    /// @param params array of RemoveLiquidityParams that specify the bins,\\n    //and amounts\\n    function removeLiquidity(\\n        address recipient,\\n        uint256 tokenId,\\n        RemoveLiquidityParams[] calldata params\\n    )\\n        external\\n        returns (uint256 tokenAOut, uint256 tokenBOut, BinDelta[] memory binDeltas);\\n    /// @notice Migrate bins up the linked list of merged bins so that its\\n    //mergeId is the currrent active bin.\\n    /// @param binId is an array of the binIds to be migrated\\n    /// @param maxRecursion is the maximum recursion depth of the migration. set to\\n    //zero to recurse until the active bin is found.\\n    function migrateBinUpStack(uint128 binId, uint32 maxRecursion) external;\\n    /// @notice swap tokens\\n    /// @param recipient address that will receive the output tokens\\n    /// @param amount amount of token that is either the input if exactOutput\\n    //is false or the output if exactOutput is true\\n    /// @param tokenAIn bool indicating whether tokenA is the input\\n    /// @param exactOutput bool indicating whether the amount specified is the\\n    //exact output amount (true)\\n    /// @param sqrtPriceLimit limiting sqrt price of the swap.  A value of 0\\n    //indicates no limit.  Limit is only engaged for exactOutput=false.  If the\\n    //limit is reached only part of the input amount will be swapped and the\\n    //callback will only require that amount of the swap to be paid.\\n    /// @param data callback function that swap will call so that the\\n    //caller can transfer tokens\\n    function swap(\\n        address recipient,\\n        uint256 amount,\\n        bool tokenAIn,\\n        bool exactOutput,\\n        uint256 sqrtPriceLimit,\\n        bytes calldata data\\n    )\\n        external\\n        returns (uint256 amountIn, uint256 amountOut);\\n    /// @notice bin information for a given binId\\n    function getBin(uint128 binId) external view returns (BinState memory bin);\\n    /// @notice LP token balance for a given tokenId at a given binId\\n    function balanceOf(uint256 tokenId, uint128 binId) external view returns (uint256 lpToken);\\n    /// @notice tokenA scale value\\n    /// @dev msb is a flag to indicate whether tokenA has more or less than 18\\n    //decimals.  Scale is used in conjuction with Math.toScale/Math.fromScale\\n    //functions to convert from token amounts to D18 scale internal pool\\n    //accounting.\\n    function tokenAScale() external view returns (uint256);\\n    /// @notice tokenB scale value\\n    /// @dev msb is a flag to indicate whether tokenA has more or less than 18\\n    //decimals.  Scale is used in conjuction with Math.toScale/Math.fromScale\\n    //functions to convert from token amounts to D18 scale internal pool\\n    //accounting.\\n    function tokenBScale() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/maverick/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IPool.sol\\\";\\n\\ninterface ISwapRouter {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        IPool pool;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint256 sqrtPriceLimitD18;\\n    }\\n\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\n/// @title  IERC20Metadata\\n/// @author ZeroLiquid\\ninterface IERC20Metadata {\\n    /// @notice Gets the name of the token.\\n    ///\\n    /// @return The name.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Gets the symbol of the token.\\n    ///\\n    /// @return The symbol.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Gets the number of decimals that the token has.\\n    ///\\n    /// @return The number of decimals.\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/maverick/IFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IPool.sol\\\";\\nimport \\\"./IPosition.sol\\\";\\n\\ninterface IFactory {\\n    event PoolCreated(\\n        address poolAddress,\\n        uint256 fee,\\n        uint256 tickSpacing,\\n        int32 activeTick,\\n        int256 lookback,\\n        uint64 protocolFeeRatio,\\n        IERC20 tokenA,\\n        IERC20 tokenB\\n    );\\n    event SetFactoryProtocolFeeRatio(uint64 protocolFeeRatio);\\n    event SetFactoryOwner(address owner);\\n    /// @notice creates new pool\\n    /// @param _fee is a rate in prbmath 60x18 decimal format\\n    /// @param _tickSpacing  1.0001^tickSpacing is the bin width\\n    /// @param _activeTick initial activeTick of the pool\\n    /// @param _lookback TWAP lookback in whole seconds\\n    /// @param _tokenA ERC20 token\\n    /// @param _tokenB ERC20 token\\n\\n    function create(\\n        uint256 _fee,\\n        uint256 _tickSpacing,\\n        int256 _lookback,\\n        int32 _activeTick,\\n        IERC20 _tokenA,\\n        IERC20 _tokenB\\n    )\\n        external\\n        returns (IPool);\\n    function lookup(\\n        uint256 fee,\\n        uint256 tickSpacing,\\n        int256 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB\\n    )\\n        external\\n        view\\n        returns (IPool);\\n    function owner() external view returns (address);\\n    function position() external view returns (IPosition);\\n    /// @notice protocolFeeRatio ratio of the swap fee that is kept for the\\n    //protocol\\n    function protocolFeeRatio() external view returns (uint64);\\n    /// @notice lookup table for whether a pool is owned by the factory\\n    function isFactoryPool(IPool pool) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/maverick/IPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\nimport \\\"./IPositionMetadata.sol\\\";\\n\\ninterface IPosition is IERC721Enumerable {\\n    event SetMetadata(IPositionMetadata metadata);\\n    /// @notice mint new position NFT\\n\\n    function mint(address to) external returns (uint256 tokenId);\\n    /// @notice mint new position NFT\\n    function tokenOfOwnerByIndexExists(address owner, uint256 index) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/maverick/IPositionMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IPositionMetadata {\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"prb-test/=lib/prb-test/src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"zeroliquid\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maverickPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maverickRouter\",\"type\":\"address\"}],\"internalType\":\"struct InitializationParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC20CallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"maverickPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maverickRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"unwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"wrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroliquid\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SwETHAdapter", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000246e28c6b161764492e54cbf852e28a4da2d672000000000000000000000000f951e335afb289353dc249e82926178eac7ded78000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000ce176e1b11a8f88a4ba2535de80e81f88592bad000000000000000000000000bbf1ee38152e9d8e3470dc47947eaa65dca94913", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}