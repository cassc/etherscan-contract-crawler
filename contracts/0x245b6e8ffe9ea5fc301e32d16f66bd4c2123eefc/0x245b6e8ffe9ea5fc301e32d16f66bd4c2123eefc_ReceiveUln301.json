{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport { IMessageLibManager } from \\\"./IMessageLibManager.sol\\\";\\nimport { IMessagingComposer } from \\\"./IMessagingComposer.sol\\\";\\nimport { IMessagingChannel } from \\\"./IMessagingChannel.sol\\\";\\nimport { IMessagingContext } from \\\"./IMessagingContext.sol\\\";\\n\\nstruct MessagingParams {\\n    uint32 dstEid;\\n    bytes32 receiver;\\n    bytes message;\\n    bytes options;\\n    bool payInLzToken;\\n}\\n\\nstruct MessagingReceipt {\\n    bytes32 guid;\\n    uint64 nonce;\\n    MessagingFee fee;\\n}\\n\\nstruct MessagingFee {\\n    uint256 nativeFee;\\n    uint256 lzTokenFee;\\n}\\n\\nstruct Origin {\\n    uint32 srcEid;\\n    bytes32 sender;\\n    uint64 nonce;\\n}\\n\\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\\n\\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\\n\\n    event PacketDelivered(Origin origin, address receiver);\\n\\n    event LzReceiveAlert(\\n        address indexed receiver,\\n        address indexed executor,\\n        Origin origin,\\n        bytes32 guid,\\n        uint256 gas,\\n        uint256 value,\\n        bytes message,\\n        bytes extraData,\\n        bytes reason\\n    );\\n\\n    event LzTokenSet(address token);\\n\\n    event DelegateSet(address sender, address delegate);\\n\\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\\n\\n    function send(\\n        MessagingParams calldata _params,\\n        address _refundAddress\\n    ) external payable returns (MessagingReceipt memory);\\n\\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\\n\\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\\n\\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\\n\\n    function lzReceive(\\n        Origin calldata _origin,\\n        address _receiver,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable;\\n\\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\\n\\n    function setLzToken(address _lzToken) external;\\n\\n    function lzToken() external view returns (address);\\n\\n    function nativeToken() external view returns (address);\\n\\n    function setDelegate(address _delegate) external;\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport { SetConfigParam } from \\\"./IMessageLibManager.sol\\\";\\n\\nenum MessageLibType {\\n    Send,\\n    Receive,\\n    SendAndReceive\\n}\\n\\ninterface IMessageLib is IERC165 {\\n    function setConfig(address _oapp, SetConfigParam[] calldata _config) external;\\n\\n    function getConfig(uint32 _eid, address _oapp, uint32 _configType) external view returns (bytes memory config);\\n\\n    function isSupportedEid(uint32 _eid) external view returns (bool);\\n\\n    // message libs of same major version are compatible\\n    function version() external view returns (uint64 major, uint8 minor, uint8 endpointVersion);\\n\\n    function messageLibType() external view returns (MessageLibType);\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nstruct SetConfigParam {\\n    uint32 eid;\\n    uint32 configType;\\n    bytes config;\\n}\\n\\ninterface IMessageLibManager {\\n    struct Timeout {\\n        address lib;\\n        uint256 expiry;\\n    }\\n\\n    event LibraryRegistered(address newLib);\\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\\n\\n    function registerLibrary(address _lib) external;\\n\\n    function isRegisteredLibrary(address _lib) external view returns (bool);\\n\\n    function getRegisteredLibraries() external view returns (address[] memory);\\n\\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\\n\\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _timeout) external;\\n\\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\\n\\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\\n\\n    function isSupportedEid(uint32 _eid) external view returns (bool);\\n\\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\\n\\n    /// ------------------- OApp interfaces -------------------\\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\\n\\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\\n\\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\\n\\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\\n\\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\\n\\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _gracePeriod) external;\\n\\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\\n\\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\\n\\n    function getConfig(\\n        address _oapp,\\n        address _lib,\\n        uint32 _eid,\\n        uint32 _configType\\n    ) external view returns (bytes memory config);\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingChannel {\\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\\n\\n    function eid() external view returns (uint32);\\n\\n    // this is an emergency function if a message cannot be verified for some reasons\\n    // required to provide _nextNonce to avoid race condition\\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\\n\\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\\n\\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\\n\\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\\n\\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n\\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\\n\\n    function inboundPayloadHash(\\n        address _receiver,\\n        uint32 _srcEid,\\n        bytes32 _sender,\\n        uint64 _nonce\\n    ) external view returns (bytes32);\\n\\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingComposer {\\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\\n    event LzComposeAlert(\\n        address indexed from,\\n        address indexed to,\\n        address indexed executor,\\n        bytes32 guid,\\n        uint16 index,\\n        uint256 gas,\\n        uint256 value,\\n        bytes message,\\n        bytes extraData,\\n        bytes reason\\n    );\\n\\n    function composeQueue(\\n        address _from,\\n        address _to,\\n        bytes32 _guid,\\n        uint16 _index\\n    ) external view returns (bytes32 messageHash);\\n\\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\\n\\n    function lzCompose(\\n        address _from,\\n        address _to,\\n        bytes32 _guid,\\n        uint16 _index,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingContext {\\n    function isSendingMessage() external view returns (bool);\\n\\n    function getSendContext() external view returns (uint32 dstEid, address sender);\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ISendLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport { MessagingFee } from \\\"./ILayerZeroEndpointV2.sol\\\";\\nimport { IMessageLib } from \\\"./IMessageLib.sol\\\";\\n\\nstruct Packet {\\n    uint64 nonce;\\n    uint32 srcEid;\\n    address sender;\\n    uint32 dstEid;\\n    bytes32 receiver;\\n    bytes32 guid;\\n    bytes message;\\n}\\n\\ninterface ISendLib is IMessageLib {\\n    function send(\\n        Packet calldata _packet,\\n        bytes calldata _options,\\n        bool _payInLzToken\\n    ) external returns (MessagingFee memory, bytes memory encodedPacket);\\n\\n    function quote(\\n        Packet calldata _packet,\\n        bytes calldata _options,\\n        bool _payInLzToken\\n    ) external view returns (MessagingFee memory);\\n\\n    function setTreasury(address _treasury) external;\\n\\n    function withdrawFee(address _to, uint256 _amount) external;\\n\\n    function withdrawLzTokenFee(address _lzToken, address _to, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LZBL-1.2\\n\\npragma solidity ^0.8.20;\\n\\nlibrary AddressCast {\\n    error AddressCast_InvalidSizeForAddress();\\n    error AddressCast_InvalidAddress();\\n\\n    function toBytes32(bytes calldata _addressBytes) internal pure returns (bytes32 result) {\\n        if (_addressBytes.length > 32) revert AddressCast_InvalidAddress();\\n        result = bytes32(_addressBytes);\\n        unchecked {\\n            uint256 offset = 32 - _addressBytes.length;\\n            result = result >> (offset * 8);\\n        }\\n    }\\n\\n    function toBytes32(address _address) internal pure returns (bytes32 result) {\\n        result = bytes32(uint256(uint160(_address)));\\n    }\\n\\n    function toBytes(bytes32 _addressBytes32, uint256 _size) internal pure returns (bytes memory result) {\\n        if (_size == 0 || _size > 32) revert AddressCast_InvalidSizeForAddress();\\n        result = new bytes(_size);\\n        unchecked {\\n            uint256 offset = 256 - _size * 8;\\n            assembly {\\n                mstore(add(result, 32), shl(offset, _addressBytes32))\\n            }\\n        }\\n    }\\n\\n    function toAddress(bytes32 _addressBytes32) internal pure returns (address result) {\\n        result = address(uint160(uint256(_addressBytes32)));\\n    }\\n\\n    function toAddress(bytes calldata _addressBytes) internal pure returns (address result) {\\n        if (_addressBytes.length != 20) revert AddressCast_InvalidAddress();\\n        result = address(bytes20(_addressBytes));\\n    }\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LZBL-1.2\\n\\npragma solidity ^0.8.20;\\n\\nimport { Packet } from \\\"../../interfaces/ISendLib.sol\\\";\\nimport { AddressCast } from \\\"../../libs/AddressCast.sol\\\";\\n\\nlibrary PacketV1Codec {\\n    using AddressCast for address;\\n    using AddressCast for bytes32;\\n\\n    uint8 internal constant PACKET_VERSION = 1;\\n\\n    // header (version + nonce + path)\\n    // version\\n    uint256 private constant PACKET_VERSION_OFFSET = 0;\\n    //    nonce\\n    uint256 private constant NONCE_OFFSET = 1;\\n    //    path\\n    uint256 private constant SRC_EID_OFFSET = 9;\\n    uint256 private constant SENDER_OFFSET = 13;\\n    uint256 private constant DST_EID_OFFSET = 45;\\n    uint256 private constant RECEIVER_OFFSET = 49;\\n    // payload (guid + message)\\n    uint256 private constant GUID_OFFSET = 81; // keccak256(nonce + path)\\n    uint256 private constant MESSAGE_OFFSET = 113;\\n\\n    function encode(Packet memory _packet) internal pure returns (bytes memory encodedPacket) {\\n        encodedPacket = abi.encodePacked(\\n            PACKET_VERSION,\\n            _packet.nonce,\\n            _packet.srcEid,\\n            _packet.sender.toBytes32(),\\n            _packet.dstEid,\\n            _packet.receiver,\\n            _packet.guid,\\n            _packet.message\\n        );\\n    }\\n\\n    function encodePacketHeader(Packet memory _packet) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                PACKET_VERSION,\\n                _packet.nonce,\\n                _packet.srcEid,\\n                _packet.sender.toBytes32(),\\n                _packet.dstEid,\\n                _packet.receiver\\n            );\\n    }\\n\\n    function encodePayload(Packet memory _packet) internal pure returns (bytes memory) {\\n        return abi.encodePacked(_packet.guid, _packet.message);\\n    }\\n\\n    function header(bytes calldata _packet) internal pure returns (bytes calldata) {\\n        return _packet[0:GUID_OFFSET];\\n    }\\n\\n    function version(bytes calldata _packet) internal pure returns (uint8) {\\n        return uint8(bytes1(_packet[PACKET_VERSION_OFFSET:NONCE_OFFSET]));\\n    }\\n\\n    function nonce(bytes calldata _packet) internal pure returns (uint64) {\\n        return uint64(bytes8(_packet[NONCE_OFFSET:SRC_EID_OFFSET]));\\n    }\\n\\n    function srcEid(bytes calldata _packet) internal pure returns (uint32) {\\n        return uint32(bytes4(_packet[SRC_EID_OFFSET:SENDER_OFFSET]));\\n    }\\n\\n    function sender(bytes calldata _packet) internal pure returns (bytes32) {\\n        return bytes32(_packet[SENDER_OFFSET:DST_EID_OFFSET]);\\n    }\\n\\n    function senderAddressB20(bytes calldata _packet) internal pure returns (address) {\\n        return sender(_packet).toAddress();\\n    }\\n\\n    function dstEid(bytes calldata _packet) internal pure returns (uint32) {\\n        return uint32(bytes4(_packet[DST_EID_OFFSET:RECEIVER_OFFSET]));\\n    }\\n\\n    function receiver(bytes calldata _packet) internal pure returns (bytes32) {\\n        return bytes32(_packet[RECEIVER_OFFSET:GUID_OFFSET]);\\n    }\\n\\n    function receiverB20(bytes calldata _packet) internal pure returns (address) {\\n        return receiver(_packet).toAddress();\\n    }\\n\\n    function guid(bytes calldata _packet) internal pure returns (bytes32) {\\n        return bytes32(_packet[GUID_OFFSET:MESSAGE_OFFSET]);\\n    }\\n\\n    function message(bytes calldata _packet) internal pure returns (bytes calldata) {\\n        return bytes(_packet[MESSAGE_OFFSET:]);\\n    }\\n\\n    function payload(bytes calldata _packet) internal pure returns (bytes calldata) {\\n        return bytes(_packet[GUID_OFFSET:]);\\n    }\\n\\n    function payloadHash(bytes calldata _packet) internal pure returns (bytes32) {\\n        return keccak256(payload(_packet));\\n    }\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./ILayerZeroUserApplicationConfig.sol\\\";\\n\\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\n    // @param _payload - a custom bytes payload to send to the destination contract\\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\\n    function send(\\n        uint16 _dstChainId,\\n        bytes calldata _destination,\\n        bytes calldata _payload,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes calldata _adapterParams\\n    ) external payable;\\n\\n    // @notice used by the messaging library to publish verified payload\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source contract (as bytes) at the source chain\\n    // @param _dstAddress - the address on destination chain\\n    // @param _nonce - the unbound message ordering nonce\\n    // @param _gasLimit - the gas limit for external contract execution\\n    // @param _payload - verified payload to send to the destination contract\\n    function receivePayload(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        address _dstAddress,\\n        uint64 _nonce,\\n        uint _gasLimit,\\n        bytes calldata _payload\\n    ) external;\\n\\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\\n\\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n    // @param _srcAddress - the source chain contract address\\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\\n\\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _userApplication - the user app address on this EVM chain\\n    // @param _payload - the custom message to send over LayerZero\\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n    function estimateFees(\\n        uint16 _dstChainId,\\n        address _userApplication,\\n        bytes calldata _payload,\\n        bool _payInZRO,\\n        bytes calldata _adapterParam\\n    ) external view returns (uint nativeFee, uint zroFee);\\n\\n    // @notice get this Endpoint's immutable source identifier\\n    function getChainId() external view returns (uint16);\\n\\n    // @notice the interface to retry failed message on this Endpoint destination\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    // @param _payload - the payload to be retried\\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\\n\\n    // @notice query if any STORED payload (message blocking) at the endpoint.\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\\n\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\\n\\n    // @notice query if the non-reentrancy guard for send() is on\\n    // @return true if the guard is on. false otherwise\\n    function isSendingPayload() external view returns (bool);\\n\\n    // @notice query if the non-reentrancy guard for receive() is on\\n    // @return true if the guard is on. false otherwise\\n    function isReceivingPayload() external view returns (bool);\\n\\n    // @notice get the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _userApplication - the contract address of the user application\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    function getConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        address _userApplication,\\n        uint _configType\\n    ) external view returns (bytes memory);\\n\\n    // @notice get the send() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getSendVersion(address _userApplication) external view returns (uint16);\\n\\n    // @notice get the lzReceive() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroUserApplicationConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroUserApplicationConfig {\\n    // @notice set the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    // @param _config - configuration in the bytes. can encode arbitrary content.\\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\\n\\n    // @notice set the send() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setSendVersion(uint16 _version) external;\\n\\n    // @notice set the lzReceive() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setReceiveVersion(uint16 _version) external;\\n\\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n    // @param _srcChainId - the chainId of the source chain\\n    // @param _srcAddress - the contract address of the source contract at the source chain\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MessageLibBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LZBL-1.2\\n\\npragma solidity ^0.8.20;\\n\\n/// @dev simply a container of endpoint address and local eid\\nabstract contract MessageLibBase {\\n    address internal immutable endpoint;\\n    uint32 internal immutable localEid;\\n\\n    error LZ_MessageLib_OnlyEndpoint();\\n\\n    modifier onlyEndpoint() {\\n        if (endpoint != msg.sender) revert LZ_MessageLib_OnlyEndpoint();\\n        _;\\n    }\\n\\n    constructor(address _endpoint, uint32 _localEid) {\\n        endpoint = _endpoint;\\n        localEid = _localEid;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uln/ReceiveUlnBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LZBL-1.2\\n\\npragma solidity ^0.8.20;\\n\\nimport { PacketV1Codec } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\\\";\\n\\nimport { UlnBase, UlnConfig } from \\\"./UlnBase.sol\\\";\\n\\nstruct Verification {\\n    bool submitted;\\n    uint64 confirmations;\\n}\\n\\n/// @dev includes the utility functions for checking ULN states and logics\\nabstract contract ReceiveUlnBase is UlnBase {\\n    using PacketV1Codec for bytes;\\n\\n    mapping(bytes32 headerHash => mapping(bytes32 payloadHash => mapping(address dvn => Verification)))\\n        public hashLookup;\\n\\n    event PayloadVerified(address dvn, bytes header, uint256 confirmations, bytes32 proofHash);\\n\\n    error LZ_ULN_InvalidPacketHeader();\\n    error LZ_ULN_InvalidPacketVersion();\\n    error LZ_ULN_InvalidEid();\\n    error LZ_ULN_Verifying();\\n\\n    // ============================ External ===================================\\n    function verifiable(\\n        UlnConfig memory _config,\\n        bytes32 _headerHash,\\n        bytes32 _payloadHash\\n    ) external view returns (bool) {\\n        return _checkVerifiable(_config, _headerHash, _payloadHash);\\n    }\\n\\n    function assertHeader(bytes calldata _packetHeader, uint32 _localEid) external pure {\\n        _assertHeader(_packetHeader, _localEid);\\n    }\\n\\n    // ============================ Internal ===================================\\n    /// @dev per DVN signing function\\n    function _verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) internal {\\n        hashLookup[keccak256(_packetHeader)][_payloadHash][msg.sender] = Verification(true, _confirmations);\\n        emit PayloadVerified(msg.sender, _packetHeader, _confirmations, _payloadHash);\\n    }\\n\\n    function _verified(\\n        address _dvn,\\n        bytes32 _headerHash,\\n        bytes32 _payloadHash,\\n        uint64 _requiredConfirmation\\n    ) internal view returns (bool verified) {\\n        Verification memory verification = hashLookup[_headerHash][_payloadHash][_dvn];\\n        // return true if the dvn has signed enough confirmations\\n        verified = verification.submitted && verification.confirmations >= _requiredConfirmation;\\n    }\\n\\n    function _verifyAndReclaimStorage(UlnConfig memory _config, bytes32 _headerHash, bytes32 _payloadHash) internal {\\n        if (!_checkVerifiable(_config, _headerHash, _payloadHash)) {\\n            revert LZ_ULN_Verifying();\\n        }\\n\\n        // iterate the required DVNs\\n        if (_config.requiredDVNCount > 0) {\\n            for (uint8 i = 0; i < _config.requiredDVNCount; ++i) {\\n                delete hashLookup[_headerHash][_payloadHash][_config.requiredDVNs[i]];\\n            }\\n        }\\n\\n        // iterate the optional DVNs\\n        if (_config.optionalDVNCount > 0) {\\n            for (uint8 i = 0; i < _config.optionalDVNCount; ++i) {\\n                delete hashLookup[_headerHash][_payloadHash][_config.optionalDVNs[i]];\\n            }\\n        }\\n    }\\n\\n    function _assertHeader(bytes calldata _packetHeader, uint32 _localEid) internal pure {\\n        // assert packet header is of right size 81\\n        if (_packetHeader.length != 81) revert LZ_ULN_InvalidPacketHeader();\\n        // assert packet header version is the same as ULN\\n        if (_packetHeader.version() != PacketV1Codec.PACKET_VERSION) revert LZ_ULN_InvalidPacketVersion();\\n        // assert the packet is for this endpoint\\n        if (_packetHeader.dstEid() != _localEid) revert LZ_ULN_InvalidEid();\\n    }\\n\\n    /// @dev for verifiable view function\\n    /// @dev checks if this verification is ready to be committed to the endpoint\\n    function _checkVerifiable(\\n        UlnConfig memory _config,\\n        bytes32 _headerHash,\\n        bytes32 _payloadHash\\n    ) internal view returns (bool) {\\n        // iterate the required DVNs\\n        if (_config.requiredDVNCount > 0) {\\n            for (uint8 i = 0; i < _config.requiredDVNCount; ++i) {\\n                if (!_verified(_config.requiredDVNs[i], _headerHash, _payloadHash, _config.confirmations)) {\\n                    // return if any of the required DVNs haven't signed\\n                    return false;\\n                }\\n            }\\n            if (_config.optionalDVNCount == 0) {\\n                // returns early if all required DVNs have signed and there are no optional DVNs\\n                return true;\\n            }\\n        }\\n\\n        // then it must require optional validations\\n        uint8 threshold = _config.optionalDVNThreshold;\\n        for (uint8 i = 0; i < _config.optionalDVNCount; ++i) {\\n            if (_verified(_config.optionalDVNs[i], _headerHash, _payloadHash, _config.confirmations)) {\\n                // increment the optional count if the optional DVN has signed\\n                threshold--;\\n                if (threshold == 0) {\\n                    // early return if the optional threshold has hit\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        // return false as a catch-all\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uln/UlnBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LZBL-1.2\\n\\npragma solidity ^0.8.20;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n// the formal properties are documented in the setter functions\\nstruct UlnConfig {\\n    uint64 confirmations;\\n    // we store the length of required DVNs and optional DVNs instead of using DVN.length directly to save gas\\n    uint8 requiredDVNCount; // 0 indicate DEFAULT, NIL_DVN_COUNT indicate NONE (to override the value of default)\\n    uint8 optionalDVNCount; // 0 indicate DEFAULT, NIL_DVN_COUNT indicate NONE (to override the value of default)\\n    uint8 optionalDVNThreshold; // (0, optionalDVNCount]\\n    address[] requiredDVNs; // no duplicates. sorted an an ascending order. allowed overlap with optionalDVNs\\n    address[] optionalDVNs; // no duplicates. sorted an an ascending order. allowed overlap with requiredDVNs\\n}\\n\\nstruct SetDefaultUlnConfigParam {\\n    uint32 eid;\\n    UlnConfig config;\\n}\\n\\n/// @dev includes the utility functions for checking ULN states and logics\\nabstract contract UlnBase is Ownable {\\n    address private constant DEFAULT_CONFIG = address(0);\\n    // reserved values for\\n    uint8 internal constant DEFAULT = 0;\\n    uint8 internal constant NIL_DVN_COUNT = type(uint8).max;\\n    uint64 internal constant NIL_CONFIRMATIONS = type(uint64).max;\\n    // 127 to prevent total number of DVNs (127 * 2) exceeding uint8.max (255)\\n    // by limiting the total size, it would help constraint the design of DVNOptions\\n    uint8 private constant MAX_COUNT = (type(uint8).max - 1) / 2;\\n\\n    mapping(address oapp => mapping(uint32 eid => UlnConfig)) internal ulnConfigs;\\n\\n    error LZ_ULN_Unsorted();\\n    error LZ_ULN_InvalidRequiredDVNCount();\\n    error LZ_ULN_InvalidOptionalDVNCount();\\n    error LZ_ULN_AtLeastOneDVN();\\n    error LZ_ULN_InvalidOptionalDVNThreshold();\\n    error LZ_ULN_InvalidConfirmations();\\n    error LZ_ULN_UnsupportedEid(uint32 eid);\\n\\n    event DefaultUlnConfigsSet(SetDefaultUlnConfigParam[] params);\\n    event UlnConfigSet(address oapp, uint32 eid, UlnConfig config);\\n\\n    // ============================ OnlyOwner ===================================\\n\\n    /// @dev about the DEFAULT ULN config\\n    /// 1) its values are all LITERAL (e.g. 0 is 0). whereas in the oapp ULN config, 0 (default value) points to the default ULN config\\n    ///     this design enables the oapp to point to DEFAULT config without explicitly setting the config\\n    /// 2) its configuration is more restrictive than the oapp ULN config that\\n    ///     a) it must not use NIL value, where NIL is used only by oapps to indicate the LITERAL 0\\n    ///     b) it must have at least one DVN\\n    function setDefaultUlnConfigs(SetDefaultUlnConfigParam[] calldata _params) external onlyOwner {\\n        for (uint256 i = 0; i < _params.length; ++i) {\\n            SetDefaultUlnConfigParam calldata param = _params[i];\\n\\n            // 2.a must not use NIL\\n            if (param.config.requiredDVNCount == NIL_DVN_COUNT) revert LZ_ULN_InvalidRequiredDVNCount();\\n            if (param.config.optionalDVNCount == NIL_DVN_COUNT) revert LZ_ULN_InvalidOptionalDVNCount();\\n            if (param.config.confirmations == NIL_CONFIRMATIONS) revert LZ_ULN_InvalidConfirmations();\\n\\n            // 2.b must have at least one dvn\\n            _assertAtLeastOneDVN(param.config);\\n\\n            _setConfig(DEFAULT_CONFIG, param.eid, param.config);\\n        }\\n        emit DefaultUlnConfigsSet(_params);\\n    }\\n\\n    // ============================ View ===================================\\n    // @dev assuming most oapps use default, we get default as memory and custom as storage to save gas\\n    function getUlnConfig(address _oapp, uint32 _remoteEid) public view returns (UlnConfig memory rtnConfig) {\\n        UlnConfig storage defaultConfig = ulnConfigs[DEFAULT_CONFIG][_remoteEid];\\n        UlnConfig storage customConfig = ulnConfigs[_oapp][_remoteEid];\\n\\n        // if confirmations is 0, use default\\n        uint64 confirmations = customConfig.confirmations;\\n        if (confirmations == DEFAULT) {\\n            rtnConfig.confirmations = defaultConfig.confirmations;\\n        } else if (confirmations != NIL_CONFIRMATIONS) {\\n            // if confirmations is uint64.max, no block confirmations required\\n            rtnConfig.confirmations = confirmations;\\n        } // else do nothing, rtnConfig.confirmation is 0\\n\\n        if (customConfig.requiredDVNCount == DEFAULT) {\\n            if (defaultConfig.requiredDVNCount > 0) {\\n                // copy only if count > 0. save gas\\n                rtnConfig.requiredDVNs = defaultConfig.requiredDVNs;\\n                rtnConfig.requiredDVNCount = defaultConfig.requiredDVNCount;\\n            } // else, do nothing\\n        } else {\\n            if (customConfig.requiredDVNCount != NIL_DVN_COUNT) {\\n                rtnConfig.requiredDVNs = customConfig.requiredDVNs;\\n                rtnConfig.requiredDVNCount = customConfig.requiredDVNCount;\\n            } // else, do nothing\\n        }\\n\\n        if (customConfig.optionalDVNCount == DEFAULT) {\\n            if (defaultConfig.optionalDVNCount > 0) {\\n                // copy only if count > 0. save gas\\n                rtnConfig.optionalDVNs = defaultConfig.optionalDVNs;\\n                rtnConfig.optionalDVNCount = defaultConfig.optionalDVNCount;\\n                rtnConfig.optionalDVNThreshold = defaultConfig.optionalDVNThreshold;\\n            }\\n        } else {\\n            if (customConfig.optionalDVNCount != NIL_DVN_COUNT) {\\n                rtnConfig.optionalDVNs = customConfig.optionalDVNs;\\n                rtnConfig.optionalDVNCount = customConfig.optionalDVNCount;\\n                rtnConfig.optionalDVNThreshold = customConfig.optionalDVNThreshold;\\n            }\\n        }\\n\\n        // the final value must have at least one dvn\\n        // it is possible that some default config result into 0 dvns\\n        _assertAtLeastOneDVN(rtnConfig);\\n    }\\n\\n    /// @dev Get the uln config without the default config for the given remoteEid.\\n    function getAppUlnConfig(address _oapp, uint32 _remoteEid) external view returns (UlnConfig memory) {\\n        return ulnConfigs[_oapp][_remoteEid];\\n    }\\n\\n    // ============================ Internal ===================================\\n    function _setUlnConfig(uint32 _remoteEid, address _oapp, UlnConfig memory _param) internal {\\n        _setConfig(_oapp, _remoteEid, _param);\\n\\n        // get ULN config again as a catch all to ensure the config is valid\\n        getUlnConfig(_oapp, _remoteEid);\\n        emit UlnConfigSet(_oapp, _remoteEid, _param);\\n    }\\n\\n    /// @dev a supported Eid must have a valid default uln config, which has at least one dvn\\n    function _isSupportedEid(uint32 _remoteEid) internal view returns (bool) {\\n        UlnConfig storage defaultConfig = ulnConfigs[DEFAULT_CONFIG][_remoteEid];\\n        return defaultConfig.requiredDVNCount > 0 || defaultConfig.optionalDVNThreshold > 0;\\n    }\\n\\n    function _assertSupportedEid(uint32 _remoteEid) internal view {\\n        if (!_isSupportedEid(_remoteEid)) revert LZ_ULN_UnsupportedEid(_remoteEid);\\n    }\\n\\n    // ============================ Private ===================================\\n\\n    function _assertAtLeastOneDVN(UlnConfig memory _config) private pure {\\n        if (_config.requiredDVNCount == 0 && _config.optionalDVNThreshold == 0) revert LZ_ULN_AtLeastOneDVN();\\n    }\\n\\n    /// @dev this private function is used in both setDefaultUlnConfigs and setUlnConfig\\n    function _setConfig(address _oapp, uint32 _eid, UlnConfig memory _param) private {\\n        // @dev required dvns\\n        // if dvnCount == NONE, dvns list must be empty\\n        // if dvnCount == DEFAULT, dvn list must be empty\\n        // otherwise, dvnList.length == dvnCount and assert the list is valid\\n        if (_param.requiredDVNCount == NIL_DVN_COUNT || _param.requiredDVNCount == DEFAULT) {\\n            if (_param.requiredDVNs.length != 0) revert LZ_ULN_InvalidRequiredDVNCount();\\n        } else {\\n            if (_param.requiredDVNs.length != _param.requiredDVNCount || _param.requiredDVNCount > MAX_COUNT)\\n                revert LZ_ULN_InvalidRequiredDVNCount();\\n            _assertNoDuplicates(_param.requiredDVNs);\\n        }\\n\\n        // @dev optional dvns\\n        // if optionalDVNCount == NONE, optionalDVNs list must be empty and threshold must be 0\\n        // if optionalDVNCount == DEFAULT, optionalDVNs list must be empty and threshold must be 0\\n        // otherwise, optionalDVNs.length == optionalDVNCount, threshold > 0 && threshold <= optionalDVNCount and assert the list is valid\\n\\n        // example use case: an oapp uses the DEFAULT 'required' but\\n        //     a) use a custom 1/1 dvn (practically a required dvn), or\\n        //     b) use a custom 2/3 dvn\\n        if (_param.optionalDVNCount == NIL_DVN_COUNT || _param.optionalDVNCount == DEFAULT) {\\n            if (_param.optionalDVNs.length != 0) revert LZ_ULN_InvalidOptionalDVNCount();\\n            if (_param.optionalDVNThreshold != 0) revert LZ_ULN_InvalidOptionalDVNThreshold();\\n        } else {\\n            if (_param.optionalDVNs.length != _param.optionalDVNCount || _param.optionalDVNCount > MAX_COUNT)\\n                revert LZ_ULN_InvalidOptionalDVNCount();\\n            if (_param.optionalDVNThreshold == 0 || _param.optionalDVNThreshold > _param.optionalDVNCount)\\n                revert LZ_ULN_InvalidOptionalDVNThreshold();\\n            _assertNoDuplicates(_param.optionalDVNs);\\n        }\\n        // don't assert valid count here, as it needs to be validated along side default config\\n\\n        ulnConfigs[_oapp][_eid] = _param;\\n    }\\n\\n    function _assertNoDuplicates(address[] memory _dvns) private pure {\\n        address lastDVN = address(0);\\n        for (uint256 i = 0; i < _dvns.length; i++) {\\n            address dvn = _dvns[i];\\n            if (dvn <= lastDVN) revert LZ_ULN_Unsorted(); // to ensure no duplicates\\n            lastDVN = dvn;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uln/uln301/AddressSizeConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LZBL-1.2\\n\\npragma solidity ^0.8.20;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nabstract contract AddressSizeConfig is Ownable {\\n    // EndpointV1 is using bytes as address. this map is for address length assertion\\n    mapping(uint32 dstEid => uint256 size) public addressSizes;\\n\\n    event AddressSizeSet(uint16 eid, uint256 size);\\n\\n    error AddressSizeConfig_InvalidAddressSize();\\n    error AddressSizeConfig_AddressSizeAlreadySet();\\n\\n    function setAddressSize(uint16 _eid, uint256 _size) external onlyOwner {\\n        if (_size > 32) revert AddressSizeConfig_InvalidAddressSize();\\n        if (addressSizes[_eid] != 0) revert AddressSizeConfig_AddressSizeAlreadySet();\\n        addressSizes[_eid] = _size;\\n        emit AddressSizeSet(_eid, _size);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uln/uln301/ReceiveLibBaseE1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LZBL-1.2\\n\\npragma solidity ^0.8.20;\\n\\nimport { Origin } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\\\";\\nimport { ILayerZeroEndpoint } from \\\"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroEndpoint.sol\\\";\\nimport { AddressCast } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/libs/AddressCast.sol\\\";\\n\\nimport { AddressSizeConfig } from \\\"./AddressSizeConfig.sol\\\";\\nimport { MessageLibBase } from \\\"../../MessageLibBase.sol\\\";\\n\\n// only receiver function from \\\"@layerzerolabs/lz-evm-v1-0.7/contracts/interfaces/ILayerZeroMessagingLibrary.sol\\\"\\n// because we are separating the send and receive libraries\\ninterface ILayerZeroReceiveLibrary {\\n    // setConfig / getConfig are User Application (UA) functions to specify Oracle, Relayer, blockConfirmations, libraryVersion\\n    function setConfig(uint16 _chainId, address _userApplication, uint256 _configType, bytes calldata _config) external;\\n\\n    function getConfig(\\n        uint16 _chainId,\\n        address _userApplication,\\n        uint256 _configType\\n    ) external view returns (bytes memory);\\n}\\n\\nstruct SetDefaultExecutorParam {\\n    uint32 eid;\\n    address executor;\\n}\\n\\n/// @dev receive-side message library base contract on endpoint v1.\\n/// design:\\n/// 1/ it provides an internal execute function that calls the endpoint. It enforces the path definition on V1.\\n/// 2/ it provides interfaces to configure executors that is whitelisted to execute the msg to prevent grieving\\nabstract contract ReceiveLibBaseE1 is MessageLibBase, AddressSizeConfig, ILayerZeroReceiveLibrary {\\n    using AddressCast for bytes32;\\n\\n    mapping(address oapp => mapping(uint32 eid => address executor)) public executors;\\n    mapping(uint32 eid => address executor) public defaultExecutors;\\n\\n    // this event is the same as the PacketDelivered event on EndpointV2\\n    event PacketDelivered(Origin origin, address receiver);\\n    event InvalidDst(\\n        uint16 indexed srcChainId,\\n        bytes32 srcAddress,\\n        address indexed dstAddress,\\n        uint64 nonce,\\n        bytes32 payloadHash\\n    );\\n    event DefaultExecutorsSet(SetDefaultExecutorParam[] params);\\n    event ExecutorSet(address oapp, uint32 eid, address executor);\\n\\n    error LZ_MessageLib_InvalidExecutor();\\n    error LZ_MessageLib_OnlyExecutor();\\n\\n    constructor(address _endpoint, uint32 _localEid) MessageLibBase(_endpoint, _localEid) {}\\n\\n    function setDefaultExecutors(SetDefaultExecutorParam[] calldata _params) external onlyOwner {\\n        for (uint256 i = 0; i < _params.length; ++i) {\\n            SetDefaultExecutorParam calldata param = _params[i];\\n            if (param.executor == address(0x0)) revert LZ_MessageLib_InvalidExecutor();\\n            defaultExecutors[param.eid] = param.executor;\\n        }\\n        emit DefaultExecutorsSet(_params);\\n    }\\n\\n    function getExecutor(address _oapp, uint32 _remoteEid) public view returns (address) {\\n        address executor = executors[_oapp][_remoteEid];\\n        return executor != address(0x0) ? executor : defaultExecutors[_remoteEid];\\n    }\\n\\n    function _setExecutor(uint32 _remoteEid, address _oapp, address _executor) internal {\\n        executors[_oapp][_remoteEid] = _executor;\\n        emit ExecutorSet(_oapp, _remoteEid, _executor);\\n    }\\n\\n    /// @dev this function change pack the path as required for EndpointV1\\n    function _execute(\\n        uint16 _srcEid,\\n        bytes32 _sender,\\n        address _receiver,\\n        uint64 _nonce,\\n        bytes memory _message,\\n        uint256 _gasLimit\\n    ) internal {\\n        // if the executor is malicious, it can make the msg as a storedPayload or fail in the nonBlockingApp\\n        // which might result in unintended behaviour and risks, like grieving.\\n        // to err on the safe side, we should assert the executor here.\\n        if (msg.sender != getExecutor(_receiver, _srcEid)) revert LZ_MessageLib_OnlyExecutor();\\n\\n        if (_receiver.code.length == 0) {\\n            /// on chains where EOA has no codes, it will early return and emit InvalidDst event\\n            // on chains where all address have codes, this will be skipped\\n            emit InvalidDst(_srcEid, _sender, _receiver, _nonce, keccak256(_message));\\n            return;\\n        }\\n\\n        bytes memory pathData = abi.encodePacked(_sender.toBytes(addressSizes[_srcEid]), _receiver);\\n        ILayerZeroEndpoint(endpoint).receivePayload(_srcEid, pathData, _receiver, _nonce, _gasLimit, _message);\\n\\n        Origin memory origin = Origin(_srcEid, _sender, _nonce);\\n        emit PacketDelivered(origin, _receiver);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uln/uln301/ReceiveUln301.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LZBL-1.2\\n\\npragma solidity ^0.8.20;\\n\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport { PacketV1Codec } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/messagelib/libs/PacketV1Codec.sol\\\";\\n\\nimport { IUltraLightNode301 } from \\\"./interfaces/IUltraLightNode301.sol\\\";\\nimport { ReceiveLibBaseE1 } from \\\"./ReceiveLibBaseE1.sol\\\";\\nimport { ReceiveUlnBase } from \\\"../ReceiveUlnBase.sol\\\";\\nimport { UlnConfig } from \\\"../UlnBase.sol\\\";\\n\\n/// @dev ULN301 will be deployed on EndpointV1 and is for backward compatibility with ULN302 on EndpointV2. 301 can talk to both 301 and 302\\n/// @dev This is a gluing contract. It simply parses the requests and forward to the super.impl() accordingly.\\n/// @dev In this case, it combines the logic of ReceiveUlnBase and ReceiveLibBaseE1\\ncontract ReceiveUln301 is IUltraLightNode301, ReceiveUlnBase, ReceiveLibBaseE1 {\\n    using PacketV1Codec for bytes;\\n    using SafeCast for uint32; // for chain ID uint32 to uint16 conversion\\n\\n    uint256 internal constant CONFIG_TYPE_EXECUTOR = 1;\\n    uint256 internal constant CONFIG_TYPE_ULN = 2;\\n\\n    error LZ_ULN_InvalidConfigType(uint256 configType);\\n\\n    constructor(address _endpoint, uint32 _localEid) ReceiveLibBaseE1(_endpoint, _localEid) {}\\n\\n    // ============================ OnlyEndpoint ===================================\\n\\n    function setConfig(\\n        uint16 _eid,\\n        address _oapp,\\n        uint256 _configType,\\n        bytes calldata _config\\n    ) external override onlyEndpoint {\\n        _assertSupportedEid(_eid);\\n        if (_configType == CONFIG_TYPE_EXECUTOR) {\\n            _setExecutor(_eid, _oapp, abi.decode(_config, (address)));\\n        } else if (_configType == CONFIG_TYPE_ULN) {\\n            _setUlnConfig(_eid, _oapp, abi.decode(_config, (UlnConfig)));\\n        } else {\\n            revert LZ_ULN_InvalidConfigType(_configType);\\n        }\\n    }\\n\\n    // ============================ External ===================================\\n\\n    /// @dev in 301, this is equivalent to execution as in Endpoint V2\\n    /// @dev dont need to check endpoint verifiable here to save gas, as it will reverts if not verifiable.\\n    function commitVerification(bytes calldata _packet, uint256 _gasLimit) external {\\n        bytes calldata header = _packet.header();\\n        _assertHeader(header, localEid);\\n\\n        // cache these values to save gas\\n        address receiver = _packet.receiverB20();\\n        uint16 srcEid = _packet.srcEid().toUint16();\\n\\n        UlnConfig memory config = getUlnConfig(receiver, srcEid);\\n        _verifyAndReclaimStorage(config, keccak256(header), _packet.payloadHash());\\n\\n        // endpoint will revert if nonce != ++inboundNonce\\n        _execute(srcEid, _packet.sender(), receiver, _packet.nonce(), _packet.message(), _gasLimit);\\n    }\\n\\n    function verify(bytes calldata _packetHeader, bytes32 _payloadHash, uint64 _confirmations) external {\\n        _verify(_packetHeader, _payloadHash, _confirmations);\\n    }\\n\\n    // ============================ View ===================================\\n\\n    function getConfig(uint16 _eid, address _oapp, uint256 _configType) external view override returns (bytes memory) {\\n        if (_configType == CONFIG_TYPE_EXECUTOR) {\\n            return abi.encode(getExecutor(_oapp, _eid));\\n        } else if (_configType == CONFIG_TYPE_ULN) {\\n            return abi.encode(getUlnConfig(_oapp, _eid));\\n        } else {\\n            revert LZ_ULN_InvalidConfigType(_configType);\\n        }\\n    }\\n\\n    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {\\n        return (3, 0, 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uln/uln301/interfaces/IUltraLightNode301.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IUltraLightNode301 {\\n    function commitVerification(bytes calldata _packet, uint256 _gasLimit) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_endpoint\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_localEid\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AddressCast_InvalidSizeForAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AddressSizeConfig_AddressSizeAlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AddressSizeConfig_InvalidAddressSize\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_MessageLib_InvalidExecutor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_MessageLib_OnlyEndpoint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_MessageLib_OnlyExecutor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_ULN_AtLeastOneDVN\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"configType\",\"type\":\"uint256\"}],\"name\":\"LZ_ULN_InvalidConfigType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_ULN_InvalidConfirmations\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_ULN_InvalidEid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_ULN_InvalidOptionalDVNCount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_ULN_InvalidOptionalDVNThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_ULN_InvalidPacketHeader\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_ULN_InvalidPacketVersion\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_ULN_InvalidRequiredDVNCount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_ULN_Unsorted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"}],\"name\":\"LZ_ULN_UnsupportedEid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LZ_ULN_Verifying\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"eid\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"AddressSizeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct SetDefaultExecutorParam[]\",\"name\":\"params\",\"type\":\"tuple[]\"}],\"name\":\"DefaultExecutorsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"confirmations\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"requiredDVNCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"optionalDVNCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"optionalDVNThreshold\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"requiredDVNs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"optionalDVNs\",\"type\":\"address[]\"}],\"internalType\":\"struct UlnConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct SetDefaultUlnConfigParam[]\",\"name\":\"params\",\"type\":\"tuple[]\"}],\"name\":\"DefaultUlnConfigsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oapp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"ExecutorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcAddress\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidDst\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"struct Origin\",\"name\":\"origin\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"PacketDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dvn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"header\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"confirmations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proofHash\",\"type\":\"bytes32\"}],\"name\":\"PayloadVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oapp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"confirmations\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"requiredDVNCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"optionalDVNCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"optionalDVNThreshold\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"requiredDVNs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"optionalDVNs\",\"type\":\"address[]\"}],\"indexed\":false,\"internalType\":\"struct UlnConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"UlnConfigSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"dstEid\",\"type\":\"uint32\"}],\"name\":\"addressSizes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_packetHeader\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"_localEid\",\"type\":\"uint32\"}],\"name\":\"assertHeader\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_packet\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"}],\"name\":\"commitVerification\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"}],\"name\":\"defaultExecutors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oapp\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"}],\"name\":\"executors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oapp\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_remoteEid\",\"type\":\"uint32\"}],\"name\":\"getAppUlnConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"confirmations\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"requiredDVNCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"optionalDVNCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"optionalDVNThreshold\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"requiredDVNs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"optionalDVNs\",\"type\":\"address[]\"}],\"internalType\":\"struct UlnConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_eid\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_oapp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oapp\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_remoteEid\",\"type\":\"uint32\"}],\"name\":\"getExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oapp\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_remoteEid\",\"type\":\"uint32\"}],\"name\":\"getUlnConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"confirmations\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"requiredDVNCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"optionalDVNCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"optionalDVNThreshold\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"requiredDVNs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"optionalDVNs\",\"type\":\"address[]\"}],\"internalType\":\"struct UlnConfig\",\"name\":\"rtnConfig\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"headerHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"dvn\",\"type\":\"address\"}],\"name\":\"hashLookup\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"submitted\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"confirmations\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_eid\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"}],\"name\":\"setAddressSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_eid\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_oapp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_config\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"internalType\":\"struct SetDefaultExecutorParam[]\",\"name\":\"_params\",\"type\":\"tuple[]\"}],\"name\":\"setDefaultExecutors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"confirmations\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"requiredDVNCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"optionalDVNCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"optionalDVNThreshold\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"requiredDVNs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"optionalDVNs\",\"type\":\"address[]\"}],\"internalType\":\"struct UlnConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"internalType\":\"struct SetDefaultUlnConfigParam[]\",\"name\":\"_params\",\"type\":\"tuple[]\"}],\"name\":\"setDefaultUlnConfigs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"confirmations\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"requiredDVNCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"optionalDVNCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"optionalDVNThreshold\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"requiredDVNs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"optionalDVNs\",\"type\":\"address[]\"}],\"internalType\":\"struct UlnConfig\",\"name\":\"_config\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_headerHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_payloadHash\",\"type\":\"bytes32\"}],\"name\":\"verifiable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_packetHeader\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_payloadHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_confirmations\",\"type\":\"uint64\"}],\"name\":\"verify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"major\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"minor\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"endpointVersion\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "ReceiveUln301", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "00000000000000000000000066a71dcef29a0ffbdbe3c6a460a3b5bc225cd6750000000000000000000000000000000000000000000000000000000000000065", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}