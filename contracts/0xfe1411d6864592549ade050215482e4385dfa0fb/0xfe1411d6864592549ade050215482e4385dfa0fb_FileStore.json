{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/FileStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\nimport {SSTORE2} from \\\"solady/utils/SSTORE2.sol\\\";\\nimport {LibString} from \\\"solady/utils/LibString.sol\\\";\\nimport {IFileStore} from \\\"./IFileStore.sol\\\";\\nimport {File, BytecodeSlice, SliceOutOfBounds} from \\\"./File.sol\\\";\\nimport {addContent, isValidPointer} from \\\"./common.sol\\\";\\n\\n/**\\n * @title EthFS FileStore\\n * @notice Content-addressable file storage for Ethereum. Files are composed of slices of contract bytecode, the most efficient way to store and retrieve data onchain.\\n */\\ncontract FileStore is IFileStore {\\n    /**\\n     * @dev The address of the CREATE2 deterministic deployer\\n     */\\n    address public immutable deployer;\\n\\n    /**\\n     * @dev Mapping of filenames to their respective SSTORE2 pointer where the ABI-encoded File lives\\n     */\\n    mapping(string filename => address pointer) public files;\\n\\n    /**\\n     *\\n     * @param _deployer The address of the deterministic CREATE2 deployer\\n     */\\n    constructor(address _deployer) {\\n        deployer = _deployer;\\n        emit Deployed();\\n    }\\n\\n    /**\\n     * @notice Checks if a file exists for a given filename\\n     * @param filename The name of the file to check\\n     * @return True if the file exists, false otherwise\\n     */\\n    function fileExists(string memory filename) public view returns (bool) {\\n        return files[filename] != address(0);\\n    }\\n\\n    /**\\n     * @notice Retrieves the pointer address for a given filename\\n     * @param filename The name of the file\\n     * @return pointer The pointer address of the file\\n     */\\n    function getPointer(\\n        string memory filename\\n    ) public view returns (address pointer) {\\n        pointer = files[filename];\\n        if (pointer == address(0)) {\\n            revert FileNotFound(filename);\\n        }\\n        return pointer;\\n    }\\n\\n    /**\\n     * @notice Retrieves a file by its filename\\n     * @param filename The name of the file\\n     * @return file The file associated with the filename\\n     */\\n    function getFile(\\n        string memory filename\\n    ) public view returns (File memory file) {\\n        address pointer = files[filename];\\n        if (pointer == address(0)) {\\n            revert FileNotFound(filename);\\n        }\\n        return abi.decode(SSTORE2.read(pointer), (File));\\n    }\\n\\n    /**\\n     * @notice Creates a new file with the provided file contents\\n     * @dev This is a convenience method to simplify small file uploads. It's recommended to use `createFileFromPointers` or `createFileFromSlices` for larger files. This particular method splits `contents` into 24575-byte chunks before storing them via SSTORE2.\\n     * @param filename The name of the new file\\n     * @param contents The contents of the file\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFile(\\n        string memory filename,\\n        string memory contents\\n    ) public returns (address pointer, File memory file) {\\n        return _createFile(filename, _fileFromContents(contents), new bytes(0));\\n    }\\n\\n    /**\\n     * @notice Creates a new file with the provided file contents and file metadata\\n     * @dev This is a convenience method to simplify small file uploads. It's recommended to use `createFileFromPointers` or `createFileFromSlices` for larger files. This particular method splits `contents` into 24575-byte chunks before storing them via SSTORE2.\\n     * @param filename The name of the new file\\n     * @param contents The contents of the file\\n     * @param metadata Additional file metadata, usually a JSON-encoded string, for offchain indexers\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFile(\\n        string memory filename,\\n        string memory contents,\\n        bytes memory metadata\\n    ) public returns (address pointer, File memory file) {\\n        return _createFile(filename, _fileFromContents(contents), metadata);\\n    }\\n\\n    /**\\n     * @notice Creates a new file where its content is composed of the provided string chunks\\n     * @dev This is a convenience method to simplify small and nuanced file uploads. It's recommended to use `createFileFromPointers` or `createFileFromSlices` for larger files. This particular will store each chunk separately via SSTORE2. For best gas efficiency, each chunk should be as large as possible (up to the contract size limit) and at least 32 bytes.\\n     * @param filename The name of the new file\\n     * @param chunks The string chunks composing the file\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFileFromChunks(\\n        string memory filename,\\n        string[] memory chunks\\n    ) public returns (address pointer, File memory file) {\\n        return _createFile(filename, _fileFromChunks(chunks), new bytes(0));\\n    }\\n\\n    /**\\n     * @notice Creates a new file with the provided string chunks and file metadata\\n     * @dev This is a convenience method to simplify small and nuanced file uploads. It's recommended to use `createFileFromPointers` or `createFileFromSlices` for larger files. This particular will store each chunk separately via SSTORE2. For best gas efficiency, each chunk should be as large as possible (up to the contract size limit) and at least 32 bytes.\\n     * @param filename The name of the new file\\n     * @param chunks The string chunks composing the file\\n     * @param metadata Additional file metadata, usually a JSON-encoded string, for offchain indexers\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFileFromChunks(\\n        string memory filename,\\n        string[] memory chunks,\\n        bytes memory metadata\\n    ) public returns (address pointer, File memory file) {\\n        return _createFile(filename, _fileFromChunks(chunks), metadata);\\n    }\\n\\n    /**\\n     * @notice Creates a new file where its content is composed of the provided SSTORE2 pointers\\n     * @param filename The name of the new file\\n     * @param pointers The SSTORE2 pointers composing the file\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFileFromPointers(\\n        string memory filename,\\n        address[] memory pointers\\n    ) public returns (address pointer, File memory file) {\\n        return _createFile(filename, _fileFromPointers(pointers), new bytes(0));\\n    }\\n\\n    /**\\n     * @notice Creates a new file with the provided SSTORE2 pointers and file metadata\\n     * @param filename The name of the new file\\n     * @param pointers The SSTORE2 pointers composing the file\\n     * @param metadata Additional file metadata, usually a JSON-encoded string, for offchain indexers\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFileFromPointers(\\n        string memory filename,\\n        address[] memory pointers,\\n        bytes memory metadata\\n    ) public returns (address pointer, File memory file) {\\n        return _createFile(filename, _fileFromPointers(pointers), metadata);\\n    }\\n\\n    /**\\n     * @notice Creates a new file where its content is composed of the provided bytecode slices\\n     * @param filename The name of the new file\\n     * @param slices The bytecode slices composing the file\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFileFromSlices(\\n        string memory filename,\\n        BytecodeSlice[] memory slices\\n    ) public returns (address pointer, File memory file) {\\n        return _createFile(filename, _fileFromSlices(slices), new bytes(0));\\n    }\\n\\n    /**\\n     * @notice Creates a new file with the provided bytecode slices and file metadata\\n     * @param filename The name of the new file\\n     * @param slices The bytecode slices composing the file\\n     * @param metadata Additional file metadata, usually a JSON-encoded string, for offchain indexers\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFileFromSlices(\\n        string memory filename,\\n        BytecodeSlice[] memory slices,\\n        bytes memory metadata\\n    ) public returns (address pointer, File memory file) {\\n        return _createFile(filename, _fileFromSlices(slices), metadata);\\n    }\\n\\n    /**\\n     * @dev Internal function for preparing a file from its contents\\n     */\\n    function _fileFromContents(\\n        string memory contents\\n    ) internal returns (File memory file) {\\n        uint256 size = bytes(contents).length;\\n        uint256 chunkSize = 0x6000 - 1;\\n        uint256 numChunks = (size + chunkSize - 1) / chunkSize;\\n        string[] memory chunks = new string[](numChunks);\\n        for (uint256 i = 0; i < numChunks; ++i) {\\n            uint256 start = i * chunkSize;\\n            uint256 end = start + chunkSize > size ? size : start + chunkSize;\\n            chunks[i] = LibString.slice(contents, start, end);\\n        }\\n        return _fileFromChunks(chunks);\\n    }\\n\\n    /**\\n     * @dev Internal function for preparing a file from its chunks\\n     */\\n    function _fileFromChunks(\\n        string[] memory chunks\\n    ) internal returns (File memory file) {\\n        uint256 size = 0;\\n        BytecodeSlice[] memory slices = new BytecodeSlice[](chunks.length);\\n        for (uint256 i = 0; i < chunks.length; ++i) {\\n            slices[i].pointer = addContent(deployer, bytes(chunks[i]));\\n            slices[i].start = uint32(SSTORE2.DATA_OFFSET);\\n            slices[i].end = uint32(\\n                SSTORE2.DATA_OFFSET + bytes(chunks[i]).length\\n            );\\n            size += slices[i].end - slices[i].start;\\n        }\\n        return File({size: size, slices: slices});\\n    }\\n\\n    /**\\n     * @dev Internal function for preparing a file from its pointers\\n     */\\n    function _fileFromPointers(\\n        address[] memory pointers\\n    ) internal view returns (File memory file) {\\n        uint256 size = 0;\\n        BytecodeSlice[] memory slices = new BytecodeSlice[](pointers.length);\\n        for (uint256 i = 0; i < pointers.length; ++i) {\\n            if (!isValidPointer(pointers[i])) {\\n                revert InvalidPointer(pointers[i]);\\n            }\\n            slices[i].pointer = pointers[i];\\n            slices[i].start = uint32(SSTORE2.DATA_OFFSET);\\n            slices[i].end = uint32(pointers[i].code.length);\\n            size += slices[i].end - slices[i].start;\\n        }\\n        return File({size: size, slices: slices});\\n    }\\n\\n    /**\\n     * @dev Internal function for preparing a file from its slices\\n     */\\n    function _fileFromSlices(\\n        BytecodeSlice[] memory slices\\n    ) internal view returns (File memory file) {\\n        uint256 size = 0;\\n        for (uint256 i = 0; i < slices.length; ++i) {\\n            if (slices[i].end - slices[i].start <= 0) {\\n                revert SliceEmpty(\\n                    slices[i].pointer,\\n                    slices[i].start,\\n                    slices[i].end\\n                );\\n            }\\n            uint32 codeSize = uint32(slices[i].pointer.code.length);\\n            if (slices[i].end > codeSize) {\\n                revert SliceOutOfBounds(\\n                    slices[i].pointer,\\n                    codeSize,\\n                    slices[i].start,\\n                    slices[i].end\\n                );\\n            }\\n            size += slices[i].end - slices[i].start;\\n        }\\n        return File({size: size, slices: slices});\\n    }\\n\\n    /**\\n     * @dev Internal function for creating a file\\n     */\\n    function _createFile(\\n        string memory filename,\\n        File memory file,\\n        bytes memory metadata\\n    ) internal returns (address pointer, File memory) {\\n        if (file.size == 0) {\\n            revert FileEmpty();\\n        }\\n        if (files[filename] != address(0)) {\\n            revert FilenameExists(filename);\\n        }\\n        pointer = addContent(deployer, abi.encode(file));\\n        files[filename] = pointer;\\n        emit FileCreated(filename, pointer, filename, file.size, metadata);\\n        return (pointer, file);\\n    }\\n\\n    /**\\n     * @notice Convenience method for reading files in frontends and indexers where libraries are not accessible.\\n     * @dev This method is intentionally left out of the `IFileStore` interface.\\n     * Contracts should use `File.read()` directly, rather than this method. Otherwise you will incur unnecessary gas for passing around large byte blobs.\\n     * @param filename The name of the file to read\\n     * @return contents The contents of the file\\n     */\\n    function readFile(\\n        string memory filename\\n    ) public view returns (string memory contents) {\\n        return getFile(filename).read();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SSTORE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/SSTORE2.sol)\\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev We skip the first byte as it's a STOP opcode,\\n    /// which ensures the contract can't be called.\\n    uint256 internal constant DATA_OFFSET = 1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Unable to deploy the storage contract.\\n    error DeploymentFailed();\\n\\n    /// @dev The storage contract address is invalid.\\n    error InvalidPointer();\\n\\n    /// @dev Attempt to read outside of the storage contract's bytecode bounds.\\n    error ReadOutOfBounds();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         WRITE LOGIC                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\\n    function write(bytes memory data) internal returns (address pointer) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let originalDataLength := mload(data)\\n\\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\\n            let dataSize := add(originalDataLength, DATA_OFFSET)\\n\\n            /**\\n             * ------------------------------------------------------------------------------+\\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\\n             * ------------------------------------------------------------------------------|\\n             * 61 dataSize | PUSH2 dataSize  | dataSize                |                     |\\n             * 80          | DUP1            | dataSize dataSize       |                     |\\n             * 60 0xa      | PUSH1 0xa       | 0xa dataSize dataSize   |                     |\\n             * 3D          | RETURNDATASIZE  | 0 0xa dataSize dataSize |                     |\\n             * 39          | CODECOPY        | dataSize                | [0..dataSize): code |\\n             * 3D          | RETURNDATASIZE  | 0 dataSize              | [0..dataSize): code |\\n             * F3          | RETURN          |                         | [0..dataSize): code |\\n             * 00          | STOP            |                         |                     |\\n             * ------------------------------------------------------------------------------+\\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\\n             */\\n            mstore(\\n                // Do a out-of-gas revert if `dataSize` is more than 2 bytes.\\n                // The actual EVM limit may be smaller and may change over time.\\n                add(data, gt(dataSize, 0xffff)),\\n                // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\\n                or(0xfd61000080600a3d393df300, shl(0x40, dataSize))\\n            )\\n\\n            // Deploy a new contract with the generated creation code.\\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\\n\\n            // If `pointer` is zero, revert.\\n            if iszero(pointer) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore original length of the variable size `data`.\\n            mstore(data, originalDataLength)\\n        }\\n    }\\n\\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\\n    /// and returns its deterministic address.\\n    function writeDeterministic(bytes memory data, bytes32 salt)\\n        internal\\n        returns (address pointer)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let originalDataLength := mload(data)\\n            let dataSize := add(originalDataLength, DATA_OFFSET)\\n\\n            mstore(\\n                // Do a out-of-gas revert if `dataSize` is more than 2 bytes.\\n                // The actual EVM limit may be smaller and may change over time.\\n                add(data, gt(dataSize, 0xffff)),\\n                // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\\n                or(0xfd61000080600a3d393df300, shl(0x40, dataSize))\\n            )\\n\\n            // Deploy a new contract with the generated creation code.\\n            pointer := create2(0, add(data, 0x15), add(dataSize, 0xa), salt)\\n\\n            // If `pointer` is zero, revert.\\n            if iszero(pointer) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore original length of the variable size `data`.\\n            mstore(data, originalDataLength)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let originalDataLength := mload(data)\\n            let dataSize := add(originalDataLength, DATA_OFFSET)\\n\\n            // Do a out-of-gas revert if `dataSize` is more than 2 bytes.\\n            // The actual EVM limit may be smaller and may change over time.\\n            returndatacopy(returndatasize(), returndatasize(), shr(16, dataSize))\\n\\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\\n\\n            hash := keccak256(add(data, 0x15), add(dataSize, 0xa))\\n\\n            // Restore original length of the variable size `data`.\\n            mstore(data, originalDataLength)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the storage contract for `data`\\n    /// deployed with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(bytes memory data, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        bytes32 hash = initCodeHash(data);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, deployer))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x35, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         READ LOGIC                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns all the `data` from the bytecode of the storage contract at `pointer`.\\n    function read(address pointer) internal view returns (bytes memory data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let pointerCodesize := extcodesize(pointer)\\n            if iszero(pointerCodesize) {\\n                // Store the function selector of `InvalidPointer()`.\\n                mstore(0x00, 0x11052bb4)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Offset all indices by 1 to skip the STOP opcode.\\n            let size := sub(pointerCodesize, DATA_OFFSET)\\n\\n            // Get the pointer to the free memory and allocate\\n            // enough 32-byte words for the data and the length of the data,\\n            // then copy the code to the allocated memory.\\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\\n            data := mload(0x40)\\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\\n            mstore(data, size)\\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\\n            extcodecopy(pointer, add(data, 0x20), DATA_OFFSET, size)\\n        }\\n    }\\n\\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\\n    /// from the byte at `start`, to the end of the data stored.\\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let pointerCodesize := extcodesize(pointer)\\n            if iszero(pointerCodesize) {\\n                // Store the function selector of `InvalidPointer()`.\\n                mstore(0x00, 0x11052bb4)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // If `!(pointer.code.size > start)`, reverts.\\n            // This also handles the case where `start + DATA_OFFSET` overflows.\\n            if iszero(gt(pointerCodesize, start)) {\\n                // Store the function selector of `ReadOutOfBounds()`.\\n                mstore(0x00, 0x84eb0dd1)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            let size := sub(pointerCodesize, add(start, DATA_OFFSET))\\n\\n            // Get the pointer to the free memory and allocate\\n            // enough 32-byte words for the data and the length of the data,\\n            // then copy the code to the allocated memory.\\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\\n            data := mload(0x40)\\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\\n            mstore(data, size)\\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\\n        }\\n    }\\n\\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\\n    /// from the byte at `start`, to the byte at `end` (exclusive) of the data stored.\\n    function read(address pointer, uint256 start, uint256 end)\\n        internal\\n        view\\n        returns (bytes memory data)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let pointerCodesize := extcodesize(pointer)\\n            if iszero(pointerCodesize) {\\n                // Store the function selector of `InvalidPointer()`.\\n                mstore(0x00, 0x11052bb4)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\\n            // This also handles the cases where\\n            // `end + DATA_OFFSET` or `start + DATA_OFFSET` overflows.\\n            if iszero(\\n                and(\\n                    gt(pointerCodesize, end), // Within bounds.\\n                    iszero(gt(start, end)) // Valid range.\\n                )\\n            ) {\\n                // Store the function selector of `ReadOutOfBounds()`.\\n                mstore(0x00, 0x84eb0dd1)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            let size := sub(end, start)\\n\\n            // Get the pointer to the free memory and allocate\\n            // enough 32-byte words for the data and the length of the data,\\n            // then copy the code to the allocated memory.\\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\\n            data := mload(0x40)\\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\\n            mstore(data, size)\\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\nlibrary LibString {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The `length` of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(uint256(-value));\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                // Store the function selector of `HexLengthInsufficient()`.\\n                mstore(0x00, 0x2194895a)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // For performance and bytecode compactness, all indices of the following operations\\n    // are byte (ASCII) offsets, not UTF character offsets.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `smallString` must be null terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 smallString) internal pure returns (string memory result) {\\n        if (smallString == bytes32(0)) return result;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} 1 {} {\\n                n := add(n, 1)\\n                if iszero(byte(n, smallString)) { break } // Scan for '\\\\0'.\\n            }\\n            mstore(result, n)\\n            let o := add(result, 0x20)\\n            mstore(o, smallString)\\n            mstore(add(o, n), 0)\\n            mstore(0x40, add(result, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`. For small strings up to 32 bytes.\\n    /// `b` must be null terminated, or behavior will be undefined.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let x := and(b, add(not(b), 1))\\n            let r := or(shl(8, iszero(b)), shl(7, iszero(iszero(shr(128, x)))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            result := gt(eq(mload(a), sub(32, shr(3, r))), shr(r, xor(b, mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IFileStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\nimport {File, BytecodeSlice} from \\\"./File.sol\\\";\\n\\n/// @title EthFS FileStore interface\\n/// @notice Specifies a content-addressable onchain file store\\ninterface IFileStore {\\n    event Deployed();\\n\\n    /**\\n     * @dev Emitted when a new file is created\\n     * @param indexedFilename The indexed filename for easier finding by filename in logs\\n     * @param pointer The pointer address of the file\\n     * @param filename The name of the file\\n     * @param size The total size of the file\\n     * @param metadata Additional metadata of the file, only emitted for use in offchain indexers\\n     */\\n    event FileCreated(\\n        string indexed indexedFilename,\\n        address indexed pointer,\\n        string filename,\\n        uint256 size,\\n        bytes metadata\\n    );\\n\\n    /**\\n     * @dev Error thrown when a requested file is not found\\n     * @param filename The name of the file requested\\n     */\\n    error FileNotFound(string filename);\\n\\n    /**\\n     * @dev Error thrown when a filename already exists\\n     * @param filename The name of the file attempted to be created\\n     */\\n    error FilenameExists(string filename);\\n\\n    /**\\n     * @dev Error thrown when attempting to create an empty file\\n     */\\n    error FileEmpty();\\n\\n    /**\\n     * @dev Error thrown when a provided slice for a file is empty\\n     * @param pointer The contract address where the bytecode lives\\n     * @param start The byte offset to start the slice (inclusive)\\n     * @param end The byte offset to end the slice (exclusive)\\n     */\\n    error SliceEmpty(address pointer, uint32 start, uint32 end);\\n\\n    /**\\n     * @dev Error thrown when the provided pointer's bytecode does not have the expected STOP opcode prefix from SSTORE2\\n     * @param pointer The SSTORE2 pointer address\\n     */\\n    error InvalidPointer(address pointer);\\n\\n    /**\\n     * @notice Returns the address of the CREATE2 deterministic deployer used by this FileStore\\n     * @return The address of the CREATE2 deterministic deployer\\n     */\\n    function deployer() external view returns (address);\\n\\n    /**\\n     * @notice Retrieves the pointer address of a file by its filename\\n     * @param filename The name of the file\\n     * @return pointer The pointer address of the file\\n     */\\n    function files(\\n        string memory filename\\n    ) external view returns (address pointer);\\n\\n    /**\\n     * @notice Checks if a file exists for a given filename\\n     * @param filename The name of the file to check\\n     * @return True if the file exists, false otherwise\\n     */\\n    function fileExists(string memory filename) external view returns (bool);\\n\\n    /**\\n     * @notice Retrieves the pointer address for a given filename\\n     * @param filename The name of the file\\n     * @return pointer The pointer address of the file\\n     */\\n    function getPointer(\\n        string memory filename\\n    ) external view returns (address pointer);\\n\\n    /**\\n     * @notice Retrieves a file by its filename\\n     * @param filename The name of the file\\n     * @return file The file associated with the filename\\n     */\\n    function getFile(\\n        string memory filename\\n    ) external view returns (File memory file);\\n\\n    /**\\n     * @notice Creates a new file with the provided file contents\\n     * @dev This is a convenience method to simplify small file uploads. It's recommended to use `createFileFromPointers` or `createFileFromSlices` for larger files. This particular method splits `contents` into 24575-byte chunks before storing them via SSTORE2.\\n     * @param filename The name of the new file\\n     * @param contents The contents of the file\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFile(\\n        string memory filename,\\n        string memory contents\\n    ) external returns (address pointer, File memory file);\\n\\n    /**\\n     * @notice Creates a new file with the provided file contents and file metadata\\n     * @dev This is a convenience method to simplify small file uploads. It's recommended to use `createFileFromPointers` or `createFileFromSlices` for larger files. This particular method splits `contents` into 24575-byte chunks before storing them via SSTORE2.\\n     * @param filename The name of the new file\\n     * @param contents The contents of the file\\n     * @param metadata Additional file metadata, usually a JSON-encoded string, for offchain indexers\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFile(\\n        string memory filename,\\n        string memory contents,\\n        bytes memory metadata\\n    ) external returns (address pointer, File memory file);\\n\\n    /**\\n     * @notice Creates a new file where its content is composed of the provided string chunks\\n     * @dev This is a convenience method to simplify small and nuanced file uploads. It's recommended to use `createFileFromPointers` or `createFileFromSlices` for larger files. This particular will store each chunk separately via SSTORE2. For best gas efficiency, each chunk should be as large as possible (up to the contract size limit) and at least 32 bytes.\\n     * @param filename The name of the new file\\n     * @param chunks The string chunks composing the file\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFileFromChunks(\\n        string memory filename,\\n        string[] memory chunks\\n    ) external returns (address pointer, File memory file);\\n\\n    /**\\n     * @notice Creates a new file with the provided string chunks and file metadata\\n     * @dev This is a convenience method to simplify small and nuanced file uploads. It's recommended to use `createFileFromPointers` or `createFileFromSlices` for larger files. This particular will store each chunk separately via SSTORE2. For best gas efficiency, each chunk should be as large as possible (up to the contract size limit) and at least 32 bytes.\\n     * @param filename The name of the new file\\n     * @param chunks The string chunks composing the file\\n     * @param metadata Additional file metadata, usually a JSON-encoded string, for offchain indexers\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFileFromChunks(\\n        string memory filename,\\n        string[] memory chunks,\\n        bytes memory metadata\\n    ) external returns (address pointer, File memory file);\\n\\n    /**\\n     * @notice Creates a new file where its content is composed of the provided SSTORE2 pointers\\n     * @param filename The name of the new file\\n     * @param pointers The SSTORE2 pointers composing the file\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFileFromPointers(\\n        string memory filename,\\n        address[] memory pointers\\n    ) external returns (address pointer, File memory file);\\n\\n    /**\\n     * @notice Creates a new file with the provided SSTORE2 pointers and file metadata\\n     * @param filename The name of the new file\\n     * @param pointers The SSTORE2 pointers composing the file\\n     * @param metadata Additional file metadata, usually a JSON-encoded string, for offchain indexers\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFileFromPointers(\\n        string memory filename,\\n        address[] memory pointers,\\n        bytes memory metadata\\n    ) external returns (address pointer, File memory file);\\n\\n    /**\\n     * @notice Creates a new file where its content is composed of the provided bytecode slices\\n     * @param filename The name of the new file\\n     * @param slices The bytecode slices composing the file\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFileFromSlices(\\n        string memory filename,\\n        BytecodeSlice[] memory slices\\n    ) external returns (address pointer, File memory file);\\n\\n    /**\\n     * @notice Creates a new file with the provided bytecode slices and file metadata\\n     * @param filename The name of the new file\\n     * @param slices The bytecode slices composing the file\\n     * @param metadata Additional file metadata, usually a JSON-encoded string, for offchain indexers\\n     * @return pointer The pointer address of the new file\\n     * @return file The newly created file\\n     */\\n    function createFileFromSlices(\\n        string memory filename,\\n        BytecodeSlice[] memory slices,\\n        bytes memory metadata\\n    ) external returns (address pointer, File memory file);\\n}\\n\"\r\n    },\r\n    \"src/File.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\n/**\\n * @title EthFS File\\n * @notice A representation of an onchain file, composed of slices of contract bytecode and utilities to construct the file contents from those slices.\\n * @dev For best gas efficiency, it's recommended using `File.read()` as close to the output returned by the contract call as possible. Lots of gas is consumed every time a large data blob is passed between functions.\\n */\\n\\n/**\\n * @dev Represents a reference to a slice of bytecode in a contract\\n */\\nstruct BytecodeSlice {\\n    address pointer;\\n    uint32 start;\\n    uint32 end;\\n}\\n\\n/**\\n * @dev Represents a file composed of one or more bytecode slices\\n */\\nstruct File {\\n    // Total length of file contents (sum of all slice sizes). Useful when you want to use DynamicBuffer to build the file contents from the slices.\\n    uint256 size;\\n    BytecodeSlice[] slices;\\n}\\n// extend File struct with read functions\\nusing {read} for File global;\\nusing {readUnchecked} for File global;\\n\\n/**\\n * @dev Error thrown when a slice is out of the bounds of the contract's bytecode\\n */\\nerror SliceOutOfBounds(\\n    address pointer,\\n    uint32 codeSize,\\n    uint32 sliceStart,\\n    uint32 sliceEnd\\n);\\n\\n/**\\n * @notice Reads the contents of a file by concatenating its slices\\n * @param file The file to read\\n * @return contents The concatenated contents of the file\\n */\\nfunction read(File memory file) view returns (string memory contents) {\\n    BytecodeSlice[] memory slices = file.slices;\\n    bytes4 sliceOutOfBoundsSelector = SliceOutOfBounds.selector;\\n\\n    assembly {\\n        let len := mload(slices)\\n        let size := 0x20\\n        contents := mload(0x40)\\n        let slice\\n        let pointer\\n        let start\\n        let end\\n        let codeSize\\n\\n        for {\\n            let i := 0\\n        } lt(i, len) {\\n            i := add(i, 1)\\n        } {\\n            slice := mload(add(slices, add(0x20, mul(i, 0x20))))\\n            pointer := mload(slice)\\n            start := mload(add(slice, 0x20))\\n            end := mload(add(slice, 0x40))\\n\\n            codeSize := extcodesize(pointer)\\n            if gt(end, codeSize) {\\n                mstore(0x00, sliceOutOfBoundsSelector)\\n                mstore(0x04, pointer)\\n                mstore(0x24, codeSize)\\n                mstore(0x44, start)\\n                mstore(0x64, end)\\n                revert(0x00, 0x84)\\n            }\\n\\n            extcodecopy(pointer, add(contents, size), start, sub(end, start))\\n            size := add(size, sub(end, start))\\n        }\\n\\n        // update contents size\\n        mstore(contents, sub(size, 0x20))\\n        // store contents\\n        mstore(0x40, add(contents, and(add(size, 0x1f), not(0x1f))))\\n    }\\n}\\n\\n/**\\n * @notice Reads the contents of a file without reverting on unreadable/invalid slices. Skips any slices that are out of bounds or invalid. Useful if you are composing contract bytecode where a contract can still selfdestruct (which would result in an invalid slice) and want to avoid reverts but still output potentially \\\"corrupted\\\" file contents (due to missing data).\\n * @param file The file to read\\n * @return contents The concatenated contents of the file, skipping invalid slices\\n */\\nfunction readUnchecked(File memory file) view returns (string memory contents) {\\n    BytecodeSlice[] memory slices = file.slices;\\n\\n    assembly {\\n        let len := mload(slices)\\n        let size := 0x20\\n        contents := mload(0x40)\\n        let slice\\n        let pointer\\n        let start\\n        let end\\n        let codeSize\\n\\n        for {\\n            let i := 0\\n        } lt(i, len) {\\n            i := add(i, 1)\\n        } {\\n            slice := mload(add(slices, add(0x20, mul(i, 0x20))))\\n            pointer := mload(slice)\\n            start := mload(add(slice, 0x20))\\n            end := mload(add(slice, 0x40))\\n\\n            codeSize := extcodesize(pointer)\\n            if lt(end, codeSize) {\\n                extcodecopy(\\n                    pointer,\\n                    add(contents, size),\\n                    start,\\n                    sub(end, start)\\n                )\\n                size := add(size, sub(end, start))\\n            }\\n        }\\n\\n        // update contents size\\n        mstore(contents, sub(size, 0x20))\\n        // store contents\\n        mstore(0x40, add(contents, and(add(size, 0x1f), not(0x1f))))\\n    }\\n}\\n\"\r\n    },\r\n    \"src/common.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\nimport {SSTORE2} from \\\"solady/utils/SSTORE2.sol\\\";\\n\\nbytes32 constant SALT = bytes32(\\\"EthFS\\\");\\n\\n/**\\n * @dev Error thrown when the pointer of the content added does not match the one we compute from the content, signaling something weird going on with the deployer\\n * @param expectedPointer The expected address of the content\\n * @param actualPointer The actual address of the content\\n */\\nerror UnexpectedPointer(address expectedPointer, address actualPointer);\\n\\n/**\\n * @dev Converts data into creation code for an SSTORE2 data contract\\n * @param content The bytes content to be converted\\n * @return creationCode The creation code for the data contract\\n */\\nfunction contentToInitCode(\\n    bytes memory content\\n) pure returns (bytes memory creationCode) {\\n    // Use the same strategy as Solady's SSTORE2 to write a data contract, but do this via the deployer for a constant address\\n    // https://github.com/Vectorized/solady/blob/cb801a60f8319a148697b09d19b748d04e3d65c4/src/utils/SSTORE2.sol#L44-L59\\n    // TODO: convert this to assembly?\\n    return\\n        abi.encodePacked(\\n            bytes11(0x61000080600a3d393df300) |\\n                // Overlay content size (plus offset for STOP opcode) into second and third bytes\\n                bytes11(bytes3(uint24(content.length + 1))),\\n            content\\n        );\\n}\\n\\n/**\\n * @dev Predicts the address of a data contract based on its content\\n * @param deployer The deployer's address\\n * @param content The content of the data contract\\n * @return pointer The predicted address of the data contract\\n */\\nfunction getPointer(\\n    address deployer,\\n    bytes memory content\\n) pure returns (address pointer) {\\n    return SSTORE2.predictDeterministicAddress(content, SALT, deployer);\\n}\\n\\n/**\\n * @dev Checks if a pointer (data contract address) already exists\\n * @param pointer The data contract address to check\\n * @return true if the data contract exists, false otherwise\\n */\\nfunction pointerExists(address pointer) view returns (bool) {\\n    return pointer.code.length > 0;\\n}\\n\\n/**\\n * @dev Adds content as a data contract using a deterministic deployer\\n * @param deployer The deployer's address\\n * @param content The content to be added as a data contract\\n * @return pointer The address of the data contract\\n */\\nfunction addContent(\\n    address deployer,\\n    bytes memory content\\n) returns (address pointer) {\\n    address expectedPointer = getPointer(deployer, content);\\n    if (pointerExists(expectedPointer)) {\\n        return expectedPointer;\\n    }\\n\\n    (bool success, bytes memory data) = deployer.call(\\n        abi.encodePacked(SALT, contentToInitCode(content))\\n    );\\n    if (!success) revertWithBytes(data);\\n\\n    pointer = address(uint160(bytes20(data)));\\n    if (pointer != expectedPointer) {\\n        revert UnexpectedPointer(expectedPointer, pointer);\\n    }\\n}\\n\\n/**\\n * @notice Reverts the transaction using the provided raw bytes as the revert reason\\n * @dev Uses assembly to perform the revert operation with the raw bytes\\n * @param reason The raw bytes revert reason\\n */\\nfunction revertWithBytes(bytes memory reason) pure {\\n    assembly {\\n        // reason+32 is a pointer to the error message, mload(reason) is the length of the error message\\n        revert(add(reason, 0x20), mload(reason))\\n    }\\n}\\n\\n/**\\n * @dev Checks if the given address points to a valid SSTORE2 data contract (i.e. starts with STOP opcode)\\n * @param pointer The address to be checked\\n * @return isValid true if the address points to a valid contract (bytecode starts with a STOP opcode), false otherwise\\n */\\nfunction isValidPointer(address pointer) view returns (bool isValid) {\\n    // The assembly below is equivalent to\\n    //\\n    //   pointer.code.length >= 1 && pointer.code[0] == 0x00;\\n    //\\n    // but less gas because it doesn't have to load all the pointer's bytecode\\n\\n    assembly {\\n        // Get the size of the bytecode at pointer\\n        let size := extcodesize(pointer)\\n\\n        // Initialize first byte with INVALID opcode\\n        let firstByte := 0xfe\\n\\n        // If there's at least one byte of code, copy the first byte\\n        if gt(size, 0) {\\n            // Allocate memory for the first byte\\n            let code := mload(0x40)\\n\\n            // Copy the first byte of the code\\n            extcodecopy(pointer, code, 0, 1)\\n\\n            // Retrieve the first byte, ensuring it's a single byte\\n            firstByte := and(mload(sub(code, 31)), 0xff)\\n        }\\n\\n        // Check if the first byte is 0x00 (STOP opcode)\\n        isValid := eq(firstByte, 0x00)\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"@latticexyz/gas-report/=node_modules/@latticexyz/gas-report/src/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_deployer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FileEmpty\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"}],\"name\":\"FileNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"}],\"name\":\"FilenameExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"name\":\"InvalidPointer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"}],\"name\":\"SliceEmpty\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"codeSize\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"sliceStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"sliceEnd\",\"type\":\"uint32\"}],\"name\":\"SliceOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"expectedPointer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"actualPointer\",\"type\":\"address\"}],\"name\":\"UnexpectedPointer\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"indexedFilename\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"FileCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contents\",\"type\":\"string\"}],\"name\":\"createFile\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"}],\"internalType\":\"struct BytecodeSlice[]\",\"name\":\"slices\",\"type\":\"tuple[]\"}],\"internalType\":\"struct File\",\"name\":\"file\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contents\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"createFile\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"}],\"internalType\":\"struct BytecodeSlice[]\",\"name\":\"slices\",\"type\":\"tuple[]\"}],\"internalType\":\"struct File\",\"name\":\"file\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"chunks\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"createFileFromChunks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"}],\"internalType\":\"struct BytecodeSlice[]\",\"name\":\"slices\",\"type\":\"tuple[]\"}],\"internalType\":\"struct File\",\"name\":\"file\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"chunks\",\"type\":\"string[]\"}],\"name\":\"createFileFromChunks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"}],\"internalType\":\"struct BytecodeSlice[]\",\"name\":\"slices\",\"type\":\"tuple[]\"}],\"internalType\":\"struct File\",\"name\":\"file\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"pointers\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"createFileFromPointers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"}],\"internalType\":\"struct BytecodeSlice[]\",\"name\":\"slices\",\"type\":\"tuple[]\"}],\"internalType\":\"struct File\",\"name\":\"file\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"pointers\",\"type\":\"address[]\"}],\"name\":\"createFileFromPointers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"}],\"internalType\":\"struct BytecodeSlice[]\",\"name\":\"slices\",\"type\":\"tuple[]\"}],\"internalType\":\"struct File\",\"name\":\"file\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"}],\"internalType\":\"struct BytecodeSlice[]\",\"name\":\"slices\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"createFileFromSlices\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"}],\"internalType\":\"struct BytecodeSlice[]\",\"name\":\"slices\",\"type\":\"tuple[]\"}],\"internalType\":\"struct File\",\"name\":\"file\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"}],\"internalType\":\"struct BytecodeSlice[]\",\"name\":\"slices\",\"type\":\"tuple[]\"}],\"name\":\"createFileFromSlices\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"}],\"internalType\":\"struct BytecodeSlice[]\",\"name\":\"slices\",\"type\":\"tuple[]\"}],\"internalType\":\"struct File\",\"name\":\"file\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"}],\"name\":\"fileExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"}],\"name\":\"files\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"}],\"name\":\"getFile\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"}],\"internalType\":\"struct BytecodeSlice[]\",\"name\":\"slices\",\"type\":\"tuple[]\"}],\"internalType\":\"struct File\",\"name\":\"file\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"}],\"name\":\"getPointer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filename\",\"type\":\"string\"}],\"name\":\"readFile\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"contents\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FileStore", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000914d7fec6aac8cd542e72bca78b30650d45643d7", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}