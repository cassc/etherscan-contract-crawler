{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/PrivatePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/*\\n *                                   ____\\n *                                /\\\\|    ~~\\\\\\n *                              /'  |   ,-. `\\\\\\n *                             |       | X |  |\\n *                            _|________`-'   |X\\n *                          /'          ~~~~~~~~~,\\n *                        /'             ,_____,/_\\n *                     ,/'        ___,'~~         ;\\n * ~~~~~~~~|~~~~~~~|---          /  X,~~~~~~~~~~~~,\\n *         |       |            |  XX'____________'\\n *         |       |           /' XXX|            ;\\n *         |       |        --x|  XXX,~~~~~~~~~~~~,\\n *         |       |          X|     '____________'\\n *         |   o   |---~~~~\\\\__XX\\\\             |XX\\n *         |       |          XXX`\\\\          /XXXX\\n * ~~~~~~~~'~~~~~~~'               `\\\\xXXXXx/' \\\\XXX\\n *                                  /XXXXXX\\\\\\n *                                /XXXXXXXXXX\\\\\\n *                              /XXXXXX/^\\\\XXXXX\\\\\\n *                             ~~~~~~~~   ~~~~~~~\\n */\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {ERC721, ERC721TokenReceiver} from \\\"solmate/tokens/ERC721.sol\\\";\\nimport {FixedPointMathLib} from \\\"solmate/utils/FixedPointMathLib.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {MerkleProofLib} from \\\"solady/utils/MerkleProofLib.sol\\\";\\nimport {SafeCast} from \\\"openzeppelin/utils/math/SafeCast.sol\\\";\\nimport {IERC2981} from \\\"openzeppelin/interfaces/IERC2981.sol\\\";\\nimport {IRoyaltyRegistry} from \\\"royalty-registry-solidity/IRoyaltyRegistry.sol\\\";\\nimport {IERC3156FlashBorrower} from \\\"openzeppelin/interfaces/IERC3156FlashLender.sol\\\";\\n\\nimport {IStolenNftOracle} from \\\"./interfaces/IStolenNftOracle.sol\\\";\\nimport {Factory} from \\\"./Factory.sol\\\";\\n\\n/// @title Private Pool\\n/// @author out.eth (@outdoteth)\\n/// @notice A private pool is a an NFT AMM controlled by a single owner with concentrated liquidity, custom fee rates,\\n/// stolen NFT filtering, custom NFT weightings, royalty support, and flash loans. You can create a pool and change\\n/// these parameters to your liking. Deposit NFTs and base tokens (or ETH) into the pool to enable trading. Earn fees on\\n/// each trade.\\ncontract PrivatePool is ERC721TokenReceiver {\\n    using SafeTransferLib for address payable;\\n    using SafeTransferLib for address;\\n    using SafeTransferLib for ERC20;\\n\\n    /// @notice Merkle proof input for a sparse merkle multi proof. It can be generated with a library like:\\n    /// https://github.com/OpenZeppelin/merkle-tree#treegetmultiproof\\n    struct MerkleMultiProof {\\n        bytes32[] proof;\\n        bool[] flags;\\n    }\\n\\n    // forgefmt: disable-start\\n    event Initialize(address indexed baseToken, address indexed nft, uint128 virtualBaseTokenReserves, uint128 virtualNftReserves, uint56 changeFee, uint16 feeRate, bytes32 merkleRoot, bool useStolenNftOracle, bool payRoyalties);\\n    event Buy(uint256[] tokenIds, uint256[] tokenWeights, uint256 inputAmount, uint256 feeAmount, uint256 protocolFeeAmount, uint256 royaltyFeeAmount);\\n    event Sell(uint256[] tokenIds, uint256[] tokenWeights, uint256 outputAmount, uint256 feeAmount, uint256 protocolFeeAmount, uint256 royaltyFeeAmount);\\n    event Deposit(uint256[] tokenIds, uint256 baseTokenAmount);\\n    event Withdraw(address indexed nft, uint256[] tokenIds, address token, uint256 amount);\\n    event Change(uint256[] inputTokenIds, uint256[] inputTokenWeights, uint256[] outputTokenIds, uint256[] outputTokenWeights, uint256 feeAmount, uint256 protocolFeeAmount);\\n    event SetVirtualReserves(uint128 virtualBaseTokenReserves, uint128 virtualNftReserves);\\n    event SetMerkleRoot(bytes32 merkleRoot);\\n    event SetFeeRate(uint16 feeRate);\\n    event SetUseStolenNftOracle(bool useStolenNftOracle);\\n    event SetPayRoyalties(bool payRoyalties);\\n    event SetChangeFee(uint56 changeFee);\\n    // forgefmt: disable-end\\n\\n    error AlreadyInitialized();\\n    error Unauthorized();\\n    error InvalidEthAmount();\\n    error InvalidMerkleProof();\\n    error InsufficientInputWeight();\\n    error FeeRateTooHigh();\\n    error NotAvailableForFlashLoan();\\n    error FlashLoanFailed();\\n    error InvalidRoyaltyFee();\\n    error InvalidTarget();\\n    error PrivatePoolNftNotSupported();\\n    error InvalidTokenWeights();\\n    error VirtualReservesNotSet();\\n\\n    /// @notice The address of the base ERC20 token.\\n    address public baseToken;\\n\\n    /// @notice The address of the nft.\\n    address public nft;\\n\\n    /// @notice The change/flash fee to 4 decimals of precision. For example, 0.0025 ETH = 25. 500 USDC = 5_000_000.\\n    uint56 public changeFee;\\n\\n    /// @notice The buy/sell fee rate (in basis points) 200 = 2%\\n    uint16 public feeRate;\\n\\n    /// @notice Whether or not the pool has been initialized.\\n    bool public initialized;\\n\\n    /// @notice Whether or not the pool pays royalties to the NFT creator on each trade.\\n    bool public payRoyalties;\\n\\n    /// @notice Whether or not the pool uses the stolen NFT oracle to check if an NFT is stolen.\\n    bool public useStolenNftOracle;\\n\\n    /// @notice The virtual base token reserves used in the xy=k invariant. Changing this will change the liquidity\\n    /// depth and price of the pool.\\n    uint128 public virtualBaseTokenReserves;\\n\\n    /// @notice The virtual nft reserves used in the xy=k invariant. Changing this will change the liquidity\\n    /// depth and price of the pool.\\n    /// @dev The virtual NFT reserves that a user sets. If it's desired to set the reserves to match 16 NFTs then the\\n    /// virtual reserves should be set to 16e18. If weights are enabled by setting the merkle root to be non-zero then\\n    /// the virtual reserves should be set to the sum of the weights of the NFTs; where floor NFTs all have a weight of\\n    /// 1e18. A rarer NFT may have a weight of 2.3e18 if it's 2.3x more valuable than a floor.\\n    uint128 public virtualNftReserves;\\n\\n    /// @notice The merkle root of all the token weights in the pool. If the merkle root is set to bytes32(0) then all\\n    /// NFTs are set to have a weight of 1e18.\\n    bytes32 public merkleRoot;\\n\\n    /// @notice The NFT oracle to check if an NFT is stolen.\\n    address public immutable stolenNftOracle;\\n\\n    /// @notice The factory contract that created this pool.\\n    address payable public immutable factory;\\n\\n    /// @notice The royalty registry from manifold.xyz.\\n    address public immutable royaltyRegistry;\\n\\n    modifier onlyOwner() virtual {\\n        if (msg.sender != Factory(factory).ownerOf(uint160(address(this)))) {\\n            revert Unauthorized();\\n        }\\n        _;\\n    }\\n\\n    receive() external payable {}\\n\\n    /// @dev This is only called when the base implementation contract is deployed. The following immutable parameters\\n    /// are set:\\n    /// - factory: The address of the factory contract\\n    /// - royaltyRegistry: The address of the royalty registry from manifold.xyz\\n    /// - stolenNftOracle: The address of the stolen NFT oracle\\n    /// These are all stored in immutable storage, which enables all minimal proxy contracts to read them without\\n    /// incurring additional deployment costs and re-initializing them at point of creation in the factory contract.\\n    constructor(address _factory, address _royaltyRegistry, address _stolenNftOracle) {\\n        factory = payable(_factory);\\n        royaltyRegistry = _royaltyRegistry;\\n        stolenNftOracle = _stolenNftOracle;\\n    }\\n\\n    /// @notice Initializes the private pool and sets the initial parameters. Should only be called once by the factory.\\n    /// @param _baseToken The address of the base token\\n    /// @param _nft The address of the NFT\\n    /// @param _virtualBaseTokenReserves The virtual base token reserves\\n    /// @param _virtualNftReserves The virtual NFT reserves\\n    /// @param _feeRate The fee rate (in basis points) 200 = 2%\\n    /// @param _merkleRoot The merkle root\\n    /// @param _useStolenNftOracle Whether or not the pool uses the stolen NFT oracle to check if an NFT is stolen\\n    function initialize(\\n        address _baseToken,\\n        address _nft,\\n        uint128 _virtualBaseTokenReserves,\\n        uint128 _virtualNftReserves,\\n        uint56 _changeFee,\\n        uint16 _feeRate,\\n        bytes32 _merkleRoot,\\n        bool _useStolenNftOracle,\\n        bool _payRoyalties\\n    ) public {\\n        // prevent duplicate initialization\\n        if (initialized) revert AlreadyInitialized();\\n\\n        // check that the fee rate is less than 50%\\n        if (_feeRate > 5_000) revert FeeRateTooHigh();\\n\\n        // check that the nft is not a private pool NFT\\n        if (_nft == factory) revert PrivatePoolNftNotSupported();\\n\\n        // set the state variables\\n        baseToken = _baseToken;\\n        nft = _nft;\\n        virtualBaseTokenReserves = _virtualBaseTokenReserves;\\n        virtualNftReserves = _virtualNftReserves;\\n        changeFee = _changeFee;\\n        feeRate = _feeRate;\\n        merkleRoot = _merkleRoot;\\n        useStolenNftOracle = _useStolenNftOracle;\\n        payRoyalties = _payRoyalties;\\n\\n        // mark the pool as initialized\\n        initialized = true;\\n\\n        // emit the event\\n        emit Initialize(\\n            _baseToken,\\n            _nft,\\n            _virtualBaseTokenReserves,\\n            _virtualNftReserves,\\n            _changeFee,\\n            _feeRate,\\n            _merkleRoot,\\n            _useStolenNftOracle,\\n            _payRoyalties\\n        );\\n    }\\n\\n    /// @notice Buys NFTs from the pool, paying with base tokens from the caller. Then transfers the bought NFTs to the\\n    /// caller. The net cost depends on the current price, fee rate and assigned NFT weights.\\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\\n    /// will check the max input amount and revert if the slippage is too high.\\n    /// @param tokenIds The token IDs of the NFTs to buy.\\n    /// @param tokenWeights The weights of the NFTs to buy.\\n    /// @param proof The merkle proof for the weights of each NFT to buy.\\n    /// @return netInputAmount The amount of base tokens spent inclusive of fees.\\n    /// @return feeAmount The amount of base tokens spent on fees.\\n    /// @return protocolFeeAmount The amount of base tokens spent on protocol fees.\\n    function buy(uint256[] calldata tokenIds, uint256[] calldata tokenWeights, MerkleMultiProof calldata proof)\\n        public\\n        payable\\n        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\\n    {\\n        // ~~~ Checks ~~~ //\\n\\n        // check that virtual reserves are set\\n        if (virtualBaseTokenReserves == 0 || virtualNftReserves == 0) revert VirtualReservesNotSet();\\n\\n        // calculate the sum of weights of the NFTs to buy\\n        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\\n\\n        // calculate the required net input amount and fee amount\\n        (netInputAmount, feeAmount, protocolFeeAmount) = buyQuote(weightSum);\\n\\n        // check that the caller sent 0 ETH if the base token is not ETH\\n        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\\n\\n        // ~~~ Effects ~~~ //\\n\\n        // update the virtual reserves\\n        virtualBaseTokenReserves += SafeCast.toUint128(netInputAmount - feeAmount - protocolFeeAmount);\\n        virtualNftReserves -= SafeCast.toUint128(weightSum);\\n\\n        // ~~~ Interactions ~~~ //\\n\\n        if (baseToken != address(0)) {\\n            // transfer the base token from the caller to the contract\\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), netInputAmount);\\n\\n            // if the protocol fee is set then pay the protocol fee\\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(factory, protocolFeeAmount);\\n        }\\n\\n        // calculate the sale price (assume it's the same for each NFT even if weights differ)\\n        uint256 salePrice = (netInputAmount - feeAmount - protocolFeeAmount) / tokenIds.length;\\n        uint256 royaltyFeeAmount = 0;\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            // transfer the NFT to the caller\\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\\n\\n            if (payRoyalties) {\\n                // get the royalty fee for the NFT\\n                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\\n\\n                if (royaltyFee > 0 && recipient != address(0)) {\\n                    // add the royalty fee amount to the net input amount\\n                    netInputAmount += royaltyFee;\\n\\n                    // transfer the royalties to the recipient\\n                    if (baseToken != address(0)) {\\n                        ERC20(baseToken).safeTransferFrom(msg.sender, recipient, royaltyFee);\\n                    } else {\\n                        recipient.safeTransferETH(royaltyFee);\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (baseToken == address(0)) {\\n            // check that the caller sent enough ETH to cover the net required input\\n            if (msg.value < netInputAmount) revert InvalidEthAmount();\\n\\n            // if the protocol fee is set then pay the protocol fee\\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\\n\\n            // refund any excess ETH to the caller\\n            if (msg.value > netInputAmount) msg.sender.safeTransferETH(msg.value - netInputAmount);\\n        }\\n\\n        // emit the buy event\\n        emit Buy(tokenIds, tokenWeights, netInputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);\\n    }\\n\\n    /// @notice Sells NFTs into the pool and transfers base tokens to the caller. NFTs are transferred from the caller\\n    /// to the pool. The net sale amount depends on the current price, fee rate and assigned NFT weights.\\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\\n    /// will check the min output amount and revert if the slippage is too high.\\n    /// @param tokenIds The token IDs of the NFTs to sell.\\n    /// @param tokenWeights The weights of the NFTs to sell.\\n    /// @param proof The merkle proof for the weights of each NFT to sell.\\n    /// @param stolenNftProofs The proofs that show each NFT is not stolen.\\n    /// @return netOutputAmount The amount of base tokens received inclusive of fees.\\n    /// @return feeAmount The amount of base tokens to pay in fees.\\n    /// @return protocolFeeAmount The amount of base tokens to pay in protocol fees.\\n    function sell(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata tokenWeights,\\n        MerkleMultiProof calldata proof,\\n        IStolenNftOracle.Message[] memory stolenNftProofs // put in memory to avoid stack too deep error\\n    ) public returns (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount) {\\n        // ~~~ Checks ~~~ //\\n\\n        // check that virtual reserves are set\\n        if (virtualBaseTokenReserves == 0 || virtualNftReserves == 0) revert VirtualReservesNotSet();\\n\\n        // calculate the sum of weights of the NFTs to sell\\n        uint256 weightSum = sumWeightsAndValidateProof(tokenIds, tokenWeights, proof);\\n\\n        // calculate the net output amount and fee amount\\n        (netOutputAmount, feeAmount, protocolFeeAmount) = sellQuote(weightSum);\\n\\n        //  check the nfts are not stolen\\n        if (useStolenNftOracle) {\\n            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, tokenIds, stolenNftProofs);\\n        }\\n\\n        // ~~~ Effects ~~~ //\\n\\n        // update the virtual reserves\\n        virtualBaseTokenReserves -= SafeCast.toUint128(netOutputAmount + protocolFeeAmount + feeAmount);\\n        virtualNftReserves += SafeCast.toUint128(weightSum);\\n\\n        // ~~~ Interactions ~~~ //\\n\\n        uint256 royaltyFeeAmount = 0;\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            // transfer each nft from the caller\\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\\n\\n            if (payRoyalties) {\\n                // calculate the sale price (assume it's the same for each NFT even if weights differ)\\n                uint256 salePrice = (netOutputAmount + feeAmount + protocolFeeAmount) / tokenIds.length;\\n\\n                // get the royalty fee for the NFT\\n                (uint256 royaltyFee, address recipient) = _getRoyalty(tokenIds[i], salePrice);\\n\\n                // transfer the royalty fee to the recipient if it's greater than 0\\n                if (royaltyFee > 0 && recipient != address(0)) {\\n                    // tally the royalty fee amount\\n                    royaltyFeeAmount += royaltyFee;\\n\\n                    if (baseToken != address(0)) {\\n                        ERC20(baseToken).safeTransfer(recipient, royaltyFee);\\n                    } else {\\n                        recipient.safeTransferETH(royaltyFee);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // subtract the royalty fee amount from the net output amount\\n        netOutputAmount -= royaltyFeeAmount;\\n\\n        if (baseToken == address(0)) {\\n            // transfer ETH to the caller\\n            msg.sender.safeTransferETH(netOutputAmount);\\n\\n            // if the protocol fee is set then pay the protocol fee\\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\\n        } else {\\n            // transfer base tokens to the caller\\n            ERC20(baseToken).transfer(msg.sender, netOutputAmount);\\n\\n            // if the protocol fee is set then pay the protocol fee\\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransfer(factory, protocolFeeAmount);\\n        }\\n\\n        // emit the sell event\\n        emit Sell(tokenIds, tokenWeights, netOutputAmount, feeAmount, protocolFeeAmount, royaltyFeeAmount);\\n    }\\n\\n    /// @notice Changes a set of NFTs that the caller owns for another set of NFTs in the pool. The caller must approve\\n    /// the pool to transfer the NFTs. The sum of the caller's NFT weights must be greater than or equal to the sum of\\n    /// the output pool NFTs weights. The caller must also pay a fee depending the net input weight and change fee\\n    /// amount.\\n    /// @param inputTokenIds The token IDs of the NFTs to change.\\n    /// @param inputTokenWeights The weights of the NFTs to change.\\n    /// @param inputProof The merkle proof for the weights of each NFT to change.\\n    /// @param stolenNftProofs The proofs that show each input NFT is not stolen.\\n    /// @param outputTokenIds The token IDs of the NFTs to receive.\\n    /// @param outputTokenWeights The weights of the NFTs to receive.\\n    /// @param outputProof The merkle proof for the weights of each NFT to receive.\\n    /// @return feeAmount The amount of base tokens to pay in fees.\\n    /// @return protocolFeeAmount The amount of base tokens to pay in protocol fees.\\n    function change(\\n        uint256[] memory inputTokenIds,\\n        uint256[] memory inputTokenWeights,\\n        MerkleMultiProof memory inputProof,\\n        IStolenNftOracle.Message[] memory stolenNftProofs,\\n        uint256[] memory outputTokenIds,\\n        uint256[] memory outputTokenWeights,\\n        MerkleMultiProof memory outputProof\\n    ) public payable returns (uint256 feeAmount, uint256 protocolFeeAmount) {\\n        // ~~~ Checks ~~~ //\\n\\n        // check that the caller sent 0 ETH if base token is not ETH\\n        if (baseToken != address(0) && msg.value > 0) revert InvalidEthAmount();\\n\\n        // check that NFTs are not stolen\\n        if (useStolenNftOracle) {\\n            IStolenNftOracle(stolenNftOracle).validateTokensAreNotStolen(nft, inputTokenIds, stolenNftProofs);\\n        }\\n\\n        // fix stack too deep\\n        {\\n            // calculate the sum of weights for the input nfts\\n            uint256 inputWeightSum = sumWeightsAndValidateProof(inputTokenIds, inputTokenWeights, inputProof);\\n\\n            // calculate the sum of weights for the output nfts\\n            uint256 outputWeightSum = sumWeightsAndValidateProof(outputTokenIds, outputTokenWeights, outputProof);\\n\\n            // check that the input weights are greater than or equal to the output weights\\n            if (inputWeightSum < outputWeightSum) revert InsufficientInputWeight();\\n\\n            // calculate the fee amount\\n            (feeAmount, protocolFeeAmount) = changeFeeQuote(inputWeightSum);\\n        }\\n\\n        // ~~~ Interactions ~~~ //\\n\\n        if (baseToken != address(0)) {\\n            // transfer the fee amount of base tokens from the caller\\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), feeAmount);\\n\\n            // if the protocol fee is non-zero then transfer the protocol fee to the factory\\n            if (protocolFeeAmount > 0) ERC20(baseToken).safeTransferFrom(msg.sender, factory, protocolFeeAmount);\\n        } else {\\n            // check that the caller sent enough ETH to cover the fee amount and protocol fee\\n            if (msg.value < feeAmount + protocolFeeAmount) revert InvalidEthAmount();\\n\\n            // if the protocol fee is non-zero then transfer the protocol fee to the factory\\n            if (protocolFeeAmount > 0) factory.safeTransferETH(protocolFeeAmount);\\n\\n            // refund any excess ETH to the caller\\n            if (msg.value > feeAmount + protocolFeeAmount) {\\n                msg.sender.safeTransferETH(msg.value - feeAmount - protocolFeeAmount);\\n            }\\n        }\\n\\n        // transfer the input nfts from the caller\\n        for (uint256 i = 0; i < inputTokenIds.length; i++) {\\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), inputTokenIds[i]);\\n        }\\n\\n        // transfer the output nfts to the caller\\n        for (uint256 i = 0; i < outputTokenIds.length; i++) {\\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, outputTokenIds[i]);\\n        }\\n\\n        // emit the change event\\n        emit Change(inputTokenIds, inputTokenWeights, outputTokenIds, outputTokenWeights, feeAmount, protocolFeeAmount);\\n    }\\n\\n    /// @notice Executes a transaction from the pool account to a target contract. The caller must be the owner of the\\n    /// pool. This allows for use cases such as claiming airdrops.\\n    /// @param target The address of the target contract.\\n    /// @param data The data to send to the target contract.\\n    /// @return returnData The return data of the transaction.\\n    function execute(address target, bytes memory data) public payable onlyOwner returns (bytes memory) {\\n        if (target == address(baseToken) || target == address(nft)) revert InvalidTarget();\\n\\n        // call the target with the value and data\\n        (bool success, bytes memory returnData) = target.call{value: msg.value}(data);\\n\\n        // if the call succeeded return the return data\\n        if (success) return returnData;\\n\\n        // if we got an error bubble up the error message\\n        if (returnData.length > 0) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        }\\n\\n        revert();\\n    }\\n\\n    /// @notice Deposits base tokens and NFTs into the pool. The caller must approve the pool to transfer their NFTs and\\n    /// base tokens.\\n    /// @dev DO NOT call this function directly unless you know what you are doing. Instead, use a wrapper contract that\\n    /// will check the current price is within the desired bounds.\\n    /// @param tokenIds The token IDs of the NFTs to deposit.\\n    /// @param baseTokenAmount The amount of base tokens to deposit.\\n    function deposit(uint256[] calldata tokenIds, uint256 baseTokenAmount) public payable {\\n        // ~~~ Checks ~~~ //\\n\\n        // ensure the caller sent a valid amount of ETH if base token is ETH or that the caller sent 0 ETH if base token\\n        // is not ETH\\n        if ((baseToken == address(0) && msg.value != baseTokenAmount) || (msg.value > 0 && baseToken != address(0))) {\\n            revert InvalidEthAmount();\\n        }\\n\\n        // ~~~ Interactions ~~~ //\\n\\n        // transfer the nfts from the caller\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\\n        }\\n\\n        if (baseToken != address(0)) {\\n            // transfer the base tokens from the caller\\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\\n        }\\n\\n        // emit the deposit event\\n        emit Deposit(tokenIds, baseTokenAmount);\\n    }\\n\\n    /// @notice Withdraws NFTs and tokens from the pool. Can only be called by the owner of the pool.\\n    /// @param _nft The address of the NFT.\\n    /// @param tokenIds The token IDs of the NFTs to withdraw.\\n    /// @param token The address of the token to withdraw.\\n    /// @param tokenAmount The amount of tokens to withdraw.\\n    function withdraw(address _nft, uint256[] calldata tokenIds, address token, uint256 tokenAmount) public onlyOwner {\\n        // ~~~ Interactions ~~~ //\\n\\n        // transfer the nfts to the caller\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            ERC721(_nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\\n        }\\n\\n        if (token == address(0)) {\\n            // transfer the ETH to the caller\\n            msg.sender.safeTransferETH(tokenAmount);\\n        } else {\\n            // transfer the tokens to the caller\\n            ERC20(token).transfer(msg.sender, tokenAmount);\\n        }\\n\\n        // emit the withdraw event\\n        emit Withdraw(_nft, tokenIds, token, tokenAmount);\\n    }\\n\\n    /// @notice Sets the virtual base token reserves and virtual NFT reserves. Can only be called by the owner of the\\n    /// pool. These parameters affect the price and liquidity depth of the pool.\\n    /// @param newVirtualBaseTokenReserves The new virtual base token reserves.\\n    /// @param newVirtualNftReserves The new virtual NFT reserves.\\n    function setVirtualReserves(uint128 newVirtualBaseTokenReserves, uint128 newVirtualNftReserves) public onlyOwner {\\n        // set the virtual base token reserves and virtual nft reserves\\n        virtualBaseTokenReserves = newVirtualBaseTokenReserves;\\n        virtualNftReserves = newVirtualNftReserves;\\n\\n        // emit the set virtual reserves event\\n        emit SetVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves);\\n    }\\n\\n    /// @notice Sets the merkle root. Can only be called by the owner of the pool. The merkle root is used to validate\\n    /// the NFT weights.\\n    /// @param newMerkleRoot The new merkle root.\\n    function setMerkleRoot(bytes32 newMerkleRoot) public onlyOwner {\\n        // set the merkle root\\n        merkleRoot = newMerkleRoot;\\n\\n        // emit the set merkle root event\\n        emit SetMerkleRoot(newMerkleRoot);\\n    }\\n\\n    /// @notice Sets the fee rate. Can only be called by the owner of the pool. The fee rate is used to calculate the\\n    /// fee amount when swapping NFTs. The fee rate is in basis points (1/100th of a percent). For example,\\n    /// 10_000 == 100%, 200 == 2%, 1 == 0.01%.\\n    /// @param newFeeRate The new fee rate (in basis points)\\n    function setFeeRate(uint16 newFeeRate) public onlyOwner {\\n        // check that the fee rate is less than or equal to 50%\\n        if (newFeeRate > 5_000) revert FeeRateTooHigh();\\n\\n        // set the fee rate\\n        feeRate = newFeeRate;\\n\\n        // emit the set fee rate event\\n        emit SetFeeRate(newFeeRate);\\n    }\\n\\n    /// @notice Sets the whether or not to use the stolen NFT oracle. Can only be called by the owner of the pool. The\\n    /// stolen NFT oracle is used to check if an NFT is stolen.\\n    /// @param newUseStolenNftOracle The new use stolen NFT oracle flag.\\n    function setUseStolenNftOracle(bool newUseStolenNftOracle) public onlyOwner {\\n        // set the use stolen NFT oracle flag\\n        useStolenNftOracle = newUseStolenNftOracle;\\n\\n        // emit the set use stolen NFT oracle event\\n        emit SetUseStolenNftOracle(newUseStolenNftOracle);\\n    }\\n\\n    /// @notice Sets the pay royalties flag. Can only be called by the owner of the pool. If royalties are enabled then\\n    /// the pool will pay royalties when buying or selling NFTs.\\n    /// @param newPayRoyalties The new pay royalties flag.\\n    function setPayRoyalties(bool newPayRoyalties) public onlyOwner {\\n        // set the pay royalties flag\\n        payRoyalties = newPayRoyalties;\\n\\n        // emit the set pay royalties event\\n        emit SetPayRoyalties(newPayRoyalties);\\n    }\\n\\n    /// @notice Sets the change fee. Can only be called by the owner. The change fee is used to calculate the\\n    /// fixed fee amount when changing or flashloaning NFTs. The fee rate is to 4 decimals of accuracy. For\\n    /// example, 0.0025 ETH = 25. 500 USDC = 5_000_000.\\n    /// @param _newChangeFee The new pay change fee.\\n    function setChangeFee(uint56 _newChangeFee) public onlyOwner {\\n        // set the pay royalties flag\\n        changeFee = _newChangeFee;\\n\\n        // emit the set pay royalties event\\n        emit SetChangeFee(changeFee);\\n    }\\n\\n    /// @notice Updates all parameter settings in one go.\\n    /// @param newVirtualBaseTokenReserves The new virtual base token reserves.\\n    /// @param newVirtualNftReserves The new virtual NFT reserves.\\n    /// @param newMerkleRoot The new merkle root.\\n    /// @param newFeeRate The new fee rate (in basis points)\\n    /// @param newUseStolenNftOracle The new use stolen NFT oracle flag.\\n    /// @param newPayRoyalties The new pay royalties flag.\\n    /// @param newChangeFee The new change fee.\\n    function setAllParameters(\\n        uint128 newVirtualBaseTokenReserves,\\n        uint128 newVirtualNftReserves,\\n        bytes32 newMerkleRoot,\\n        uint16 newFeeRate,\\n        bool newUseStolenNftOracle,\\n        bool newPayRoyalties,\\n        uint56 newChangeFee\\n    ) public {\\n        setVirtualReserves(newVirtualBaseTokenReserves, newVirtualNftReserves);\\n        setMerkleRoot(newMerkleRoot);\\n        setFeeRate(newFeeRate);\\n        setUseStolenNftOracle(newUseStolenNftOracle);\\n        setPayRoyalties(newPayRoyalties);\\n        setChangeFee(newChangeFee);\\n    }\\n\\n    /// @notice Executes a flash loan.\\n    /// @param receiver The receiver of the flash loan.\\n    /// @param token The address of the NFT contract.\\n    /// @param tokenId The ID of the NFT.\\n    /// @param data The data to pass to the receiver.\\n    /// @return success Whether or not the flash loan was successful.\\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 tokenId, bytes calldata data)\\n        external\\n        payable\\n        returns (bool)\\n    {\\n        // check that the NFT is available for a flash loan\\n        if (!availableForFlashLoan(token, tokenId)) revert NotAvailableForFlashLoan();\\n\\n        // calculate the fee\\n        (uint256 flashFee, uint256 protocolFee) = flashFeeAndProtocolFee();\\n        uint256 fee = flashFee + protocolFee;\\n\\n        // if base token is ETH then check that caller sent enough for the fee or if base token is not ETH\\n        // then check that the user sent 0 ETH\\n        if ((baseToken == address(0) && msg.value < fee) || (baseToken != address(0) && msg.value > 0)) {\\n            revert InvalidEthAmount();\\n        }\\n\\n        // transfer the NFT to the borrower\\n        ERC721(token).safeTransferFrom(address(this), address(receiver), tokenId);\\n\\n        // call the borrower\\n        bool success =\\n            receiver.onFlashLoan(msg.sender, token, tokenId, fee, data) == keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n\\n        // check that flashloan was successful\\n        if (!success) revert FlashLoanFailed();\\n\\n        // transfer the NFT from the borrower\\n        ERC721(token).safeTransferFrom(address(receiver), address(this), tokenId);\\n\\n        if (baseToken != address(0)) {\\n            // transfer the fee from the borrower\\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), flashFee);\\n\\n            // transfer the protocol fee to the factory\\n            ERC20(baseToken).safeTransferFrom(msg.sender, factory, protocolFee);\\n        } else {\\n            // transfer the protocol fee to the factory\\n            factory.safeTransferETH(protocolFee);\\n\\n            // refund the excess ETH to the borrower\\n            if (msg.value > fee) msg.sender.safeTransferETH(msg.value - fee);\\n        }\\n\\n        return success;\\n    }\\n\\n    /// @notice Sums the weights of each NFT and validates that the weights are correct by verifying the merkle proof.\\n    /// @param tokenIds The token IDs of the NFTs to sum the weights for.\\n    /// @param tokenWeights The weights of each NFT in the token IDs array.\\n    /// @param proof The merkle proof for the weights of each NFT.\\n    /// @return sum The sum of the weights of each NFT.\\n    function sumWeightsAndValidateProof(\\n        uint256[] memory tokenIds,\\n        uint256[] memory tokenWeights,\\n        MerkleMultiProof memory proof\\n    ) public view returns (uint256) {\\n        if (merkleRoot == bytes32(0)) {\\n            // if the merkle root is not set then check that the token weights array is empty\\n            if (tokenWeights.length > 0) revert InvalidTokenWeights();\\n\\n            // if the merkle root is not set then set the weight of each nft to be 1e18\\n            return tokenIds.length * 1e18;\\n        }\\n\\n        uint256 sum;\\n        bytes32[] memory leafs = new bytes32[](tokenIds.length);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            // create the leaf for the merkle proof\\n            leafs[i] = keccak256(bytes.concat(keccak256(abi.encode(tokenIds[i], tokenWeights[i]))));\\n\\n            // sum each token weight\\n            sum += tokenWeights[i];\\n        }\\n\\n        // validate that the weights are valid against the merkle proof\\n        if (!MerkleProofLib.verifyMultiProof(proof.proof, merkleRoot, leafs, proof.flags)) {\\n            revert InvalidMerkleProof();\\n        }\\n\\n        return sum;\\n    }\\n\\n    /// @notice Returns the required input of buying a given amount of NFTs inclusive of the fee which is dependent on\\n    /// the currently set fee rate.\\n    /// @param outputAmount The amount of NFTs to buy multiplied by 1e18.\\n    /// @return netInputAmount The required input amount of base tokens inclusive of the fee.\\n    /// @return feeAmount The fee amount.\\n    /// @return protocolFeeAmount The protocol fee amount.\\n    function buyQuote(uint256 outputAmount)\\n        public\\n        view\\n        returns (uint256 netInputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\\n    {\\n        // calculate the input amount based on xy=k invariant and round up by 1 wei\\n        uint256 inputAmount =\\n            FixedPointMathLib.mulDivUp(outputAmount, virtualBaseTokenReserves, (virtualNftReserves - outputAmount));\\n\\n        protocolFeeAmount = inputAmount * Factory(factory).protocolFeeRate() / 10_000;\\n        feeAmount = inputAmount * feeRate / 10_000;\\n        netInputAmount = inputAmount + feeAmount + protocolFeeAmount;\\n    }\\n\\n    /// @notice Returns the output amount of selling a given amount of NFTs inclusive of the fee which is dependent on\\n    /// the currently set fee rate.\\n    /// @param inputAmount The amount of NFTs to sell multiplied by 1e18.\\n    /// @return netOutputAmount The output amount of base tokens inclusive of the fee.\\n    /// @return feeAmount The fee amount.\\n    /// @return protocolFeeAmount The protocol fee amount.\\n    function sellQuote(uint256 inputAmount)\\n        public\\n        view\\n        returns (uint256 netOutputAmount, uint256 feeAmount, uint256 protocolFeeAmount)\\n    {\\n        // calculate the output amount based on xy=k invariant\\n        uint256 outputAmount = inputAmount * virtualBaseTokenReserves / (virtualNftReserves + inputAmount);\\n\\n        protocolFeeAmount = outputAmount * Factory(factory).protocolFeeRate() / 10_000;\\n        feeAmount = outputAmount * feeRate / 10_000;\\n        netOutputAmount = outputAmount - feeAmount - protocolFeeAmount;\\n    }\\n\\n    /// @notice Returns the fee required to change a given amount of NFTs. The fee is based on the current changeFee\\n    /// (which contains 4 decimals of precision) multiplied by some exponent depending on the base token decimals.\\n    /// @param inputAmount The amount of NFTs to change multiplied by 1e18.\\n    /// @return feeAmount The fee amount.\\n    /// @return protocolFeeAmount The protocol fee amount.\\n    function changeFeeQuote(uint256 inputAmount) public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\\n        // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\\n        uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4;\\n        uint256 feePerNft = changeFee * 10 ** exponent;\\n\\n        feeAmount = inputAmount * feePerNft / 1e18;\\n        protocolFeeAmount = feeAmount * Factory(factory).protocolChangeFeeRate() / 10_000;\\n    }\\n\\n    /// @notice Returns the price of the pool to 18 decimals of accuracy.\\n    /// @return price The price of the pool.\\n    function price() public view returns (uint256) {\\n        // ensure that the exponent is always to 18 decimals of accuracy\\n        uint256 exponent = baseToken == address(0) ? 18 : (36 - ERC20(baseToken).decimals());\\n        return (virtualBaseTokenReserves * 10 ** exponent) / virtualNftReserves;\\n    }\\n\\n    /// @notice Returns the fee and protocol fee required to flash swap a given NFT.\\n    /// @return feeAmount The fee amount.\\n    /// @return protocolFeeAmount The protocol fee amount.\\n    function flashFeeAndProtocolFee() public view returns (uint256 feeAmount, uint256 protocolFeeAmount) {\\n        // multiply the changeFee to get the fee per NFT (4 decimals of accuracy)\\n        uint256 exponent = baseToken == address(0) ? 18 - 4 : ERC20(baseToken).decimals() - 4;\\n        feeAmount = changeFee * 10 ** exponent;\\n        protocolFeeAmount = feeAmount * Factory(factory).protocolChangeFeeRate() / 10_000;\\n    }\\n\\n    /// @notice Returns the fee required to flash swap a given NFT.\\n    /// @return feeAmount The fee amount.\\n    function flashFee(address, uint256) public view returns (uint256) {\\n        (uint256 feeAmount, uint256 protocolFeeAmount) = flashFeeAndProtocolFee();\\n        return feeAmount + protocolFeeAmount;\\n    }\\n\\n    /// @notice Returns the token that is used to pay the flash fee.\\n    function flashFeeToken() public view returns (address) {\\n        return baseToken;\\n    }\\n\\n    /// @notice Returns whether or not an NFT is available for a flash loan.\\n    /// @param token The address of the NFT contract.\\n    /// @param tokenId The ID of the NFT.\\n    /// @return available Whether or not the NFT is available for a flash loan.\\n    function availableForFlashLoan(address token, uint256 tokenId) public view returns (bool) {\\n        // return if the NFT is owned by this contract\\n        try ERC721(token).ownerOf(tokenId) returns (address result) {\\n            return result == address(this);\\n        } catch {\\n            return false;\\n        }\\n    }\\n\\n    /// @notice Gets the royalty and recipient for a given NFT and sale price. Looks up the royalty info from the\\n    /// manifold registry.\\n    /// @param tokenId The token ID of the NFT.\\n    /// @param salePrice The sale price of the NFT.\\n    /// @return royaltyFee The royalty fee to pay.\\n    /// @return recipient The address to pay the royalty fee to.\\n    function _getRoyalty(uint256 tokenId, uint256 salePrice)\\n        internal\\n        view\\n        returns (uint256 royaltyFee, address recipient)\\n    {\\n        // get the royalty lookup address\\n        address lookupAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(nft);\\n\\n        if (IERC2981(lookupAddress).supportsInterface(type(IERC2981).interfaceId)) {\\n            // get the royalty fee from the registry\\n            (recipient, royaltyFee) = IERC2981(lookupAddress).royaltyInfo(tokenId, salePrice);\\n\\n            // revert if the royalty fee is greater than the sale price\\n            if (royaltyFee > salePrice) revert InvalidRoyaltyFee();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/MerkleProofLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)\\nlibrary MerkleProofLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*            MERKLE PROOF VERIFICATION OPERATIONS            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\\n        internal\\n        pure\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(proof) {\\n                // Initialize `offset` to the offset of `proof` elements in memory.\\n                let offset := add(proof, 0x20)\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                let end := add(offset, shl(5, mload(proof)))\\n                // Iterate over proof elements to compute root hash.\\n                for {} 1 {} {\\n                    // Slot of `leaf` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(leaf, mload(offset)))\\n                    // Store elements to hash contiguously in scratch space.\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\n                    mstore(scratch, leaf)\\n                    mstore(xor(scratch, 0x20), mload(offset))\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\n                    leaf := keccak256(0x00, 0x40)\\n                    offset := add(offset, 0x20)\\n                    if iszero(lt(offset, end)) { break }\\n                }\\n            }\\n            isValid := eq(leaf, root)\\n        }\\n    }\\n\\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\\n        internal\\n        pure\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if proof.length {\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                let end := add(proof.offset, shl(5, proof.length))\\n                // Initialize `offset` to the offset of `proof` in the calldata.\\n                let offset := proof.offset\\n                // Iterate over proof elements to compute root hash.\\n                for {} 1 {} {\\n                    // Slot of `leaf` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\\n                    // Store elements to hash contiguously in scratch space.\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\n                    mstore(scratch, leaf)\\n                    mstore(xor(scratch, 0x20), calldataload(offset))\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\n                    leaf := keccak256(0x00, 0x40)\\n                    offset := add(offset, 0x20)\\n                    if iszero(lt(offset, end)) { break }\\n                }\\n            }\\n            isValid := eq(leaf, root)\\n        }\\n    }\\n\\n    /// @dev Returns whether all `leafs` exist in the Merkle tree with `root`,\\n    /// given `proof` and `flags`.\\n    function verifyMultiProof(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32[] memory leafs,\\n        bool[] memory flags\\n    ) internal pure returns (bool isValid) {\\n        // Rebuilds the root by consuming and producing values on a queue.\\n        // The queue starts with the `leafs` array, and goes into a `hashes` array.\\n        // After the process, the last element on the queue is verified\\n        // to be equal to the `root`.\\n        //\\n        // The `flags` array denotes whether the sibling\\n        // should be popped from the queue (`flag == true`), or\\n        // should be popped from the `proof` (`flag == false`).\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cache the lengths of the arrays.\\n            let leafsLength := mload(leafs)\\n            let proofLength := mload(proof)\\n            let flagsLength := mload(flags)\\n\\n            // Advance the pointers of the arrays to point to the data.\\n            leafs := add(0x20, leafs)\\n            proof := add(0x20, proof)\\n            flags := add(0x20, flags)\\n\\n            // If the number of flags is correct.\\n            for {} eq(add(leafsLength, proofLength), add(flagsLength, 1)) {} {\\n                // For the case where `proof.length + leafs.length == 1`.\\n                if iszero(flagsLength) {\\n                    // `isValid = (proof.length == 1 ? proof[0] : leafs[0]) == root`.\\n                    isValid := eq(mload(xor(leafs, mul(xor(proof, leafs), proofLength))), root)\\n                    break\\n                }\\n\\n                // We can use the free memory space for the queue.\\n                // We don't need to allocate, since the queue is temporary.\\n                let hashesFront := mload(0x40)\\n                // Copy the leafs into the hashes.\\n                // Sometimes, a little memory expansion costs less than branching.\\n                // Should cost less, even with a high free memory offset of 0x7d00.\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                leafsLength := shl(5, leafsLength)\\n                for { let i := 0 } iszero(eq(i, leafsLength)) { i := add(i, 0x20) } {\\n                    mstore(add(hashesFront, i), mload(add(leafs, i)))\\n                }\\n                // Compute the back of the hashes.\\n                let hashesBack := add(hashesFront, leafsLength)\\n                // This is the end of the memory for the queue.\\n                // We recycle `flagsLength` to save on stack variables\\n                // (this trick may not always save gas).\\n                flagsLength := add(hashesBack, shl(5, flagsLength))\\n\\n                for {} 1 {} {\\n                    // Pop from `hashes`.\\n                    let a := mload(hashesFront)\\n                    // Pop from `hashes`.\\n                    let b := mload(add(hashesFront, 0x20))\\n                    hashesFront := add(hashesFront, 0x40)\\n\\n                    // If the flag is false, load the next proof,\\n                    // else, pops from the queue.\\n                    if iszero(mload(flags)) {\\n                        // Loads the next proof.\\n                        b := mload(proof)\\n                        proof := add(proof, 0x20)\\n                        // Unpop from `hashes`.\\n                        hashesFront := sub(hashesFront, 0x20)\\n                    }\\n\\n                    // Advance to the next flag.\\n                    flags := add(flags, 0x20)\\n\\n                    // Slot of `a` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(a, b))\\n                    // Hash the scratch space and push the result onto the queue.\\n                    mstore(scratch, a)\\n                    mstore(xor(scratch, 0x20), b)\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\n                    hashesBack := add(hashesBack, 0x20)\\n                    if iszero(lt(hashesBack, flagsLength)) { break }\\n                }\\n                // Checks if the last value in the queue is same as the root.\\n                isValid := eq(mload(sub(hashesBack, 0x20)), root)\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether all `leafs` exist in the Merkle tree with `root`,\\n    /// given `proof` and `flags`.\\n    function verifyMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32[] calldata leafs,\\n        bool[] calldata flags\\n    ) internal pure returns (bool isValid) {\\n        // Rebuilds the root by consuming and producing values on a queue.\\n        // The queue starts with the `leafs` array, and goes into a `hashes` array.\\n        // After the process, the last element on the queue is verified\\n        // to be equal to the `root`.\\n        //\\n        // The `flags` array denotes whether the sibling\\n        // should be popped from the queue (`flag == true`), or\\n        // should be popped from the `proof` (`flag == false`).\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the number of flags is correct.\\n            for {} eq(add(leafs.length, proof.length), add(flags.length, 1)) {} {\\n                // For the case where `proof.length + leafs.length == 1`.\\n                if iszero(flags.length) {\\n                    // `isValid = (proof.length == 1 ? proof[0] : leafs[0]) == root`.\\n                    // forgefmt: disable-next-item\\n                    isValid := eq(\\n                        calldataload(\\n                            xor(leafs.offset, mul(xor(proof.offset, leafs.offset), proof.length))\\n                        ),\\n                        root\\n                    )\\n                    break\\n                }\\n\\n                // We can use the free memory space for the queue.\\n                // We don't need to allocate, since the queue is temporary.\\n                let hashesFront := mload(0x40)\\n                // Copy the leafs into the hashes.\\n                // Sometimes, a little memory expansion costs less than branching.\\n                // Should cost less, even with a high free memory offset of 0x7d00.\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\n                calldatacopy(hashesFront, leafs.offset, shl(5, leafs.length))\\n                // Compute the back of the hashes.\\n                let hashesBack := add(hashesFront, shl(5, leafs.length))\\n                // This is the end of the memory for the queue.\\n                // We recycle `flags.length` to save on stack variables\\n                // (this trick may not always save gas).\\n                flags.length := add(hashesBack, shl(5, flags.length))\\n\\n                // We don't need to make a copy of `proof.offset` or `flags.offset`,\\n                // as they are pass-by-value (this trick may not always save gas).\\n\\n                for {} 1 {} {\\n                    // Pop from `hashes`.\\n                    let a := mload(hashesFront)\\n                    // Pop from `hashes`.\\n                    let b := mload(add(hashesFront, 0x20))\\n                    hashesFront := add(hashesFront, 0x40)\\n\\n                    // If the flag is false, load the next proof,\\n                    // else, pops from the queue.\\n                    if iszero(calldataload(flags.offset)) {\\n                        // Loads the next proof.\\n                        b := calldataload(proof.offset)\\n                        proof.offset := add(proof.offset, 0x20)\\n                        // Unpop from `hashes`.\\n                        hashesFront := sub(hashesFront, 0x20)\\n                    }\\n\\n                    // Advance to the next flag offset.\\n                    flags.offset := add(flags.offset, 0x20)\\n\\n                    // Slot of `a` in scratch space.\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\n                    let scratch := shl(5, gt(a, b))\\n                    // Hash the scratch space and push the result onto the queue.\\n                    mstore(scratch, a)\\n                    mstore(xor(scratch, 0x20), b)\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\n                    hashesBack := add(hashesBack, 0x20)\\n                    if iszero(lt(hashesBack, flags.length)) { break }\\n                }\\n                // Checks if the last value in the queue is same as the root.\\n                isValid := eq(mload(sub(hashesBack, 0x20)), root)\\n                break\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes32 array.\\n    function emptyProof() internal pure returns (bytes32[] calldata proof) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            proof.length := 0\\n        }\\n    }\\n\\n    /// @dev Returns an empty calldata bytes32 array.\\n    function emptyLeafs() internal pure returns (bytes32[] calldata leafs) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            leafs.length := 0\\n        }\\n    }\\n\\n    /// @dev Returns an empty calldata bool array.\\n    function emptyFlags() internal pure returns (bool[] calldata flags) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            flags.length := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"lib/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @author: manifold.xyz\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Royalty registry interface\\n */\\ninterface IRoyaltyRegistry is IERC165 {\\n    event RoyaltyOverride(address owner, address tokenAddress, address royaltyAddress);\\n\\n    /**\\n     * Override the location of where to look up royalty information for a given token contract.\\n     * Allows for backwards compatibility and implementation of royalty logic for contracts that did not previously support them.\\n     *\\n     * @param tokenAddress    - The token address you wish to override\\n     * @param royaltyAddress  - The royalty override address\\n     */\\n    function setRoyaltyLookupAddress(address tokenAddress, address royaltyAddress) external returns (bool);\\n\\n    /**\\n     * Returns royalty address location.  Returns the tokenAddress by default, or the override if it exists\\n     *\\n     * @param tokenAddress    - The token address you are looking up the royalty for\\n     */\\n    function getRoyaltyLookupAddress(address tokenAddress) external view returns (address);\\n\\n    /**\\n     * Returns the token address that an overrideAddress is set for.\\n     * Note: will not be accurate if the override was created before this function was added.\\n     *\\n     * @param overrideAddress - The override address you are looking up the token for\\n     */\\n    function getOverrideLookupTokenAddress(address overrideAddress) external view returns (address);\\n\\n    /**\\n     * Whether or not the message sender can override the royalty address for the given token address\\n     *\\n     * @param tokenAddress    - The token address you are looking up the royalty for\\n     */\\n    function overrideAllowed(address tokenAddress) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC3156 FlashLender, as defined in\\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC3156FlashLender {\\n    /**\\n     * @dev The amount of currency available to be lended.\\n     * @param token The loan currency.\\n     * @return The amount of `token` that can be borrowed.\\n     */\\n    function maxFlashLoan(address token) external view returns (uint256);\\n\\n    /**\\n     * @dev The fee to be charged for a given loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n     */\\n    function flashFee(address token, uint256 amount) external view returns (uint256);\\n\\n    /**\\n     * @dev Initiate a flash loan.\\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     */\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver,\\n        address token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStolenNftOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IStolenNftOracle {\\n    // copied from https://github.com/reservoirprotocol/oracle/blob/main/contracts/ReservoirOracle.sol\\n    struct Message {\\n        bytes32 id;\\n        bytes payload;\\n        // The UNIX timestamp when the message was signed by the oracle\\n        uint256 timestamp;\\n        // ECDSA signature or EIP-2098 compact signature\\n        bytes signature;\\n    }\\n\\n    /// @notice Validates that a set of token ids have not been marked as stolen by the oracle.\\n    /// @dev Check a signed message from the oracle to ensure that the token ids have not been marked as stolen.\\n    /// @param tokenAddress The address of the token contract.\\n    /// @param tokenIds The token ids to validate.\\n    /// @param proofs The proofs that the token ids have not been marked as stolen.\\n    function validateTokensAreNotStolen(address tokenAddress, uint256[] calldata tokenIds, Message[] calldata proofs)\\n        external;\\n}\\n\"\r\n    },\r\n    \"src/Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/*\\n *\\n *       __________...----..____..-'``-..___\\n *     ,'.                                  ```--.._\\n *    :                                             ``._\\n *    |                           --                    ``.\\n *    |                 -0-           -.     -   -.        `.\\n *    :                     __           --            .     \\\\\\n *     `._____________     (  `.   -.-      --  -   .   `     \\\\\\n *        `-----------------\\\\   \\\\_.--------..__..--.._ `. `.   :\\n *                           `--'                     `-._ .   |\\n *                                                        `.`  |\\n *                                                          \\\\` |\\n *                                                           \\\\ |\\n *                                                           / \\\\`.\\n *                                                          /  _\\\\-'\\n *                                                         /_,'\\n */\\n\\nimport {LibClone} from \\\"solady/utils/LibClone.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {ERC721} from \\\"solmate/tokens/ERC721.sol\\\";\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\nimport {PrivatePool} from \\\"./PrivatePool.sol\\\";\\nimport {PrivatePoolMetadata} from \\\"./PrivatePoolMetadata.sol\\\";\\n\\n/// @title Caviar Private Pool Factory\\n/// @author out.eth (@outdoteth)\\n/// @notice This contract is used to create and initialize new private pools. Each time a private pool is created, a new\\n/// NFT representing that private pool is minted to the creator. All protocol fees also accrue to this contract and can\\n/// be withdrawn by the admin.\\ncontract Factory is ERC721, Owned {\\n    using LibClone for address;\\n    using SafeTransferLib for address;\\n\\n    event Create(address indexed privatePool, uint256[] tokenIds, uint256 baseTokenAmount);\\n    event Withdraw(address indexed token, uint256 indexed amount);\\n    event SetPrivatePoolMetadata(address indexed privatePoolMetadata);\\n    event SetPrivatePoolImplementation(address indexed privatePoolImplementation);\\n    event SetProtocolFeeRate(uint16 indexed protocolFeeRate);\\n    event SetProtocolChangeFeeRate(uint16 indexed protocolChangeFeeRate);\\n\\n    error ProtocolFeeRateTooHigh();\\n    error ProtocolChangeFeeRateTooHigh();\\n    error URIQueryForNonExistentToken();\\n\\n    /// @notice The address of the private pool implementation that proxies point to.\\n    address public privatePoolImplementation;\\n\\n    /// @notice Helper contract that constructs the private pool metadata svg and json for each pool NFT.\\n    address public privatePoolMetadata;\\n\\n    /// @notice The protocol fee that is taken on each buy/sell/change. It's in basis points: 350 = 3.5%.\\n    uint16 public protocolFeeRate;\\n\\n    /// @notice The protocol change fee rate that is taken on each change/flash loan. It's in basis points: 200 = 2.00%.\\n    uint16 public protocolChangeFeeRate;\\n\\n    constructor() ERC721(\\\"Caviar Private Pools\\\", \\\"POOL\\\") Owned(msg.sender) {}\\n\\n    receive() external payable {}\\n\\n    /// @notice Creates a new private pool using the minimal proxy pattern that points to the private pool\\n    /// implementation. The caller must approve the factory to transfer the NFTs that will be deposited to the pool.\\n    /// @param _baseToken The address of the base token.\\n    /// @param _nft The address of the NFT.\\n    /// @param _virtualBaseTokenReserves The virtual base token reserves.\\n    /// @param _virtualNftReserves The virtual NFT reserves.\\n    /// @param _changeFee The change fee.\\n    /// @param _feeRate The fee rate.\\n    /// @param _merkleRoot The merkle root.\\n    /// @param _useStolenNftOracle Whether to use the stolen NFT oracle.\\n    /// @param _salt The salt that will used on deployment.\\n    /// @param tokenIds The token ids to deposit to the pool.\\n    /// @param baseTokenAmount The amount of base tokens to deposit to the pool.\\n    /// @return privatePool The address of the private pool.\\n    function create(\\n        address _baseToken,\\n        address _nft,\\n        uint128 _virtualBaseTokenReserves,\\n        uint128 _virtualNftReserves,\\n        uint56 _changeFee,\\n        uint16 _feeRate,\\n        bytes32 _merkleRoot,\\n        bool _useStolenNftOracle,\\n        bool _payRoyalties,\\n        bytes32 _salt,\\n        uint256[] memory tokenIds, // put in memory to avoid stack too deep error\\n        uint256 baseTokenAmount\\n    ) public payable returns (PrivatePool privatePool) {\\n        // check that the msg.value is equal to the base token amount if the base token is ETH or the msg.value is equal\\n        // to zero if the base token is not ETH\\n        if ((_baseToken == address(0) && msg.value != baseTokenAmount) || (_baseToken != address(0) && msg.value > 0)) {\\n            revert PrivatePool.InvalidEthAmount();\\n        }\\n\\n        // deploy a minimal proxy clone of the private pool implementation\\n        bytes32 salt = keccak256(abi.encode(msg.sender, _salt));\\n        privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(salt)));\\n\\n        // mint the nft to the caller\\n        _safeMint(msg.sender, uint256(uint160(address(privatePool))));\\n\\n        // initialize the pool\\n        privatePool.initialize(\\n            _baseToken,\\n            _nft,\\n            _virtualBaseTokenReserves,\\n            _virtualNftReserves,\\n            _changeFee,\\n            _feeRate,\\n            _merkleRoot,\\n            _useStolenNftOracle,\\n            _payRoyalties\\n        );\\n\\n        if (_baseToken == address(0)) {\\n            // transfer eth into the pool if base token is ETH\\n            address(privatePool).safeTransferETH(baseTokenAmount);\\n        } else {\\n            // deposit the base tokens from the caller into the pool\\n            SafeTransferLib.safeTransferFrom(ERC20(_baseToken), msg.sender, address(privatePool), baseTokenAmount);\\n        }\\n\\n        // deposit the nfts from the caller into the pool\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            ERC721(_nft).safeTransferFrom(msg.sender, address(privatePool), tokenIds[i]);\\n        }\\n\\n        // emit create event\\n        emit Create(address(privatePool), tokenIds, baseTokenAmount);\\n    }\\n\\n    /// @notice Sets private pool metadata contract.\\n    /// @param _privatePoolMetadata The private pool metadata contract.\\n    function setPrivatePoolMetadata(address _privatePoolMetadata) public onlyOwner {\\n        privatePoolMetadata = _privatePoolMetadata;\\n        emit SetPrivatePoolMetadata(_privatePoolMetadata);\\n    }\\n\\n    /// @notice Sets the private pool implementation contract that newly deployed proxies point to.\\n    /// @param _privatePoolImplementation The private pool implementation contract.\\n    function setPrivatePoolImplementation(address _privatePoolImplementation) public onlyOwner {\\n        privatePoolImplementation = _privatePoolImplementation;\\n        emit SetPrivatePoolImplementation(_privatePoolImplementation);\\n    }\\n\\n    /// @notice Sets the protocol fee that is taken on each buy/sell/change. It's in basis points: 350 = 3.5%.\\n    /// @param _protocolFeeRate The protocol fee.\\n    function setProtocolFeeRate(uint16 _protocolFeeRate) public onlyOwner {\\n        // check that the protocol fee rate is not higher than 5%\\n        if (_protocolFeeRate > 500) revert ProtocolFeeRateTooHigh();\\n\\n        protocolFeeRate = _protocolFeeRate;\\n        emit SetProtocolFeeRate(_protocolFeeRate);\\n    }\\n\\n    /// @notice Sets the protocol fee that is taken on change or flash loan. It's in basis points: 350 = 3.5%.\\n    /// @param _protocolChangeFeeRate The protocol change fee rate.\\n    function setProtocolChangeFeeRate(uint16 _protocolChangeFeeRate) public onlyOwner {\\n        // check that the protocol change fee rate is not higher than 100%\\n        if (_protocolChangeFeeRate > 10_000) revert ProtocolChangeFeeRateTooHigh();\\n\\n        protocolChangeFeeRate = _protocolChangeFeeRate;\\n        emit SetProtocolChangeFeeRate(_protocolChangeFeeRate);\\n    }\\n\\n    /// @notice Withdraws the earned protocol fees.\\n    /// @param token The token to withdraw.\\n    /// @param amount The amount to withdraw.\\n    function withdraw(address token, uint256 amount) public onlyOwner {\\n        if (token == address(0)) {\\n            msg.sender.safeTransferETH(amount);\\n        } else {\\n            ERC20(token).transfer(msg.sender, amount);\\n        }\\n\\n        emit Withdraw(token, amount);\\n    }\\n\\n    /// @notice Returns the token URI for a given token id.\\n    /// @param id The token id.\\n    /// @return uri The token URI.\\n    function tokenURI(uint256 id) public view override returns (string memory) {\\n        // check that the token exists\\n        if (_ownerOf[id] == address(0)) revert URIQueryForNonExistentToken();\\n\\n        return PrivatePoolMetadata(privatePoolMetadata).tokenURI(id);\\n    }\\n\\n    /// @notice Predicts the deployment address of a new private pool.\\n    /// @param salt The salt that will used on deployment.\\n    /// @return predictedAddress The predicted deployment address of the private pool.\\n    function predictPoolDeploymentAddress(bytes32 salt) public view returns (address predictedAddress) {\\n        predictedAddress = privatePoolImplementation.predictDeterministicAddress(salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/royalty-registry-solidity/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC3156FlashBorrower.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC3156FlashBorrower {\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"IERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibClone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Minimal proxy library.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\\n/// @author Minimal proxy by 0age (https://github.com/0age)\\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\\n///\\n/// @dev Minimal proxy:\\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\\n///\\n/// @dev Clones with immutable args (CWIA):\\n/// The implementation of CWIA here implements a `receive()` method that emits the\\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\\n/// composability. The minimal proxy implementation does not offer this feature.\\nlibrary LibClone {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Unable to deploy the clone.\\n    error DeploymentFailed();\\n\\n    /// @dev The salt must start with either the zero address or the caller.\\n    error SaltDoesNotStartWithCaller();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  MINIMAL PROXY OPERATIONS                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (44 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | 0                      |                       |\\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create(0, 0x0c, 0x35)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x21, 0)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    function cloneDeterministic(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create2(0, 0x0c, 0x35, salt)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x21, 0)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            hash := keccak256(0x0c, 0x35)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x21, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        bytes32 hash = initCodeHash(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a minimal proxy with `implementation`,\\n    /// using immutable arguments encoded in `data`.\\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n            // The `creationSize` is `extraLength + 108`\\n            // The `runSize` is `creationSize - 10`.\\n\\n            /**\\n             * ---------------------------------------------------------------------------------------------------+\\n             * CREATION (10 bytes)                                                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\\n             * 81         | DUP2              | r 0 r     |                                                       |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * RUNTIME (98 bytes + extraLength)                                                                   |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\\n             * ---------------------------------------------------------------------------------------------------|\\n             *                                                                                                    |\\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\\n             * 57       | JUMPI          |                          |                                             |\\n             * 34       | CALLVALUE      | cv                       |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\\n             * 5b       | JUMPDEST       |                          |                                             |\\n             *                                                                                                    |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\\n             * ---------------------------------------------------------------------------------------------------+\\n             */\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Create the instance.\\n            instance := create(0, sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`,\\n    /// using immutable arguments encoded in `data`, with `salt`.\\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Create the instance.\\n            instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)\\n\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Compute and store the bytecode hash.\\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of\\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash(implementation, data);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      OTHER OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the address when a contract with initialization code hash,\\n    /// `hash`, is deployed with `salt`, by `deployer`.\\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, deployer))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x35, 0)\\n        }\\n    }\\n\\n    /// @dev Reverts if `salt` does not start with either the zero address or the caller.\\n    function checkStartsWithCaller(bytes32 salt) internal view {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the salt does not start with the zero address or the caller.\\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\\n                // Store the function selector of `SaltDoesNotStartWithCaller()`.\\n                mstore(0x00, 0x2f634836)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/PrivatePoolMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {Strings} from \\\"openzeppelin/utils/Strings.sol\\\";\\nimport {Base64} from \\\"openzeppelin/utils/Base64.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {ERC721} from \\\"solmate/tokens/ERC721.sol\\\";\\n\\nimport {PrivatePool} from \\\"./PrivatePool.sol\\\";\\n\\n/// @title Private Pool Metadata\\n/// @author out.eth (@outdoteth)\\n/// @notice This contract is used to generate NFT metadata for private pools.\\ncontract PrivatePoolMetadata {\\n    /// @notice Returns the tokenURI for a pool with it's metadata.\\n    /// @param tokenId The private pool's token ID.\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\n        // forgefmt: disable-next-item\\n        bytes memory metadata = abi.encodePacked(\\n            \\\"{\\\",\\n                '\\\"name\\\": \\\"Private Pool ',Strings.toHexString(tokenId),'\\\",',\\n                '\\\"description\\\": \\\"Caviar private pool AMM position.\\\",',\\n                '\\\"image\\\": ','\\\"data:image/svg+xml;base64,', Base64.encode(svg(tokenId)),'\\\",',\\n                '\\\"attributes\\\": [',\\n                    attributes(tokenId),\\n                \\\"]\\\",\\n            \\\"}\\\"\\n        );\\n\\n        return string(abi.encodePacked(\\\"data:application/json;base64,\\\", Base64.encode(metadata)));\\n    }\\n\\n    /// @notice Returns the attributes for a pool encoded as json.\\n    /// @param tokenId The private pool's token ID.\\n    function attributes(uint256 tokenId) public view returns (string memory) {\\n        PrivatePool privatePool = PrivatePool(payable(address(uint160(tokenId))));\\n\\n        // forgefmt: disable-next-item\\n        bytes memory _attributes = abi.encodePacked(\\n            _trait(\\\"Pool address\\\", Strings.toHexString(address(privatePool))), ',',\\n            _trait(\\\"Base token\\\", Strings.toHexString(privatePool.baseToken())), ',',\\n            _trait(\\\"NFT\\\", Strings.toHexString(privatePool.nft())), ',',\\n            _trait(\\\"Virtual base token reserves\\\",Strings.toString(privatePool.virtualBaseTokenReserves())), ',',\\n            _trait(\\\"Virtual NFT reserves\\\", Strings.toString(privatePool.virtualNftReserves())), ',',\\n            _trait(\\\"Fee rate (bps): \\\", Strings.toString(privatePool.feeRate())), ',',\\n            _trait(\\\"NFT balance\\\", Strings.toString(ERC721(privatePool.nft()).balanceOf(address(privatePool)))), ',',\\n            _trait(\\\"Base token balance\\\",  Strings.toString(privatePool.baseToken() == address(0) ? address(privatePool).balance : ERC20(privatePool.baseToken()).balanceOf(address(privatePool))))\\n        );\\n\\n        return string(_attributes);\\n    }\\n\\n    /// @notice Returns an svg image for a pool.\\n    /// @param tokenId The private pool's token ID.\\n    function svg(uint256 tokenId) public view returns (bytes memory) {\\n        PrivatePool privatePool = PrivatePool(payable(address(uint160(tokenId))));\\n\\n        // break up svg building into multiple scopes to avoid stack too deep errors\\n        bytes memory _svg;\\n        {\\n            // forgefmt: disable-next-item\\n            _svg = abi.encodePacked(\\n                '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 400 400\\\" style=\\\"width:100%;background:black;fill:white;font-family:serif;\\\">',\\n                    '<text x=\\\"24px\\\" y=\\\"24px\\\" font-size=\\\"12\\\">',\\n                        \\\"Caviar AMM private pool position\\\",\\n                    \\\"</text>\\\",\\n                    '<text x=\\\"24px\\\" y=\\\"48px\\\" font-size=\\\"12\\\">',\\n                        \\\"Private pool: \\\", Strings.toHexString(address(privatePool)),\\n                    \\\"</text>\\\",\\n                    '<text x=\\\"24px\\\" y=\\\"72px\\\" font-size=\\\"12\\\">',\\n                        \\\"Base token: \\\", Strings.toHexString(privatePool.baseToken()),\\n                    \\\"</text>\\\",\\n                    '<text x=\\\"24px\\\" y=\\\"96px\\\" font-size=\\\"12\\\">',\\n                        \\\"NFT: \\\", Strings.toHexString(privatePool.nft()),\\n                    \\\"</text>\\\"\\n            );\\n        }\\n\\n        {\\n            // forgefmt: disable-next-item\\n            _svg = abi.encodePacked(\\n                _svg,\\n                '<text x=\\\"24px\\\" y=\\\"120px\\\" font-size=\\\"12\\\">',\\n                    \\\"Virtual base token reserves: \\\", Strings.toString(privatePool.virtualBaseTokenReserves()),\\n                \\\"</text>\\\",\\n                '<text x=\\\"24px\\\" y=\\\"144px\\\" font-size=\\\"12\\\">',\\n                    \\\"Virtual NFT reserves: \\\", Strings.toString(privatePool.virtualNftReserves()),\\n                \\\"</text>\\\",\\n                '<text x=\\\"24px\\\" y=\\\"168px\\\" font-size=\\\"12\\\">',\\n                    \\\"Fee rate (bps): \\\", Strings.toString(privatePool.feeRate()),\\n                \\\"</text>\\\"\\n            );\\n        }\\n\\n        {\\n            // forgefmt: disable-next-item\\n            _svg = abi.encodePacked(\\n                _svg, \\n                    '<text x=\\\"24px\\\" y=\\\"192px\\\" font-size=\\\"12\\\">',\\n                        \\\"NFT balance: \\\", Strings.toString(ERC721(privatePool.nft()).balanceOf(address(privatePool))),\\n                    \\\"</text>\\\",\\n                    '<text x=\\\"24px\\\" y=\\\"216px\\\" font-size=\\\"12\\\">',\\n                        \\\"Base token balance: \\\", Strings.toString(privatePool.baseToken() == address(0) ? address(privatePool).balance : ERC20(privatePool.baseToken()).balanceOf(address(privatePool))),\\n                    \\\"</text>\\\",\\n                \\\"</svg>\\\"\\n            );\\n        }\\n\\n        return _svg;\\n    }\\n\\n    function _trait(string memory traitType, string memory value) internal pure returns (string memory) {\\n        // forgefmt: disable-next-item\\n        return string(\\n            abi.encodePacked(\\n                '{ \\\"trait_type\\\": \\\"', traitType, '\\\",', '\\\"value\\\": \\\"', value, '\\\" }'\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@manifoldxyz/libraries-solidity/=lib/royalty-registry-solidity/lib/libraries-solidity/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/royalty-registry-solidity/lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/royalty-registry-solidity/lib/openzeppelin-contracts/contracts/\",\r\n      \"ERC721A/=lib/caviar/lib/ERC721A/contracts/\",\r\n      \"caviar/=lib/caviar/src/\",\r\n      \"create2-helpers/=lib/royalty-registry-solidity/lib/create2-helpers/\",\r\n      \"create2-scripts/=lib/royalty-registry-solidity/lib/create2-helpers/script/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"libraries-solidity/=lib/royalty-registry-solidity/lib/libraries-solidity/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/royalty-registry-solidity/lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"oracle/=lib/caviar/lib/oracle/contracts/\",\r\n      \"reservoir-oracle/=lib/caviar/lib/oracle/contracts/\",\r\n      \"royalty-registry-solidity/=lib/royalty-registry-solidity/contracts/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_royaltyRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stolenNftOracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeeRateTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FlashLoanFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientInputWeight\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEthAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMerkleProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRoyaltyFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTarget\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenWeights\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAvailableForFlashLoan\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrivatePoolNftNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VirtualReservesNotSet\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenWeights\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltyFeeAmount\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"inputTokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"inputTokenWeights\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"outputTokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"outputTokenWeights\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"}],\"name\":\"Change\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseTokenAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"virtualBaseTokenReserves\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"virtualNftReserves\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint56\",\"name\":\"changeFee\",\"type\":\"uint56\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"feeRate\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"useStolenNftOracle\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"payRoyalties\",\"type\":\"bool\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenWeights\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltyFeeAmount\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint56\",\"name\":\"changeFee\",\"type\":\"uint56\"}],\"name\":\"SetChangeFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"feeRate\",\"type\":\"uint16\"}],\"name\":\"SetFeeRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"SetMerkleRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"payRoyalties\",\"type\":\"bool\"}],\"name\":\"SetPayRoyalties\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"useStolenNftOracle\",\"type\":\"bool\"}],\"name\":\"SetUseStolenNftOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"virtualBaseTokenReserves\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"virtualNftReserves\",\"type\":\"uint128\"}],\"name\":\"SetVirtualReserves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"availableForFlashLoan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenWeights\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool[]\",\"name\":\"flags\",\"type\":\"bool[]\"}],\"internalType\":\"struct PrivatePool.MerkleMultiProof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netInputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"}],\"name\":\"buyQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netInputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"inputTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"inputTokenWeights\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool[]\",\"name\":\"flags\",\"type\":\"bool[]\"}],\"internalType\":\"struct PrivatePool.MerkleMultiProof\",\"name\":\"inputProof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct IStolenNftOracle.Message[]\",\"name\":\"stolenNftProofs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputTokenWeights\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool[]\",\"name\":\"flags\",\"type\":\"bool[]\"}],\"internalType\":\"struct PrivatePool.MerkleMultiProof\",\"name\":\"outputProof\",\"type\":\"tuple\"}],\"name\":\"change\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeFee\",\"outputs\":[{\"internalType\":\"uint56\",\"name\":\"\",\"type\":\"uint56\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"}],\"name\":\"changeFeeQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"baseTokenAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"flashFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashFeeAndProtocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashFeeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC3156FlashBorrower\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_virtualBaseTokenReserves\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_virtualNftReserves\",\"type\":\"uint128\"},{\"internalType\":\"uint56\",\"name\":\"_changeFee\",\"type\":\"uint56\"},{\"internalType\":\"uint16\",\"name\":\"_feeRate\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_useStolenNftOracle\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_payRoyalties\",\"type\":\"bool\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payRoyalties\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenWeights\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool[]\",\"name\":\"flags\",\"type\":\"bool[]\"}],\"internalType\":\"struct PrivatePool.MerkleMultiProof\",\"name\":\"proof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct IStolenNftOracle.Message[]\",\"name\":\"stolenNftProofs\",\"type\":\"tuple[]\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netOutputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"}],\"name\":\"sellQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netOutputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newVirtualBaseTokenReserves\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"newVirtualNftReserves\",\"type\":\"uint128\"},{\"internalType\":\"bytes32\",\"name\":\"newMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"newFeeRate\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"newUseStolenNftOracle\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"newPayRoyalties\",\"type\":\"bool\"},{\"internalType\":\"uint56\",\"name\":\"newChangeFee\",\"type\":\"uint56\"}],\"name\":\"setAllParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint56\",\"name\":\"_newChangeFee\",\"type\":\"uint56\"}],\"name\":\"setChangeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newFeeRate\",\"type\":\"uint16\"}],\"name\":\"setFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newPayRoyalties\",\"type\":\"bool\"}],\"name\":\"setPayRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newUseStolenNftOracle\",\"type\":\"bool\"}],\"name\":\"setUseStolenNftOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newVirtualBaseTokenReserves\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"newVirtualNftReserves\",\"type\":\"uint128\"}],\"name\":\"setVirtualReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stolenNftOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenWeights\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool[]\",\"name\":\"flags\",\"type\":\"bool[]\"}],\"internalType\":\"struct PrivatePool.MerkleMultiProof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"name\":\"sumWeightsAndValidateProof\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"useStolenNftOracle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"virtualBaseTokenReserves\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"virtualNftReserves\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PrivatePool", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a16be8d32934a9aab272102ac4bb890481f4074e000000000000000000000000ad2184fb5dbcfc05d8f056542fb25b04fa32a95d000000000000000000000000190eb447e37489975d5de9977bf8ad6c9ae096f3", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}