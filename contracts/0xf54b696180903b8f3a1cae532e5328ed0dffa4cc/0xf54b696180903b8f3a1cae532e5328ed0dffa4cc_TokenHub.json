{"SourceCode": "{\"AccessController.sol\":{\"content\":\"// SPDX-License-Identifier: -- DG --\\r\\n\\r\\npragma solidity =0.8.21;\\r\\n\\r\\ncontract AccessController {\\r\\n\\r\\n    address public ceoAddress;\\r\\n    mapping (address =\\u003e bool) public isWorker;\\r\\n\\r\\n    event CEOSet(\\r\\n        address newCEO\\r\\n    );\\r\\n\\r\\n    event WorkerAdded(\\r\\n        address newWorker\\r\\n    );\\r\\n\\r\\n    event WorkerRemoved(\\r\\n        address existingWorker\\r\\n    );\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        address creator = msg.sender;\\r\\n        ceoAddress = creator;\\r\\n        isWorker[creator] = true;\\r\\n\\r\\n        emit CEOSet(\\r\\n            creator\\r\\n        );\\r\\n\\r\\n        emit WorkerAdded(\\r\\n            creator\\r\\n        );\\r\\n    }\\r\\n\\r\\n    modifier onlyCEO() {\\r\\n        require(\\r\\n            msg.sender == ceoAddress,\\r\\n            \\\"AccessControl: CEO_DENIED\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyWorker() {\\r\\n        require(\\r\\n            isWorker[msg.sender] == true,\\r\\n            \\\"AccessControl: WORKER_DENIED\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier nonZeroAddress(\\r\\n        address checkingAddress\\r\\n    ) {\\r\\n        require(\\r\\n            checkingAddress != address(0x0),\\r\\n            \\\"AccessControl: INVALID_ADDRESS\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setCEO(\\r\\n        address _newCEO\\r\\n    )\\r\\n        external\\r\\n        nonZeroAddress(_newCEO)\\r\\n        onlyCEO\\r\\n    {\\r\\n        ceoAddress = _newCEO;\\r\\n\\r\\n        emit CEOSet(\\r\\n            ceoAddress\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function addWorker(\\r\\n        address _newWorker\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        _addWorker(\\r\\n            _newWorker\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function addWorkerBulk(\\r\\n        address[] calldata _newWorkers\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        for (uint8 index = 0; index \\u003c _newWorkers.length; index++) {\\r\\n            _addWorker(_newWorkers[index]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _addWorker(\\r\\n        address _newWorker\\r\\n    )\\r\\n        internal\\r\\n        nonZeroAddress(_newWorker)\\r\\n    {\\r\\n        require(\\r\\n            isWorker[_newWorker] == false,\\r\\n            \\u0027AccessControl: worker already exist\\u0027\\r\\n        );\\r\\n\\r\\n        isWorker[_newWorker] = true;\\r\\n\\r\\n        emit WorkerAdded(\\r\\n            _newWorker\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function removeWorker(\\r\\n        address _existingWorker\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        _removeWorker(\\r\\n            _existingWorker\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function removeWorkerBulk(\\r\\n        address[] calldata _workerArray\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        for (uint8 index = 0; index \\u003c _workerArray.length; index++) {\\r\\n            _removeWorker(_workerArray[index]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _removeWorker(\\r\\n        address _existingWorker\\r\\n    )\\r\\n        internal\\r\\n        nonZeroAddress(_existingWorker)\\r\\n    {\\r\\n        require(\\r\\n            isWorker[_existingWorker] == true,\\r\\n            \\\"AccessControl: worker not detected\\\"\\r\\n        );\\r\\n\\r\\n        isWorker[_existingWorker] = false;\\r\\n\\r\\n        emit WorkerRemoved(\\r\\n            _existingWorker\\r\\n        );\\r\\n    }\\r\\n}\"},\"EIP712Base.sol\":{\"content\":\"// SPDX-License-Identifier: -- DG --\\r\\n\\r\\npragma solidity =0.8.21;\\r\\n\\r\\ncontract EIP712Base {\\r\\n\\r\\n    struct EIP712Domain {\\r\\n        string name;\\r\\n        string version;\\r\\n        uint256 chainId;\\r\\n        address verifyingContract;\\r\\n    }\\r\\n\\r\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\\r\\n        bytes(\\r\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\r\\n        )\\r\\n    );\\r\\n\\r\\n    bytes32 internal domainSeperator;\\r\\n\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _version\\r\\n    ) {\\r\\n        domainSeperator = keccak256(abi.encode(\\r\\n\\t\\t\\tEIP712_DOMAIN_TYPEHASH,\\r\\n\\t\\t\\tkeccak256(bytes(_name)),\\r\\n\\t\\t\\tkeccak256(bytes(_version)),\\r\\n\\t\\t\\tgetChainID(),\\r\\n\\t\\t\\taddress(this)\\r\\n\\t\\t));\\r\\n    }\\r\\n\\r\\n    function getChainID()\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 id)\\r\\n    {\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tid := 1\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n    function getDomainSeperator()\\r\\n        private\\r\\n        view\\r\\n        returns(bytes32)\\r\\n    {\\r\\n\\t\\treturn domainSeperator;\\r\\n\\t}\\r\\n\\r\\n    function toTypedMessageHash(\\r\\n        bytes32 _messageHash\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns(bytes32)\\r\\n    {\\r\\n        return keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19\\\\x01\\\",\\r\\n                getDomainSeperator(),\\r\\n                _messageHash\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n}\"},\"EIP712MetaTransaction.sol\":{\"content\":\"// SPDX-License-Identifier: -- DG --\\r\\n\\r\\npragma solidity =0.8.21;\\r\\n\\r\\nimport \\\"./EIP712Base.sol\\\";\\r\\n\\r\\nabstract contract EIP712MetaTransaction is EIP712Base {\\r\\n\\r\\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\\r\\n        bytes(\\r\\n            \\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\"\\r\\n        )\\r\\n    );\\r\\n\\r\\n    event MetaTransactionExecuted(\\r\\n        address userAddress,\\r\\n        address payable relayerAddress,\\r\\n        bytes functionSignature\\r\\n    );\\r\\n\\r\\n    mapping(address =\\u003e uint256) internal nonces;\\r\\n\\r\\n    struct MetaTransaction {\\r\\n\\t\\tuint256 nonce;\\r\\n\\t\\taddress from;\\r\\n        bytes functionSignature;\\r\\n\\t}\\r\\n\\r\\n    function executeMetaTransaction(\\r\\n        address _userAddress,\\r\\n        bytes memory _functionSignature,\\r\\n        bytes32 _sigR,\\r\\n        bytes32 _sigS,\\r\\n        uint8 _sigV\\r\\n    )\\r\\n        public\\r\\n        payable\\r\\n        returns(bytes memory)\\r\\n    {\\r\\n        MetaTransaction memory metaTx = MetaTransaction(\\r\\n            {\\r\\n                nonce: nonces[_userAddress],\\r\\n                from: _userAddress,\\r\\n                functionSignature: _functionSignature\\r\\n            }\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            verify(\\r\\n                _userAddress,\\r\\n                metaTx,\\r\\n                _sigR,\\r\\n                _sigS,\\r\\n                _sigV\\r\\n            ), \\\"EIP712MetaTransaction: INVALID_SIGNATURE\\\"\\r\\n        );\\r\\n\\r\\n\\t    nonces[_userAddress] =\\r\\n\\t    nonces[_userAddress] + 1;\\r\\n\\r\\n        (bool success, bytes memory returnData) = address(this).call(\\r\\n            abi.encodePacked(\\r\\n                _functionSignature,\\r\\n                _userAddress\\r\\n            )\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            success,\\r\\n            \\\"EIP712MetaTransaction: INVALID_CALL\\\"\\r\\n        );\\r\\n\\r\\n        emit MetaTransactionExecuted(\\r\\n            _userAddress,\\r\\n            payable(msg.sender),\\r\\n            _functionSignature\\r\\n        );\\r\\n\\r\\n        return returnData;\\r\\n    }\\r\\n\\r\\n    function hashMetaTransaction(\\r\\n        MetaTransaction memory _metaTx\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32)\\r\\n    {\\r\\n\\t\\treturn keccak256(\\r\\n\\t\\t    abi.encode(\\r\\n                META_TRANSACTION_TYPEHASH,\\r\\n                _metaTx.nonce,\\r\\n                _metaTx.from,\\r\\n                keccak256(_metaTx.functionSignature)\\r\\n            )\\r\\n        );\\r\\n\\t}\\r\\n\\r\\n    function verify(\\r\\n        address _user,\\r\\n        MetaTransaction memory _metaTx,\\r\\n        bytes32 _sigR,\\r\\n        bytes32 _sigS,\\r\\n        uint8 _sigV\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        address signer = ecrecover(\\r\\n            toTypedMessageHash(\\r\\n                hashMetaTransaction(_metaTx)\\r\\n            ),\\r\\n            _sigV,\\r\\n            _sigR,\\r\\n            _sigS\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            signer != address(0x0),\\r\\n            \\\"EIP712MetaTransaction: INVALID_SIGNATURE\\\"\\r\\n        );\\r\\n\\r\\n\\t\\treturn signer == _user;\\r\\n\\t}\\r\\n\\r\\n    function msgSender()\\r\\n        internal\\r\\n        view\\r\\n        returns(address sender)\\r\\n    {\\r\\n        if (msg.sender == address(this)) {\\r\\n\\r\\n            bytes memory array = msg.data;\\r\\n            uint256 index = msg.data.length;\\r\\n\\r\\n            assembly {\\r\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\r\\n                sender := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\r\\n            }\\r\\n        } else {\\r\\n            sender = msg.sender;\\r\\n        }\\r\\n\\r\\n        return sender;\\r\\n    }\\r\\n\\r\\n    function getNonce(\\r\\n        address _user\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns(uint256 nonce)\\r\\n    {\\r\\n        nonce = nonces[_user];\\r\\n    }\\r\\n}\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: -- DG --\\r\\n\\r\\npragma solidity =0.8.21;\\r\\n\\r\\ninterface ERC721 {\\r\\n\\r\\n    function ownerOf(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function transferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        external;\\r\\n}\\r\\n\\r\\ninterface ERC20 {\\r\\n\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    )\\r\\n        external \\r\\n        returns (bool);\\r\\n        \\r\\n    function burn(\\r\\n        uint256 _amount\\r\\n    )\\r\\n        external;\\r\\n}\\r\\n\\r\\ninterface DGAccessories  {\\r\\n\\r\\n    function issueTokens(\\r\\n        address[] calldata _beneficiaries,\\r\\n        uint256[] calldata _itemIds\\r\\n    )\\r\\n        external;\\r\\n\\r\\n    function encodeTokenId(\\r\\n        uint256 _itemId,\\r\\n        uint256 _issuedId\\r\\n    )\\r\\n        external\\r\\n        pure\\r\\n        returns (uint256 id);\\r\\n\\r\\n    function decodeTokenId(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        external\\r\\n        pure\\r\\n        returns (\\r\\n            uint256 itemId,\\r\\n            uint256 issuedId\\r\\n        );\\r\\n\\r\\n    function items(\\r\\n        uint256 _id\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            string memory rarity,\\r\\n            uint256 maxSupply,\\r\\n            uint256 totalSupply,\\r\\n            uint256 price,\\r\\n            address beneficiary,\\r\\n            string memory metadata,\\r\\n            string memory contentHash\\r\\n        );\\r\\n\\r\\n    function itemsCount()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n}\"},\"TokenHub.sol\":{\"content\":\"// SPDX-License-Identifier: -- DG --\\r\\n\\r\\npragma solidity =0.8.21;\\r\\n\\r\\nimport \\\"./Interfaces.sol\\\";\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\nimport \\\"./AccessController.sol\\\";\\r\\nimport \\\"./EIP712MetaTransaction.sol\\\";\\r\\n\\r\\ncontract TokenHub is\\r\\n    AccessController,\\r\\n    TransferHelper,\\r\\n    EIP712MetaTransaction\\r\\n{    \\r\\n    uint256 public forwardFrame;\\r\\n    address public forwardAddress;\\r\\n\\r\\n    receive()\\r\\n        external\\r\\n        payable\\r\\n    {\\r\\n        emit ReceiveNative(\\r\\n            msg.value\\r\\n        );\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e bool) public supportedTokens;\\r\\n    mapping(address =\\u003e uint256) public forwardFrames;\\r\\n\\r\\n    event Forward(\\r\\n        address indexed depositorAddress,\\r\\n        address indexed paymentTokenAddress,\\r\\n        uint256 indexed paymentTokenAmount\\r\\n    );\\r\\n\\r\\n    event ForwardNative(\\r\\n        address indexed depositorAddress,\\r\\n        uint256 indexed paymentTokenAmount\\r\\n    );\\r\\n\\r\\n    event ReceiveNative(\\r\\n        uint256 indexed nativeAmount\\r\\n    );\\r\\n\\r\\n    constructor(\\r\\n        address _defaultToken,\\r\\n        uint256 _defaultFrame,\\r\\n        address _defaultAddress\\r\\n    )\\r\\n        EIP712Base(\\r\\n            \\\"TokenHub\\\",\\r\\n            \\\"v3.0\\\"\\r\\n        )\\r\\n    {\\r\\n        forwardFrame = _defaultFrame;\\r\\n        forwardAddress = _defaultAddress;        \\r\\n        supportedTokens[_defaultToken] = true;\\r\\n    }\\r\\n\\r\\n    function forwardNative()\\r\\n        external\\r\\n        payable \\r\\n    {\\r\\n        address _depositorAddress = msg.sender;\\r\\n\\r\\n        require(\\r\\n            canDepositAgain(_depositorAddress),\\r\\n            \\\"TokenHub: DEPOSIT_COOLDOWN\\\"\\r\\n        );\\r\\n\\r\\n        forwardFrames[_depositorAddress] = block.number;\\r\\n\\r\\n        payable(forwardAddress).transfer(\\r\\n            msg.value\\r\\n        );\\r\\n\\r\\n        emit ForwardNative(\\r\\n            msg.sender,\\r\\n            msg.value\\r\\n        );        \\r\\n    }\\r\\n\\r\\n    function forwardTokens(\\r\\n        address _paymentToken,\\r\\n        uint256 _paymentTokenAmount\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        address _depositorAddress = msg.sender;\\r\\n\\r\\n        require(\\r\\n            canDepositAgain(_depositorAddress),\\r\\n            \\\"TokenHub: DEPOSIT_COOLDOWN\\\"\\r\\n        );\\r\\n\\r\\n        forwardFrames[_depositorAddress] = block.number;\\r\\n\\r\\n        require(\\r\\n            supportedTokens[_paymentToken],\\r\\n            \\\"TokenHub: UNSUPPORTED_TOKEN\\\"\\r\\n        );\\r\\n\\r\\n        safeTransferFrom(\\r\\n            _paymentToken,\\r\\n            _depositorAddress,\\r\\n            forwardAddress,\\r\\n            _paymentTokenAmount\\r\\n        );\\r\\n\\r\\n        emit Forward(\\r\\n            msg.sender,\\r\\n            _paymentToken,\\r\\n            _paymentTokenAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function forwardTokensByWorker(\\r\\n        address _depositorAddress,\\r\\n        address _paymentTokenAddress,\\r\\n        uint256 _paymentTokenAmount\\r\\n    )\\r\\n        external\\r\\n        onlyWorker\\r\\n    {\\r\\n        require(\\r\\n            canDepositAgain(_depositorAddress),\\r\\n            \\\"TokenHub: DEPOSIT_COOLDOWN\\\"\\r\\n        );\\r\\n\\r\\n        forwardFrames[_depositorAddress] = block.number;\\r\\n\\r\\n        require(\\r\\n            supportedTokens[_paymentTokenAddress],\\r\\n            \\\"TokenHub: UNSUPPORTED_TOKEN\\\"\\r\\n        );\\r\\n\\r\\n        safeTransferFrom(\\r\\n            _paymentTokenAddress,\\r\\n            _depositorAddress,\\r\\n            forwardAddress,\\r\\n            _paymentTokenAmount\\r\\n        );\\r\\n\\r\\n        emit Forward(\\r\\n            _depositorAddress,\\r\\n            _paymentTokenAddress,\\r\\n            _paymentTokenAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function changeForwardFrame(\\r\\n        uint256 _newDepositFrame\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        forwardFrame = _newDepositFrame;\\r\\n    }\\r\\n\\r\\n    function changeForwardAddress(\\r\\n        address _newForwardAddress\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        forwardAddress = _newForwardAddress;\\r\\n    }\\r\\n\\r\\n    function changeSupportedToken(\\r\\n        address _tokenAddress,\\r\\n        bool _supportStatus\\r\\n    )\\r\\n        external \\r\\n        onlyCEO\\r\\n    {\\r\\n        supportedTokens[_tokenAddress] = _supportStatus;\\r\\n    }\\r\\n\\r\\n    function canDepositAgain(\\r\\n        address _depositorAddress\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return block.number - forwardFrames[_depositorAddress] \\u003e= forwardFrame;\\r\\n    }\\r\\n\\r\\n    function rescueToken(\\r\\n        address _tokenAddress\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        uint256 tokenBalance = safeBalance(\\r\\n            _tokenAddress,\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        safeTransfer(\\r\\n            _tokenAddress,\\r\\n            msg.sender,\\r\\n            tokenBalance\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function rescueNative() \\r\\n        external \\r\\n        onlyCEO \\r\\n    {\\r\\n        uint256 etherBalance = address(this).balance;\\r\\n        require(etherBalance \\u003e 0, \\\"No Ether balance to rescue\\\");\\r\\n        \\r\\n        payable(msg.sender).transfer(etherBalance);\\r\\n    }\\r\\n}\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: -- DG --\\r\\n\\r\\npragma solidity =0.8.21;\\r\\n\\r\\ncontract TransferHelper {\\r\\n\\r\\n    bytes4 private constant TRANSFER = bytes4(\\r\\n        keccak256(\\r\\n            bytes(\\r\\n                \\\"transfer(address,uint256)\\\" // 0xa9059cbb\\r\\n            )\\r\\n        )\\r\\n    );\\r\\n\\r\\n    bytes4 private constant TRANSFER_FROM = bytes4(\\r\\n        keccak256(\\r\\n            bytes(\\r\\n                \\\"transferFrom(address,address,uint256)\\\" // 0x23b872dd\\r\\n            )\\r\\n        )\\r\\n    );\\r\\n\\r\\n    bytes4 private constant BALANCE_OF = bytes4(\\r\\n        keccak256(\\r\\n            bytes(\\r\\n                \\\"balanceOf(address)\\\"\\r\\n            )\\r\\n        )\\r\\n    );\\r\\n\\r\\n    function safeTransfer(\\r\\n        address _token,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        (bool success, bytes memory data) = _token.call(\\r\\n            abi.encodeWithSelector(\\r\\n                TRANSFER, // 0xa9059cbb\\r\\n                _to,\\r\\n                _value\\r\\n            )\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            success \\u0026\\u0026 (\\r\\n                data.length == 0 || abi.decode(\\r\\n                    data, (bool)\\r\\n                )\\r\\n            ),\\r\\n            \\\"TransferHelper: TRANSFER_FAILED\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address _token,\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint _value\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        (bool success, bytes memory data) = _token.call(\\r\\n            abi.encodeWithSelector(\\r\\n                TRANSFER_FROM,\\r\\n                _from,\\r\\n                _to,\\r\\n                _value\\r\\n            )\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            success \\u0026\\u0026 (\\r\\n                data.length == 0 || abi.decode(\\r\\n                    data, (bool)\\r\\n                )\\r\\n            ),\\r\\n            \\\"TransferHelper: TRANSFER_FROM_FAILED\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeBalance(\\r\\n        address _token,\\r\\n        address _owner\\r\\n    )\\r\\n        internal\\r\\n        returns (uint256)\\r\\n    {\\r\\n        (bool success, bytes memory data) = _token.call(\\r\\n            abi.encodeWithSelector(\\r\\n                BALANCE_OF,\\r\\n                _owner\\r\\n            )\\r\\n        );\\r\\n\\r\\n        if (success == false) return 0;\\r\\n\\r\\n        return abi.decode(\\r\\n            data,\\r\\n            (uint256)\\r\\n        );\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defaultToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_defaultFrame\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_defaultAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCEO\",\"type\":\"address\"}],\"name\":\"CEOSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"paymentTokenAmount\",\"type\":\"uint256\"}],\"name\":\"Forward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"paymentTokenAmount\",\"type\":\"uint256\"}],\"name\":\"ForwardNative\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"name\":\"ReceiveNative\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newWorker\",\"type\":\"address\"}],\"name\":\"WorkerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"existingWorker\",\"type\":\"address\"}],\"name\":\"WorkerRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWorker\",\"type\":\"address\"}],\"name\":\"addWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newWorkers\",\"type\":\"address[]\"}],\"name\":\"addWorkerBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositorAddress\",\"type\":\"address\"}],\"name\":\"canDepositAgain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newForwardAddress\",\"type\":\"address\"}],\"name\":\"changeForwardAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDepositFrame\",\"type\":\"uint256\"}],\"name\":\"changeForwardFrame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_supportStatus\",\"type\":\"bool\"}],\"name\":\"changeSupportedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forwardAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forwardFrame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"forwardFrames\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forwardNative\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_paymentTokenAmount\",\"type\":\"uint256\"}],\"name\":\"forwardTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_paymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_paymentTokenAmount\",\"type\":\"uint256\"}],\"name\":\"forwardTokensByWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWorker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_existingWorker\",\"type\":\"address\"}],\"name\":\"removeWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_workerArray\",\"type\":\"address[]\"}],\"name\":\"removeWorkerBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokenHub", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004b520c812e8430659fc9f12f6d0c39026c83588d0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a88fee97d2d980f824bb87af07c8fa8569ce83b3", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c5703897802bf6ac1308c073afe5f1f8c1a5eb11c535ebe17afb21ca6f999b0f"}