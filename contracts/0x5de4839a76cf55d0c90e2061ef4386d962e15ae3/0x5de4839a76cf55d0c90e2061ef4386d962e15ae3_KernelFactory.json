{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/factory/KernelFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AdminLessERC1967Factory.sol\\\";\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/Create2.sol\\\";\\nimport \\\"src/Kernel.sol\\\";\\nimport \\\"src/validator/ECDSAValidator.sol\\\";\\nimport \\\"solady/auth/Ownable.sol\\\";\\n\\ncontract KernelFactory is AdminLessERC1967Factory, Ownable {\\n    IEntryPoint public entryPoint;\\n    mapping(address => bool) public isAllowedImplementation;\\n\\n    constructor(address _owner, IEntryPoint _entryPoint) {\\n        _initializeOwner(_owner);\\n        entryPoint = _entryPoint;\\n    }\\n\\n    function setImplementation(address _implementation, bool _allow) external onlyOwner {\\n        isAllowedImplementation[_implementation] = _allow;\\n    }\\n\\n    function setEntryPoint(IEntryPoint _entryPoint) external onlyOwner {\\n        entryPoint = _entryPoint;\\n    }\\n\\n    function createAccount(address _implementation, bytes calldata _data, uint256 _index)\\n        external\\n        payable\\n        returns (address proxy)\\n    {\\n        require(isAllowedImplementation[_implementation], \\\"KernelFactory: implementation not allowed\\\");\\n        bytes32 salt = bytes32(uint256(keccak256(abi.encodePacked(_data, _index))) & type(uint96).max);\\n        proxy = deployDeterministicAndCall(_implementation, salt, _data);\\n    }\\n\\n    function getAccountAddress(bytes calldata _data, uint256 _index) public view returns (address) {\\n        bytes32 salt = bytes32(uint256(keccak256(abi.encodePacked(_data, _index))) & type(uint96).max);\\n        return predictDeterministicAddress(salt);\\n    }\\n\\n    // stake functions\\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\\n        entryPoint.addStake{value: msg.value}(unstakeDelaySec);\\n    }\\n\\n    function unlockStake() external onlyOwner {\\n        entryPoint.unlockStake();\\n    }\\n\\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\\n        entryPoint.withdrawStake(withdrawAddress);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/factory/AdminLessERC1967Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Factory for deploying and managing ERC1967 proxy contracts.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ERC1967Factory.sol)\\n/// @author jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\\n/// @author taeklee (https://github.com/zerodevapp/kernel)\\ncontract AdminLessERC1967Factory {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The proxy deployment failed.\\n    error DeploymentFailed();\\n\\n    /// @dev The salt does not start with the caller.\\n    error SaltDoesNotStartWithCaller();\\n\\n    /// @dev `bytes4(keccak256(bytes(\\\"DeploymentFailed()\\\")))`.\\n    uint256 internal constant _DEPLOYMENT_FAILED_ERROR_SELECTOR = 0x30116425;\\n\\n    /// @dev `bytes4(keccak256(bytes(\\\"SaltDoesNotStartWithCaller()\\\")))`.\\n    uint256 internal constant _SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR = 0x2f634836;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev A proxy has been deployed.\\n    event Deployed(address indexed proxy, address indexed implementation);\\n\\n    /// @dev `keccak256(bytes(\\\"Deployed(address,address)\\\"))`.\\n    uint256 internal constant _DEPLOYED_EVENT_SIGNATURE =\\n        0x09e48df7857bd0c1e0d31bb8a85d42cf1874817895f171c917f6ee2cea73ec20;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\\n    /// `uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1`.\\n    uint256 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      DEPLOY FUNCTIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n    /// @dev Deploys a proxy for `implementation`, with `salt`,\\n    /// and returns its deterministic address.\\n    /// The value passed into this function will be forwarded to the proxy.\\n    /// Then, calls the proxy with abi encoded `data`.\\n    function deployDeterministicAndCall(address implementation, bytes32 salt, bytes calldata data)\\n        internal\\n        returns (address proxy)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the salt does not start with the zero address or the caller.\\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\\n                mstore(0x00, _SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        proxy = _deploy(implementation, salt, data);\\n    }\\n\\n    /// @dev Deploys the proxy, with optionality to deploy deterministically with a `salt`.\\n    function _deploy(address implementation, bytes32 salt, bytes calldata data) internal returns (address proxy) {\\n        bytes memory m = _initCode();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let hash := keccak256(add(m, 0x13), 0x89)\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, address()))\\n            mstore(0x15, salt)\\n            proxy := keccak256(0x00, 0x55)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x35, 0)\\n            if iszero(extcodesize(proxy)) {\\n                proxy := create2(0, add(m, 0x13), 0x89, salt)\\n                if iszero(proxy) {\\n                    // Revert if the creation fails.\\n                    mstore(0x00, _DEPLOYMENT_FAILED_ERROR_SELECTOR)\\n                    revert(0x1c, 0x04)\\n                }\\n                // Set up the calldata to set the implementation of the proxy.\\n                mstore(m, implementation)\\n                mstore(add(m, 0x20), _IMPLEMENTATION_SLOT)\\n                calldatacopy(add(m, 0x40), data.offset, data.length)\\n                // Try setting the implementation on the proxy and revert upon failure.\\n                if iszero(call(gas(), proxy, callvalue(), m, add(0x40, data.length), 0x00, 0x00)) {\\n                    // Revert with the `DeploymentFailed` selector if there is no error returndata.\\n                    if iszero(returndatasize()) {\\n                        mstore(0x00, _DEPLOYMENT_FAILED_ERROR_SELECTOR)\\n                        revert(0x1c, 0x04)\\n                    }\\n                    // Otherwise, bubble up the returned error.\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n\\n                // Emit the {Deployed} event.\\n                log3(0, 0, _DEPLOYED_EVENT_SIGNATURE, proxy, implementation)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the address of the proxy deployed with `salt`.\\n    function predictDeterministicAddress(bytes32 salt) public view returns (address predicted) {\\n        bytes32 hash = initCodeHash();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, address()))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x35, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the proxy.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash() public view returns (bytes32 result) {\\n        bytes memory m = _initCode();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := keccak256(add(m, 0x13), 0x89)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of a proxy created via this factory.\\n    function _initCode() internal view returns (bytes memory m) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * -------------------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                                   |\\n             * -------------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic        | Stack               | Memory                          |\\n             * -------------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize   | r                   |                                 |\\n             * 3d         | RETURNDATASIZE  | 0 r                 |                                 |\\n             * 81         | DUP2            | r 0 r               |                                 |\\n             * 60 offset  | PUSH1 offset    | o r 0 r             |                                 |\\n             * 3d         | RETURNDATASIZE  | 0 o r 0 r           |                                 |\\n             * 39         | CODECOPY        | 0 r                 | [0..runSize): runtime code      |\\n             * f3         | RETURN          |                     | [0..runSize): runtime code      |\\n             * -------------------------------------------------------------------------------------|\\n             * RUNTIME (127 bytes)                                                                  |\\n             * -------------------------------------------------------------------------------------|\\n             * Opcode      | Mnemonic       | Stack               | Memory                          |\\n             * -------------------------------------------------------------------------------------|\\n             *                                                                                      |\\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d          | RETURNDATASIZE | 0                   |                                 |\\n             * 3d          | RETURNDATASIZE | 0 0                 |                                 |\\n             *                                                                                      |\\n             * ::: check if caller is factory ::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 33          | CALLER         | c 0 0               |                                 |\\n             * 73 factory  | PUSH20 factory | f c 0 0             |                                 |\\n             * 14          | EQ             | isf 0 0             |                                 |\\n             * 60 0x57     | PUSH1 0x57     | dest isf 0 0        |                                 |\\n             * 57          | JUMPI          | 0 0                 |                                 |\\n             *                                                                                      |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36          | CALLDATASIZE   | cds 0 0             |                                 |\\n             * 3d          | RETURNDATASIZE | 0 cds 0 0           |                                 |\\n             * 3d          | RETURNDATASIZE | 0 0 cds 0 0         |                                 |\\n             * 37          | CALLDATACOPY   | 0 0                 | [0..calldatasize): calldata     |\\n             *                                                                                      |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36          | CALLDATASIZE   | cds 0 0             | [0..calldatasize): calldata     |\\n             * 3d          | RETURNDATASIZE | 0 cds 0 0           | [0..calldatasize): calldata     |\\n             * 7f slot     | PUSH32 slot    | s 0 cds 0 0         | [0..calldatasize): calldata     |\\n             * 54          | SLOAD          | i cds 0 0           | [0..calldatasize): calldata     |\\n             * 5a          | GAS            | g i cds 0 0         | [0..calldatasize): calldata     |\\n             * f4          | DELEGATECALL   | succ                | [0..calldatasize): calldata     |\\n             *                                                                                      |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d          | RETURNDATASIZE | rds succ            | [0..calldatasize): calldata     |\\n             * 60 0x00     | PUSH1 0x00     | 0 rds succ          | [0..calldatasize): calldata     |\\n             * 80          | DUP1           | 0 0 rds succ        | [0..calldatasize): calldata     |\\n             * 3e          | RETURNDATACOPY | succ                | [0..returndatasize): returndata |\\n             *                                                                                      |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x52     | PUSH1 0x52     | dest succ           | [0..returndatasize): returndata |\\n             * 57          | JUMPI          |                     | [0..returndatasize): returndata |\\n             *                                                                                      |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\\n             * fd          | REVERT         |                     | [0..returndatasize): returndata |\\n             *                                                                                      |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b          | JUMPDEST       |                     | [0..returndatasize): returndata |\\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\\n             * f3          | RETURN         |                     | [0..returndatasize): returndata |\\n             *                                                                                      |\\n             * ::: set new implementation (caller is factory) ::::::::::::::::::::::::::::::::::::: |\\n             * 5b          | JUMPDEST       | 0 0                 |                                 |\\n             * 3d          | RETURNDATASIZE | 0 0 0               |                                 |\\n             * 35          | CALLDATALOAD   | impl 0 0            |                                 |\\n             * 06 0x20     | PUSH1 0x20     | w impl 0 0          |                                 |\\n             * 35          | CALLDATALOAD   | slot impl 0 0       |                                 |\\n             * 55          | SSTORE         | 0 0                 |                                 |\\n             *                                                                                      |\\n             * ::: no extra calldata, return :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x40     | PUSH1 0x40     | 2w 0 0              |                                 |\\n             * 80          | DUP1           | 2w 2w 0 0           |                                 |\\n             * 36          | CALLDATASIZE   | cds 2w 2w 0 0       |                                 |\\n             * 11          | GT             | gt 2w 0 0           |                                 |\\n             * 15          | ISZERO         | lte 2w 0 0          |                                 |\\n             * 60 0x52     | PUSH1 0x52     | dest lte 2w 0 0     |                                 |\\n             * 57          | JUMPI          | 2w 0 0              |                                 |\\n             *                                                                                      |\\n             * ::: copy extra calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36          | CALLDATASIZE   | cds 2w 0 0          |                                 |\\n             * 03          | SUB            | t 0 0               |                                 |\\n             * 80          | DUP1           | t t 0 0             |                                 |\\n             * 60 0x40     | PUSH1 0x40     | 2w t t 0 0          |                                 |\\n             * 3d          | RETURNDATASIZE | 0 2w t t 0 0        |                                 |\\n             * 37          | CALLDATACOPY   | t 0 0               | [0..t): extra calldata          |\\n             *                                                                                      |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d          | RETURNDATASIZE | 0 t 0 0             | [0..t): extra calldata          |\\n             * 3d          | RETURNDATASIZE | 0 0 t 0 0           | [0..t): extra calldata          |\\n             * 35          | CALLDATALOAD   | i t 0 0             | [0..t): extra calldata          |\\n             * 5a          | GAS            | g i t 0 0           | [0..t): extra calldata          |\\n             * f4          | DELEGATECALL   | succ                | [0..t): extra calldata          |\\n             *                                                                                      |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d          | RETURNDATASIZE | rds succ            | [0..t): extra calldata          |\\n             * 60 0x00     | PUSH1 0x00     | 0 rds succ          | [0..t): extra calldata          |\\n             * 80          | DUP1           | 0 0 rds succ        | [0..t): extra calldata          |\\n             * 3e          | RETURNDATACOPY | succ                | [0..returndatasize): returndata |\\n             *                                                                                      |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x52     | PUSH1 0x52     | dest succ           | [0..returndatasize): returndata |\\n             * 57          | JUMPI          |                     | [0..returndatasize): returndata |\\n             *                                                                                      |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\\n             * fd          | REVERT         |                     | [0..returndatasize): returndata |\\n             * -------------------------------------------------------------------------------------+\\n             */\\n\\n            m := mload(0x40)\\n            // forgefmt: disable-start\\n            switch shr(112, address())\\n            case 0 {\\n                // If the factory's address has six or more leading zero bytes.\\n                mstore(add(m, 0x75), 0x604c573d6000fd) // 7\\n                mstore(add(m, 0x6e), 0x3d3560203555604080361115604c5736038060403d373d3d355af43d6000803e) // 32\\n                mstore(add(m, 0x4e), 0x3735a920a3ca505d382bbc545af43d6000803e604c573d6000fd5b3d6000f35b) // 32\\n                mstore(add(m, 0x2e), 0x14605157363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc) // 32\\n                mstore(add(m, 0x0e), address()) // 14\\n                mstore(m, 0x60793d8160093d39f33d3d336d) // 9 + 4\\n            }\\n            default {\\n                mstore(add(m, 0x7b), 0x6052573d6000fd) // 7\\n                mstore(add(m, 0x74), 0x3d356020355560408036111560525736038060403d373d3d355af43d6000803e) // 32\\n                mstore(add(m, 0x54), 0x3735a920a3ca505d382bbc545af43d6000803e6052573d6000fd5b3d6000f35b) // 32\\n                mstore(add(m, 0x34), 0x14605757363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc) // 32\\n                mstore(add(m, 0x14), address()) // 20\\n                mstore(m, 0x607f3d8160093d39f33d3d3373) // 9 + 4\\n            }\\n            // forgefmt: disable-end\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          HELPERS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Helper function to return an empty bytes calldata.\\n    function _emptyData() internal pure returns (bytes calldata data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            data.length := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address addr) {\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \u2193 ptr ...  \u2193 ptr + 0x0B (start) ...  \u2193 ptr + 0x20 ...  \u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Kernel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Importing external libraries and contracts\\nimport \\\"solady/utils/EIP712.sol\\\";\\nimport \\\"solady/utils/ECDSA.sol\\\";\\nimport \\\"account-abstraction/interfaces/IEntryPoint.sol\\\";\\nimport \\\"./abstract/Compatibility.sol\\\";\\nimport \\\"./abstract/KernelStorage.sol\\\";\\nimport \\\"./utils/KernelHelper.sol\\\";\\n\\nimport \\\"src/common/Constants.sol\\\";\\nimport \\\"src/common/Enum.sol\\\";\\n\\n/// @title Kernel\\n/// @author taek<leekt216@gmail.com>\\n/// @notice wallet kernel for extensible wallet functionality\\n\\ncontract Kernel is EIP712, Compatibility, KernelStorage {\\n    string public constant name = KERNEL_NAME;\\n\\n    string public constant version = KERNEL_VERSION;\\n\\n    error NotEntryPoint();\\n    error DisabledMode();\\n\\n    /// @dev Sets up the EIP712 and KernelStorage with the provided entry point\\n    constructor(IEntryPoint _entryPoint) KernelStorage(_entryPoint) {}\\n\\n    function _domainNameAndVersion() internal pure override returns (string memory, string memory) {\\n        return (KERNEL_NAME, KERNEL_VERSION);\\n    }\\n\\n    /// @notice Accepts incoming Ether transactions and calls from the EntryPoint contract\\n    /// @dev This function will delegate any call to the appropriate executor based on the function signature.\\n    fallback() external payable {\\n        bytes4 sig = msg.sig;\\n        address executor = getKernelStorage().execution[sig].executor;\\n        if (msg.sender != address(entryPoint) && !_checkCaller()) {\\n            revert NotAuthorizedCaller();\\n        }\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), executor, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /// @notice Executes a function call to an external contract\\n    /// @dev The type of operation (call or delegatecall) is specified as an argument.\\n    /// @param to The address of the target contract\\n    /// @param value The amount of Ether to send\\n    /// @param data The call data to be sent\\n    /// @param operation The type of operation (call or delegatecall)\\n    function execute(address to, uint256 value, bytes memory data, Operation operation) external payable {\\n        if (msg.sender != address(entryPoint) && !_checkCaller()) {\\n            revert NotAuthorizedCaller();\\n        }\\n        if (operation == Operation.Call) {\\n            assembly {\\n                let success := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\\n                returndatacopy(0, 0, returndatasize())\\n                switch success\\n                case 0 { revert(0, returndatasize()) }\\n                default { return(0, returndatasize()) }\\n            }\\n        } else {\\n            assembly {\\n                let success := delegatecall(gas(), to, add(data, 0x20), mload(data), 0, 0)\\n                returndatacopy(0, 0, returndatasize())\\n                switch success\\n                case 0 { revert(0, returndatasize()) }\\n                default { return(0, returndatasize()) }\\n            }\\n        }\\n    }\\n\\n    /// @notice Validates a user operation based on its mode\\n    /// @dev This function will validate user operation and be called by EntryPoint\\n    /// @param userOp The user operation to be validated\\n    /// @param userOpHash The hash of the user operation\\n    /// @param missingAccountFunds The funds needed to be reimbursed\\n    /// @return validationData The data used for validation\\n    function validateUserOp(UserOperation memory userOp, bytes32 userOpHash, uint256 missingAccountFunds)\\n        external\\n        payable\\n        returns (ValidationData validationData)\\n    {\\n        if (msg.sender != address(entryPoint)) {\\n            revert NotEntryPoint();\\n        }\\n        bytes calldata userOpSignature;\\n        uint256 userOpEndOffset;\\n        bytes32 storage_slot_1;\\n        assembly {\\n            userOpEndOffset := add(calldataload(0x04), 0x24)\\n            userOpSignature.offset := add(calldataload(add(userOpEndOffset, 0x120)), userOpEndOffset)\\n            userOpSignature.length := calldataload(sub(userOpSignature.offset, 0x20))\\n            storage_slot_1 := sload(KERNEL_STORAGE_SLOT_1)\\n        }\\n        // mode based signature\\n        bytes4 mode = bytes4(userOpSignature[0:4]); // mode == 00..00 use validators\\n        // mode == 0x00000000 use sudo validator\\n        // mode == 0x00000001 use given validator\\n        // mode == 0x00000002 enable validator\\n        IKernelValidator validator;\\n        if (mode == 0x00000000) {\\n            // sudo mode (use default validator)\\n            userOpSignature = userOpSignature[4:];\\n            assembly {\\n                validator := shr(80, storage_slot_1)\\n            }\\n        } else if (mode & (storage_slot_1 << 224) != 0x00000000) {\\n            revert DisabledMode();\\n        } else if (mode == 0x00000001) {\\n            bytes calldata userOpCallData;\\n            assembly {\\n                userOpCallData.offset := add(calldataload(add(userOpEndOffset, 0x40)), userOpEndOffset)\\n                userOpCallData.length := calldataload(sub(userOpCallData.offset, 0x20))\\n            }\\n            ExecutionDetail storage detail = getKernelStorage().execution[bytes4(userOpCallData[0:4])];\\n            validator = detail.validator;\\n            if (address(validator) == address(0)) {\\n                assembly {\\n                    validator := shr(80, storage_slot_1)\\n                }\\n            }\\n            userOpSignature = userOpSignature[4:];\\n            validationData = packValidationData(detail.validAfter, detail.validUntil);\\n        } else if (mode == 0x00000002) {\\n            bytes calldata userOpCallData;\\n            assembly {\\n                userOpCallData.offset := add(calldataload(add(userOpEndOffset, 0x40)), userOpEndOffset)\\n                userOpCallData.length := calldataload(sub(userOpCallData.offset, 0x20))\\n            }\\n            // use given validator\\n            // userOpSignature[4:10] = validAfter,\\n            // userOpSignature[10:16] = validUntil,\\n            // userOpSignature[16:36] = validator address,\\n            (validator, validationData, userOpSignature) =\\n                _approveValidator(bytes4(userOpCallData[0:4]), userOpSignature);\\n        } else {\\n            return SIG_VALIDATION_FAILED;\\n        }\\n        if (missingAccountFunds != 0) {\\n            assembly {\\n                pop(call(gas(), caller(), missingAccountFunds, 0, 0, 0, 0))\\n            }\\n            //ignore failure (its EntryPoint's job to verify, not account.)\\n        }\\n        userOp.signature = userOpSignature;\\n        validationData =\\n            _intersectValidationData(validationData, validator.validateUserOp(userOp, userOpHash, missingAccountFunds));\\n        return validationData;\\n    }\\n\\n    function _approveValidator(bytes4 sig, bytes calldata signature)\\n        internal\\n        returns (IKernelValidator validator, ValidationData validationData, bytes calldata validationSig)\\n    {\\n        unchecked {\\n            validator = IKernelValidator(address(bytes20(signature[16:36])));\\n            uint256 cursor = 88;\\n            uint256 length = uint256(bytes32(signature[56:88])); // this is enableDataLength\\n            bytes calldata enableData;\\n            assembly {\\n                enableData.offset := add(signature.offset, cursor)\\n                enableData.length := length\\n                cursor := add(cursor, length) // 88 + enableDataLength\\n            }\\n            length = uint256(bytes32(signature[cursor:cursor + 32])); // this is enableSigLength\\n            assembly {\\n                cursor := add(cursor, 32)\\n            }\\n            bytes32 enableDigest = _hashTypedData(\\n                keccak256(\\n                    abi.encode(\\n                        VALIDATOR_APPROVED_STRUCT_HASH,\\n                        bytes4(sig),\\n                        uint256(bytes32(signature[4:36])),\\n                        address(bytes20(signature[36:56])),\\n                        keccak256(enableData)\\n                    )\\n                )\\n            );\\n            validationData = _intersectValidationData(\\n                getKernelStorage().defaultValidator.validateSignature(enableDigest, signature[cursor:cursor + length]),\\n                ValidationData.wrap(\\n                    uint256(bytes32(signature[4:36]))\\n                        & 0xffffffffffffffffffffffff0000000000000000000000000000000000000000\\n                )\\n            );\\n            assembly {\\n                cursor := add(cursor, length)\\n                validationSig.offset := add(signature.offset, cursor)\\n                validationSig.length := sub(signature.length, cursor)\\n            }\\n            getKernelStorage().execution[sig] = ExecutionDetail({\\n                validAfter: ValidAfter.wrap(uint48(bytes6(signature[4:10]))),\\n                validUntil: ValidUntil.wrap(uint48(bytes6(signature[10:16]))),\\n                executor: address(bytes20(signature[36:56])),\\n                validator: IKernelValidator(address(bytes20(signature[16:36])))\\n            });\\n            validator.enable(enableData);\\n        }\\n    }\\n\\n    /// @notice Checks if a signature is valid\\n    /// @dev This function checks if a signature is valid based on the hash of the data signed.\\n    /// @param hash The hash of the data that was signed\\n    /// @param signature The signature to be validated\\n    /// @return The magic value 0x1626ba7e if the signature is valid, otherwise returns 0xffffffff.\\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {\\n        ValidationData validationData = getKernelStorage().defaultValidator.validateSignature(hash, signature);\\n        (ValidAfter validAfter, ValidUntil validUntil, address result) = parseValidationData(validationData);\\n        if (ValidAfter.unwrap(validAfter) > block.timestamp) {\\n            return 0xffffffff;\\n        }\\n        if (ValidUntil.unwrap(validUntil) < block.timestamp) {\\n            return 0xffffffff;\\n        }\\n        if (result != address(0)) {\\n            return 0xffffffff;\\n        }\\n\\n        return 0x1626ba7e;\\n    }\\n\\n    function _checkCaller() internal view returns (bool) {\\n        if (getKernelStorage().defaultValidator.validCaller(msg.sender, msg.data)) {\\n            return true;\\n        }\\n        bytes4 sig = msg.sig;\\n        ExecutionDetail storage detail = getKernelStorage().execution[sig];\\n        if (\\n            address(detail.validator) == address(0)\\n                || (ValidUntil.unwrap(detail.validUntil) != 0 && ValidUntil.unwrap(detail.validUntil) < block.timestamp)\\n                || ValidAfter.unwrap(detail.validAfter) > block.timestamp\\n        ) {\\n            return false;\\n        } else {\\n            return detail.validator.validCaller(msg.sender, msg.data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/validator/ECDSAValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"solady/utils/ECDSA.sol\\\";\\nimport \\\"src/utils/KernelHelper.sol\\\";\\nimport \\\"src/interfaces/IValidator.sol\\\";\\nimport \\\"src/common/Types.sol\\\";\\n\\nstruct ECDSAValidatorStorage {\\n    address owner;\\n}\\n\\ncontract ECDSAValidator is IKernelValidator {\\n    event OwnerChanged(address indexed kernel, address indexed oldOwner, address indexed newOwner);\\n\\n    mapping(address => ECDSAValidatorStorage) public ecdsaValidatorStorage;\\n\\n    function disable(bytes calldata) external payable override {\\n        delete ecdsaValidatorStorage[msg.sender];\\n    }\\n\\n    function enable(bytes calldata _data) external payable override {\\n        address owner = address(bytes20(_data[0:20]));\\n        address oldOwner = ecdsaValidatorStorage[msg.sender].owner;\\n        ecdsaValidatorStorage[msg.sender].owner = owner;\\n        emit OwnerChanged(msg.sender, oldOwner, owner);\\n    }\\n\\n    function validateUserOp(UserOperation calldata _userOp, bytes32 _userOpHash, uint256)\\n        external\\n        payable\\n        override\\n        returns (ValidationData validationData)\\n    {\\n        address owner = ecdsaValidatorStorage[_userOp.sender].owner;\\n        bytes32 hash = ECDSA.toEthSignedMessageHash(_userOpHash);\\n        if (owner == ECDSA.recover(hash, _userOp.signature)) {\\n            return ValidationData.wrap(0);\\n        }\\n        if (owner != ECDSA.recover(_userOpHash, _userOp.signature)) {\\n            return SIG_VALIDATION_FAILED;\\n        }\\n    }\\n\\n    function validateSignature(bytes32 hash, bytes calldata signature) public view override returns (ValidationData) {\\n        address owner = ecdsaValidatorStorage[msg.sender].owner;\\n        if (owner == ECDSA.recover(hash, signature)) {\\n            return ValidationData.wrap(0);\\n        }\\n        bytes32 ethHash = ECDSA.toEthSignedMessageHash(hash);\\n        address recovered = ECDSA.recover(ethHash, signature);\\n        if (owner != recovered) {\\n            return SIG_VALIDATION_FAILED;\\n        }\\n        return ValidationData.wrap(0);\\n    }\\n\\n    function validCaller(address _caller, bytes calldata) external view override returns (bool) {\\n        return ecdsaValidatorStorage[msg.sender].owner == _caller;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\\n/// for compatibility, the nomenclature for the 2-step ownership handover\\n/// may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\n    /// It is intentionally choosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n            // Store the new value.\\n            sstore(ownerSlot, newOwner)\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will be automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(not(_OWNER_SLOT_NOT))\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    function ownershipHandoverValidFor() public view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\\n/// Note, this implementation:\\n/// - Uses `address(this)` for the `verifyingContract` field.\\n/// - Does NOT use the optional EIP-712 salt.\\n/// - Does NOT use any EIP-712 extensions.\\n/// This is for simplicity and to save gas.\\n/// If you need to customize, please fork / modify accordingly.\\nabstract contract EIP712 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  CONSTANTS AND IMMUTABLES                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 internal constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    address private immutable _cachedThis;\\n    uint256 private immutable _cachedChainId;\\n    bytes32 private immutable _cachedNameHash;\\n    bytes32 private immutable _cachedVersionHash;\\n    bytes32 private immutable _cachedDomainSeparator;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CONSTRUCTOR                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Cache the hashes for cheaper runtime gas costs.\\n    /// In the case of upgradeable contracts (i.e. proxies),\\n    /// or if the chain id changes due to a hard fork,\\n    /// the domain separator will be seamlessly calculated on-the-fly.\\n    constructor() {\\n        _cachedThis = address(this);\\n        _cachedChainId = block.chainid;\\n\\n        (string memory name, string memory version) = _domainNameAndVersion();\\n        bytes32 nameHash = keccak256(bytes(name));\\n        bytes32 versionHash = keccak256(bytes(version));\\n        _cachedNameHash = nameHash;\\n        _cachedVersionHash = versionHash;\\n\\n        bytes32 separator;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Load the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            separator := keccak256(m, 0xa0)\\n        }\\n        _cachedDomainSeparator = separator;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   FUNCTIONS TO OVERRIDE                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Please override this function to return the domain name and version.\\n    /// ```\\n    ///     function _domainNameAndVersion()\\n    ///         internal\\n    ///         pure\\n    ///         virtual\\n    ///         returns (string memory name, string memory version)\\n    ///     {\\n    ///         name = \\\"Solady\\\";\\n    ///         version = \\\"1\\\";\\n    ///     }\\n    /// ```\\n    function _domainNameAndVersion()\\n        internal\\n        pure\\n        virtual\\n        returns (string memory name, string memory version);\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the EIP-712 domain separator.\\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\\n        separator = _cachedDomainSeparator;\\n        if (_cachedDomainSeparatorInvalidated()) {\\n            separator = _buildDomainSeparator();\\n        }\\n    }\\n\\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\\n    /// given `structHash`, as defined in\\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\\n    ///\\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\\n    /// ```\\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\\n    ///         keccak256(\\\"Mail(address to,string contents)\\\"),\\n    ///         mailTo,\\n    ///         keccak256(bytes(mailContents))\\n    ///     )));\\n    ///     address signer = ECDSA.recover(digest, signature);\\n    /// ```\\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\\n        bytes32 separator = _cachedDomainSeparator;\\n        if (_cachedDomainSeparatorInvalidated()) {\\n            separator = _buildDomainSeparator();\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the digest.\\n            mstore(0x00, 0x1901000000000000) // Store \\\"\\\\x19\\\\x01\\\".\\n            mstore(0x1a, separator) // Store the domain separator.\\n            mstore(0x3a, structHash) // Store the struct hash.\\n            digest := keccak256(0x18, 0x42)\\n            // Restore the part of the free memory slot that was overwritten.\\n            mstore(0x3a, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    EIP-5267 OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        fields = hex\\\"0f\\\"; // `0b01111`.\\n        (name, version) = _domainNameAndVersion();\\n        chainId = block.chainid;\\n        verifyingContract = address(this);\\n        salt = salt; // `bytes32(0)`.\\n        extensions = extensions; // `new uint256[](0)`.\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the EIP-712 domain separator.\\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\\n        bytes32 nameHash = _cachedNameHash;\\n        bytes32 versionHash = _cachedVersionHash;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Load the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            separator := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /// @dev Returns if the cached domain separator has been invalidated.\\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\\n        uint256 cachedChainId = _cachedChainId;\\n        address cachedThis = _cachedThis;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized ECDSA wrapper.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\nlibrary ECDSA {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The signature is invalid.\\n    error InvalidSignature();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The number which `s` must not exceed in order for\\n    /// the signature to be non-malleable.\\n    bytes32 private constant _MALLEABILITY_THRESHOLD =\\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    RECOVERY OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // Note: as of Solady version 0.0.68, these functions will\\n    // revert upon recovery failure for more safety by default.\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Copy the free memory pointer so that we can restore it later.\\n            let m := mload(0x40)\\n            // Copy `r` and `s`.\\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n            let s := mload(add(signature, 0x40))\\n            mstore(0x60, s)\\n            // Store the `hash` in the scratch space.\\n            mstore(0x00, hash)\\n            // Compute `v` and store it in the scratch space.\\n            mstore(0x20, byte(0, mload(add(signature, 0x60))))\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    and(\\n                        // If the signature is exactly 65 bytes in length.\\n                        eq(mload(signature), 65),\\n                        // If `s` in lower half order, such that the signature is not malleable.\\n                        lt(s, add(_MALLEABILITY_THRESHOLD, 1))\\n                    ), // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x00, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            result := mload(0x00)\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                // Store the function selector of `InvalidSignature()`.\\n                mstore(0x00, 0x8baa579f)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the zero slot.\\n            mstore(0x60, 0)\\n            // Restore the free memory pointer.\\n            mstore(0x40, m)\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Copy the free memory pointer so that we can restore it later.\\n            let m := mload(0x40)\\n            // Directly copy `r` and `s` from the calldata.\\n            calldatacopy(0x40, signature.offset, 0x40)\\n            // Store the `hash` in the scratch space.\\n            mstore(0x00, hash)\\n            // Compute `v` and store it in the scratch space.\\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40))))\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    and(\\n                        // If the signature is exactly 65 bytes in length.\\n                        eq(signature.length, 65),\\n                        // If `s` in lower half order, such that the signature is not malleable.\\n                        lt(mload(0x60), add(_MALLEABILITY_THRESHOLD, 1))\\n                    ), // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x00, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            result := mload(0x00)\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                // Store the function selector of `InvalidSignature()`.\\n                mstore(0x00, 0x8baa579f)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the zero slot.\\n            mstore(0x60, 0)\\n            // Restore the free memory pointer.\\n            mstore(0x40, m)\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    ///\\n    /// This function only accepts EIP-2098 short form signatures.\\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\\n    ///\\n    /// To be honest, I do not recommend using EIP-2098 signatures\\n    /// for simplicity, performance, and security reasons. Most if not\\n    /// all clients support traditional non EIP-2098 signatures by default.\\n    /// As such, this method is intentionally not fully inlined.\\n    /// It is merely included for completeness.\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\\n        uint8 v;\\n        bytes32 s;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            s := shr(1, shl(1, vs))\\n            v := add(shr(255, vs), 27)\\n        }\\n        result = recover(hash, v, r, s);\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Copy the free memory pointer so that we can restore it later.\\n            let m := mload(0x40)\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    // If `s` in lower half order, such that the signature is not malleable.\\n                    lt(s, add(_MALLEABILITY_THRESHOLD, 1)), // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x00, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            result := mload(0x00)\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                // Store the function selector of `InvalidSignature()`.\\n                mstore(0x00, 0x8baa579f)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the zero slot.\\n            mstore(0x60, 0)\\n            // Restore the free memory pointer.\\n            mstore(0x40, m)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   TRY-RECOVER OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // WARNING!\\n    // These functions will NOT revert upon recovery failure.\\n    // Instead, they will return the zero address upon recovery failure.\\n    // It is critical that the returned address is NEVER compared against\\n    // a zero address (e.g. an uninitialized address variable).\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function tryRecover(bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(xor(mload(signature), 65)) {\\n                // Copy the free memory pointer so that we can restore it later.\\n                let m := mload(0x40)\\n                // Copy `r` and `s`.\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                let s := mload(add(signature, 0x40))\\n                mstore(0x60, s)\\n                // If `s` in lower half order, such that the signature is not malleable.\\n                if iszero(gt(s, _MALLEABILITY_THRESHOLD)) {\\n                    // Store the `hash` in the scratch space.\\n                    mstore(0x00, hash)\\n                    // Compute `v` and store it in the scratch space.\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60))))\\n                    pop(\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            0x01, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x40, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    )\\n                    // Restore the zero slot.\\n                    mstore(0x60, 0)\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    result := mload(xor(0x60, returndatasize()))\\n                }\\n                // Restore the free memory pointer.\\n                mstore(0x40, m)\\n            }\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(xor(signature.length, 65)) {\\n                // Copy the free memory pointer so that we can restore it later.\\n                let m := mload(0x40)\\n                // Directly copy `r` and `s` from the calldata.\\n                calldatacopy(0x40, signature.offset, 0x40)\\n                // If `s` in lower half order, such that the signature is not malleable.\\n                if iszero(gt(mload(0x60), _MALLEABILITY_THRESHOLD)) {\\n                    // Store the `hash` in the scratch space.\\n                    mstore(0x00, hash)\\n                    // Compute `v` and store it in the scratch space.\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40))))\\n                    pop(\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            0x01, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x40, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    )\\n                    // Restore the zero slot.\\n                    mstore(0x60, 0)\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    result := mload(xor(0x60, returndatasize()))\\n                }\\n                // Restore the free memory pointer.\\n                mstore(0x40, m)\\n            }\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    ///\\n    /// This function only accepts EIP-2098 short form signatures.\\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\\n    ///\\n    /// To be honest, I do not recommend using EIP-2098 signatures\\n    /// for simplicity, performance, and security reasons. Most if not\\n    /// all clients support traditional non EIP-2098 signatures by default.\\n    /// As such, this method is intentionally not fully inlined.\\n    /// It is merely included for completeness.\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        uint8 v;\\n        bytes32 s;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            s := shr(1, shl(1, vs))\\n            v := add(shr(255, vs), 27)\\n        }\\n        result = tryRecover(hash, v, r, s);\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Copy the free memory pointer so that we can restore it later.\\n            let m := mload(0x40)\\n            // If `s` in lower half order, such that the signature is not malleable.\\n            if iszero(gt(s, _MALLEABILITY_THRESHOLD)) {\\n                // Store the `hash`, `v`, `r`, `s` in the scratch space.\\n                mstore(0x00, hash)\\n                mstore(0x20, and(v, 0xff))\\n                mstore(0x40, r)\\n                mstore(0x60, s)\\n                pop(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        0x01, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x40, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                result := mload(xor(0x60, returndatasize()))\\n            }\\n            // Restore the free memory pointer.\\n            mstore(0x40, m)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Store into scratch space for keccak256.\\n            mstore(0x20, hash)\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            // 0x40 - 0x04 = 0x3c\\n            result := keccak256(0x04, 0x3c)\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        assembly {\\n            // The length of \\\"\\\\x19Ethereum Signed Message:\\\\n\\\" is 26 bytes (i.e. 0x1a).\\n            // If we reserve 2 words, we'll have 64 - 26 = 38 bytes to store the\\n            // ASCII decimal representation of the length of `s` up to about 2 ** 126.\\n\\n            // Instead of allocating, we temporarily copy the 64 bytes before the\\n            // start of `s` data to some variables.\\n            let m := mload(sub(s, 0x20))\\n            // The length of `s` is in bytes.\\n            let sLength := mload(s)\\n            let ptr := add(s, 0x20)\\n            let w := not(0)\\n            // `end` marks the end of the memory which we will compute the keccak256 of.\\n            let end := add(ptr, sLength)\\n            // Convert the length of the bytes to ASCII decimal representation\\n            // and store it into the memory.\\n            for { let temp := sLength } 1 {} {\\n                ptr := add(ptr, w) // `sub(ptr, 1)`.\\n                mstore8(ptr, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            // Copy the header over to the memory.\\n            mstore(sub(ptr, 0x20), \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n\\\")\\n            // Compute the keccak256 of the memory.\\n            result := keccak256(sub(ptr, 0x1a), sub(end, sub(ptr, 0x1a)))\\n            // Restore the previous memory.\\n            mstore(s, sLength)\\n            mstore(sub(s, 0x20), m)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/interfaces/IEntryPoint.sol\": {\r\n      \"content\": \"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./UserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\nimport \\\"./INonceManager.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager, INonceManager {\\n\\n    /***\\n     * An event emitted after each successful request\\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\\n     * @param sender - the account that generates this request.\\n     * @param paymaster - if non-null, the paymaster that pays for this request.\\n     * @param nonce - the nonce value from the request.\\n     * @param success - true if the sender transaction succeeded, false if reverted.\\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\\n     */\\n    event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);\\n\\n    /**\\n     * account \\\"sender\\\" was deployed.\\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender the account that is deployed\\n     * @param factory the factory used to deploy this account (in the initCode)\\n     * @param paymaster the paymaster used by this UserOp\\n     */\\n    event AccountDeployed(bytes32 indexed userOpHash, address indexed sender, address factory, address paymaster);\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length\\n     * @param userOpHash the request unique identifier.\\n     * @param sender the sender of this request\\n     * @param nonce the nonce used in the request\\n     * @param revertReason - the return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason);\\n\\n    /**\\n     * an event emitted by handleOps(), before starting the execution loop.\\n     * any event emitted before this event, is part of the validation.\\n     */\\n    event BeforeExecution();\\n\\n    /**\\n     * signature aggregator used by the following UserOperationEvents within this bundle.\\n     */\\n    event SignatureAggregatorChanged(address indexed aggregator);\\n\\n    /**\\n     * a custom revert error of handleOps, to identify the offending op.\\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\\n     *  @param reason - revert reason\\n     *      The string starts with a unique code \\\"AAmn\\\", where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n     *      so a failure can be attributed to the correct entity.\\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n     */\\n    error FailedOp(uint256 opIndex, string reason);\\n\\n    /**\\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    /**\\n     * Successful result from simulateValidation.\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     */\\n    error ValidationResult(ReturnInfo returnInfo,\\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);\\n\\n    /**\\n     * Successful result from simulateValidation, if the account returns a signature aggregator\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\\n     */\\n    error ValidationResultWithAggregation(ReturnInfo returnInfo,\\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo,\\n        AggregatorStakeInfo aggregatorInfo);\\n\\n    /**\\n     * return value of getSenderAddress\\n     */\\n    error SenderAddressResult(address sender);\\n\\n    /**\\n     * return value of simulateHandleOp\\n     */\\n    error ExecutionResult(uint256 preOpGas, uint256 paid, uint48 validAfter, uint48 validUntil, bool targetSuccess, bytes targetResult);\\n\\n    //UserOps handled, per aggregator\\n    struct UserOpsPerAggregator {\\n        UserOperation[] userOps;\\n\\n        // aggregator address\\n        IAggregator aggregator;\\n        // aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation.\\n     * no signature aggregator is used.\\n     * if any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);\\n\\n    /**\\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\\n     * @param userOp the user operation to validate.\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external;\\n\\n    /**\\n     * gas and return values during simulation\\n     * @param preOpGas the gas used for validation (including preValidationGas)\\n     * @param prefund the required prefund for this operation\\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        bool sigFailed;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * returned aggregated signature info.\\n     * the aggregator returned by the account, and its current stake.\\n     */\\n    struct AggregatorStakeInfo {\\n        address aggregator;\\n        StakeInfo stakeInfo;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * this method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n\\n    /**\\n     * simulate full execution of a UserOperation (including both validation and target execution)\\n     * this method will always revert with \\\"ExecutionResult\\\".\\n     * it performs full validation of the UserOperation, but ignores signature error.\\n     * an optional target address is called after the userop succeeds, and its value is returned\\n     * (before the entire call is reverted)\\n     * Note that in order to collect the the success/failure of the target call, it must be executed\\n     * with trace enabled to track the emitted events.\\n     * @param op the UserOperation to simulate\\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\\n     *        are set to the return from that call.\\n     * @param targetCallData callData to pass to target address\\n     */\\n    function simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external;\\n}\\n\\n\"\r\n    },\r\n    \"src/abstract/Compatibility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Compatibility {\\n    receive() external payable {}\\n\\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\\n        external\\n        pure\\n        returns (bytes4)\\n    {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/abstract/KernelStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Importing necessary interfaces\\nimport \\\"account-abstraction/interfaces/IEntryPoint.sol\\\";\\nimport \\\"src/interfaces/IValidator.sol\\\";\\nimport \\\"src/common/Constants.sol\\\";\\nimport \\\"src/common/Structs.sol\\\";\\n\\n/// @title Kernel Storage Contract\\n/// @author taek<leekt216@gmail.com>\\n/// @notice This contract serves as the storage module for the Kernel contract.\\n/// @dev This contract should only be used by the main Kernel contract.\\ncontract KernelStorage {\\n    IEntryPoint public immutable entryPoint; // The entry point of the contract\\n\\n    // Event declarations\\n    event Upgraded(address indexed newImplementation);\\n    event DefaultValidatorChanged(address indexed oldValidator, address indexed newValidator);\\n    event ExecutionChanged(bytes4 indexed selector, address indexed executor, address indexed validator);\\n\\n    // Error declarations\\n    error NotAuthorizedCaller();\\n    error AlreadyInitialized();\\n\\n    // Modifier to check if the function is called by the entry point, the contract itself or the owner\\n    modifier onlyFromEntryPointOrSelf() {\\n        if (msg.sender != address(entryPoint) && msg.sender != address(this)) {\\n            revert NotAuthorizedCaller();\\n        }\\n        _;\\n    }\\n\\n    /// @param _entryPoint The address of the EntryPoint contract\\n    /// @dev Sets up the EntryPoint contract address\\n    constructor(IEntryPoint _entryPoint) {\\n        entryPoint = _entryPoint;\\n        getKernelStorage().defaultValidator = IKernelValidator(address(1));\\n    }\\n\\n    // Function to initialize the wallet kernel\\n    function initialize(IKernelValidator _defaultValidator, bytes calldata _data) external payable {\\n        _setInitialData(_defaultValidator, _data);\\n    }\\n\\n    // Function to get the wallet kernel storage\\n    function getKernelStorage() internal pure returns (WalletKernelStorage storage ws) {\\n        assembly {\\n            ws.slot := KERNEL_STORAGE_SLOT\\n        }\\n    }\\n\\n    // Function to upgrade the contract to a new implementation\\n    function upgradeTo(address _newImplementation) external payable onlyFromEntryPointOrSelf {\\n        assembly {\\n            sstore(IMPLEMENTATION_SLOT, _newImplementation)\\n        }\\n        emit Upgraded(_newImplementation);\\n    }\\n\\n    // Functions to get the nonce from the entry point\\n    function getNonce() public view virtual returns (uint256) {\\n        return entryPoint.getNonce(address(this), 0);\\n    }\\n\\n    function getNonce(uint192 key) public view virtual returns (uint256) {\\n        return entryPoint.getNonce(address(this), key);\\n    }\\n\\n    // query storage\\n    function getDefaultValidator() public view returns (IKernelValidator validator) {\\n        assembly {\\n            validator := shr(80, sload(KERNEL_STORAGE_SLOT_1))\\n        }\\n    }\\n\\n    function getDisabledMode() public view returns (bytes4 disabled) {\\n        assembly {\\n            disabled := shl(224, sload(KERNEL_STORAGE_SLOT_1))\\n        }\\n    }\\n\\n    function getLastDisabledTime() public view returns (uint48) {\\n        return getKernelStorage().lastDisabledTime;\\n    }\\n\\n    /// @notice Returns the execution details for a specific function signature\\n    /// @dev This function can be used to get execution details for a specific function signature\\n    /// @param _selector The function signature\\n    /// @return ExecutionDetail struct containing the execution details\\n    function getExecution(bytes4 _selector) public view returns (ExecutionDetail memory) {\\n        return getKernelStorage().execution[_selector];\\n    }\\n\\n    /// @notice Changes the execution details for a specific function selector\\n    /// @dev This function can only be called from the EntryPoint contract, the contract owner, or itself\\n    /// @param _selector The selector of the function for which execution details are being set\\n    /// @param _executor The executor to be associated with the function selector\\n    /// @param _validator The validator contract that will be responsible for validating operations associated with this function selector\\n    /// @param _validUntil The timestamp until which the execution details are valid\\n    /// @param _validAfter The timestamp after which the execution details are valid\\n    function setExecution(\\n        bytes4 _selector,\\n        address _executor,\\n        IKernelValidator _validator,\\n        uint48 _validUntil,\\n        uint48 _validAfter,\\n        bytes calldata _enableData\\n    ) external payable onlyFromEntryPointOrSelf {\\n        getKernelStorage().execution[_selector] = ExecutionDetail({\\n            executor: _executor,\\n            validator: _validator,\\n            validUntil: ValidUntil.wrap(_validUntil),\\n            validAfter: ValidAfter.wrap(_validAfter)\\n        });\\n        _validator.enable(_enableData);\\n        emit ExecutionChanged(_selector, _executor, address(_validator));\\n    }\\n\\n    function setDefaultValidator(IKernelValidator _defaultValidator, bytes calldata _data)\\n        external\\n        payable\\n        onlyFromEntryPointOrSelf\\n    {\\n        IKernelValidator oldValidator = getKernelStorage().defaultValidator;\\n        getKernelStorage().defaultValidator = _defaultValidator;\\n        emit DefaultValidatorChanged(address(oldValidator), address(_defaultValidator));\\n        _defaultValidator.enable(_data);\\n    }\\n\\n    /// @notice Updates the disabled mode\\n    /// @dev This function can be used to update the disabled mode\\n    /// @param _disableFlag The new disabled mode\\n    function disableMode(bytes4 _disableFlag) external payable onlyFromEntryPointOrSelf {\\n        getKernelStorage().disabledMode = _disableFlag;\\n        getKernelStorage().lastDisabledTime = uint48(block.timestamp);\\n    }\\n\\n    function _setInitialData(IKernelValidator _defaultValidator, bytes calldata _data) internal virtual {\\n        address validator;\\n        assembly {\\n            validator := shr(80, sload(KERNEL_STORAGE_SLOT_1))\\n        }\\n        if (address(validator) != address(0)) {\\n            revert AlreadyInitialized();\\n        }\\n        getKernelStorage().defaultValidator = _defaultValidator;\\n        _defaultValidator.enable(_data);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/KernelHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {SIG_VALIDATION_FAILED_UINT} from \\\"src/common/Constants.sol\\\";\\nimport {ValidationData} from \\\"src/common/Types.sol\\\";\\n\\nfunction _intersectValidationData(ValidationData a, ValidationData b) pure returns (ValidationData validationData) {\\n    assembly {\\n        // xor(a,b) == shows only matching bits\\n        // and(xor(a,b), 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff) == filters out the validAfter and validUntil bits\\n        // if the result is not zero, then aggregator part is not matching\\n        switch iszero(and(xor(a, b), 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff))\\n        case 1 {\\n            // validAfter\\n            let a_vd := and(0xffffffffffff000000000000ffffffffffffffffffffffffffffffffffffffff, a)\\n            let b_vd := and(0xffffffffffff000000000000ffffffffffffffffffffffffffffffffffffffff, b)\\n            validationData := xor(a_vd, mul(xor(a_vd, b_vd), gt(b_vd, a_vd)))\\n            // validUntil\\n            a_vd := and(0x000000000000ffffffffffff0000000000000000000000000000000000000000, a)\\n            b_vd := and(0x000000000000ffffffffffff0000000000000000000000000000000000000000, b)\\n            let until := xor(a_vd, mul(xor(a_vd, b_vd), lt(b_vd, a_vd)))\\n            if iszero(until) { until := 0x000000000000ffffffffffff0000000000000000000000000000000000000000 }\\n            validationData := or(validationData, until)\\n        }\\n        default { validationData := SIG_VALIDATION_FAILED_UINT }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/common/Constants.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// constants for kernel metadata\\nstring constant KERNEL_NAME = \\\"Kernel\\\";\\nstring constant KERNEL_VERSION = \\\"0.2.1\\\";\\n\\n// ERC4337 constants\\nuint256 constant SIG_VALIDATION_FAILED_UINT = 1;\\n\\n// STRUCT_HASH\\nbytes32 constant VALIDATOR_APPROVED_STRUCT_HASH = 0x3ce406685c1b3551d706d85a68afdaa49ac4e07b451ad9b8ff8b58c3ee964176;\\n\\n// Storage slots\\nbytes32 constant KERNEL_STORAGE_SLOT = 0x439ffe7df606b78489639bc0b827913bd09e1246fa6802968a5b3694c53e0dd8;\\nbytes32 constant KERNEL_STORAGE_SLOT_1 = 0x439ffe7df606b78489639bc0b827913bd09e1246fa6802968a5b3694c53e0dd9;\\nbytes32 constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\"\r\n    },\r\n    \"src/common/Enum.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nenum Operation {\\n    Call,\\n    DelegateCall\\n}\\n\\nenum ParamCondition {\\n    EQUAL,\\n    GREATER_THAN,\\n    LESS_THAN,\\n    GREATER_THAN_OR_EQUAL,\\n    LESS_THAN_OR_EQUAL,\\n    NOT_EQUAL\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {UserOperation} from \\\"account-abstraction/interfaces/UserOperation.sol\\\";\\nimport \\\"src/common/Types.sol\\\";\\n\\ninterface IKernelValidator {\\n    function enable(bytes calldata _data) external payable;\\n\\n    function disable(bytes calldata _data) external payable;\\n\\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingFunds)\\n        external\\n        payable\\n        returns (ValidationData);\\n\\n    function validateSignature(bytes32 hash, bytes calldata signature) external view returns (ValidationData);\\n\\n    function validCaller(address caller, bytes calldata data) external view returns (bool);\\n}\\n\\n// 3 modes\\n// 1. default mode, use preset validator for the kernel\\n// 2. enable mode, enable a new validator for given action and use it for current userOp\\n// 3. sudo mode, use default plugin for current userOp\\n\"\r\n    },\r\n    \"src/common/Types.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.9;\\n\\nimport \\\"src/common/Constants.sol\\\";\\n\\ntype ValidAfter is uint48;\\n\\ntype ValidUntil is uint48;\\n\\ntype ValidationData is uint256;\\n\\nValidationData constant SIG_VALIDATION_FAILED = ValidationData.wrap(SIG_VALIDATION_FAILED_UINT);\\n\\nfunction packValidationData(ValidAfter validAfter, ValidUntil validUntil) pure returns (ValidationData) {\\n    return ValidationData.wrap(\\n        uint256(ValidAfter.unwrap(validAfter)) << 208 | uint256(ValidUntil.unwrap(validUntil)) << 160\\n    );\\n}\\n\\nfunction parseValidationData(ValidationData validationData)\\n    pure\\n    returns (ValidAfter validAfter, ValidUntil validUntil, address result)\\n{\\n    assembly {\\n        result := validationData\\n        validUntil := and(shr(160, validationData), 0xffffffffffff)\\n        switch iszero(validUntil)\\n        case 1 { validUntil := 0xffffffffffff }\\n        validAfter := shr(208, validationData)\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/interfaces/UserOperation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport {calldataKeccak} from \\\"../core/Helpers.sol\\\";\\n\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request.\\n     * @param nonce unique value the sender uses to verify it is not a replay.\\n     * @param initCode if set, the account contract will be created by this constructor/\\n     * @param callData the method call to execute on this account.\\n     * @param callGasLimit the gas limit passed to the callData method call.\\n     * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\\n     * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n     * @param maxFeePerGas same as EIP-1559 gas parameter.\\n     * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\\n     * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\\n     * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n     */\\n    struct UserOperation {\\n\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n        bytes paymasterAndData;\\n        bytes signature;\\n    }\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {data := calldataload(userOp)}\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\\n    unchecked {\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        if (maxFeePerGas == maxPriorityFeePerGas) {\\n            //legacy mode (for networks that don't support basefee opcode)\\n            return maxFeePerGas;\\n        }\\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n    }\\n    }\\n\\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        uint256 callGasLimit = userOp.callGasLimit;\\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return abi.encode(\\n            sender, nonce,\\n            hashInitCode, hashCallData,\\n            callGasLimit, verificationGasLimit, preVerificationGas,\\n            maxFeePerGas, maxPriorityFeePerGas,\\n            hashPaymasterAndData\\n        );\\n    }\\n\\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/interfaces/IStakeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n\\n    event Deposited(\\n        address indexed account,\\n        uint256 totalDeposit\\n    );\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /// Emitted when stake or unstake delay are modified\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 unstakeDelaySec\\n    );\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeUnlocked(\\n        address indexed account,\\n        uint256 withdrawTime\\n    );\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit the entity's deposit\\n     * @param staked true if this entity is staked.\\n     * @param stake actual amount of ether staked for this entity.\\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\\n     *    and the rest fit into a 2nd cell.\\n     *    112 bit allows for 10^15 eth\\n     *    48 bit for full timestamp\\n     *    32 bit allows 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint112 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint48 withdrawTime;\\n    }\\n\\n    //API struct used by getStakeInfo and simulateValidation\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    /// @return info - full deposit information of given account\\n    function getDepositInfo(address account) external view returns (DepositInfo memory info);\\n\\n    /// @return the deposit (for gas payment) of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 _unstakeDelaySec) external payable;\\n\\n    /**\\n     * attempt to unlock the stake.\\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external;\\n\\n    /**\\n     * withdraw from the (unlocked) stake.\\n     * must first call unlockStake and wait for the unstakeDelay to pass\\n     * @param withdrawAddress the address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external;\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/interfaces/IAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n\\n    /**\\n     * validate aggregated signature.\\n     * revert if the aggregated signature does not match the given list of operations.\\n     */\\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature) external view;\\n\\n    /**\\n     * validate signature of a single userOp\\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n     * @param userOp the userOperation received from the user.\\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\\n     *    (usually empty, unless account and aggregator support some kind of \\\"multisig\\\"\\n     */\\n    function validateUserOpSignature(UserOperation calldata userOp)\\n    external view returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code perform this aggregation\\n     * @param userOps array of UserOperations to collect the signatures from.\\n     * @return aggregatedSignature the aggregated signature\\n     */\\n    function aggregateSignatures(UserOperation[] calldata userOps) external view returns (bytes memory aggregatedSignature);\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/interfaces/INonceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\ninterface INonceManager {\\n\\n    /**\\n     * Return the next nonce for this sender.\\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\\n     * But UserOp with different keys can come with arbitrary order.\\n     *\\n     * @param sender the account address\\n     * @param key the high 192 bit of the nonce\\n     * @return nonce a full nonce to pass for next UserOp with this sender.\\n     */\\n    function getNonce(address sender, uint192 key)\\n    external view returns (uint256 nonce);\\n\\n    /**\\n     * Manually increment the nonce of the sender.\\n     * This method is exposed just for completeness..\\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\\n     * as the EntryPoint will update the nonce regardless.\\n     * Possible use-case is call it with various keys to \\\"initialize\\\" their nonces to one, so that future\\n     * UserOperations will not pay extra for the first transaction with a given key.\\n     */\\n    function incrementNonce(uint192 key) external;\\n}\\n\"\r\n    },\r\n    \"src/common/Structs.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport \\\"src/interfaces/IValidator.sol\\\";\\nimport \\\"src/common/Enum.sol\\\";\\nimport \\\"src/common/Types.sol\\\";\\n\\n// Defining a struct for execution details\\nstruct ExecutionDetail {\\n    ValidAfter validAfter; // Until what time is this execution valid\\n    ValidUntil validUntil; // After what time is this execution valid\\n    address executor; // Who is the executor of this execution\\n    IKernelValidator validator; // The validator for this execution\\n}\\n\\n// Defining a struct for wallet kernel storage\\nstruct WalletKernelStorage {\\n    bytes32 __deprecated; // A deprecated field\\n    bytes4 disabledMode; // Mode which is currently disabled\\n    uint48 lastDisabledTime; // Last time when a mode was disabled\\n    IKernelValidator defaultValidator; // Default validator for the wallet\\n    mapping(bytes4 => ExecutionDetail) execution; // Mapping of function selectors to execution details\\n}\\n\\n// Param Rule for session key\\nstruct ParamRule {\\n    uint256 offset;\\n    ParamCondition condition;\\n    bytes32 param;\\n}\\n\\nstruct Permission {\\n    address target;\\n    uint256 valueLimit;\\n    bytes4 sig;\\n    ParamRule[] rules;\\n    Operation operation;\\n}\\n\\nstruct SessionData {\\n    bytes32 merkleRoot;\\n    ValidAfter validAfter;\\n    ValidUntil validUntil;\\n    address paymaster; // address(0) means accept userOp without paymaster, address(1) means reject userOp with paymaster, other address means accept userOp with paymaster with the address\\n    bool enabled;\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/core/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n/**\\n * returned data from validateUserOp.\\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and parsed by `_parseValidationData`\\n * @param aggregator - address(0) - the account validated the signature by itself.\\n *              address(1) - the account failed to validate the signature.\\n *              otherwise - this is an address of a signature aggregator that must be used to validate the signature.\\n * @param validAfter - this UserOp is valid only after this timestamp.\\n * @param validaUntil - this UserOp is valid only up to this timestamp.\\n */\\n    struct ValidationData {\\n        address aggregator;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n    }\\n\\n//extract sigFailed, validAfter, validUntil.\\n// also convert zero validUntil to type(uint48).max\\n    function _parseValidationData(uint validationData) pure returns (ValidationData memory data) {\\n        address aggregator = address(uint160(validationData));\\n        uint48 validUntil = uint48(validationData >> 160);\\n        if (validUntil == 0) {\\n            validUntil = type(uint48).max;\\n        }\\n        uint48 validAfter = uint48(validationData >> (48 + 160));\\n        return ValidationData(aggregator, validAfter, validUntil);\\n    }\\n\\n// intersect account and paymaster ranges.\\n    function _intersectTimeRange(uint256 validationData, uint256 paymasterValidationData) pure returns (ValidationData memory) {\\n        ValidationData memory accountValidationData = _parseValidationData(validationData);\\n        ValidationData memory pmValidationData = _parseValidationData(paymasterValidationData);\\n        address aggregator = accountValidationData.aggregator;\\n        if (aggregator == address(0)) {\\n            aggregator = pmValidationData.aggregator;\\n        }\\n        uint48 validAfter = accountValidationData.validAfter;\\n        uint48 validUntil = accountValidationData.validUntil;\\n        uint48 pmValidAfter = pmValidationData.validAfter;\\n        uint48 pmValidUntil = pmValidationData.validUntil;\\n\\n        if (validAfter < pmValidAfter) validAfter = pmValidAfter;\\n        if (validUntil > pmValidUntil) validUntil = pmValidUntil;\\n        return ValidationData(aggregator, validAfter, validUntil);\\n    }\\n\\n/**\\n * helper to pack the return value for validateUserOp\\n * @param data - the ValidationData to pack\\n */\\n    function _packValidationData(ValidationData memory data) pure returns (uint256) {\\n        return uint160(data.aggregator) | (uint256(data.validUntil) << 160) | (uint256(data.validAfter) << (160 + 48));\\n    }\\n\\n/**\\n * helper to pack the return value for validateUserOp, when not using an aggregator\\n * @param sigFailed - true for signature failure, false for success\\n * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\\n * @param validAfter first timestamp this UserOperation is valid\\n */\\n    function _packValidationData(bool sigFailed, uint48 validUntil, uint48 validAfter) pure returns (uint256) {\\n        return (sigFailed ? 1 : 0) | (uint256(validUntil) << 160) | (uint256(validAfter) << (160 + 48));\\n    }\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n */\\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n        assembly {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"account-abstraction/=lib/account-abstraction/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"solady/=lib/solady/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract IEntryPoint\",\"name\":\"_entryPoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DeploymentFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SaltDoesNotStartWithCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"unstakeDelaySec\",\"type\":\"uint32\"}],\"name\":\"addStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"createAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPoint\",\"outputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getAccountAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initCodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAllowedImplementation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownershipHandoverValidFor\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"predictDeterministicAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"predicted\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"_entryPoint\",\"type\":\"address\"}],\"name\":\"setEntryPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"withdrawAddress\",\"type\":\"address\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "KernelFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009775137314fe595c943712b0b336327dfa80ae8a0000000000000000000000005ff137d4b0fdcd49dca30c7cf57e578a026d2789", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}