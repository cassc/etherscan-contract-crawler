{"SourceCode": "pragma solidity ^0.5.17;\r\n\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Uint256Helpers.sol\r\n// Adapted to use pragma ^0.5.17 and satisfy our linter rules\r\nlibrary Uint256Helpers {\r\n    uint256 private constant MAX_UINT8 = uint8(-1);\r\n    uint256 private constant MAX_UINT64 = uint64(-1);\r\n\r\n    string private constant ERROR_UINT8_NUMBER_TOO_BIG = \"UINT8_NUMBER_TOO_BIG\";\r\n    string private constant ERROR_UINT64_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\r\n\r\n    function toUint8(uint256 a) internal pure returns (uint8) {\r\n        require(a <= MAX_UINT8, ERROR_UINT8_NUMBER_TOO_BIG);\r\n        return uint8(a);\r\n    }\r\n\r\n    function toUint64(uint256 a) internal pure returns (uint64) {\r\n        require(a <= MAX_UINT64, ERROR_UINT64_NUMBER_TOO_BIG);\r\n        return uint64(a);\r\n    }\r\n}\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _who) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\ninterface IArbitrator {\r\n    /**\r\n    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\r\n    * @param _possibleRulings Number of possible rulings allowed for the dispute\r\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\r\n    * @return Dispute identification number\r\n    */\r\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256);\r\n\r\n    /**\r\n    * @dev Submit evidence for a dispute\r\n    * @param _disputeId Id of the dispute in the Court\r\n    * @param _submitter Address of the account submitting the evidence\r\n    * @param _evidence Data submitted for the evidence related to the dispute\r\n    */\r\n    function submitEvidence(uint256 _disputeId, address _submitter, bytes calldata _evidence) external;\r\n\r\n    /**\r\n    * @dev Close the evidence period of a dispute\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function closeEvidencePeriod(uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @notice Rule dispute #`_disputeId` if ready\r\n    * @param _disputeId Identification number of the dispute to be ruled\r\n    * @return subject Subject associated to the dispute\r\n    * @return ruling Ruling number computed for the given dispute\r\n    */\r\n    function rule(uint256 _disputeId) external returns (address subject, uint256 ruling);\r\n\r\n    /**\r\n    * @dev Tell the dispute fees information to create a dispute\r\n    * @return recipient Address where the corresponding dispute fees must be transferred to\r\n    * @return feeToken ERC20 token used for the fees\r\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\r\n    */\r\n    function getDisputeFees() external view returns (address recipient, IERC20 feeToken, uint256 feeAmount);\r\n\r\n    /**\r\n    * @dev Tell the payments recipient address\r\n    * @return Address of the payments recipient module\r\n    */\r\n    function getPaymentsRecipient() external view returns (address);\r\n}\r\n\r\n/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n/**\r\n* @dev The Arbitrable instances actually don't require to follow any specific interface.\r\n*      Note that this is actually optional, although it does allow the Court to at least have a way to identify a specific set of instances.\r\n*/\r\ncontract IArbitrable {\r\n    /**\r\n    * @dev Emitted when an IArbitrable instance's dispute is ruled by an IArbitrator\r\n    * @param arbitrator IArbitrator instance ruling the dispute\r\n    * @param disputeId Identification number of the dispute being ruled by the arbitrator\r\n    * @param ruling Ruling given by the arbitrator\r\n    */\r\n    event Ruled(IArbitrator indexed arbitrator, uint256 indexed disputeId, uint256 ruling);\r\n}\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/IsContract.sol\r\n// Adapted to use pragma ^0.5.17 and satisfy our linter rules\r\ncontract IsContract {\r\n    /*\r\n    * NOTE: this should NEVER be used for authentication\r\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\r\n    *\r\n    * This is only intended to be used as a sanity check that an address is actually a contract,\r\n    * RATHER THAN an address not being a contract.\r\n    */\r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly { size := extcodesize(_target) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ncontract ACL {\r\n    string private constant ERROR_BAD_FREEZE = \"ACL_BAD_FREEZE\";\r\n    string private constant ERROR_ROLE_ALREADY_FROZEN = \"ACL_ROLE_ALREADY_FROZEN\";\r\n    string private constant ERROR_INVALID_BULK_INPUT = \"ACL_INVALID_BULK_INPUT\";\r\n\r\n    enum BulkOp { Grant, Revoke, Freeze }\r\n\r\n    address internal constant FREEZE_FLAG = address(1);\r\n    address internal constant ANY_ADDR = address(-1);\r\n\r\n    // List of all roles assigned to different addresses\r\n    mapping (bytes32 => mapping (address => bool)) public roles;\r\n\r\n    event Granted(bytes32 indexed id, address indexed who);\r\n    event Revoked(bytes32 indexed id, address indexed who);\r\n    event Frozen(bytes32 indexed id);\r\n\r\n    /**\r\n    * @dev Tell whether an address has a role assigned\r\n    * @param _who Address being queried\r\n    * @param _id ID of the role being checked\r\n    * @return True if the requested address has assigned the given role, false otherwise\r\n    */\r\n    function hasRole(address _who, bytes32 _id) public view returns (bool) {\r\n        return roles[_id][_who] || roles[_id][ANY_ADDR];\r\n    }\r\n\r\n    /**\r\n    * @dev Tell whether a role is frozen\r\n    * @param _id ID of the role being checked\r\n    * @return True if the given role is frozen, false otherwise\r\n    */\r\n    function isRoleFrozen(bytes32 _id) public view returns (bool) {\r\n        return roles[_id][FREEZE_FLAG];\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to grant a role to a given address\r\n    * @param _id ID of the role to be granted\r\n    * @param _who Address to grant the role to\r\n    */\r\n    function _grant(bytes32 _id, address _who) internal {\r\n        require(!isRoleFrozen(_id), ERROR_ROLE_ALREADY_FROZEN);\r\n        require(_who != FREEZE_FLAG, ERROR_BAD_FREEZE);\r\n\r\n        if (!hasRole(_who, _id)) {\r\n            roles[_id][_who] = true;\r\n            emit Granted(_id, _who);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to revoke a role from a given address\r\n    * @param _id ID of the role to be revoked\r\n    * @param _who Address to revoke the role from\r\n    */\r\n    function _revoke(bytes32 _id, address _who) internal {\r\n        require(!isRoleFrozen(_id), ERROR_ROLE_ALREADY_FROZEN);\r\n\r\n        if (hasRole(_who, _id)) {\r\n            roles[_id][_who] = false;\r\n            emit Revoked(_id, _who);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to freeze a role\r\n    * @param _id ID of the role to be frozen\r\n    */\r\n    function _freeze(bytes32 _id) internal {\r\n        require(!isRoleFrozen(_id), ERROR_ROLE_ALREADY_FROZEN);\r\n        roles[_id][FREEZE_FLAG] = true;\r\n        emit Frozen(_id);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to enact a bulk list of ACL operations\r\n    */\r\n    function _bulk(BulkOp[] memory _op, bytes32[] memory _id, address[] memory _who) internal {\r\n        require(_op.length == _id.length && _op.length == _who.length, ERROR_INVALID_BULK_INPUT);\r\n\r\n        for (uint256 i = 0; i < _op.length; i++) {\r\n            BulkOp op = _op[i];\r\n            if (op == BulkOp.Grant) {\r\n                _grant(_id[i], _who[i]);\r\n            } else if (op == BulkOp.Revoke) {\r\n                _revoke(_id[i], _who[i]);\r\n            } else if (op == BulkOp.Freeze) {\r\n                _freeze(_id[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract ModuleIds {\r\n    // DisputeManager module ID - keccak256(abi.encodePacked(\"DISPUTE_MANAGER\"))\r\n    bytes32 internal constant MODULE_ID_DISPUTE_MANAGER = 0x14a6c70f0f6d449c014c7bbc9e68e31e79e8474fb03b7194df83109a2d888ae6;\r\n\r\n    // GuardiansRegistry module ID - keccak256(abi.encodePacked(\"GUARDIANS_REGISTRY\"))\r\n    bytes32 internal constant MODULE_ID_GUARDIANS_REGISTRY = 0x8af7b7118de65da3b974a3fd4b0c702b66442f74b9dff6eaed1037254c0b79fe;\r\n\r\n    // Voting module ID - keccak256(abi.encodePacked(\"VOTING\"))\r\n    bytes32 internal constant MODULE_ID_VOTING = 0x7cbb12e82a6d63ff16fe43977f43e3e2b247ecd4e62c0e340da8800a48c67346;\r\n\r\n    // PaymentsBook module ID - keccak256(abi.encodePacked(\"PAYMENTS_BOOK\"))\r\n    bytes32 internal constant MODULE_ID_PAYMENTS_BOOK = 0xfa275b1417437a2a2ea8e91e9fe73c28eaf0a28532a250541da5ac0d1892b418;\r\n\r\n    // Treasury module ID - keccak256(abi.encodePacked(\"TREASURY\"))\r\n    bytes32 internal constant MODULE_ID_TREASURY = 0x06aa03964db1f7257357ef09714a5f0ca3633723df419e97015e0c7a3e83edb7;\r\n}\r\n\r\ninterface IModulesLinker {\r\n    /**\r\n    * @notice Update the implementations of a list of modules\r\n    * @param _ids List of IDs of the modules to be updated\r\n    * @param _addresses List of module addresses to be updated\r\n    */\r\n    function linkModules(bytes32[] calldata _ids, address[] calldata _addresses) external;\r\n}\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath64.sol\r\n// Adapted to use pragma ^0.5.17 and satisfy our linter rules\r\n/**\r\n * @title SafeMath64\r\n * @dev Math operations for uint64 with safety checks that revert on error\r\n */\r\nlibrary SafeMath64 {\r\n    string private constant ERROR_ADD_OVERFLOW = \"MATH64_ADD_OVERFLOW\";\r\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH64_SUB_UNDERFLOW\";\r\n    string private constant ERROR_MUL_OVERFLOW = \"MATH64_MUL_OVERFLOW\";\r\n    string private constant ERROR_DIV_ZERO = \"MATH64_DIV_ZERO\";\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        uint256 c = uint256(_a) * uint256(_b);\r\n        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\r\n\r\n        return uint64(c);\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\r\n        uint64 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\r\n        uint64 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\r\n        uint64 c = _a + _b;\r\n        require(c >= _a, ERROR_ADD_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b != 0, ERROR_DIV_ZERO);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/TimeHelpers.sol\r\n// Adapted to use pragma ^0.5.17 and satisfy our linter rules\r\ncontract TimeHelpers {\r\n    using Uint256Helpers for uint256;\r\n\r\n    /**\r\n    * @dev Returns the current block number.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber() internal view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current block number, converted to uint64.\r\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\r\n    *      tests.\r\n    */\r\n    function getBlockNumber64() internal view returns (uint64) {\r\n        return getBlockNumber().toUint64();\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp() internal view returns (uint256) {\r\n        return block.timestamp; // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current timestamp, converted to uint64.\r\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\r\n    *      tests.\r\n    */\r\n    function getTimestamp64() internal view returns (uint64) {\r\n        return getTimestamp().toUint64();\r\n    }\r\n}\r\n\r\ninterface IClock {\r\n    /**\r\n    * @dev Ensure that the current term of the clock is up-to-date\r\n    * @return Identification number of the current term\r\n    */\r\n    function ensureCurrentTerm() external returns (uint64);\r\n\r\n    /**\r\n    * @dev Transition up to a certain number of terms to leave the clock up-to-date\r\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\r\n    * @return Identification number of the term ID after executing the heartbeat transitions\r\n    */\r\n    function heartbeat(uint64 _maxRequestedTransitions) external returns (uint64);\r\n\r\n    /**\r\n    * @dev Ensure that a certain term has its randomness set\r\n    * @return Randomness of the current term\r\n    */\r\n    function ensureCurrentTermRandomness() external returns (bytes32);\r\n\r\n    /**\r\n    * @dev Tell the last ensured term identification number\r\n    * @return Identification number of the last ensured term\r\n    */\r\n    function getLastEnsuredTermId() external view returns (uint64);\r\n\r\n    /**\r\n    * @dev Tell the current term identification number. Note that there may be pending term transitions.\r\n    * @return Identification number of the current term\r\n    */\r\n    function getCurrentTermId() external view returns (uint64);\r\n\r\n    /**\r\n    * @dev Tell the number of terms the clock should transition to be up-to-date\r\n    * @return Number of terms the clock should transition to be up-to-date\r\n    */\r\n    function getNeededTermTransitions() external view returns (uint64);\r\n\r\n    /**\r\n    * @dev Tell the information related to a term based on its ID\r\n    * @param _termId ID of the term being queried\r\n    * @return startTime Term start time\r\n    * @return randomnessBN Block number used for randomness in the requested term\r\n    * @return randomness Randomness computed for the requested term\r\n    */\r\n    function getTerm(uint64 _termId) external view returns (uint64 startTime, uint64 randomnessBN, bytes32 randomness);\r\n\r\n    /**\r\n    * @dev Tell the randomness of a term even if it wasn't computed yet\r\n    * @param _termId Identification number of the term being queried\r\n    * @return Randomness of the requested term\r\n    */\r\n    function getTermRandomness(uint64 _termId) external view returns (bytes32);\r\n}\r\n\r\ncontract CourtClock is IClock, TimeHelpers {\r\n    using SafeMath64 for uint64;\r\n\r\n    string private constant ERROR_TERM_DOES_NOT_EXIST = \"CLK_TERM_DOES_NOT_EXIST\";\r\n    string private constant ERROR_TERM_DURATION_TOO_LONG = \"CLK_TERM_DURATION_TOO_LONG\";\r\n    string private constant ERROR_TERM_RANDOMNESS_NOT_YET = \"CLK_TERM_RANDOMNESS_NOT_YET\";\r\n    string private constant ERROR_TERM_RANDOMNESS_UNAVAILABLE = \"CLK_TERM_RANDOMNESS_UNAVAILABLE\";\r\n    string private constant ERROR_BAD_FIRST_TERM_START_TIME = \"CLK_BAD_FIRST_TERM_START_TIME\";\r\n    string private constant ERROR_TOO_MANY_TRANSITIONS = \"CLK_TOO_MANY_TRANSITIONS\";\r\n    string private constant ERROR_INVALID_TRANSITION_TERMS = \"CLK_INVALID_TRANSITION_TERMS\";\r\n    string private constant ERROR_CANNOT_DELAY_STARTED_COURT = \"CLK_CANNOT_DELAY_STARTED_PROT\";\r\n    string private constant ERROR_CANNOT_DELAY_PAST_START_TIME = \"CLK_CANNOT_DELAY_PAST_START_TIME\";\r\n\r\n    // Maximum number of term transitions a callee may have to assume in order to call certain functions that require the Court being up-to-date\r\n    uint64 internal constant MAX_AUTO_TERM_TRANSITIONS_ALLOWED = 1;\r\n\r\n    // Max duration in seconds that a term can last\r\n    uint64 internal constant MAX_TERM_DURATION = 365 days;\r\n\r\n    // Max time until first term starts since contract is deployed\r\n    uint64 internal constant MAX_FIRST_TERM_DELAY_PERIOD = 2 * MAX_TERM_DURATION;\r\n\r\n    struct Term {\r\n        uint64 startTime;              // Timestamp when the term started\r\n        uint64 randomnessBN;           // Block number for entropy\r\n        bytes32 randomness;            // Entropy from randomnessBN block hash\r\n    }\r\n\r\n    // Duration in seconds for each term of the Court\r\n    uint64 private termDuration;\r\n\r\n    // Last ensured term id\r\n    uint64 private termId;\r\n\r\n    // List of Court terms indexed by id\r\n    mapping (uint64 => Term) private terms;\r\n\r\n    event Heartbeat(uint64 previousTermId, uint64 currentTermId);\r\n    event StartTimeDelayed(uint64 previousStartTime, uint64 currentStartTime);\r\n\r\n    /**\r\n    * @dev Ensure a certain term has already been processed\r\n    * @param _termId Identification number of the term to be checked\r\n    */\r\n    modifier termExists(uint64 _termId) {\r\n        require(_termId <= termId, ERROR_TERM_DOES_NOT_EXIST);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _termParams Array containing:\r\n    *        0. _termDuration Duration in seconds per term\r\n    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for guardian on-boarding)\r\n    */\r\n    constructor(uint64[2] memory _termParams) public {\r\n        uint64 _termDuration = _termParams[0];\r\n        uint64 _firstTermStartTime = _termParams[1];\r\n\r\n        require(_termDuration < MAX_TERM_DURATION, ERROR_TERM_DURATION_TOO_LONG);\r\n        require(_firstTermStartTime >= getTimestamp64() + _termDuration, ERROR_BAD_FIRST_TERM_START_TIME);\r\n        require(_firstTermStartTime <= getTimestamp64() + MAX_FIRST_TERM_DELAY_PERIOD, ERROR_BAD_FIRST_TERM_START_TIME);\r\n\r\n        termDuration = _termDuration;\r\n\r\n        // No need for SafeMath: we already checked values above\r\n        terms[0].startTime = _firstTermStartTime - _termDuration;\r\n    }\r\n\r\n    /**\r\n    * @notice Ensure that the current term of the Court is up-to-date. If the Court is outdated by more than `MAX_AUTO_TERM_TRANSITIONS_ALLOWED`\r\n    *         terms, the heartbeat function must be called manually instead.\r\n    * @return Identification number of the current term\r\n    */\r\n    function ensureCurrentTerm() external returns (uint64) {\r\n        return _ensureCurrentTerm();\r\n    }\r\n\r\n    /**\r\n    * @notice Transition up to `_maxRequestedTransitions` terms\r\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\r\n    * @return Identification number of the term ID after executing the heartbeat transitions\r\n    */\r\n    function heartbeat(uint64 _maxRequestedTransitions) external returns (uint64) {\r\n        return _heartbeat(_maxRequestedTransitions);\r\n    }\r\n\r\n    /**\r\n    * @notice Ensure that a certain term has its randomness set. As we allow to draft disputes requested for previous terms, if there\r\n    *      were mined more than 256 blocks for the current term, the blockhash of its randomness BN is no longer available, given\r\n    *      round will be able to be drafted in the following term.\r\n    * @return Randomness of the current term\r\n    */\r\n    function ensureCurrentTermRandomness() external returns (bytes32) {\r\n        // If the randomness for the given term was already computed, return\r\n        uint64 currentTermId = termId;\r\n        Term storage term = terms[currentTermId];\r\n        bytes32 termRandomness = term.randomness;\r\n        if (termRandomness != bytes32(0)) {\r\n            return termRandomness;\r\n        }\r\n\r\n        // Compute term randomness\r\n        bytes32 newRandomness = _computeTermRandomness(currentTermId);\r\n        require(newRandomness != bytes32(0), ERROR_TERM_RANDOMNESS_UNAVAILABLE);\r\n        term.randomness = newRandomness;\r\n        return newRandomness;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the term duration of the Court\r\n    * @return Duration in seconds of the Court term\r\n    */\r\n    function getTermDuration() external view returns (uint64) {\r\n        return termDuration;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the last ensured term identification number\r\n    * @return Identification number of the last ensured term\r\n    */\r\n    function getLastEnsuredTermId() external view returns (uint64) {\r\n        return _lastEnsuredTermId();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the current term identification number. Note that there may be pending term transitions.\r\n    * @return Identification number of the current term\r\n    */\r\n    function getCurrentTermId() external view returns (uint64) {\r\n        return _currentTermId();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the number of terms the Court should transition to be up-to-date\r\n    * @return Number of terms the Court should transition to be up-to-date\r\n    */\r\n    function getNeededTermTransitions() external view returns (uint64) {\r\n        return _neededTermTransitions();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the information related to a term based on its ID. Note that if the term has not been reached, the\r\n    *      information returned won't be computed yet. This function allows querying future terms that were not computed yet.\r\n    * @param _termId ID of the term being queried\r\n    * @return startTime Term start time\r\n    * @return randomnessBN Block number used for randomness in the requested term\r\n    * @return randomness Randomness computed for the requested term\r\n    */\r\n    function getTerm(uint64 _termId) external view returns (uint64 startTime, uint64 randomnessBN, bytes32 randomness) {\r\n        Term storage term = terms[_termId];\r\n        return (term.startTime, term.randomnessBN, term.randomness);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the randomness of a term even if it wasn't computed yet\r\n    * @param _termId Identification number of the term being queried\r\n    * @return Randomness of the requested term\r\n    */\r\n    function getTermRandomness(uint64 _termId) external view termExists(_termId) returns (bytes32) {\r\n        return _computeTermRandomness(_termId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to ensure that the current term of the Court is up-to-date. If the Court is outdated by more than\r\n    *      `MAX_AUTO_TERM_TRANSITIONS_ALLOWED` terms, the heartbeat function must be called manually.\r\n    * @return Identification number of the resultant term ID after executing the corresponding transitions\r\n    */\r\n    function _ensureCurrentTerm() internal returns (uint64) {\r\n        // Check the required number of transitions does not exceeds the max allowed number to be processed automatically\r\n        uint64 requiredTransitions = _neededTermTransitions();\r\n        require(requiredTransitions <= MAX_AUTO_TERM_TRANSITIONS_ALLOWED, ERROR_TOO_MANY_TRANSITIONS);\r\n\r\n        // If there are no transitions pending, return the last ensured term id\r\n        if (uint256(requiredTransitions) == 0) {\r\n            return termId;\r\n        }\r\n\r\n        // Process transition if there is at least one pending\r\n        return _heartbeat(requiredTransitions);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to transition the Court terms up to a requested number of terms\r\n    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\r\n    * @return Identification number of the resultant term ID after executing the requested transitions\r\n    */\r\n    function _heartbeat(uint64 _maxRequestedTransitions) internal returns (uint64) {\r\n        // Transition the minimum number of terms between the amount requested and the amount actually needed\r\n        uint64 neededTransitions = _neededTermTransitions();\r\n        uint256 transitions = uint256(_maxRequestedTransitions < neededTransitions ? _maxRequestedTransitions : neededTransitions);\r\n        require(transitions > 0, ERROR_INVALID_TRANSITION_TERMS);\r\n\r\n        uint64 blockNumber = getBlockNumber64();\r\n        uint64 previousTermId = termId;\r\n        uint64 currentTermId = previousTermId;\r\n        for (uint256 transition = 1; transition <= transitions; transition++) {\r\n            // Term IDs are incremented by one based on the number of time periods since the Court started. Since time is represented in uint64,\r\n            // even if we chose the minimum duration possible for a term (1 second), we can ensure terms will never reach 2^64 since time is\r\n            // already assumed to fit in uint64.\r\n            Term storage previousTerm = terms[currentTermId++];\r\n            Term storage currentTerm = terms[currentTermId];\r\n            _onTermTransitioned(currentTermId);\r\n\r\n            // Set the start time of the new term. Note that we are using a constant term duration value to guarantee\r\n            // equally long terms, regardless of heartbeats.\r\n            currentTerm.startTime = previousTerm.startTime.add(termDuration);\r\n\r\n            // In order to draft a random number of guardians in a term, we use a randomness factor for each term based on a\r\n            // block number that is set once the term has started. Note that this information could not be known beforehand.\r\n            currentTerm.randomnessBN = blockNumber + 1;\r\n        }\r\n\r\n        termId = currentTermId;\r\n        emit Heartbeat(previousTermId, currentTermId);\r\n        return currentTermId;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to delay the first term start time only if it wasn't reached yet\r\n    * @param _newFirstTermStartTime New timestamp in seconds when the court will open\r\n    */\r\n    function _delayStartTime(uint64 _newFirstTermStartTime) internal {\r\n        require(_currentTermId() == 0, ERROR_CANNOT_DELAY_STARTED_COURT);\r\n\r\n        Term storage term = terms[0];\r\n        uint64 currentFirstTermStartTime = term.startTime.add(termDuration);\r\n        require(_newFirstTermStartTime > currentFirstTermStartTime, ERROR_CANNOT_DELAY_PAST_START_TIME);\r\n\r\n        // No need for SafeMath: we already checked above that `_newFirstTermStartTime` > `currentFirstTermStartTime` >= `termDuration`\r\n        term.startTime = _newFirstTermStartTime - termDuration;\r\n        emit StartTimeDelayed(currentFirstTermStartTime, _newFirstTermStartTime);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to notify when a term has been transitioned. This function must be overridden to provide custom behavior.\r\n    * @param _termId Identification number of the new current term that has been transitioned\r\n    */\r\n    function _onTermTransitioned(uint64 _termId) internal;\r\n\r\n    /**\r\n    * @dev Internal function to tell the last ensured term identification number\r\n    * @return Identification number of the last ensured term\r\n    */\r\n    function _lastEnsuredTermId() internal view returns (uint64) {\r\n        return termId;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the current term identification number. Note that there may be pending term transitions.\r\n    * @return Identification number of the current term\r\n    */\r\n    function _currentTermId() internal view returns (uint64) {\r\n        return termId.add(_neededTermTransitions());\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the number of terms the Court should transition to be up-to-date\r\n    * @return Number of terms the Court should transition to be up-to-date\r\n    */\r\n    function _neededTermTransitions() internal view returns (uint64) {\r\n        // Note that the Court is always initialized providing a start time for the first-term in the future. If that's the case,\r\n        // no term transitions are required.\r\n        uint64 currentTermStartTime = terms[termId].startTime;\r\n        if (getTimestamp64() < currentTermStartTime) {\r\n            return uint64(0);\r\n        }\r\n\r\n        // No need for SafeMath: we already know that the start time of the current term is in the past\r\n        return (getTimestamp64() - currentTermStartTime) / termDuration;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to compute the randomness that will be used to draft guardians for the given term. This\r\n    *      function assumes the given term exists. To determine the randomness factor for a term we use the hash of a\r\n    *      block number that is set once the term has started to ensure it cannot be known beforehand. Note that the\r\n    *      hash function being used only works for the 256 most recent block numbers.\r\n    * @param _termId Identification number of the term being queried\r\n    * @return Randomness computed for the given term\r\n    */\r\n    function _computeTermRandomness(uint64 _termId) internal view returns (bytes32) {\r\n        Term storage term = terms[_termId];\r\n        require(getBlockNumber64() > term.randomnessBN, ERROR_TERM_RANDOMNESS_NOT_YET);\r\n        return blockhash(term.randomnessBN);\r\n    }\r\n}\r\n\r\n// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath.sol\r\n// Adapted to use pragma ^0.5.17 and satisfy our linter rules\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    string private constant ERROR_ADD_OVERFLOW = \"MATH_ADD_OVERFLOW\";\r\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH_SUB_UNDERFLOW\";\r\n    string private constant ERROR_MUL_OVERFLOW = \"MATH_MUL_OVERFLOW\";\r\n    string private constant ERROR_DIV_ZERO = \"MATH_DIV_ZERO\";\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a, ERROR_ADD_OVERFLOW);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, ERROR_DIV_ZERO);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary PctHelpers {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant PCT_BASE = 10000; // \u2031 (1 / 10,000)\r\n\r\n    function isValid(uint16 _pct) internal pure returns (bool) {\r\n        return _pct <= PCT_BASE;\r\n    }\r\n\r\n    function pct(uint256 self, uint16 _pct) internal pure returns (uint256) {\r\n        return self.mul(uint256(_pct)) / PCT_BASE;\r\n    }\r\n\r\n    function pct256(uint256 self, uint256 _pct) internal pure returns (uint256) {\r\n        return self.mul(_pct) / PCT_BASE;\r\n    }\r\n\r\n    function pctIncrease(uint256 self, uint16 _pct) internal pure returns (uint256) {\r\n        // No need for SafeMath: for addition note that `PCT_BASE` is lower than (2^256 - 2^16)\r\n        return self.mul(PCT_BASE + uint256(_pct)) / PCT_BASE;\r\n    }\r\n}\r\n\r\ninterface IConfig {\r\n\r\n    /**\r\n    * @dev Tell the full Court configuration parameters at a certain term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @return token Address of the token used to pay for fees\r\n    * @return fees Array containing:\r\n    *         0. guardianFee Amount of fee tokens that is paid per guardian per dispute\r\n    *         1. draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    *         2. settleFee Amount of fee tokens per guardian to cover round settlement cost\r\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *         0. evidenceTerms Max submitting evidence period duration in terms\r\n    *         1. commitTerms Commit period duration in terms\r\n    *         2. revealTerms Reveal period duration in terms\r\n    *         3. appealTerms Appeal period duration in terms\r\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @return pcts Array containing:\r\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (\u2031 - 1/10,000)\r\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (\u2031 - 1/10,000)\r\n    * @return roundParams Array containing params for rounds:\r\n    *         0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\r\n    *         1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\r\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    * @return appealCollateralParams Array containing params for appeal collateral:\r\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @return minActiveBalance Minimum amount of tokens guardians have to activate to participate in the Court\r\n    */\r\n    function getConfig(uint64 _termId) external view\r\n        returns (\r\n            IERC20 feeToken,\r\n            uint256[3] memory fees,\r\n            uint64[5] memory roundStateDurations,\r\n            uint16[2] memory pcts,\r\n            uint64[4] memory roundParams,\r\n            uint256[2] memory appealCollateralParams,\r\n            uint256 minActiveBalance\r\n        );\r\n\r\n    /**\r\n    * @dev Tell the draft config at a certain term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @return feeToken Address of the token used to pay for fees\r\n    * @return draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (\u2031 - 1/10,000)\r\n    */\r\n    function getDraftConfig(uint64 _termId) external view returns (IERC20 feeToken, uint256 draftFee, uint16 penaltyPct);\r\n\r\n    /**\r\n    * @dev Tell the min active balance config at a certain term\r\n    * @param _termId Term querying the min active balance config of\r\n    * @return Minimum amount of tokens guardians have to activate to participate in the Court\r\n    */\r\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256);\r\n}\r\n\r\ncontract CourtConfigData {\r\n    struct Config {\r\n        FeesConfig fees;                        // Full fees-related config\r\n        DisputesConfig disputes;                // Full disputes-related config\r\n        uint256 minActiveBalance;               // Minimum amount of tokens guardians have to activate to participate in the Court\r\n    }\r\n\r\n    struct FeesConfig {\r\n        IERC20 token;                           // ERC20 token to be used for the fees of the Court\r\n        uint16 finalRoundReduction;             // Permyriad of fees reduction applied for final appeal round (\u2031 - 1/10,000)\r\n        uint256 guardianFee;                    // Amount of tokens paid to draft a guardian to adjudicate a dispute\r\n        uint256 draftFee;                       // Amount of tokens paid per round to cover the costs of drafting guardians\r\n        uint256 settleFee;                      // Amount of tokens paid per round to cover the costs of slashing guardians\r\n    }\r\n\r\n    struct DisputesConfig {\r\n        uint64 evidenceTerms;                   // Max submitting evidence period duration in terms\r\n        uint64 commitTerms;                     // Committing period duration in terms\r\n        uint64 revealTerms;                     // Revealing period duration in terms\r\n        uint64 appealTerms;                     // Appealing period duration in terms\r\n        uint64 appealConfirmTerms;              // Confirmation appeal period duration in terms\r\n        uint16 penaltyPct;                      // Permyriad of min active tokens balance to be locked for each drafted guardian (\u2031 - 1/10,000)\r\n        uint64 firstRoundGuardiansNumber;       // Number of guardians drafted on first round\r\n        uint64 appealStepFactor;                // Factor in which the guardians number is increased on each appeal\r\n        uint64 finalRoundLockTerms;             // Period a coherent guardian in the final round will remain locked\r\n        uint256 maxRegularAppealRounds;         // Before the final appeal\r\n        uint256 appealCollateralFactor;         // Permyriad multiple of dispute fees required to appeal a preliminary ruling (\u2031 - 1/10,000)\r\n        uint256 appealConfirmCollateralFactor;  // Permyriad multiple of dispute fees required to confirm appeal (\u2031 - 1/10,000)\r\n    }\r\n\r\n    struct DraftConfig {\r\n        IERC20 feeToken;                         // ERC20 token to be used for the fees of the Court\r\n        uint16 penaltyPct;                      // Permyriad of min active tokens balance to be locked for each drafted guardian (\u2031 - 1/10,000)\r\n        uint256 draftFee;                       // Amount of tokens paid per round to cover the costs of drafting guardians\r\n    }\r\n}\r\n\r\ncontract CourtConfig is IConfig, CourtConfigData {\r\n    using SafeMath64 for uint64;\r\n    using PctHelpers for uint256;\r\n\r\n    string private constant ERROR_TOO_OLD_TERM = \"CONF_TOO_OLD_TERM\";\r\n    string private constant ERROR_INVALID_PENALTY_PCT = \"CONF_INVALID_PENALTY_PCT\";\r\n    string private constant ERROR_INVALID_FINAL_ROUND_REDUCTION_PCT = \"CONF_INVALID_FINAL_ROUND_RED_PCT\";\r\n    string private constant ERROR_INVALID_MAX_APPEAL_ROUNDS = \"CONF_INVALID_MAX_APPEAL_ROUNDS\";\r\n    string private constant ERROR_LARGE_ROUND_PHASE_DURATION = \"CONF_LARGE_ROUND_PHASE_DURATION\";\r\n    string private constant ERROR_BAD_INITIAL_GUARDIANS_NUMBER = \"CONF_BAD_INITIAL_GUARDIAN_NUMBER\";\r\n    string private constant ERROR_BAD_APPEAL_STEP_FACTOR = \"CONF_BAD_APPEAL_STEP_FACTOR\";\r\n    string private constant ERROR_ZERO_COLLATERAL_FACTOR = \"CONF_ZERO_COLLATERAL_FACTOR\";\r\n    string private constant ERROR_ZERO_MIN_ACTIVE_BALANCE = \"CONF_ZERO_MIN_ACTIVE_BALANCE\";\r\n\r\n    // Max number of terms that each of the different adjudication states can last (if lasted 1h, this would be a year)\r\n    uint64 internal constant MAX_ADJ_STATE_DURATION = 8670;\r\n\r\n    // Cap the max number of regular appeal rounds\r\n    uint256 internal constant MAX_REGULAR_APPEAL_ROUNDS_LIMIT = 10;\r\n\r\n    // Future term ID in which a config change has been scheduled\r\n    uint64 private configChangeTermId;\r\n\r\n    // List of all the configs used in the Court\r\n    Config[] private configs;\r\n\r\n    // List of configs indexed by id\r\n    mapping (uint64 => uint256) private configIdByTerm;\r\n\r\n    event NewConfig(uint64 fromTermId, uint64 courtConfigId);\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _feeToken Address of the token contract that is used to pay for fees\r\n    * @param _fees Array containing:\r\n    *        0. guardianFee Amount of fee tokens that is paid per guardian per dispute\r\n    *        1. draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per guardian to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (\u2031 - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (\u2031 - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *        1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of guardian tokens that can be activated\r\n    */\r\n    constructor(\r\n        IERC20 _feeToken,\r\n        uint256[3] memory _fees,\r\n        uint64[5] memory _roundStateDurations,\r\n        uint16[2] memory _pcts,\r\n        uint64[4] memory _roundParams,\r\n        uint256[2] memory _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        public\r\n    {\r\n        // Leave config at index 0 empty for non-scheduled config changes\r\n        configs.length = 1;\r\n        _setConfig(\r\n            0,\r\n            0,\r\n            _feeToken,\r\n            _fees,\r\n            _roundStateDurations,\r\n            _pcts,\r\n            _roundParams,\r\n            _appealCollateralParams,\r\n            _minActiveBalance\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the full Court configuration parameters at a certain term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @return token Address of the token used to pay for fees\r\n    * @return fees Array containing:\r\n    *         0. guardianFee Amount of fee tokens that is paid per guardian per dispute\r\n    *         1. draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    *         2. settleFee Amount of fee tokens per guardian to cover round settlement cost\r\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *         0. evidenceTerms Max submitting evidence period duration in terms\r\n    *         1. commitTerms Commit period duration in terms\r\n    *         2. revealTerms Reveal period duration in terms\r\n    *         3. appealTerms Appeal period duration in terms\r\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @return pcts Array containing:\r\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (\u2031 - 1/10,000)\r\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (\u2031 - 1/10,000)\r\n    * @return roundParams Array containing params for rounds:\r\n    *         0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\r\n    *         1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\r\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    * @return appealCollateralParams Array containing params for appeal collateral:\r\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @return minActiveBalance Minimum amount of tokens guardians have to activate to participate in the Court\r\n    */\r\n    function getConfig(uint64 _termId) external view\r\n        returns (\r\n            IERC20 feeToken,\r\n            uint256[3] memory fees,\r\n            uint64[5] memory roundStateDurations,\r\n            uint16[2] memory pcts,\r\n            uint64[4] memory roundParams,\r\n            uint256[2] memory appealCollateralParams,\r\n            uint256 minActiveBalance\r\n        );\r\n\r\n    /**\r\n    * @dev Tell the draft config at a certain term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @return feeToken Address of the token used to pay for fees\r\n    * @return draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (\u2031 - 1/10,000)\r\n    */\r\n    function getDraftConfig(uint64 _termId) external view returns (IERC20 feeToken, uint256 draftFee, uint16 penaltyPct);\r\n\r\n    /**\r\n    * @dev Tell the min active balance config at a certain term\r\n    * @param _termId Term querying the min active balance config of\r\n    * @return Minimum amount of tokens guardians have to activate to participate in the Court\r\n    */\r\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Tell the term identification number of the next scheduled config change\r\n    * @return Term identification number of the next scheduled config change\r\n    */\r\n    function getConfigChangeTermId() external view returns (uint64) {\r\n        return configChangeTermId;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal to make sure to set a config for the new term, it will copy the previous term config if none\r\n    * @param _termId Identification number of the new current term that has been transitioned\r\n    */\r\n    function _ensureTermConfig(uint64 _termId) internal {\r\n        // If the term being transitioned had no config change scheduled, keep the previous one\r\n        uint256 currentConfigId = configIdByTerm[_termId];\r\n        if (currentConfigId == 0) {\r\n            uint256 previousConfigId = configIdByTerm[_termId.sub(1)];\r\n            configIdByTerm[_termId] = previousConfigId;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Assumes that sender it's allowed (either it's from governor or it's on init)\r\n    * @param _termId Identification number of the current Court term\r\n    * @param _fromTermId Identification number of the term in which the config will be effective at\r\n    * @param _feeToken Address of the token contract that is used to pay for fees.\r\n    * @param _fees Array containing:\r\n    *        0. guardianFee Amount of fee tokens that is paid per guardian per dispute\r\n    *        1. draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per guardian to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (\u2031 - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (\u2031 - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *        1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of guardian tokens that can be activated\r\n    */\r\n    function _setConfig(\r\n        uint64 _termId,\r\n        uint64 _fromTermId,\r\n        IERC20 _feeToken,\r\n        uint256[3] memory _fees,\r\n        uint64[5] memory _roundStateDurations,\r\n        uint16[2] memory _pcts,\r\n        uint64[4] memory _roundParams,\r\n        uint256[2] memory _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        internal\r\n    {\r\n        // If the current term is not zero, changes must be scheduled at least after the current period.\r\n        // No need to ensure delays for on-going disputes since these already use their creation term for that.\r\n        require(_termId == 0 || _fromTermId > _termId, ERROR_TOO_OLD_TERM);\r\n\r\n        // Make sure appeal collateral factors are greater than zero\r\n        require(_appealCollateralParams[0] > 0 && _appealCollateralParams[1] > 0, ERROR_ZERO_COLLATERAL_FACTOR);\r\n\r\n        // Make sure the given penalty and final round reduction pcts are not greater than 100%\r\n        require(PctHelpers.isValid(_pcts[0]), ERROR_INVALID_PENALTY_PCT);\r\n        require(PctHelpers.isValid(_pcts[1]), ERROR_INVALID_FINAL_ROUND_REDUCTION_PCT);\r\n\r\n        // Disputes must request at least one guardian to be drafted initially\r\n        require(_roundParams[0] > 0, ERROR_BAD_INITIAL_GUARDIANS_NUMBER);\r\n\r\n        // Prevent that further rounds have zero guardians\r\n        require(_roundParams[1] > 0, ERROR_BAD_APPEAL_STEP_FACTOR);\r\n\r\n        // Make sure the max number of appeals allowed does not reach the limit\r\n        uint256 _maxRegularAppealRounds = _roundParams[2];\r\n        bool isMaxAppealRoundsValid = _maxRegularAppealRounds > 0 && _maxRegularAppealRounds <= MAX_REGULAR_APPEAL_ROUNDS_LIMIT;\r\n        require(isMaxAppealRoundsValid, ERROR_INVALID_MAX_APPEAL_ROUNDS);\r\n\r\n        // Make sure each adjudication round phase duration is valid\r\n        for (uint i = 0; i < _roundStateDurations.length; i++) {\r\n            require(_roundStateDurations[i] > 0 && _roundStateDurations[i] < MAX_ADJ_STATE_DURATION, ERROR_LARGE_ROUND_PHASE_DURATION);\r\n        }\r\n\r\n        // Make sure min active balance is not zero\r\n        require(_minActiveBalance > 0, ERROR_ZERO_MIN_ACTIVE_BALANCE);\r\n\r\n        // If there was a config change already scheduled, reset it (in that case we will overwrite last array item).\r\n        // Otherwise, schedule a new config.\r\n        if (configChangeTermId > _termId) {\r\n            configIdByTerm[configChangeTermId] = 0;\r\n        } else {\r\n            configs.length++;\r\n        }\r\n\r\n        uint64 courtConfigId = uint64(configs.length - 1);\r\n        Config storage config = configs[courtConfigId];\r\n\r\n        config.fees = FeesConfig({\r\n            token: _feeToken,\r\n            guardianFee: _fees[0],\r\n            draftFee: _fees[1],\r\n            settleFee: _fees[2],\r\n            finalRoundReduction: _pcts[1]\r\n        });\r\n\r\n        config.disputes = DisputesConfig({\r\n            evidenceTerms: _roundStateDurations[0],\r\n            commitTerms: _roundStateDurations[1],\r\n            revealTerms: _roundStateDurations[2],\r\n            appealTerms: _roundStateDurations[3],\r\n            appealConfirmTerms: _roundStateDurations[4],\r\n            penaltyPct: _pcts[0],\r\n            firstRoundGuardiansNumber: _roundParams[0],\r\n            appealStepFactor: _roundParams[1],\r\n            maxRegularAppealRounds: _maxRegularAppealRounds,\r\n            finalRoundLockTerms: _roundParams[3],\r\n            appealCollateralFactor: _appealCollateralParams[0],\r\n            appealConfirmCollateralFactor: _appealCollateralParams[1]\r\n        });\r\n\r\n        config.minActiveBalance = _minActiveBalance;\r\n\r\n        configIdByTerm[_fromTermId] = courtConfigId;\r\n        configChangeTermId = _fromTermId;\r\n\r\n        emit NewConfig(_fromTermId, courtConfigId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the Court config for a given term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return token Address of the token used to pay for fees\r\n    * @return fees Array containing:\r\n    *         0. guardianFee Amount of fee tokens that is paid per guardian per dispute\r\n    *         1. draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    *         2. settleFee Amount of fee tokens per guardian to cover round settlement cost\r\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *         0. evidenceTerms Max submitting evidence period duration in terms\r\n    *         1. commitTerms Commit period duration in terms\r\n    *         2. revealTerms Reveal period duration in terms\r\n    *         3. appealTerms Appeal period duration in terms\r\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @return pcts Array containing:\r\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (\u2031 - 1/10,000)\r\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (\u2031 - 1/10,000)\r\n    * @return roundParams Array containing params for rounds:\r\n    *         0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\r\n    *         1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\r\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *         3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @return appealCollateralParams Array containing params for appeal collateral:\r\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    * @return minActiveBalance Minimum amount of guardian tokens that can be activated\r\n    */\r\n    function _getConfigAt(uint64 _termId, uint64 _lastEnsuredTermId) internal view\r\n        returns (\r\n            IERC20 feeToken,\r\n            uint256[3] memory fees,\r\n            uint64[5] memory roundStateDurations,\r\n            uint16[2] memory pcts,\r\n            uint64[4] memory roundParams,\r\n            uint256[2] memory appealCollateralParams,\r\n            uint256 minActiveBalance\r\n        )\r\n    {\r\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\r\n\r\n        FeesConfig storage feesConfig = config.fees;\r\n        feeToken = feesConfig.token;\r\n        fees = [feesConfig.guardianFee, feesConfig.draftFee, feesConfig.settleFee];\r\n\r\n        DisputesConfig storage disputesConfig = config.disputes;\r\n        roundStateDurations = [\r\n            disputesConfig.evidenceTerms,\r\n            disputesConfig.commitTerms,\r\n            disputesConfig.revealTerms,\r\n            disputesConfig.appealTerms,\r\n            disputesConfig.appealConfirmTerms\r\n        ];\r\n        pcts = [disputesConfig.penaltyPct, feesConfig.finalRoundReduction];\r\n        roundParams = [\r\n            disputesConfig.firstRoundGuardiansNumber,\r\n            disputesConfig.appealStepFactor,\r\n            uint64(disputesConfig.maxRegularAppealRounds),\r\n            disputesConfig.finalRoundLockTerms\r\n        ];\r\n        appealCollateralParams = [disputesConfig.appealCollateralFactor, disputesConfig.appealConfirmCollateralFactor];\r\n\r\n        minActiveBalance = config.minActiveBalance;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the draft config at a certain term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return feeToken Address of the token used to pay for fees\r\n    * @return draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (\u2031 - 1/10,000)\r\n    */\r\n    function _getDraftConfig(uint64 _termId,  uint64 _lastEnsuredTermId) internal view\r\n        returns (IERC20 feeToken, uint256 draftFee, uint16 penaltyPct)\r\n    {\r\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\r\n        return (config.fees.token, config.fees.draftFee, config.disputes.penaltyPct);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the min active balance config for a given term\r\n    * @param _termId Identification number of the term querying the min active balance config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return Minimum amount of guardian tokens that can be activated at the given term\r\n    */\r\n    function _getMinActiveBalance(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (uint256) {\r\n        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\r\n        return config.minActiveBalance;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the Court config for a given term\r\n    * @param _termId Identification number of the term querying the min active balance config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return Court config for the given term\r\n    */\r\n    function _getConfigFor(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (Config storage) {\r\n        uint256 id = _getConfigIdFor(_termId, _lastEnsuredTermId);\r\n        return configs[id];\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the Court config ID for a given term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\r\n    * @return Identification number of the config for the given terms\r\n    */\r\n    function _getConfigIdFor(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (uint256) {\r\n        // If the given term is lower or equal to the last ensured Court term, it is safe to use a past Court config\r\n        if (_termId <= _lastEnsuredTermId) {\r\n            return configIdByTerm[_termId];\r\n        }\r\n\r\n        // If the given term is in the future but there is a config change scheduled before it, use the incoming config\r\n        uint64 scheduledChangeTermId = configChangeTermId;\r\n        if (scheduledChangeTermId <= _termId) {\r\n            return configIdByTerm[scheduledChangeTermId];\r\n        }\r\n\r\n        // If no changes are scheduled, use the Court config of the last ensured term\r\n        return configIdByTerm[_lastEnsuredTermId];\r\n    }\r\n}\r\n\r\ninterface IDisputeManager {\r\n    enum DisputeState {\r\n        PreDraft,\r\n        Adjudicating,\r\n        Ruled\r\n    }\r\n\r\n    enum AdjudicationState {\r\n        Invalid,\r\n        Committing,\r\n        Revealing,\r\n        Appealing,\r\n        ConfirmingAppeal,\r\n        Ended\r\n    }\r\n\r\n    /**\r\n    * @dev Create a dispute to be drafted in a future term\r\n    * @param _subject Arbitrable instance creating the dispute\r\n    * @param _possibleRulings Number of possible rulings allowed for the drafted guardians to vote on the dispute\r\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\r\n    * @return Dispute identification number\r\n    */\r\n    function createDispute(IArbitrable _subject, uint8 _possibleRulings, bytes calldata _metadata) external returns (uint256);\r\n\r\n    /**\r\n    * @dev Submit evidence for a dispute\r\n    * @param _subject Arbitrable instance submitting the dispute\r\n    * @param _disputeId Identification number of the dispute receiving new evidence\r\n    * @param _submitter Address of the account submitting the evidence\r\n    * @param _evidence Data submitted for the evidence of the dispute\r\n    */\r\n    function submitEvidence(IArbitrable _subject, uint256 _disputeId, address _submitter, bytes calldata _evidence) external;\r\n\r\n    /**\r\n    * @dev Close the evidence period of a dispute\r\n    * @param _subject IArbitrable instance requesting to close the evidence submission period\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function closeEvidencePeriod(IArbitrable _subject, uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @dev Draft guardians for the next round of a dispute\r\n    * @param _disputeId Identification number of the dispute to be drafted\r\n    */\r\n    function draft(uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @dev Appeal round of a dispute in favor of a certain ruling\r\n    * @param _disputeId Identification number of the dispute being appealed\r\n    * @param _roundId Identification number of the dispute round being appealed\r\n    * @param _ruling Ruling appealing a dispute round in favor of\r\n    */\r\n    function createAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external;\r\n\r\n    /**\r\n    * @dev Confirm appeal for a round of a dispute in favor of a ruling\r\n    * @param _disputeId Identification number of the dispute confirming an appeal of\r\n    * @param _roundId Identification number of the dispute round confirming an appeal of\r\n    * @param _ruling Ruling being confirmed against a dispute round appeal\r\n    */\r\n    function confirmAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external;\r\n\r\n    /**\r\n    * @dev Compute the final ruling for a dispute\r\n    * @param _disputeId Identification number of the dispute to compute its final ruling\r\n    * @return subject Arbitrable instance associated to the dispute\r\n    * @return finalRuling Final ruling decided for the given dispute\r\n    */\r\n    function computeRuling(uint256 _disputeId) external returns (IArbitrable subject, uint8 finalRuling);\r\n\r\n    /**\r\n    * @dev Settle penalties for a round of a dispute\r\n    * @param _disputeId Identification number of the dispute to settle penalties for\r\n    * @param _roundId Identification number of the dispute round to settle penalties for\r\n    * @param _guardiansToSettle Maximum number of guardians to be slashed in this call\r\n    */\r\n    function settlePenalties(uint256 _disputeId, uint256 _roundId, uint256 _guardiansToSettle) external;\r\n\r\n    /**\r\n    * @dev Claim rewards for a round of a dispute for guardian\r\n    * @dev For regular rounds, it will only reward winning guardians\r\n    * @param _disputeId Identification number of the dispute to settle rewards for\r\n    * @param _roundId Identification number of the dispute round to settle rewards for\r\n    * @param _guardian Address of the guardian to settle their rewards\r\n    */\r\n    function settleReward(uint256 _disputeId, uint256 _roundId, address _guardian) external;\r\n\r\n    /**\r\n    * @dev Settle appeal deposits for a round of a dispute\r\n    * @param _disputeId Identification number of the dispute to settle appeal deposits for\r\n    * @param _roundId Identification number of the dispute round to settle appeal deposits for\r\n    */\r\n    function settleAppealDeposit(uint256 _disputeId, uint256 _roundId) external;\r\n\r\n    /**\r\n    * @dev Tell the amount of token fees required to create a dispute\r\n    * @return feeToken ERC20 token used for the fees\r\n    * @return feeAmount Total amount of fees to be paid for a dispute at the given term\r\n    */\r\n    function getDisputeFees() external view returns (IERC20 feeToken, uint256 feeAmount);\r\n\r\n    /**\r\n    * @dev Tell information of a certain dispute\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @return subject Arbitrable subject being disputed\r\n    * @return possibleRulings Number of possible rulings allowed for the drafted guardians to vote on the dispute\r\n    * @return state Current state of the dispute being queried: pre-draft, adjudicating, or ruled\r\n    * @return finalRuling The winning ruling in case the dispute is finished\r\n    * @return lastRoundId Identification number of the last round created for the dispute\r\n    * @return createTermId Identification number of the term when the dispute was created\r\n    */\r\n    function getDispute(uint256 _disputeId) external view\r\n        returns (IArbitrable subject, uint8 possibleRulings, DisputeState state, uint8 finalRuling, uint256 lastRoundId, uint64 createTermId);\r\n\r\n    /**\r\n    * @dev Tell information of a certain adjudication round\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round being queried\r\n    * @return draftTerm Term from which the requested round can be drafted\r\n    * @return delayedTerms Number of terms the given round was delayed based on its requested draft term id\r\n    * @return guardiansNumber Number of guardians requested for the round\r\n    * @return selectedGuardians Number of guardians already selected for the requested round\r\n    * @return settledPenalties Whether or not penalties have been settled for the requested round\r\n    * @return collectedTokens Amount of guardian tokens that were collected from slashed guardians for the requested round\r\n    * @return coherentGuardians Number of guardians that voted in favor of the final ruling in the requested round\r\n    * @return state Adjudication state of the requested round\r\n    */\r\n    function getRound(uint256 _disputeId, uint256 _roundId) external view\r\n        returns (\r\n            uint64 draftTerm,\r\n            uint64 delayedTerms,\r\n            uint64 guardiansNumber,\r\n            uint64 selectedGuardians,\r\n            uint256 guardianFees,\r\n            bool settledPenalties,\r\n            uint256 collectedTokens,\r\n            uint64 coherentGuardians,\r\n            AdjudicationState state\r\n        );\r\n\r\n    /**\r\n    * @dev Tell appeal-related information of a certain adjudication round\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round being queried\r\n    * @return maker Address of the account appealing the given round\r\n    * @return appealedRuling Ruling confirmed by the appealer of the given round\r\n    * @return taker Address of the account confirming the appeal of the given round\r\n    * @return opposedRuling Ruling confirmed by the appeal taker of the given round\r\n    */\r\n    function getAppeal(uint256 _disputeId, uint256 _roundId) external view\r\n        returns (address maker, uint64 appealedRuling, address taker, uint64 opposedRuling);\r\n\r\n    /**\r\n    * @dev Tell information related to the next round due to an appeal of a certain round given.\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round requesting the appeal details of\r\n    * @return nextRoundStartTerm Term ID from which the next round will start\r\n    * @return nextRoundGuardiansNumber Guardians number for the next round\r\n    * @return newDisputeState New state for the dispute associated to the given round after the appeal\r\n    * @return feeToken ERC20 token used for the next round fees\r\n    * @return guardianFees Total amount of fees to be distributed between the winning guardians of the next round\r\n    * @return totalFees Total amount of fees for a regular round at the given term\r\n    * @return appealDeposit Amount to be deposit of fees for a regular round at the given term\r\n    * @return confirmAppealDeposit Total amount of fees for a regular round at the given term\r\n    */\r\n    function getNextRoundDetails(uint256 _disputeId, uint256 _roundId) external view\r\n        returns (\r\n            uint64 nextRoundStartTerm,\r\n            uint64 nextRoundGuardiansNumber,\r\n            DisputeState newDisputeState,\r\n            IERC20 feeToken,\r\n            uint256 totalFees,\r\n            uint256 guardianFees,\r\n            uint256 appealDeposit,\r\n            uint256 confirmAppealDeposit\r\n        );\r\n\r\n    /**\r\n    * @dev Tell guardian-related information of a certain adjudication round\r\n    * @param _disputeId Identification number of the dispute being queried\r\n    * @param _roundId Identification number of the round being queried\r\n    * @param _guardian Address of the guardian being queried\r\n    * @return weight Guardian weight drafted for the requested round\r\n    * @return rewarded Whether or not the given guardian was rewarded based on the requested round\r\n    */\r\n    function getGuardian(uint256 _disputeId, uint256 _roundId, address _guardian) external view returns (uint64 weight, bool rewarded);\r\n}\r\n\r\ncontract Controller is IsContract, ModuleIds, CourtClock, CourtConfig, ACL {\r\n    string private constant ERROR_SENDER_NOT_GOVERNOR = \"CTR_SENDER_NOT_GOVERNOR\";\r\n    string private constant ERROR_INVALID_GOVERNOR_ADDRESS = \"CTR_INVALID_GOVERNOR_ADDRESS\";\r\n    string private constant ERROR_MODULE_NOT_SET = \"CTR_MODULE_NOT_SET\";\r\n    string private constant ERROR_MODULE_ALREADY_ENABLED = \"CTR_MODULE_ALREADY_ENABLED\";\r\n    string private constant ERROR_MODULE_ALREADY_DISABLED = \"CTR_MODULE_ALREADY_DISABLED\";\r\n    string private constant ERROR_DISPUTE_MANAGER_NOT_ACTIVE = \"CTR_DISPUTE_MANAGER_NOT_ACTIVE\";\r\n    string private constant ERROR_CUSTOM_FUNCTION_NOT_SET = \"CTR_CUSTOM_FUNCTION_NOT_SET\";\r\n    string private constant ERROR_IMPLEMENTATION_NOT_CONTRACT = \"CTR_IMPLEMENTATION_NOT_CONTRACT\";\r\n    string private constant ERROR_INVALID_IMPLS_INPUT_LENGTH = \"CTR_INVALID_IMPLS_INPUT_LENGTH\";\r\n\r\n    address private constant ZERO_ADDRESS = address(0);\r\n\r\n    /**\r\n    * @dev Governor of the whole system. Set of three addresses to recover funds, change configuration settings and setup modules\r\n    */\r\n    struct Governor {\r\n        address funds;      // This address can be unset at any time. It is allowed to recover funds from the ControlledRecoverable modules\r\n        address config;     // This address is meant not to be unset. It is allowed to change the different configurations of the whole system\r\n        address modules;    // This address can be unset at any time. It is allowed to plug/unplug modules from the system\r\n    }\r\n\r\n    /**\r\n    * @dev Module information\r\n    */\r\n    struct Module {\r\n        bytes32 id;         // ID associated to a module\r\n        bool disabled;      // Whether the module is disabled\r\n    }\r\n\r\n    // Governor addresses of the system\r\n    Governor private governor;\r\n\r\n    // List of current modules registered for the system indexed by ID\r\n    mapping (bytes32 => address) internal currentModules;\r\n\r\n    // List of all historical modules registered for the system indexed by address\r\n    mapping (address => Module) internal allModules;\r\n\r\n    // List of custom function targets indexed by signature\r\n    mapping (bytes4 => address) internal customFunctions;\r\n\r\n    event ModuleSet(bytes32 id, address addr);\r\n    event ModuleEnabled(bytes32 id, address addr);\r\n    event ModuleDisabled(bytes32 id, address addr);\r\n    event CustomFunctionSet(bytes4 signature, address target);\r\n    event FundsGovernorChanged(address previousGovernor, address currentGovernor);\r\n    event ConfigGovernorChanged(address previousGovernor, address currentGovernor);\r\n    event ModulesGovernorChanged(address previousGovernor, address currentGovernor);\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the funds governor\r\n    */\r\n    modifier onlyFundsGovernor {\r\n        require(msg.sender == governor.funds, ERROR_SENDER_NOT_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the modules governor\r\n    */\r\n    modifier onlyConfigGovernor {\r\n        require(msg.sender == governor.config, ERROR_SENDER_NOT_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure the msg.sender is the modules governor\r\n    */\r\n    modifier onlyModulesGovernor {\r\n        require(msg.sender == governor.modules, ERROR_SENDER_NOT_GOVERNOR);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensure the given dispute manager is active\r\n    */\r\n    modifier onlyActiveDisputeManager(IDisputeManager _disputeManager) {\r\n        require(!_isModuleDisabled(address(_disputeManager)), ERROR_DISPUTE_MANAGER_NOT_ACTIVE);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _termParams Array containing:\r\n    *        0. _termDuration Duration in seconds per term\r\n    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for guardian on-boarding)\r\n    * @param _governors Array containing:\r\n    *        0. _fundsGovernor Address of the funds governor\r\n    *        1. _configGovernor Address of the config governor\r\n    *        2. _modulesGovernor Address of the modules governor\r\n    * @param _feeToken Address of the token contract that is used to pay for fees\r\n    * @param _fees Array containing:\r\n    *        0. guardianFee Amount of fee tokens that is paid per guardian per dispute\r\n    *        1. draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per guardian to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted guardians (\u2031 - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (\u2031 - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\r\n    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of guardian tokens that can be activated\r\n    */\r\n    constructor(\r\n        uint64[2] memory _termParams,\r\n        address[3] memory _governors,\r\n        IERC20 _feeToken,\r\n        uint256[3] memory _fees,\r\n        uint64[5] memory _roundStateDurations,\r\n        uint16[2] memory _pcts,\r\n        uint64[4] memory _roundParams,\r\n        uint256[2] memory _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        public\r\n        CourtClock(_termParams)\r\n        CourtConfig(_feeToken, _fees, _roundStateDurations, _pcts, _roundParams, _appealCollateralParams, _minActiveBalance)\r\n    {\r\n        _setFundsGovernor(_governors[0]);\r\n        _setConfigGovernor(_governors[1]);\r\n        _setModulesGovernor(_governors[2]);\r\n    }\r\n\r\n    /**\r\n    * @dev Fallback function allows to forward calls to a specific address in case it was previously registered\r\n    *      Note the sender will be always the controller in case it is forwarded\r\n    */\r\n    function () external payable {\r\n        address target = customFunctions[msg.sig];\r\n        require(target != address(0), ERROR_CUSTOM_FUNCTION_NOT_SET);\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success,) = address(target).call.value(msg.value)(msg.data);\r\n        assembly {\r\n            let size := returndatasize\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            let result := success\r\n            switch result case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Change Court configuration params\r\n    * @param _fromTermId Identification number of the term in which the config will be effective at\r\n    * @param _feeToken Address of the token contract that is used to pay for fees\r\n    * @param _fees Array containing:\r\n    *        0. guardianFee Amount of fee tokens that is paid per guardian per dispute\r\n    *        1. draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per guardian to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted guardians (\u2031 - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (\u2031 - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\r\n    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of guardian tokens that can be activated\r\n    */\r\n    function setConfig(\r\n        uint64 _fromTermId,\r\n        IERC20 _feeToken,\r\n        uint256[3] calldata _fees,\r\n        uint64[5] calldata _roundStateDurations,\r\n        uint16[2] calldata _pcts,\r\n        uint64[4] calldata _roundParams,\r\n        uint256[2] calldata _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        external\r\n        onlyConfigGovernor\r\n    {\r\n        uint64 currentTermId = _ensureCurrentTerm();\r\n        _setConfig(\r\n            currentTermId,\r\n            _fromTermId,\r\n            _feeToken,\r\n            _fees,\r\n            _roundStateDurations,\r\n            _pcts,\r\n            _roundParams,\r\n            _appealCollateralParams,\r\n            _minActiveBalance\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Delay the Court start time to `_newFirstTermStartTime`\r\n    * @param _newFirstTermStartTime New timestamp in seconds when the court will open\r\n    */\r\n    function delayStartTime(uint64 _newFirstTermStartTime) external onlyConfigGovernor {\r\n        _delayStartTime(_newFirstTermStartTime);\r\n    }\r\n\r\n    /**\r\n    * @notice Change funds governor address to `_newFundsGovernor`\r\n    * @param _newFundsGovernor Address of the new funds governor to be set\r\n    */\r\n    function changeFundsGovernor(address _newFundsGovernor) external onlyFundsGovernor {\r\n        require(_newFundsGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\r\n        _setFundsGovernor(_newFundsGovernor);\r\n    }\r\n\r\n    /**\r\n    * @notice Change config governor address to `_newConfigGovernor`\r\n    * @param _newConfigGovernor Address of the new config governor to be set\r\n    */\r\n    function changeConfigGovernor(address _newConfigGovernor) external onlyConfigGovernor {\r\n        require(_newConfigGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\r\n        _setConfigGovernor(_newConfigGovernor);\r\n    }\r\n\r\n    /**\r\n    * @notice Change modules governor address to `_newModulesGovernor`\r\n    * @param _newModulesGovernor Address of the new governor to be set\r\n    */\r\n    function changeModulesGovernor(address _newModulesGovernor) external onlyModulesGovernor {\r\n        require(_newModulesGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\r\n        _setModulesGovernor(_newModulesGovernor);\r\n    }\r\n\r\n    /**\r\n    * @notice Remove the funds governor. Set the funds governor to the zero address.\r\n    * @dev This action cannot be rolled back, once the funds governor has been unset, funds cannot be recovered from recoverable modules anymore\r\n    */\r\n    function ejectFundsGovernor() external onlyFundsGovernor {\r\n        _setFundsGovernor(ZERO_ADDRESS);\r\n    }\r\n\r\n    /**\r\n    * @notice Remove the modules governor. Set the modules governor to the zero address.\r\n    * @dev This action cannot be rolled back, once the modules governor has been unset, system modules cannot be changed anymore\r\n    */\r\n    function ejectModulesGovernor() external onlyModulesGovernor {\r\n        _setModulesGovernor(ZERO_ADDRESS);\r\n    }\r\n\r\n    /**\r\n    * @notice Grant `_id` role to `_who`\r\n    * @param _id ID of the role to be granted\r\n    * @param _who Address to grant the role to\r\n    */\r\n    function grant(bytes32 _id, address _who) external onlyConfigGovernor {\r\n        _grant(_id, _who);\r\n    }\r\n\r\n    /**\r\n    * @notice Revoke `_id` role from `_who`\r\n    * @param _id ID of the role to be revoked\r\n    * @param _who Address to revoke the role from\r\n    */\r\n    function revoke(bytes32 _id, address _who) external onlyConfigGovernor {\r\n        _revoke(_id, _who);\r\n    }\r\n\r\n    /**\r\n    * @notice Freeze `_id` role\r\n    * @param _id ID of the role to be frozen\r\n    */\r\n    function freeze(bytes32 _id) external onlyConfigGovernor {\r\n        _freeze(_id);\r\n    }\r\n\r\n    /**\r\n    * @notice Enact a bulk list of ACL operations\r\n    */\r\n    function bulk(BulkOp[] calldata _op, bytes32[] calldata _id, address[] calldata _who) external onlyConfigGovernor {\r\n        _bulk(_op, _id, _who);\r\n    }\r\n\r\n    /**\r\n    * @notice Set module `_id` to `_addr`\r\n    * @param _id ID of the module to be set\r\n    * @param _addr Address of the module to be set\r\n    */\r\n    function setModule(bytes32 _id, address _addr) external onlyModulesGovernor {\r\n        _setModule(_id, _addr);\r\n    }\r\n\r\n    /**\r\n    * @notice Set and link many modules at once\r\n    * @param _newModuleIds List of IDs of the new modules to be set\r\n    * @param _newModuleAddresses List of addresses of the new modules to be set\r\n    * @param _newModuleLinks List of IDs of the modules that will be linked in the new modules being set\r\n    * @param _currentModulesToBeSynced List of addresses of current modules to be re-linked to the new modules being set\r\n    */\r\n    function setModules(\r\n        bytes32[] calldata _newModuleIds,\r\n        address[] calldata _newModuleAddresses,\r\n        bytes32[] calldata _newModuleLinks,\r\n        address[] calldata _currentModulesToBeSynced\r\n    )\r\n        external\r\n        onlyModulesGovernor\r\n    {\r\n        // We only care about the modules being set, links are optional\r\n        require(_newModuleIds.length == _newModuleAddresses.length, ERROR_INVALID_IMPLS_INPUT_LENGTH);\r\n\r\n        // First set the addresses of the new modules or the modules to be updated\r\n        for (uint256 i = 0; i < _newModuleIds.length; i++) {\r\n            _setModule(_newModuleIds[i], _newModuleAddresses[i]);\r\n        }\r\n\r\n        // Then sync the links of the new modules based on the list of IDs specified (ideally the IDs of their dependencies)\r\n        _syncModuleLinks(_newModuleAddresses, _newModuleLinks);\r\n\r\n        // Finally sync the links of the existing modules to be synced to the new modules being set\r\n        _syncModuleLinks(_currentModulesToBeSynced, _newModuleIds);\r\n    }\r\n\r\n    /**\r\n    * @notice Sync modules for a list of modules IDs based on their current implementation address\r\n    * @param _modulesToBeSynced List of addresses of connected modules to be synced\r\n    * @param _idsToBeSet List of IDs of the modules included in the sync\r\n    */\r\n    function syncModuleLinks(address[] calldata _modulesToBeSynced, bytes32[] calldata _idsToBeSet)\r\n        external\r\n        onlyModulesGovernor\r\n    {\r\n        require(_idsToBeSet.length > 0 && _modulesToBeSynced.length > 0, ERROR_INVALID_IMPLS_INPUT_LENGTH);\r\n        _syncModuleLinks(_modulesToBeSynced, _idsToBeSet);\r\n    }\r\n\r\n    /**\r\n    * @notice Disable module `_addr`\r\n    * @dev Current modules can be disabled to allow pausing the court. However, these can be enabled back again, see `enableModule`\r\n    * @param _addr Address of the module to be disabled\r\n    */\r\n    function disableModule(address _addr) external onlyModulesGovernor {\r\n        Module storage module = allModules[_addr];\r\n        _ensureModuleExists(module);\r\n        require(!module.disabled, ERROR_MODULE_ALREADY_DISABLED);\r\n\r\n        module.disabled = true;\r\n        emit ModuleDisabled(module.id, _addr);\r\n    }\r\n\r\n    /**\r\n    * @notice Enable module `_addr`\r\n    * @param _addr Address of the module to be enabled\r\n    */\r\n    function enableModule(address _addr) external onlyModulesGovernor {\r\n        Module storage module = allModules[_addr];\r\n        _ensureModuleExists(module);\r\n        require(module.disabled, ERROR_MODULE_ALREADY_ENABLED);\r\n\r\n        module.disabled = false;\r\n        emit ModuleEnabled(module.id, _addr);\r\n    }\r\n\r\n    /**\r\n    * @notice Set custom function `_sig` for `_target`\r\n    * @param _sig Signature of the function to be set\r\n    * @param _target Address of the target implementation to be registered for the given signature\r\n    */\r\n    function setCustomFunction(bytes4 _sig, address _target) external onlyModulesGovernor {\r\n        customFunctions[_sig] = _target;\r\n        emit CustomFunctionSet(_sig, _target);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the full Court configuration parameters at a certain term\r\n    * @param _termId Identification number of the term querying the Court config of\r\n    * @return token Address of the token used to pay for fees\r\n    * @return fees Array containing:\r\n    *         0. guardianFee Amount of fee tokens that is paid per guardian per dispute\r\n    *         1. draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    *         2. settleFee Amount of fee tokens per guardian to cover round settlement cost\r\n    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *         0. evidenceTerms Max submitting evidence period duration in terms\r\n    *         1. commitTerms Commit period duration in terms\r\n    *         2. revealTerms Reveal period duration in terms\r\n    *         3. appealTerms Appeal period duration in terms\r\n    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @return pcts Array containing:\r\n    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (\u2031 - 1/10,000)\r\n    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (\u2031 - 1/10,000)\r\n    * @return roundParams Array containing params for rounds:\r\n    *         0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\r\n    *         1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\r\n    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *         3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @return appealCollateralParams Array containing params for appeal collateral:\r\n    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\r\n    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\r\n    */\r\n    function getConfig(uint64 _termId) external view\r\n        returns (\r\n            IERC20 feeToken,\r\n            uint256[3] memory fees,\r\n            uint64[5] memory roundStateDurations,\r\n            uint16[2] memory pcts,\r\n            uint64[4] memory roundParams,\r\n            uint256[2] memory appealCollateralParams,\r\n            uint256 minActiveBalance\r\n        )\r\n    {\r\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\r\n        return _getConfigAt(_termId, lastEnsuredTermId);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the draft config at a certain term\r\n    * @param _termId Identification number of the term querying the draft config of\r\n    * @return feeToken Address of the token used to pay for fees\r\n    * @return draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (\u2031 - 1/10,000)\r\n    */\r\n    function getDraftConfig(uint64 _termId) external view returns (IERC20 feeToken, uint256 draftFee, uint16 penaltyPct) {\r\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\r\n        return _getDraftConfig(_termId, lastEnsuredTermId);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the min active balance config at a certain term\r\n    * @param _termId Identification number of the term querying the min active balance config of\r\n    * @return Minimum amount of tokens guardians have to activate to participate in the Court\r\n    */\r\n    function getMinActiveBalance(uint64 _termId) external view returns (uint256) {\r\n        uint64 lastEnsuredTermId = _lastEnsuredTermId();\r\n        return _getMinActiveBalance(_termId, lastEnsuredTermId);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the funds governor\r\n    * @return Address of the funds governor\r\n    */\r\n    function getFundsGovernor() external view returns (address) {\r\n        return governor.funds;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the config governor\r\n    * @return Address of the config governor\r\n    */\r\n    function getConfigGovernor() external view returns (address) {\r\n        return governor.config;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the address of the modules governor\r\n    * @return Address of the modules governor\r\n    */\r\n    function getModulesGovernor() external view returns (address) {\r\n        return governor.modules;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell if a given module is active\r\n    * @param _id ID of the module to be checked\r\n    * @param _addr Address of the module to be checked\r\n    * @return True if the given module address has the requested ID and is enabled\r\n    */\r\n    function isActive(bytes32 _id, address _addr) external view returns (bool) {\r\n        Module storage module = allModules[_addr];\r\n        return module.id == _id && !module.disabled;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the current ID and disable status of a module based on a given address\r\n    * @param _addr Address of the requested module\r\n    * @return id ID of the module being queried\r\n    * @return disabled Whether the module has been disabled\r\n    */\r\n    function getModuleByAddress(address _addr) external view returns (bytes32 id, bool disabled) {\r\n        Module storage module = allModules[_addr];\r\n        id = module.id;\r\n        disabled = module.disabled;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the current address and disable status of a module based on a given ID\r\n    * @param _id ID of the module being queried\r\n    * @return addr Current address of the requested module\r\n    * @return disabled Whether the module has been disabled\r\n    */\r\n    function getModule(bytes32 _id) external view returns (address addr, bool disabled) {\r\n        return _getModule(_id);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the information for the current DisputeManager module\r\n    * @return addr Current address of the DisputeManager module\r\n    * @return disabled Whether the module has been disabled\r\n    */\r\n    function getDisputeManager() external view returns (address addr, bool disabled) {\r\n        return _getModule(MODULE_ID_DISPUTE_MANAGER);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the information for  the current GuardiansRegistry module\r\n    * @return addr Current address of the GuardiansRegistry module\r\n    * @return disabled Whether the module has been disabled\r\n    */\r\n    function getGuardiansRegistry() external view returns (address addr, bool disabled) {\r\n        return _getModule(MODULE_ID_GUARDIANS_REGISTRY);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the information for the current Voting module\r\n    * @return addr Current address of the Voting module\r\n    * @return disabled Whether the module has been disabled\r\n    */\r\n    function getVoting() external view returns (address addr, bool disabled) {\r\n        return _getModule(MODULE_ID_VOTING);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the information for the current PaymentsBook module\r\n    * @return addr Current address of the PaymentsBook module\r\n    * @return disabled Whether the module has been disabled\r\n    */\r\n    function getPaymentsBook() external view returns (address addr, bool disabled) {\r\n        return _getModule(MODULE_ID_PAYMENTS_BOOK);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the information for the current Treasury module\r\n    * @return addr Current address of the Treasury module\r\n    * @return disabled Whether the module has been disabled\r\n    */\r\n    function getTreasury() external view returns (address addr, bool disabled) {\r\n        return _getModule(MODULE_ID_TREASURY);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the target registered for a custom function\r\n    * @param _sig Signature of the function being queried\r\n    * @return Address of the target where the function call will be forwarded\r\n    */\r\n    function getCustomFunction(bytes4 _sig) external view returns (address) {\r\n        return customFunctions[_sig];\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set the address of the funds governor\r\n    * @param _newFundsGovernor Address of the new config governor to be set\r\n    */\r\n    function _setFundsGovernor(address _newFundsGovernor) internal {\r\n        emit FundsGovernorChanged(governor.funds, _newFundsGovernor);\r\n        governor.funds = _newFundsGovernor;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set the address of the config governor\r\n    * @param _newConfigGovernor Address of the new config governor to be set\r\n    */\r\n    function _setConfigGovernor(address _newConfigGovernor) internal {\r\n        emit ConfigGovernorChanged(governor.config, _newConfigGovernor);\r\n        governor.config = _newConfigGovernor;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set the address of the modules governor\r\n    * @param _newModulesGovernor Address of the new modules governor to be set\r\n    */\r\n    function _setModulesGovernor(address _newModulesGovernor) internal {\r\n        emit ModulesGovernorChanged(governor.modules, _newModulesGovernor);\r\n        governor.modules = _newModulesGovernor;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to set an address as the current implementation for a module\r\n    *      Note that the disabled condition is not affected, if the module was not set before it will be enabled by default\r\n    * @param _id Id of the module to be set\r\n    * @param _addr Address of the module to be set\r\n    */\r\n    function _setModule(bytes32 _id, address _addr) internal {\r\n        require(isContract(_addr), ERROR_IMPLEMENTATION_NOT_CONTRACT);\r\n\r\n        currentModules[_id] = _addr;\r\n        allModules[_addr].id = _id;\r\n        emit ModuleSet(_id, _addr);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to sync the modules for a list of modules IDs based on their current implementation address\r\n    * @param _modulesToBeSynced List of addresses of connected modules to be synced\r\n    * @param _idsToBeSet List of IDs of the modules to be linked\r\n    */\r\n    function _syncModuleLinks(address[] memory _modulesToBeSynced, bytes32[] memory _idsToBeSet) internal {\r\n        address[] memory addressesToBeSet = new address[](_idsToBeSet.length);\r\n\r\n        // Load the addresses associated with the requested module ids\r\n        for (uint256 i = 0; i < _idsToBeSet.length; i++) {\r\n            address moduleAddress = _getModuleAddress(_idsToBeSet[i]);\r\n            Module storage module = allModules[moduleAddress];\r\n            _ensureModuleExists(module);\r\n            addressesToBeSet[i] = moduleAddress;\r\n        }\r\n\r\n        // Update the links of all the requested modules\r\n        for (uint256 j = 0; j < _modulesToBeSynced.length; j++) {\r\n            IModulesLinker(_modulesToBeSynced[j]).linkModules(_idsToBeSet, addressesToBeSet);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to notify when a term has been transitioned\r\n    * @param _termId Identification number of the new current term that has been transitioned\r\n    */\r\n    function _onTermTransitioned(uint64 _termId) internal {\r\n        _ensureTermConfig(_termId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to check if a module was set\r\n    * @param _module Module to be checked\r\n    */\r\n    function _ensureModuleExists(Module storage _module) internal view {\r\n        require(_module.id != bytes32(0), ERROR_MODULE_NOT_SET);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the information for a module based on a given ID\r\n    * @param _id ID of the module being queried\r\n    * @return addr Current address of the requested module\r\n    * @return disabled Whether the module has been disabled\r\n    */\r\n    function _getModule(bytes32 _id) internal view returns (address addr, bool disabled) {\r\n        addr = _getModuleAddress(_id);\r\n        disabled = _isModuleDisabled(addr);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the current address for a module by ID\r\n    * @param _id ID of the module being queried\r\n    * @return Current address of the requested module\r\n    */\r\n    function _getModuleAddress(bytes32 _id) internal view returns (address) {\r\n        return currentModules[_id];\r\n    }\r\n\r\n    /**\r\n    * @dev Tell whether a module is disabled\r\n    * @param _addr Address of the module being queried\r\n    * @return True if the module is disabled, false otherwise\r\n    */\r\n    function _isModuleDisabled(address _addr) internal view returns (bool) {\r\n        return allModules[_addr].disabled;\r\n    }\r\n}\r\n\r\ncontract AragonCourt is IArbitrator, Controller {\r\n    using Uint256Helpers for uint256;\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    * @param _termParams Array containing:\r\n    *        0. _termDuration Duration in seconds per term\r\n    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for guardian on-boarding)\r\n    * @param _governors Array containing:\r\n    *        0. _fundsGovernor Address of the funds governor\r\n    *        1. _configGovernor Address of the config governor\r\n    *        2. _modulesGovernor Address of the modules governor\r\n    * @param _feeToken Address of the token contract that is used to pay for fees\r\n    * @param _fees Array containing:\r\n    *        0. guardianFee Amount of fee tokens that is paid per guardian per dispute\r\n    *        1. draftFee Amount of fee tokens per guardian to cover the drafting cost\r\n    *        2. settleFee Amount of fee tokens per guardian to cover round settlement cost\r\n    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\r\n    *        0. evidenceTerms Max submitting evidence period duration in terms\r\n    *        1. commitTerms Commit period duration in terms\r\n    *        2. revealTerms Reveal period duration in terms\r\n    *        3. appealTerms Appeal period duration in terms\r\n    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\r\n    * @param _pcts Array containing:\r\n    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted guardians (\u2031 - 1/10,000)\r\n    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (\u2031 - 1/10,000)\r\n    * @param _roundParams Array containing params for rounds:\r\n    *        0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\r\n    *        1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\r\n    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\r\n    *        3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\r\n    * @param _appealCollateralParams Array containing params for appeal collateral:\r\n    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\r\n    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\r\n    * @param _minActiveBalance Minimum amount of guardian tokens that can be activated\r\n    */\r\n    constructor(\r\n        uint64[2] memory _termParams,\r\n        address[3] memory _governors,\r\n        IERC20 _feeToken,\r\n        uint256[3] memory _fees,\r\n        uint64[5] memory _roundStateDurations,\r\n        uint16[2] memory _pcts,\r\n        uint64[4] memory _roundParams,\r\n        uint256[2] memory _appealCollateralParams,\r\n        uint256 _minActiveBalance\r\n    )\r\n        public\r\n        Controller(\r\n            _termParams,\r\n            _governors,\r\n            _feeToken,\r\n            _fees,\r\n            _roundStateDurations,\r\n            _pcts,\r\n            _roundParams,\r\n            _appealCollateralParams,\r\n            _minActiveBalance\r\n        )\r\n    {\r\n        // solium-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n    * @notice Create a dispute with `_possibleRulings` possible rulings\r\n    * @param _possibleRulings Number of possible rulings allowed for the drafted guardians to vote on the dispute\r\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\r\n    * @return Dispute identification number\r\n    */\r\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256) {\r\n        IArbitrable subject = IArbitrable(msg.sender);\r\n        return _disputeManager().createDispute(subject, _possibleRulings.toUint8(), _metadata);\r\n    }\r\n\r\n    /**\r\n    * @notice Submit `_evidence` as evidence from `_submitter` for dispute #`_disputeId`\r\n    * @param _disputeId Id of the dispute in the Court\r\n    * @param _submitter Address of the account submitting the evidence\r\n    * @param _evidence Data submitted for the evidence related to the dispute\r\n    */\r\n    function submitEvidence(uint256 _disputeId, address _submitter, bytes calldata _evidence) external {\r\n        _submitEvidence(_disputeManager(), _disputeId, _submitter, _evidence);\r\n    }\r\n\r\n    /**\r\n    * @notice Submit `_evidence` as evidence from `_submitter` for dispute #`_disputeId`\r\n    * @dev This entry point can be used to submit evidences to previous Dispute Manager instances\r\n    * @param _disputeManager Dispute manager to be used\r\n    * @param _disputeId Id of the dispute in the Court\r\n    * @param _submitter Address of the account submitting the evidence\r\n    * @param _evidence Data submitted for the evidence related to the dispute\r\n    */\r\n    function submitEvidenceForModule(IDisputeManager _disputeManager, uint256 _disputeId, address _submitter, bytes calldata _evidence)\r\n        external\r\n        onlyActiveDisputeManager(_disputeManager)\r\n    {\r\n        _submitEvidence(_disputeManager, _disputeId, _submitter, _evidence);\r\n    }\r\n\r\n    /**\r\n    * @notice Close the evidence period of dispute #`_disputeId`\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function closeEvidencePeriod(uint256 _disputeId) external {\r\n        _closeEvidencePeriod(_disputeManager(), _disputeId);\r\n    }\r\n\r\n    /**\r\n    * @notice Close the evidence period of dispute #`_disputeId`\r\n    * @dev This entry point can be used to close evidence periods on previous Dispute Manager instances\r\n    * @param _disputeManager Dispute manager to be used\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function closeEvidencePeriodForModule(IDisputeManager _disputeManager, uint256 _disputeId)\r\n        external\r\n        onlyActiveDisputeManager(_disputeManager)\r\n    {\r\n        _closeEvidencePeriod(_disputeManager, _disputeId);\r\n    }\r\n\r\n    /**\r\n    * @notice Rule dispute #`_disputeId` if ready\r\n    * @param _disputeId Identification number of the dispute to be ruled\r\n    * @return subject Arbitrable instance associated to the dispute\r\n    * @return ruling Ruling number computed for the given dispute\r\n    */\r\n    function rule(uint256 _disputeId) external returns (address subject, uint256 ruling) {\r\n        return _rule(_disputeManager(), _disputeId);\r\n    }\r\n\r\n    /**\r\n    * @notice Rule dispute #`_disputeId` if ready\r\n    * @dev This entry point can be used to rule disputes on previous Dispute Manager instances\r\n    * @param _disputeManager Dispute manager to be used\r\n    * @param _disputeId Identification number of the dispute to be ruled\r\n    * @return subject Arbitrable instance associated to the dispute\r\n    * @return ruling Ruling number computed for the given dispute\r\n    */\r\n    function ruleForModule(IDisputeManager _disputeManager, uint256 _disputeId)\r\n        external\r\n        onlyActiveDisputeManager(_disputeManager)\r\n        returns (address subject, uint256 ruling)\r\n    {\r\n        return _rule(_disputeManager, _disputeId);\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the dispute fees information to create a dispute\r\n    * @return recipient Address where the corresponding dispute fees must be transferred to\r\n    * @return feeToken ERC20 token used for the fees\r\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\r\n    */\r\n    function getDisputeFees() external view returns (address recipient, IERC20 feeToken, uint256 feeAmount) {\r\n        IDisputeManager disputeManager = _disputeManager();\r\n        recipient = address(disputeManager);\r\n        (feeToken, feeAmount) = disputeManager.getDisputeFees();\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the payments recipient address\r\n    * @return Address of the payments recipient module\r\n    */\r\n    function getPaymentsRecipient() external view returns (address) {\r\n        return currentModules[MODULE_ID_PAYMENTS_BOOK];\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to submit evidence for a dispute\r\n    * @param _disputeManager Dispute manager to be used\r\n    * @param _disputeId Id of the dispute in the Court\r\n    * @param _submitter Address of the account submitting the evidence\r\n    * @param _evidence Data submitted for the evidence related to the dispute\r\n    */\r\n    function _submitEvidence(IDisputeManager _disputeManager, uint256 _disputeId, address _submitter, bytes memory _evidence) internal {\r\n        IArbitrable subject = IArbitrable(msg.sender);\r\n        _disputeManager.submitEvidence(subject, _disputeId, _submitter, _evidence);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to close the evidence period of a dispute\r\n    * @param _disputeManager Dispute manager to be used\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function _closeEvidencePeriod(IDisputeManager _disputeManager, uint256 _disputeId) internal {\r\n        IArbitrable subject = IArbitrable(msg.sender);\r\n        _disputeManager.closeEvidencePeriod(subject, _disputeId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to rule a dispute\r\n    * @param _disputeManager Dispute manager to be used\r\n    * @param _disputeId Identification number of the dispute to be ruled\r\n    * @return subject Arbitrable instance associated to the dispute\r\n    * @return ruling Ruling number computed for the given dispute\r\n    */\r\n    function _rule(IDisputeManager _disputeManager, uint256 _disputeId) internal returns (address subject, uint256 ruling) {\r\n        (IArbitrable _subject, uint8 _ruling) = _disputeManager.computeRuling(_disputeId);\r\n        return (address(_subject), uint256(_ruling));\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to tell the current DisputeManager module\r\n    * @return Current DisputeManager module\r\n    */\r\n    function _disputeManager() internal view returns (IDisputeManager) {\r\n        return IDisputeManager(_getModuleAddress(MODULE_ID_DISPUTE_MANAGER));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint64[2]\",\"name\":\"_termParams\",\"type\":\"uint64[2]\"},{\"internalType\":\"address[3]\",\"name\":\"_governors\",\"type\":\"address[3]\"},{\"internalType\":\"contract IERC20\",\"name\":\"_feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256[3]\",\"name\":\"_fees\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint64[5]\",\"name\":\"_roundStateDurations\",\"type\":\"uint64[5]\"},{\"internalType\":\"uint16[2]\",\"name\":\"_pcts\",\"type\":\"uint16[2]\"},{\"internalType\":\"uint64[4]\",\"name\":\"_roundParams\",\"type\":\"uint64[4]\"},{\"internalType\":\"uint256[2]\",\"name\":\"_appealCollateralParams\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"_minActiveBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousGovernor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentGovernor\",\"type\":\"address\"}],\"name\":\"ConfigGovernorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"signature\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"CustomFunctionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"Frozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousGovernor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentGovernor\",\"type\":\"address\"}],\"name\":\"FundsGovernorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Granted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"previousTermId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"currentTermId\",\"type\":\"uint64\"}],\"name\":\"Heartbeat\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ModuleDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ModuleEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ModuleSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousGovernor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentGovernor\",\"type\":\"address\"}],\"name\":\"ModulesGovernorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"fromTermId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"courtConfigId\",\"type\":\"uint64\"}],\"name\":\"NewConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Revoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"previousStartTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"currentStartTime\",\"type\":\"uint64\"}],\"name\":\"StartTimeDelayed\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum ACL.BulkOp[]\",\"name\":\"_op\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_id\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"_who\",\"type\":\"address[]\"}],\"name\":\"bulk\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newConfigGovernor\",\"type\":\"address\"}],\"name\":\"changeConfigGovernor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFundsGovernor\",\"type\":\"address\"}],\"name\":\"changeFundsGovernor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newModulesGovernor\",\"type\":\"address\"}],\"name\":\"changeModulesGovernor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"closeEvidencePeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IDisputeManager\",\"name\":\"_disputeManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"closeEvidencePeriodForModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_possibleRulings\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_metadata\",\"type\":\"bytes\"}],\"name\":\"createDispute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_newFirstTermStartTime\",\"type\":\"uint64\"}],\"name\":\"delayStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"disableModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ejectFundsGovernor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ejectModulesGovernor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"enableModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ensureCurrentTerm\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ensureCurrentTermRandomness\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_termId\",\"type\":\"uint64\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256[3]\",\"name\":\"fees\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint64[5]\",\"name\":\"roundStateDurations\",\"type\":\"uint64[5]\"},{\"internalType\":\"uint16[2]\",\"name\":\"pcts\",\"type\":\"uint16[2]\"},{\"internalType\":\"uint64[4]\",\"name\":\"roundParams\",\"type\":\"uint64[4]\"},{\"internalType\":\"uint256[2]\",\"name\":\"appealCollateralParams\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"minActiveBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConfigChangeTermId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConfigGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTermId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_sig\",\"type\":\"bytes4\"}],\"name\":\"getCustomFunction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputeFees\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputeManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_termId\",\"type\":\"uint64\"}],\"name\":\"getDraftConfig\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"draftFee\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"penaltyPct\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFundsGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGuardiansRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastEnsuredTermId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_termId\",\"type\":\"uint64\"}],\"name\":\"getMinActiveBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getModuleByAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getModulesGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNeededTermTransitions\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPaymentsBook\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPaymentsRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_termId\",\"type\":\"uint64\"}],\"name\":\"getTerm\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"randomnessBN\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"randomness\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTermDuration\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_termId\",\"type\":\"uint64\"}],\"name\":\"getTermRandomness\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"grant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_maxRequestedTransitions\",\"type\":\"uint64\"}],\"name\":\"heartbeat\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"isRoleFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"roles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"rule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ruling\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IDisputeManager\",\"name\":\"_disputeManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"ruleForModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ruling\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_fromTermId\",\"type\":\"uint64\"},{\"internalType\":\"contract IERC20\",\"name\":\"_feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256[3]\",\"name\":\"_fees\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint64[5]\",\"name\":\"_roundStateDurations\",\"type\":\"uint64[5]\"},{\"internalType\":\"uint16[2]\",\"name\":\"_pcts\",\"type\":\"uint16[2]\"},{\"internalType\":\"uint64[4]\",\"name\":\"_roundParams\",\"type\":\"uint64[4]\"},{\"internalType\":\"uint256[2]\",\"name\":\"_appealCollateralParams\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"_minActiveBalance\",\"type\":\"uint256\"}],\"name\":\"setConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_sig\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"setCustomFunction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_newModuleIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"_newModuleAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_newModuleLinks\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"_currentModulesToBeSynced\",\"type\":\"address[]\"}],\"name\":\"setModules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_submitter\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_evidence\",\"type\":\"bytes\"}],\"name\":\"submitEvidence\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IDisputeManager\",\"name\":\"_disputeManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_submitter\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_evidence\",\"type\":\"bytes\"}],\"name\":\"submitEvidenceForModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_modulesToBeSynced\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_idsToBeSet\",\"type\":\"bytes32[]\"}],\"name\":\"syncModuleLinks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AragonCourt", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "400", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000070800000000000000000000000000000000000000000000000000000000060c77d00000000000000000000000000a974a0436b5d2842f47312832618900b1b633617000000000000000000000000a974a0436b5d2842f47312832618900b1b633617000000000000000000000000a974a0436b5d2842f47312832618900b1b6336170000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000022b1c8c1227a0000000000000000000000000000000000000000000000000000053444835ec5800000000000000000000000000000000000000000000000000003782dace9d900000000000000000000000000000000000000000000000000000000000000000001500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000bb80000000000000000000000000000000000000000000000000000000000001388000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001500000000000000000000000000000000000000000000000000000000000075300000000000000000000000000000000000000000000000000000000000004e200000000000000000000000000000000000000000000000056bc75e2d63100000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://d9aa997e9581a8d5d43c1270e494334c30aabcdf3849dcc360139f6019f296c7"}