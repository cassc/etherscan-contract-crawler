{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.13;\\n\\nimport {ReentrancyGuard} from \\\"solmate/utils/ReentrancyGuard.sol\\\";\\nimport {IDepositContract} from \\\"src/interfaces/IDepositContract.sol\\\";\\nimport {IStaking} from \\\"src/interfaces/IStaking.sol\\\";\\nimport {Owned} from \\\"src/lib/Owned.sol\\\";\\nimport {Pausable} from \\\"src/lib/Pausable.sol\\\";\\nimport {SafeTransferLib} from \\\"src/lib/SafeTransferLib.sol\\\";\\nimport {FeeRecipient} from \\\"src/FeeRecipient.sol\\\";\\nimport {StakingConstants} from \\\"src/StakingConstants.sol\\\";\\n\\ncontract Staking is IStaking, ReentrancyGuard, Owned, Pausable, StakingConstants {\\n    /// @notice Ethereum staking deposit contract address.\\n    address public immutable depositContract;\\n    /// @notice stakewith.us treasury which receives share of profit from execution layer rewards.\\n    address public treasury;\\n    /// @notice One-time fee for creating a new validator.\\n    uint256 public oneTimeFee;\\n    /// @notice Performance fee percentage from execution layer rewards / `FEE_BASIS`, i.e. 10_000 represents 100%.\\n    uint256 public performanceFee;\\n    /// @notice Delay before a user can initiate a refund of pending unstaked ETH.\\n    uint256 public refundDelay;\\n    /// @notice Total number pending unstaked deposits across all users.\\n    uint256 public totalPendingValidators;\\n\\n    /// @notice Mapping of users to FeeRecipient contracts which users collect their execution layer rewards from.\\n    mapping(address => address) public registry;\\n    /// @notice Mapping of users to number of pending unstaked deposits for that user.\\n    mapping(address => uint256) public pendingValidators;\\n    /// @notice Mapping of users to timestamp of their last deposit.\\n    mapping(address => uint256) public lastDepositTimestamp;\\n\\n    uint256 internal constant _DEPOSIT_AMOUNT = 32 ether;\\n    uint256 internal constant _MAXIMUM_REFUND_DELAY = 7 days;\\n\\n    error InvalidAmount();\\n    error InvalidLength();\\n    error PendingValidators();\\n    error NoDeposit();\\n    error BeforeRefundDelay();\\n    error SameValue();\\n\\n    constructor(\\n        address owner_,\\n        address operator_,\\n        address depositContract_,\\n        address treasury_,\\n        uint256 oneTimeFee_,\\n        uint256 performanceFee_,\\n        uint256 refundDelay_\\n    ) Owned(owner_, operator_) {\\n        if (depositContract_ == address(0)) revert ZeroAddress();\\n        depositContract = depositContract_;\\n        _setTreasury(treasury_);\\n        _setOneTimeFee(oneTimeFee_);\\n        _setPerformanceFee(performanceFee_);\\n        _setRefundDelay(refundDelay_);\\n    }\\n\\n    /// @dev Costs less gas than `deposit()` if user if depositing for their own address.\\n    receive() external payable {\\n        _deposit(msg.sender);\\n    }\\n\\n    /*//////////////////////////////////////\\n\\t            PUBLIC FUNCTIONS\\n\\t//////////////////////////////////////*/\\n\\n    /**\\n     * @notice Deposits ETH into this contract for stakewith.us to create a new validator node on user's behalf.\\n     * @param user_ User's withdrawal address which receives consensus rewards and can claim execution layer rewards.\\n     * @dev `msg.value` must be a multiple of `_DEPOSIT_AMOUNT (32 ether) + oneTimeFee`\\n     */\\n    function deposit(address user_) external payable {\\n        _deposit(user_);\\n    }\\n\\n    function _deposit(address user_) internal whenNotPaused nonReentrant {\\n        if (user_ == address(0)) revert ZeroAddress();\\n        if (pendingValidators[user_] > 0) revert PendingValidators();\\n\\n        uint256 perValidator = _DEPOSIT_AMOUNT + oneTimeFee;\\n        if (msg.value == 0 || msg.value % perValidator != 0) revert InvalidAmount();\\n\\n        // Deploy FeeRecipient for address if its their first deposit.\\n        if (registry[user_] == address(0)) {\\n            address feeRecipient = address(new FeeRecipient(user_));\\n            registry[user_] = feeRecipient;\\n            emit UserRegistered(user_, feeRecipient);\\n        }\\n\\n        uint256 validators = msg.value / perValidator;\\n\\n        pendingValidators[user_] += validators;\\n        totalPendingValidators += validators;\\n        lastDepositTimestamp[user_] = block.timestamp;\\n\\n        emit Deposit(msg.sender, user_, validators);\\n    }\\n\\n    /**\\n     * @notice Refunds unstaked ETH to user. User must wait for at least `refundDelay` after depositing before\\n     * initiating a refund.\\n     */\\n    function refund() external nonReentrant {\\n        uint256 validators = pendingValidators[msg.sender];\\n        if (block.timestamp < lastDepositTimestamp[msg.sender] + refundDelay) revert BeforeRefundDelay();\\n\\n        _refund(msg.sender, validators);\\n    }\\n\\n    /*////////////////////////////////////////\\n\\t            OPERATOR FUNCTIONS\\n\\t////////////////////////////////////////*/\\n\\n    function stake(address user_, DepositData[] memory data_) external onlyOperator {\\n        uint256 length = data_.length;\\n        if (length == 0) revert InvalidLength();\\n\\n        // This underflows, throwing an error if length > pendingValidators[user_]\\n        pendingValidators[user_] -= length;\\n        totalPendingValidators -= length;\\n\\n        if (oneTimeFee > 0) SafeTransferLib.safeTransferETH(treasury, length * oneTimeFee);\\n\\n        bytes[] memory pubkeys = new bytes[](length);\\n\\n        for (uint256 i = 0; i < length; ++i) {\\n            bytes memory pubkey = data_[i].pubkey;\\n\\n            IDepositContract(depositContract).deposit{value: _DEPOSIT_AMOUNT}({\\n                pubkey: pubkey,\\n                withdrawal_credentials: abi.encodePacked(true, uint88(0), user_), // true | 11 bytes padding | address\\n                signature: data_[i].signature,\\n                deposit_data_root: data_[i].deposit_data_root\\n            });\\n\\n            pubkeys[i] = pubkey;\\n        }\\n\\n        emit Staked(user_, pubkeys);\\n    }\\n\\n    function refundUser(address user_, uint256 validators_) external onlyOperator {\\n        _refund(user_, validators_);\\n    }\\n\\n    function pause() external onlyOperator {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyOperator {\\n        _unpause();\\n    }\\n\\n    /*/////////////////////////////////////\\n\\t            OWNER FUNCTIONS\\n\\t/////////////////////////////////////*/\\n\\n    function setOneTimeFee(uint256 oneTimeFee_) external onlyOwner {\\n        if (oneTimeFee_ == oneTimeFee) revert SameValue();\\n        _setOneTimeFee(oneTimeFee_);\\n    }\\n\\n    function setPerformanceFee(uint256 performanceFee_) external onlyOwner {\\n        if (performanceFee_ == performanceFee) revert SameValue();\\n        _setPerformanceFee(performanceFee_);\\n    }\\n\\n    function setTreasury(address treasury_) external onlyOwner {\\n        if (treasury_ == address(0)) revert ZeroAddress();\\n        if (treasury_ == treasury) revert SameValue();\\n        _setTreasury(treasury_);\\n    }\\n\\n    function setRefundDelay(uint256 refundDelay_) external onlyOwner {\\n        if (refundDelay_ == refundDelay) revert SameValue();\\n        _setRefundDelay(refundDelay_);\\n    }\\n\\n    /*////////////////////////////////////////\\n\\t            INTERNAL FUNCTIONS\\n\\t////////////////////////////////////////*/\\n\\n    function _refund(address user_, uint256 validators_) internal {\\n        if (validators_ == 0) revert NoDeposit();\\n\\n        // This underflows, throwing an error if validators_ > pendingValidators[user_]\\n        pendingValidators[user_] -= validators_;\\n        totalPendingValidators -= validators_;\\n\\n        SafeTransferLib.safeTransferETH(user_, validators_ * (_DEPOSIT_AMOUNT + oneTimeFee));\\n        emit Refund(user_, validators_);\\n    }\\n\\n    /// @dev One-time fee cannot be adjusted while there are still pending validators. Pause contract and stake/refund\\n    /// all pending validators before changing one-time fee.\\n    function _setOneTimeFee(uint256 oneTimeFee_) internal {\\n        if (totalPendingValidators != 0) revert PendingValidators();\\n        oneTimeFee = oneTimeFee_;\\n        emit OneTimeFeeSet(oneTimeFee_);\\n    }\\n\\n    function _setPerformanceFee(uint256 performanceFee_) internal {\\n        if (performanceFee_ > FEE_BASIS) revert InvalidAmount();\\n        performanceFee = performanceFee_;\\n        emit PerformanceFeeSet(performanceFee_);\\n    }\\n\\n    function _setTreasury(address treasury_) internal {\\n        emit NewTreasury(treasury, treasury_);\\n        treasury = treasury_;\\n    }\\n\\n    function _setRefundDelay(uint256 refundDelay_) internal {\\n        if (refundDelay_ > _MAXIMUM_REFUND_DELAY) revert InvalidAmount();\\n        refundDelay = refundDelay_;\\n        emit RefundDelaySet(refundDelay_);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IDepositContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\ninterface IDepositContract {\\n    function deposit(\\n        bytes calldata pubkey,\\n        bytes calldata withdrawal_credentials,\\n        bytes calldata signature,\\n        bytes32 deposit_data_root\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IStaking {\\n    struct DepositData {\\n        bytes pubkey;\\n        bytes signature;\\n        bytes32 deposit_data_root;\\n    }\\n\\n    event UserRegistered(address indexed user, address indexed feeRecipient);\\n    event Deposit(address indexed from, address indexed user, uint256 validators);\\n    event Staked(address indexed user, bytes[] pubkeys);\\n    event Refund(address indexed user, uint256 validators);\\n    event OneTimeFeeSet(uint256);\\n    event PerformanceFeeSet(uint256);\\n    event NewTreasury(address indexed oldTreasury, address indexed newTreasury);\\n    event RefundDelaySet(uint256);\\n\\n    function depositContract() external view returns (address);\\n\\n    function treasury() external view returns (address);\\n\\n    function oneTimeFee() external view returns (uint256);\\n\\n    function performanceFee() external view returns (uint256);\\n\\n    function registry(address) external view returns (address);\\n\\n    function pendingValidators(address) external view returns (uint256);\\n\\n    function deposit(address user) external payable;\\n}\\n\"\r\n    },\r\n    \"src/lib/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.13;\\n\\n/**\\n * @notice Auth contract with two levels of access - `owner` can access both `onlyOwner` and `onlyOperator` functions,\\n *  while `operator` can only access `onlyOperator` functions.\\n */\\nabstract contract Owned {\\n    address public owner;\\n    address public nominatedOwner;\\n    address public operator;\\n\\n    event NewOwner(address indexed oldOwner, address indexed newOwner);\\n    event NominatedOwner(address indexed nominatedOwner);\\n    event NewOperator(address indexed oldOperator, address indexed newOperator);\\n\\n    error Unauthorized();\\n    error ZeroAddress();\\n\\n    modifier onlyOwner() virtual {\\n        if (msg.sender != owner) revert Unauthorized();\\n        _;\\n    }\\n\\n    modifier onlyNominatedOwner() virtual {\\n        if (msg.sender != nominatedOwner) revert Unauthorized();\\n        _;\\n    }\\n\\n    modifier onlyOperator() virtual {\\n        if (msg.sender != owner && msg.sender != operator) revert Unauthorized();\\n        _;\\n    }\\n\\n    constructor(address owner_, address operator_) {\\n        if (owner_ == address(0)) revert ZeroAddress();\\n        if (operator_ == address(0)) revert ZeroAddress();\\n        emit NewOwner(address(0), owner_);\\n        emit NewOperator(address(0), operator_);\\n        owner = owner_;\\n        operator = operator_;\\n    }\\n\\n    function setOperator(address operator_) public virtual onlyOwner {\\n        if (operator_ == address(0)) revert ZeroAddress();\\n        emit NewOperator(operator, operator_);\\n        operator = operator_;\\n    }\\n\\n    function nominateOwner(address nominatedOwner_) public virtual onlyOwner {\\n        emit NominatedOwner(nominatedOwner_);\\n        nominatedOwner = nominatedOwner_;\\n    }\\n\\n    function acceptOwnership() public virtual onlyNominatedOwner {\\n        emit NewOwner(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.13;\\n\\nabstract contract Pausable {\\n    bool public paused;\\n\\n    event Paused(address indexed sender);\\n    event Unpaused(address indexed sender);\\n\\n    error IsPaused();\\n    error NotPaused();\\n\\n    function _pause() internal whenNotPaused {\\n        paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    function _unpause() internal whenPaused {\\n        paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    modifier whenNotPaused() {\\n        if (paused) revert IsPaused();\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        if (!paused) revert NotPaused();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.13;\\n\\n/// @notice Gas-efficient safe ETH transfer library that gracefully handles missing return values.\\n/// @author Copied from Solmate with ERC20 code removed.\\n/// @author https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/FeeRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.13;\\n\\nimport {FixedPointMathLib} from \\\"solmate/utils/FixedPointMathLib.sol\\\";\\nimport {IStaking} from \\\"src/interfaces/IStaking.sol\\\";\\nimport {SafeTransferLib} from \\\"src/lib/SafeTransferLib.sol\\\";\\nimport {StakingConstants} from \\\"src/StakingConstants.sol\\\";\\n\\n/**\\n * @notice Contract set as the `fee_recipient` for all validators belonging to a user. Receives execution layer rewards\\n * from block production gas tips and MEV bribes which users can claim via `claimRewards()` function.\\n */\\ncontract FeeRecipient is StakingConstants {\\n    using FixedPointMathLib for uint256;\\n\\n    IStaking public immutable staking;\\n    address public immutable user;\\n\\n    /// @dev Unclaimed rewards that fully belong to user.\\n    uint256 internal _userRewards;\\n\\n    event ClaimRewards(uint256 amount);\\n    event TreasuryClaim(uint256 amount);\\n\\n    error Unauthorized();\\n    error NothingToClaim();\\n\\n    constructor(address user_) {\\n        staking = IStaking(payable(msg.sender));\\n        user = user_;\\n    }\\n\\n    /// @dev To receive MEV bribes directly transferred to `fee_recipient`.\\n    receive() external payable {}\\n\\n    function unclaimedRewards() public view returns (uint256) {\\n        return address(this).balance - _calcToTreasury(address(this).balance - _userRewards);\\n    }\\n\\n    function claimRewards() external onlyUser {\\n        if (unclaimedRewards() == 0) revert NothingToClaim();\\n\\n        _treasuryClaim();\\n\\n        emit ClaimRewards(address(this).balance);\\n        _userRewards = 0;\\n\\n        SafeTransferLib.safeTransferETH(user, address(this).balance);\\n    }\\n\\n    function treasuryClaim() external onlyTreasury {\\n        if (_calcToTreasury(address(this).balance - _userRewards) == 0) revert NothingToClaim();\\n        _treasuryClaim();\\n    }\\n\\n    function _treasuryClaim() internal {\\n        uint256 share = address(this).balance - _userRewards;\\n        uint256 toTreasury = _calcToTreasury(share);\\n        if (toTreasury == 0) return; // Do nothing as treasury has nothing to claim.\\n\\n        emit TreasuryClaim(toTreasury);\\n        _userRewards += share - toTreasury;\\n\\n        SafeTransferLib.safeTransferETH(staking.treasury(), toTreasury);\\n    }\\n\\n    function _calcToTreasury(uint256 amount_) internal view returns (uint256) {\\n        return amount_.mulDivDown(staking.performanceFee(), FEE_BASIS);\\n    }\\n\\n    modifier onlyUser() {\\n        if (msg.sender != user) revert Unauthorized();\\n        _;\\n    }\\n\\n    modifier onlyTreasury() {\\n        if (msg.sender != staking.treasury()) revert Unauthorized();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/StakingConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.13;\\n\\n/// @notice Contract for shared values between Staking.sol and FeeRecipient.sol.\\nabstract contract StakingConstants {\\n    /// @notice Denominator for calculating performance fees, i.e. a `performanceFee` of 10_000 represents 100%.\\n    uint256 public constant FEE_BASIS = 10_000;\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"depositContract_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oneTimeFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"performanceFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refundDelay_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BeforeRefundDelay\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IsPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoDeposit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PendingValidators\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SameValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validators\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"NewOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldTreasury\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"NewTreasury\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nominatedOwner\",\"type\":\"address\"}],\"name\":\"NominatedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"OneTimeFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PerformanceFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validators\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefundDelaySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"pubkeys\",\"type\":\"bytes[]\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_BASIS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastDepositTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nominatedOwner_\",\"type\":\"address\"}],\"name\":\"nominateOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneTimeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingValidators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"validators_\",\"type\":\"uint256\"}],\"name\":\"refundUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"oneTimeFee_\",\"type\":\"uint256\"}],\"name\":\"setOneTimeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"performanceFee_\",\"type\":\"uint256\"}],\"name\":\"setPerformanceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"refundDelay_\",\"type\":\"uint256\"}],\"name\":\"setRefundDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"deposit_data_root\",\"type\":\"bytes32\"}],\"internalType\":\"struct IStaking.DepositData[]\",\"name\":\"data_\",\"type\":\"tuple[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPendingValidators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003b373f51cea611f92d1deb2adb354bf2c11e3c980000000000000000000000003b373f51cea611f92d1deb2adb354bf2c11e3c9800000000000000000000000000000000219ab540356cbb839cbe05303d7705fa0000000000000000000000001c064ea662365c09c8e87242791dacbb9000260500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000003f480", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}