{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PDProtocolSetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {\\n    UserMintCapParam,\\n    TemplateParam,\\n    Whitelist,\\n    Blacklist,\\n    SetDaoParam,\\n    NftMinterCapInfo\\n} from \\\"contracts/interface/D4AStructs.sol\\\";\\nimport { PriceTemplateType, DaoTag } from \\\"contracts/interface/D4AEnums.sol\\\";\\nimport \\\"contracts/interface/D4AErrors.sol\\\";\\nimport { DaoStorage } from \\\"contracts/storages/DaoStorage.sol\\\";\\nimport { SettingsStorage } from \\\"contracts/storages/SettingsStorage.sol\\\";\\nimport { BasicDaoStorage } from \\\"contracts/storages/BasicDaoStorage.sol\\\";\\nimport { D4AProtocolReadable } from \\\"contracts/D4AProtocolReadable.sol\\\";\\nimport { D4AProtocolSetter } from \\\"contracts/D4AProtocolSetter.sol\\\";\\n\\ncontract PDProtocolSetter is D4AProtocolSetter {\\n    // \u4fee\u6539\u9ed1\u767d\u540d\u5355\u65b9\u6cd5\\n    function setMintCapAndPermission(\\n        bytes32 daoId,\\n        uint32 daoMintCap,\\n        UserMintCapParam[] calldata userMintCapParams,\\n        NftMinterCapInfo[] calldata nftMinterCapInfo,\\n        Whitelist memory whitelist,\\n        Blacklist memory blacklist,\\n        Blacklist memory unblacklist\\n    )\\n        public\\n        override\\n    {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (\\n            DaoStorage.layout().daoInfos[daoId].daoTag == DaoTag.BASIC_DAO && msg.sender != l.createProjectProxy\\n                && !BasicDaoStorage.layout().basicDaoInfos[daoId].unlocked\\n        ) {\\n            revert BasicDaoLocked();\\n        }\\n\\n        super.setMintCapAndPermission(\\n            daoId, daoMintCap, userMintCapParams, nftMinterCapInfo, whitelist, blacklist, unblacklist\\n        );\\n    }\\n\\n    // \u4fee\u6539Dao\u53c2\u6570\u65b9\u6cd5\\n    function setDaoParams(SetDaoParam memory vars) public override {\\n        if (\\n            DaoStorage.layout().daoInfos[vars.daoId].daoTag == DaoTag.BASIC_DAO\\n                && !BasicDaoStorage.layout().basicDaoInfos[vars.daoId].unlocked\\n        ) revert BasicDaoLocked();\\n\\n        super.setDaoParams(vars);\\n    }\\n\\n    function setDaoNftMaxSupply(bytes32 daoId, uint256 newMaxSupply) public override {\\n        if (\\n            DaoStorage.layout().daoInfos[daoId].daoTag == DaoTag.BASIC_DAO\\n                && !BasicDaoStorage.layout().basicDaoInfos[daoId].unlocked\\n        ) revert BasicDaoLocked();\\n\\n        super.setDaoNftMaxSupply(daoId, newMaxSupply);\\n    }\\n\\n    function setDaoMintableRound(bytes32 daoId, uint256 newMintableRound) public override {\\n        if (\\n            DaoStorage.layout().daoInfos[daoId].daoTag == DaoTag.BASIC_DAO\\n                && !BasicDaoStorage.layout().basicDaoInfos[daoId].unlocked\\n        ) revert BasicDaoLocked();\\n\\n        super.setDaoMintableRound(daoId, newMintableRound);\\n    }\\n\\n    function setDaoFloorPrice(bytes32 daoId, uint256 newFloorPrice) public override {\\n        if (\\n            DaoStorage.layout().daoInfos[daoId].daoTag == DaoTag.BASIC_DAO\\n                && !BasicDaoStorage.layout().basicDaoInfos[daoId].unlocked\\n        ) revert BasicDaoLocked();\\n\\n        super.setDaoFloorPrice(daoId, newFloorPrice);\\n    }\\n\\n    function setDaoPriceTemplate(\\n        bytes32 daoId,\\n        PriceTemplateType priceTemplateType,\\n        uint256 nftPriceFactor\\n    )\\n        public\\n        override\\n    {\\n        if (\\n            DaoStorage.layout().daoInfos[daoId].daoTag == DaoTag.BASIC_DAO\\n                && !BasicDaoStorage.layout().basicDaoInfos[daoId].unlocked\\n        ) revert BasicDaoLocked();\\n\\n        super.setDaoPriceTemplate(daoId, priceTemplateType, nftPriceFactor);\\n    }\\n\\n    function setTemplate(bytes32 daoId, TemplateParam calldata templateParam) public override {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (\\n            DaoStorage.layout().daoInfos[daoId].daoTag == DaoTag.BASIC_DAO && msg.sender != l.createProjectProxy\\n                && !BasicDaoStorage.layout().basicDaoInfos[daoId].unlocked\\n        ) {\\n            revert BasicDaoLocked();\\n        }\\n\\n        super.setTemplate(daoId, templateParam);\\n    }\\n\\n    function setRatio(\\n        bytes32 daoId,\\n        uint256 daoCreatorERC20Ratio,\\n        uint256 canvasCreatorERC20Ratio,\\n        uint256 nftMinterERC20Ratio,\\n        uint256 daoFeePoolETHRatio,\\n        uint256 daoFeePoolETHRatioFlatPrice\\n    )\\n        public\\n        override\\n    {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (\\n            DaoStorage.layout().daoInfos[daoId].daoTag == DaoTag.BASIC_DAO && msg.sender != l.createProjectProxy\\n                && !BasicDaoStorage.layout().basicDaoInfos[daoId].unlocked\\n        ) {\\n            revert BasicDaoLocked();\\n        }\\n\\n        super.setRatio(\\n            daoId,\\n            daoCreatorERC20Ratio,\\n            canvasCreatorERC20Ratio,\\n            nftMinterERC20Ratio,\\n            daoFeePoolETHRatio,\\n            daoFeePoolETHRatioFlatPrice\\n        );\\n    }\\n\\n    function setCanvasRebateRatioInBps(bytes32 canvasId, uint256 newCanvasRebateRatioInBps) public payable override {\\n        bytes32 daoId = D4AProtocolReadable(address(this)).getCanvasDaoId(canvasId);\\n        if (\\n            DaoStorage.layout().daoInfos[daoId].daoTag == DaoTag.BASIC_DAO\\n                && !BasicDaoStorage.layout().basicDaoInfos[daoId].unlocked\\n        ) revert BasicDaoLocked();\\n\\n        super.setCanvasRebateRatioInBps(canvasId, newCanvasRebateRatioInBps);\\n    }\\n\\n    function setDailyMintCap(bytes32 daoId, uint256 dailyMintCap) public override {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (\\n            DaoStorage.layout().daoInfos[daoId].daoTag == DaoTag.BASIC_DAO && msg.sender != l.createProjectProxy\\n                && !BasicDaoStorage.layout().basicDaoInfos[daoId].unlocked\\n        ) {\\n            revert BasicDaoLocked();\\n        }\\n\\n        super.setDailyMintCap(daoId, dailyMintCap);\\n    }\\n\\n    function setDaoTokenSupply(bytes32 daoId, uint256 addedDaoToken) public override {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (\\n            DaoStorage.layout().daoInfos[daoId].daoTag == DaoTag.BASIC_DAO && msg.sender != l.createProjectProxy\\n                && !BasicDaoStorage.layout().basicDaoInfos[daoId].unlocked\\n        ) {\\n            revert BasicDaoLocked();\\n        }\\n        super.setDaoTokenSupply(daoId, addedDaoToken);\\n    }\\n\\n    function setWhitelistMintCap(bytes32 daoId, address whitelistUser, uint32 whitelistUserMintCap) public override {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (\\n            DaoStorage.layout().daoInfos[daoId].daoTag == DaoTag.BASIC_DAO && msg.sender != l.createProjectProxy\\n                && !BasicDaoStorage.layout().basicDaoInfos[daoId].unlocked\\n        ) {\\n            revert BasicDaoLocked();\\n        }\\n        super.setWhitelistMintCap(daoId, whitelistUser, whitelistUserMintCap);\\n    }\\n\\n    function setDaoUnifiedPrice(bytes32 daoId, uint256 newUnifiedPrice) public override {\\n        if (\\n            DaoStorage.layout().daoInfos[daoId].daoTag == DaoTag.BASIC_DAO\\n                && !BasicDaoStorage.layout().basicDaoInfos[daoId].unlocked\\n        ) revert BasicDaoLocked();\\n\\n        super.setDaoUnifiedPrice(daoId, newUnifiedPrice);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/D4AStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { PriceTemplateType, RewardTemplateType } from \\\"./D4AEnums.sol\\\";\\n\\nstruct DaoMetadataParam {\\n    uint256 startDrb;\\n    uint256 mintableRounds;\\n    uint256 floorPriceRank;\\n    uint256 maxNftRank;\\n    uint96 royaltyFee;\\n    string projectUri;\\n    uint256 projectIndex;\\n}\\n\\nstruct DaoMintInfo {\\n    uint32 daoMintCap; // Dao\u7684\u94f8\u9020\u4e0a\u9650\\n    uint32 NFTHolderMintCap; // NftHolder\u7684\u94f8\u9020\u4e0a\u9650\\n    mapping(address minter => UserMintInfo) userMintInfos; // \u7ed9\u5b9aminter\u7684\u5730\u5740\uff0c\u83b7\u53d6\u5df2\u7ecfmint\u7684\u4e2a\u6570\u4ee5\u53camintCap\\n}\\n\\nstruct NftMinterCapInfo {\\n    address nftAddress;\\n    uint256 nftMintCap;\\n}\\n\\nstruct NftMinterCap {\\n    mapping(address nftAddress => bool) nftExistInMapping;\\n    mapping(address nftAddress => uint256) nftHolderMintCap;\\n}\\n\\nstruct UserMintInfo {\\n    uint32 minted;\\n    uint32 mintCap;\\n}\\n\\nstruct DaoMintCapParam {\\n    uint32 daoMintCap;\\n    UserMintCapParam[] userMintCapParams;\\n}\\n\\nstruct UserMintCapParam {\\n    address minter;\\n    uint32 mintCap;\\n}\\n\\nstruct DaoETHAndERC20SplitRatioParam {\\n    uint256 daoCreatorERC20Ratio;\\n    uint256 canvasCreatorERC20Ratio;\\n    uint256 nftMinterERC20Ratio;\\n    uint256 daoFeePoolETHRatio;\\n    uint256 daoFeePoolETHRatioFlatPrice;\\n}\\n\\nstruct TemplateParam {\\n    PriceTemplateType priceTemplateType;\\n    uint256 priceFactor;\\n    RewardTemplateType rewardTemplateType;\\n    uint256 rewardDecayFactor;\\n    bool isProgressiveJackpot;\\n}\\n\\nstruct UpdateRewardParam {\\n    bytes32 daoId;\\n    bytes32 canvasId;\\n    address token;\\n    uint256 startRound;\\n    uint256 currentRound;\\n    uint256 totalRound;\\n    uint256 daoFeeAmount;\\n    uint256 protocolERC20RatioInBps;\\n    uint256 daoCreatorERC20RatioInBps;\\n    uint256 canvasCreatorERC20RatioInBps;\\n    uint256 nftMinterERC20RatioInBps;\\n    uint256 canvasRebateRatioInBps;\\n}\\n\\nstruct MintNftInfo {\\n    string tokenUri;\\n    uint256 flatPrice;\\n}\\n\\nstruct Blacklist {\\n    address[] minterAccounts;\\n    address[] canvasCreatorAccounts;\\n}\\n\\nstruct Whitelist {\\n    bytes32 minterMerkleRoot;\\n    address[] minterNFTHolderPasses;\\n    bytes32 canvasCreatorMerkleRoot;\\n    address[] canvasCreatorNFTHolderPasses;\\n}\\n\\nstruct BasicDaoParam {\\n    uint256 initTokenSupplyRatio;\\n    bytes32 canvasId;\\n    string canvasUri;\\n    string daoName;\\n}\\n\\nstruct ContinuousDaoParam {\\n    uint256 reserveNftNumber;\\n    bool unifiedPriceModeOff;\\n    uint256 unifiedPrice;\\n    bool needMintableWork;\\n    uint256 dailyMintCap;\\n}\\n// \u4fee\u6539Dao\u4e2d\u53c2\u6570\u7684\u7ed3\u6784\u4f53\uff0c\u88ab\u7528\u4e8esetDaoParams\u65b9\u6cd5\\n\\nstruct SetDaoParam {\\n    bytes32 daoId;\\n    uint256 nftMaxSupplyRank;\\n    uint256 mintableRoundRank;\\n    uint256 daoFloorPriceRank;\\n    PriceTemplateType priceTemplateType;\\n    uint256 nftPriceFactor;\\n    uint256 daoCreatorERC20Ratio;\\n    uint256 canvasCreatorERC20Ratio;\\n    uint256 nftMinterERC20Ratio;\\n    uint256 daoFeePoolETHRatio;\\n    uint256 daoFeePoolETHRatioFlatPrice;\\n    uint256 dailyMintCap;\\n    uint256 addedDaoToken;\\n    uint256 unifiedPrice;\\n}\\n\\nstruct SetMintCapAndPermissionParam {\\n    bytes32 daoId;\\n    uint32 daoMintCap;\\n    UserMintCapParam[] userMintCapParams;\\n    NftMinterCapInfo[] nftMinterCapInfo;\\n    Whitelist whitelist;\\n    Blacklist blacklist;\\n    Blacklist unblacklist;\\n}\\n\\nstruct SetRatioParam {\\n    bytes32 daoId;\\n    uint256 daoCreatorERC20Ratio;\\n    uint256 canvasCreatorERC20Ratio;\\n    uint256 nftMinterERC20Ratio;\\n    uint256 daoFeePoolETHRatio;\\n    uint256 daoFeePoolETHRatioFlatPrice;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/D4AEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nenum PriceTemplateType {\\n    EXPONENTIAL_PRICE_VARIATION,\\n    LINEAR_PRICE_VARIATION\\n}\\n\\nenum RewardTemplateType {\\n    LINEAR_REWARD_ISSUANCE,\\n    EXPONENTIAL_REWARD_ISSUANCE\\n}\\n\\nenum TemplateChoice {\\n    PRICE,\\n    REWARD\\n}\\n\\nenum DaoTag {\\n    D4A_DAO,\\n    BASIC_DAO\\n}\\n\\nenum DeployMethod {\\n    REMOVE,\\n    REPLACE,\\n    ADD,\\n    REMOVE_AND_ADD\\n}\\n\"\r\n    },\r\n    \"contracts/interface/D4AErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nerror NotDaoOwner();\\n\\nerror NotCanvasOwner();\\n\\nerror NotRole(bytes32 role, address account);\\n\\nerror NotCaller(address caller);\\n\\nerror RoyaltyFeeRatioOutOfRange();\\n\\nerror UnauthorizedToExchangeRoyaltyTokenToETH();\\n\\nerror Blacklisted();\\n\\nerror NotInWhitelist();\\n\\nerror InvalidETHRatio();\\n\\nerror ExceedMaxMintableRound();\\n\\nerror ExceedDaoMintableRound();\\n\\nerror NewMintableRoundsFewerThanRewardIssuedRounds();\\n\\nerror InvalidRound();\\n\\nerror ExceedMinterMaxMintAmount();\\n\\nerror NftExceedMaxAmount();\\n\\nerror ZeroFloorPriceCannotUseLinearPriceVariation();\\n\\nerror D4APaused();\\n\\nerror Paused(bytes32 id);\\n\\nerror UriAlreadyExist(string uri);\\n\\nerror UriNotExist(string uri);\\n\\nerror DaoIndexTooLarge();\\n\\nerror DaoIndexAlreadyExist();\\n\\nerror InvalidSignature();\\n\\nerror DaoNotExist();\\n\\nerror CanvasNotExist();\\n\\nerror PriceTooLow();\\n\\nerror NotEnoughEther();\\n\\nerror D4AProjectAlreadyExist(bytes32 daoId);\\n\\nerror D4ACanvasAlreadyExist(bytes32 canvasId);\\n\\nerror StartRoundAlreadyPassed();\\n\\nerror DaoNotStarted();\\n\\nerror NotOperationRole();\\n\\nerror UnableToUnlock();\\n\\nerror BasicDaoLocked();\\n\\nerror NotCanvasIdOfSpecialTokenUri();\\n\\nerror NotBasicDaoNftFlatPrice();\\n\\nerror SupplyOutOfRange();\\n\\nerror ExceedDailyMintCap();\\n\\nerror NotBasicDaoFloorPrice();\\n\\nerror NotBasicDaoOwner();\\n\\nerror ZeroNftReserveNumber();\\n\"\r\n    },\r\n    \"contracts/storages/DaoStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport { PriceTemplateType, RewardTemplateType, DaoTag } from \\\"../interface/D4AEnums.sol\\\";\\nimport { DaoMintInfo, NftMinterCapInfo, NftMinterCap } from \\\"contracts/interface/D4AStructs.sol\\\";\\n\\nlibrary DaoStorage {\\n    struct DaoInfo {\\n        // metadata\\n        uint256 startRound;\\n        uint256 mintableRound;\\n        uint256 daoIndex;\\n        string daoUri;\\n        address daoFeePool;\\n        // token related info\\n        address token;\\n        uint256 tokenMaxSupply;\\n        // nft related info\\n        address nft;\\n        uint256 nftMaxSupply;\\n        uint256 nftTotalSupply;\\n        uint96 royaltyFeeRatioInBps;\\n        // miscellanous\\n        bool daoExist;\\n        PriceTemplateType priceTemplateType;\\n        RewardTemplateType rewardTemplateType;\\n        DaoTag daoTag;\\n        DaoMintInfo daoMintInfo;\\n        bytes32[] canvases;\\n        uint256 nftPriceFactor;\\n        uint256 daoFeePoolETHRatioInBps;\\n        uint256 daoFeePoolETHRatioInBpsFlatPrice;\\n        NftMinterCap nftMinterCap;\\n        NftMinterCapInfo[] nftMinterCapInfo;\\n        mapping(uint256 => uint256) dailyMint;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 daoId => DaoInfo) daoInfos;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"D4Av2.contracts.storage.DaoStorage\\\");\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/storages/SettingsStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.10;\\n\\nimport { ID4ADrb } from \\\"../interface/ID4ADrb.sol\\\";\\nimport { ID4AFeePoolFactory } from \\\"../interface/ID4AFeePoolFactory.sol\\\";\\nimport { ID4AERC20Factory } from \\\"../interface/ID4AERC20Factory.sol\\\";\\nimport { ID4AERC721Factory } from \\\"../interface/ID4AERC721Factory.sol\\\";\\nimport { ID4AOwnerProxy } from \\\"../interface/ID4AOwnerProxy.sol\\\";\\nimport { IPermissionControl } from \\\"../interface/IPermissionControl.sol\\\";\\n\\nlibrary SettingsStorage {\\n    struct Layout {\\n        // fee related\\n        uint256 createDaoFeeAmount;\\n        uint256 createCanvasFeeAmount;\\n        uint256 protocolMintFeeRatioInBps;\\n        uint256 daoFeePoolMintFeeRatioInBps;\\n        uint256 daoFeePoolMintFeeRatioInBpsFlatPrice;\\n        uint256 protocolRoyaltyFeeRatioInBps;\\n        uint256 minRoyaltyFeeRatioInBps;\\n        uint256 maxRoyaltyFeeRatioInBps;\\n        uint256 protocolERC20RatioInBps;\\n        uint256 daoCreatorERC20RatioInBps;\\n        uint256 canvasCreatorERC20RatioInBps;\\n        // contract address\\n        address protocolFeePool;\\n        ID4ADrb drb;\\n        ID4AERC20Factory erc20Factory;\\n        ID4AERC721Factory erc721Factory;\\n        ID4AFeePoolFactory feePoolFactory;\\n        ID4AOwnerProxy ownerProxy;\\n        IPermissionControl permissionControl;\\n        address createProjectProxy;\\n        // params\\n        uint256 tokenMaxSupply;\\n        uint256 maxMintableRound; //366\\n        uint256[] mintableRounds;\\n        uint256[] daoFloorPrices;\\n        uint256[] nftMaxSupplies;\\n        address assetOwner;\\n        bool isProtocolPaused;\\n        mapping(bytes32 => bool) pauseStatuses;\\n        uint256 reservedDaoAmount;\\n        address[256] priceTemplates;\\n        address[256] rewardTemplates;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"D4Av2.contracts.storage.Settings\\\");\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/storages/BasicDaoStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nlibrary BasicDaoStorage {\\n    struct BasicDaoInfo {\\n        bool unlocked;\\n        bytes32 canvasIdOfSpecialNft;\\n        uint256 tokenId;\\n        uint256 dailyMintCap;\\n        uint256 reserveNftNumber;\\n        bool unifiedPriceModeOff;\\n        uint256 unifiedPrice;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 daoId => BasicDaoInfo basicDaoInfo) basicDaoInfos;\\n        string specialTokenUriPrefix;\\n        uint256 basicDaoNftFlatPrice;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"D4Av2.contracts.storage.BasicDaoStorage\\\");\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/D4AProtocolReadable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport { BASIS_POINT, BASIC_DAO_RESERVE_NFT_NUMBER } from \\\"contracts/interface/D4AConstants.sol\\\";\\nimport { DaoTag } from \\\"contracts/interface/D4AEnums.sol\\\";\\nimport { DaoStorage } from \\\"contracts/storages/DaoStorage.sol\\\";\\nimport { BasicDaoStorage } from \\\"contracts/storages/BasicDaoStorage.sol\\\";\\nimport { CanvasStorage } from \\\"contracts/storages/CanvasStorage.sol\\\";\\nimport { PriceStorage } from \\\"contracts/storages/PriceStorage.sol\\\";\\nimport { RewardStorage } from \\\"./storages/RewardStorage.sol\\\";\\nimport { SettingsStorage } from \\\"./storages/SettingsStorage.sol\\\";\\nimport { ID4AProtocolReadable } from \\\"contracts/interface/ID4AProtocolReadable.sol\\\";\\nimport { IPriceTemplate } from \\\"contracts/interface/IPriceTemplate.sol\\\";\\nimport { IRewardTemplate } from \\\"contracts/interface/IRewardTemplate.sol\\\";\\n\\ncontract D4AProtocolReadable is ID4AProtocolReadable {\\n    // legacy functions\\n    function getProjectCanvasAt(bytes32 daoId, uint256 index) public view returns (bytes32) {\\n        return DaoStorage.layout().daoInfos[daoId].canvases[index];\\n    }\\n\\n    function getProjectInfo(bytes32 daoId)\\n        public\\n        view\\n        returns (\\n            uint256 startRound,\\n            uint256 mintableRound,\\n            uint256 nftMaxSupply,\\n            address daoFeePool,\\n            uint96 royaltyFeeRatioInBps,\\n            uint256 daoIndex,\\n            string memory daoUri,\\n            uint256 tokenMaxSupply\\n        )\\n    {\\n        DaoStorage.DaoInfo storage pi = DaoStorage.layout().daoInfos[daoId];\\n        startRound = pi.startRound;\\n        mintableRound = pi.mintableRound;\\n        nftMaxSupply = pi.nftMaxSupply;\\n        daoFeePool = pi.daoFeePool;\\n        royaltyFeeRatioInBps = pi.royaltyFeeRatioInBps;\\n        daoIndex = pi.daoIndex;\\n        daoUri = pi.daoUri;\\n        tokenMaxSupply = pi.tokenMaxSupply;\\n    }\\n\\n    function getProjectFloorPrice(bytes32 daoId) public view returns (uint256) {\\n        return PriceStorage.layout().daoFloorPrices[daoId];\\n    }\\n\\n    function getProjectTokens(bytes32 daoId) public view returns (address token, address nft) {\\n        DaoStorage.DaoInfo storage daoInfo = DaoStorage.layout().daoInfos[daoId];\\n        token = daoInfo.token;\\n        nft = daoInfo.nft;\\n    }\\n\\n    function getCanvasNFTCount(bytes32 canvasId) public view returns (uint256) {\\n        return CanvasStorage.layout().canvasInfos[canvasId].tokenIds.length;\\n    }\\n\\n    function getTokenIDAt(bytes32 canvasId, uint256 index) public view returns (uint256) {\\n        return CanvasStorage.layout().canvasInfos[canvasId].tokenIds[index];\\n    }\\n\\n    function getCanvasProject(bytes32 canvasId) public view returns (bytes32) {\\n        return CanvasStorage.layout().canvasInfos[canvasId].daoId;\\n    }\\n\\n    function getCanvasURI(bytes32 canvasId) public view returns (string memory) {\\n        return CanvasStorage.layout().canvasInfos[canvasId].canvasUri;\\n    }\\n\\n    function getProjectCanvasCount(bytes32 daoId) public view returns (uint256) {\\n        return DaoStorage.layout().daoInfos[daoId].canvases.length;\\n    }\\n\\n    // new functions\\n    // DAO related functions\\n    function getDaoStartRound(bytes32 daoId) external view returns (uint256 startRound) {\\n        return DaoStorage.layout().daoInfos[daoId].startRound;\\n    }\\n\\n    function getDaoMintableRound(bytes32 daoId) external view returns (uint256 mintableRound) {\\n        return DaoStorage.layout().daoInfos[daoId].mintableRound;\\n    }\\n\\n    function getDaoIndex(bytes32 daoId) external view returns (uint256 index) {\\n        return DaoStorage.layout().daoInfos[daoId].daoIndex;\\n    }\\n\\n    function getDaoUri(bytes32 daoId) external view returns (string memory daoUri) {\\n        return DaoStorage.layout().daoInfos[daoId].daoUri;\\n    }\\n\\n    function getDaoFeePool(bytes32 daoId) external view returns (address daoFeePool) {\\n        return DaoStorage.layout().daoInfos[daoId].daoFeePool;\\n    }\\n\\n    function getDaoToken(bytes32 daoId) external view returns (address token) {\\n        return DaoStorage.layout().daoInfos[daoId].token;\\n    }\\n\\n    function getDaoTokenMaxSupply(bytes32 daoId) external view returns (uint256 tokenMaxSupply) {\\n        return DaoStorage.layout().daoInfos[daoId].tokenMaxSupply;\\n    }\\n\\n    function getDaoNft(bytes32 daoId) external view returns (address nft) {\\n        return DaoStorage.layout().daoInfos[daoId].nft;\\n    }\\n\\n    function getDaoNftMaxSupply(bytes32 daoId) external view returns (uint256 nftMaxSupply) {\\n        return DaoStorage.layout().daoInfos[daoId].nftMaxSupply;\\n    }\\n\\n    function getDaoNftTotalSupply(bytes32 daoId) external view returns (uint256 nftTotalSupply) {\\n        return DaoStorage.layout().daoInfos[daoId].nftTotalSupply;\\n    }\\n\\n    function getDaoNftRoyaltyFeeRatioInBps(bytes32 daoId) external view returns (uint96 royaltyFeeRatioInBps) {\\n        return DaoStorage.layout().daoInfos[daoId].royaltyFeeRatioInBps;\\n    }\\n\\n    function getDaoExist(bytes32 daoId) external view returns (bool exist) {\\n        return DaoStorage.layout().daoInfos[daoId].daoExist;\\n    }\\n\\n    function getDaoCanvases(bytes32 daoId) external view returns (bytes32[] memory canvases) {\\n        return DaoStorage.layout().daoInfos[daoId].canvases;\\n    }\\n\\n    function getDaoPriceTemplate(bytes32 daoId) external view returns (address priceTemplate) {\\n        return SettingsStorage.layout().priceTemplates[uint8(DaoStorage.layout().daoInfos[daoId].priceTemplateType)];\\n    }\\n\\n    function getDaoPriceFactor(bytes32 daoId) external view returns (uint256 priceFactor) {\\n        return DaoStorage.layout().daoInfos[daoId].nftPriceFactor;\\n    }\\n\\n    function getDaoRewardTemplate(bytes32 daoId) external view override returns (address rewardTemplate) {\\n        return SettingsStorage.layout().rewardTemplates[uint8(DaoStorage.layout().daoInfos[daoId].rewardTemplateType)];\\n    }\\n\\n    function getDaoMintCap(bytes32 daoId) public view returns (uint32) {\\n        return DaoStorage.layout().daoInfos[daoId].daoMintInfo.daoMintCap;\\n    }\\n\\n    function getDaoNftHolderMintCap(bytes32 daoId) public view returns (uint32) {\\n        return DaoStorage.layout().daoInfos[daoId].daoMintInfo.NFTHolderMintCap;\\n    }\\n\\n    function getUserMintInfo(bytes32 daoId, address account) public view returns (uint32 minted, uint32 userMintCap) {\\n        minted = DaoStorage.layout().daoInfos[daoId].daoMintInfo.userMintInfos[account].minted;\\n        userMintCap = DaoStorage.layout().daoInfos[daoId].daoMintInfo.userMintInfos[account].mintCap;\\n    }\\n\\n    function getDaoFeePoolETHRatio(bytes32 daoId) public view returns (uint256) {\\n        DaoStorage.DaoInfo storage daoInfo = DaoStorage.layout().daoInfos[daoId];\\n        if (daoInfo.daoFeePoolETHRatioInBps == 0) {\\n            return SettingsStorage.layout().daoFeePoolMintFeeRatioInBps;\\n        }\\n        return daoInfo.daoFeePoolETHRatioInBps;\\n    }\\n\\n    function getDaoFeePoolETHRatioFlatPrice(bytes32 daoId) public view returns (uint256) {\\n        DaoStorage.DaoInfo storage daoInfo = DaoStorage.layout().daoInfos[daoId];\\n        if (daoInfo.daoFeePoolETHRatioInBpsFlatPrice == 0) {\\n            return SettingsStorage.layout().daoFeePoolMintFeeRatioInBpsFlatPrice;\\n        }\\n        return daoInfo.daoFeePoolETHRatioInBpsFlatPrice;\\n    }\\n\\n    function getDaoTag(bytes32 daoId) public view returns (string memory) {\\n        DaoTag tag = DaoStorage.layout().daoInfos[daoId].daoTag;\\n        if (tag == DaoTag.D4A_DAO) return \\\"D4A DAO\\\";\\n        else if (tag == DaoTag.BASIC_DAO) return \\\"BASIC DAO\\\";\\n        else return \\\"\\\";\\n    }\\n\\n    // canvas related functions\\n    function getCanvasDaoId(bytes32 canvasId) external view returns (bytes32 daoId) {\\n        return CanvasStorage.layout().canvasInfos[canvasId].daoId;\\n    }\\n\\n    function getCanvasTokenIds(bytes32 canvasId) external view returns (uint256[] memory tokenIds) {\\n        return CanvasStorage.layout().canvasInfos[canvasId].tokenIds;\\n    }\\n\\n    function getCanvasIndex(bytes32 canvasId) public view returns (uint256) {\\n        return CanvasStorage.layout().canvasInfos[canvasId].index;\\n    }\\n\\n    function getCanvasUri(bytes32 canvasId) external view returns (string memory canvasUri) {\\n        return CanvasStorage.layout().canvasInfos[canvasId].canvasUri;\\n    }\\n\\n    function getCanvasRebateRatioInBps(bytes32 canvasId) public view returns (uint256) {\\n        return CanvasStorage.layout().canvasInfos[canvasId].canvasRebateRatioInBps;\\n    }\\n\\n    function getCanvasExist(bytes32 canvasId) external view returns (bool exist) {\\n        return CanvasStorage.layout().canvasInfos[canvasId].canvasExist;\\n    }\\n\\n    // prices related functions\\n    function getCanvasLastPrice(bytes32 canvasId) public view returns (uint256 round, uint256 price) {\\n        PriceStorage.MintInfo storage mintInfo = PriceStorage.layout().canvasLastMintInfos[canvasId];\\n        return (mintInfo.round, mintInfo.price);\\n    }\\n\\n    function getCanvasNextPrice(bytes32 canvasId) public view returns (uint256) {\\n        bytes32 daoId = CanvasStorage.layout().canvasInfos[canvasId].daoId;\\n        uint256 daoFloorPrice = PriceStorage.layout().daoFloorPrices[daoId];\\n        PriceStorage.MintInfo memory maxPrice = PriceStorage.layout().daoMaxPrices[daoId];\\n        PriceStorage.MintInfo memory mintInfo = PriceStorage.layout().canvasLastMintInfos[canvasId];\\n        DaoStorage.DaoInfo storage pi = DaoStorage.layout().daoInfos[daoId];\\n        SettingsStorage.Layout storage settingsStorage = SettingsStorage.layout();\\n        return IPriceTemplate(\\n            settingsStorage.priceTemplates[uint8(DaoStorage.layout().daoInfos[daoId].priceTemplateType)]\\n        ).getCanvasNextPrice(\\n            pi.startRound, settingsStorage.drb.currentRound(), pi.nftPriceFactor, daoFloorPrice, maxPrice, mintInfo\\n        );\\n    }\\n\\n    function getDaoMaxPriceInfo(bytes32 daoId) external view returns (uint256 round, uint256 price) {\\n        PriceStorage.MintInfo memory maxPrice = PriceStorage.layout().daoMaxPrices[daoId];\\n        return (maxPrice.round, maxPrice.price);\\n    }\\n\\n    function getDaoFloorPrice(bytes32 daoId) external view returns (uint256 floorPrice) {\\n        return PriceStorage.layout().daoFloorPrices[daoId];\\n    }\\n\\n    // reward related functions\\n    function getDaoRewardStartRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 startRound)\\n    {\\n        return RewardStorage.layout().rewardInfos[daoId].rewardCheckpoints[rewardCheckpointIndex].startRound;\\n    }\\n\\n    function getDaoRewardTotalRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 totalRound)\\n    {\\n        return RewardStorage.layout().rewardInfos[daoId].rewardCheckpoints[rewardCheckpointIndex].totalRound;\\n    }\\n\\n    function getDaoTotalReward(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 totalReward)\\n    {\\n        return RewardStorage.layout().rewardInfos[daoId].rewardCheckpoints[rewardCheckpointIndex].totalReward;\\n    }\\n\\n    function getDaoRewardDecayFactor(bytes32 daoId) external view returns (uint256 rewardDecayFactor) {\\n        return RewardStorage.layout().rewardInfos[daoId].rewardDecayFactor;\\n    }\\n\\n    function getDaoRewardIsProgressiveJackpot(bytes32 daoId) external view returns (bool isProgressiveJackpot) {\\n        return RewardStorage.layout().rewardInfos[daoId].isProgressiveJackpot;\\n    }\\n\\n    function getDaoRewardLastActiveRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 lastActiveRound)\\n    {\\n        return RewardStorage.layout().rewardInfos[daoId].rewardCheckpoints[rewardCheckpointIndex].lastActiveRound;\\n    }\\n\\n    function getDaoRewardActiveRounds(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256[] memory activeRounds)\\n    {\\n        return RewardStorage.layout().rewardInfos[daoId].rewardCheckpoints[rewardCheckpointIndex].activeRounds;\\n    }\\n\\n    function getDaoCreatorClaimableRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 claimableRound)\\n    {\\n        RewardStorage.RewardCheckpoint storage rewardCheckpoint =\\n            RewardStorage.layout().rewardInfos[daoId].rewardCheckpoints[rewardCheckpointIndex];\\n        return rewardCheckpoint.activeRounds[rewardCheckpoint.daoCreatorClaimableRoundIndex];\\n    }\\n\\n    function getCanvasCreatorClaimableRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointsIndex,\\n        bytes32 canvasId\\n    )\\n        external\\n        view\\n        returns (uint256 claimableRound)\\n    {\\n        RewardStorage.RewardCheckpoint storage rewardCheckpoint =\\n            RewardStorage.layout().rewardInfos[daoId].rewardCheckpoints[rewardCheckpointsIndex];\\n        return rewardCheckpoint.activeRounds[rewardCheckpoint.canvasCreatorClaimableRoundIndexes[canvasId]];\\n    }\\n\\n    function getNftMinterClaimableRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointsIndex,\\n        address nftMinter\\n    )\\n        external\\n        view\\n        returns (uint256 claimableRound)\\n    {\\n        RewardStorage.RewardCheckpoint storage rewardCheckpoint =\\n            RewardStorage.layout().rewardInfos[daoId].rewardCheckpoints[rewardCheckpointsIndex];\\n        return rewardCheckpoint.activeRounds[rewardCheckpoint.nftMinterClaimableRoundIndexes[nftMinter]];\\n    }\\n\\n    function getTotalWeight(bytes32 daoId, uint256 round) external view returns (uint256 totalWeight) {\\n        return RewardStorage.layout().rewardInfos[daoId].totalWeights[round];\\n    }\\n\\n    function getProtocolWeight(bytes32 daoId, uint256 round) external view returns (uint256 protocolWeight) {\\n        return RewardStorage.layout().rewardInfos[daoId].protocolWeights[round];\\n    }\\n\\n    function getDaoCreatorWeight(bytes32 daoId, uint256 round) external view returns (uint256 creatorWeight) {\\n        return RewardStorage.layout().rewardInfos[daoId].daoCreatorWeights[round];\\n    }\\n\\n    function getCanvasCreatorWeight(\\n        bytes32 daoId,\\n        uint256 round,\\n        bytes32 canvasId\\n    )\\n        external\\n        view\\n        returns (uint256 creatorWeight)\\n    {\\n        return RewardStorage.layout().rewardInfos[daoId].canvasCreatorWeights[round][canvasId];\\n    }\\n\\n    function getNftMinterWeight(\\n        bytes32 daoId,\\n        uint256 round,\\n        address nftMinter\\n    )\\n        external\\n        view\\n        returns (uint256 minterWeight)\\n    {\\n        return RewardStorage.layout().rewardInfos[daoId].nftMinterWeights[round][nftMinter];\\n    }\\n\\n    function getDaoCreatorERC20Ratio(bytes32 daoId) public view returns (uint256) {\\n        SettingsStorage.Layout storage settingsStorage = SettingsStorage.layout();\\n        uint256 daoCreatorERC20RatioInBps = RewardStorage.layout().rewardInfos[daoId].daoCreatorERC20RatioInBps;\\n        if (daoCreatorERC20RatioInBps == 0) {\\n            return settingsStorage.daoCreatorERC20RatioInBps;\\n        }\\n        return (daoCreatorERC20RatioInBps * (BASIS_POINT - settingsStorage.protocolERC20RatioInBps)) / BASIS_POINT;\\n    }\\n\\n    function getCanvasCreatorERC20Ratio(bytes32 daoId) public view returns (uint256) {\\n        SettingsStorage.Layout storage settingsStorage = SettingsStorage.layout();\\n        uint256 canvasCreatorERC20RatioInBps = RewardStorage.layout().rewardInfos[daoId].canvasCreatorERC20RatioInBps;\\n        if (canvasCreatorERC20RatioInBps == 0) {\\n            return settingsStorage.canvasCreatorERC20RatioInBps;\\n        }\\n        return (canvasCreatorERC20RatioInBps * (BASIS_POINT - settingsStorage.protocolERC20RatioInBps)) / BASIS_POINT;\\n    }\\n\\n    function getNftMinterERC20Ratio(bytes32 daoId) public view returns (uint256) {\\n        return BASIS_POINT - SettingsStorage.layout().protocolERC20RatioInBps - getDaoCreatorERC20Ratio(daoId)\\n            - getCanvasCreatorERC20Ratio(daoId);\\n    }\\n\\n    function getRoundReward(bytes32 daoId, uint256 round) public view returns (uint256) {\\n        return _castGetRoundRewardToView(_getRoundReward)(daoId, round);\\n    }\\n\\n    function getRewardTillRound(bytes32 daoId, uint256 round) public view returns (uint256) {\\n        RewardStorage.RewardInfo storage rewardInfo = RewardStorage.layout().rewardInfos[daoId];\\n        RewardStorage.RewardCheckpoint[] storage rewardCheckpoints = rewardInfo.rewardCheckpoints;\\n\\n        uint256 totalRoundReward;\\n        for (uint256 i; i < rewardCheckpoints.length; i++) {\\n            uint256[] memory activeRounds = rewardCheckpoints[i].activeRounds;\\n            for (uint256 j; j < activeRounds.length && activeRounds[j] <= round; j++) {\\n                totalRoundReward += getRoundReward(daoId, activeRounds[j]);\\n            }\\n        }\\n\\n        return totalRoundReward;\\n    }\\n\\n    function getDaoDailyMintCap(bytes32 daoId) public view returns (uint256) {\\n        BasicDaoStorage.Layout storage basicDaoStorage = BasicDaoStorage.layout();\\n        return basicDaoStorage.basicDaoInfos[daoId].dailyMintCap;\\n    }\\n\\n    function getDaoUnifiedPriceModeOff(bytes32 daoId) public view returns (bool) {\\n        BasicDaoStorage.Layout storage basicDaoStorage = BasicDaoStorage.layout();\\n        return basicDaoStorage.basicDaoInfos[daoId].unifiedPriceModeOff;\\n    }\\n\\n    //9999 = 0, 0 = 0.01,\\n    function getDaoUnifiedPrice(bytes32 daoId) public view returns (uint256) {\\n        BasicDaoStorage.BasicDaoInfo storage basicDaoInfo = BasicDaoStorage.layout().basicDaoInfos[daoId];\\n        if (basicDaoInfo.unifiedPrice == 9999 ether) {\\n            return 0;\\n        } else {\\n            return basicDaoInfo.unifiedPrice == 0\\n                ? BasicDaoStorage.layout().basicDaoNftFlatPrice\\n                : basicDaoInfo.unifiedPrice;\\n        }\\n    }\\n\\n    function getDaoReserveNftNumber(bytes32 daoId) public view returns (uint256) {\\n        BasicDaoStorage.BasicDaoInfo storage basicDaoInfo = BasicDaoStorage.layout().basicDaoInfos[daoId];\\n        return basicDaoInfo.reserveNftNumber == 0 ? BASIC_DAO_RESERVE_NFT_NUMBER : basicDaoInfo.reserveNftNumber;\\n    }\\n\\n    function _getRoundReward(bytes32 daoId, uint256 round) internal returns (uint256) {\\n        address rewardTemplate =\\n            SettingsStorage.layout().rewardTemplates[uint8(DaoStorage.layout().daoInfos[daoId].rewardTemplateType)];\\n\\n        (bool succ, bytes memory data) =\\n            rewardTemplate.delegatecall(abi.encodeWithSelector(IRewardTemplate.getRoundReward.selector, daoId, round));\\n        if (!succ) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n        return abi.decode(data, (uint256));\\n    }\\n\\n    function _castGetRoundRewardToView(function(bytes32, uint256) internal returns (uint256) fnIn)\\n        internal\\n        pure\\n        returns (function(bytes32, uint256) internal view returns (uint256) fnOut)\\n    {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/D4AProtocolSetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport { FixedPointMathLib as Math } from \\\"solady/utils/FixedPointMathLib.sol\\\";\\nimport { SafeCastLib } from \\\"solady/utils/SafeCastLib.sol\\\";\\n\\nimport { BASIS_POINT } from \\\"contracts/interface/D4AConstants.sol\\\";\\nimport {\\n    UserMintCapParam,\\n    TemplateParam,\\n    DaoMintInfo,\\n    Whitelist,\\n    Blacklist,\\n    SetDaoParam,\\n    NftMinterCapInfo,\\n    NftMinterCap\\n} from \\\"contracts/interface/D4AStructs.sol\\\";\\nimport { PriceTemplateType } from \\\"contracts/interface/D4AEnums.sol\\\";\\nimport \\\"contracts/interface/D4AErrors.sol\\\";\\nimport { DaoStorage } from \\\"contracts/storages/DaoStorage.sol\\\";\\nimport { BasicDaoStorage } from \\\"contracts/storages/BasicDaoStorage.sol\\\";\\nimport { CanvasStorage } from \\\"contracts/storages/CanvasStorage.sol\\\";\\nimport { PriceStorage } from \\\"contracts/storages/PriceStorage.sol\\\";\\nimport { RewardStorage } from \\\"./storages/RewardStorage.sol\\\";\\nimport { SettingsStorage } from \\\"./storages/SettingsStorage.sol\\\";\\nimport { ID4AProtocolSetter } from \\\"contracts/interface/ID4AProtocolSetter.sol\\\";\\nimport { IRewardTemplate } from \\\"contracts/interface/IRewardTemplate.sol\\\";\\nimport { D4AProtocolReadable } from \\\"contracts/D4AProtocolReadable.sol\\\";\\nimport { ID4AProtocolReadable } from \\\"./interface/ID4AProtocolReadable.sol\\\";\\n\\ncontract D4AProtocolSetter is ID4AProtocolSetter {\\n    function setMintCapAndPermission(\\n        bytes32 daoId,\\n        uint32 daoMintCap,\\n        UserMintCapParam[] calldata userMintCapParams,\\n        NftMinterCapInfo[] calldata nftMinterCapInfo,\\n        Whitelist memory whitelist,\\n        Blacklist memory blacklist,\\n        Blacklist memory unblacklist\\n    )\\n        public\\n        virtual\\n    {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.createProjectProxy && msg.sender != l.ownerProxy.ownerOf(daoId)) {\\n            revert NotDaoOwner();\\n        }\\n        DaoMintInfo storage daoMintInfo = DaoStorage.layout().daoInfos[daoId].daoMintInfo;\\n        daoMintInfo.daoMintCap = daoMintCap;\\n\\n        uint256 length = userMintCapParams.length;\\n        for (uint256 i; i < length;) {\\n            daoMintInfo.userMintInfos[userMintCapParams[i].minter].mintCap = userMintCapParams[i].mintCap;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        length = DaoStorage.layout().daoInfos[daoId].nftMinterCapInfo.length;\\n        for (uint256 i; i < length;) {\\n            DaoStorage.layout().daoInfos[daoId].nftMinterCapInfo.pop();\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        length = nftMinterCapInfo.length;\\n        for (uint256 i; i < length;) {\\n            DaoStorage.layout().daoInfos[daoId].nftMinterCapInfo.push(nftMinterCapInfo[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit MintCapSet(daoId, daoMintCap, userMintCapParams, nftMinterCapInfo);\\n\\n        l.permissionControl.modifyPermission(daoId, whitelist, blacklist, unblacklist);\\n    }\\n\\n    // \u4fee\u6539Dao\u53c2\u6570\\n    function setDaoParams(SetDaoParam memory vars) public virtual {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.ownerProxy.ownerOf(vars.daoId)) revert NotDaoOwner();\\n\\n        setDaoNftMaxSupply(vars.daoId, l.nftMaxSupplies[vars.nftMaxSupplyRank]);\\n        setDaoMintableRound(vars.daoId, l.mintableRounds[vars.mintableRoundRank]);\\n        setDaoFloorPrice(vars.daoId, vars.daoFloorPriceRank == 9999 ? 0 : l.daoFloorPrices[vars.daoFloorPriceRank]);\\n        setDaoPriceTemplate(vars.daoId, vars.priceTemplateType, vars.nftPriceFactor);\\n        setRatio(\\n            vars.daoId,\\n            vars.daoCreatorERC20Ratio,\\n            vars.canvasCreatorERC20Ratio,\\n            vars.nftMinterERC20Ratio,\\n            vars.daoFeePoolETHRatio,\\n            vars.daoFeePoolETHRatioFlatPrice\\n        );\\n        setDailyMintCap(vars.daoId, vars.dailyMintCap);\\n        setDaoTokenSupply(vars.daoId, vars.addedDaoToken);\\n        setDaoUnifiedPrice(vars.daoId, vars.unifiedPrice);\\n    }\\n\\n    function setDaoNftMaxSupply(bytes32 daoId, uint256 newMaxSupply) public virtual {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.ownerProxy.ownerOf(daoId)) revert NotDaoOwner();\\n\\n        DaoStorage.layout().daoInfos[daoId].nftMaxSupply = newMaxSupply;\\n\\n        emit DaoNftMaxSupplySet(daoId, newMaxSupply);\\n    }\\n\\n    function setDaoMintableRound(bytes32 daoId, uint256 newMintableRound) public virtual {\\n        DaoStorage.DaoInfo storage daoInfo = DaoStorage.layout().daoInfos[daoId];\\n        if (daoInfo.mintableRound == newMintableRound) return;\\n\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.ownerProxy.ownerOf(daoId)) revert NotDaoOwner();\\n\\n        RewardStorage.RewardInfo storage rewardInfo = RewardStorage.layout().rewardInfos[daoId];\\n        RewardStorage.RewardCheckpoint storage rewardCheckpoint =\\n            rewardInfo.rewardCheckpoints[rewardInfo.rewardCheckpoints.length - 1];\\n        uint256 currentRound = l.drb.currentRound();\\n        uint256 oldMintableRound = daoInfo.mintableRound;\\n        int256 mintableRoundDelta = SafeCastLib.toInt256(newMintableRound) - SafeCastLib.toInt256(oldMintableRound);\\n        if (newMintableRound > l.maxMintableRound) revert ExceedMaxMintableRound();\\n        if (rewardInfo.isProgressiveJackpot) {\\n            if (currentRound >= rewardCheckpoint.startRound + rewardCheckpoint.totalRound) {\\n                revert ExceedDaoMintableRound();\\n            }\\n            if (\\n                SafeCastLib.toInt256(rewardCheckpoint.startRound + rewardCheckpoint.totalRound) + mintableRoundDelta\\n                    < SafeCastLib.toInt256(currentRound)\\n            ) revert NewMintableRoundsFewerThanRewardIssuedRounds();\\n        } else {\\n            uint256 finalActiveRound;\\n            {\\n                for (uint256 i = rewardInfo.rewardCheckpoints.length - 1; ~i != 0;) {\\n                    uint256[] storage activeRounds = rewardInfo.rewardCheckpoints[i].activeRounds;\\n                    if (activeRounds.length > 0) finalActiveRound = activeRounds[activeRounds.length - 1];\\n                    unchecked {\\n                        --i;\\n                    }\\n                }\\n            }\\n\\n            if (rewardCheckpoint.activeRounds.length >= rewardCheckpoint.totalRound && currentRound > finalActiveRound)\\n            {\\n                revert ExceedDaoMintableRound();\\n            }\\n            if (\\n                SafeCastLib.toInt256(rewardCheckpoint.totalRound) + mintableRoundDelta\\n                    < SafeCastLib.toInt256(rewardCheckpoint.activeRounds.length)\\n            ) {\\n                revert NewMintableRoundsFewerThanRewardIssuedRounds();\\n            }\\n        }\\n\\n        daoInfo.mintableRound = newMintableRound;\\n\\n        (bool succ,) = l.rewardTemplates[uint8(daoInfo.rewardTemplateType)].delegatecall(\\n            abi.encodeWithSelector(IRewardTemplate.setRewardCheckpoint.selector, daoId, mintableRoundDelta, 0)\\n        );\\n        require(succ);\\n\\n        emit DaoMintableRoundSet(daoId, newMintableRound);\\n    }\\n\\n    function setDaoFloorPrice(bytes32 daoId, uint256 newFloorPrice) public virtual {\\n        PriceStorage.Layout storage priceStorage = PriceStorage.layout();\\n        if (priceStorage.daoFloorPrices[daoId] == newFloorPrice) return;\\n\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.ownerProxy.ownerOf(daoId)) revert NotDaoOwner();\\n\\n        bytes32[] memory canvases = DaoStorage.layout().daoInfos[daoId].canvases;\\n        uint256 length = canvases.length;\\n        for (uint256 i; i < length;) {\\n            uint256 canvasNextPrice = D4AProtocolReadable(address(this)).getCanvasNextPrice(canvases[i]);\\n            if (canvasNextPrice >= newFloorPrice) {\\n                priceStorage.canvasLastMintInfos[canvases[i]] =\\n                    PriceStorage.MintInfo({ round: l.drb.currentRound() - 1, price: canvasNextPrice });\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        priceStorage.daoMaxPrices[daoId] = PriceStorage.MintInfo({ round: l.drb.currentRound(), price: newFloorPrice });\\n        priceStorage.daoFloorPrices[daoId] = newFloorPrice;\\n\\n        emit DaoFloorPriceSet(daoId, newFloorPrice);\\n    }\\n\\n    function setDaoPriceTemplate(\\n        bytes32 daoId,\\n        PriceTemplateType priceTemplateType,\\n        uint256 nftPriceFactor\\n    )\\n        public\\n        virtual\\n    {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.ownerProxy.ownerOf(daoId)) revert NotDaoOwner();\\n\\n        if (priceTemplateType == PriceTemplateType.EXPONENTIAL_PRICE_VARIATION) require(nftPriceFactor >= 10_000);\\n\\n        DaoStorage.DaoInfo storage daoInfo = DaoStorage.layout().daoInfos[daoId];\\n        daoInfo.priceTemplateType = priceTemplateType;\\n        daoInfo.nftPriceFactor = nftPriceFactor;\\n\\n        emit DaoPriceTemplateSet(daoId, priceTemplateType, nftPriceFactor);\\n    }\\n\\n    function setTemplate(bytes32 daoId, TemplateParam calldata templateParam) public virtual {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.ownerProxy.ownerOf(daoId) && msg.sender != l.createProjectProxy) revert NotDaoOwner();\\n\\n        DaoStorage.DaoInfo storage daoInfo = DaoStorage.layout().daoInfos[daoId];\\n        daoInfo.priceTemplateType = templateParam.priceTemplateType;\\n        daoInfo.nftPriceFactor = templateParam.priceFactor;\\n        daoInfo.rewardTemplateType = templateParam.rewardTemplateType;\\n\\n        RewardStorage.RewardInfo storage rewardInfo = RewardStorage.layout().rewardInfos[daoId];\\n        rewardInfo.rewardDecayFactor = templateParam.rewardDecayFactor;\\n        rewardInfo.isProgressiveJackpot = templateParam.isProgressiveJackpot;\\n\\n        (bool succ,) = l.rewardTemplates[uint8(daoInfo.rewardTemplateType)].delegatecall(\\n            abi.encodeWithSelector(IRewardTemplate.setRewardCheckpoint.selector, daoId, 0, 0)\\n        );\\n        require(succ);\\n\\n        emit DaoTemplateSet(daoId, templateParam);\\n    }\\n\\n    function setRatio(\\n        bytes32 daoId,\\n        uint256 daoCreatorERC20Ratio,\\n        uint256 canvasCreatorERC20Ratio,\\n        uint256 nftMinterERC20Ratio,\\n        uint256 daoFeePoolETHRatio,\\n        uint256 daoFeePoolETHRatioFlatPrice\\n    )\\n        public\\n        virtual\\n    {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.ownerProxy.ownerOf(daoId) && msg.sender != l.createProjectProxy) revert NotDaoOwner();\\n\\n        if (\\n            daoFeePoolETHRatioFlatPrice > BASIS_POINT - l.protocolMintFeeRatioInBps\\n                || daoFeePoolETHRatio > daoFeePoolETHRatioFlatPrice\\n        ) revert InvalidETHRatio();\\n\\n        RewardStorage.RewardInfo storage rewardInfo = RewardStorage.layout().rewardInfos[daoId];\\n        uint256 sum = daoCreatorERC20Ratio + canvasCreatorERC20Ratio + nftMinterERC20Ratio;\\n        uint256 daoCreatorERC20RatioInBps = Math.fullMulDivUp(daoCreatorERC20Ratio, BASIS_POINT, sum);\\n        uint256 canvasCreatorERC20RatioInBps = Math.fullMulDivUp(canvasCreatorERC20Ratio, BASIS_POINT, sum);\\n        rewardInfo.daoCreatorERC20RatioInBps = daoCreatorERC20RatioInBps;\\n        rewardInfo.canvasCreatorERC20RatioInBps = canvasCreatorERC20RatioInBps;\\n\\n        DaoStorage.DaoInfo storage daoInfo = DaoStorage.layout().daoInfos[daoId];\\n        daoInfo.daoFeePoolETHRatioInBps = daoFeePoolETHRatio;\\n        daoInfo.daoFeePoolETHRatioInBpsFlatPrice = daoFeePoolETHRatioFlatPrice;\\n\\n        emit DaoRatioSet(\\n            daoId,\\n            daoCreatorERC20Ratio,\\n            canvasCreatorERC20Ratio,\\n            nftMinterERC20Ratio,\\n            daoFeePoolETHRatio,\\n            daoFeePoolETHRatioFlatPrice\\n        );\\n    }\\n\\n    function setCanvasRebateRatioInBps(bytes32 canvasId, uint256 newCanvasRebateRatioInBps) public payable virtual {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.ownerProxy.ownerOf(canvasId)) revert NotCanvasOwner();\\n\\n        require(newCanvasRebateRatioInBps <= 10_000);\\n        CanvasStorage.layout().canvasInfos[canvasId].canvasRebateRatioInBps = newCanvasRebateRatioInBps;\\n\\n        emit CanvasRebateRatioInBpsSet(canvasId, newCanvasRebateRatioInBps);\\n    }\\n\\n    function setDailyMintCap(bytes32 daoId, uint256 dailyMintCap) public virtual {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.createProjectProxy && msg.sender != l.ownerProxy.ownerOf(daoId)) {\\n            revert NotDaoOwner();\\n        }\\n        BasicDaoStorage.Layout storage basicDaoStorage = BasicDaoStorage.layout();\\n        basicDaoStorage.basicDaoInfos[daoId].dailyMintCap = dailyMintCap;\\n\\n        emit DailyMintCapSet(daoId, dailyMintCap);\\n    }\\n\\n    function setDaoTokenSupply(bytes32 daoId, uint256 addedDaoToken) public virtual {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.createProjectProxy && msg.sender != l.ownerProxy.ownerOf(daoId)) {\\n            revert NotDaoOwner();\\n        }\\n        if (addedDaoToken == 0) return;\\n\\n        DaoStorage.DaoInfo storage daoInfo = DaoStorage.layout().daoInfos[daoId];\\n\\n        // \u8ffd\u52a0tokenMaxSupply\u5e76\u5224\u65ad\u603b\u6570\u5c0f\u4e8e10\u4ebf\\n        if (daoInfo.tokenMaxSupply + addedDaoToken > 1_000_000_000 ether) {\\n            revert SupplyOutOfRange();\\n        } else {\\n            daoInfo.tokenMaxSupply += addedDaoToken;\\n        }\\n\\n        (bool succ,) = l.rewardTemplates[uint8(daoInfo.rewardTemplateType)].delegatecall(\\n            abi.encodeWithSelector(IRewardTemplate.setRewardCheckpoint.selector, daoId, 0, addedDaoToken)\\n        );\\n        require(succ);\\n\\n        emit DaoTokenSupplySet(daoId, addedDaoToken);\\n    }\\n\\n    function setWhitelistMintCap(bytes32 daoId, address whitelistUser, uint32 whitelistUserMintCap) public virtual {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.createProjectProxy && msg.sender != l.ownerProxy.ownerOf(daoId)) {\\n            revert NotDaoOwner();\\n        }\\n\\n        DaoMintInfo storage daoMintInfo = DaoStorage.layout().daoInfos[daoId].daoMintInfo;\\n\\n        daoMintInfo.userMintInfos[whitelistUser].mintCap = whitelistUserMintCap;\\n\\n        emit WhiteListMintCapSet(daoId, whitelistUser, whitelistUserMintCap);\\n    }\\n\\n    function setDaoUnifiedPrice(bytes32 daoId, uint256 newUnifiedPrice) public virtual {\\n        SettingsStorage.Layout storage l = SettingsStorage.layout();\\n        if (msg.sender != l.createProjectProxy && msg.sender != l.ownerProxy.ownerOf(daoId)) {\\n            revert NotDaoOwner();\\n        }\\n        BasicDaoStorage.Layout storage basicDaoStorage = BasicDaoStorage.layout();\\n        basicDaoStorage.basicDaoInfos[daoId].unifiedPrice = newUnifiedPrice;\\n        emit DaoUnifiedPriceSet(daoId, ID4AProtocolReadable(address(this)).getDaoUnifiedPrice(daoId));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ID4ADrb.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface ID4ADrb {\\n    event CheckpointSet(uint256 startDrb, uint256 startBlock, uint256 blocksPerDrbE18);\\n\\n    function getCheckpointsLength() external view returns (uint256);\\n\\n    function getStartBlock(uint256 drb) external view returns (uint256);\\n\\n    function getDrb(uint256 blockNumber) external view returns (uint256);\\n\\n    function currentRound() external view returns (uint256);\\n\\n    function setNewCheckpoint(uint256 startDrb, uint256 startBlock, uint256 blocksPerDrbE18) external;\\n\\n    function modifyLastCheckpoint(uint256 startDrb, uint256 startBlock, uint256 blocksPerDrbE18) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ID4AFeePoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.10;\\n\\ninterface ID4AFeePoolFactory {\\n    function createD4AFeePool(string memory _name) external returns (address pool);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ID4AERC20Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.10;\\n\\ninterface ID4AERC20Factory {\\n    function createD4AERC20(string memory _name, string memory _symbol, address _minter) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ID4AERC721Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.10;\\n\\ninterface ID4AERC721Factory {\\n    function createD4AERC721(\\n        string memory name,\\n        string memory symbol,\\n        uint256 startTokenId\\n    )\\n        external\\n        returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ID4AOwnerProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.10;\\n\\ninterface ID4AOwnerProxy {\\n    function ownerOf(bytes32 hash) external view returns (address);\\n    function initOwnerOf(bytes32 hash, address addr) external returns (bool);\\n    function transferOwnership(bytes32 hash, address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPermissionControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.10;\\n\\nimport { Whitelist, Blacklist } from \\\"contracts/interface/D4AStructs.sol\\\";\\nimport { ID4AOwnerProxy } from \\\"contracts/interface/ID4AOwnerProxy.sol\\\";\\n\\ninterface IPermissionControl {\\n    event MinterBlacklisted(bytes32 indexed daoId, address indexed account);\\n\\n    event CanvasCreatorBlacklisted(bytes32 indexed daoId, address indexed account);\\n\\n    event MinterUnBlacklisted(bytes32 indexed daoId, address indexed account);\\n\\n    event CanvasCreatorUnBlacklisted(bytes32 indexed daoId, address indexed account);\\n\\n    event WhitelistModified(bytes32 indexed daoId, Whitelist whitelist);\\n\\n    function getWhitelist(bytes32 daoId) external view returns (Whitelist calldata whitelist);\\n\\n    function addPermissionWithSignature(\\n        bytes32 daoId,\\n        Whitelist calldata whitelist,\\n        Blacklist calldata blacklist,\\n        bytes calldata signature\\n    )\\n        external;\\n\\n    function addPermission(bytes32 daoId, Whitelist calldata whitelist, Blacklist calldata blacklist) external;\\n\\n    function modifyPermission(\\n        bytes32 daoId,\\n        Whitelist calldata whitelist,\\n        Blacklist calldata blacklist,\\n        Blacklist calldata unblacklist\\n    )\\n        external;\\n\\n    function isMinterBlacklisted(bytes32 daoId, address _account) external view returns (bool);\\n\\n    function isCanvasCreatorBlacklisted(bytes32 daoId, address _account) external view returns (bool);\\n\\n    function inMinterWhitelist(\\n        bytes32 daoId,\\n        address _account,\\n        bytes32[] calldata _proof\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    function inMinterNFTHolderPasses(Whitelist memory whitelist, address account) external view returns (bool);\\n\\n    function inCanvasCreatorWhitelist(\\n        bytes32 daoId,\\n        address _account,\\n        bytes32[] calldata _proof\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    function inCanvasCreatorNFTHolderPasses(Whitelist memory whitelist, address account) external view returns (bool);\\n\\n    function setOwnerProxy(ID4AOwnerProxy _ownerProxy) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/D4AConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nuint256 constant BASIS_POINT = 10_000;\\n\\nbytes32 constant DEFAULT_ADMIN_ROLE = 0;\\nbytes32 constant PROTOCOL_ROLE = keccak256(\\\"PROTOCOL_ROLE\\\");\\nbytes32 constant OPERATION_ROLE = keccak256(\\\"OPERATION_ROLE\\\");\\nbytes32 constant DAO_ROLE = keccak256(\\\"DAO_ROLE\\\");\\nbytes32 constant SIGNER_ROLE = keccak256(\\\"SIGNER_ROLE\\\");\\n\\nuint256 constant BASIC_DAO_RESERVE_NFT_NUMBER = 1000;\\n\"\r\n    },\r\n    \"contracts/storages/CanvasStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nlibrary CanvasStorage {\\n    struct CanvasInfo {\\n        bytes32 daoId;\\n        uint256[] tokenIds;\\n        uint256 index;\\n        string canvasUri;\\n        bool canvasExist;\\n        uint256 canvasRebateRatioInBps;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 canvasId => CanvasInfo) canvasInfos;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"D4Av2.contracts.storage.CanvasStorage\\\");\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/storages/PriceStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nlibrary PriceStorage {\\n    struct MintInfo {\\n        uint256 round;\\n        uint256 price;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 canvasId => MintInfo mintInfo) canvasLastMintInfos;\\n        mapping(bytes32 daoId => MintInfo) daoMaxPrices;\\n        mapping(bytes32 daoId => uint256 floorPrice) daoFloorPrices;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"D4Av2.contracts.storage.PriceStorage\\\");\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/storages/RewardStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nlibrary RewardStorage {\\n    struct RewardCheckpoint {\\n        uint256 startRound;\\n        uint256 totalRound;\\n        uint256 totalReward;\\n        uint256 lastActiveRound; // deprecated\\n        uint256[] activeRounds;\\n        // claimable round index\\n        uint256 daoCreatorClaimableRoundIndex;\\n        mapping(bytes32 canvasId => uint256 claimableRoundIndex) canvasCreatorClaimableRoundIndexes;\\n        mapping(address nftMinter => uint256 claimableRoundIndex) nftMinterClaimableRoundIndexes;\\n    }\\n\\n    struct RewardInfo {\\n        RewardCheckpoint[] rewardCheckpoints;\\n        uint256 rewardIssuePendingRound;\\n        uint256 rewardDecayFactor;\\n        bool isProgressiveJackpot;\\n        // weights\\n        mapping(uint256 round => uint256 totalWeight) totalWeights; // also total ETH in DAO fee pool at given round\\n        mapping(uint256 round => uint256 weight) protocolWeights;\\n        mapping(uint256 round => uint256 weight) daoCreatorWeights;\\n        mapping(uint256 round => mapping(bytes32 canvasId => uint256 weight)) canvasCreatorWeights;\\n        mapping(uint256 round => mapping(address nftMinter => uint256 weight)) nftMinterWeights;\\n        uint256 daoCreatorERC20RatioInBps;\\n        uint256 canvasCreatorERC20RatioInBps;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 daoId => RewardInfo rewardInfo) rewardInfos;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"D4Av2.contracts.storage.RewardStorage\\\");\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ID4AProtocolReadable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\ninterface ID4AProtocolReadable {\\n    // legacy functions\\n    function getProjectCanvasAt(bytes32 daoId, uint256 index) external view returns (bytes32);\\n\\n    function getProjectInfo(bytes32 daoId)\\n        external\\n        view\\n        returns (\\n            uint256 startRound,\\n            uint256 mintableRound,\\n            uint256 maxNftAmount,\\n            address daoFeePool,\\n            uint96 royaltyFeeRatioInBps,\\n            uint256 index,\\n            string memory daoUri,\\n            uint256 erc20TotalSupply\\n        );\\n\\n    function getProjectFloorPrice(bytes32 daoId) external view returns (uint256);\\n\\n    function getProjectTokens(bytes32 daoId) external view returns (address token, address nft);\\n\\n    function getCanvasNFTCount(bytes32 canvasId) external view returns (uint256);\\n\\n    function getTokenIDAt(bytes32 canvasId, uint256 index) external view returns (uint256);\\n\\n    function getCanvasProject(bytes32 canvasId) external view returns (bytes32);\\n\\n    function getCanvasURI(bytes32 canvasId) external view returns (string memory);\\n\\n    function getProjectCanvasCount(bytes32 daoId) external view returns (uint256);\\n\\n    // new functions\\n    // DAO related functions\\n    function getDaoStartRound(bytes32 daoId) external view returns (uint256 startRound);\\n\\n    function getDaoMintableRound(bytes32 daoId) external view returns (uint256 mintableRound);\\n\\n    function getDaoIndex(bytes32 daoId) external view returns (uint256 index);\\n\\n    function getDaoUri(bytes32 daoId) external view returns (string memory daoUri);\\n\\n    function getDaoFeePool(bytes32 daoId) external view returns (address daoFeePool);\\n\\n    function getDaoToken(bytes32 daoId) external view returns (address token);\\n\\n    function getDaoTokenMaxSupply(bytes32 daoId) external view returns (uint256 tokenMaxSupply);\\n\\n    function getDaoNft(bytes32 daoId) external view returns (address nft);\\n\\n    function getDaoNftMaxSupply(bytes32 daoId) external view returns (uint256 nftMaxSupply);\\n\\n    function getDaoNftTotalSupply(bytes32 daoId) external view returns (uint256 nftTotalSupply);\\n\\n    function getDaoNftRoyaltyFeeRatioInBps(bytes32 daoId) external view returns (uint96 royaltyFeeRatioInBps);\\n\\n    function getDaoExist(bytes32 daoId) external view returns (bool);\\n\\n    function getDaoCanvases(bytes32 daoId) external view returns (bytes32[] memory canvases);\\n\\n    function getDaoPriceTemplate(bytes32 daoId) external view returns (address priceTemplate);\\n\\n    function getDaoPriceFactor(bytes32 daoId) external view returns (uint256 priceFactor);\\n\\n    function getDaoRewardTemplate(bytes32 daoId) external view returns (address rewardTemplate);\\n\\n    function getDaoMintCap(bytes32 daoId) external view returns (uint32);\\n\\n    function getDaoNftHolderMintCap(bytes32 daoId) external view returns (uint32);\\n\\n    function getUserMintInfo(\\n        bytes32 daoId,\\n        address account\\n    )\\n        external\\n        view\\n        returns (uint32 minted, uint32 userMintCap);\\n\\n    function getDaoFeePoolETHRatio(bytes32 daoId) external view returns (uint256);\\n\\n    function getDaoFeePoolETHRatioFlatPrice(bytes32 daoId) external view returns (uint256);\\n\\n    function getDaoTag(bytes32 daoId) external view returns (string memory);\\n\\n    // canvas related functions\\n    function getCanvasDaoId(bytes32 canvasId) external view returns (bytes32 daoId);\\n\\n    function getCanvasTokenIds(bytes32 canvasId) external view returns (uint256[] memory tokenIds);\\n\\n    function getCanvasIndex(bytes32 canvasId) external view returns (uint256);\\n\\n    function getCanvasUri(bytes32 canvasId) external view returns (string memory canvasUri);\\n\\n    function getCanvasRebateRatioInBps(bytes32 canvasId) external view returns (uint256 rebateRatioInBps);\\n\\n    function getCanvasExist(bytes32 canvasId) external view returns (bool);\\n\\n    // prices related functions\\n    function getCanvasLastPrice(bytes32 canvasId) external view returns (uint256 round, uint256 price);\\n\\n    function getCanvasNextPrice(bytes32 canvasId) external view returns (uint256 price);\\n\\n    function getDaoMaxPriceInfo(bytes32 daoId) external view returns (uint256 round, uint256 price);\\n\\n    function getDaoFloorPrice(bytes32 daoId) external view returns (uint256 floorPrice);\\n\\n    function getDaoDailyMintCap(bytes32 daoId) external view returns (uint256);\\n\\n    function getDaoUnifiedPriceModeOff(bytes32 daoId) external view returns (bool);\\n\\n    function getDaoUnifiedPrice(bytes32 daoId) external view returns (uint256);\\n\\n    function getDaoReserveNftNumber(bytes32 daoId) external view returns (uint256);\\n\\n    // reward related functions\\n    function getDaoRewardStartRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 startRound);\\n\\n    function getDaoRewardTotalRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 totalRound);\\n\\n    function getDaoTotalReward(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 totalReward);\\n\\n    function getDaoRewardDecayFactor(bytes32 daoId) external view returns (uint256 rewardDecayFactor);\\n\\n    function getDaoRewardIsProgressiveJackpot(bytes32 daoId) external view returns (bool isProgressiveJackpot);\\n\\n    function getDaoRewardLastActiveRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 lastActiveRound);\\n\\n    function getDaoRewardActiveRounds(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256[] memory activeRounds);\\n\\n    function getDaoCreatorClaimableRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointsIndex\\n    )\\n        external\\n        view\\n        returns (uint256 claimableRound);\\n\\n    function getCanvasCreatorClaimableRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointsIndex,\\n        bytes32 canvasId\\n    )\\n        external\\n        view\\n        returns (uint256 claimableRound);\\n\\n    function getNftMinterClaimableRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointsIndex,\\n        address nftMinter\\n    )\\n        external\\n        view\\n        returns (uint256 claimableRound);\\n\\n    function getTotalWeight(bytes32 daoId, uint256 round) external view returns (uint256 totalWeight);\\n\\n    function getProtocolWeight(bytes32 daoId, uint256 round) external view returns (uint256 protocolWeight);\\n\\n    function getDaoCreatorWeight(bytes32 daoId, uint256 round) external view returns (uint256 creatorWeight);\\n\\n    function getCanvasCreatorWeight(\\n        bytes32 daoId,\\n        uint256 round,\\n        bytes32 canvasId\\n    )\\n        external\\n        view\\n        returns (uint256 creatorWeight);\\n\\n    function getNftMinterWeight(\\n        bytes32 daoId,\\n        uint256 round,\\n        address nftMinter\\n    )\\n        external\\n        view\\n        returns (uint256 minterWeight);\\n\\n    function getDaoCreatorERC20Ratio(bytes32 daoId) external view returns (uint256 ratioInBps);\\n\\n    function getCanvasCreatorERC20Ratio(bytes32 daoId) external view returns (uint256 ratioInBps);\\n\\n    function getNftMinterERC20Ratio(bytes32 daoId) external view returns (uint256 ratioInBps);\\n\\n    function getRoundReward(bytes32 daoId, uint256 round) external view returns (uint256);\\n\\n    function getRewardTillRound(bytes32 daoId, uint256 round) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPriceTemplate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport { PriceStorage } from \\\"contracts/storages/PriceStorage.sol\\\";\\n\\ninterface IPriceTemplate {\\n    function getCanvasNextPrice(\\n        uint256 startRound,\\n        uint256 currentRound,\\n        uint256 priceFactor,\\n        uint256 daoFloorPrice,\\n        PriceStorage.MintInfo memory maxPrice,\\n        PriceStorage.MintInfo memory mintInfo\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function updateCanvasPrice(\\n        bytes32 daoId,\\n        bytes32 canvasId,\\n        uint256 currentRound,\\n        uint256 price,\\n        uint256 priceMultiplierInBps\\n    )\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IRewardTemplate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport { UpdateRewardParam } from \\\"contracts/interface/D4AStructs.sol\\\";\\n\\ninterface IRewardTemplate {\\n    function updateReward(UpdateRewardParam memory param) external payable;\\n\\n    function claimDaoCreatorReward(\\n        bytes32 daoId,\\n        address protocolFeePool,\\n        address daoCreator,\\n        uint256 currentRound,\\n        address token\\n    )\\n        external\\n        returns (uint256 protocolClaimableReward, uint256 daoCreatorClaimableReward);\\n\\n    function claimCanvasCreatorReward(\\n        bytes32 daoId,\\n        bytes32 canvasId,\\n        address canvasCreator,\\n        uint256 currentRound,\\n        address token\\n    )\\n        external\\n        returns (uint256 claimableReward);\\n\\n    function claimNftMinterReward(\\n        bytes32 daoId,\\n        address nftMinter,\\n        uint256 currentRound,\\n        address token\\n    )\\n        external\\n        returns (uint256 claimableReward);\\n\\n    function setRewardCheckpoint(bytes32 daoId, int256 mintableRoundDelta, uint256 totalRewardDelta) external payable;\\n\\n    function getRoundReward(bytes32 daoId, uint256 round) external view returns (uint256 rewardAmount);\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error ExpOverflow();\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error FactorialOverflow();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error MulWadFailed();\\n\\n    /// @dev The operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error DivWadFailed();\\n\\n    /// @dev The multiply-divide operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error MulDivFailed();\\n\\n    /// @dev The division failed, as the denominator is zero.\\n    error DivFailed();\\n\\n    /// @dev The full precision multiply-divide operation failed, either due\\n    /// to the result being larger than 256 bits, or a division by a zero.\\n    error FullMulDivFailed();\\n\\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\\n    error LnWadUndefined();\\n\\n    /// @dev The output is undefined, as the input is zero.\\n    error Log2Undefined();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `x` to the power of `y`.\\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Using `ln(x)` means `x` must be greater than 0.\\n        return expWad((lnWad(x) * y) / int256(WAD));\\n    }\\n\\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return r;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n                // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n                if iszero(slt(x, 135305999368893231589)) {\\n                    // Store the function selector of `ExpOverflow()`.\\n                    mstore(0x00, 0xa37bfec9)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5 ** 18;\\n\\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256(\\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\\n            );\\n        }\\n    }\\n\\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                if iszero(sgt(x, 0)) {\\n                    // Store the function selector of `LnWadUndefined()`.\\n                    mstore(0x00, 0x1615e638)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Compute k = log2(x) - 96.\\n            int256 k;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let v := x\\n                k := shl(7, lt(0xffffffffffffffffffffffffffffffff, v))\\n                k := or(k, shl(6, lt(0xffffffffffffffff, shr(k, v))))\\n                k := or(k, shl(5, lt(0xffffffff, shr(k, v))))\\n\\n                // For the remaining 32 bits, use a De Bruijn lookup.\\n                // See: https://graphics.stanford.edu/~seander/bithacks.html\\n                v := shr(k, v)\\n                v := or(v, shr(1, v))\\n                v := or(v, shr(2, v))\\n                v := or(v, shr(4, v))\\n                v := or(v, shr(8, v))\\n                v := or(v, shr(16, v))\\n\\n                // forgefmt: disable-next-item\\n                k := sub(or(k, byte(shr(251, mul(v, shl(224, 0x07c4acdd))),\\n                    0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)), 96)\\n            }\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  GENERAL NUMBER UTILITIES                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Calculates `floor(a * b / d)` with full precision.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/21/muldiv\\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for {} 1 {} {\\n                // 512-bit multiply `[prod1 prod0] = x * y`.\\n                // Compute the product mod `2**256` and mod `2**256 - 1`\\n                // then use the Chinese Remainder Theorem to reconstruct\\n                // the 512 bit result. The result is stored in two 256\\n                // variables such that `product = prod1 * 2**256 + prod0`.\\n\\n                // Least significant 256 bits of the product.\\n                let prod0 := mul(x, y)\\n                let mm := mulmod(x, y, not(0))\\n                // Most significant 256 bits of the product.\\n                let prod1 := sub(mm, add(prod0, lt(mm, prod0)))\\n\\n                // Handle non-overflow cases, 256 by 256 division.\\n                if iszero(prod1) {\\n                    if iszero(d) {\\n                        // Store the function selector of `FullMulDivFailed()`.\\n                        mstore(0x00, 0xae47f702)\\n                        // Revert with (offset, size).\\n                        revert(0x1c, 0x04)\\n                    }\\n                    result := div(prod0, d)\\n                    break       \\n                }\\n\\n                // Make sure the result is less than `2**256`.\\n                // Also prevents `d == 0`.\\n                if iszero(gt(d, prod1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n\\n                ///////////////////////////////////////////////\\n                // 512 by 256 division.\\n                ///////////////////////////////////////////////\\n\\n                // Make division exact by subtracting the remainder from `[prod1 prod0]`.\\n                // Compute remainder using mulmod.\\n                let remainder := mulmod(x, y, d)\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n                // Factor powers of two out of `d`.\\n                // Compute largest power of two divisor of `d`.\\n                // Always greater or equal to 1.\\n                let twos := and(d, sub(0, d))\\n                // Divide d by power of two.\\n                d := div(d, twos)\\n                // Divide [prod1 prod0] by the factors of two.\\n                prod0 := div(prod0, twos)\\n                // Shift in bits from `prod1` into `prod0`. For this we need\\n                // to flip `twos` such that it is `2**256 / twos`.\\n                // If `twos` is zero, then it becomes one.\\n                prod0 := or(prod0, mul(prod1, add(div(sub(0, twos), twos), 1)))\\n                // Invert `d mod 2**256`\\n                // Now that `d` is an odd number, it has an inverse\\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\\n                // Compute the inverse by starting with a seed that is correct\\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\\n                let inv := xor(mul(3, d), 2)\\n                // Now use Newton-Raphson iteration to improve the precision.\\n                // Thanks to Hensel's lifting lemma, this also works in modular\\n                // arithmetic, doubling the correct bits in each step.\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\\n                result := mul(prod0, mul(inv, sub(2, mul(d, inv)))) // inverse mod 2**256\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Uniswap-v3-core under MIT license:\\n    /// https://github.com/Uniswap/v3-core/blob/contracts/libraries/FullMath.sol\\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        result = fullMulDiv(x, y, d);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mulmod(x, y, d) {\\n                if iszero(add(result, 1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n                result := add(result, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `floor(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), d)\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x / d)`.\\n    /// Reverts if `d` is zero.\\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(d) {\\n                // Store the function selector of `DivFailed()`.\\n                mstore(0x00, 0x65244e4e)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`.\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // Let `y = x / 2**r`.\\n            // We check `y >= 2**(k + 8)` but shift right by `k` bits\\n            // each branch to ensure that if `x >= 256`, then `y >= 256`.\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\\n            z := shl(shr(1, r), z)\\n\\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\\n\\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\\n\\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\\n\\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\\n            // Then we can estimate `sqrt(y)` using\\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\\n\\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If `x+1` is a perfect square, the Babylonian method cycles between\\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    /// @dev Returns the cube root of `x`.\\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n\\n            z := shl(add(div(r, 3), lt(0xf, shr(r, x))), 0xff)\\n            z := div(z, byte(mod(r, 3), shl(232, 0x7f624b)))\\n\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n\\n            z := sub(z, lt(div(x, mul(z, z)), z))\\n        }\\n    }\\n\\n    /// @dev Returns the factorial of `x`.\\n    function factorial(uint256 x) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, 58)) {\\n                // Store the function selector of `FactorialOverflow()`.\\n                mstore(0x00, 0xaba0f2a2)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            for { result := 1 } x {} {\\n                result := mul(result, x)\\n                x := sub(x, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`.\\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(x) {\\n                // Store the function selector of `Log2Undefined()`.\\n                mstore(0x00, 0x5be3aa5c)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            // See: https://graphics.stanford.edu/~seander/bithacks.html\\n            x := shr(r, x)\\n            x := or(x, shr(1, x))\\n            x := or(x, shr(2, x))\\n            x := or(x, shr(4, x))\\n            x := or(x, shr(8, x))\\n            x := or(x, shr(16, x))\\n\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`, rounded up.\\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\\n        unchecked {\\n            uint256 isNotPo2;\\n            assembly {\\n                isNotPo2 := iszero(iszero(and(x, sub(x, 1))))\\n            }\\n            return log2(x) + isNotPo2;\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = (x & y) + ((x ^ y) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = (x >> 1) + (y >> 1) + (((x & 1) + (y & 1)) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the absolute value of `x`.\\n    function abs(int256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := sub(0, shr(255, x))\\n            z := xor(mask, add(mask, x))\\n        }\\n    }\\n\\n    /// @dev Returns the absolute distance between `x` and `y`.\\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let a := sub(y, x)\\n            z := xor(a, mul(xor(a, sub(x, y)), sgt(x, y)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns greatest common divisor of `x` and `y`.\\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for { z := x } y {} {\\n                let t := y\\n                y := mod(z, y)\\n                z := t\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RAW NUMBER OPERATIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := smod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := addmod(x, y, d)\\n        }\\n    }\\n\\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mulmod(x, y, d)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SafeCastLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe integer casting library that reverts on overflow.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    error Overflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*          UNSIGNED INTEGER SAFE CASTING OPERATIONS          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    function toUint8(uint256 x) internal pure returns (uint8) {\\n        if (x >= 1 << 8) _revertOverflow();\\n        return uint8(x);\\n    }\\n\\n    function toUint16(uint256 x) internal pure returns (uint16) {\\n        if (x >= 1 << 16) _revertOverflow();\\n        return uint16(x);\\n    }\\n\\n    function toUint24(uint256 x) internal pure returns (uint24) {\\n        if (x >= 1 << 24) _revertOverflow();\\n        return uint24(x);\\n    }\\n\\n    function toUint32(uint256 x) internal pure returns (uint32) {\\n        if (x >= 1 << 32) _revertOverflow();\\n        return uint32(x);\\n    }\\n\\n    function toUint40(uint256 x) internal pure returns (uint40) {\\n        if (x >= 1 << 40) _revertOverflow();\\n        return uint40(x);\\n    }\\n\\n    function toUint48(uint256 x) internal pure returns (uint48) {\\n        if (x >= 1 << 48) _revertOverflow();\\n        return uint48(x);\\n    }\\n\\n    function toUint56(uint256 x) internal pure returns (uint56) {\\n        if (x >= 1 << 56) _revertOverflow();\\n        return uint56(x);\\n    }\\n\\n    function toUint64(uint256 x) internal pure returns (uint64) {\\n        if (x >= 1 << 64) _revertOverflow();\\n        return uint64(x);\\n    }\\n\\n    function toUint72(uint256 x) internal pure returns (uint72) {\\n        if (x >= 1 << 72) _revertOverflow();\\n        return uint72(x);\\n    }\\n\\n    function toUint80(uint256 x) internal pure returns (uint80) {\\n        if (x >= 1 << 80) _revertOverflow();\\n        return uint80(x);\\n    }\\n\\n    function toUint88(uint256 x) internal pure returns (uint88) {\\n        if (x >= 1 << 88) _revertOverflow();\\n        return uint88(x);\\n    }\\n\\n    function toUint96(uint256 x) internal pure returns (uint96) {\\n        if (x >= 1 << 96) _revertOverflow();\\n        return uint96(x);\\n    }\\n\\n    function toUint104(uint256 x) internal pure returns (uint104) {\\n        if (x >= 1 << 104) _revertOverflow();\\n        return uint104(x);\\n    }\\n\\n    function toUint112(uint256 x) internal pure returns (uint112) {\\n        if (x >= 1 << 112) _revertOverflow();\\n        return uint112(x);\\n    }\\n\\n    function toUint120(uint256 x) internal pure returns (uint120) {\\n        if (x >= 1 << 120) _revertOverflow();\\n        return uint120(x);\\n    }\\n\\n    function toUint128(uint256 x) internal pure returns (uint128) {\\n        if (x >= 1 << 128) _revertOverflow();\\n        return uint128(x);\\n    }\\n\\n    function toUint136(uint256 x) internal pure returns (uint136) {\\n        if (x >= 1 << 136) _revertOverflow();\\n        return uint136(x);\\n    }\\n\\n    function toUint144(uint256 x) internal pure returns (uint144) {\\n        if (x >= 1 << 144) _revertOverflow();\\n        return uint144(x);\\n    }\\n\\n    function toUint152(uint256 x) internal pure returns (uint152) {\\n        if (x >= 1 << 152) _revertOverflow();\\n        return uint152(x);\\n    }\\n\\n    function toUint160(uint256 x) internal pure returns (uint160) {\\n        if (x >= 1 << 160) _revertOverflow();\\n        return uint160(x);\\n    }\\n\\n    function toUint168(uint256 x) internal pure returns (uint168) {\\n        if (x >= 1 << 168) _revertOverflow();\\n        return uint168(x);\\n    }\\n\\n    function toUint176(uint256 x) internal pure returns (uint176) {\\n        if (x >= 1 << 176) _revertOverflow();\\n        return uint176(x);\\n    }\\n\\n    function toUint184(uint256 x) internal pure returns (uint184) {\\n        if (x >= 1 << 184) _revertOverflow();\\n        return uint184(x);\\n    }\\n\\n    function toUint192(uint256 x) internal pure returns (uint192) {\\n        if (x >= 1 << 192) _revertOverflow();\\n        return uint192(x);\\n    }\\n\\n    function toUint200(uint256 x) internal pure returns (uint200) {\\n        if (x >= 1 << 200) _revertOverflow();\\n        return uint200(x);\\n    }\\n\\n    function toUint208(uint256 x) internal pure returns (uint208) {\\n        if (x >= 1 << 208) _revertOverflow();\\n        return uint208(x);\\n    }\\n\\n    function toUint216(uint256 x) internal pure returns (uint216) {\\n        if (x >= 1 << 216) _revertOverflow();\\n        return uint216(x);\\n    }\\n\\n    function toUint224(uint256 x) internal pure returns (uint224) {\\n        if (x >= 1 << 224) _revertOverflow();\\n        return uint224(x);\\n    }\\n\\n    function toUint232(uint256 x) internal pure returns (uint232) {\\n        if (x >= 1 << 232) _revertOverflow();\\n        return uint232(x);\\n    }\\n\\n    function toUint240(uint256 x) internal pure returns (uint240) {\\n        if (x >= 1 << 240) _revertOverflow();\\n        return uint240(x);\\n    }\\n\\n    function toUint248(uint256 x) internal pure returns (uint248) {\\n        if (x >= 1 << 248) _revertOverflow();\\n        return uint248(x);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*           SIGNED INTEGER SAFE CASTING OPERATIONS           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    function toInt8(int256 x) internal pure returns (int8) {\\n        int8 y = int8(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt16(int256 x) internal pure returns (int16) {\\n        int16 y = int16(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt24(int256 x) internal pure returns (int24) {\\n        int24 y = int24(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt32(int256 x) internal pure returns (int32) {\\n        int32 y = int32(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt40(int256 x) internal pure returns (int40) {\\n        int40 y = int40(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt48(int256 x) internal pure returns (int48) {\\n        int48 y = int48(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt56(int256 x) internal pure returns (int56) {\\n        int56 y = int56(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt64(int256 x) internal pure returns (int64) {\\n        int64 y = int64(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt72(int256 x) internal pure returns (int72) {\\n        int72 y = int72(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt80(int256 x) internal pure returns (int80) {\\n        int80 y = int80(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt88(int256 x) internal pure returns (int88) {\\n        int88 y = int88(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt96(int256 x) internal pure returns (int96) {\\n        int96 y = int96(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt104(int256 x) internal pure returns (int104) {\\n        int104 y = int104(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt112(int256 x) internal pure returns (int112) {\\n        int112 y = int112(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt120(int256 x) internal pure returns (int120) {\\n        int120 y = int120(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt128(int256 x) internal pure returns (int128) {\\n        int128 y = int128(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt136(int256 x) internal pure returns (int136) {\\n        int136 y = int136(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt144(int256 x) internal pure returns (int144) {\\n        int144 y = int144(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt152(int256 x) internal pure returns (int152) {\\n        int152 y = int152(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt160(int256 x) internal pure returns (int160) {\\n        int160 y = int160(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt168(int256 x) internal pure returns (int168) {\\n        int168 y = int168(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt176(int256 x) internal pure returns (int176) {\\n        int176 y = int176(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt184(int256 x) internal pure returns (int184) {\\n        int184 y = int184(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt192(int256 x) internal pure returns (int192) {\\n        int192 y = int192(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt200(int256 x) internal pure returns (int200) {\\n        int200 y = int200(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt208(int256 x) internal pure returns (int208) {\\n        int208 y = int208(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt216(int256 x) internal pure returns (int216) {\\n        int216 y = int216(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt224(int256 x) internal pure returns (int224) {\\n        int224 y = int224(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt232(int256 x) internal pure returns (int232) {\\n        int232 y = int232(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt240(int256 x) internal pure returns (int240) {\\n        int240 y = int240(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    function toInt248(int256 x) internal pure returns (int248) {\\n        int248 y = int248(x);\\n        if (x != y) _revertOverflow();\\n        return y;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*         UNSIGNED TO SIGNED SAFE CASTING OPERATIONS         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    function toInt256(uint256 x) internal pure returns (int256) {\\n        if (x >= 1 << 255) _revertOverflow();\\n        return int256(x);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    function _revertOverflow() private pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Store the function selector of `Overflow()`.\\n            mstore(0x00, 0x35278d12)\\n            // Revert with (offset, size).\\n            revert(0x1c, 0x04)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ID4AProtocolSetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {\\n    UserMintCapParam,\\n    TemplateParam,\\n    Whitelist,\\n    Blacklist,\\n    SetDaoParam,\\n    NftMinterCapInfo\\n} from \\\"contracts/interface/D4AStructs.sol\\\";\\nimport { PriceTemplateType } from \\\"contracts/interface/D4AEnums.sol\\\";\\n\\ninterface ID4AProtocolSetter {\\n    event MintCapSet(\\n        bytes32 indexed daoId,\\n        uint32 daoMintCap,\\n        UserMintCapParam[] userMintCapParams,\\n        NftMinterCapInfo[] nftMinterCapInfo\\n    );\\n\\n    event DaoPriceTemplateSet(bytes32 indexed daoId, PriceTemplateType priceTemplateType, uint256 nftPriceFactor);\\n\\n    event CanvasRebateRatioInBpsSet(bytes32 indexed canvasId, uint256 newCanvasRebateRatioInBps);\\n\\n    event DaoNftMaxSupplySet(bytes32 indexed daoId, uint256 newMaxSupply);\\n\\n    event DaoMintableRoundSet(bytes32 daoId, uint256 newMintableRounds);\\n\\n    event DaoFloorPriceSet(bytes32 daoId, uint256 newFloorPrice);\\n\\n    event DaoTemplateSet(bytes32 daoId, TemplateParam templateParam);\\n\\n    event DaoRatioSet(\\n        bytes32 daoId,\\n        uint256 daoCreatorERC20Ratio,\\n        uint256 canvasCreatorERC20Ratio,\\n        uint256 nftMinterERC20Ratio,\\n        uint256 daoFeePoolETHRatio,\\n        uint256 daoFeePoolETHRatioFlatPrice\\n    );\\n\\n    event DailyMintCapSet(bytes32 indexed daoId, uint256 dailyMintCap);\\n\\n    event DaoTokenSupplySet(bytes32 daoId, uint256 addedDaoToken);\\n\\n    event WhiteListMintCapSet(bytes32 daoId, address whitelistUser, uint256 whitelistUserMintCap);\\n\\n    event DaoUnifiedPriceSet(bytes32 daoId, uint256 newUnifiedPrice);\\n\\n    function setMintCapAndPermission(\\n        bytes32 daoId,\\n        uint32 daoMintCap,\\n        UserMintCapParam[] calldata userMintCapParams,\\n        NftMinterCapInfo[] calldata nftMinterCapInfo,\\n        Whitelist memory whitelist,\\n        Blacklist memory blacklist,\\n        Blacklist memory unblacklist\\n    )\\n        external;\\n\\n    function setDaoParams(SetDaoParam memory vars) external;\\n\\n    function setDaoPriceTemplate(bytes32 daoId, PriceTemplateType priceTemplateType, uint256 priceFactor) external;\\n\\n    function setDaoNftMaxSupply(bytes32 daoId, uint256 newMaxSupply) external;\\n\\n    function setDaoMintableRound(bytes32 daoId, uint256 newMintableRound) external;\\n\\n    function setDaoFloorPrice(bytes32 daoId, uint256 newFloorPrice) external;\\n\\n    function setTemplate(bytes32 daoId, TemplateParam calldata templateParam) external;\\n\\n    function setDailyMintCap(bytes32 daoId, uint256 dailyMintCap) external;\\n\\n    function setDaoTokenSupply(bytes32 daoId, uint256 addedDaoToken) external;\\n\\n    function setWhitelistMintCap(bytes32 daoId, address whitelistUser, uint32 whitelistUserMintCap) external;\\n\\n    function setRatio(\\n        bytes32 daoId,\\n        uint256 daoCreatorERC20Ratio,\\n        uint256 canvasCreatorERC20Ratio,\\n        uint256 nftMinterERC20Ratio,\\n        uint256 daoFeePoolETHRatio,\\n        uint256 daoFeePoolETHRatioFlatPrice\\n    )\\n        external;\\n\\n    function setCanvasRebateRatioInBps(bytes32 canvasId, uint256 newCanvasRebateRatioInBps) external payable;\\n\\n    function setDaoUnifiedPrice(bytes32 daoId, uint256 newUnifiedPrice) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@solidstate/=node_modules/@solidstate/\",\r\n      \"@uniswap/=node_modules/@uniswap/\",\r\n      \"@chainlink/=node_modules/@chainlink/\",\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/chainlink/contracts/foundry-lib/openzeppelin-contracts/lib/erc4626-tests/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"BasicDaoLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedDaoMintableRound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedMaxMintableRound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidETHRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewMintableRoundsFewerThanRewardIssuedRounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotCanvasOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotDaoOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupplyOutOfRange\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"canvasId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCanvasRebateRatioInBps\",\"type\":\"uint256\"}],\"name\":\"CanvasRebateRatioInBpsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dailyMintCap\",\"type\":\"uint256\"}],\"name\":\"DailyMintCapSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFloorPrice\",\"type\":\"uint256\"}],\"name\":\"DaoFloorPriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMintableRounds\",\"type\":\"uint256\"}],\"name\":\"DaoMintableRoundSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxSupply\",\"type\":\"uint256\"}],\"name\":\"DaoNftMaxSupplySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"enum PriceTemplateType\",\"name\":\"priceTemplateType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftPriceFactor\",\"type\":\"uint256\"}],\"name\":\"DaoPriceTemplateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daoCreatorERC20Ratio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"canvasCreatorERC20Ratio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftMinterERC20Ratio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daoFeePoolETHRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daoFeePoolETHRatioFlatPrice\",\"type\":\"uint256\"}],\"name\":\"DaoRatioSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"enum PriceTemplateType\",\"name\":\"priceTemplateType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"priceFactor\",\"type\":\"uint256\"},{\"internalType\":\"enum RewardTemplateType\",\"name\":\"rewardTemplateType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"rewardDecayFactor\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isProgressiveJackpot\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct TemplateParam\",\"name\":\"templateParam\",\"type\":\"tuple\"}],\"name\":\"DaoTemplateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"addedDaoToken\",\"type\":\"uint256\"}],\"name\":\"DaoTokenSupplySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newUnifiedPrice\",\"type\":\"uint256\"}],\"name\":\"DaoUnifiedPriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"daoMintCap\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"mintCap\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct UserMintCapParam[]\",\"name\":\"userMintCapParams\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftMintCap\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct NftMinterCapInfo[]\",\"name\":\"nftMinterCapInfo\",\"type\":\"tuple[]\"}],\"name\":\"MintCapSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"whitelistUser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"whitelistUserMintCap\",\"type\":\"uint256\"}],\"name\":\"WhiteListMintCapSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"canvasId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"newCanvasRebateRatioInBps\",\"type\":\"uint256\"}],\"name\":\"setCanvasRebateRatioInBps\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"dailyMintCap\",\"type\":\"uint256\"}],\"name\":\"setDailyMintCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"newFloorPrice\",\"type\":\"uint256\"}],\"name\":\"setDaoFloorPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"newMintableRound\",\"type\":\"uint256\"}],\"name\":\"setDaoMintableRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"newMaxSupply\",\"type\":\"uint256\"}],\"name\":\"setDaoNftMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nftMaxSupplyRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintableRoundRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daoFloorPriceRank\",\"type\":\"uint256\"},{\"internalType\":\"enum PriceTemplateType\",\"name\":\"priceTemplateType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"nftPriceFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daoCreatorERC20Ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"canvasCreatorERC20Ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftMinterERC20Ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daoFeePoolETHRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daoFeePoolETHRatioFlatPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyMintCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addedDaoToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unifiedPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct SetDaoParam\",\"name\":\"vars\",\"type\":\"tuple\"}],\"name\":\"setDaoParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"internalType\":\"enum PriceTemplateType\",\"name\":\"priceTemplateType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"nftPriceFactor\",\"type\":\"uint256\"}],\"name\":\"setDaoPriceTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"addedDaoToken\",\"type\":\"uint256\"}],\"name\":\"setDaoTokenSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"newUnifiedPrice\",\"type\":\"uint256\"}],\"name\":\"setDaoUnifiedPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"daoMintCap\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"mintCap\",\"type\":\"uint32\"}],\"internalType\":\"struct UserMintCapParam[]\",\"name\":\"userMintCapParams\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftMintCap\",\"type\":\"uint256\"}],\"internalType\":\"struct NftMinterCapInfo[]\",\"name\":\"nftMinterCapInfo\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"minterMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"minterNFTHolderPasses\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"canvasCreatorMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"canvasCreatorNFTHolderPasses\",\"type\":\"address[]\"}],\"internalType\":\"struct Whitelist\",\"name\":\"whitelist\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"minterAccounts\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"canvasCreatorAccounts\",\"type\":\"address[]\"}],\"internalType\":\"struct Blacklist\",\"name\":\"blacklist\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"minterAccounts\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"canvasCreatorAccounts\",\"type\":\"address[]\"}],\"internalType\":\"struct Blacklist\",\"name\":\"unblacklist\",\"type\":\"tuple\"}],\"name\":\"setMintCapAndPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"daoCreatorERC20Ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"canvasCreatorERC20Ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftMinterERC20Ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daoFeePoolETHRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daoFeePoolETHRatioFlatPrice\",\"type\":\"uint256\"}],\"name\":\"setRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"enum PriceTemplateType\",\"name\":\"priceTemplateType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"priceFactor\",\"type\":\"uint256\"},{\"internalType\":\"enum RewardTemplateType\",\"name\":\"rewardTemplateType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"rewardDecayFactor\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isProgressiveJackpot\",\"type\":\"bool\"}],\"internalType\":\"struct TemplateParam\",\"name\":\"templateParam\",\"type\":\"tuple\"}],\"name\":\"setTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"daoId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"whitelistUser\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"whitelistUserMintCap\",\"type\":\"uint32\"}],\"name\":\"setWhitelistMintCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PDProtocolSetter", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}