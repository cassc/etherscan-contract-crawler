{"SourceCode": "pragma solidity >=0.4.21 <0.6.0;\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, \"add\");\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a, \"sub\");\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"mul\");\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0, \"div\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract MultiSigInterface{\r\n  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);\r\n  function is_signer(address addr) public view returns(bool);\r\n}\r\n\r\ncontract MultiSigTools{\r\n  MultiSigInterface public multisig_contract;\r\n  constructor(address _contract) public{\r\n    require(_contract!= address(0x0));\r\n    multisig_contract = MultiSigInterface(_contract);\r\n  }\r\n\r\n  modifier only_signer{\r\n    require(multisig_contract.is_signer(msg.sender), \"only a signer can call in MultiSigTools\");\r\n    _;\r\n  }\r\n\r\n  modifier is_majority_sig(uint64 id, string memory name) {\r\n    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\r\n    if(multisig_contract.update_and_check_reach_majority(id, name, hash, msg.sender)){\r\n      _;\r\n    }\r\n  }\r\n\r\n  event TransferMultiSig(address _old, address _new);\r\n\r\n  function transfer_multisig(uint64 id, address _contract) public only_signer\r\n  is_majority_sig(id, \"transfer_multisig\"){\r\n    require(_contract != address(0x0));\r\n    address old = address(multisig_contract);\r\n    multisig_contract = MultiSigInterface(_contract);\r\n    emit TransferMultiSig(old, _contract);\r\n  }\r\n}\r\nlibrary AddressArray{\r\n  function exists(address[] storage self, address addr) public view returns(bool){\r\n    for (uint i = 0; i< self.length;i++){\r\n      if (self[i]==addr){\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function index_of(address[] storage self, address addr) public view returns(uint){\r\n    for (uint i = 0; i< self.length;i++){\r\n      if (self[i]==addr){\r\n        return i;\r\n      }\r\n    }\r\n    require(false, \"AddressArray:index_of, not exist\");\r\n  }\r\n\r\n  function remove(address[] storage self, address addr) public returns(bool){\r\n    uint index = index_of(self, addr);\r\n    self[index] = self[self.length - 1];\r\n\r\n    delete self[self.length-1];\r\n    self.length--;\r\n  }\r\n\r\n  function replace(address[] storage self, address old_addr, address new_addr) public returns(bool){\r\n    uint index = index_of(self, old_addr);\r\n    self[index] = new_addr;\r\n  }\r\n}\r\n\r\ncontract TransferableToken{\r\n    function balanceOf(address _owner) public returns (uint256 balance) ;\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) ;\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) ;\r\n}\r\n\r\n\r\ncontract TokenClaimer{\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n  function _claimStdTokens(address _token, address payable to) internal {\r\n        if (_token == address(0x0)) {\r\n            to.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        TransferableToken token = TransferableToken(_token);\r\n        uint balance = token.balanceOf(address(this));\r\n\r\n        (bool status,) = _token.call(abi.encodeWithSignature(\"transfer(address,uint256)\", to, balance));\r\n        require(status, \"call failed\");\r\n        emit ClaimedTokens(_token, to, balance);\r\n  }\r\n}\r\n\r\ncontract TokenInterface is TransferableToken{\r\n    function destroyTokens(address _owner, uint _amount) public returns (bool);\r\n    function generateTokens(address _owner, uint _amount) public returns (bool);\r\n}\r\n\r\ncontract PeriodMint is MultiSigTools{\r\n  using SafeMath for uint;\r\n  using AddressArray for address[];\r\n\r\n  TokenInterface public token_contract;\r\n  uint public last_block_num;\r\n  uint public period_block_num;\r\n  uint public period_share;\r\n  uint public total_alloc_share;\r\n\r\n  mapping(address => uint) public share_amounts;\r\n  address[] public shareholders;\r\n\r\n  address public admin;\r\n\r\n  constructor(address _token, uint _start_block, uint _period, uint _period_share,\r\n                            address _multisig) MultiSigTools(_multisig) public {\r\n    token_contract = TokenInterface(_token);\r\n    last_block_num = _start_block;\r\n    period_block_num = _period;\r\n    period_share = _period_share;\r\n    total_alloc_share = 0;\r\n    admin = address(0);\r\n  }\r\n\r\n  function issue() public {\r\n    uint interval = block.number.safeSub(last_block_num);\r\n    uint periods = interval.safeDiv(period_block_num);\r\n    if(periods == 0) return ;\r\n\r\n    last_block_num = last_block_num.safeAdd(periods.safeMul(period_block_num));\r\n    uint total_allocation = total_alloc_share;\r\n    uint total_shares = periods.safeMul(period_share);\r\n    for(uint i = 0; i < shareholders.length; i++){\r\n      if(share_amounts[shareholders[i]] == 0) continue;\r\n      uint t = share_amounts[shareholders[i]].safeMul(total_shares).safeDiv(total_allocation);\r\n      token_contract.generateTokens(shareholders[i], t);\r\n    }\r\n  }\r\n\r\n  function delegate_admin(uint64 id, address _admin) public only_signer is_majority_sig(id, \"delegate_admin\"){\r\n    require(_admin != address(0x0), \"invalid address\");\r\n    admin = _admin;\r\n  }\r\n\r\n  function cancel_delegate_admin(uint64 id) public only_signer is_majority_sig(id, \"cancel_delegate_admin\"){\r\n    admin = address(0x0);\r\n  }\r\n\r\n  modifier only_admin{\r\n    require(admin != address(0x0), \"admin not set\");\r\n    require(msg.sender == admin, \"only admin can op this\");\r\n    _;\r\n  }\r\n\r\n  function shareholder_exists(address account) private view returns(bool){\r\n    return shareholders.exists(account);\r\n  }\r\n\r\n  function _internal_add_shareholder(address account, uint amount) private{\r\n    require(amount > 0, \"invalid amount\");\r\n    require(account != address(0), \"invalid address\");\r\n    require(!shareholder_exists(account), \"already exist\");\r\n\r\n    issue();\r\n\r\n    shareholders.push(account);\r\n    share_amounts[account] = amount;\r\n    total_alloc_share = total_alloc_share.safeAdd(amount);\r\n  }\r\n\r\n\r\n  function admin_add_shareholder(address account, uint amount) public only_admin{\r\n    _internal_add_shareholder(account, amount);\r\n  }\r\n\r\n  function add_shareholder(uint64 id, address account, uint amount)\r\n    public\r\n    only_signer\r\n    is_majority_sig(id, \"add_shareholder\")\r\n  {\r\n    _internal_add_shareholder(account, amount);\r\n  }\r\n\r\n  function _internal_config_shareholder(address account, uint amount) private{\r\n    require(account != address(0x0), \"invalid address\");\r\n    require(shareholder_exists(account), \"not exist\");\r\n\r\n    issue();\r\n\r\n    total_alloc_share = total_alloc_share.safeSub(share_amounts[account]);\r\n    total_alloc_share = total_alloc_share.safeAdd(amount);\r\n    share_amounts[account] = amount;\r\n  }\r\n\r\n  function config_shareholder(uint64 id, address account, uint amount)\r\n    external\r\n    only_signer\r\n    is_majority_sig(id, \"config_shareholder\")\r\n  {\r\n    _internal_config_shareholder(account, amount);\r\n  }\r\n\r\n  function admin_config_shareholder(address account, uint amount)\r\n    public\r\n    only_admin{\r\n      _internal_config_shareholder(account, amount);\r\n  }\r\n\r\n  function _internal_remove_shareholder(address account) private {\r\n    require(account != address(0), \"invalid address\");\r\n    require(shareholder_exists(account), \"not exist\");\r\n    issue();\r\n    total_alloc_share = total_alloc_share.safeSub(share_amounts[account]);\r\n    share_amounts[account] = 0;\r\n    shareholders.remove(account);\r\n  }\r\n\r\n  function remove_shareholder(uint64 id, address account)\r\n    public\r\n    only_signer\r\n    is_majority_sig(id, \"remove_shareholder\"){\r\n    _internal_remove_shareholder(account);\r\n  }\r\n\r\n  function admin_remove_shareholder(address account)\r\n    public\r\n    only_admin{\r\n    _internal_remove_shareholder(account);\r\n  }\r\n\r\n  function get_total_allocation() public view returns(uint total){\r\n    return total_alloc_share;\r\n  }\r\n\r\n  function get_share(address account) public view returns(uint){\r\n    return share_amounts[account];\r\n  }\r\n\r\n  function status() public view returns(uint _last_block_num,\r\n                                       uint _period_block_num,\r\n                                       uint _period_share){\r\n    return (last_block_num, period_block_num, period_share);\r\n  }\r\n\r\n  function set_issue_period_param(uint64 id, uint block_num, uint share)\r\n    public\r\n    only_signer\r\n    is_majority_sig(id, \"set_issue_period_param\")\r\n  {\r\n    require(block_num > 0);\r\n    require(share > 0);\r\n    issue();\r\n    period_block_num = block_num;\r\n    period_share = share;\r\n  }\r\n\r\n  function get_shareholders_count() public view returns(uint){\r\n    return shareholders.length;\r\n  }\r\n\r\n  function get_shareholder_amount_with_index(uint index) public view returns(address account, uint amount) {\r\n    require(index>=0 && index<shareholders.length);\r\n    return (shareholders[index], share_amounts[shareholders[index]]);\r\n  }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"delegate_admin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"}],\"name\":\"cancel_delegate_admin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"remove_shareholder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"transfer_multisig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"last_block_num\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"_last_block_num\",\"type\":\"uint256\"},{\"name\":\"_period_block_num\",\"type\":\"uint256\"},{\"name\":\"_period_share\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"add_shareholder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"get_shareholder_amount_with_index\",\"outputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_alloc_share\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"period_block_num\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig_contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"get_share\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_shareholders_count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"period_share\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shareholders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"config_shareholder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"issue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"admin_remove_shareholder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint64\"},{\"name\":\"block_num\",\"type\":\"uint256\"},{\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"set_issue_period_param\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"admin_config_shareholder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"share_amounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"admin_add_shareholder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_total_allocation\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_start_block\",\"type\":\"uint256\"},{\"name\":\"_period\",\"type\":\"uint256\"},{\"name\":\"_period_share\",\"type\":\"uint256\"},{\"name\":\"_multisig\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"TransferMultiSig\",\"type\":\"event\"}]", "ContractName": "PeriodMint", "CompilerVersion": "v0.5.10+commit.5a6ea5b1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c06a9758d89289d72e09e412bb51913206a183fe0000000000000000000000000000000000000000000000000000000000945570000000000000000000000000000000000000000000000000000000000002cfec000000000000000000000000000000000000000000000000000000007d2b7500000000000000000000000000d030fffd702b037235676af30612577a7ca201a2", "EVMVersion": "Default", "Library": "SafeMath:a37426cdca2be3d52c950d5ca1ffac842b89b06a;AddressArray:0493163ff05664a1add5f87374ef78940ae33bc4", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://238b7b08991a76a775fbce0188abe0ab2efa60a6e0458d5d424ac3273a2cbe76"}