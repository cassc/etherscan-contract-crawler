{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/util/ALE.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: None\\npragma solidity ^0.8.0;\\n\\nimport \\\"src/interfaces/IMarket.sol\\\";\\nimport \\\"src/interfaces/IERC20.sol\\\";\\nimport \\\"src/interfaces/ITransformHelper.sol\\\";\\nimport \\\"src/util/CurveDBRHelper.sol\\\";\\nimport {Ownable} from \\\"lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\nimport {ReentrancyGuard} from \\\"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\\\";\\n\\ninterface IDBR {\\n    function markets(address) external view returns (bool);\\n}\\n\\n// Accelerated leverage engine\\ncontract ALE is Ownable, ReentrancyGuard, CurveDBRHelper {\\n    error CollateralNotSet();\\n    error MarketNotSet(address market);\\n    error SwapFailed();\\n    error DOLAInvalidBorrow(uint256 expected, uint256 actual);\\n    error DOLAInvalidRepay(uint256 expected, uint256 actual);\\n    error InvalidProxyAddress();\\n    error InvalidHelperAddress();\\n    error NothingToDeposit();\\n    error DepositFailed(uint256 expected, uint256 actual);\\n    error WithdrawFailed(uint256 expected, uint256 actual);\\n    error TotalSupplyChanged(uint256 expected, uint256 actual);\\n    error CollateralIsZero();\\n    error NoMarket(address market);\\n    error WrongCollateral(address market, address buySellToken, address collateral, address helper);\\n\\n    // 0x ExchangeProxy address.\\n    // See https://docs.0x.org/developer-resources/contract-addresses\\n    address payable public exchangeProxy;\\n\\n    IDBR public constant DBR = IDBR(0xAD038Eb671c44b853887A7E32528FaB35dC5D710);\\n\\n    struct Market {\\n        IERC20 buySellToken;\\n        IERC20 collateral;\\n        ITransformHelper helper;\\n    }\\n\\n    struct Permit {\\n        uint256 deadline;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    struct DBRHelper {\\n        uint256 amountIn; // DOLA or DBR\\n        uint256 minOut; // DOLA or DBR\\n        uint256 dola; // DOLA to extra borrow or extra repay\\n    }\\n\\n    event LeverageUp(\\n        address indexed market,\\n        address indexed account,\\n        uint256 dolaFlashMinted, // DOLA flash minted for buying collateral only\\n        uint256 collateralDeposited, // amount of collateral deposited into the escrow    \\n        uint256 dolaBorrowed,  // amount of DOLA borrowed on behalf of the user\\n        uint256 dolaForDBR   // amount of DOLA used for buying DBR\\n    );\\n\\n    event LeverageDown(\\n        address indexed market,\\n        address indexed account,\\n        uint256 dolaFlashMinted, // Flash minted DOLA for repaying leverage only\\n        uint256 collateralSold,  // amount of collateral/underlying sold\\n        uint256 dolaUserRepaid,  // amount of DOLA deposited by the user as part of the repay\\n        uint256 dbrSoldForDola   // amount of DBR sold for DOLA\\n    );\\n\\n    event Deposit(address indexed market, address indexed account, uint256 depositAmount);\\n\\n    event NewMarket(address indexed market, address indexed buySellToken, address collateral, address indexed helper);\\n\\n    event NewHelper(address indexed market, address indexed helper);\\n\\n    // Mapping of market to Market structs\\n    // NOTE: in normal cases sellToken/buyToken is the collateral token,\\n    // in other cases it could be different (eg. st-yCRV is collateral, yCRV is the token to be swapped from/to DOLA)\\n    mapping(address => Market) public markets;\\n\\n    modifier dolaSupplyUnchanged() {\\n        uint256 totalSupply = dola.totalSupply();\\n        _;\\n        if (totalSupply != dola.totalSupply())\\n            revert TotalSupplyChanged(totalSupply, dola.totalSupply());\\n    }\\n\\n    constructor(\\n        address _exchangeProxy,\\n        address _pool\\n    ) Ownable(msg.sender) CurveDBRHelper(_pool) {\\n        exchangeProxy = payable(address(_exchangeProxy));\\n    }\\n\\n    function setExchangeProxy(address _exchangeProxy) external onlyOwner {\\n        if (_exchangeProxy == address(0)) revert InvalidProxyAddress();\\n        exchangeProxy = payable(_exchangeProxy);\\n    }\\n\\n    /// @notice Set the market for a collateral token\\n    /// @param _buySellToken The token which will be bought/sold (usually the collateral token), probably underlying if there's a helper\\n    /// @param _market The market contract\\n    /// @param _collateral The collateral token\\n    /// @param _helper Optional helper contract to transform collateral to buySelltoken and viceversa\\n    function setMarket(\\n        address _market,\\n        address _buySellToken,\\n        address _collateral,\\n        address _helper\\n    ) external onlyOwner {\\n        if(!DBR.markets(_market)) revert NoMarket(_market);\\n\\n        if(_helper == address(0)) {\\n            if(_buySellToken != IMarket(_market).collateral() || _collateral != IMarket(_market).collateral()) {\\n                revert WrongCollateral(_market, _buySellToken, _collateral, _helper);\\n            }\\n        } else if (_helper != address(0) && _collateral != IMarket(_market).collateral()) {\\n            revert WrongCollateral(_market, _buySellToken, _collateral, _helper);\\n        }\\n\\n        markets[_market].buySellToken = IERC20(_buySellToken);\\n        markets[_market].collateral = IERC20(_collateral);\\n        IERC20(_buySellToken).approve(_market, type(uint256).max);\\n\\n        if (_buySellToken != _collateral) {\\n            IERC20(_collateral).approve(_market, type(uint256).max);\\n        } \\n\\n        if (_helper != address(0)) {\\n            markets[_market].helper = ITransformHelper(_helper);\\n            IERC20(_buySellToken).approve(_helper, type(uint256).max);\\n            IERC20(_collateral).approve(_helper, type(uint256).max);\\n        }\\n\\n        emit NewMarket(_market, _buySellToken, _collateral, _helper);\\n    }\\n\\n    /// @notice Update the helper contract\\n    /// @param _market The market we want to update the helper contract for\\n    /// @param _helper The helper contract\\n    function updateMarketHelper(\\n        address _market,\\n        address _helper\\n    ) external onlyOwner {\\n        if (address(markets[_market].buySellToken) == address(0)) revert MarketNotSet(_market);\\n\\n        address oldHelper = address(markets[_market].helper);\\n        if (oldHelper != address(0)) {\\n            markets[_market].buySellToken.approve(oldHelper, 0);\\n            markets[_market].collateral.approve(oldHelper, 0);\\n        }\\n\\n        markets[_market].helper = ITransformHelper(_helper);\\n        \\n        if (_helper != address(0)) {\\n            markets[_market].buySellToken.approve(_helper, type(uint256).max);\\n            markets[_market].collateral.approve(_helper, type(uint256).max);\\n        }\\n     \\n\\n        emit NewHelper(_market, _helper);\\n    }\\n\\n    /// @notice Leverage user position by minting DOLA, buying collateral, deposting into the user escrow and borrow DOLA on behalf to repay the minted DOLA\\n    /// @dev Requires user to sign message to permit the contract to borrow DOLA on behalf\\n    /// @param _value Amount of DOLA to flash mint/burn\\n    /// @param _market The market contract\\n    /// @param _spender The `allowanceTarget` field from the API response.\\n    /// @param _swapCallData The `data` field from the API response.\\n    /// @param _permit Permit data\\n    /// @param _helperData Optional helper data in case the collateral needs to be transformed\\n    /// @param _dbrData Optional data in case the user wants to buy DBR and also withdraw some DOLA\\n    function leveragePosition(\\n        uint256 _value,\\n        address _market,\\n        address _spender,\\n        bytes calldata _swapCallData,\\n        Permit calldata _permit,\\n        bytes calldata _helperData,\\n        DBRHelper calldata _dbrData\\n    ) public payable nonReentrant dolaSupplyUnchanged {\\n        if (address(markets[_market].buySellToken) == address(0))\\n            revert MarketNotSet(_market);\\n\\n        IMarket market = IMarket(_market);\\n\\n        // Mint and approve\\n        _mintAndApproveDola(_spender, _value);\\n\\n        // Call the encoded swap function call on the contract at `swapTarget`,\\n        // passing along any ETH attached to this function call to cover protocol fees.\\n        (bool success, ) = exchangeProxy.call{value: msg.value}(_swapCallData);\\n        if (!success) revert SwapFailed();\\n\\n        // Actual collateral/buyToken bought\\n        uint256 collateralAmount = markets[_market].buySellToken.balanceOf(address(this));\\n        if(collateralAmount == 0) revert CollateralIsZero();\\n\\n        // If there's a helper contract, the buyToken has to be transformed\\n        if (address(markets[_market].helper) != address(0)) {\\n            collateralAmount = _convertToCollateral(\\n                collateralAmount,\\n                _market,\\n                _helperData\\n            );\\n        }\\n\\n        // Deposit and borrow on behalf\\n        market.deposit(msg.sender, collateralAmount);\\n\\n        _borrowDola(_value, _permit, _dbrData, market);\\n\\n        // Burn the dola minted previously\\n        dola.burn(_value);\\n\\n        if (_dbrData.dola != 0) {\\n            dola.transfer(msg.sender, _dbrData.dola);\\n        }\\n\\n        if (_dbrData.amountIn != 0) {\\n            _buyDbr(_dbrData.amountIn, _dbrData.minOut, msg.sender);\\n        }\\n\\n        if (dola.balanceOf(address(this)) != 0) {\\n            dola.transfer(msg.sender, dola.balanceOf(address(this)));\\n        }\\n\\n        // Refund any possible unspent 0x protocol fees to the sender.\\n        if (address(this).balance > 0)\\n            payable(msg.sender).transfer(address(this).balance);\\n\\n        emit LeverageUp(_market, msg.sender, _value, collateralAmount, _dbrData.dola, _dbrData.amountIn);\\n    }\\n\\n    /// @notice Deposit collateral and instantly leverage user position by minting DOLA, buying collateral, deposting into the user escrow and borrow DOLA on behalf to repay the minted DOLA\\n    /// @dev Requires user to sign message to permit the contract to borrow DOLA on behalf\\n    /// @param _initialDeposit Amount of collateral or underlying (in case of helper) to deposit\\n    /// @param _value Amount of DOLA to borrow\\n    /// @param _market The market address\\n    /// @param _spender The `allowanceTarget` field from the API response.\\n    /// @param _swapCallData The `data` field from the API response.\\n    /// @param _permit Permit data\\n    /// @param _helperData Optional helper data in case the collateral needs to be transformed\\n    function depositAndLeveragePosition(\\n        uint256 _initialDeposit,\\n        uint256 _value,\\n        address _market,\\n        address _spender,\\n        bytes calldata _swapCallData,\\n        Permit calldata _permit,\\n        bytes calldata _helperData,\\n        DBRHelper calldata _dbrData\\n    ) external payable {\\n        if (_initialDeposit == 0) revert NothingToDeposit();\\n        IERC20 buyToken = markets[_market].buySellToken;\\n        buyToken.transferFrom(msg.sender, address(this), _initialDeposit);\\n\\n        emit Deposit(_market, msg.sender, _initialDeposit);\\n\\n        leveragePosition(\\n            _value,\\n            _market,\\n            _spender,\\n            _swapCallData,\\n            _permit,\\n            _helperData,\\n            _dbrData\\n        );\\n    }\\n\\n    /// @notice Repay a DOLA loan and withdraw collateral from the escrow\\n    /// @dev Requires user to sign message to permit the contract to withdraw collateral from the escrow\\n    /// @param _value Amount of DOLA to repay\\n    /// @param _market The market contract\\n    /// @param _collateralAmount Collateral amount to withdraw from the escrow\\n    /// @param _spender The `allowanceTarget` field from the API response.\\n    /// @param _swapCallData The `data` field from the API response.\\n    /// @param _permit Permit data\\n    /// @param _helperData Optional helper data in case collateral needs to be transformed\\n    /// @param _dbrData Optional data in case the user wants to sell DBR\\n    function deleveragePosition(\\n        uint256 _value,\\n        address _market,\\n        uint256 _collateralAmount,\\n        address _spender,\\n        bytes calldata _swapCallData,\\n        Permit calldata _permit,\\n        bytes calldata _helperData,\\n        DBRHelper calldata _dbrData\\n    ) external payable nonReentrant dolaSupplyUnchanged {\\n        if (address(markets[_market].buySellToken) == address(0))\\n            revert MarketNotSet(_market);\\n\\n        IERC20 sellToken = markets[_market].buySellToken;\\n\\n        _repayAndWithdraw(_value, _collateralAmount, _permit, _dbrData, IMarket(_market));\\n\\n        // If there's a helper contract, the collateral has to be transformed\\n        if (address(markets[_market].helper) != address(0)) {\\n            _collateralAmount = _convertToAsset(\\n                _collateralAmount,\\n                _market,\\n                sellToken,\\n                _helperData\\n            );\\n        }\\n\\n        // Approve sellToken for spender\\n        sellToken.approve(_spender, 0);\\n        sellToken.approve(_spender, _collateralAmount);\\n\\n        // Call the encoded swap function call on the contract at `swapTarget`,\\n        // passing along any ETH attached to this function call to cover protocol fees.\\n        // NOTE: This will swap the collateral or helperCollateral for DOLA\\n        (bool success, ) = exchangeProxy.call{value: msg.value}(_swapCallData);\\n        if (!success) revert SwapFailed();\\n\\n        if (address(markets[_market].helper) == address(0)) {\\n            uint256 collateralAvailable = markets[_market].collateral.balanceOf(\\n                address(this)\\n            );\\n\\n            if (collateralAvailable != 0) {\\n                markets[_market].collateral.transfer(\\n                    msg.sender,\\n                    collateralAvailable\\n                );\\n            }\\n        } else {\\n            uint256 sellTokenBal = sellToken.balanceOf(address(this));\\n            // Send any leftover sellToken to the sender\\n            if (sellTokenBal != 0) {\\n                sellToken.transfer(msg.sender, sellTokenBal);\\n            }\\n        }\\n\\n        if (dola.balanceOf(address(this)) < _value)\\n            revert DOLAInvalidRepay(_value, dola.balanceOf(address(this)));\\n\\n        dola.burn(_value);\\n\\n        // Send any DOLA leftover to the sender after burning (in case the collateral withdrawn and swapped exceeds the value to burn)\\n        dola.transfer(msg.sender, dola.balanceOf(address(this)));\\n\\n        if (_dbrData.amountIn != 0) {\\n            dbr.transferFrom(msg.sender, address(this), _dbrData.amountIn);\\n            _sellDbr(_dbrData.amountIn, _dbrData.minOut, msg.sender);\\n        }\\n\\n        // Refund any unspent protocol fees to the sender.\\n        if (address(this).balance > 0)\\n            payable(msg.sender).transfer(address(this).balance);\\n\\n       emit LeverageDown(_market, msg.sender, _value, _collateralAmount, _dbrData.dola, _dbrData.amountIn);\\n    }\\n\\n    /// @notice Mint DOLA to this contract and approve the spender\\n    /// @param spender The spender address\\n    /// @param _value Amount of DOLA to mint and approve\\n    function _mintAndApproveDola(address spender, uint256 _value) internal {\\n        dola.mint(address(this), _value);\\n        dola.approve(spender, _value);\\n    }\\n\\n    /// @notice Borrow DOLA on behalf of the user\\n    /// @param _value Amount of DOLA to borrow\\n    /// @param _permit Permit data\\n    /// @param _dbrData DBR data\\n    /// @param market The market contract\\n    function _borrowDola(\\n        uint256 _value,\\n        Permit calldata _permit,\\n        DBRHelper calldata _dbrData,\\n        IMarket market\\n    ) internal {\\n        uint256 dolaToBorrow = _value;\\n\\n        if (_dbrData.dola != 0) {\\n            dolaToBorrow += _dbrData.dola;\\n        }\\n\\n        if (_dbrData.amountIn != 0) {\\n            dolaToBorrow += _dbrData.amountIn;\\n        }\\n        // We borrow the amount of DOLA we minted before plus the amount for buying DBR if any\\n        market.borrowOnBehalf(\\n            msg.sender,\\n            dolaToBorrow,\\n            _permit.deadline,\\n            _permit.v,\\n            _permit.r,\\n            _permit.s\\n        );\\n\\n        if (dola.balanceOf(address(this)) < dolaToBorrow)\\n            revert DOLAInvalidBorrow(dolaToBorrow,dola.balanceOf(address(this)));\\n    }\\n\\n    /// @notice Repay DOLA loan and withdraw collateral from the escrow\\n    /// @param _value Amount of DOLA to repay\\n    /// @param _collateralAmount Collateral amount to withdraw from the escrow\\n    /// @param _permit Permit data\\n    /// @param _dbrData DBR data\\n    /// @param market The market contract\\n    function _repayAndWithdraw(\\n        uint256 _value,\\n        uint256 _collateralAmount,\\n        Permit calldata _permit,\\n        DBRHelper calldata _dbrData,\\n        IMarket market\\n    ) internal {\\n        if (_dbrData.dola != 0) {\\n            dola.transferFrom(msg.sender, address(this), _dbrData.dola);\\n\\n            dola.mint(address(this), _value);\\n            dola.approve(address(market), _value + _dbrData.dola);\\n\\n            market.repay(msg.sender, _value + _dbrData.dola);\\n        } else {\\n            _mintAndApproveDola(address(market), _value);\\n            market.repay(msg.sender, _value);\\n        }\\n\\n        // withdraw amount from ZERO EX quote\\n        market.withdrawOnBehalf(\\n            msg.sender,\\n            _collateralAmount,\\n            _permit.deadline,\\n            _permit.v,\\n            _permit.r,\\n            _permit.s\\n        );\\n    }\\n\\n    /// @notice convert a collateral amount into the underlying asset\\n    /// @param _collateralAmount Collateral amount to convert\\n    /// @param _market The market contract\\n    /// @param sellToken The sell token (the underlying asset)\\n    /// @param _helperData Optional helper data\\n    /// @return assetAmount The amount of sellToken/underlying after the conversion\\n    function _convertToAsset(\\n        uint256 _collateralAmount,\\n        address _market,\\n        IERC20 sellToken,\\n        bytes calldata _helperData\\n    ) internal returns (uint256) {\\n        // Collateral amount is now transformed into sellToken\\n        uint256 assetAmount = markets[_market].helper.transformFromCollateral(\\n            _collateralAmount,\\n            _helperData\\n        );\\n\\n        if (sellToken.balanceOf(address(this)) < assetAmount)\\n            revert WithdrawFailed(assetAmount,sellToken.balanceOf(address(this)));\\n\\n        return assetAmount;\\n    }\\n\\n    /// @notice convert the underlying asset amount into the collateral\\n    /// @param _assetAmount The amount of sellToken/underlying to convert\\n    /// @param _market The market contract\\n    /// @param _helperData Optional helper data\\n    /// @return collateralAmount The amount of collateral after the conversion\\n    function _convertToCollateral(\\n        uint256 _assetAmount,\\n        address _market,\\n        bytes calldata _helperData\\n    ) internal returns (uint256) {\\n        // Collateral amount is now transformed\\n        uint256 collateralAmount = markets[_market]\\n            .helper\\n            .transformToCollateral(_assetAmount, _helperData);\\n\\n        if (\\n            markets[_market].collateral.balanceOf(address(this)) <\\n            collateralAmount\\n        )\\n            revert DepositFailed(\\n                collateralAmount,\\n                markets[_market].collateral.balanceOf(address(this))\\n            );\\n\\n        return collateralAmount;\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMarket.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\ninterface IMarket {\\n    function borrowOnBehalf(address msgSender, uint dolaAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function withdrawOnBehalf(address msgSender, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function deposit(address msgSender, uint collateralAmount) external;\\n    function repay(address msgSender, uint amount) external;\\n    function collateral() external returns(address);\\n    function debts(address user) external returns(uint);\\n    function recall(uint amount) external;\\n    function totalDebt() external view returns (uint);\\n    function borrowPaused() external view returns (bool);\\n    function oracle() external view returns (address);\\n}\\n\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\ninterface IERC20 {\\n    function approve(address,uint) external;\\n    function transfer(address,uint) external returns (bool);\\n    function transferFrom(address,address,uint) external returns (bool);\\n    function balanceOf(address) external view returns (uint);\\n    function allowance(address from, address to) external view returns (uint);\\n}\\n\\ninterface IDelegateableERC20 is IERC20 {\\n    function delegate(address delegatee) external;\\n    function delegates(address delegator) external view returns (address delegatee);\\n}\\n\\n\"\r\n    },\r\n    \"src/interfaces/ITransformHelper.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: None\\npragma solidity ^0.8.0;\\n\\ninterface ITransformHelper {\\n    \\n    struct Permit {\\n        uint256 deadline;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    function transformToCollateral(\\n        uint amount,\\n        bytes calldata data\\n    ) external returns (uint);\\n\\n    function transformToCollateralAndDeposit(\\n        uint amount,\\n        bytes calldata data\\n    ) external returns (uint256 collateralAmount);\\n\\n    function transformFromCollateral(\\n        uint amount,\\n        bytes calldata data\\n    ) external returns (uint);\\n\\n    function withdrawAndTransformFromCollateral(\\n        uint amount,\\n        Permit calldata permit,\\n        bytes calldata data\\n    ) external returns (uint256 underlyingAmount);\\n\\n    function assetToCollateralRatio(\\n        uint assetAmount\\n    ) external view returns (uint collateralAmount);\\n\\n    function assetToCollateral(\\n        uint assetAmount\\n    ) external view returns (uint collateralAmount);\\n    \\n    function collateralToAsset(\\n        uint collateralAmount\\n    ) external view returns (uint assetAmount);\\n}\\n\"\r\n    },\r\n    \"src/util/CurveDBRHelper.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n//import \\\"src/util/OffchainAbstractHelper.sol\\\";\\nimport \\\"src/interfaces/IERC20.sol\\\";\\nimport \\\"src/interfaces/IDola.sol\\\";\\n\\ninterface ICurvePool {\\n    function coins(uint index) external view returns (address);\\n\\n    function get_dy(uint i, uint j, uint dx) external view returns (uint);\\n\\n    function exchange(\\n        uint i,\\n        uint j,\\n        uint dx,\\n        uint min_dy,\\n        bool use_eth\\n    ) external payable returns (uint);\\n\\n    function exchange(\\n        uint i,\\n        uint j,\\n        uint dx,\\n        uint min_dy,\\n        bool use_eth,\\n        address receiver\\n    ) external payable returns (uint);\\n}\\n\\ncontract CurveDBRHelper {\\n    ICurvePool public immutable curvePool;\\n    IDola constant dola = IDola(0x865377367054516e17014CcdED1e7d814EDC9ce4);\\n    IERC20 constant dbr = IERC20(0xAD038Eb671c44b853887A7E32528FaB35dC5D710);\\n\\n    uint dbrIndex;\\n    uint dolaIndex;\\n\\n    constructor(address _pool) {\\n        curvePool = ICurvePool(_pool);\\n        dola.approve(_pool, type(uint).max);\\n        dbr.approve(_pool, type(uint).max);\\n        if (ICurvePool(_pool).coins(0) == address(dola)) {\\n            dolaIndex = 0;\\n            dbrIndex = 1;\\n        } else {\\n            dolaIndex = 1;\\n            dbrIndex = 0;\\n        }\\n    }\\n\\n    /**\\n    @notice Sells an exact amount of DBR for DOLA in a curve pool\\n    @param amount Amount of DBR to sell\\n    @param minOut minimum amount of DOLA to receive\\n    */\\n    function _sellDbr(uint amount, uint minOut, address receiver) internal {\\n        if (amount > 0) {\\n            curvePool.exchange(\\n                dbrIndex,\\n                dolaIndex,\\n                amount,\\n                minOut,\\n                false,\\n                receiver\\n            );\\n        }\\n    }\\n\\n    /**\\n    @notice Buys an exact amount of DBR for DOLA in a curve pool\\n    @param amount Amount of DOLA to sell\\n    @param minOut minimum amount of DBR out\\n    */\\n    function _buyDbr(uint amount, uint minOut, address receiver) internal {\\n        if (amount > 0) {\\n            curvePool.exchange(\\n                dolaIndex,\\n                dbrIndex,\\n                amount,\\n                minOut,\\n                false,\\n                receiver\\n            );\\n        }\\n    }\\n\\n    /**\\n    @notice Approximates the total amount of dola and dbr needed to borrow a dolaBorrowAmount while also borrowing enough to buy the DBR needed to cover for the borrowing period\\n    @dev Uses a binary search to approximate the amounts needed. Should only be called as part of generating transaction parameters.\\n    @param dolaBorrowAmount Amount of dola the user wishes to end up with\\n    @param period Amount of time in seconds the loan will last\\n    @param iterations Number of approximation iterations. The higher the more precise the result\\n    */\\n    function approximateDolaAndDbrNeeded(\\n        uint dolaBorrowAmount,\\n        uint period,\\n        uint iterations\\n    ) public view returns (uint dolaForDbr, uint dbrNeeded) {\\n        uint amountIn = dolaBorrowAmount;\\n        uint stepSize = amountIn / 2;\\n        uint dbrReceived = curvePool.get_dy(dolaIndex, dbrIndex, amountIn);\\n        uint dbrToBuy = ((amountIn + dolaBorrowAmount) * period) / 365 days;\\n        uint dist = dbrReceived > dbrToBuy\\n            ? dbrReceived - dbrToBuy\\n            : dbrToBuy - dbrReceived;\\n        for (uint i; i < iterations; ++i) {\\n            uint newAmountIn = amountIn;\\n            if (dbrReceived > dbrToBuy) {\\n                newAmountIn -= stepSize;\\n            } else {\\n                newAmountIn += stepSize;\\n            }\\n            uint newDbrReceived = curvePool.get_dy(\\n                dolaIndex,\\n                dbrIndex,\\n                newAmountIn\\n            );\\n            uint newDbrToBuy = ((newAmountIn + dolaBorrowAmount) * period) /\\n                365 days;\\n            uint newDist = newDbrReceived > newDbrToBuy\\n                ? newDbrReceived - newDbrToBuy\\n                : newDbrToBuy - newDbrReceived;\\n            if (newDist < dist) {\\n                dbrReceived = newDbrReceived;\\n                dbrToBuy = newDbrToBuy;\\n                dist = newDist;\\n                amountIn = newAmountIn;\\n            }\\n            stepSize /= 2;\\n        }\\n        return (amountIn, ((dolaBorrowAmount + amountIn) * period) / 365 days);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IDola.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"src/interfaces/IERC20.sol\\\";\\n\\ninterface IDola  is IERC20{\\n    function mint(address recipient, uint256 amount) external;\\n    function burn(uint256 amount) external;\\n    function addMinter(address minter) external;\\n    function totalSupply() external view returns (uint256);\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchangeProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CollateralIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollateralNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"DOLAInvalidBorrow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"DOLAInvalidRepay\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"DepositFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidHelperAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProxyAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"MarketNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"NoMarket\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToDeposit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SwapFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"TotalSupplyChanged\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"WithdrawFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buySellToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"helper\",\"type\":\"address\"}],\"name\":\"WrongCollateral\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dolaFlashMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dolaUserRepaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dbrSoldForDola\",\"type\":\"uint256\"}],\"name\":\"LeverageDown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dolaFlashMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralDeposited\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dolaBorrowed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dolaForDBR\",\"type\":\"uint256\"}],\"name\":\"LeverageUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"helper\",\"type\":\"address\"}],\"name\":\"NewHelper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buySellToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"helper\",\"type\":\"address\"}],\"name\":\"NewMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DBR\",\"outputs\":[{\"internalType\":\"contract IDBR\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dolaBorrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"}],\"name\":\"approximateDolaAndDbrNeeded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dolaForDbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbrNeeded\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curvePool\",\"outputs\":[{\"internalType\":\"contract ICurvePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_swapCallData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ALE.Permit\",\"name\":\"_permit\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_helperData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dola\",\"type\":\"uint256\"}],\"internalType\":\"struct ALE.DBRHelper\",\"name\":\"_dbrData\",\"type\":\"tuple\"}],\"name\":\"deleveragePosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_swapCallData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ALE.Permit\",\"name\":\"_permit\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_helperData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dola\",\"type\":\"uint256\"}],\"internalType\":\"struct ALE.DBRHelper\",\"name\":\"_dbrData\",\"type\":\"tuple\"}],\"name\":\"depositAndLeveragePosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeProxy\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_swapCallData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ALE.Permit\",\"name\":\"_permit\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_helperData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dola\",\"type\":\"uint256\"}],\"internalType\":\"struct ALE.DBRHelper\",\"name\":\"_dbrData\",\"type\":\"tuple\"}],\"name\":\"leveragePosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"markets\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"buySellToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"contract ITransformHelper\",\"name\":\"helper\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchangeProxy\",\"type\":\"address\"}],\"name\":\"setExchangeProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buySellToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_helper\",\"type\":\"address\"}],\"name\":\"setMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_helper\",\"type\":\"address\"}],\"name\":\"updateMarketHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ALE", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000def1c0ded9bec7f1a1670819833240f027b25eff000000000000000000000000c7de47b9ca2fc753d6a2f167d8b3e19c6d18b19a", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}