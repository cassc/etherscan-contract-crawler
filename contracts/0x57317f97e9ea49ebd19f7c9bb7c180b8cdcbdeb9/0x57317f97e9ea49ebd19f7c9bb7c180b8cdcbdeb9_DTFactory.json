{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/ahmedali/Desktop/work/mainnet-deployment/ocean-contracts/contracts/DTFactory.sol\": {\r\n      \"content\": \"pragma solidity 0.5.7;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\nimport './utils/Deployer.sol';\\nimport './interfaces/IERC20Template.sol';\\n\\n/**\\n * @title DTFactory contract\\n * @author Ocean Protocol Team\\n *\\n * @dev Implementation of Ocean DataTokens Factory\\n *\\n *      DTFactory deploys DataToken proxy contracts.\\n *      New DataToken proxy contracts are links to the template contract's bytecode.\\n *      Proxy contract functionality is based on Ocean Protocol custom implementation of ERC1167 standard.\\n */\\ncontract DTFactory is Deployer {\\n    address private tokenTemplate;\\n    address private communityFeeCollector;\\n    uint256 private currentTokenCount = 1;\\n\\n    event TokenCreated(\\n        address indexed newTokenAddress,\\n        address indexed templateAddress,\\n        string indexed tokenName\\n    );\\n\\n    event TokenRegistered(\\n        address indexed tokenAddress,\\n        string tokenName,\\n        string tokenSymbol,\\n        uint256 tokenCap,\\n        address indexed registeredBy,\\n        string indexed blob\\n    );\\n\\n    /**\\n     * @dev constructor\\n     *      Called on contract deployment. Could not be called with zero address parameters.\\n     * @param _template refers to the address of a deployed DataToken contract.\\n     * @param _collector refers to the community fee collector address\\n     */\\n    constructor(\\n        address _template,\\n        address _collector\\n    ) public {\\n        require(\\n            _template != address(0) &&\\n            _collector != address(0),\\n            'DTFactory: Invalid template token/community fee collector address'\\n        );\\n        tokenTemplate = _template;\\n        communityFeeCollector = _collector;\\n    }\\n\\n    /**\\n     * @dev Deploys new DataToken proxy contract.\\n     *      Template contract address could not be a zero address.\\n     * @param blob any string that hold data/metadata for the new token\\n     * @param name token name\\n     * @param symbol token symbol\\n     * @param cap the maximum total supply\\n     * @return address of a new proxy DataToken contract\\n     */\\n    function createToken(\\n        string memory blob,\\n        string memory name,\\n        string memory symbol,\\n        uint256 cap\\n    )\\n        public\\n        returns (address token)\\n    {\\n        require(\\n            cap != 0,\\n            'DTFactory: zero cap is not allowed'\\n        );\\n\\n        token = deploy(tokenTemplate);\\n\\n        require(\\n            token != address(0),\\n            'DTFactory: Failed to perform minimal deploy of a new token'\\n        );\\n        IERC20Template tokenInstance = IERC20Template(token);\\n        require(\\n            tokenInstance.initialize(\\n                name,\\n                symbol,\\n                msg.sender,\\n                cap,\\n                blob,\\n                communityFeeCollector\\n            ),\\n            'DTFactory: Unable to initialize token instance'\\n        );\\n        emit TokenCreated(token, tokenTemplate, name);\\n        emit TokenRegistered(\\n            token,\\n            name,\\n            symbol,\\n            cap,\\n            msg.sender,\\n            blob\\n        );\\n        currentTokenCount += 1;\\n    }\\n\\n    /**\\n     * @dev get the current token count.\\n     * @return the current token count\\n     */\\n    function getCurrentTokenCount() external view returns (uint256) {\\n        return currentTokenCount;\\n    }\\n\\n    /**\\n     * @dev get the token template address\\n     * @return the template address\\n     */\\n    function getTokenTemplate() external view returns (address) {\\n        return tokenTemplate;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ahmedali/Desktop/work/mainnet-deployment/ocean-contracts/contracts/interfaces/IERC20Template.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20Template {\\n    function initialize(\\n        string calldata name,\\n        string calldata symbol,\\n        address minter,\\n        uint256 cap,\\n        string calldata blob,\\n        address collector\\n    ) external returns (bool);\\n\\n    function mint(address account, uint256 value) external;\\n    function minter() external view returns(address);    \\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function cap() external view returns (uint256);\\n    function isMinter(address account) external view returns (bool);\\n    function isInitialized() external view returns (bool);\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function proposeMinter(address newMinter) external;\\n    function approveMinter() external;\\n}\\n\"\r\n    },\r\n    \"/Users/ahmedali/Desktop/work/mainnet-deployment/ocean-contracts/contracts/utils/Deployer.sol\": {\r\n      \"content\": \"pragma solidity 0.5.7;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\n/**\\n * @title Deployer Contract\\n * @author Ocean Protocol Team\\n *\\n * @dev Contract Deployer\\n *      This contract allowes factory contract \\n *      to deploy new contract instances using\\n *      the same library pattern in solidity.\\n *      the logic it self is deployed only once, but\\n *      executed in the context of the new storage \\n *      contract (new contract instance)\\n */\\ncontract Deployer {\\n    event InstanceDeployed(address instance);\\n    \\n    /**\\n     * @dev deploy\\n     *      deploy new contract instance \\n     * @param _logic the logic contract address\\n     * @return address of the new instance\\n     */\\n    function deploy(\\n        address _logic\\n    ) \\n      internal \\n      returns (address instance) \\n    {\\n        bytes20 targetBytes = bytes20(_logic);\\n        // Follows OpenZeppelin Implementation https://github.com/OpenZeppelin/openzeppelin-sdk/blob/71c9ad77e0326db079e6a643eca8568ab316d4a9/packages/lib/contracts/upgradeability/ProxyFactory.sol\\n        // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n          let clone := mload(0x40)\\n          mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n          mstore(add(clone, 0x14), targetBytes)\\n          mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n          instance := create(0, clone, 0x37)\\n        }\\n        emit InstanceDeployed(address(instance));\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {\r\n      \"\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"getTokenTemplate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blob\",\"type\":\"string\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"createToken\",\"outputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_template\",\"type\":\"address\"},{\"name\":\"_collector\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"templateAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenName\",\"type\":\"string\"}],\"name\":\"TokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"tokenCap\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"registeredBy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"blob\",\"type\":\"string\"}],\"name\":\"TokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"InstanceDeployed\",\"type\":\"event\"}]", "ContractName": "DTFactory", "CompilerVersion": "v0.5.7+commit.6da8b019", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000081d1ae20e83d955d1b2e517238f32b8e8deadd20000000000000000000000002e6ff1f888425e6eac81cf3360bb805ab40ecc1a", "EVMVersion": "byzantium", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}