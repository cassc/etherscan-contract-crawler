{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nabstract contract Context {\r\nfunction _msgSender() internal view virtual returns (address) {\r\nreturn msg.sender;\r\n}\r\n}\r\n\r\ninterface IERC20 {\r\nfunction totalSupply() external view returns (uint256);\r\nfunction balanceOf(address account) external view returns (uint256);\r\nfunction transfer(address recipient, uint256 amount) external returns (bool);\r\nfunction allowance(address owner, address spender) external view returns (uint256);\r\nfunction approve(address spender, uint256 amount) external returns (bool);\r\nfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\nevent Transfer(address indexed from, address indexed to, uint256 value);\r\nevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\nuint256 c = a + b;\r\nrequire(c >= a, \"SafeMath: addition overflow\");\r\nreturn c;\r\n}\r\n\r\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\nreturn sub(a, b, \"SafeMath: subtraction overflow\");\r\n}\r\n\r\nfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\nrequire(b <= a, errorMessage);\r\nuint256 c = a - b;\r\nreturn c;\r\n}\r\n\r\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\nif (a == 0) {\r\nreturn 0;\r\n}\r\nuint256 c = a * b;\r\nrequire(c / a == b, \"SafeMath: multiplication overflow\");\r\nreturn c;\r\n}\r\n\r\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\nreturn div(a, b, \"SafeMath: division by zero\");\r\n}\r\n\r\nfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\nrequire(b > 0, errorMessage);\r\nuint256 c = a / b;\r\nreturn c;\r\n}\r\n\r\n}\r\n\r\nabstract contract Ownable is Context {\r\naddress private _owner;\r\n\r\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n/**\r\n* @dev Initializes the contract setting the deployer as the initial owner.\r\n*/\r\nconstructor() {\r\n_transferOwnership(_msgSender());\r\n}\r\n\r\n/**\r\n* @dev Throws if called by any account other than the owner.\r\n*/\r\nmodifier onlyOwner() {\r\n_checkOwner();\r\n_;\r\n}\r\n\r\n/**\r\n* @dev Returns the address of the current owner.\r\n*/\r\nfunction owner() public view virtual returns (address) {\r\nreturn _owner;\r\n}\r\n\r\n/**\r\n* @dev Throws if the sender is not the owner.\r\n*/\r\nfunction _checkOwner() internal view virtual {\r\nrequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n}\r\n\r\n/**\r\n* @dev Leaves the contract without owner. It will not be possible to call\r\n* `onlyOwner` functions. Can only be called by the current owner.\r\n*\r\n* NOTE: Renouncing ownership will leave the contract without an owner,\r\n* thereby disabling any functionality that is only available to the owner.\r\n*/\r\nfunction renounceOwnership() public virtual onlyOwner {\r\n_transferOwnership(address(0));\r\n}\r\n\r\n/**\r\n* @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n* Can only be called by the current owner.\r\n*/\r\nfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\nrequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n_transferOwnership(newOwner);\r\n}\r\n\r\n/**\r\n* @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n* Internal function without access restriction.\r\n*/\r\nfunction _transferOwnership(address newOwner) internal virtual {\r\naddress oldOwner = _owner;\r\n_owner = newOwner;\r\nemit OwnershipTransferred(oldOwner, newOwner);\r\n}\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\nfunction createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\nfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\nuint amountIn,\r\nuint amountOutMin,\r\naddress[] calldata path,\r\naddress to,\r\nuint deadline\r\n) external;\r\nfunction factory() external pure returns (address);\r\nfunction WETH() external pure returns (address);\r\nfunction addLiquidityETH(\r\naddress token,\r\nuint amountTokenDesired,\r\nuint amountTokenMin,\r\nuint amountETHMin,\r\naddress to,\r\nuint deadline\r\n) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\ncontract CryptoAI is Context, IERC20, Ownable {\r\nusing SafeMath for uint256;\r\n\r\nmapping (address => uint256) private _balances;\r\nmapping (address => mapping (address => uint256)) private _allowances;\r\nmapping (address => bool) public _isExcludedFromFee;\r\naddress payable public _taxWallet = payable(0x6498b9351935B78d07a7D61Ec733D733d13C0774); // tax wallet\r\n\r\nuint256 public _buyTax = 3;\r\nuint256 public _sellTax = 23;\r\n\r\nuint8 private constant _decimals = 18;\r\nuint256 private constant _tTotal = 2000000000 * 10**_decimals; // Total Supply\r\nstring private constant _name = unicode\"CryptoAI\"; // name\r\nstring private constant _symbol = unicode\"CryptoAI\"; // symbol\r\nuint256 public _taxSwapThreshold= 1000000 * 10**_decimals;\r\n\r\nIUniswapV2Router02 private uniswapV2Router;\r\naddress private uniswapV2Pair;\r\nbool private tradingOpen;\r\nbool private inSwap = false;\r\nbool private swapEnabled = true;\r\n\r\nmodifier lockTheSwap {\r\ninSwap = true;\r\n_;\r\ninSwap = false;\r\n}\r\n\r\nconstructor () {\r\nIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // mainnet router address\r\n\r\n// Create a uniswap pair for this new token\r\nuniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n.createPair(address(this), _uniswapV2Router.WETH());\r\n\r\n// set the rest of the contract variables\r\nuniswapV2Router = _uniswapV2Router;\r\n\r\n_balances[_msgSender()] = _tTotal;\r\n_isExcludedFromFee[owner()] = true;\r\n_isExcludedFromFee[address(this)] = true;\r\n_isExcludedFromFee[_taxWallet] = true;\r\n\r\ntradingOpen = true;\r\n\r\nemit Transfer(address(0), _msgSender(), _tTotal);\r\n}\r\n\r\nfunction name() public pure returns (string memory) {\r\nreturn _name;\r\n}\r\n\r\nfunction symbol() public pure returns (string memory) {\r\nreturn _symbol;\r\n}\r\n\r\nfunction decimals() public pure returns (uint8) {\r\nreturn _decimals;\r\n}\r\n\r\nfunction totalSupply() public pure override returns (uint256) {\r\nreturn _tTotal;\r\n}\r\n\r\nfunction balanceOf(address account) public view override returns (uint256) {\r\nreturn _balances[account];\r\n}\r\n\r\nfunction transfer(address recipient, uint256 amount) public override returns (bool) {\r\n_transfer(_msgSender(), recipient, amount);\r\nreturn true;\r\n}\r\n\r\nfunction allowance(address owner, address spender) public view override returns (uint256) {\r\nreturn _allowances[owner][spender];\r\n}\r\n\r\nfunction approve(address spender, uint256 amount) public override returns (bool) {\r\n_approve(_msgSender(), spender, amount);\r\nreturn true;\r\n}\r\n\r\nfunction transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n_transfer(sender, recipient, amount);\r\n_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\nreturn true;\r\n}\r\n\r\nfunction _approve(address owner, address spender, uint256 amount) private {\r\nrequire(owner != address(0), \"ERC20: approve from the zero address\");\r\nrequire(spender != address(0), \"ERC20: approve to the zero address\");\r\n_allowances[owner][spender] = amount;\r\nemit Approval(owner, spender, amount);\r\n}\r\n\r\nfunction _transfer(address from, address to, uint256 amount) private {\r\nrequire(from != address(0), \"ERC20: transfer from the zero address\");\r\nrequire(to != address(0), \"ERC20: transfer to the zero address\");\r\nrequire(amount > 0, \"Transfer amount must be greater than zero\");\r\nuint256 taxAmount=0;\r\nif (!_isExcludedFromFee[from] && !_isExcludedFromFee[to]) {\r\n\r\nif (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] ) {\r\ntaxAmount = amount.mul(_buyTax).div(100);\r\n}\r\n\r\nif(to == uniswapV2Pair && from!= address(this) ){\r\ntaxAmount = amount.mul(_sellTax).div(100);\r\n\r\n}\r\n\r\nuint256 contractTokenBalance = balanceOf(address(this));\r\nif (!inSwap && to == uniswapV2Pair && swapEnabled && contractTokenBalance>_taxSwapThreshold) {\r\nswapTokensForEth(contractTokenBalance);\r\nuint256 contractETHBalance = address(this).balance;\r\nif(contractETHBalance > 0) {\r\nsendETHToFee(address(this).balance);\r\n}\r\n}\r\n}\r\n\r\nif(taxAmount>0){\r\n_balances[address(this)]=_balances[address(this)].add(taxAmount);\r\nemit Transfer(from, address(this),taxAmount);\r\n}\r\n_balances[from]=_balances[from].sub(amount);\r\n_balances[to]=_balances[to].add(amount.sub(taxAmount));\r\nemit Transfer(from, to, amount.sub(taxAmount));\r\n}\r\n\r\nfunction min(uint256 a, uint256 b) private pure returns (uint256){\r\nreturn (a>b)?b:a;\r\n}\r\n\r\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\nif(tokenAmount==0){return;}\r\nif(!tradingOpen){return;}\r\naddress[] memory path = new address[](2);\r\npath[0] = address(this);\r\npath[1] = uniswapV2Router.WETH();\r\n_approve(address(this), address(uniswapV2Router), tokenAmount);\r\nuniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\ntokenAmount,\r\n0,\r\npath,\r\naddress(this),\r\nblock.timestamp\r\n);\r\n}\r\n\r\nfunction sendETHToFee(uint256 amount) private {\r\n_taxWallet.transfer(amount);\r\n}\r\n\r\nreceive() external payable {}\r\n\r\nfunction manualSwap() external {\r\nrequire(_msgSender()==_taxWallet);\r\nuint256 tokenBalance=balanceOf(address(this));\r\nif(tokenBalance>0){\r\nswapTokensForEth(tokenBalance);\r\n}\r\nuint256 ethBalance=address(this).balance;\r\nif(ethBalance>0){\r\nsendETHToFee(ethBalance);\r\n}\r\n}\r\n\r\nfunction changeTaxes(uint256 buyFee, uint256 sellFee) public onlyOwner {\r\nrequire(buyFee <= 25, \"Tax too high\");\r\nrequire(sellFee <= 25, \"Tax too high\");\r\n_buyTax = buyFee;\r\n_sellTax = sellFee;\r\n}\r\n\r\nfunction whitelistFromTaxes(address account) public onlyOwner {\r\n_isExcludedFromFee[account] = true;\r\n}\r\n\r\nfunction includeInTaxes(address account) public onlyOwner {\r\n_isExcludedFromFee[account] = false;\r\n}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_buyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxSwapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellFee\",\"type\":\"uint256\"}],\"name\":\"changeTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"whitelistFromTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CryptoAI", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7b1e6a7f8c5945e0a3ee11d13bd9f854686df603954377756a78fe83d6bad725"}