{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin-4.7/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\\n     * consuming from one or the other at each step according to the instructions given by\\n     * `proofFlags`.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IAdminACLV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAdminACLV0 {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     * @param previousSuperAdmin The previous superAdmin address.\\n     * @param newSuperAdmin The new superAdmin address.\\n     * @param genArt721CoreAddressesToUpdate Array of genArt721Core\\n     * addresses to update to the new superAdmin, for indexing purposes only.\\n     */\\n    event SuperAdminTransferred(\\n        address indexed previousSuperAdmin,\\n        address indexed newSuperAdmin,\\n        address[] genArt721CoreAddressesToUpdate\\n    );\\n\\n    /// Type of the Admin ACL contract, e.g. \\\"AdminACLV0\\\"\\n    function AdminACLType() external view returns (string memory);\\n\\n    /// super admin address\\n    function superAdmin() external view returns (address);\\n\\n    /**\\n     * @notice Calls transferOwnership on other contract from this contract.\\n     * This is useful for updating to a new AdminACL contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function transferOwnershipOn(\\n        address _contract,\\n        address _newAdminACL\\n    ) external;\\n\\n    /**\\n     * @notice Calls renounceOwnership on other contract from this contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function renounceOwnershipOn(address _contract) external;\\n\\n    /**\\n     * @notice Checks if sender `_sender` is allowed to call function with selector\\n     * `_selector` on contract `_contract`.\\n     */\\n    function allowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IDelegationRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.19;\\n\\n/// @dev Source: https://github.com/0xfoobar/delegation-registry/blob/main/src/IDelegationRegistry.sol\\n\\n/**\\n * @title An immutable registry contract to be deployed as a standalone primitive\\n * @dev See EIP-5639, new project launches can read previous cold wallet -> hot wallet delegations\\n * from here and integrate those permissions into their flow\\n */\\ninterface IDelegationRegistry {\\n    /// @notice Delegation type\\n    enum DelegationType {\\n        NONE,\\n        ALL,\\n        CONTRACT,\\n        TOKEN\\n    }\\n\\n    /// @notice Info about a single delegation, used for onchain enumeration\\n    struct DelegationInfo {\\n        DelegationType type_;\\n        address vault;\\n        address delegate;\\n        address contract_;\\n        uint256 tokenId;\\n    }\\n\\n    /// @notice Info about a single contract-level delegation\\n    struct ContractDelegation {\\n        address contract_;\\n        address delegate;\\n    }\\n\\n    /// @notice Info about a single token-level delegation\\n    struct TokenDelegation {\\n        address contract_;\\n        uint256 tokenId;\\n        address delegate;\\n    }\\n\\n    /// @notice Emitted when a user delegates their entire wallet\\n    event DelegateForAll(address vault, address delegate, bool value);\\n\\n    /// @notice Emitted when a user delegates a specific contract\\n    event DelegateForContract(\\n        address vault,\\n        address delegate,\\n        address contract_,\\n        bool value\\n    );\\n\\n    /// @notice Emitted when a user delegates a specific token\\n    event DelegateForToken(\\n        address vault,\\n        address delegate,\\n        address contract_,\\n        uint256 tokenId,\\n        bool value\\n    );\\n\\n    /// @notice Emitted when a user revokes all delegations\\n    event RevokeAllDelegates(address vault);\\n\\n    /// @notice Emitted when a user revoes all delegations for a given delegate\\n    event RevokeDelegate(address vault, address delegate);\\n\\n    /**\\n     * -----------  WRITE -----------\\n     */\\n\\n    /**\\n     * @notice Allow the delegate to act on your behalf for all contracts\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\n     */\\n    function delegateForAll(address delegate, bool value) external;\\n\\n    /**\\n     * @notice Allow the delegate to act on your behalf for a specific contract\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\n     */\\n    function delegateForContract(\\n        address delegate,\\n        address contract_,\\n        bool value\\n    ) external;\\n\\n    /**\\n     * @notice Allow the delegate to act on your behalf for a specific token\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param tokenId The token id for the token you're delegating\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\n     */\\n    function delegateForToken(\\n        address delegate,\\n        address contract_,\\n        uint256 tokenId,\\n        bool value\\n    ) external;\\n\\n    /**\\n     * @notice Revoke all delegates\\n     */\\n    function revokeAllDelegates() external;\\n\\n    /**\\n     * @notice Revoke a specific delegate for all their permissions\\n     * @param delegate The hotwallet to revoke\\n     */\\n    function revokeDelegate(address delegate) external;\\n\\n    /**\\n     * @notice Remove yourself as a delegate for a specific vault\\n     * @param vault The vault which delegated to the msg.sender, and should be removed\\n     */\\n    function revokeSelf(address vault) external;\\n\\n    /**\\n     * -----------  READ -----------\\n     */\\n\\n    /**\\n     * @notice Returns all active delegations a given delegate is able to claim on behalf of\\n     * @param delegate The delegate that you would like to retrieve delegations for\\n     * @return info Array of DelegationInfo structs\\n     */\\n    function getDelegationsByDelegate(\\n        address delegate\\n    ) external view returns (DelegationInfo[] memory);\\n\\n    /**\\n     * @notice Returns an array of wallet-level delegates for a given vault\\n     * @param vault The cold wallet who issued the delegation\\n     * @return addresses Array of wallet-level delegates for a given vault\\n     */\\n    function getDelegatesForAll(\\n        address vault\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns an array of contract-level delegates for a given vault and contract\\n     * @param vault The cold wallet who issued the delegation\\n     * @param contract_ The address for the contract you're delegating\\n     * @return addresses Array of contract-level delegates for a given vault and contract\\n     */\\n    function getDelegatesForContract(\\n        address vault,\\n        address contract_\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns an array of contract-level delegates for a given vault's token\\n     * @param vault The cold wallet who issued the delegation\\n     * @param contract_ The address for the contract holding the token\\n     * @param tokenId The token id for the token you're delegating\\n     * @return addresses Array of contract-level delegates for a given vault's token\\n     */\\n    function getDelegatesForToken(\\n        address vault,\\n        address contract_,\\n        uint256 tokenId\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns all contract-level delegations for a given vault\\n     * @param vault The cold wallet who issued the delegations\\n     * @return delegations Array of ContractDelegation structs\\n     */\\n    function getContractLevelDelegations(\\n        address vault\\n    ) external view returns (ContractDelegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns all token-level delegations for a given vault\\n     * @param vault The cold wallet who issued the delegations\\n     * @return delegations Array of TokenDelegation structs\\n     */\\n    function getTokenLevelDelegations(\\n        address vault\\n    ) external view returns (TokenDelegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns true if the address is delegated to act on the entire vault\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param vault The cold wallet who issued the delegation\\n     */\\n    function checkDelegateForAll(\\n        address delegate,\\n        address vault\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the address is delegated to act on your behalf for a token contract or an entire vault\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param vault The cold wallet who issued the delegation\\n     */\\n    function checkDelegateForContract(\\n        address delegate,\\n        address vault,\\n        address contract_\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the address is delegated to act on your behalf for a specific token, the token's contract or an entire vault\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param tokenId The token id for the token you're delegating\\n     * @param vault The cold wallet who issued the delegation\\n     */\\n    function checkDelegateForToken(\\n        address delegate,\\n        address vault,\\n        address contract_,\\n        uint256 tokenId\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterMerkleV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV1.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterV1 interface in order to\\n * add support for including Merkle proofs when purchasing.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterMerkleV0 is IFilteredMinterV1 {\\n    /**\\n     * @notice Notifies of the contract's default maximum mints allowed per\\n     * user for a given project, on this minter. This value can be overridden\\n     * by the artist of any project at any time.\\n     */\\n    event DefaultMaxInvocationsPerAddress(\\n        uint256 defaultMaxInvocationsPerAddress\\n    );\\n\\n    // Triggers a purchase of a token from the desired project, to the\\n    // TX-sending address. Requires Merkle proof.\\n    function purchase(\\n        uint256 _projectId,\\n        bytes32[] memory _proof\\n    ) external payable returns (uint256 tokenId);\\n\\n    // Triggers a purchase of a token from the desired project, to the specified\\n    // receiving address. Requires Merkle proof.\\n    function purchaseTo(\\n        address _to,\\n        uint256 _projectId,\\n        bytes32[] memory _proof\\n    ) external payable returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterMerkleV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterMerkleV0.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterMerkleV0 interface in order\\n * to add support for configuring and indexing the delegation registry address.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterMerkleV1 is IFilteredMinterMerkleV0 {\\n    /**\\n     * @notice Notifies of the contract's configured delegation registry\\n     * address.\\n     */\\n    event DelegationRegistryUpdated(address delegationRegistryAddress);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterMerkleV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterMerkleV1.sol\\\";\\nimport \\\"./IFilteredMinterV2.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterMerkleV0 interface in order to\\n * add support for manually setting project max invocations.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterMerkleV2 is\\n    IFilteredMinterMerkleV1,\\n    IFilteredMinterV2\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IFilteredMinterV0 {\\n    /**\\n     * @notice Price per token in wei updated for project `_projectId` to\\n     * `_pricePerTokenInWei`.\\n     */\\n    event PricePerTokenInWeiUpdated(\\n        uint256 indexed _projectId,\\n        uint256 indexed _pricePerTokenInWei\\n    );\\n\\n    /**\\n     * @notice Currency updated for project `_projectId` to symbol\\n     * `_currencySymbol` and address `_currencyAddress`.\\n     */\\n    event ProjectCurrencyInfoUpdated(\\n        uint256 indexed _projectId,\\n        address indexed _currencyAddress,\\n        string _currencySymbol\\n    );\\n\\n    /// togglePurchaseToDisabled updated\\n    event PurchaseToDisabledUpdated(\\n        uint256 indexed _projectId,\\n        bool _purchaseToDisabled\\n    );\\n\\n    // getter function of public variable\\n    function minterType() external view returns (string memory);\\n\\n    function genArt721CoreAddress() external returns (address);\\n\\n    function minterFilterAddress() external returns (address);\\n\\n    // Triggers a purchase of a token from the desired project, to the\\n    // TX-sending address.\\n    function purchase(\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId);\\n\\n    // Triggers a purchase of a token from the desired project, to the specified\\n    // receiving address.\\n    function purchaseTo(\\n        address _to,\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId);\\n\\n    // Toggles the ability for `purchaseTo` to be called directly with a\\n    // specified receiving address that differs from the TX-sending address.\\n    function togglePurchaseToDisabled(uint256 _projectId) external;\\n\\n    // Called to make the minter contract aware of the max invocations for a\\n    // given project.\\n    function setProjectMaxInvocations(uint256 _projectId) external;\\n\\n    // Gets if token price is configured, token price in wei, currency symbol,\\n    // and currency address, assuming this is project's minter.\\n    // Supersedes any defined core price.\\n    function getPriceInfo(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV0.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterV0 interface in order to\\n * add support for generic project minter configuration updates.\\n * @dev keys represent strings of finite length encoded in bytes32 to minimize\\n * gas.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterV1 is IFilteredMinterV0 {\\n    /// ANY\\n    /**\\n     * @notice Generic project minter configuration event. Removes key `_key`\\n     * for project `_projectId`.\\n     */\\n    event ConfigKeyRemoved(uint256 indexed _projectId, bytes32 _key);\\n\\n    /// BOOL\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(uint256 indexed _projectId, bytes32 _key, bool _value);\\n\\n    /// UINT256\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of uint256 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of uint256 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /// ADDRESS\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of addresses at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of addresses at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /// BYTES32\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of bytes32 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of bytes32 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @dev Strings not supported. Recommend conversion of (short) strings to\\n     * bytes32 to remain gas-efficient.\\n     */\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV1.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterV1 interface in order to\\n * add support for manually setting project max invocations.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterV2 is IFilteredMinterV1 {\\n    /**\\n     * @notice Local max invocations for project `_projectId`, tied to core contract `_coreContractAddress`,\\n     * updated to `_maxInvocations`.\\n     */\\n    event ProjectMaxInvocationsLimitUpdated(\\n        uint256 indexed _projectId,\\n        uint256 _maxInvocations\\n    );\\n\\n    // Sets the local max invocations for a given project, checking that the provided max invocations is\\n    // less than or equal to the global max invocations for the project set on the core contract.\\n    // This does not impact the max invocations value defined on the core contract.\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 _projectId,\\n        uint256 _maxInvocations\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\n/// use the Royalty Registry's IManifold interface for token royalties\\nimport \\\"./IManifold.sol\\\";\\n\\n/**\\n * @title This interface is intended to house interface items that are common\\n * across all GenArt721CoreContractV3 flagship and derivative implementations.\\n * This interface extends the IManifold royalty interface in order to\\n * add support the Royalty Registry by default.\\n * @author Art Blocks Inc.\\n */\\ninterface IGenArt721CoreContractV3_Base is IManifold {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     */\\n    event Mint(address indexed _to, uint256 indexed _tokenId);\\n\\n    /**\\n     * @notice currentMinter updated to `_currentMinter`.\\n     * @dev Implemented starting with V3 core\\n     */\\n    event MinterUpdated(address indexed _currentMinter);\\n\\n    /**\\n     * @notice Platform updated on bytes32-encoded field `_field`.\\n     */\\n    event PlatformUpdated(bytes32 indexed _field);\\n\\n    /**\\n     * @notice Project ID `_projectId` updated on bytes32-encoded field\\n     * `_update`.\\n     */\\n    event ProjectUpdated(uint256 indexed _projectId, bytes32 indexed _update);\\n\\n    event ProposedArtistAddressesAndSplits(\\n        uint256 indexed _projectId,\\n        address _artistAddress,\\n        address _additionalPayeePrimarySales,\\n        uint256 _additionalPayeePrimarySalesPercentage,\\n        address _additionalPayeeSecondarySales,\\n        uint256 _additionalPayeeSecondarySalesPercentage\\n    );\\n\\n    event AcceptedArtistAddressesAndSplits(uint256 indexed _projectId);\\n\\n    // version and type of the core contract\\n    // coreVersion is a string of the form \\\"0.x.y\\\"\\n    function coreVersion() external view returns (string memory);\\n\\n    // coreType is a string of the form \\\"GenArt721CoreV3\\\"\\n    function coreType() external view returns (string memory);\\n\\n    // owner (pre-V3 was named admin) of contract\\n    // this is expected to be an Admin ACL contract for V3\\n    function owner() external view returns (address);\\n\\n    // Admin ACL contract for V3, will be at the address owner()\\n    function adminACLContract() external returns (IAdminACLV0);\\n\\n    // backwards-compatible (pre-V3) admin - equal to owner()\\n    function admin() external view returns (address);\\n\\n    /**\\n     * Function determining if _sender is allowed to call function with\\n     * selector _selector on contract `_contract`. Intended to be used with\\n     * peripheral contracts such as minters, as well as internally by the\\n     * core contract itself.\\n     */\\n    function adminACLAllowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n\\n    /// getter function of public variable\\n    function startingProjectId() external view returns (uint256);\\n\\n    // getter function of public variable\\n    function nextProjectId() external view returns (uint256);\\n\\n    // getter function of public mapping\\n    function tokenIdToProjectId(\\n        uint256 tokenId\\n    ) external view returns (uint256 projectId);\\n\\n    // @dev this is not available in V0\\n    function isMintWhitelisted(address minter) external view returns (bool);\\n\\n    function projectIdToArtistAddress(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySales(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySalesPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectIdToSecondaryMarketRoyaltyPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectURIInfo(\\n        uint256 _projectId\\n    ) external view returns (string memory projectBaseURI);\\n\\n    // @dev new function in V3\\n    function projectStateData(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 invocations,\\n            uint256 maxInvocations,\\n            bool active,\\n            bool paused,\\n            uint256 completedTimestamp,\\n            bool locked\\n        );\\n\\n    function projectDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory projectName,\\n            string memory artist,\\n            string memory description,\\n            string memory website,\\n            string memory license\\n        );\\n\\n    function projectScriptDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory scriptTypeAndVersion,\\n            string memory aspectRatio,\\n            uint256 scriptCount\\n        );\\n\\n    function projectScriptByIndex(\\n        uint256 _projectId,\\n        uint256 _index\\n    ) external view returns (string memory);\\n\\n    function tokenIdToHash(uint256 _tokenId) external view returns (bytes32);\\n\\n    // function to set a token's hash (must be guarded)\\n    function setTokenHash_8PT(uint256 _tokenId, bytes32 _hash) external;\\n\\n    // @dev gas-optimized signature in V3 for `mint`\\n    function mint_Ecf(\\n        address _to,\\n        uint256 _projectId,\\n        address _by\\n    ) external returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3_Engine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\nimport \\\"./IGenArt721CoreContractV3_Base.sol\\\";\\n\\ninterface IGenArt721CoreContractV3_Engine is IGenArt721CoreContractV3_Base {\\n    // @dev new function in V3\\n    function getPrimaryRevenueSplits(\\n        uint256 _projectId,\\n        uint256 _price\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 renderProviderRevenue_,\\n            address payable renderProviderAddress_,\\n            uint256 platformProviderRevenue_,\\n            address payable platformProviderAddress_,\\n            uint256 artistRevenue_,\\n            address payable artistAddress_,\\n            uint256 additionalPayeePrimaryRevenue_,\\n            address payable additionalPayeePrimaryAddress_\\n        );\\n\\n    // @dev The render provider primary sales payment address\\n    function renderProviderPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev The platform provider primary sales payment address\\n    function platformProviderPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Percentage of primary sales allocated to the render provider\\n    function renderProviderPrimarySalesPercentage()\\n        external\\n        view\\n        returns (uint256);\\n\\n    // @dev Percentage of primary sales allocated to the platform provider\\n    function platformProviderPrimarySalesPercentage()\\n        external\\n        view\\n        returns (uint256);\\n\\n    // @dev The render provider secondary sales royalties payment address\\n    function renderProviderSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev The platform provider secondary sales royalties payment address\\n    function platformProviderSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Basis points of secondary sales allocated to the render provider\\n    function renderProviderSecondarySalesBPS() external view returns (uint256);\\n\\n    // @dev Basis points of secondary sales allocated to the platform provider\\n    function platformProviderSecondarySalesBPS()\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\nimport \\\"./IGenArt721CoreContractV3_Base.sol\\\";\\n\\n/**\\n * @title This interface extends IGenArt721CoreContractV3_Base with functions\\n * that are part of the Art Blocks Flagship core contract.\\n * @author Art Blocks Inc.\\n */\\n// This interface extends IGenArt721CoreContractV3_Base with functions that are\\n// in part of the Art Blocks Flagship core contract.\\ninterface IGenArt721CoreContractV3 is IGenArt721CoreContractV3_Base {\\n    // @dev new function in V3\\n    function getPrimaryRevenueSplits(\\n        uint256 _projectId,\\n        uint256 _price\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 artblocksRevenue_,\\n            address payable artblocksAddress_,\\n            uint256 artistRevenue_,\\n            address payable artistAddress_,\\n            uint256 additionalPayeePrimaryRevenue_,\\n            address payable additionalPayeePrimaryAddress_\\n        );\\n\\n    // @dev Art Blocks primary sales payment address\\n    function artblocksPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\\n     * primary sales payment address (now called artblocksPrimarySalesAddress).\\n     */\\n    function artblocksAddress() external view returns (address payable);\\n\\n    // @dev Percentage of primary sales allocated to Art Blocks\\n    function artblocksPrimarySalesPercentage() external view returns (uint256);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\\n     * primary sales percentage (now called artblocksPrimarySalesPercentage).\\n     */\\n    function artblocksPercentage() external view returns (uint256);\\n\\n    // @dev Art Blocks secondary sales royalties payment address\\n    function artblocksSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Basis points of secondary sales allocated to Art Blocks\\n    function artblocksSecondarySalesBPS() external view returns (uint256);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function  that gets artist +\\n     * artist's additional payee royalty data for token ID `_tokenId`.\\n     * WARNING: Does not include Art Blocks portion of royalties.\\n     */\\n    function getRoyaltyData(\\n        uint256 _tokenId\\n    )\\n        external\\n        view\\n        returns (\\n            address artistAddress,\\n            address additionalPayee,\\n            uint256 additionalPayeePercentage,\\n            uint256 royaltyFeeByID\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IManifold.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev Royalty Registry interface, used to support the Royalty Registry.\\n/// @dev Source: https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/specs/IManifold.sol\\n\\n/// @author: manifold.xyz\\n\\n/**\\n * @dev Royalty interface for creator core classes\\n */\\ninterface IManifold {\\n    /**\\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\\n     *\\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\\n     *\\n     *  => 0xbb3bafd6 = 0xbb3bafd6\\n     */\\n    function getRoyalties(\\n        uint256 tokenId\\n    ) external view returns (address payable[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IMinterBaseV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV2.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface defines any events or functions required for a minter\\n * to conform to the MinterBase contract.\\n * @dev The MinterBase contract was not implemented from the beginning of the\\n * MinterSuite contract suite, therefore early versions of some minters may not\\n * conform to this interface.\\n * @author Art Blocks Inc.\\n */\\ninterface IMinterBaseV0 {\\n    // Function that returns if a minter is configured to integrate with a V3 flagship or V3 engine contract.\\n    // Returns true only if the minter is configured to integrate with an engine contract.\\n    function isEngine() external returns (bool isEngine);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IMinterFilterV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IMinterFilterV0 {\\n    /**\\n     * @notice Emitted when contract is deployed to notify indexing services\\n     * of the new contract deployment.\\n     */\\n    event Deployed();\\n\\n    /**\\n     * @notice Approved minter `_minterAddress`.\\n     */\\n    event MinterApproved(address indexed _minterAddress, string _minterType);\\n\\n    /**\\n     * @notice Revoked approval for minter `_minterAddress`\\n     */\\n    event MinterRevoked(address indexed _minterAddress);\\n\\n    /**\\n     * @notice Minter `_minterAddress` of type `_minterType`\\n     * registered for project `_projectId`.\\n     */\\n    event ProjectMinterRegistered(\\n        uint256 indexed _projectId,\\n        address indexed _minterAddress,\\n        string _minterType\\n    );\\n\\n    /**\\n     * @notice Any active minter removed for project `_projectId`.\\n     */\\n    event ProjectMinterRemoved(uint256 indexed _projectId);\\n\\n    function genArt721CoreAddress() external returns (address);\\n\\n    function setMinterForProject(uint256, address) external;\\n\\n    function removeMinterForProject(uint256) external;\\n\\n    function mint(\\n        address _to,\\n        uint256 _projectId,\\n        address sender\\n    ) external returns (uint256);\\n\\n    function getMinterForProject(uint256) external view returns (address);\\n\\n    function projectHasMinter(uint256) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/minter-suite/Minters/MinterBase_v0_1_1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"../../interfaces/v0.8.x/IMinterBaseV0.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3_Engine.sol\\\";\\n\\nimport \\\"@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Art Blocks Minter Base Class\\n * @notice A base class for Art Blocks minter contracts that provides common\\n * functionality used across minter contracts.\\n * This contract is not intended to be deployed directly, but rather to be\\n * inherited by other minter contracts.\\n * From a design perspective, this contract is intended to remain simple and\\n * easy to understand. It is not intended to cause a complex inheritance tree,\\n * and instead should keep minter contracts as readable as possible for\\n * collectors and developers.\\n * @dev Semantic versioning is used in the solidity file name, and is therefore\\n * controlled by contracts importing the appropriate filename version.\\n * @author Art Blocks Inc.\\n */\\nabstract contract MinterBase is IMinterBaseV0 {\\n    /// state variable that tracks whether this contract's associated core\\n    /// contract is an Engine contract, where Engine contracts have an\\n    /// additional revenue split for the platform provider\\n    bool public immutable isEngine;\\n\\n    // @dev we do not track an initialization state, as the only state variable\\n    // is immutable, which the compiler enforces to be assigned during\\n    // construction.\\n\\n    /**\\n     * @notice Initializes contract to ensure state variable `isEngine` is set\\n     * appropriately based on the minter's associated core contract address.\\n     * @param genArt721Address Art Blocks core contract address for\\n     * which this contract will be a minter.\\n     */\\n    constructor(address genArt721Address) {\\n        // set state variable isEngine\\n        isEngine = _getV3CoreIsEngine(genArt721Address);\\n    }\\n\\n    /**\\n     * @notice splits ETH funds between sender (if refund), providers,\\n     * artist, and artist's additional payee for a token purchased on\\n     * project `_projectId`.\\n     * WARNING: This function uses msg.value and msg.sender to determine\\n     * refund amounts, and therefore may not be applicable to all use cases\\n     * (e.g. do not use with Dutch Auctions with on-chain settlement).\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     * @param projectId Project ID for which funds shall be split.\\n     * @param pricePerTokenInWei Current price of token, in Wei.\\n     */\\n    function splitFundsETH(\\n        uint256 projectId,\\n        uint256 pricePerTokenInWei,\\n        address genArt721CoreAddress\\n    ) internal {\\n        if (msg.value > 0) {\\n            bool success_;\\n            // send refund to sender\\n            uint256 refund = msg.value - pricePerTokenInWei;\\n            if (refund > 0) {\\n                (success_, ) = msg.sender.call{value: refund}(\\\"\\\");\\n                require(success_, \\\"Refund failed\\\");\\n            }\\n            // split revenues\\n            splitRevenuesETH(\\n                projectId,\\n                pricePerTokenInWei,\\n                genArt721CoreAddress\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice splits ETH revenues between providers, artist, and artist's\\n     * additional payee for revenue generated by project `_projectId`.\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     * @param projectId Project ID for which funds shall be split.\\n     * @param valueInWei Value to be split, in Wei.\\n     */\\n    function splitRevenuesETH(\\n        uint256 projectId,\\n        uint256 valueInWei,\\n        address genArtCoreContract\\n    ) internal {\\n        if (valueInWei <= 0) {\\n            return; // return early\\n        }\\n        bool success;\\n        // split funds between platforms, artist, and artist's\\n        // additional payee\\n        uint256 renderProviderRevenue_;\\n        address payable renderProviderAddress_;\\n        uint256 artistRevenue_;\\n        address payable artistAddress_;\\n        uint256 additionalPayeePrimaryRevenue_;\\n        address payable additionalPayeePrimaryAddress_;\\n        if (isEngine) {\\n            // get engine splits\\n            uint256 platformProviderRevenue_;\\n            address payable platformProviderAddress_;\\n            (\\n                renderProviderRevenue_,\\n                renderProviderAddress_,\\n                platformProviderRevenue_,\\n                platformProviderAddress_,\\n                artistRevenue_,\\n                artistAddress_,\\n                additionalPayeePrimaryRevenue_,\\n                additionalPayeePrimaryAddress_\\n            ) = IGenArt721CoreContractV3_Engine(genArtCoreContract)\\n                .getPrimaryRevenueSplits(projectId, valueInWei);\\n            // Platform Provider payment (only possible if engine)\\n            if (platformProviderRevenue_ > 0) {\\n                (success, ) = platformProviderAddress_.call{\\n                    value: platformProviderRevenue_\\n                }(\\\"\\\");\\n                require(success, \\\"Platform Provider payment failed\\\");\\n            }\\n        } else {\\n            // get flagship splits\\n            (\\n                renderProviderRevenue_, // artblocks revenue\\n                renderProviderAddress_, // artblocks address\\n                artistRevenue_,\\n                artistAddress_,\\n                additionalPayeePrimaryRevenue_,\\n                additionalPayeePrimaryAddress_\\n            ) = IGenArt721CoreContractV3(genArtCoreContract)\\n                .getPrimaryRevenueSplits(projectId, valueInWei);\\n        }\\n        // Render Provider / Art Blocks payment\\n        if (renderProviderRevenue_ > 0) {\\n            (success, ) = renderProviderAddress_.call{\\n                value: renderProviderRevenue_\\n            }(\\\"\\\");\\n            require(success, \\\"Render Provider payment failed\\\");\\n        }\\n        // artist payment\\n        if (artistRevenue_ > 0) {\\n            (success, ) = artistAddress_.call{value: artistRevenue_}(\\\"\\\");\\n            require(success, \\\"Artist payment failed\\\");\\n        }\\n        // additional payee payment\\n        if (additionalPayeePrimaryRevenue_ > 0) {\\n            (success, ) = additionalPayeePrimaryAddress_.call{\\n                value: additionalPayeePrimaryRevenue_\\n            }(\\\"\\\");\\n            require(success, \\\"Additional Payee payment failed\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice splits ERC-20 funds between providers, artist, and artist's\\n     * additional payee, for a token purchased on project `_projectId`.\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     */\\n    function splitFundsERC20(\\n        uint256 projectId,\\n        uint256 pricePerTokenInWei,\\n        address currencyAddress,\\n        address genArtCoreContract\\n    ) internal {\\n        IERC20 _projectCurrency = IERC20(currencyAddress);\\n        // split remaining funds between foundation, artist, and artist's\\n        // additional payee\\n        uint256 renderProviderRevenue_;\\n        address payable renderProviderAddress_;\\n        uint256 artistRevenue_;\\n        address payable artistAddress_;\\n        uint256 additionalPayeePrimaryRevenue_;\\n        address payable additionalPayeePrimaryAddress_;\\n        if (isEngine) {\\n            // get engine splits\\n            uint256 platformProviderRevenue_;\\n            address payable platformProviderAddress_;\\n            (\\n                renderProviderRevenue_,\\n                renderProviderAddress_,\\n                platformProviderRevenue_,\\n                platformProviderAddress_,\\n                artistRevenue_,\\n                artistAddress_,\\n                additionalPayeePrimaryRevenue_,\\n                additionalPayeePrimaryAddress_\\n            ) = IGenArt721CoreContractV3_Engine(genArtCoreContract)\\n                .getPrimaryRevenueSplits(projectId, pricePerTokenInWei);\\n            // Platform Provider payment (only possible if engine)\\n            if (platformProviderRevenue_ > 0) {\\n                _projectCurrency.transferFrom(\\n                    msg.sender,\\n                    platformProviderAddress_,\\n                    platformProviderRevenue_\\n                );\\n            }\\n        } else {\\n            // get flagship splits\\n            (\\n                renderProviderRevenue_, // artblocks revenue\\n                renderProviderAddress_, // artblocks address\\n                artistRevenue_,\\n                artistAddress_,\\n                additionalPayeePrimaryRevenue_,\\n                additionalPayeePrimaryAddress_\\n            ) = IGenArt721CoreContractV3(genArtCoreContract)\\n                .getPrimaryRevenueSplits(projectId, pricePerTokenInWei);\\n        }\\n        // Art Blocks payment\\n        if (renderProviderRevenue_ > 0) {\\n            _projectCurrency.transferFrom(\\n                msg.sender,\\n                renderProviderAddress_,\\n                renderProviderRevenue_\\n            );\\n        }\\n        // artist payment\\n        if (artistRevenue_ > 0) {\\n            _projectCurrency.transferFrom(\\n                msg.sender,\\n                artistAddress_,\\n                artistRevenue_\\n            );\\n        }\\n        // additional payee payment\\n        if (additionalPayeePrimaryRevenue_ > 0) {\\n            _projectCurrency.transferFrom(\\n                msg.sender,\\n                additionalPayeePrimaryAddress_,\\n                additionalPayeePrimaryRevenue_\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns whether a V3 core contract is an Art Blocks Engine\\n     * contract or not. Return value of false indicates that the core is a\\n     * flagship contract.\\n     * @dev this function reverts if a core contract does not return the\\n     * expected number of return values from getPrimaryRevenueSplits() for\\n     * either a flagship or engine core contract.\\n     * @dev this function uses the length of the return data (in bytes) to\\n     * determine whether the core is an engine or not.\\n     * @param genArt721CoreV3 The address of the deployed core contract.\\n     */\\n    function _getV3CoreIsEngine(\\n        address genArt721CoreV3\\n    ) private returns (bool) {\\n        // call getPrimaryRevenueSplits() on core contract\\n        bytes memory payload = abi.encodeWithSignature(\\n            \\\"getPrimaryRevenueSplits(uint256,uint256)\\\",\\n            0,\\n            0\\n        );\\n        (bool success, bytes memory returnData) = genArt721CoreV3.call(payload);\\n        require(success, \\\"getPrimaryRevenueSplits() call failed\\\");\\n        // determine whether core is engine or not, based on return data length\\n        uint256 returnDataLength = returnData.length;\\n        if (returnDataLength == 6 * 32) {\\n            // 6 32-byte words returned if flagship (not engine)\\n            // @dev 6 32-byte words are expected because the non-engine core\\n            // contracts return a payout address and uint256 payment value for\\n            // the artist, and artist's additional payee, and Art Blocks.\\n            // also note that per Solidity ABI encoding, the address return\\n            // values are padded to 32 bytes.\\n            return false;\\n        } else if (returnDataLength == 8 * 32) {\\n            // 8 32-byte words returned if engine\\n            // @dev 8 32-byte words are expected because the engine core\\n            // contracts return a payout address and uint256 payment value for\\n            // the artist, artist's additional payee, render provider\\n            // typically Art Blocks, and platform provider (partner).\\n            // also note that per Solidity ABI encoding, the address return\\n            // values are padded to 32 bytes.\\n            return true;\\n        } else {\\n            // unexpected return value length\\n            revert(\\\"Unexpected revenue split bytes\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/minter-suite/Minters/MinterMerkleV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IMinterFilterV0.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IFilteredMinterMerkleV2.sol\\\";\\nimport \\\"../../interfaces/v0.8.x/IDelegationRegistry.sol\\\";\\nimport \\\"./MinterBase_v0_1_1.sol\\\";\\n\\nimport \\\"@openzeppelin-4.7/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport \\\"@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin-4.7/contracts/security/ReentrancyGuard.sol\\\";\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title Filtered Minter contract that allows tokens to be minted with ETH\\n * for addresses in a Merkle allowlist.\\n * This is designed to be used with GenArt721CoreContractV3 flagship or\\n * engine contracts.\\n * @author Art Blocks Inc.\\n * @notice Privileged Roles and Ownership:\\n * This contract is designed to be managed, with limited powers.\\n * Privileged roles and abilities are controlled by the project's artist, which\\n * can be modified by the core contract's Admin ACL contract. Both of these\\n * roles hold extensive power and can modify minter details.\\n * Care must be taken to ensure that the admin ACL contract and artist\\n * addresses are secure behind a multi-sig or other access control mechanism.\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted to a project's artist:\\n * - updateMerkleRoot\\n * - updatePricePerTokenInWei\\n * - setProjectInvocationsPerAddress\\n * - setProjectMaxInvocations\\n * - manuallyLimitProjectMaxInvocations\\n * ----------------------------------------------------------------------------\\n * Additional admin and artist privileged roles may be described on other\\n * contracts that this minter integrates with.\\n * ----------------------------------------------------------------------------\\n * This contract allows vaults to configure token-level or wallet-level\\n * delegation of minting privileges. This allows a vault on an allowlist to\\n * delegate minting privileges to a wallet that is not on the allowlist,\\n * enabling the vault to remain air-gapped while still allowing minting. The\\n * delegation registry contract is responsible for managing these delegations,\\n * and is available at the address returned by the public immutable\\n * `delegationRegistryAddress`. At the time of writing, the delegation\\n * registry enables easy delegation configuring at https://delegate.cash/.\\n * Art Blocks does not guarentee the security of the delegation registry, and\\n * users should take care to ensure that the delegation registry is secure.\\n * Token-level delegations are configured by the vault owner, and contract-\\n * level delegations must be configured for the core token contract as returned\\n * by the public immutable variable `genArt721CoreAddress`.\\n */\\ncontract MinterMerkleV5 is\\n    ReentrancyGuard,\\n    MinterBase,\\n    IFilteredMinterMerkleV2\\n{\\n    using MerkleProof for bytes32[];\\n\\n    /// Delegation registry address\\n    address public immutable delegationRegistryAddress;\\n\\n    /// Delegation registry address\\n    IDelegationRegistry private immutable delegationRegistryContract;\\n\\n    /// Core contract address this minter interacts with\\n    address public immutable genArt721CoreAddress;\\n\\n    /// The core contract integrates with V3 contracts\\n    IGenArt721CoreContractV3_Base private immutable genArtCoreContract_Base;\\n\\n    /// Minter filter address this minter interacts with\\n    address public immutable minterFilterAddress;\\n\\n    /// Minter filter this minter may interact with.\\n    IMinterFilterV0 private immutable minterFilter;\\n\\n    /// minterType for this minter\\n    string public constant minterType = \\\"MinterMerkleV5\\\";\\n\\n    /// minter version for this minter\\n    string public constant minterVersion = \\\"v5.1.0\\\";\\n\\n    /// project minter configuration keys used by this minter\\n    bytes32 private constant CONFIG_MERKLE_ROOT = \\\"merkleRoot\\\";\\n    bytes32 private constant CONFIG_USE_MAX_INVOCATIONS_PER_ADDRESS_OVERRIDE =\\n        \\\"useMaxMintsPerAddrOverride\\\"; // shortened to fit in 32 bytes\\n    bytes32 private constant CONFIG_MAX_INVOCATIONS_OVERRIDE =\\n        \\\"maxMintsPerAddrOverride\\\"; // shortened to match format of previous key\\n\\n    uint256 constant ONE_MILLION = 1_000_000;\\n\\n    uint256 public constant DEFAULT_MAX_INVOCATIONS_PER_ADDRESS = 1;\\n\\n    struct ProjectConfig {\\n        bool maxHasBeenInvoked;\\n        bool priceIsConfigured;\\n        // initial value is false, so by default, projects limit allowlisted\\n        // addresses to a mint qty of `DEFAULT_MAX_INVOCATIONS_PER_ADDRESS`\\n        bool useMaxInvocationsPerAddressOverride;\\n        // a value of 0 means no limit\\n        // (only used if `useMaxInvocationsPerAddressOverride` is true)\\n        uint24 maxInvocationsPerAddressOverride;\\n        uint24 maxInvocations;\\n        uint256 pricePerTokenInWei;\\n    }\\n\\n    mapping(uint256 => ProjectConfig) public projectConfig;\\n\\n    /// projectId => merkle root\\n    mapping(uint256 => bytes32) public projectMerkleRoot;\\n\\n    /// projectId => purchaser address => qty of mints purchased for project\\n    mapping(uint256 => mapping(address => uint256))\\n        public projectUserMintInvocations;\\n\\n    function _onlyArtist(uint256 _projectId) internal view {\\n        require(\\n            msg.sender ==\\n                genArtCoreContract_Base.projectIdToArtistAddress(_projectId),\\n            \\\"Only Artist\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Initializes contract to be a Filtered Minter for\\n     * `_minterFilter`, integrated with Art Blocks core contract\\n     * at address `_genArt721Address`. Also configures the delegation\\n     * registry address to be address `_delegationRegistryAddress`.\\n     * @param _genArt721Address Art Blocks core contract address for\\n     * which this contract will be a minter.\\n     * @param _minterFilter Minter filter for which this will be a\\n     * filtered minter.\\n     * @param _delegationRegistryAddress Delegation registry contract address.\\n     */\\n    constructor(\\n        address _genArt721Address,\\n        address _minterFilter,\\n        address _delegationRegistryAddress\\n    ) ReentrancyGuard() MinterBase(_genArt721Address) {\\n        genArt721CoreAddress = _genArt721Address;\\n        // always populate immutable engine contracts, but only use appropriate\\n        // interface based on isEngine in the rest of the contract\\n        genArtCoreContract_Base = IGenArt721CoreContractV3_Base(\\n            _genArt721Address\\n        );\\n        delegationRegistryAddress = _delegationRegistryAddress;\\n        emit DelegationRegistryUpdated(_delegationRegistryAddress);\\n        delegationRegistryContract = IDelegationRegistry(\\n            _delegationRegistryAddress\\n        );\\n        minterFilterAddress = _minterFilter;\\n        minterFilter = IMinterFilterV0(_minterFilter);\\n        require(\\n            minterFilter.genArt721CoreAddress() == _genArt721Address,\\n            \\\"Illegal contract pairing\\\"\\n        );\\n        // broadcast default max invocations per address for this minter\\n        emit DefaultMaxInvocationsPerAddress(\\n            DEFAULT_MAX_INVOCATIONS_PER_ADDRESS\\n        );\\n    }\\n\\n    /**\\n     * @notice Update the Merkle root for project `_projectId`.\\n     * @param _projectId Project ID to be updated.\\n     * @param _root root of Merkle tree defining addresses allowed to mint\\n     * on project `_projectId`.\\n     */\\n    function updateMerkleRoot(uint256 _projectId, bytes32 _root) external {\\n        _onlyArtist(_projectId);\\n        require(_root != bytes32(0), \\\"Root must be provided\\\");\\n        projectMerkleRoot[_projectId] = _root;\\n        emit ConfigValueSet(_projectId, CONFIG_MERKLE_ROOT, _root);\\n    }\\n\\n    /**\\n     * @notice Returns hashed address (to be used as merkle tree leaf).\\n     * Included as a public function to enable users to calculate their hashed\\n     * address in Solidity when generating proofs off-chain.\\n     * @param _address address to be hashed\\n     * @return bytes32 hashed address, via keccak256 (using encodePacked)\\n     */\\n    function hashAddress(address _address) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_address));\\n    }\\n\\n    /**\\n     * @notice Verify if address is allowed to mint on project `_projectId`.\\n     * @param _projectId Project ID to be checked.\\n     * @param _proof Merkle proof for address.\\n     * @param _address Address to check.\\n     * @return inAllowlist true only if address is allowed to mint and valid\\n     * Merkle proof was provided\\n     */\\n    function verifyAddress(\\n        uint256 _projectId,\\n        bytes32[] calldata _proof,\\n        address _address\\n    ) public view returns (bool) {\\n        return\\n            _proof.verifyCalldata(\\n                projectMerkleRoot[_projectId],\\n                hashAddress(_address)\\n            );\\n    }\\n\\n    /**\\n     * @notice Sets maximum allowed invocations per allowlisted address for\\n     * project `_project` to `limit`. If `limit` is set to 0, allowlisted\\n     * addresses will be able to mint as many times as desired, until the\\n     * project reaches its maximum invocations.\\n     * Default is a value of 1 if never configured by artist.\\n     * @param _projectId Project ID to toggle the mint limit.\\n     * @param _maxInvocationsPerAddress Maximum allowed invocations per\\n     * allowlisted address.\\n     * @dev default value stated above must be updated if the value of\\n     * CONFIG_USE_MAX_INVOCATIONS_PER_ADDRESS_OVERRIDE is changed.\\n     */\\n    function setProjectInvocationsPerAddress(\\n        uint256 _projectId,\\n        uint24 _maxInvocationsPerAddress\\n    ) external {\\n        _onlyArtist(_projectId);\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        // use override value instead of the contract's default\\n        // @dev this never changes from true to false; default value is only\\n        // used if artist has never configured project invocations per address\\n        _projectConfig.useMaxInvocationsPerAddressOverride = true;\\n        // update the override value\\n        _projectConfig\\n            .maxInvocationsPerAddressOverride = _maxInvocationsPerAddress;\\n        // generic events\\n        emit ConfigValueSet(\\n            _projectId,\\n            CONFIG_USE_MAX_INVOCATIONS_PER_ADDRESS_OVERRIDE,\\n            true\\n        );\\n        emit ConfigValueSet(\\n            _projectId,\\n            CONFIG_MAX_INVOCATIONS_OVERRIDE,\\n            uint256(_maxInvocationsPerAddress)\\n        );\\n    }\\n\\n    /**\\n     * @notice Syncs local maximum invocations of project `_projectId` based on\\n     * the value currently defined in the core contract.\\n     * @param _projectId Project ID to set the maximum invocations for.\\n     * @dev this enables gas reduction after maxInvocations have been reached -\\n     * core contracts shall still enforce a maxInvocation check during mint.\\n     */\\n    function setProjectMaxInvocations(uint256 _projectId) public {\\n        _onlyArtist(_projectId);\\n        uint256 maxInvocations;\\n        uint256 invocations;\\n        (invocations, maxInvocations, , , , ) = genArtCoreContract_Base\\n            .projectStateData(_projectId);\\n        // update storage with results\\n        projectConfig[_projectId].maxInvocations = uint24(maxInvocations);\\n\\n        // We need to ensure maxHasBeenInvoked is correctly set after manually syncing the\\n        // local maxInvocations value with the core contract's maxInvocations value.\\n        // This synced value of maxInvocations from the core contract will always be greater\\n        // than or equal to the previous value of maxInvocations stored locally.\\n        projectConfig[_projectId].maxHasBeenInvoked =\\n            invocations == maxInvocations;\\n\\n        emit ProjectMaxInvocationsLimitUpdated(_projectId, maxInvocations);\\n    }\\n\\n    /**\\n     * @notice Manually sets the local maximum invocations of project `_projectId`\\n     * with the provided `_maxInvocations`, checking that `_maxInvocations` is less\\n     * than or equal to the value of project `_project_id`'s maximum invocations that is\\n     * set on the core contract.\\n     * @dev Note that a `_maxInvocations` of 0 can only be set if the current `invocations`\\n     * value is also 0 and this would also set `maxHasBeenInvoked` to true, correctly short-circuiting\\n     * this minter's purchase function, avoiding extra gas costs from the core contract's maxInvocations check.\\n     * @param _projectId Project ID to set the maximum invocations for.\\n     * @param _maxInvocations Maximum invocations to set for the project.\\n     */\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 _projectId,\\n        uint256 _maxInvocations\\n    ) external {\\n        _onlyArtist(_projectId);\\n        // CHECKS\\n        // ensure that the manually set maxInvocations is not greater than what is set on the core contract\\n        uint256 maxInvocations;\\n        uint256 invocations;\\n        (invocations, maxInvocations, , , , ) = genArtCoreContract_Base\\n            .projectStateData(_projectId);\\n        require(\\n            _maxInvocations <= maxInvocations,\\n            \\\"Cannot increase project max invocations above core contract set project max invocations\\\"\\n        );\\n        require(\\n            _maxInvocations >= invocations,\\n            \\\"Cannot set project max invocations to less than current invocations\\\"\\n        );\\n\\n        // EFFECTS\\n        // update storage with results\\n        projectConfig[_projectId].maxInvocations = uint24(_maxInvocations);\\n        // We need to ensure maxHasBeenInvoked is correctly set after manually setting the\\n        // local maxInvocations value.\\n        projectConfig[_projectId].maxHasBeenInvoked =\\n            invocations == _maxInvocations;\\n\\n        emit ProjectMaxInvocationsLimitUpdated(_projectId, _maxInvocations);\\n    }\\n\\n    /**\\n     * @notice Warning: Disabling purchaseTo is not supported on this minter.\\n     * This method exists purely for interface-conformance purposes.\\n     */\\n    function togglePurchaseToDisabled(uint256 _projectId) external view {\\n        _onlyArtist(_projectId);\\n        revert(\\\"Action not supported\\\");\\n    }\\n\\n    /**\\n     * @notice projectId => has project reached its maximum number of\\n     * invocations? Note that this returns a local cache of the core contract's\\n     * state, and may be out of sync with the core contract. This is\\n     * intentional, as it only enables gas optimization of mints after a\\n     * project's maximum invocations has been reached. A false negative will\\n     * only result in a gas cost increase, since the core contract will still\\n     * enforce a maxInvocation check during minting. A false positive is not\\n     * possible because the V3 core contract only allows maximum invocations\\n     * to be reduced, not increased. Based on this rationale, we intentionally\\n     * do not do input validation in this method as to whether or not the input\\n     * `_projectId` is an existing project ID.\\n     */\\n    function projectMaxHasBeenInvoked(\\n        uint256 _projectId\\n    ) external view returns (bool) {\\n        return projectConfig[_projectId].maxHasBeenInvoked;\\n    }\\n\\n    /**\\n     * @notice projectId => project's maximum number of invocations.\\n     * Optionally synced with core contract value, for gas optimization.\\n     * Note that this returns a local cache of the core contract's\\n     * state, and may be out of sync with the core contract. This is\\n     * intentional, as it only enables gas optimization of mints after a\\n     * project's maximum invocations has been reached.\\n     * @dev A number greater than the core contract's project max invocations\\n     * will only result in a gas cost increase, since the core contract will\\n     * still enforce a maxInvocation check during minting. A number less than\\n     * the core contract's project max invocations is only possible when the\\n     * project's max invocations have not been synced on this minter, since the\\n     * V3 core contract only allows maximum invocations to be reduced, not\\n     * increased. When this happens, the minter will enable minting, allowing\\n     * the core contract to enforce the max invocations check. Based on this\\n     * rationale, we intentionally do not do input validation in this method as\\n     * to whether or not the input `_projectId` is an existing project ID.\\n     */\\n    function projectMaxInvocations(\\n        uint256 _projectId\\n    ) external view returns (uint256) {\\n        return uint256(projectConfig[_projectId].maxInvocations);\\n    }\\n\\n    /**\\n     * @notice Updates this minter's price per token of project `_projectId`\\n     * to be '_pricePerTokenInWei`, in Wei.\\n     * This price supersedes any legacy core contract price per token value.\\n     * @dev Note that it is intentionally supported here that the configured\\n     * price may be explicitly set to `0`.\\n     */\\n    function updatePricePerTokenInWei(\\n        uint256 _projectId,\\n        uint256 _pricePerTokenInWei\\n    ) external {\\n        _onlyArtist(_projectId);\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        _projectConfig.pricePerTokenInWei = _pricePerTokenInWei;\\n        _projectConfig.priceIsConfigured = true;\\n        emit PricePerTokenInWeiUpdated(_projectId, _pricePerTokenInWei);\\n\\n        // sync local max invocations if not initially populated\\n        // @dev if local max invocations and maxHasBeenInvoked are both\\n        // initial values, we know they have not been populated.\\n        if (\\n            _projectConfig.maxInvocations == 0 &&\\n            _projectConfig.maxHasBeenInvoked == false\\n        ) {\\n            setProjectMaxInvocations(_projectId);\\n        }\\n    }\\n\\n    /**\\n     * @notice Inactive function - requires Merkle proof to purchase.\\n     */\\n    function purchase(uint256) external payable returns (uint256) {\\n        revert(\\\"Must provide Merkle proof\\\");\\n    }\\n\\n    /**\\n     * @notice Inactive function - requires Merkle proof to purchase.\\n     */\\n    function purchaseTo(address, uint256) public payable returns (uint256) {\\n        revert(\\\"Must provide Merkle proof\\\");\\n    }\\n\\n    /**\\n     * @notice Purchases a token from project `_projectId`.\\n     * @param _projectId Project ID to mint a token on.\\n     * @param _proof Merkle proof.\\n     * @return tokenId Token ID of minted token\\n     */\\n    function purchase(\\n        uint256 _projectId,\\n        bytes32[] calldata _proof\\n    ) external payable returns (uint256 tokenId) {\\n        tokenId = purchaseTo_kem(msg.sender, _projectId, _proof, address(0));\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice gas-optimized version of purchase(uint256,bytes32[]).\\n     */\\n    function purchase_gD5(\\n        uint256 _projectId,\\n        bytes32[] calldata _proof\\n    ) external payable returns (uint256 tokenId) {\\n        tokenId = purchaseTo_kem(msg.sender, _projectId, _proof, address(0));\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice Purchases a token from project `_projectId` and sets\\n     * the token's owner to `_to`.\\n     * @param _to Address to be the new token's owner.\\n     * @param _projectId Project ID to mint a token on.\\n     * @param _proof Merkle proof.\\n     * @return tokenId Token ID of minted token\\n     */\\n    function purchaseTo(\\n        address _to,\\n        uint256 _projectId,\\n        bytes32[] calldata _proof\\n    ) external payable returns (uint256 tokenId) {\\n        return purchaseTo_kem(_to, _projectId, _proof, address(0));\\n    }\\n\\n    /**\\n     * @notice Purchases a token from project `_projectId` and sets\\n     *         the token's owner to `_to`, as a delegate, (the `msg.sender`)\\n     *         on behalf of an explicitly defined vault.\\n     * @param _to Address to be the new token's owner.\\n     * @param _projectId Project ID to mint a token on.\\n     * @param _proof Merkle proof.\\n     * @param _vault Vault being purchased on behalf of.\\n     * @return tokenId Token ID of minted token\\n     */\\n    function purchaseTo(\\n        address _to,\\n        uint256 _projectId,\\n        bytes32[] calldata _proof,\\n        address _vault\\n    ) external payable returns (uint256 tokenId) {\\n        return purchaseTo_kem(_to, _projectId, _proof, _vault);\\n    }\\n\\n    /**\\n     * @notice gas-optimized version of\\n     * purchaseTo(address,uint256,bytes32[],address).\\n     * @param _to Address to be the new token's owner.\\n     * @param _projectId Project ID to mint a token on.\\n     * @param _proof Merkle proof. Must be a valid proof of either `msg.sender`\\n     * if `_vault` is `address(0)`, or `_vault` if `_vault` is not `address(0)`.\\n     * @param _vault Vault being purchased on behalf of. Acceptable to be\\n     * address(0) if no vault.\\n     */\\n    function purchaseTo_kem(\\n        address _to,\\n        uint256 _projectId,\\n        bytes32[] calldata _proof,\\n        address _vault // acceptable to be `address(0)` if no vault\\n    ) public payable nonReentrant returns (uint256 tokenId) {\\n        // CHECKS\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n\\n        // Note that `maxHasBeenInvoked` is only checked here to reduce gas\\n        // consumption after a project has been fully minted.\\n        // `_projectConfig.maxHasBeenInvoked` is locally cached to reduce\\n        // gas consumption, but if not in sync with the core contract's value,\\n        // the core contract also enforces its own max invocation check during\\n        // minting.\\n        require(\\n            !_projectConfig.maxHasBeenInvoked,\\n            \\\"Maximum number of invocations reached\\\"\\n        );\\n\\n        // load price of token into memory\\n        uint256 pricePerTokenInWei = _projectConfig.pricePerTokenInWei;\\n\\n        require(\\n            msg.value >= pricePerTokenInWei,\\n            \\\"Must send minimum value to mint!\\\"\\n        );\\n\\n        // require artist to have configured price of token on this minter\\n        require(_projectConfig.priceIsConfigured, \\\"Price not configured\\\");\\n\\n        // no contract filter since Merkle tree controls allowed addresses\\n\\n        // NOTE: delegate-vault handling **begins here**.\\n\\n        // handle that the vault may be either the `msg.sender` in the case\\n        // that there is not a true vault, or may be `_vault` if one is\\n        // provided explicitly (and it is valid).\\n        address vault = msg.sender;\\n        if (_vault != address(0)) {\\n            // If a vault is provided, it must be valid, otherwise throw rather\\n            // than optimistically-minting with original `msg.sender`.\\n            // Note, we do not check `checkDelegateForAll` as well, as it is known\\n            // to be implicitly checked by calling `checkDelegateForContract`.\\n            bool isValidDelegee = delegationRegistryContract\\n                .checkDelegateForContract(\\n                    msg.sender, // delegate\\n                    _vault, // vault\\n                    genArt721CoreAddress // contract\\n                );\\n            require(isValidDelegee, \\\"Invalid delegate-vault pairing\\\");\\n            vault = _vault;\\n        }\\n\\n        // require valid Merkle proof\\n        require(\\n            verifyAddress(_projectId, _proof, vault),\\n            \\\"Invalid Merkle proof\\\"\\n        );\\n\\n        // limit mints per address by project\\n        uint256 _maxProjectInvocationsPerAddress = _projectConfig\\n            .useMaxInvocationsPerAddressOverride\\n            ? _projectConfig.maxInvocationsPerAddressOverride\\n            : DEFAULT_MAX_INVOCATIONS_PER_ADDRESS;\\n\\n        // note that mint limits index off of the `vault` (when applicable)\\n        require(\\n            projectUserMintInvocations[_projectId][vault] <\\n                _maxProjectInvocationsPerAddress ||\\n                _maxProjectInvocationsPerAddress == 0,\\n            \\\"Maximum number of invocations per address reached\\\"\\n        );\\n\\n        // EFFECTS\\n        // increment user's invocations for this project\\n        unchecked {\\n            // this will never overflow since user's invocations on a project\\n            // are limited by the project's max invocations\\n            projectUserMintInvocations[_projectId][vault]++;\\n        }\\n\\n        // mint token\\n        tokenId = minterFilter.mint(_to, _projectId, vault);\\n\\n        // NOTE: delegate-vault handling **ends here**.\\n\\n        // invocation is token number plus one, and will never overflow due to\\n        // limit of 1e6 invocations per project. block scope for gas efficiency\\n        // (i.e. avoid an unnecessary var initialization to 0).\\n        unchecked {\\n            uint256 tokenInvocation = (tokenId % ONE_MILLION) + 1;\\n            uint256 localMaxInvocations = _projectConfig.maxInvocations;\\n            // handle the case where the token invocation == minter local max\\n            // invocations occurred on a different minter, and we have a stale\\n            // local maxHasBeenInvoked value returning a false negative.\\n            // @dev this is a CHECK after EFFECTS, so security was considered\\n            // in detail here.\\n            require(\\n                tokenInvocation <= localMaxInvocations,\\n                \\\"Maximum invocations reached\\\"\\n            );\\n            // in typical case, update the local maxHasBeenInvoked value\\n            // to true if the token invocation == minter local max invocations\\n            // (enables gas efficient reverts after sellout)\\n            if (tokenInvocation == localMaxInvocations) {\\n                _projectConfig.maxHasBeenInvoked = true;\\n            }\\n        }\\n\\n        // INTERACTIONS\\n        splitFundsETH(_projectId, pricePerTokenInWei, genArt721CoreAddress);\\n\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice projectId => maximum invocations per allowlisted address. If a\\n     * a value of 0 is returned, there is no limit on the number of mints per\\n     * allowlisted address.\\n     * Default behavior is limit 1 mint per address.\\n     * This value can be changed at any time by the artist.\\n     * @dev default value stated above must be updated if the value of\\n     * CONFIG_USE_MAX_INVOCATIONS_PER_ADDRESS_OVERRIDE is changed.\\n     */\\n    function projectMaxInvocationsPerAddress(\\n        uint256 _projectId\\n    ) public view returns (uint256) {\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        if (_projectConfig.useMaxInvocationsPerAddressOverride) {\\n            return uint256(_projectConfig.maxInvocationsPerAddressOverride);\\n        } else {\\n            return DEFAULT_MAX_INVOCATIONS_PER_ADDRESS;\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns remaining invocations for a given address.\\n     * If `projectLimitsMintInvocationsPerAddress` is false, individual\\n     * addresses are only limited by the project's maximum invocations, and a\\n     * dummy value of zero is returned for `mintInvocationsRemaining`.\\n     * If `projectLimitsMintInvocationsPerAddress` is true, the quantity of\\n     * remaining mint invocations for address `_address` is returned as\\n     * `mintInvocationsRemaining`.\\n     * Note that mint invocations per address can be changed at any time by the\\n     * artist of a project.\\n     * Also note that all mint invocations are limited by a project's maximum\\n     * invocations as defined on the core contract. This function may return\\n     * a value greater than the project's remaining invocations.\\n     */\\n    function projectRemainingInvocationsForAddress(\\n        uint256 _projectId,\\n        address _address\\n    )\\n        external\\n        view\\n        returns (\\n            bool projectLimitsMintInvocationsPerAddress,\\n            uint256 mintInvocationsRemaining\\n        )\\n    {\\n        uint256 maxInvocationsPerAddress = projectMaxInvocationsPerAddress(\\n            _projectId\\n        );\\n        if (maxInvocationsPerAddress == 0) {\\n            // project does not limit mint invocations per address, so leave\\n            // `projectLimitsMintInvocationsPerAddress` at solidity initial\\n            // value of false. Also leave `mintInvocationsRemaining` at\\n            // solidity initial value of zero, as indicated in this function's\\n            // documentation.\\n        } else {\\n            projectLimitsMintInvocationsPerAddress = true;\\n            uint256 userMintInvocations = projectUserMintInvocations[\\n                _projectId\\n            ][_address];\\n            // if user has not reached max invocations per address, return\\n            // remaining invocations\\n            if (maxInvocationsPerAddress > userMintInvocations) {\\n                unchecked {\\n                    // will never underflow due to the check above\\n                    mintInvocationsRemaining =\\n                        maxInvocationsPerAddress -\\n                        userMintInvocations;\\n                }\\n            }\\n            // else user has reached their maximum invocations, so leave\\n            // `mintInvocationsRemaining` at solidity initial value of zero\\n        }\\n    }\\n\\n    /**\\n     * @notice Process proof for an address. Returns Merkle root. Included to\\n     * enable users to easily verify a proof's validity.\\n     * @param _proof Merkle proof for address.\\n     * @param _address Address to process.\\n     * @return merkleRoot Merkle root for `_address` and `_proof`\\n     */\\n    function processProofForAddress(\\n        bytes32[] calldata _proof,\\n        address _address\\n    ) external pure returns (bytes32) {\\n        return _proof.processProofCalldata(hashAddress(_address));\\n    }\\n\\n    /**\\n     * @notice Gets if price of token is configured, price of minting a\\n     * token on project `_projectId`, and currency symbol and address to be\\n     * used as payment. Supersedes any core contract price information.\\n     * @param _projectId Project ID to get price information for.\\n     * @return isConfigured true only if token price has been configured on\\n     * this minter\\n     * @return tokenPriceInWei current price of token on this minter - invalid\\n     * if price has not yet been configured\\n     * @return currencySymbol currency symbol for purchases of project on this\\n     * minter. This minter always returns \\\"ETH\\\"\\n     * @return currencyAddress currency address for purchases of project on\\n     * this minter. This minter always returns null address, reserved for ether\\n     */\\n    function getPriceInfo(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        )\\n    {\\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\\n        isConfigured = _projectConfig.priceIsConfigured;\\n        tokenPriceInWei = _projectConfig.pricePerTokenInWei;\\n        currencySymbol = \\\"ETH\\\";\\n        currencyAddress = address(0);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 25\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_genArt721Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minterFilter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_delegationRegistryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"ConfigKeyRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ConfigValueAddedToSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"ConfigValueAddedToSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"ConfigValueAddedToSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ConfigValueRemovedFromSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"ConfigValueRemovedFromSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"ConfigValueRemovedFromSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"ConfigValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ConfigValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"ConfigValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_value\",\"type\":\"bytes32\"}],\"name\":\"ConfigValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"defaultMaxInvocationsPerAddress\",\"type\":\"uint256\"}],\"name\":\"DefaultMaxInvocationsPerAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegationRegistryAddress\",\"type\":\"address\"}],\"name\":\"DelegationRegistryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_pricePerTokenInWei\",\"type\":\"uint256\"}],\"name\":\"PricePerTokenInWeiUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_currencyAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_currencySymbol\",\"type\":\"string\"}],\"name\":\"ProjectCurrencyInfoUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maxInvocations\",\"type\":\"uint256\"}],\"name\":\"ProjectMaxInvocationsLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_purchaseToDisabled\",\"type\":\"bool\"}],\"name\":\"PurchaseToDisabledUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_MAX_INVOCATIONS_PER_ADDRESS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delegationRegistryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genArt721CoreAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"getPriceInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isConfigured\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenPriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"currencySymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"hashAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEngine\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxInvocations\",\"type\":\"uint256\"}],\"name\":\"manuallyLimitProjectMaxInvocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterFilterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"processProofForAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projectConfig\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"maxHasBeenInvoked\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"priceIsConfigured\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useMaxInvocationsPerAddressOverride\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"maxInvocationsPerAddressOverride\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"maxInvocations\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"pricePerTokenInWei\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"projectMaxHasBeenInvoked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"projectMaxInvocations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"projectMaxInvocationsPerAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projectMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"projectRemainingInvocationsForAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"projectLimitsMintInvocationsPerAddress\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"mintInvocationsRemaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"projectUserMintInvocations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"purchaseTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"purchaseTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"purchaseTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"purchaseTo_kem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"purchase_gD5\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"_maxInvocationsPerAddress\",\"type\":\"uint24\"}],\"name\":\"setProjectInvocationsPerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"setProjectMaxInvocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"togglePurchaseToDisabled\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"updateMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pricePerTokenInWei\",\"type\":\"uint256\"}],\"name\":\"updatePricePerTokenInWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"verifyAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MinterMerkleV5", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "25", "ConstructorArguments": "00000000000000000000000084f12b499f050cb612403c75d9f2777a5995fe17000000000000000000000000b96eaa691bf27d659eb134230ca8262baf9f9d3c00000000000000000000000000000000000076a84fef008cdabe6409d2fe638b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}