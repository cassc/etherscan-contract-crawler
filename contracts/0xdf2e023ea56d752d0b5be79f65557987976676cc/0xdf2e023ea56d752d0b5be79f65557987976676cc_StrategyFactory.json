{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/strategies/StrategyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\\n\\nimport {AuthorityControl} from '@floor/authorities/AuthorityControl.sol';\\nimport {CannotSetNullAddress, CollectionNotApproved, StrategyNotApproved} from '@floor/utils/Errors.sol';\\n\\nimport {ICollectionRegistry} from '@floor-interfaces/collections/CollectionRegistry.sol';\\nimport {IBaseStrategy} from '@floor-interfaces/strategies/BaseStrategy.sol';\\nimport {IStrategyFactory} from '@floor-interfaces/strategies/StrategyFactory.sol';\\nimport {IStrategyRegistry} from '@floor-interfaces/strategies/StrategyRegistry.sol';\\nimport {ITreasury} from '@floor-interfaces/Treasury.sol';\\n\\n// No empty names, that's just silly\\nerror StrategyNameCannotBeEmpty();\\n\\n/**\\n * Allows for strategies to be created, pairing them with an approved collection. The strategy\\n * creation script needs to be as highly optimised as possible to ensure that the gas\\n * costs are kept down.\\n *\\n * This factory will keep an index of created strategies and secondary information to ensure\\n * that external applications can display and maintain a list of available strategies.\\n */\\ncontract StrategyFactory is AuthorityControl, IStrategyFactory {\\n    /// Maintains an array of all strategies created\\n    address[] private _strategies;\\n\\n    /// Store our Treasury address\\n    address public treasury;\\n\\n    /// Contract mappings to our approved collections\\n    ICollectionRegistry public immutable collectionRegistry;\\n\\n    /// Contract mappings to our approved strategy implementations\\n    IStrategyRegistry public immutable strategyRegistry;\\n\\n    /// Mappings to aide is discoverability\\n    mapping(uint => address) private _strategyIds;\\n\\n    /// Mapping of collection to strategy addresses\\n    mapping(address => address[]) private _collectionStrategies;\\n\\n    /// Stores a list of bypassed strategies\\n    mapping(address => bool) private _bypassStrategy;\\n\\n    /**\\n     * Store our registries, mapped to their interfaces.\\n     *\\n     * @param _authority {AuthorityRegistry} contract address\\n     * @param _collectionRegistry Address of our {CollectionRegistry}\\n     */\\n    constructor(address _authority, address _collectionRegistry, address _strategyRegistry) AuthorityControl(_authority) {\\n        if (_collectionRegistry == address(0)) revert CannotSetNullAddress();\\n        if (_strategyRegistry == address(0)) revert CannotSetNullAddress();\\n\\n        // Type-cast our interfaces and store our registry contracts\\n        collectionRegistry = ICollectionRegistry(_collectionRegistry);\\n        strategyRegistry = IStrategyRegistry(_strategyRegistry);\\n    }\\n\\n    /**\\n     * Provides a list of all strategies created.\\n     *\\n     * @return Array of all strategies created by the {StrategyFactory}\\n     */\\n    function strategies() external view returns (address[] memory) {\\n        return _strategies;\\n    }\\n\\n    /**\\n     * Returns an array of all strategies that belong to a specific collection.\\n     *\\n     * @param _collection The address of the collection to query\\n     *\\n     * @return address[] Array of strategy addresses\\n     */\\n    function collectionStrategies(address _collection) external view returns (address[] memory) {\\n        return _collectionStrategies[_collection];\\n    }\\n\\n    /**\\n     * Provides a strategy against the provided `strategyId` (index). If the index does not exist,\\n     * then address(0) will be returned.\\n     *\\n     * @param _strategyId ID of the strategy to retrieve\\n     *\\n     * @return Address of the strategy\\n     */\\n    function strategy(uint _strategyId) external view returns (address) {\\n        return _strategyIds[_strategyId];\\n    }\\n\\n    /**\\n     * Creates a strategy with an approved collection.\\n     *\\n     * @dev The strategy is not created using Clones as there are complications when\\n     * allocated roles and permissions.\\n     *\\n     * @param _name Human-readable name of the strategy\\n     * @param _strategy The strategy implemented by the strategy\\n     * @param _strategyInitData Bytes data required by the {Strategy} for initialization\\n     * @param _collection The address of the collection attached to the strategy\\n     *\\n     * @return strategyId_ ID of the newly created strategy\\n     * @return strategyAddr_ Address of the newly created strategy\\n     */\\n    function deployStrategy(bytes32 _name, address _strategy, bytes calldata _strategyInitData, address _collection)\\n        external\\n        onlyRole(STRATEGY_MANAGER)\\n        returns (uint strategyId_, address strategyAddr_)\\n    {\\n        // No empty names, that's just silly\\n        if (_name == '') revert StrategyNameCannotBeEmpty();\\n\\n        // Make sure the strategy implementation is approved\\n        if (!strategyRegistry.isApproved(_strategy)) revert StrategyNotApproved(_strategy);\\n\\n        // Make sure the collection is approved\\n        if (!collectionRegistry.isApproved(_collection)) revert CollectionNotApproved(_collection);\\n\\n        // Capture our `strategyId`, before we increment the array length\\n        strategyId_ = _strategies.length;\\n\\n        // Deploy a new {Strategy} instance using the clone mechanic\\n        strategyAddr_ = Clones.cloneDeterministic(_strategy, bytes32(strategyId_));\\n\\n        // We then need to instantiate the strategy using our supplied `strategyInitData`\\n        IBaseStrategy(strategyAddr_).initialize(_name, strategyId_, _strategyInitData);\\n\\n        // Add our strategies to our internal tracking\\n        _strategies.push(strategyAddr_);\\n\\n        // Add our mappings for onchain discoverability\\n        _strategyIds[strategyId_] = strategyAddr_;\\n        _collectionStrategies[_collection].push(strategyAddr_);\\n\\n        // Finally we can emit our event to notify watchers of a new strategy\\n        emit StrategyCreated(strategyId_, strategyAddr_, _collection);\\n    }\\n\\n    /**\\n     * Allows individual strategies to be paused, meaning that assets can no longer be deposited,\\n     * although staked assets can always be withdrawn.\\n     *\\n     * @dev Events are fired within the strategy to allow listeners to update.\\n     *\\n     * @param _strategyId strategy ID to be updated\\n     * @param _paused If the strategy should be paused or unpaused\\n     */\\n    function pause(uint _strategyId, bool _paused) public onlyRole(STRATEGY_MANAGER) {\\n        IBaseStrategy(_strategyIds[_strategyId]).pause(_paused);\\n    }\\n\\n    /**\\n     * Reads the yield generated by all strategies since the last time that this\\n     * function was called.\\n     */\\n    function snapshot(uint _epoch)\\n        external\\n        onlyRole(STRATEGY_MANAGER)\\n        returns (address[] memory strategies_, uint[] memory amounts_, uint totalAmount_)\\n    {\\n        // Get our underlying WETH address\\n        address weth = address(ITreasury(treasury).weth());\\n\\n        // Prefine some variables\\n        address[] memory tokens;\\n        uint[] memory amounts;\\n        uint tokensLength;\\n\\n        // Get the number of strategies and define our returned array lengths\\n        uint strategiesLength = _strategies.length;\\n        strategies_ = new address[](strategiesLength);\\n        amounts_ = new uint[](strategiesLength);\\n\\n        // Iterate over strategies to pull out yield\\n        for (uint i; i < strategiesLength;) {\\n            // Prevent a bypassed strategy from snapshotting\\n            if (!_bypassStrategy[_strategies[i]]) {\\n                // Snapshot our strategy\\n                (tokens, amounts) = IBaseStrategy(_strategies[i]).snapshot();\\n\\n                // Capture the strategy address, even if we receive no WETH yield\\n                strategies_[i] = _strategies[i];\\n\\n                // Iterate over tokens to just find WETH amounts\\n                tokensLength = tokens.length;\\n                for (uint l; l < tokensLength;) {\\n                    // Ensure that we only handle WETH tokens with amounts\\n                    if (tokens[l] == address(weth) && amounts[l] != 0) {\\n                        // Capture the WETH yield relative to the strategy\\n                        amounts_[i] = amounts[l];\\n\\n                        // Keep a tally of the total amount of WETH earned\\n                        totalAmount_ += amounts[l];\\n                    }\\n\\n                    unchecked { ++l; }\\n                }\\n            }\\n\\n            unchecked { ++i; }\\n        }\\n\\n        emit StrategySnapshot(_epoch, strategies_, amounts_);\\n    }\\n\\n    /**\\n     * Harvest available reward yield from the strategy. This won't affect the amount\\n     * depositted into the contract and should only harvest rewards directly into the\\n     * {Treasury}.\\n     *\\n     * @param _strategyId Strategy ID to be harvested\\n     */\\n    function harvest(uint _strategyId) external onlyRole(STRATEGY_MANAGER) {\\n        if (_bypassStrategy[_strategyIds[_strategyId]]) return;\\n\\n        IBaseStrategy(_strategyIds[_strategyId]).harvest(treasury);\\n    }\\n\\n    /**\\n     * Makes a call to a strategy withdraw function by passing the strategy ID and\\n     * `abi.encodeWithSelector` to build the bytes `_data` parameter. This will then\\n     * pass the data on to the strategy function and inject the treasury recipient\\n     * address within the call as the first function parameter.\\n     *\\n     * @dev It is required for the transaction to return a successful call, otherwise\\n     * the transaction will be reverted. The error response will be standardised so\\n     * debugging will require a trace, rather than just the end message.\\n     *\\n     * @param _strategyId Strategy ID to be withdrawn from\\n     * @param _data Strategy withdraw function call, using `encodeWithSelector`\\n     */\\n    function withdraw(uint _strategyId, bytes calldata _data) external onlyRole(STRATEGY_MANAGER) {\\n        // If we are bypassing the strategy, then skip this call\\n        if (_bypassStrategy[_strategyIds[_strategyId]]) return;\\n\\n        // Extract the selector from data\\n        bytes4 _selector = bytes4(_data);\\n\\n        // Create a replication of the bytes data that removes the selector\\n        bytes memory _newData = new bytes(_data.length - 4);\\n        for (uint i; i < _data.length - 4; i++) {\\n            _newData[i] = _data[i + 4];\\n        }\\n\\n        // Make a call to our strategy that passes on our withdrawal data\\n        (bool success,) = _strategyIds[_strategyId].call(\\n            // Sandwich the selector against the recipient and remaining data\\n            abi.encodePacked(abi.encodeWithSelector(_selector, treasury), _newData)\\n        );\\n\\n        // If our call failed, return a standardised message rather than decoding\\n        require(success, 'Unable to withdraw');\\n    }\\n\\n    /**\\n     * Makes a call to a strategy withdraw function.\\n     *\\n     * @param _strategy Strategy address to be updated\\n     * @param _percentage The percentage of position to withdraw from\\n     */\\n    function withdrawPercentage(address _strategy, uint _percentage)\\n        external\\n        onlyRole(STRATEGY_MANAGER)\\n        returns (address[] memory tokens_, uint[] memory amounts_)\\n    {\\n        // Ensure our percentage is valid (less than 100% to 2 decimal places)\\n        require(_percentage > 0, 'Invalid percentage');\\n        require(_percentage <= 100_00, 'Invalid percentage');\\n\\n        // Prevent a bypassed strategy from parsing withdrawal calculations\\n        if (_bypassStrategy[_strategy]) {\\n            return (tokens_, amounts_);\\n        }\\n\\n        // Calls our strategy to withdraw a percentage of the holdings\\n        return IBaseStrategy(_strategy).withdrawPercentage(msg.sender, _percentage);\\n    }\\n\\n    /**\\n     * Allow a strategy to be skipped when being processing. This is beneficial if a\\n     * strategy becomes corrupted at an external point and would otherwise prevent an\\n     * epoch from ending.\\n     *\\n     * @dev This does not shutdown the strategy as it can be undone. If a strategy wants\\n     * to wind down, then it should also be paused and a full withdraw made.\\n     */\\n    function bypassStrategy(address _strategy, bool _bypass) external onlyRole(STRATEGY_MANAGER) {\\n        _bypassStrategy[_strategy] = _bypass;\\n    }\\n\\n    /**\\n     * Allows the {Treasury} contract address to be updated. All withdrawals will\\n     * be requested to be sent to this address when the `withdraw` is called.\\n     *\\n     * @dev This address is dynamically injected into the subsequent strategy\\n     * withdraw call.\\n     *\\n     * @param _treasury The new {Treasury} contract address\\n     */\\n    function setTreasury(address _treasury) public onlyRole(TREASURY_MANAGER) {\\n        if (_treasury == address(0)) revert CannotSetNullAddress();\\n\\n        treasury = _treasury;\\n        emit TreasuryUpdated(_treasury);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/authorities/AuthorityControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\\n\\nimport {CannotSetNullAddress} from '@floor/utils/Errors.sol';\\n\\nimport {IAuthorityControl} from '@floor-interfaces/authorities/AuthorityControl.sol';\\nimport {IAuthorityRegistry} from '@floor-interfaces/authorities/AuthorityRegistry.sol';\\n\\n/// If the account does not have the required role for the call.\\n/// @param caller The address making the call\\n/// @param role The role that is required for the call\\nerror AccountDoesNotHaveRole(address caller, bytes32 role);\\n\\n/// If the account does not have the required admin role for the call.\\n/// @param caller The address making the call\\nerror AccountDoesNotHaveAdminRole(address caller);\\n\\n/**\\n * This contract is heavily based on the standardised OpenZeppelin `AccessControl` library.\\n * This allows for the creation of role based access levels that can be assigned to 1-n\\n * addresses.\\n *\\n * Contracts will be able to implement the AuthorityControl to provide access to the `onlyRole` modifier or the\\n * `hasRole` function. This will ensure that the `msg.sender` is allowed to perform an action.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed in the external API and be\\n * unique. The best way to achieve this is by using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"TreasuryManager\\\");\\n * ```\\n */\\ncontract AuthorityControl is Context, IAuthorityControl {\\n    /// CollectionManager - Can approve token addresses to be allowed to be used in strategies\\n    bytes32 public constant COLLECTION_MANAGER = keccak256('CollectionManager');\\n\\n    /// EpochTrigger - Can run epoch trigger contract specific logic\\n    bytes32 public constant EPOCH_TRIGGER = keccak256('EpochTrigger');\\n\\n    /// FloorManager - Can mint and manage Floor and VeFloor tokens\\n    bytes32 public constant FLOOR_MANAGER = keccak256('FloorManager');\\n\\n    /// Governor - A likely DAO owned vote address to allow for wide scale decisions to\\n    /// be made and implemented.\\n    bytes32 public constant GOVERNOR = keccak256('Governor');\\n\\n    /// Guardian - Wallet address that will allow for Governor based actions, except without\\n    /// timeframe restrictions.\\n    bytes32 public constant GUARDIAN = keccak256('Guardian');\\n\\n    /// TreasuryManager - Access to Treasury asset management\\n    bytes32 public constant TREASURY_MANAGER = keccak256('TreasuryManager');\\n\\n    /// StrategyManager - Can create new strategies against approved strategies and collections\\n    bytes32 public constant STRATEGY_MANAGER = keccak256('StrategyManager');\\n\\n    /// VoteManager - Can manage account votes\\n    bytes32 public constant VOTE_MANAGER = keccak256('VoteManager');\\n\\n    /// Reference to the {AuthorityRegistry} contract that maintains role allocations\\n    IAuthorityRegistry public immutable registry;\\n\\n    /**\\n     * Modifier that checks that an account has a specific role. Reverts with a\\n     * standardized message if user does not have specified role.\\n     *\\n     * @param role The keccak256 encoded role string\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        if (!registry.hasRole(role, _msgSender())) {\\n            revert AccountDoesNotHaveRole(_msgSender(), role);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * Modifier that checks that an account has a governor or guardian role.\\n     * Reverts with a standardized message if sender does not have an admin role.\\n     */\\n    modifier onlyAdminRole() {\\n        if (!registry.hasAdminRole(_msgSender())) {\\n            revert AccountDoesNotHaveAdminRole(_msgSender());\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * The address that deploys the {AuthorityControl} becomes the default controller. This\\n     * can only be overwritten by the existing.\\n     *\\n     * @param _registry The address of our deployed AuthorityRegistry contract\\n     */\\n    constructor(address _registry) {\\n        if (_registry == address(0)) revert CannotSetNullAddress();\\n        registry = IAuthorityRegistry(_registry);\\n    }\\n\\n    /**\\n     * Returns `true` if `account` has been granted `role`.\\n     *\\n     * @param role The keccak256 encoded role string\\n     * @param account Address to check ownership of role\\n     *\\n     * @return bool If the address has the specified user role\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return registry.hasRole(role, account);\\n    }\\n\\n    /**\\n     * Returns `true` if `account` has been granted either GOVERNOR or GUARDIAN role.\\n     *\\n     * @param account Address to check ownership of role\\n     *\\n     * @return bool If the address has the GOVERNOR or GUARDIAN role\\n     */\\n    function hasAdminRole(address account) public view returns (bool) {\\n        return registry.hasAdminRole(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/utils/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n/**\\n * A collection of generic errors that can be referenced across multiple\\n * contracts. Contract-specific errors should still be stored in their\\n * individual Solidity files.\\n */\\n\\n/// If a NULL address tries to be stored which should not be accepted\\nerror CannotSetNullAddress();\\n\\n/// If the caller has entered an insufficient amount to process the action. This\\n/// will likely be a zero amount.\\nerror InsufficientAmount();\\n\\n/// If the caller enters a percentage value that is too high for the requirements\\nerror PercentageTooHigh(uint amount);\\n\\n/// If a required ETH or token `transfer` call fails\\nerror TransferFailed();\\n\\n/// If a user calls a deposit related function with a zero amount\\nerror CannotDepositZeroAmount();\\n\\n/// If a user calls a withdrawal related function with a zero amount\\nerror CannotWithdrawZeroAmount();\\n\\n/// If there are no rewards available to be claimed\\nerror NoRewardsAvailableToClaim();\\n\\n/// If the requested collection is not approved\\n/// @param collection Address of the collection requested\\nerror CollectionNotApproved(address collection);\\n\\n/// If the requested strategy implementation is not approved\\n/// @param strategyImplementation Address of the strategy implementation requested\\nerror StrategyNotApproved(address strategyImplementation);\\n\"\r\n    },\r\n    \"src/interfaces/collections/CollectionRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * Allows collection contracts to be approved and revoked by addresses holding the\\n * {CollectionManager} role. Only once approved can these collections be applied to\\n * new or existing strategies. They will only need to be stored as a mapping of address\\n * to boolean.\\n */\\n\\ninterface ICollectionRegistry {\\n    /// Emitted when a collection is successfully approved\\n    event CollectionApproved(address contractAddr);\\n\\n    /// Emitted when a collection has been successfully revoked\\n    event CollectionRevoked(address contractAddr);\\n\\n    /**\\n     * Returns `true` if the contract address is an approved collection, otherwise\\n     * returns `false`.\\n     */\\n    function isApproved(address contractAddr) external view returns (bool);\\n\\n    /**\\n     * Returns an array of all approved collections.\\n     */\\n    function approvedCollections() external view returns (address[] memory);\\n\\n    /**\\n     * Approves a collection contract to be used for strategies.\\n     */\\n    function approveCollection(address contractAddr) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/strategies/BaseStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * Strategies will hold the logic for interacting with external platforms to stake\\n * and harvest reward yield. Each strategy will require its own strategy implementation\\n * to allow for different immutable variables to be defined during construct.\\n *\\n * This will follow a similar approach to how NFTX offer their eligibility module\\n * logic, with a lot of the power coming from inheritence.\\n *\\n * When constructed, we want to give the {Treasury} a max uint approval of the yield\\n * and underlying tokens.\\n */\\ninterface IBaseStrategy {\\n    /// @dev When strategy receives a deposit\\n    event Deposit(address token, uint amount, address caller);\\n\\n    /// @dev When strategy is harvested\\n    event Harvest(address token, uint amount);\\n\\n    /// @dev When a staked user exits their position\\n    event Withdraw(address token, uint amount, address recipient);\\n\\n    /**\\n     * Allows the strategy to be initialised.\\n     */\\n    function initialize(bytes32 name, uint strategyId, bytes calldata initData) external;\\n\\n    /**\\n     * Name of the strategy.\\n     */\\n    function name() external view returns (bytes32);\\n\\n    /**\\n     * The numerical ID of the strategy that acts as an index for the {StrategyFactory}.\\n     */\\n    function strategyId() external view returns (uint);\\n\\n    /**\\n     * Total rewards generated by the strategy in all time. This is pure bragging rights.\\n     */\\n    function lifetimeRewards(address token) external returns (uint amount_);\\n\\n    /**\\n     * The amount of rewards claimed in the last claim call.\\n     */\\n    function lastEpochRewards(address token) external returns (uint amount_);\\n\\n    /**\\n     * Gets rewards that are available to harvest.\\n     */\\n    function available() external returns (address[] memory, uint[] memory);\\n\\n    /**\\n     * Extracts all rewards from third party and moves it to a recipient. This should\\n     * only be called by a specific action.\\n     *\\n     * @dev This _should_ always be imposed to be the {Treasury} by the {StrategyFactory}.\\n     */\\n    function harvest(address /* _recipient */ ) external;\\n\\n    /**\\n     * Returns an array of tokens that the strategy supports.\\n     *\\n     * @return address[] The address of valid tokens\\n     */\\n    function validTokens() external view returns (address[] memory);\\n\\n    /**\\n     * Makes a call to a strategy to withdraw a percentage of the deposited holdings.\\n     *\\n     * @param recipient Strategy address to be updated\\n     * @param percentage The 2 decimal accuracy of the percentage to withdraw (e.g. 100% = 10000)\\n     *\\n     * @return address[] Array of tokens withdrawn\\n     * @return uint[] Amounts of respective tokens withdrawn\\n     */\\n    function withdrawPercentage(address recipient, uint percentage) external returns (address[] memory, uint[] memory);\\n\\n    /**\\n     * Pauses deposits from being made into the strategy. This should only be called by\\n     * a guardian or governor.\\n     *\\n     * @param _p Boolean value for if the strategy should be paused\\n     */\\n    function pause(bool _p) external;\\n\\n    /**\\n     * Gets a read of new yield since the last call. This is what can be called when\\n     * the epoch ends to determine the amount generated within the epoch.\\n     */\\n    function snapshot() external returns (address[] memory, uint[] memory);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/strategies/StrategyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * Allows for strategies to be created, pairing them with a {Strategy} and an approved\\n * collection. The strategy creation script needs to be as highly optimised as possible\\n * to ensure that the gas costs are kept down.\\n *\\n * This factory will keep an index of created strategies and secondary information to ensure\\n * that external applications can display and maintain a list of available strategies.\\n *\\n * The contract can be paused to prevent the creation of new strategies.\\n */\\n\\ninterface IStrategyFactory {\\n    /// @dev Sent when a strategy is created successfully\\n    event StrategyCreated(uint indexed strategyId, address strategyAddress, address assetAddress);\\n\\n    /// @dev Sent when a snapshot is taken\\n    event StrategySnapshot(uint epoch, address[] tokens, uint[] amounts);\\n\\n    /// @dev Sent when the Treasury address is updated\\n    event TreasuryUpdated(address treasury);\\n\\n    /**\\n     * Our stored {Treasury} address.\\n     */\\n    function treasury() external view returns (address);\\n\\n    /**\\n     * Provides a list of all strategies created.\\n     *\\n     * @return Array of all strategies created by the {StrategyFactory}\\n     */\\n    function strategies() external view returns (address[] memory);\\n\\n    /**\\n     * Returns an array of all strategies that belong to a specific collection.\\n     */\\n    function collectionStrategies(address _collection) external view returns (address[] memory);\\n\\n    /**\\n     * Provides a strategy against the provided `strategyId` (index). If the index does not exist,\\n     * then address(0) will be returned.\\n     *\\n     * @param _strategyId ID of the strategy to retrieve\\n     *\\n     * @return Address of the strategy\\n     */\\n    function strategy(uint _strategyId) external view returns (address);\\n\\n    /**\\n     * Creates a strategy with an approved collection.\\n     *\\n     * @dev The strategy is not created using Clones as there are complications when allocated\\n     * roles and permissions.\\n     *\\n     * @param _name Human-readable name of the strategy\\n     * @param _strategy The strategy implemented by the strategy\\n     * @param _strategyInitData Bytes data required by the {Strategy} for initialization\\n     * @param _collection The address of the collection attached to the strategy\\n     *\\n     * @return strategyId_ ID of the newly created strategy\\n     * @return strategyAddr_ Address of the newly created strategy\\n     */\\n    function deployStrategy(bytes32 _name, address _strategy, bytes calldata _strategyInitData, address _collection)\\n        external\\n        returns (uint strategyId_, address strategyAddr_);\\n\\n    /**\\n     * Allows individual strategies to be paused, meaning that assets can no longer be deposited,\\n     * although staked assets can always be withdrawn.\\n     *\\n     * @dev Events are fired within the strategy to allow listeners to update.\\n     *\\n     * @param _strategyId Strategy ID to be paused\\n     * @param _paused If the strategy should be paused or unpaused\\n     */\\n    function pause(uint _strategyId, bool _paused) external;\\n\\n    /**\\n     * Reads the yield generated by a strategy since the last time that this function was called.\\n     *\\n     * @param _epoch The current epoch being snapshotted\\n     *\\n     * @return tokens Tokens that have been generated as yield\\n     * @return amounts The amount of yield generated for the corresponding token\\n     */\\n    function snapshot(uint _epoch) external returns (address[] memory tokens, uint[] memory amounts, uint totalAmount);\\n\\n    /**\\n     * Harvest available reward yield from the strategy. This won't affect the amount\\n     * depositted into the contract and should only harvest rewards directly into the\\n     * {Treasury}.\\n     *\\n     * @param _strategyId Strategy ID to be harvested\\n     */\\n    function harvest(uint _strategyId) external;\\n\\n    /**\\n     * Makes a call to a strategy withdraw function by passing the strategy ID and\\n     * `abi.encodeWithSelector` to build the bytes `_data` parameter. This will then\\n     * pass the data on to the strategy function and inject the treasury recipient\\n     * address within the call as the first function parameter.\\n     *\\n     * @dev It is required for the transaction to return a successful call, otherwise\\n     * the transaction will be reverted. The error response will be standardised so\\n     * debugging will require a trace, rather than just the end message.\\n     *\\n     * @param _strategyId Strategy ID to be withdrawn from\\n     * @param _data Strategy withdraw function call, using `encodeWithSelector`\\n     */\\n    function withdraw(uint _strategyId, bytes calldata _data) external;\\n\\n    /**\\n     * Makes a call to a strategy to withdraw a percentage of the deposited holdings.\\n     *\\n     * @param _strategy Strategy address to be updated\\n     * @param _percentage The 2 decimal accuracy of the percentage to withdraw (e.g. 100% = 10000)\\n     */\\n    function withdrawPercentage(address _strategy, uint _percentage) external returns (address[] memory, uint[] memory);\\n\\n    /**\\n     * Allows the {Treasury} contract address to be updated. All withdrawals will\\n     * be requested to be sent to this address when the `withdraw` is called.\\n     *\\n     * @dev This address is dynamically injected into the subsequent strategy\\n     * withdraw call.\\n     *\\n     * @param _treasury The new {Treasury} contract address\\n     */\\n    function setTreasury(address _treasury) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/strategies/StrategyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * Allows strategy contracts to be approved and revoked by addresses holding the\\n * {TREASURY_MANAGER} role. Only once approved can these strategy implementations be deployed\\n * to new or existing strategies.\\n */\\ninterface IStrategyRegistry {\\n    /// Emitted when a strategy is approved or unapproved\\n    event ApprovedStrategyUpdated(address contractAddr, bool approved);\\n\\n    /**\\n     * Checks if a strategy has previously been approved.\\n     *\\n     * @param contractAddr The strategy implementation address to be checked\\n     *\\n     * @return Returns `true` if the contract address is an approved strategy, otherwise\\n     * returns `false`.\\n     */\\n    function isApproved(address contractAddr) external view returns (bool);\\n\\n    /**\\n     * Changes the approval state of a strategy implementation contract.\\n     *\\n     * The strategy address cannot be null, and if it is already the new state, then\\n     * no changes will be made.\\n     *\\n     * The caller must have the `TREASURY_MANAGER` role.\\n     *\\n     * @param contractAddr Address of unapproved strategy to approve\\n     * @param approved The new approval state for the implementation\\n     */\\n    function approveStrategy(address contractAddr, bool approved) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/Treasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IWETH} from '@floor-interfaces/tokens/WETH.sol';\\n\\n\\nlibrary TreasuryEnums {\\n    /// Different sweep types that can be specified.\\n    enum SweepType {\\n        COLLECTION_ADDITION,\\n        SWEEP\\n    }\\n\\n    /// Different approval types that can be specified.\\n    enum ApprovalType {\\n        NATIVE,\\n        ERC20,\\n        ERC721,\\n        ERC1155\\n    }\\n}\\n\\n/**\\n * @dev The Treasury will hold all assets.\\n */\\ninterface ITreasury {\\n    /// Stores data that allows the Treasury to action a sweep.\\n    struct Sweep {\\n        TreasuryEnums.SweepType sweepType;\\n        address[] collections;\\n        uint[] amounts;\\n        bool completed;\\n        string message;\\n    }\\n\\n    /// The data structure format that will be mapped against to define a token\\n    /// approval request.\\n    struct ActionApproval {\\n        TreasuryEnums.ApprovalType _type; // Token type\\n        address assetContract; // Used by 20, 721 and 1155\\n        address target; // Used by 20, 721 and 1155\\n        uint amount; // Used by native and 20 tokens\\n    }\\n\\n    /// @dev When native network token is withdrawn from the Treasury\\n    event Deposit(uint amount);\\n\\n    /// @dev When an ERC20 is depositted into the Treasury\\n    event DepositERC20(address token, uint amount);\\n\\n    /// @dev When an ERC721 is depositted into the Treasury\\n    event DepositERC721(address token, uint tokenId);\\n\\n    /// @dev When an ERC1155 is depositted into the Treasury\\n    event DepositERC1155(address token, uint tokenId, uint amount);\\n\\n    /// @dev When native network token is withdrawn from the Treasury\\n    event Withdraw(uint amount, address recipient);\\n\\n    /// @dev When an ERC20 token is withdrawn from the Treasury\\n    event WithdrawERC20(address token, uint amount, address recipient);\\n\\n    /// @dev When an ERC721 token is withdrawn from the Treasury\\n    event WithdrawERC721(address token, uint tokenId, address recipient);\\n\\n    /// @dev When an ERC1155 is withdrawn from the Treasury\\n    event WithdrawERC1155(address token, uint tokenId, uint amount, address recipient);\\n\\n    /// @dev When FLOOR is minted\\n    event FloorMinted(uint amount);\\n\\n    /// @dev When a {Treasury} action is processed\\n    event ActionProcessed(address action, bytes data);\\n\\n    /// @dev When a sweep is registered against an epoch\\n    event SweepRegistered(uint sweepEpoch, TreasuryEnums.SweepType sweepType, address[] collections, uint[] amounts);\\n\\n    /// @dev When an action is assigned to a sweep epoch\\n    event SweepAction(uint sweepEpoch);\\n\\n    /// @dev When an epoch is swept\\n    event EpochSwept(uint epochIndex);\\n\\n    /// Emitted when the {MercenarySweeper} contract address is updated\\n    event MercenarySweeperUpdated(address mercSweeper);\\n\\n    /// Emitted when the minimum sweep amount is updated\\n    event MinSweepAmountUpdated(uint minSweepAmount);\\n\\n    /// Emitted when the {VeFloorStaking} contract is updated\\n    event VeFloorStakingUpdated(address veFloorStaking);\\n\\n    /// Emitted when the {StrategyFactory} contract is updated\\n    event StrategyFactoryUpdated(address strategyFactory);\\n\\n    /**\\n     * Our stored WETH address for the {Treasury}\\n     */\\n    function weth() external returns (IWETH);\\n\\n    /**\\n     * Allow FLOOR token to be minted. This should be called from the deposit method\\n     * internally, but a public method will allow a {TreasuryManager} to bypass this\\n     * and create additional FLOOR tokens if needed.\\n     *\\n     * @dev We only want to do this on creation and for inflation. Have a think on how\\n     * we can implement this!\\n     */\\n    function mint(uint amount) external;\\n\\n    /**\\n     * Allows an ERC20 token to be deposited and generates FLOOR tokens based on\\n     * the current determined value of FLOOR and the token.\\n     */\\n    function depositERC20(address token, uint amount) external;\\n\\n    /**\\n     * Allows an ERC721 token to be deposited and generates FLOOR tokens based on\\n     * the current determined value of FLOOR and the token.\\n     */\\n    function depositERC721(address token, uint tokenId) external;\\n\\n    /**\\n     * Allows an ERC1155 token(s) to be deposited and generates FLOOR tokens based on\\n     * the current determined value of FLOOR and the token.\\n     */\\n    function depositERC1155(address token, uint tokenId, uint amount) external;\\n\\n    /**\\n     * Allows an approved user to withdraw native token.\\n     */\\n    function withdraw(address recipient, uint amount) external;\\n\\n    /**\\n     * Allows an approved user to withdraw and ERC20 token from the Treasury.\\n     */\\n    function withdrawERC20(address recipient, address token, uint amount) external;\\n\\n    /**\\n     * Allows an approved user to withdraw and ERC721 token from the Treasury.\\n     */\\n    function withdrawERC721(address recipient, address token, uint tokenId) external;\\n\\n    /**\\n     * Allows an approved user to withdraw an ERC1155 token(s) from the Treasury.\\n     */\\n    function withdrawERC1155(address recipient, address token, uint tokenId, uint amount) external;\\n\\n    /**\\n     * Actions a sweep to be used against a contract that implements {ISweeper}. This\\n     * will fulfill the sweep and we then mark the sweep as completed.\\n     */\\n    function sweepEpoch(uint epochIndex, address sweeper, bytes calldata data, uint mercSweep) external;\\n\\n    /**\\n     * Allows the DAO to resweep an already swept \\\"Sweep\\\" struct, using a contract that\\n     * implements {ISweeper}. This will fulfill the sweep again and keep the sweep marked\\n     * as completed.\\n     */\\n    function resweepEpoch(uint epochIndex, address sweeper, bytes calldata data, uint mercSweep) external;\\n\\n    /**\\n     * When an epoch ends, we have the ability to register a sweep against the {Treasury}\\n     * via an approved contract. This will store a DAO sweep that will need to be actioned\\n     * using the `sweepEpoch` function.\\n     */\\n    function registerSweep(uint epoch, address[] calldata collections, uint[] calldata amounts, TreasuryEnums.SweepType sweepType)\\n        external;\\n\\n    /**\\n     * The minimum sweep amount that can be implemented, or excluded, as desired by the DAO.\\n     */\\n    function minSweepAmount() external returns (uint);\\n\\n    /**\\n     * Allows the mercenary sweeper contract to be updated.\\n     */\\n    function setMercenarySweeper(address _mercSweeper) external;\\n\\n    /**\\n     * Allows us to set a new VeFloorStaking contract that is used when sweeping epochs.\\n     */\\n    function setVeFloorStaking(address _veFloorStaking) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/authorities/AuthorityControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAuthorityControl {\\n    /// CollectionManager - Can approve token addresses to be allowed to be used in strategies\\n    function COLLECTION_MANAGER() external returns (bytes32);\\n\\n    /// EpochTrigger - Can run epoch trigger contract specific logic\\n    function EPOCH_TRIGGER() external returns (bytes32);\\n\\n    /// FloorManager - Can mint and manage Floor and VeFloor tokens\\n    function FLOOR_MANAGER() external returns (bytes32);\\n\\n    /// Governor - A likely DAO owned vote address to allow for wide scale decisions to\\n    /// be made and implemented.\\n    function GOVERNOR() external returns (bytes32);\\n\\n    /// Guardian - Wallet address that will allow for Governor based actions, except without\\n    /// timeframe restrictions.\\n    function GUARDIAN() external returns (bytes32);\\n\\n    /// TreasuryManager - Access to Treasury asset management\\n    function TREASURY_MANAGER() external returns (bytes32);\\n\\n    /// StrategyManager - Can create new strategies against approved strategies and collections\\n    function STRATEGY_MANAGER() external returns (bytes32);\\n\\n    /// VoteManager - Can manage account votes\\n    function VOTE_MANAGER() external returns (bytes32);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted either the GOVERNOR or\\n     * GUARDIAN `role`.\\n     */\\n    function hasAdminRole(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/authorities/AuthorityRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * This interface expands upon the OpenZeppelin `IAccessControl` interface:\\n * https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/master/contracts/access/IAccessControl.sol\\n */\\n\\ninterface IAuthorityRegistry {\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted either the GOVERNOR or\\n     * GUARDIAN `role`.\\n     */\\n    function hasAdminRole(address account) external view returns (bool);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/tokens/WETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IWETH is IERC20 {\\n    function allowance(address, address) external view returns (uint);\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    function approve(address, uint) external returns (bool);\\n\\n    function transfer(address, uint) external returns (bool);\\n\\n    function transferFrom(address, address, uint) external returns (bool);\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@uniswap-v3/=lib/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"@chainlink/=lib/chainlink/\",\r\n      \"@murky/=lib/murky/src/\",\r\n      \"@solidity-math-utils/=lib/solidity-math-utils/project/contracts/\",\r\n      \"@solidity-trigonometry/=lib/solidity-trigonometry/src/\",\r\n      \"@1inch/=lib/\",\r\n      \"@charmfi/=lib/charmfi-contracts-0.8.0-support/\",\r\n      \"@sudoswap/=lib/lssvm/src/\",\r\n      \"@floor/=src/contracts/\",\r\n      \"@floor-interfaces/=src/interfaces/\",\r\n      \"@floor-scripts/=script/\",\r\n      \"@ERC721A/=lib/ERC721A/contracts/\",\r\n      \"foundry-random/=lib/foundry-random/src/\",\r\n      \"lssvm2/=lib/lssvm2/src/\",\r\n      \"@nftx-protocol-v3/=lib/nftx-protocol-v3/src/\",\r\n      \"@manifoldxyz/=lib/lssvm2/lib/\",\r\n      \"@mocks/=lib/nftx-protocol-v3/src/mocks/\",\r\n      \"@permit2/=lib/nftx-protocol-v3/lib/permit2/src/\",\r\n      \"@prb/math/=lib/lssvm2/lib/prb-math/src/\",\r\n      \"@prb/test/=lib/foundry-random/lib/prb-test/src/\",\r\n      \"@src/=lib/nftx-protocol-v3/src/\",\r\n      \"@test/=lib/nftx-protocol-v3/test/\",\r\n      \"@uni-core/=lib/nftx-protocol-v3/src/uniswap/v3-core/\",\r\n      \"@uni-periphery/=lib/nftx-protocol-v3/src/uniswap/v3-periphery/\",\r\n      \"@uniswap/lib/=lib/nftx-protocol-v3/lib/solidity-lib/\",\r\n      \"@uniswap/v2-core/=lib/nftx-protocol-v3/lib/v2-core/\",\r\n      \"@uniswap/v3-core/contracts/=lib/nftx-protocol-v3/src/uniswap/v3-core/\",\r\n      \"CramBit/=lib/foundry-random/lib/CramBit/\",\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"base64-sol/=lib/nftx-protocol-v3/src/uniswap/v3-periphery/libraries/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"charmfi-contracts-0.8.0-support/=lib/charmfi-contracts-0.8.0-support/\",\r\n      \"clones-with-immutable-args/=lib/lssvm2/lib/clones-with-immutable-args/src/\",\r\n      \"crambit/=lib/foundry-random/lib/CramBit/src/\",\r\n      \"create2-helpers/=lib/lssvm2/lib/royalty-registry-solidity/lib/create2-helpers/\",\r\n      \"create3-factory/=lib/lssvm2/lib/create3-factory/\",\r\n      \"foundry-huff/=lib/lssvm2/lib/foundry-huff/src/\",\r\n      \"foundry-random/=lib/foundry-random/src/\",\r\n      \"huffmate/=lib/lssvm2/lib/huffmate/src/\",\r\n      \"libraries-solidity/=lib/lssvm2/lib/libraries-solidity/contracts/\",\r\n      \"lssvm/=lib/lssvm/src/\",\r\n      \"lssvm2/=lib/lssvm2/src/\",\r\n      \"manifoldxyz/=lib/lssvm2/lib/royalty-registry-solidity/contracts/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"nftx-protocol-v3/=lib/nftx-protocol-v3/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"prb-math/=lib/solidity-trigonometry/lib/prb-math/contracts/\",\r\n      \"prb-test/=lib/foundry-random/lib/prb-test/src/\",\r\n      \"royalty-registry-solidity.git/=lib/lssvm/lib/royalty-registry-solidity.git/contracts/\",\r\n      \"royalty-registry-solidity/=lib/lssvm2/lib/royalty-registry-solidity/\",\r\n      \"solidity-bytes-utils/=lib/foundry-random/lib/solidity-bytes-utils/contracts/\",\r\n      \"solidity-math-utils/=lib/solidity-math-utils/\",\r\n      \"solidity-stringutils/=lib/lssvm2/lib/foundry-huff/lib/solidity-stringutils/\",\r\n      \"solidity-trigonometry/=lib/solidity-trigonometry/src/\",\r\n      \"solidity-utils/=lib/solidity-utils/contracts/\",\r\n      \"solmate/=lib/lssvm2/lib/solmate/src/\",\r\n      \"src/=lib/foundry-random/src/\",\r\n      \"stringutils/=lib/lssvm2/lib/foundry-huff/lib/solidity-stringutils/\",\r\n      \"v3-core/=lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\",\r\n      \"weird-erc20/=lib/lssvm/lib/solmate/lib/weird-erc20/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collectionRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategyRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"AccountDoesNotHaveRole\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetNullAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"CollectionNotApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StrategyNameCannotBeEmpty\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyImplementation\",\"type\":\"address\"}],\"name\":\"StrategyNotApproved\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"}],\"name\":\"StrategyCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"StrategySnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"TreasuryUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COLLECTION_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EPOCH_TRIGGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FLOOR_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOVERNOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GUARDIAN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STRATEGY_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TREASURY_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VOTE_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bypass\",\"type\":\"bool\"}],\"name\":\"bypassStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectionRegistry\",\"outputs\":[{\"internalType\":\"contract ICollectionRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"}],\"name\":\"collectionStrategies\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_name\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_strategyInitData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"}],\"name\":\"deployStrategy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"strategyAddr_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_strategyId\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasAdminRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_strategyId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IAuthorityRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"snapshot\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"strategies_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategies\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_strategyId\",\"type\":\"uint256\"}],\"name\":\"strategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyRegistry\",\"outputs\":[{\"internalType\":\"contract IStrategyRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_strategyId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"withdrawPercentage\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StrategyFactory", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000601d281e3d68324449141212fb6802fc81d38c2f000000000000000000000000afb8c2ab888718e6e8f250c422f7968b177d6a8f00000000000000000000000069c794b9d734e51f44bd83fc3f11de22115f41f0", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}