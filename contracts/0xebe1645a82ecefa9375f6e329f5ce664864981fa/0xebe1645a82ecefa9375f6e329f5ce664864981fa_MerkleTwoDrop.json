{"SourceCode": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\ncontract MerkleTwoDrop {\r\n\r\n    struct Airdrop {\r\n      bytes32 root;\r\n      mapping(address => bool) awarded;\r\n    }\r\n\r\n    /// Events\r\n    event Start(uint id);\r\n    event Award(uint id, address recipient, uint amount0, uint amount1);\r\n\r\n    /// State\r\n    mapping(uint => Airdrop) public airdrops;\r\n    ITokenManager public tokenManager0;\r\n    ITokenManager public tokenManager1;\r\n    uint public airdropsCount;\r\n    address public startAuth;\r\n\r\n    bool private initialized;\r\n\r\n    function initialize(address _tokenManager0, address _tokenManager1, address _startAuth) public {\r\n        require(!initialized, \"Already initialized\");\r\n        initialized = true;\r\n\r\n        require(_tokenManager0 != address(0), \"Needs token0 manager\");\r\n        require(_tokenManager1 != address(0), \"Needs token1 manager\");\r\n        require(_startAuth != address(0), \"Needs startAuth\");\r\n\r\n        tokenManager0 = ITokenManager(_tokenManager0);\r\n        tokenManager1 = ITokenManager(_tokenManager1);\r\n        startAuth = _startAuth;\r\n    }\r\n\r\n    /**\r\n     * @notice Start a new airdrop `_root`\r\n     * @param _root New airdrop merkle root\r\n     */\r\n    function start(bytes32 _root) public {\r\n        require(msg.sender == startAuth, \"Not authorized\");\r\n        _start(_root);\r\n    }\r\n\r\n    function _start(bytes32 _root) internal returns(uint id){\r\n        id = ++airdropsCount;    // start at 1\r\n        Airdrop storage newAirdrop = airdrops[id];\r\n        newAirdrop.root = _root;\r\n        emit Start(id);\r\n    }\r\n\r\n    /**\r\n     * @notice Award from airdrop\r\n     * @param _id Airdrop id\r\n     * @param _recipient Recepient of award\r\n     * @param _amount0 The token0 amount\r\n     * @param _amount1 The token1 amount\r\n     * @param _proof Merkle proof to correspond to data supplied\r\n     */\r\n    function award(uint _id, address _recipient, uint256 _amount0, uint256 _amount1, bytes32[] calldata _proof) public {\r\n        Airdrop storage airdrop = airdrops[_id];\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(_recipient, _amount0, _amount1));\r\n        require( validate(airdrop.root, _proof, hash), \"Invalid proof\" );\r\n\r\n        require( !airdrops[_id].awarded[_recipient], \"Already awarded\" );\r\n\r\n        airdrops[_id].awarded[_recipient] = true;\r\n\r\n        tokenManager0.mint(_recipient, _amount0);\r\n        tokenManager1.mint(_recipient, _amount1);\r\n\r\n        emit Award(_id, _recipient, _amount0, _amount1);\r\n    }\r\n\r\n    /**\r\n     * @notice Award from multiple airdrops to single recipient\r\n     * @param _ids Airdrop ids\r\n     * @param _recipient Recepient of award\r\n     * @param _amount0s The token0 amounts\r\n     * @param _amount1s The token1 amounts\r\n     * @param _proofs Merkle proofs\r\n     */\r\n    function awardFromMany(uint[] calldata _ids, address _recipient, uint[] calldata _amount0s, uint[] calldata _amount1s, bytes32[][] calldata _proofs) public {\r\n\r\n        uint totalAmount0;\r\n        uint totalAmount1;\r\n\r\n        for (uint i = 0; i < _ids.length; i++) {\r\n            uint id = _ids[i];\r\n\r\n            bytes32 hash = keccak256(abi.encodePacked(_recipient, _amount0s[i], _amount1s[i]));\r\n            require( validate(airdrops[id].root, _proofs[i], hash), \"Invalid proof\" );\r\n\r\n            require( !airdrops[id].awarded[_recipient], \"Already awarded\" );\r\n\r\n            airdrops[id].awarded[_recipient] = true;\r\n\r\n            totalAmount0 += _amount0s[i];\r\n            totalAmount1 += _amount1s[i];\r\n\r\n            emit Award(id, _recipient, _amount0s[i], _amount1s[i]);\r\n        }\r\n\r\n        tokenManager0.mint(_recipient, totalAmount0);\r\n        tokenManager1.mint(_recipient, totalAmount1);\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Award from airdrop to multiple recipients\r\n     * @param _id Airdrop ids\r\n     * @param _recipients Recepients of award\r\n     * @param _amount0s The karma amount\r\n     * @param _amount1s The currency amount\r\n     * @param _proofs Merkle proofs\r\n     */\r\n    function awardToMany(uint _id, address[] calldata _recipients, uint[] calldata _amount0s, uint[] calldata _amount1s, bytes32[][] calldata _proofs) public {\r\n\r\n        for (uint i = 0; i < _recipients.length; i++) {\r\n            address recipient = _recipients[i];\r\n\r\n            if( airdrops[_id].awarded[recipient] )\r\n                continue;\r\n\r\n            bytes32 hash = keccak256(abi.encodePacked(recipient, _amount0s[i], _amount1s[i]));\r\n            if( !validate(airdrops[_id].root, _proofs[i], hash) )\r\n                continue;\r\n\r\n            airdrops[_id].awarded[recipient] = true;\r\n\r\n            tokenManager0.mint(recipient, _amount0s[i]);\r\n            tokenManager1.mint(recipient, _amount1s[i]);\r\n\r\n            emit Award(_id, recipient, _amount0s[i], _amount1s[i]);\r\n        }\r\n\r\n    }\r\n\r\n    function validate(bytes32 root, bytes32[] memory proof, bytes32 hash) public pure returns (bool) {\r\n\r\n        for (uint i = 0; i < proof.length; i++) {\r\n            if (hash < proof[i]) {\r\n                hash = keccak256(abi.encodePacked(hash, proof[i]));\r\n            } else {\r\n                hash = keccak256(abi.encodePacked(proof[i], hash));\r\n            }\r\n        }\r\n\r\n        return hash == root;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if address:`_recipient` awarded in airdrop:`_id`\r\n     * @param _id Airdrop id\r\n     * @param _recipient Recipient to check\r\n     */\r\n    function awarded(uint _id, address _recipient) public view returns(bool) {\r\n        return airdrops[_id].awarded[_recipient];\r\n    }\r\n}\r\n\r\nabstract contract ITokenManager {\r\n    function mint(address _receiver, uint256 _amount) virtual external;\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Award\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Start\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"airdrops\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"award\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount0s\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount1s\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"_proofs\",\"type\":\"bytes32[][]\"}],\"name\":\"awardFromMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount0s\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount1s\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"_proofs\",\"type\":\"bytes32[][]\"}],\"name\":\"awardToMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"awarded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenManager0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenManager1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_startAuth\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startAuth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenManager0\",\"outputs\":[{\"internalType\":\"contract ITokenManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenManager1\",\"outputs\":[{\"internalType\":\"contract ITokenManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "MerkleTwoDrop", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1c54db7417f5c7703feb6848b4b76fc356c877ad379db13c6423e0f62a8bc57e"}