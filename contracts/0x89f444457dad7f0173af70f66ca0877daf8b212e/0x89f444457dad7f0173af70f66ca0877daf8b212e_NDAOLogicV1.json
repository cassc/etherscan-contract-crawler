{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/governance/NDAOLogicV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n\\n/// @title The Punks DAO logic version 1\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\n// LICENSE\\n// NDAOLogicV1.sol is a modified version of Compound Lab's GovernorBravoDelegate.sol:\\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoDelegate.sol\\n//\\n// GovernorBravoDelegate.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\\n// With modifications by Punk2 DAO.\\n//\\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\\n//\\n// MODIFICATIONS\\n// NDAOLogicV1 adds:\\n// - Proposal Threshold basis points instead of fixed number\\n//   due to the Punk2 token's increasing supply\\n//\\n// - Quorum Votes basis points instead of fixed number\\n//   due to the Punk2 token's increasing supply\\n//\\n// - Per proposal storing of fixed `proposalThreshold`\\n//   and `quorumVotes` calculated using the Punk2 token's total supply\\n//   at the block the proposal was created and the basis point parameters\\n//\\n// - `ProposalCreatedWithRequirements` event that emits `ProposalCreated` parameters with\\n//   the addition of `proposalThreshold` and `quorumVotes`\\n//\\n// - Votes are counted from the block a proposal is created instead of\\n//   the proposal's voting start block to align with the parameters\\n//   stored with the proposal\\n//\\n// - Veto ability which allows `veteor` to halt any proposal at any stage unless\\n//   the proposal is executed.\\n//   The `veto(uint proposalId)` logic is a modified version of `cancel(uint proposalId)`\\n//   A `vetoed` flag was added to the `Proposal` struct to support this.\\n//\\n// NDAOLogicV1 removes:\\n// - `initialProposalId` and `_initiate()` due to this being the\\n//   first instance of the governance contract unlike\\n//   GovernorBravo which upgrades GovernorAlpha\\n//\\n// - Value passed along using `timelock.executeTransaction{value: proposal.value}`\\n//   in `execute(uint proposalId)`. This contract should not hold funds and does not\\n//   implement `receive()` or `fallback()` functions.\\n//\\n\\npragma solidity ^0.8.6;\\n\\nimport './NDAOInterfaces.sol';\\n\\ncontract NDAOLogicV1 is NDAOStorageV1, NDAOEvents {\\n    /// @notice The name of this contract\\n    string public constant name = 'NPunk DAO';\\n\\n    /// @notice The minimum setable proposal threshold\\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\\n\\n    /// @notice The maximum setable proposal threshold\\n    uint256 public constant MAX_PROPOSAL_THRESHOLD_BPS = 1_000; // 1,000 basis points or 10%\\n\\n    /// @notice The minimum setable voting period\\n    uint256 public constant MIN_VOTING_PERIOD = 5_760; // About 24 hours\\n\\n    /// @notice The max setable voting period\\n    uint256 public constant MAX_VOTING_PERIOD = 80_640; // About 2 weeks\\n\\n    /// @notice The min setable voting delay\\n    uint256 public constant MIN_VOTING_DELAY = 1;\\n\\n    /// @notice The max setable voting delay\\n    uint256 public constant MAX_VOTING_DELAY = 40_320; // About 1 week\\n\\n    /// @notice The minimum setable quorum votes basis points\\n    uint256 public constant MIN_QUORUM_VOTES_BPS = 200; // 200 basis points or 2%\\n\\n    /// @notice The maximum setable quorum votes basis points\\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 2_000; // 2,000 basis points or 20%\\n\\n    /// @notice The maximum number of actions that can be included in a proposal\\n    uint256 public constant proposalMaxOperations = 10; // 10 actions\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH =\\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\\n\\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\\n\\n    /**\\n     * @notice Used to initialize the contract during delegator contructor\\n     * @param timelock_ The address of the NDAOExecutor\\n     * @param npunks_ The address of the PUNK2 tokens\\n     * @param cryptopunksVote_ The address of the CryptoPunks Voting contract\\n     * @param vetoer_ The address allowed to unilaterally veto proposals\\n     * @param votingPeriod_ The initial voting period\\n     * @param votingDelay_ The initial voting delay\\n     * @param proposalThresholdBPS_ The initial proposal threshold in basis points\\n     * * @param quorumVotesBPS_ The initial quorum votes threshold in basis points\\n     */\\n    function initialize(\\n        address timelock_,\\n        address npunks_,\\n        address cryptopunksVote_,\\n        address vetoer_,\\n        uint256 votingPeriod_,\\n        uint256 votingDelay_,\\n        uint256 proposalThresholdBPS_,\\n        uint256 quorumVotesBPS_\\n    ) public virtual {\\n        require(address(timelock) == address(0), 'NDAO::initialize: can only initialize once');\\n        require(msg.sender == admin, 'NDAO::initialize: admin only');\\n        require(timelock_ != address(0), 'NDAO::initialize: invalid timelock address');\\n        require(npunks_ != address(0), 'NDAO::initialize: invalid punk2 address');\\n        require(cryptopunksVote_ != address(0), 'NDAO::initialize: invalid cryptopunksVote address');\\n        require(\\n            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\\n            'NDAO::initialize: invalid voting period'\\n        );\\n        require(\\n            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\\n            'NDAO::initialize: invalid voting delay'\\n        );\\n        require(\\n            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\\n            'NDAO::initialize: invalid proposal threshold'\\n        );\\n        require(\\n            quorumVotesBPS_ >= MIN_QUORUM_VOTES_BPS && quorumVotesBPS_ <= MAX_QUORUM_VOTES_BPS,\\n            'NDAO::initialize: invalid proposal threshold'\\n        );\\n\\n        emit VotingPeriodSet(votingPeriod, votingPeriod_);\\n        emit VotingDelaySet(votingDelay, votingDelay_);\\n        emit ProposalThresholdBPSSet(proposalThresholdBPS, proposalThresholdBPS_);\\n        emit QuorumVotesBPSSet(quorumVotesBPS, quorumVotesBPS_);\\n\\n        timelock = IDAOExecutor(timelock_);\\n        npunks = NTokenLike(npunks_);\\n        cryptopunksVote = CryptopunksVote(cryptopunksVote_);\\n        vetoer = vetoer_;\\n        votingPeriod = votingPeriod_;\\n        votingDelay = votingDelay_;\\n        proposalThresholdBPS = proposalThresholdBPS_;\\n        quorumVotesBPS = quorumVotesBPS_;\\n    }\\n\\n    struct ProposalTemp {\\n        uint256 totalSupply;\\n        uint256 proposalThreshold;\\n        uint256 latestProposalId;\\n        uint256 startBlock;\\n        uint256 endBlock;\\n    }\\n\\n    /**\\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\\n     * @param targets Target addresses for proposal calls\\n     * @param values Eth values for proposal calls\\n     * @param signatures Function signatures for proposal calls\\n     * @param calldatas Calldatas for proposal calls\\n     * @param description String description of the proposal\\n     * @return Proposal id of new proposal\\n     */\\n    function propose(\\n        address[] memory targets,\\n        uint256[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas,\\n        string memory description\\n    ) public returns (uint256) {\\n        ProposalTemp memory temp;\\n\\n        temp.totalSupply = npunks.totalSupply() + cryptopunksVote.totalSupply();\\n\\n        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\\n\\n        require(\\n            npunks.getPriorVotes(msg.sender, block.number - 1) +\\n                cryptopunksVote.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\\n            'NDAO::propose: proposer votes below proposal threshold'\\n        );\\n        require(\\n            targets.length == values.length &&\\n                targets.length == signatures.length &&\\n                targets.length == calldatas.length,\\n            'NDAO::propose: proposal function information arity mismatch'\\n        );\\n        require(targets.length != 0, 'NDAO::propose: must provide actions');\\n        require(targets.length <= proposalMaxOperations, 'NDAO::propose: too many actions');\\n\\n        temp.latestProposalId = latestProposalIds[msg.sender];\\n        if (temp.latestProposalId != 0) {\\n            ProposalState proposersLatestProposalState = state(temp.latestProposalId);\\n            require(\\n                proposersLatestProposalState != ProposalState.Active,\\n                'NDAO::propose: one live proposal per proposer, found an already active proposal'\\n            );\\n            require(\\n                proposersLatestProposalState != ProposalState.Pending,\\n                'NDAO::propose: one live proposal per proposer, found an already pending proposal'\\n            );\\n        }\\n\\n        temp.startBlock = block.number + votingDelay;\\n        temp.endBlock = temp.startBlock + votingPeriod;\\n\\n        proposalCount++;\\n        Proposal storage newProposal = proposals[proposalCount];\\n\\n        newProposal.id = proposalCount;\\n        newProposal.proposer = msg.sender;\\n        newProposal.proposalThreshold = temp.proposalThreshold;\\n        newProposal.quorumVotes = bps2Uint(quorumVotesBPS, temp.totalSupply);\\n        newProposal.eta = 0;\\n        newProposal.targets = targets;\\n        newProposal.values = values;\\n        newProposal.signatures = signatures;\\n        newProposal.calldatas = calldatas;\\n        newProposal.startBlock = temp.startBlock;\\n        newProposal.endBlock = temp.endBlock;\\n        newProposal.forVotes = 0;\\n        newProposal.againstVotes = 0;\\n        newProposal.abstainVotes = 0;\\n        newProposal.canceled = false;\\n        newProposal.executed = false;\\n        newProposal.vetoed = false;\\n\\n        latestProposalIds[newProposal.proposer] = newProposal.id;\\n\\n        /// @notice Maintains backwards compatibility with GovernorBravo events\\n        emit ProposalCreated(\\n            newProposal.id,\\n            msg.sender,\\n            targets,\\n            values,\\n            signatures,\\n            calldatas,\\n            newProposal.startBlock,\\n            newProposal.endBlock,\\n            description\\n        );\\n\\n        /// @notice Updated event with `proposalThreshold` and `quorumVotes`\\n        emit ProposalCreatedWithRequirements(\\n            newProposal.id,\\n            msg.sender,\\n            targets,\\n            values,\\n            signatures,\\n            calldatas,\\n            newProposal.startBlock,\\n            newProposal.endBlock,\\n            newProposal.proposalThreshold,\\n            newProposal.quorumVotes,\\n            description\\n        );\\n\\n        return newProposal.id;\\n    }\\n\\n    /**\\n     * @notice Queues a proposal of state succeeded\\n     * @param proposalId The id of the proposal to queue\\n     */\\n    function queue(uint256 proposalId) external {\\n        require(\\n            state(proposalId) == ProposalState.Succeeded,\\n            'NDAO::queue: proposal can only be queued if it is succeeded'\\n        );\\n        Proposal storage proposal = proposals[proposalId];\\n        uint256 eta = block.timestamp + timelock.delay();\\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\\n            queueOrRevertInternal(\\n                proposal.targets[i],\\n                proposal.values[i],\\n                proposal.signatures[i],\\n                proposal.calldatas[i],\\n                eta\\n            );\\n        }\\n        proposal.eta = eta;\\n        emit ProposalQueued(proposalId, eta);\\n    }\\n\\n    function queueOrRevertInternal(\\n        address target,\\n        uint256 value,\\n        string memory signature,\\n        bytes memory data,\\n        uint256 eta\\n    ) internal {\\n        require(\\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\\n            'NDAO::queueOrRevertInternal: identical proposal action already queued at eta'\\n        );\\n        timelock.queueTransaction(target, value, signature, data, eta);\\n    }\\n\\n    /**\\n     * @notice Executes a queued proposal if eta has passed\\n     * @param proposalId The id of the proposal to execute\\n     */\\n    function execute(uint256 proposalId) external {\\n        require(\\n            state(proposalId) == ProposalState.Queued,\\n            'NDAO::execute: proposal can only be executed if it is queued'\\n        );\\n        Proposal storage proposal = proposals[proposalId];\\n        proposal.executed = true;\\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\\n            timelock.executeTransaction(\\n                proposal.targets[i],\\n                proposal.values[i],\\n                proposal.signatures[i],\\n                proposal.calldatas[i],\\n                proposal.eta\\n            );\\n        }\\n        emit ProposalExecuted(proposalId);\\n    }\\n\\n    /**\\n     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\\n     * @param proposalId The id of the proposal to cancel\\n     */\\n    function cancel(uint256 proposalId) external {\\n        require(state(proposalId) != ProposalState.Executed, 'NDAO::cancel: cannot cancel executed proposal');\\n\\n        Proposal storage proposal = proposals[proposalId];\\n        require(\\n            msg.sender == proposal.proposer ||\\n                npunks.getPriorVotes(proposal.proposer, block.number - 1) +\\n                    cryptopunksVote.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold,\\n            'NDAO::cancel: proposer above threshold'\\n        );\\n\\n        proposal.canceled = true;\\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\\n            timelock.cancelTransaction(\\n                proposal.targets[i],\\n                proposal.values[i],\\n                proposal.signatures[i],\\n                proposal.calldatas[i],\\n                proposal.eta\\n            );\\n        }\\n\\n        emit ProposalCanceled(proposalId);\\n    }\\n\\n    /**\\n     * @notice Vetoes a proposal only if sender is the vetoer and the proposal has not been executed.\\n     * @param proposalId The id of the proposal to veto\\n     */\\n    function veto(uint256 proposalId) external {\\n        require(vetoer != address(0), 'NDAO::veto: veto power burned');\\n        require(msg.sender == vetoer, 'NDAO::veto: only vetoer');\\n        require(state(proposalId) != ProposalState.Executed, 'NDAO::veto: cannot veto executed proposal');\\n\\n        Proposal storage proposal = proposals[proposalId];\\n\\n        proposal.vetoed = true;\\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\\n            timelock.cancelTransaction(\\n                proposal.targets[i],\\n                proposal.values[i],\\n                proposal.signatures[i],\\n                proposal.calldatas[i],\\n                proposal.eta\\n            );\\n        }\\n\\n        emit ProposalVetoed(proposalId);\\n    }\\n\\n    /**\\n     * @notice Gets actions of a proposal\\n     * @param proposalId the id of the proposal\\n     * @return targets\\n     * @return values\\n     * @return signatures\\n     * @return calldatas\\n     */\\n    function getActions(uint256 proposalId)\\n        external\\n        view\\n        returns (\\n            address[] memory targets,\\n            uint256[] memory values,\\n            string[] memory signatures,\\n            bytes[] memory calldatas\\n        )\\n    {\\n        Proposal storage p = proposals[proposalId];\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\n    }\\n\\n    /**\\n     * @notice Gets the receipt for a voter on a given proposal\\n     * @param proposalId the id of proposal\\n     * @param voter The address of the voter\\n     * @return The voting receipt\\n     */\\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory) {\\n        return proposals[proposalId].receipts[voter];\\n    }\\n\\n    /**\\n     * @notice Gets the state of a proposal\\n     * @param proposalId The id of the proposal\\n     * @return Proposal state\\n     */\\n    function state(uint256 proposalId) public view returns (ProposalState) {\\n        require(proposalCount >= proposalId, 'NDAO::state: invalid proposal id');\\n        Proposal storage proposal = proposals[proposalId];\\n        if (proposal.vetoed) {\\n            return ProposalState.Vetoed;\\n        } else if (proposal.canceled) {\\n            return ProposalState.Canceled;\\n        } else if (block.number <= proposal.startBlock) {\\n            return ProposalState.Pending;\\n        } else if (block.number <= proposal.endBlock) {\\n            return ProposalState.Active;\\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\\n            return ProposalState.Defeated;\\n        } else if (proposal.eta == 0) {\\n            return ProposalState.Succeeded;\\n        } else if (proposal.executed) {\\n            return ProposalState.Executed;\\n        } else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\\n            return ProposalState.Expired;\\n        } else {\\n            return ProposalState.Queued;\\n        }\\n    }\\n\\n    /**\\n     * @notice Cast a vote for a proposal\\n     * @param proposalId The id of the proposal to vote on\\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\\n     */\\n    function castVote(uint256 proposalId, uint8 support) external {\\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), '');\\n    }\\n\\n    /**\\n     * @notice Cast a vote for a proposal with a reason\\n     * @param proposalId The id of the proposal to vote on\\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\\n     * @param reason The reason given for the vote by the voter\\n     */\\n    function castVoteWithReason(\\n        uint256 proposalId,\\n        uint8 support,\\n        string calldata reason\\n    ) external {\\n        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\\n    }\\n\\n    /**\\n     * @notice Cast a vote for a proposal by signature\\n     * @dev External function that accepts EIP-712 signatures for voting on proposals.\\n     */\\n    function castVoteBySig(\\n        uint256 proposalId,\\n        uint8 support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this))\\n        );\\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\\n        bytes32 digest = keccak256(abi.encodePacked('\\\\x19\\\\x01', domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), 'NDAO::castVoteBySig: invalid signature');\\n        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), '');\\n    }\\n\\n    /**\\n     * @notice Internal function that caries out voting logic\\n     * @param voter The voter that is casting their vote\\n     * @param proposalId The id of the proposal to vote on\\n     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\\n     * @return The number of votes cast\\n     */\\n    function castVoteInternal(\\n        address voter,\\n        uint256 proposalId,\\n        uint8 support\\n    ) internal returns (uint96) {\\n        require(state(proposalId) == ProposalState.Active, 'NDAO::castVoteInternal: voting is closed');\\n        require(support <= 2, 'NDAO::castVoteInternal: invalid vote type');\\n        Proposal storage proposal = proposals[proposalId];\\n        Receipt storage receipt = proposal.receipts[voter];\\n        require(receipt.hasVoted == false, 'NDAO::castVoteInternal: voter already voted');\\n\\n        /// @notice: Unlike GovernerBravo, votes are considered from the block the proposal was created in order to normalize quorumVotes and proposalThreshold metrics\\n        uint96 votes =\\n            npunks.getPriorVotes(voter, proposal.startBlock - votingDelay) +\\n            cryptopunksVote.getPriorVotes(voter, proposal.startBlock - votingDelay);\\n\\n        if (support == 0) {\\n            proposal.againstVotes = proposal.againstVotes + votes;\\n        } else if (support == 1) {\\n            proposal.forVotes = proposal.forVotes + votes;\\n        } else if (support == 2) {\\n            proposal.abstainVotes = proposal.abstainVotes + votes;\\n        }\\n\\n        receipt.hasVoted = true;\\n        receipt.support = support;\\n        receipt.votes = votes;\\n\\n        return votes;\\n    }\\n\\n    /**\\n     * @notice Admin function for setting the voting delay\\n     * @param newVotingDelay new voting delay, in blocks\\n     */\\n    function _setVotingDelay(uint256 newVotingDelay) external {\\n        require(msg.sender == admin, 'NDAO::_setVotingDelay: admin only');\\n        require(\\n            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\\n            'NDAO::_setVotingDelay: invalid voting delay'\\n        );\\n        uint256 oldVotingDelay = votingDelay;\\n        votingDelay = newVotingDelay;\\n\\n        emit VotingDelaySet(oldVotingDelay, votingDelay);\\n    }\\n\\n    /**\\n     * @notice Admin function for setting the voting period\\n     * @param newVotingPeriod new voting period, in blocks\\n     */\\n    function _setVotingPeriod(uint256 newVotingPeriod) external {\\n        require(msg.sender == admin, 'NDAO::_setVotingPeriod: admin only');\\n        require(\\n            newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\\n            'NDAO::_setVotingPeriod: invalid voting period'\\n        );\\n        uint256 oldVotingPeriod = votingPeriod;\\n        votingPeriod = newVotingPeriod;\\n\\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\\n    }\\n\\n    /**\\n     * @notice Admin function for setting the proposal threshold basis points\\n     * @dev newProposalThresholdBPS must be greater than the hardcoded min\\n     * @param newProposalThresholdBPS new proposal threshold\\n     */\\n    function _setProposalThresholdBPS(uint256 newProposalThresholdBPS) external {\\n        require(msg.sender == admin, 'NDAO::_setProposalThresholdBPS: admin only');\\n        require(\\n            newProposalThresholdBPS >= MIN_PROPOSAL_THRESHOLD_BPS &&\\n                newProposalThresholdBPS <= MAX_PROPOSAL_THRESHOLD_BPS,\\n            'NDAO::_setProposalThreshold: invalid proposal threshold'\\n        );\\n        uint256 oldProposalThresholdBPS = proposalThresholdBPS;\\n        proposalThresholdBPS = newProposalThresholdBPS;\\n\\n        emit ProposalThresholdBPSSet(oldProposalThresholdBPS, proposalThresholdBPS);\\n    }\\n\\n    /**\\n     * @notice Admin function for setting the quorum votes basis points\\n     * @dev newQuorumVotesBPS must be greater than the hardcoded min\\n     * @param newQuorumVotesBPS new proposal threshold\\n     */\\n    function _setQuorumVotesBPS(uint256 newQuorumVotesBPS) external {\\n        require(msg.sender == admin, 'NDAO::_setQuorumVotesBPS: admin only');\\n        require(\\n            newQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS && newQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS,\\n            'NDAO::_setProposalThreshold: invalid proposal threshold'\\n        );\\n        uint256 oldQuorumVotesBPS = quorumVotesBPS;\\n        quorumVotesBPS = newQuorumVotesBPS;\\n\\n        emit QuorumVotesBPSSet(oldQuorumVotesBPS, quorumVotesBPS);\\n    }\\n\\n    /**\\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n     * @param newPendingAdmin New pending admin.\\n     */\\n    function _setPendingAdmin(address newPendingAdmin) external {\\n        // Check caller = admin\\n        require(msg.sender == admin, 'NDAO::_setPendingAdmin: admin only');\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n    }\\n\\n    /**\\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n     * @dev Admin function for pending admin to accept role and update admin\\n     */\\n    function _acceptAdmin() external {\\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\\n        require(msg.sender == pendingAdmin && msg.sender != address(0), 'NDAO::_acceptAdmin: pending admin only');\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n    }\\n\\n    /**\\n     * @notice Changes vetoer address\\n     * @dev Vetoer function for updating vetoer address\\n     */\\n    function _setVetoer(address newVetoer) public {\\n        require(msg.sender == vetoer, 'NDAO::_setVetoer: vetoer only');\\n\\n        emit NewVetoer(vetoer, newVetoer);\\n\\n        vetoer = newVetoer;\\n    }\\n\\n    /**\\n     * @notice Burns veto priviledges\\n     * @dev Vetoer function destroying veto power forever\\n     */\\n    function _burnVetoPower() public {\\n        // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\\n        require(msg.sender == vetoer, 'NDAO::_burnVetoPower: vetoer only');\\n\\n        _setVetoer(address(0));\\n    }\\n\\n    /**\\n     * @notice Current proposal threshold using Punk2 Total Supply\\n     * Differs from `GovernerBravo` which uses fixed amount\\n     */\\n    function proposalThreshold() public view returns (uint256) {\\n        return bps2Uint(proposalThresholdBPS, npunks.totalSupply() + cryptopunksVote.totalSupply());\\n    }\\n\\n    /**\\n     * @notice Current quorum votes using Punk2 Total Supply\\n     * Differs from `GovernerBravo` which uses fixed amount\\n     */\\n    function quorumVotes() public view returns (uint256) {\\n        return bps2Uint(quorumVotesBPS, npunks.totalSupply() + cryptopunksVote.totalSupply());\\n    }\\n\\n    function bps2Uint(uint256 bps, uint256 number) internal pure returns (uint256) {\\n        return (number * bps) / 10000;\\n    }\\n\\n    function getChainIdInternal() internal view returns (uint256) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        return chainId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/NDAOInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n\\n/// @title Punks DAO Logic interfaces and events\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\n// LICENSE\\n// NDAOInterfaces.sol is a modified version of Compound Lab's GovernorBravoInterfaces.sol:\\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoInterfaces.sol\\n//\\n// GovernorBravoInterfaces.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\\n// With modifications by Nounders DAO.\\n//\\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\\n//\\n// MODIFICATIONS\\n// NDAOEvents, NDAOProxyStorage, NDAOStorageV1 adds support for changes made by NDAO to GovernorBravo.sol\\n// See NDAOLogicV1.sol for more details.\\n\\npragma solidity ^0.8.6;\\n\\nimport \\\"../CryptopunksVote.sol\\\";\\n\\ncontract NDAOEvents {\\n    /// @notice An event emitted when a new proposal is created\\n    event ProposalCreated(\\n        uint256 id,\\n        address proposer,\\n        address[] targets,\\n        uint256[] values,\\n        string[] signatures,\\n        bytes[] calldatas,\\n        uint256 startBlock,\\n        uint256 endBlock,\\n        string description\\n    );\\n\\n    event ProposalCreatedWithRequirements(\\n        uint256 id,\\n        address proposer,\\n        address[] targets,\\n        uint256[] values,\\n        string[] signatures,\\n        bytes[] calldatas,\\n        uint256 startBlock,\\n        uint256 endBlock,\\n        uint256 proposalThreshold,\\n        uint256 quorumVotes,\\n        string description\\n    );\\n\\n    /// @notice An event emitted when a vote has been cast on a proposal\\n    /// @param voter The address which casted a vote\\n    /// @param proposalId The proposal id which was voted on\\n    /// @param support Support value for the vote. 0=against, 1=for, 2=abstain\\n    /// @param votes Number of votes which were cast by the voter\\n    /// @param reason The reason given for the vote by the voter\\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 votes, string reason);\\n\\n    /// @notice An event emitted when a proposal has been canceled\\n    event ProposalCanceled(uint256 id);\\n\\n    /// @notice An event emitted when a proposal has been queued in the NDAOExecutor\\n    event ProposalQueued(uint256 id, uint256 eta);\\n\\n    /// @notice An event emitted when a proposal has been executed in the NDAOExecutor\\n    event ProposalExecuted(uint256 id);\\n\\n    /// @notice An event emitted when a proposal has been vetoed by vetoAddress\\n    event ProposalVetoed(uint256 id);\\n\\n    /// @notice An event emitted when the voting delay is set\\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\\n\\n    /// @notice An event emitted when the voting period is set\\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\\n\\n    /// @notice Emitted when implementation is changed\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /// @notice Emitted when proposal threshold basis points is set\\n    event ProposalThresholdBPSSet(uint256 oldProposalThresholdBPS, uint256 newProposalThresholdBPS);\\n\\n    /// @notice Emitted when quorum votes basis points is set\\n    event QuorumVotesBPSSet(uint256 oldQuorumVotesBPS, uint256 newQuorumVotesBPS);\\n\\n    /// @notice Emitted when pendingAdmin is changed\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    /// @notice Emitted when vetoer is changed\\n    event NewVetoer(address oldVetoer, address newVetoer);\\n}\\n\\ncontract NDAOProxyStorage {\\n    /// @notice Administrator for this contract\\n    address public admin;\\n\\n    /// @notice Pending administrator for this contract\\n    address public pendingAdmin;\\n\\n    /// @notice Active brains of Governor\\n    address public implementation;\\n}\\n\\n/**\\n * @title Storage for Governor Bravo Delegate\\n * @notice For future upgrades, do not change NDAOStorageV1. Create a new\\n * contract which implements DAOStorageV1 and following the naming convention\\n * NDAOStorageVX.\\n */\\ncontract NDAOStorageV1 is NDAOProxyStorage {\\n    /// @notice Vetoer who has the ability to veto any proposal\\n    address public vetoer;\\n\\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\\n    uint256 public votingDelay;\\n\\n    /// @notice The duration of voting on a proposal, in blocks\\n    uint256 public votingPeriod;\\n\\n    /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\\n    uint256 public proposalThresholdBPS;\\n\\n    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\\n    uint256 public quorumVotesBPS;\\n\\n    /// @notice The total number of proposals\\n    uint256 public proposalCount;\\n\\n    /// @notice The address of the NDAO Executor NDAOExecutor\\n    IDAOExecutor public timelock;\\n\\n    /// @notice The address of the Punk2 tokens\\n    NTokenLike public npunks;\\n\\n    /// @notice The official record of all proposals ever proposed\\n    mapping(uint256 => Proposal) public proposals;\\n\\n    /// @notice The latest proposal for each proposer\\n    mapping(address => uint256) public latestProposalIds;\\n\\n    /// @notice The address of Cryptopunks Voting Contract\\n    CryptopunksVote public cryptopunksVote;\\n\\n    struct Proposal {\\n        /// @notice Unique id for looking up a proposal\\n        uint256 id;\\n        /// @notice Creator of the proposal\\n        address proposer;\\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\\n        uint256 proposalThreshold;\\n        /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\\n        uint256 quorumVotes;\\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint256 eta;\\n        /// @notice the ordered list of target addresses for calls to be made\\n        address[] targets;\\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n        uint256[] values;\\n        /// @notice The ordered list of function signatures to be called\\n        string[] signatures;\\n        /// @notice The ordered list of calldata to be passed to each call\\n        bytes[] calldatas;\\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint256 startBlock;\\n        /// @notice The block at which voting ends: votes must be cast prior to this block\\n        uint256 endBlock;\\n        /// @notice Current number of votes in favor of this proposal\\n        uint256 forVotes;\\n        /// @notice Current number of votes in opposition to this proposal\\n        uint256 againstVotes;\\n        /// @notice Current number of votes for abstaining for this proposal\\n        uint256 abstainVotes;\\n        /// @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n        /// @notice Flag marking whether the proposal has been vetoed\\n        bool vetoed;\\n        /// @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n        /// @notice Receipts of ballots for the entire set of voters\\n        mapping(address => Receipt) receipts;\\n    }\\n\\n    /// @notice Ballot receipt record for a voter\\n    struct Receipt {\\n        /// @notice Whether or not a vote has been cast\\n        bool hasVoted;\\n        /// @notice Whether or not the voter supports the proposal or abstains\\n        uint8 support;\\n        /// @notice The number of votes the voter had, which were cast\\n        uint96 votes;\\n    }\\n\\n    /// @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed,\\n        Vetoed\\n    }\\n}\\n\\ninterface IDAOExecutor {\\n    function delay() external view returns (uint256);\\n\\n    function GRACE_PERIOD() external view returns (uint256);\\n\\n    function acceptAdmin() external;\\n\\n    function queuedTransactions(bytes32 hash) external view returns (bool);\\n\\n    function queueTransaction(\\n        address target,\\n        uint256 value,\\n        string calldata signature,\\n        bytes calldata data,\\n        uint256 eta\\n    ) external returns (bytes32);\\n\\n    function cancelTransaction(\\n        address target,\\n        uint256 value,\\n        string calldata signature,\\n        bytes calldata data,\\n        uint256 eta\\n    ) external;\\n\\n    function executeTransaction(\\n        address target,\\n        uint256 value,\\n        string calldata signature,\\n        bytes calldata data,\\n        uint256 eta\\n    ) external payable returns (bytes memory);\\n}\\n\\ninterface NTokenLike {\\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\\n\\n    function totalSupply() external view returns (uint96);\\n}\\n\"\r\n    },\r\n    \"contracts/CryptopunksVote.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface ICryptopunks {\\n    function punkIndexToAddress(uint256 punkIndex) view external returns(address);\\n}\\n\\ncontract CryptopunksVote is EIP712 {\\n\\n    /// @notice A record of each punkIndex delegate\\n    mapping(uint256 => address) private _delegates;\\n\\n    /// @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint96 votes;\\n    }\\n\\n    /// @notice A record of votes checkpoints for each account, by index\\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\\n\\n    /// @notice The number of checkpoints for each account\\n    mapping(address => uint32) public numCheckpoints;\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH =\\n        keccak256('Delegation(address delegatee,uint256 punkIndex,uint256 nonce,uint256 expiry)');\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_BATCH_TYPEHASH =\\n        keccak256('DelegationBatch(address delegatee,uint256[] punkIndexes,uint256 nonce,uint256 expiry)');\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping(address => uint256) public nonces;\\n\\n    ICryptopunks public immutable cryptopunks;\\n    IERC721 public immutable wrappedPunk;\\n    uint256 internal constant CRYPTOPUNKS_TOTAL_SUPPLY = 10_000;\\n    /// @dev just for convenience, user cannot delegate to zero address\\n    address internal constant TOTAL_SUPPLY_HOLDER = address(0);\\n\\n    /**\\n     * @dev Emitted when a punk changes its delegate.\\n     * IERC5805 not compliant\\n     */\\n    event DelegateChanged(address delegator, address indexed fromDelegate, address indexed toDelegate, uint256 indexed punkIndex);\\n\\n    /**\\n     * @dev Emitted when a delegate change results in changes to a delegate's number of votes.\\n     * IERC5805 compliant\\n     */\\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\\n\\n    constructor(address cryptopunks_, address wrappedPunk_) EIP712(\\\"CryptopunksVote\\\", \\\"1.0\\\") {\\n        require(cryptopunks_ != address (0), \\\"CryptopunksVote: zero address of cryptopunks\\\");\\n        require(wrappedPunk_ != address (0), \\\"CryptopunksVote: zero address of wrappedPunk\\\");\\n        cryptopunks = ICryptopunks(cryptopunks_);\\n        wrappedPunk = IERC721(wrappedPunk_);\\n    }\\n\\n    /**\\n     * @dev Returns the current amount of votes that `account` has.\\n     * IERC5805 compliant\\n     */\\n    function getVotes(address account) external view returns (uint256) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @dev the same as getVotes() but Compound compatible\\n     */\\n    function getCurrentVotes(address account) external view returns (uint96) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value the end of the corresponding block.\\n     * IERC5805 compliant\\n     */\\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256) {\\n        return _getPriorVotes(account, timepoint);\\n    }\\n\\n    /**\\n     * @dev the same as getVotes() but Compound compatible\\n     */\\n    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\\n        return _getPriorVotes(account, blockNumber);\\n    }\\n\\n    function totalSupply() external pure returns (uint256) {\\n        return CRYPTOPUNKS_TOTAL_SUPPLY;\\n    }\\n\\n    function totalDelegated() external view returns (uint256) {\\n        uint32 nCheckpoints = numCheckpoints[TOTAL_SUPPLY_HOLDER];\\n        return nCheckpoints > 0 ? checkpoints[TOTAL_SUPPLY_HOLDER][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\\n     * configured to use block numbers, this will return the value the end of the corresponding block.\\n     *\\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\\n     * vote.\\n     *\\n     * IERC5805 compliant\\n     *\\n     * Returns always 10_000 as there are 10_000 OG punks\\n     */\\n    function getPastTotalSupply(uint256 /*timepoint*/) external pure returns (uint256) {\\n        return CRYPTOPUNKS_TOTAL_SUPPLY;\\n    }\\n\\n    /**\\n     * @dev Returns the number of delegated votes.\\n     * It is provided in the case a project would want to refer to delegated votes/punks instead of all OG punks.\\n     */\\n    function getPastTotalDelegated(uint256 timepoint) external view returns (uint256) {\\n        return _getPriorVotes(TOTAL_SUPPLY_HOLDER, timepoint);\\n    }\\n\\n    function _getPriorVotes(address account, uint256 blockNumber) internal view returns (uint96) {\\n        require(blockNumber < block.number, 'CryptopunksVote: not yet determined');\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    /**\\n     * @dev Returns the delegate that `account` has chosen.\\n     * IERC5805 not compliant\\n     */\\n    function delegates(uint256 punkIndex) external view returns (address) {\\n        require(punkIndex < CRYPTOPUNKS_TOTAL_SUPPLY, \\\"CryptopunksVote: invalid punkIndex\\\");\\n        return _delegates[punkIndex];\\n    }\\n\\n    /**\\n     * @dev Returns the delegate that `account` has chosen in a batch.\\n     * IERC5805 not compliant\\n     */\\n    function delegatesBatch(uint256[] memory punkIndexes) external view returns (address[] memory) {\\n        address[] memory delegateAddresses = new address[](punkIndexes.length);\\n        for (uint256 i = 0 ; i < punkIndexes.length ; i++ ) {\\n            delegateAddresses[i] = _delegates[punkIndexes[i]];\\n\\n        }\\n        return delegateAddresses;\\n    }\\n\\n    /**\\n     * @dev Delegates votes from the sender to `delegatee`.\\n     * IERC5805 not compliant\\n     */\\n    function delegate(address delegatee, uint256 punkIndex) external {\\n        _delegate(msg.sender, delegatee, punkIndex);\\n    }\\n\\n    /**\\n     * @dev Delegates votes from the sender to `delegatee`.\\n     * Must be eligible for each punk.\\n     * IERC5805 not compliant\\n     */\\n    function delegateBatch(address delegatee, uint256[] memory punkIndexes) external {\\n        for (uint256 i = 0 ; i < punkIndexes.length ; i++ ) {\\n            _delegate(msg.sender, delegatee, punkIndexes[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Delegates votes from signer to `delegatee`.\\n     * IERC5805 not compliant\\n     */\\n    function delegateBySig(address delegatee, uint256 punkIndex, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external {\\n        require(block.timestamp <= expiry, \\\"CryptopunksVote: signature expired\\\");\\n        address signatory = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, punkIndex, nonce, expiry))),\\n            v,\\n            r,\\n            s\\n        );\\n        require(nonce == nonces[signatory]++, \\\"CryptopunksVote: invalid nonce\\\");\\n        _delegate(signatory, delegatee, punkIndex);\\n    }\\n\\n    /**\\n     * @dev Delegates votes from signer to `delegatee`.\\n     * Must be eligible for each punk.\\n     * IERC5805 not compliant\\n     */\\n    function delegateBatchBySig(address delegatee, uint256[] memory punkIndexes, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external {\\n        require(block.timestamp <= expiry, \\\"CryptopunksVote: signature expired\\\");\\n        address signatory = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(DELEGATION_BATCH_TYPEHASH, delegatee, keccak256(abi.encodePacked(punkIndexes)), nonce, expiry))),\\n            v,\\n            r,\\n            s\\n        );\\n        require(nonce == nonces[signatory]++, \\\"CryptopunksVote: invalid nonce\\\");\\n        for (uint256 i = 0 ; i < punkIndexes.length ; i++ ) {\\n            _delegate(signatory, delegatee, punkIndexes[i]);\\n        }\\n    }\\n\\n    function _delegate(address delegator, address delegatee, uint256 punkIndex) internal {\\n        require(punkIndex < CRYPTOPUNKS_TOTAL_SUPPLY, \\\"CryptopunksVote: invalid punkIndex\\\");\\n        require(block.number < type(uint32).max, \\\"CryptopunksVote: max block exceeded\\\");\\n        require(delegatee != address(0), \\\"CryptopunksVote: invalid delegatee\\\");\\n        address prevDelegatee = _delegates[punkIndex];\\n        address owner = cryptopunks.punkIndexToAddress(punkIndex);\\n        if (owner == address(wrappedPunk)) {\\n            owner = wrappedPunk.ownerOf(punkIndex);\\n            require(\\n                delegator == prevDelegatee\\n                || delegator == owner\\n                || delegator == wrappedPunk.getApproved(punkIndex)\\n                || wrappedPunk.isApprovedForAll(owner, delegator),\\n                \\\"CryptopunksVote: illegal delegation\\\"\\n            );\\n        } else {\\n            require(\\n                delegator == prevDelegatee || delegator == owner,\\n                \\\"CryptopunksVote: illegal delegation\\\"\\n            );\\n        }\\n\\n        _delegates[punkIndex] = delegatee;\\n\\n        if (prevDelegatee != delegatee) {\\n            if (prevDelegatee != address(0)) {\\n                uint32 nCheckpoints = numCheckpoints[prevDelegatee];\\n                uint96 newVotes = checkpoints[prevDelegatee][nCheckpoints - 1].votes - 1;\\n                _writeCheckpointAndEvent(prevDelegatee, nCheckpoints, newVotes);\\n            } else {\\n                uint32 nCheckpoints = numCheckpoints[TOTAL_SUPPLY_HOLDER];\\n                uint96 newVotes = nCheckpoints > 0 ? checkpoints[TOTAL_SUPPLY_HOLDER][nCheckpoints - 1].votes + 1: 1;\\n                _writeCheckpoint(TOTAL_SUPPLY_HOLDER, nCheckpoints, newVotes);\\n            }\\n            // a block just to prevent variable shadowing warnings\\n            {\\n                uint32 nCheckpoints = numCheckpoints[delegatee];\\n                uint96 newVotes = nCheckpoints > 0 ? checkpoints[delegatee][nCheckpoints - 1].votes + 1: 1;\\n                _writeCheckpointAndEvent(delegatee, nCheckpoints, newVotes);\\n            }\\n        }\\n\\n        emit DelegateChanged(delegator, prevDelegatee, delegatee, punkIndex);\\n    }\\n\\n    function _writeCheckpoint(\\n        address delegatee,\\n        uint32 nCheckpoints,\\n        uint96 newVotes\\n    ) internal {\\n        // all operations are safe,\\n        unchecked {\\n            // range check already done\\n            uint32 blockNumber = uint32(block.number);\\n\\n            if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n                checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n            } else {\\n                checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n                numCheckpoints[delegatee] = nCheckpoints + 1;\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpointAndEvent(\\n        address delegatee,\\n        uint32 nCheckpoints,\\n        uint96 newVotes\\n    ) internal {\\n        // all operations are safe,\\n        unchecked {\\n            // range check already done\\n            uint32 blockNumber = uint32(block.number);\\n\\n            if (nCheckpoints == 0) {\\n                emit DelegateVotesChanged(delegatee, 0, newVotes);\\n                checkpoints[delegatee][0] = Checkpoint(blockNumber, newVotes);\\n                numCheckpoints[delegatee] = 1;\\n            } else if (checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n                emit DelegateVotesChanged(delegatee, checkpoints[delegatee][nCheckpoints - 1].votes, newVotes);\\n                checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n            } else {\\n                emit DelegateVotesChanged(delegatee, checkpoints[delegatee][nCheckpoints - 1].votes, newVotes);\\n                checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n                numCheckpoints[delegatee] = nCheckpoints + 1;\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"NewImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldVetoer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newVetoer\",\"type\":\"address\"}],\"name\":\"NewVetoer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quorumVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalCreatedWithRequirements\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"ProposalQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldProposalThresholdBPS\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProposalThresholdBPS\",\"type\":\"uint256\"}],\"name\":\"ProposalThresholdBPSSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ProposalVetoed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldQuorumVotesBPS\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newQuorumVotesBPS\",\"type\":\"uint256\"}],\"name\":\"QuorumVotesBPSSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"VoteCast\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldVotingDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVotingDelay\",\"type\":\"uint256\"}],\"name\":\"VotingDelaySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldVotingPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVotingPeriod\",\"type\":\"uint256\"}],\"name\":\"VotingPeriodSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BALLOT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PROPOSAL_THRESHOLD_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_QUORUM_VOTES_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VOTING_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VOTING_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_PROPOSAL_THRESHOLD_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_QUORUM_VOTES_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_VOTING_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_VOTING_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnVetoPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newProposalThresholdBPS\",\"type\":\"uint256\"}],\"name\":\"_setProposalThresholdBPS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newQuorumVotesBPS\",\"type\":\"uint256\"}],\"name\":\"_setQuorumVotesBPS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newVetoer\",\"type\":\"address\"}],\"name\":\"_setVetoer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVotingDelay\",\"type\":\"uint256\"}],\"name\":\"_setVotingDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVotingPeriod\",\"type\":\"uint256\"}],\"name\":\"_setVotingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"}],\"name\":\"castVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"castVoteBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"castVoteWithReason\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cryptopunksVote\",\"outputs\":[{\"internalType\":\"contract CryptopunksVote\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getActions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getReceipt\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"},{\"internalType\":\"uint96\",\"name\":\"votes\",\"type\":\"uint96\"}],\"internalType\":\"struct NDAOStorageV1.Receipt\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"timelock_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"npunks_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cryptopunksVote_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vetoer_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"votingPeriod_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingDelay_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"proposalThresholdBPS_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumVotesBPS_\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"latestProposalIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"npunks\",\"outputs\":[{\"internalType\":\"contract NTokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalMaxOperations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalThresholdBPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"proposalThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quorumVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"abstainVotes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"vetoed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorumVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorumVotesBPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum NDAOStorageV1.ProposalState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelock\",\"outputs\":[{\"internalType\":\"contract IDAOExecutor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"veto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vetoer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NDAOLogicV1", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}