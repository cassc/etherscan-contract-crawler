{"SourceCode": "//SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.11;\r\n\r\n\r\ncontract Context {\r\n\r\n    constructor() {}\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, 'SafeMath: addition overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, 'SafeMath: subtraction overflow');\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, 'SafeMath: division by zero');\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, 'SafeMath: modulo by zero');\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeBEP20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IBEP20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IBEP20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            'SafeBEP20: approve from non-zero to non-zero allowance'\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value,\r\n            'SafeBEP20: decreased allowance below zero'\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n\r\n        bytes memory returndata = address(token).functionCall(data, 'SafeBEP20: low-level call failed');\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), 'SafeBEP20: BEP20 operation did not succeed');\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n        (bool success, ) = recipient.call{value: amount}('');\r\n        require(success, 'Address: unable to send value, recipient may have reverted');\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, 'Address: low-level call failed');\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, 'Address: insufficient balance for call');\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), 'Address: call to non-contract');\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract FixedAPR is Ownable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    struct UserInfo {\r\n        uint256 amount;     \r\n        uint256 rewardDebt; \r\n    }\r\n\r\n    struct PoolInfo {\r\n        IBEP20 lpToken;           \r\n        uint256 allocPoint;       \r\n        uint256 lastRewardTimestamp; \r\n        uint256 accTokensPerShare; \r\n    }\r\n\r\n    IBEP20 public immutable stakingToken;\r\n    IBEP20 public immutable rewardToken;\r\n    mapping (address => uint256) public holderUnlockTime;\r\n\r\n    uint256 public totalStaked;\r\n    uint256 public apy;\r\n\r\n    PoolInfo[] public poolInfo;\r\n    mapping (address => UserInfo) public userInfo;\r\n    uint256 private totalAllocPoint = 0;\r\n\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 amount);\r\n\r\n    constructor(address _stakingToken, address _rewardToken) {\r\n        stakingToken = IBEP20(_stakingToken);\r\n        rewardToken = IBEP20(_rewardToken);\r\n\r\n        apy = 50;\r\n\r\n        // staking pool\r\n        poolInfo.push(PoolInfo({\r\n            lpToken: stakingToken,\r\n            allocPoint: 1000,\r\n            lastRewardTimestamp: 99999999,\r\n            accTokensPerShare: 0\r\n        }));\r\n\r\n        totalAllocPoint = 1000;\r\n\r\n    }\r\n\r\n    function stopReward() external onlyOwner {\r\n        updatePool(0);\r\n        apy = 0;\r\n    }\r\n\r\n    function startReward() external onlyOwner {\r\n        require(poolInfo[0].lastRewardTimestamp == 99999999, \"Can only start rewards once\");\r\n        poolInfo[0].lastRewardTimestamp = block.timestamp;\r\n    }\r\n\r\n    function pendingReward(address _user) external view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo[0];\r\n        UserInfo storage user = userInfo[_user];\r\n        if(pool.lastRewardTimestamp == 99999999){\r\n            return 0;\r\n        }\r\n        uint256 accTokensPerShare = pool.accTokensPerShare;\r\n        uint256 lpSupply = totalStaked;\r\n        if (block.timestamp > pool.lastRewardTimestamp && lpSupply != 0) {\r\n            uint256 tokenReward = calculateNewRewards().mul(pool.allocPoint).div(totalAllocPoint);\r\n            accTokensPerShare = accTokensPerShare.add(tokenReward.mul(1e18).div(lpSupply));\r\n        }\r\n        return user.amount.mul(accTokensPerShare).div(1e18).sub(user.rewardDebt);\r\n    }\r\n\r\n    function updatePool(uint256 _pid) internal {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.timestamp <= pool.lastRewardTimestamp) {\r\n            return;\r\n        }\r\n        uint256 lpSupply = totalStaked;\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardTimestamp = block.timestamp;\r\n            return;\r\n        }\r\n        uint256 tokenReward = calculateNewRewards().mul(pool.allocPoint).div(totalAllocPoint);\r\n        pool.accTokensPerShare = pool.accTokensPerShare.add(tokenReward.mul(1e18).div(lpSupply));\r\n        pool.lastRewardTimestamp = block.timestamp;\r\n    }\r\n\r\n    function massUpdatePools() public onlyOwner {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    function deposit(uint256 _amount) public nonReentrant {\r\n        if(holderUnlockTime[msg.sender] == 0){\r\n            holderUnlockTime[msg.sender] = block.timestamp;\r\n        }\r\n        PoolInfo storage pool = poolInfo[0];\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        updatePool(0);\r\n        if (user.amount > 0) {\r\n            uint256 pending = user.amount.mul(pool.accTokensPerShare).div(1e18).sub(user.rewardDebt);\r\n            if(pending > 0) {\r\n                require(pending <= rewardsRemaining(), \"Cannot withdraw other people's staked tokens.  Contact an admin.\");\r\n                rewardToken.safeTransfer(address(msg.sender), pending);\r\n            }\r\n        }\r\n        uint256 amountTransferred = 0;\r\n        if(_amount > 0) {\r\n            uint256 initialBalance = pool.lpToken.balanceOf(address(this));\r\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n            amountTransferred = pool.lpToken.balanceOf(address(this)) - initialBalance;\r\n            user.amount = user.amount.add(amountTransferred);\r\n            totalStaked += amountTransferred;\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accTokensPerShare).div(1e18);\r\n\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    function withdraw() public nonReentrant {\r\n        \r\n        PoolInfo storage pool = poolInfo[0];\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        uint256 _amount = user.amount;\r\n        updatePool(0);\r\n        uint256 pending = user.amount.mul(pool.accTokensPerShare).div(1e18).sub(user.rewardDebt);\r\n        if(pending > 0) {\r\n            require(pending <= rewardsRemaining(), \"Cannot withdraw other people's staked tokens.  Contact an admin.\");\r\n            rewardToken.safeTransfer(address(msg.sender), pending);\r\n        }\r\n\r\n        if(_amount > 0) {\r\n            user.amount = 0;\r\n            totalStaked -= _amount;\r\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\r\n        }\r\n\r\n        user.rewardDebt = user.amount.mul(pool.accTokensPerShare).div(1e18);\r\n        \r\n        if(user.amount > 0){\r\n            holderUnlockTime[msg.sender] = block.timestamp;\r\n        } else {\r\n            holderUnlockTime[msg.sender] = 0;\r\n        }\r\n\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    function emergencyWithdraw() external nonReentrant {\r\n        PoolInfo storage pool = poolInfo[0];\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 _amount = user.amount;\r\n        totalStaked -= _amount;\r\n        holderUnlockTime[msg.sender] = 0;\r\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        emit EmergencyWithdraw(msg.sender, _amount);\r\n    }\r\n\r\n    function emergencyRewardWithdraw(uint256 _amount) external onlyOwner {\r\n        require(_amount <= rewardToken.balanceOf(address(this)), 'not enough tokens to take out');\r\n        rewardToken.safeTransfer(address(msg.sender), _amount);\r\n    }\r\n    \r\n\r\n    function calculateNewRewards() public view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo[0];\r\n        if(pool.lastRewardTimestamp > block.timestamp){\r\n            return 0;\r\n        }\r\n        return (((block.timestamp - pool.lastRewardTimestamp) * totalStaked) * apy / 100 / 365 days);\r\n    }\r\n\r\n    function rewardsRemaining() public view returns (uint256){\r\n        return rewardToken.balanceOf(address(this));\r\n    }\r\n\r\n    function updateApy(uint256 newApy) external onlyOwner {\r\n        require(newApy <= 100000, \"APY must be below 10000%\");\r\n        updatePool(0);\r\n        apy = newApy;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"apy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateNewRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyRewardWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"holderUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accTokensPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newApy\",\"type\":\"uint256\"}],\"name\":\"updateApy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FixedAPR", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000238a1fcc2f65ed50c1e1797cf5857cba3e82a55b000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://251cf416237163305c0c4227a4dc36ff12c5b8d229479aeb013f22eefc4d88be"}