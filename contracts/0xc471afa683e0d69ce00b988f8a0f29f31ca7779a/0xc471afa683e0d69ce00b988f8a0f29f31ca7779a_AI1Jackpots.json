{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ai1Jackpots.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: NONE\\r\\n\\r\\n/**\\r\\n * ai1Labs Jackpot Manager\\r\\n * \\r\\n * Holds a list of winners to be distributed\\r\\n *\\r\\n * Website: ai1.wtf\\r\\n * \\r\\n * Docs: docs.ai1.wtf\\r\\n * \\r\\n * X: x.com/ai1Labs\\r\\n * \\r\\n * Telegram: t.me/ai1Labs\\r\\n */\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n//import \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n\\r\\ncontract AI1Jackpots is Ownable {\\r\\n    event WinPending(address indexed seller, uint256 ethWinnings, uint256 randomNumber);\\r\\n    event JackpotWin(address indexed winner, uint256 winnings, uint256 randomSeedUsed);\\r\\n    event ClaimManually(address indexed winner, uint256 winnings);\\r\\n    struct WinToProcess {\\r\\n        uint256 randomNumber;\\r\\n        uint256 ethWinnings;\\r\\n        address seller;\\r\\n    }\\r\\n    struct ManuallyClaimableWin {\\r\\n        uint256 ethWinnings;\\r\\n        address winner;\\r\\n    }\\r\\n    error NotProcessingBot();\\r\\n    error NotHeadContract();\\r\\n    error ReentrancyDetected();\\r\\n\\r\\n    modifier onlyProcessingBot() {\\r\\n        if(_msgSender() != processingBot) {\\r\\n            revert NotProcessingBot();\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n    modifier onlyHeadContract() {\\r\\n        if(_msgSender() != topContract) {\\r\\n            revert NotHeadContract();\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    modifier reentrancyGuard() {\\r\\n        if(_reentrancySemaphore) {\\r\\n            revert ReentrancyDetected();\\r\\n        }\\r\\n        _reentrancySemaphore = true;\\r\\n        _;\\r\\n        _reentrancySemaphore = false;\\r\\n    }\\r\\n    address private processingBot;\\r\\n    \\r\\n    bool private _reentrancySemaphore = false;\\r\\n\\r\\n    \\r\\n\\r\\n    WinToProcess[] private pendingWins;\\r\\n\\r\\n    ManuallyClaimableWin[] private failedSends;\\r\\n\\r\\n    address private topContract;\\r\\n\\r\\n    constructor(address bot) Ownable(_msgSender()) {\\r\\n        topContract = msg.sender;\\r\\n        processingBot = bot;\\r\\n    }\\r\\n    /// @notice Changes the processing bot address. Only settable by CA owner.\\r\\n    /// @param newBot the new bot to set\\r\\n    function changeProcessingBot(address newBot) public onlyOwner {\\r\\n        processingBot = newBot;\\r\\n    }\\r\\n    function changeTopContract(address newContract) public onlyOwner {\\r\\n        topContract = newContract;\\r\\n    }\\r\\n\\r\\n    /// @notice Generates a random number - don't rely on for crypto\\r\\n    function generateNumber() private view returns (uint256 result) {\\r\\n        result = uint256(keccak256(abi.encode(block.prevrandao)));\\r\\n    }\\r\\n    /// @notice Adds a pending win from a sell - only callable by contract and the value of ETH should be sent\\r\\n    /// @param seller the seller, so we can exclude them\\r\\n\\r\\n    function addPendingWin(address seller) external payable onlyHeadContract {\\r\\n        uint256 rng = generateNumber();\\r\\n        pendingWins.push(WinToProcess(rng, msg.value, seller));\\r\\n        emit WinPending(seller, msg.value, rng);\\r\\n    }\\r\\n\\r\\n    /// @notice Get the lists of pending wins\\r\\n    function getPendingWins() public view returns (uint256[] memory rngs, uint256[] memory winnings, address[] memory sellers) {\\r\\n        rngs = new uint256[](pendingWins.length);\\r\\n        winnings = new uint256[](pendingWins.length);\\r\\n        sellers = new address[](pendingWins.length);\\r\\n        for(uint i = 0; i < pendingWins.length; i++) {\\r\\n            rngs[i] = pendingWins[i].randomNumber;\\r\\n            winnings[i] = pendingWins[i].ethWinnings;\\r\\n            sellers[i] = pendingWins[i].seller;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function processPendingWin(uint256 index, address receipient, uint256 processingCost) public onlyProcessingBot reentrancyGuard {\\r\\n        processWinInternal(index, receipient, processingCost);\\r\\n        // Check if it's the very end of the list\\r\\n        if(index != pendingWins.length-1) {\\r\\n            // It's not, so move the end to the index we wish to erase\\r\\n            pendingWins[index] = pendingWins[pendingWins.length-1];\\r\\n        }\\r\\n        // Pop the end - if our pending win is the end, it's okay, if not we made a copy of the end\\r\\n        pendingWins.pop();\\r\\n    }\\r\\n\\r\\n    function processWinInternal(uint256 index, address winner, uint256 processingCost) private {\\r\\n        uint256 winAmount = pendingWins[index].ethWinnings;\\r\\n        (bool success,) = winner.call{gas: 50000, value: winAmount-processingCost}(\\\"\\\");\\r\\n        payable(msg.sender).transfer(processingCost);\\r\\n        if(success) {\\r\\n            emit JackpotWin(winner, winAmount-processingCost, pendingWins[index].randomNumber);\\r\\n        } else {\\r\\n            failedSends.push(ManuallyClaimableWin(winAmount-processingCost, winner));\\r\\n            emit ClaimManually(winner, winAmount-processingCost);\\r\\n        }\\r\\n    }\\r\\n    /// @notice Process a list of indexes and winners. Ensure the indexes are ascending. \\r\\n    function processPendingWins(uint256[] calldata indexes, address[] calldata recipients, uint256[] calldata processingCosts) external onlyProcessingBot reentrancyGuard {\\r\\n        require(indexes.length == recipients.length && indexes.length == processingCosts.length, \\\"LuckyJackpot: Length of arrays must match.\\\");\\r\\n        for(uint i = 0; i < indexes.length; i++) {\\r\\n            processWinInternal(indexes[i], recipients[i], processingCosts[i]);\\r\\n        }\\r\\n        // Need to be a little more careful here, as we have multiple indexes to remove\\r\\n        uint indexLen = indexes.length-1;\\r\\n        for(uint i = 0; i < indexes.length; i++) {\\r\\n            // i is, from the end, how many\\r\\n            if(indexes[indexLen-i] != pendingWins.length) {\\r\\n                // Copy the end to the current index, if necessary\\r\\n                pendingWins[indexes[indexLen-i]] = pendingWins[pendingWins.length-1];\\r\\n            }\\r\\n            // Delete the end\\r\\n            pendingWins.pop();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Claim the first win for this address\\r\\n    function manualClaim(address winner) public reentrancyGuard {\\r\\n        // Find the first win in failedSends\\r\\n        for(uint i = 0; i < failedSends.length; i++) {\\r\\n            if(failedSends[i].winner == winner) {\\r\\n                (bool success,) = winner.call{value: failedSends[i].ethWinnings}(\\\"\\\");\\r\\n                require(success, \\\"LuckyJackpot: Send failed.\\\");\\r\\n                // Delete the winner\\r\\n                if(i != failedSends.length-1) {\\r\\n                    failedSends[i] = failedSends[failedSends.length-1];\\r\\n                }\\r\\n                failedSends.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdrawGas(uint256 amount) public onlyProcessingBot {\\r\\n        // Withdraw the gas fee to be spent on running a sell\\r\\n        payable(processingBot).transfer(amount);\\r\\n    }\\r\\n\\r\\n    function withdrawFees(uint256 amount) public onlyOwner {\\r\\n        // Withdraw excess fees for owner\\r\\n        payable(owner()).transfer(amount);\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bot\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotHeadContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotProcessingBot\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyDetected\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winnings\",\"type\":\"uint256\"}],\"name\":\"ClaimManually\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winnings\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomSeedUsed\",\"type\":\"uint256\"}],\"name\":\"JackpotWin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethWinnings\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"name\":\"WinPending\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"addPendingWin\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBot\",\"type\":\"address\"}],\"name\":\"changeProcessingBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"changeTopContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingWins\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rngs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"winnings\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"sellers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"manualClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"processingCost\",\"type\":\"uint256\"}],\"name\":\"processPendingWin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexes\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"processingCosts\",\"type\":\"uint256[]\"}],\"name\":\"processPendingWins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AI1Jackpots", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000883c2b17d1f91a24a89804bd68b67d8f68ee4301", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}