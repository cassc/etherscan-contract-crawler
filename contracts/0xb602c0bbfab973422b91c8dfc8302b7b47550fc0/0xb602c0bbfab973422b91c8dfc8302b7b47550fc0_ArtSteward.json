{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v1/ArtSteward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./interfaces/IERC721.sol\\\";\\nimport \\\"./utils/SafeMath.sol\\\";\\n\\n// Fixed v1 update (January 2021 update):\\n\\n// - Bumped to 0.7.x sol.\\n// - Changed 'now' to 'block.timestamp'.\\n// - Added in sections related to Restoration. \\n// - > restore() function, \\n// - > extracted buy() to enable once-off transfer\\n// - > extracted foreclosure + transferartwork to enable once-off transfer\\n\\n// What changed for V2 (June 2020 update):\\n// - Medium Severity Fixes:\\n// - Added a check on buy to prevent front-running. Needs to give currentPrice when buying.\\n// - Removed ability for someone to block buying through revert on ETH send. Funds get sent to a pull location.\\n// - Added patron check on depositWei. Since anyone can send, it can be front-run, stealing a deposit by buying before deposit clears.\\n// - Other Minor Changes:\\n// - Added past foreclosureTime() if it happened in the past.\\n// - Moved patron modifier checks to AFTER patronage. Thus, not necessary to have steward state anymore.\\n// - Removed steward state. Only check on price now. If price = zero = foreclosed. \\n// - Removed paid mapping. Wasn't used.\\n// - Moved constructor to a function in case this is used with upgradeable contracts.\\n// - Changed currentCollected into a view function rather than tracking variable. This fixed a bug where CC would keep growing in between ownerships.\\n// - Kept the numerator/denominator code (for reference), but removed to save gas costs for 100% patronage rate.\\n\\n// - Changes for UI:\\n// - Need to have additional current price when buying.\\n// - foreclosureTime() will now backdate if past foreclose time.\\n\\ncontract ArtSteward {\\n    \\n    /*\\n    This smart contract collects patronage from current owner through a Harberger tax model and \\n    takes stewardship of the artwork if the patron can't pay anymore.\\n\\n    Harberger Tax (COST): \\n    - Artwork is always on sale.\\n    - You have to have a price set.\\n    - Tax (Patronage) is paid to maintain ownership.\\n    - Steward maints control over ERC721.\\n    */\\n    using SafeMath for uint256;\\n    \\n    uint256 public price; //in wei\\n    IERC721 public art; // ERC721 NFT.\\n    \\n    uint256 public totalCollected; // all patronage ever collected\\n\\n    /* In the event that a foreclosure happens AFTER it should have been foreclosed already,\\n    this variable is backdated to when it should've occurred. Thus: timeHeld is accurate to actual deposit. */\\n    uint256 public timeLastCollected; // timestamp when last collection occurred\\n    uint256 public deposit; // funds for paying patronage\\n    address payable public artist; // beneficiary\\n    uint256 public artistFund; // what artist has earned and can withdraw\\n\\n    /*\\n    If for whatever reason the transfer fails when being sold,\\n    it's added to a pullFunds such that previous owner can withdraw it.\\n    */\\n    mapping (address => uint256) public pullFunds; // storage area in case a sale can't send the funds towards previous owner.\\n    mapping (address => bool) public patrons; // list of whom have owned it\\n    mapping (address => uint256) public timeHeld; // time held by particular patron\\n\\n    uint256 public timeAcquired; // when it is newly bought/sold\\n    \\n    // percentage patronage rate. eg 5% or 100% \\n    // granular to an additionial 10 zeroes.\\n    uint256 patronageNumerator; \\n    uint256 patronageDenominator;\\n\\n    // mainnet\\n    address public restorer; \\n    uint256 public snapshotV1Price;\\n    address public snapshotV1Owner;\\n\\n    bool public restored = false;\\n\\n    IERC721 public oldV1; // for checking if allowed to transfer\\n\\n    constructor(address payable _artist, address _artwork, \\n        uint256 _snapshotV1Price, \\n        address _snapshotV1Owner,\\n        address _oldV1Address) payable {\\n\\n        patronageNumerator = 50000000000; // 5%\\n        patronageDenominator = 1000000000000;\\n        art = IERC721(_artwork);\\n        art.setup();\\n        artist = _artist;\\n\\n        // Restoration-specific setup.\\n        oldV1 = IERC721(_oldV1Address);\\n        restorer = msg.sender; // this must be deployed by the Restoration contract.\\n        snapshotV1Price = _snapshotV1Price;\\n        snapshotV1Owner = _snapshotV1Owner;\\n\\n        //sets up initial parameters for foreclosure\\n        _initForecloseIfNecessary();\\n    }\\n\\n    function restore() public payable {\\n        require(restored == false, \\\"RESTORE: Artwork already restored\\\");\\n        require(msg.sender == restorer, \\\"RESTORE: Can only be restored by restoration contract\\\");\\n\\n        // newPrice, oldPrice, owner\\n        _buy(snapshotV1Price, 0, snapshotV1Owner);\\n        restored = true;\\n    }\\n\\n    event LogBuy(address indexed owner, uint256 indexed price);\\n    event LogPriceChange(uint256 indexed newPrice);\\n    event LogForeclosure(address indexed prevOwner);\\n    event LogCollection(uint256 indexed collected);\\n    \\n    modifier onlyPatron() {\\n        require(msg.sender == art.ownerOf(42), \\\"Not patron\\\");\\n        _;\\n    }\\n\\n    modifier collectPatronage() {\\n       _collectPatronage(); \\n       _;\\n    }\\n\\n    /* public view functions */\\n    /* used internally in external actions */\\n\\n    // how much is owed from last collection to block.timestamp.\\n    function patronageOwed() public view returns (uint256 patronageDue) {\\n        return price.mul(block.timestamp.sub(timeLastCollected)).mul(patronageNumerator).div(patronageDenominator).div(365 days);\\n        \\n        // use in 100% patronage rate\\n        //return price.mul(block.timestamp.sub(timeLastCollected)).div(365 days);\\n    }\\n\\n    /* not used internally in external actions */\\n    function patronageOwedRange(uint256 _time) public view returns (uint256 patronageDue) {\\n        return price.mul(_time).mul(patronageNumerator).div(patronageDenominator).div(365 days);\\n\\n        // used in 100% patronage rate\\n        // return price.mul(_time).div(365 days);\\n    }\\n\\n    function currentCollected() public view returns (uint256 patronageDue) {\\n        if(timeLastCollected > timeAcquired) {\\n            return patronageOwedRange(timeLastCollected.sub(timeAcquired));\\n        } else { return 0; }\\n    }\\n\\n    function patronageOwedWithTimestamp() public view returns (uint256 patronageDue, uint256 timestamp) {\\n        return (patronageOwed(), block.timestamp);\\n    }\\n\\n    function foreclosed() public view returns (bool) {\\n        // returns whether it is in foreclosed state or not\\n        // depending on whether deposit covers patronage due\\n        // useful helper function when price should be zero, but contract doesn't reflect it yet.\\n        uint256 collection = patronageOwed();\\n        if(collection >= deposit) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    // same function as above, basically\\n    function depositAbleToWithdraw() public view returns (uint256) {\\n        uint256 collection = patronageOwed();\\n        if(collection >= deposit) {\\n            return 0;\\n        } else {\\n            return deposit.sub(collection);\\n        }\\n    }\\n\\n    /*\\n    block.timestamp + deposit/patronage per second \\n    block.timestamp + depositAbleToWithdraw/(price*nume/denom/365).\\n    */\\n    function foreclosureTime() public view returns (uint256) {\\n        // patronage per second\\n        uint256 pps = price.mul(patronageNumerator).div(patronageDenominator).div(365 days);\\n        uint256 daw = depositAbleToWithdraw();\\n        if(daw > 0) {\\n            return block.timestamp + depositAbleToWithdraw().div(pps);\\n        } else if (pps > 0) {\\n            // it is still active, but in foreclosure state\\n            // it is block.timestamp or was in the past\\n            uint256 collection = patronageOwed();\\n            return timeLastCollected.add((block.timestamp.sub(timeLastCollected)).mul(deposit).div(collection));\\n        } else {\\n            // not active and actively foreclosed (price is zero)\\n            return timeLastCollected; // it has been foreclosed or in foreclosure.\\n        }\\n    }\\n\\n    /* actions */\\n    // determine patronage to pay\\n    function _collectPatronage() public {\\n\\n        if (price != 0) { // price > 0 == active owned state\\n            uint256 collection = patronageOwed();\\n            \\n            if (collection >= deposit) { // foreclosure happened in the past\\n\\n                // up to when was it actually paid for?\\n                // TLC + (time_elapsed)*deposit/collection\\n                timeLastCollected = timeLastCollected.add((block.timestamp.sub(timeLastCollected)).mul(deposit).div(collection));\\n                collection = deposit; // take what's left.\\n            } else { \\n                timeLastCollected = block.timestamp; \\n            } // normal collection\\n\\n            deposit = deposit.sub(collection);\\n            totalCollected = totalCollected.add(collection);\\n            artistFund = artistFund.add(collection);\\n            emit LogCollection(collection);\\n\\n            _forecloseIfNecessary();\\n        }\\n\\n    }\\n\\n    function buy(uint256 _newPrice, uint256 _currentPrice) public payable collectPatronage {\\n        _buy(_newPrice, _currentPrice, msg.sender);\\n    }\\n\\n    // extracted out for initial setup\\n    function _buy(uint256 _newPrice, uint256 _currentPrice, address _newOwner) internal {\\n        /* \\n            this is protection against a front-run attack.\\n            the person will only buy the artwork if it is what they agreed to.\\n            thus: someone can't buy it from under them and change the price, eating into their deposit.\\n        */\\n        require(price == _currentPrice, \\\"Current Price incorrect\\\");\\n        require(_newPrice > 0, \\\"Price is zero\\\");\\n        require(msg.value > price, \\\"Not enough\\\"); // >, coz need to have at least something for deposit\\n\\n        address currentOwner = art.ownerOf(42);\\n\\n        uint256 totalToPayBack = price.add(deposit);\\n        if(totalToPayBack > 0) { // this won't execute if steward owns it. price = 0. deposit = 0.\\n            // pay previous owner their price + deposit back.\\n            address payable payableCurrentOwner = address(uint160(currentOwner));\\n            bool transferSuccess = payableCurrentOwner.send(totalToPayBack);\\n\\n            // if the send fails, keep the funds separate for the owner\\n            if(!transferSuccess) { pullFunds[currentOwner] = pullFunds[currentOwner].add(totalToPayBack); }\\n        }\\n\\n        // new purchase\\n        timeLastCollected = block.timestamp;\\n        \\n        deposit = msg.value.sub(price);\\n        transferArtworkTo(currentOwner, _newOwner, _newPrice);\\n        emit LogBuy(_newOwner, _newPrice);\\n    }\\n\\n    /* Only Patron Actions */\\n    function depositWei() public payable collectPatronage onlyPatron {\\n        deposit = deposit.add(msg.value);\\n    }\\n\\n    function changePrice(uint256 _newPrice) public collectPatronage onlyPatron {\\n        require(_newPrice > 0, 'Price is zero'); \\n        price = _newPrice;\\n        emit LogPriceChange(price);\\n    }\\n    \\n    function withdrawDeposit(uint256 _wei) public collectPatronage onlyPatron {\\n        _withdrawDeposit(_wei);\\n    }\\n\\n    function exit() public collectPatronage onlyPatron {\\n        _withdrawDeposit(deposit);\\n    }\\n\\n    /* Actions that don't affect state of the artwork */\\n    /* Artist Actions */\\n    function withdrawArtistFunds() public {\\n        require(msg.sender == artist, \\\"Not artist\\\");\\n        uint256 toSend = artistFund;\\n        artistFund = 0;\\n        artist.transfer(toSend);\\n    }\\n\\n    /* Withdrawing Stuck Deposits */\\n    /* To reduce complexity, pull funds are entirely separate from current deposit */\\n    function withdrawPullFunds() public {\\n        require(pullFunds[msg.sender] > 0, \\\"No pull funds available.\\\");\\n        uint256 toSend = pullFunds[msg.sender];\\n        pullFunds[msg.sender] = 0;\\n        msg.sender.transfer(toSend);\\n    }\\n\\n    /* internal */\\n    function _withdrawDeposit(uint256 _wei) internal {\\n        // note: can withdraw whole deposit, which puts it in immediate to be foreclosed state.\\n        require(deposit >= _wei, 'Withdrawing too much');\\n\\n        deposit = deposit.sub(_wei);\\n        msg.sender.transfer(_wei); // msg.sender == patron\\n\\n        _forecloseIfNecessary();\\n    }\\n\\n    function _forecloseIfNecessary() internal {\\n        if(deposit == 0) {\\n            // become steward of artwork (aka foreclose)\\n            address currentOwner = art.ownerOf(42);\\n            transferArtworkTo(currentOwner, address(this), 0);\\n            emit LogForeclosure(currentOwner);\\n        }\\n    }\\n\\n    // doesn't require v1 owner check to set up.\\n    function _initForecloseIfNecessary() internal {\\n        if(deposit == 0) {\\n            // become steward of artwork (aka foreclose)\\n            address currentOwner = art.ownerOf(42);\\n            _transferArtworkTo(currentOwner, address(this), 0);\\n            emit LogForeclosure(currentOwner);\\n        }\\n\\n    }\\n\\n    function transferArtworkTo(address _currentOwner, address _newOwner, uint256 _newPrice) internal {\\n        // a symbolic check to ensure that the old V1 is still blocked and owned by the Restorer\\n        // (the old V1 is thus a part of the new v1)\\n        // if this bond is broken, both artworks will seize\\n        require(oldV1.ownerOf(42) == restorer, \\\"RESTORE: Old V1 is not owned by the Restorer\\\");\\n\\n        _transferArtworkTo(_currentOwner, _newOwner, _newPrice);\\n    }\\n\\n    function _transferArtworkTo(address _currentOwner, address _newOwner, uint256 _newPrice) internal {\\n        // note: it would also tabulate time held in stewardship by smart contract\\n        timeHeld[_currentOwner] = timeHeld[_currentOwner].add((timeLastCollected.sub(timeAcquired)));\\n        \\n        art.transferFrom(_currentOwner, _newOwner, 42);\\n\\n        price = _newPrice;\\n        timeAcquired = block.timestamp;\\n        patrons[_newOwner] = true;\\n    }\\n}\"\r\n    },\r\n    \"contracts/v1/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    // event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    // event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    // function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    // function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    // function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    // function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    // function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    // function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    function setup() external;\\n}\"\r\n    },\r\n    \"contracts/v1/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/v1/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_artist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_artwork\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_snapshotV1Price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_snapshotV1Owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oldV1Address\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"LogBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collected\",\"type\":\"uint256\"}],\"name\":\"LogCollection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"}],\"name\":\"LogForeclosure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"LogPriceChange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_collectPatronage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"art\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artist\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artistFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currentPrice\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"changePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"patronageDue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositAbleToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositWei\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foreclosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foreclosureTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldV1\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"patronageOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"patronageDue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"patronageOwedRange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"patronageDue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"patronageOwedWithTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"patronageDue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"patrons\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pullFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restore\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restored\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restorer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snapshotV1Owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snapshotV1Price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeAcquired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timeHeld\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLastCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawArtistFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"withdrawDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawPullFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ArtSteward", "CompilerVersion": "v0.7.3+commit.9bfce1f6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000cacc6104d8cd9d7b2850b4f35c65c1ecdeece030000000000000000000000002b4fa931adc5d6b58674230208787a3df0bd212100000000000000000000000000000000000000000000000821ab0d44149800000000000000000000000000005a36c5bb86b1d8037576fda54422e608230670630000000000000000000000006d7c26f2e77d0ccc200464c8b2040c0b840b28a2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}