// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

import "./ILXDAOBuidlerMetadata.sol";
import "./Base58.sol";

contract LXDAOBuidlerMetadata is Ownable, ILXDAOBuidlerMetadata, Base58 {
    using ECDSA for bytes32;

    string public baseURI = "ipfs://";
    bytes32 public tokenLxPointsURI;
    mapping(uint256 => bytes32) public tokenMetadataURIs;

    address private signer;
    // the controller of this metadata contract
    address private _controller;

    event SignerChanged();
    event ControllerChanged();
    event BaseURIChanged(address operator, string baseURI);
    event MetadataChanged(uint256 tokenId);
    event MultipleMetadataChanged(uint256[] tokenId);
    event LXPointsChanged();

    constructor(address _signer) {
        require(
            _signer != address(0),
            "LXDAOBuidlerMetadata: The signer cannot be initialized zero."
        );
        signer = _signer;
    }

    modifier onlyOwnerOrController() {
        require(
            _controller == _msgSender() || owner() == _msgSender(),
            "LXDAOBuidlerMetadata: caller is not the controller or contract owner."
        );
        _;
    }

    function setSigner(address _signer) external onlyOwner {
        signer = _signer;
        emit SignerChanged();
    }

    function getSigner() external view onlyOwner returns (address) {
        return signer;
    }

    function updateController(address controller) external onlyOwner {
        _controller = controller;
        emit ControllerChanged();
    }

    function getController() external view onlyOwner returns (address) {
        return _controller;
    }

    function updateBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
        emit BaseURIChanged(msg.sender, _newBaseURI);
    }

    function _baseURI() internal view returns (string memory) {
        return baseURI;
    }

    function _hashBytes(bytes calldata ipfsHash)
        internal
        pure
        returns (bytes32)
    {
        return keccak256(abi.encode(ipfsHash));
    }

    function _verify(bytes32 hash, bytes memory token)
        internal
        view
        returns (bool)
    {
        return (_recover(hash, token) == signer);
    }

    function _recover(bytes32 hash, bytes memory token)
        internal
        pure
        returns (address)
    {
        return hash.toEthSignedMessageHash().recover(token);
    }

    function bytesTo32(bytes calldata source) private pure returns (bytes32) {
        return bytes32(source[:32]);
    }

    /**
     * @notice cidv0 is used to convert sha256 hash to cid(v0) used by IPFS.
     * @param sha256Hash_ sha256 hash generated by anything.
     * @return IPFS cid that meets the version0 specification.
     */
    function cidv0(bytes32 sha256Hash_) private pure returns (string memory) {
        bytes memory hashString = new bytes(34);
        hashString[0] = 0x12;
        hashString[1] = 0x20;
        uint256 hashLength = sha256Hash_.length;
        for (uint256 i = 0; i < hashLength; ++i) {
            hashString[i + 2] = sha256Hash_[i];
        }
        return Base58.encodeToString(hashString);
    }

    function create(uint256 tokenId, bytes calldata metadataURI)
        external
        onlyOwnerOrController
    {
        tokenMetadataURIs[tokenId] = bytesTo32(metadataURI);

        emit MetadataChanged(tokenId);
    }

    function update(uint256 tokenId, bytes calldata metadataURI)
        external
        onlyOwnerOrController
    {
        tokenMetadataURIs[tokenId] = bytesTo32(metadataURI);

        emit MetadataChanged(tokenId);
    }

    function batchUpdate(
        uint256[] calldata tokenIds,
        bytes[] calldata metadataURIs
    ) external onlyOwnerOrController {
        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            tokenMetadataURIs[tokenId] = bytesTo32(metadataURIs[i]);
        }
        emit MultipleMetadataChanged(tokenIds);
    }

    function updateLXPointsURI(
        bytes calldata metadataURI,
        bytes calldata signature
    ) external onlyOwner {
        require(
            _verify(_hashBytes(metadataURI), signature),
            "LXDAOBuidlerMetadata: Invalid signature."
        );

        tokenLxPointsURI = bytesTo32(metadataURI);
        emit LXPointsChanged();
    }

    function tokenURI(uint256 tokenId) external view returns (string memory) {
        bytes32 hash = tokenMetadataURIs[tokenId];
        return string(abi.encodePacked(_baseURI(), cidv0(hash)));
    }

    function lxPointsURI() external view returns (string memory) {
        if (tokenLxPointsURI == bytes32(0)) {
            return "";
        }
        return string(abi.encodePacked(_baseURI(), cidv0(tokenLxPointsURI)));
    }
}