{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/v0.8/ccip/CommitStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\nimport {TypeAndVersionInterface} from \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\nimport {ICommitStore} from \\\"./interfaces/ICommitStore.sol\\\";\\nimport {IARM} from \\\"./interfaces/IARM.sol\\\";\\nimport {IPriceRegistry} from \\\"./interfaces/IPriceRegistry.sol\\\";\\n\\nimport {OCR2Base} from \\\"./ocr/OCR2Base.sol\\\";\\nimport {Internal} from \\\"./libraries/Internal.sol\\\";\\nimport {MerkleMultiProof} from \\\"./libraries/MerkleMultiProof.sol\\\";\\n\\ncontract CommitStore is ICommitStore, TypeAndVersionInterface, OCR2Base {\\n  error StaleReport();\\n  error PausedError();\\n  error InvalidInterval(Interval interval);\\n  error InvalidRoot();\\n  error InvalidCommitStoreConfig();\\n  error BadARMSignal();\\n  error RootAlreadyCommitted();\\n\\n  event Paused(address account);\\n  event Unpaused(address account);\\n  event ReportAccepted(CommitReport report);\\n  event ConfigSet(StaticConfig staticConfig, DynamicConfig dynamicConfig);\\n  event RootRemoved(bytes32 root);\\n\\n  /// @notice Static commit store config\\n  struct StaticConfig {\\n    uint64 chainSelector; // -------\u2510  Destination chainSelector\\n    uint64 sourceChainSelector; // -\u2518  Source chainSelector\\n    address onRamp; // OnRamp address on the source chain\\n    address armProxy; // ARM proxy address\\n  }\\n\\n  /// @notice Dynamic commit store config\\n  struct DynamicConfig {\\n    address priceRegistry; // Price registry address on the destination chain\\n  }\\n\\n  /// @notice a sequenceNumber interval\\n  struct Interval {\\n    uint64 min; // ---\u2510 Minimum sequence number, inclusive\\n    uint64 max; // ---\u2518 Maximum sequence number, inclusive\\n  }\\n\\n  /// @notice Report that is committed by the observing DON at the committing phase\\n  struct CommitReport {\\n    Internal.PriceUpdates priceUpdates;\\n    Interval interval;\\n    bytes32 merkleRoot;\\n  }\\n\\n  // STATIC CONFIG\\n  // solhint-disable-next-line chainlink-solidity/all-caps-constant-storage-variables\\n  string public constant override typeAndVersion = \\\"CommitStore 1.0.0\\\";\\n  // Chain ID of this chain\\n  uint64 internal immutable i_chainSelector;\\n  // Chain ID of the source chain\\n  uint64 internal immutable i_sourceChainSelector;\\n  // The onRamp address on the source chain\\n  address internal immutable i_onRamp;\\n  // The address of the arm proxy\\n  address internal immutable i_armProxy;\\n\\n  // DYNAMIC CONFIG\\n  // The dynamic commitStore config\\n  DynamicConfig internal s_dynamicConfig;\\n\\n  // STATE\\n  // The min sequence number expected for future messages\\n  uint64 private s_minSeqNr = 1;\\n  /// @dev The epoch and round of the last report\\n  uint40 private s_latestPriceEpochAndRound;\\n  /// @dev Whether this OnRamp is paused or not\\n  bool private s_paused = false;\\n  // merkleRoot => timestamp when received\\n  mapping(bytes32 merkleRoot => uint256 timestamp) private s_roots;\\n\\n  /// @param staticConfig Containing the static part of the commitStore config\\n  /// @dev When instantiating OCR2Base we set UNIQUE_REPORTS to false, which means\\n  /// that we do not require 2f+1 signatures on a report, only f+1 to save gas. 2f+1 is required\\n  /// only if one must strictly ensure that for a given round there is only one valid report ever generated by\\n  /// the DON. In our case additional valid reports (i.e. approved by >= f+1 oracles) are not a problem, as they will\\n  /// will either be ignored (reverted as an invalid interval) or will be accepted as an additional valid price update.\\n  constructor(StaticConfig memory staticConfig) OCR2Base(false) {\\n    if (\\n      staticConfig.onRamp == address(0) ||\\n      staticConfig.chainSelector == 0 ||\\n      staticConfig.sourceChainSelector == 0 ||\\n      staticConfig.armProxy == address(0)\\n    ) revert InvalidCommitStoreConfig();\\n\\n    i_chainSelector = staticConfig.chainSelector;\\n    i_sourceChainSelector = staticConfig.sourceChainSelector;\\n    i_onRamp = staticConfig.onRamp;\\n    i_armProxy = staticConfig.armProxy;\\n  }\\n\\n  // ================================================================\\n  // |                        Verification                          |\\n  // ================================================================\\n\\n  /// @notice Returns the next expected sequence number.\\n  /// @return the next expected sequenceNumber.\\n  function getExpectedNextSequenceNumber() external view returns (uint64) {\\n    return s_minSeqNr;\\n  }\\n\\n  /// @notice Sets the minimum sequence number.\\n  /// @param minSeqNr The new minimum sequence number.\\n  function setMinSeqNr(uint64 minSeqNr) external onlyOwner {\\n    s_minSeqNr = minSeqNr;\\n  }\\n\\n  /// @notice Returns the epoch and round of the last price update.\\n  /// @return the latest price epoch and round.\\n  function getLatestPriceEpochAndRound() public view returns (uint64) {\\n    return s_latestPriceEpochAndRound;\\n  }\\n\\n  /// @notice Sets the latest epoch and round for price update.\\n  /// @param latestPriceEpochAndRound The new epoch and round for prices.\\n  function setLatestPriceEpochAndRound(uint40 latestPriceEpochAndRound) external onlyOwner {\\n    s_latestPriceEpochAndRound = latestPriceEpochAndRound;\\n  }\\n\\n  /// @notice Returns the timestamp of a potentially previously committed merkle root.\\n  /// If the root was never committed 0 will be returned.\\n  /// @param root The merkle root to check the commit status for.\\n  /// @return the timestamp of the committed root or zero in the case that it was never\\n  /// committed.\\n  function getMerkleRoot(bytes32 root) external view returns (uint256) {\\n    return s_roots[root];\\n  }\\n\\n  /// @notice Returns if a root is blessed or not.\\n  /// @param root The merkle root to check the blessing status for.\\n  /// @return whether the root is blessed or not.\\n  function isBlessed(bytes32 root) public view returns (bool) {\\n    return IARM(i_armProxy).isBlessed(IARM.TaggedRoot({commitStore: address(this), root: root}));\\n  }\\n\\n  /// @notice Used by the owner in case an invalid sequence of roots has been\\n  /// posted and needs to be removed. The interval in the report is trusted.\\n  /// @param rootToReset The roots that will be reset. This function will only\\n  /// reset roots that are not blessed.\\n  function resetUnblessedRoots(bytes32[] calldata rootToReset) external onlyOwner {\\n    for (uint256 i = 0; i < rootToReset.length; ++i) {\\n      bytes32 root = rootToReset[i];\\n      if (!isBlessed(root)) {\\n        delete s_roots[root];\\n        emit RootRemoved(root);\\n      }\\n    }\\n  }\\n\\n  /// @inheritdoc ICommitStore\\n  function verify(\\n    bytes32[] calldata hashedLeaves,\\n    bytes32[] calldata proofs,\\n    uint256 proofFlagBits\\n  ) external view override whenNotPaused returns (uint256 timestamp) {\\n    bytes32 root = MerkleMultiProof.merkleRoot(hashedLeaves, proofs, proofFlagBits);\\n    // Only return non-zero if present and blessed.\\n    if (!isBlessed(root)) {\\n      return 0;\\n    }\\n    return s_roots[root];\\n  }\\n\\n  /// @inheritdoc OCR2Base\\n  /// @dev A commitReport can have two distinct parts:\\n  /// 1. Price updates\\n  /// 2. A merkle root and sequence number interval\\n  /// Both have their own, separate, staleness checks, with price updates using the epoch and round\\n  /// number of the latest price update. The merkle root checks for staleness based on the seqNums.\\n  /// They need to be separate because a price report for round t+2 might be included before a report\\n  /// containing a merkle root for round t+1. This merkle root report for round t+1 is still valid\\n  /// and should not be rejected. When a report with a stale root but valid price updates is submitted,\\n  /// we are OK to revert to preserve the invariant that we always revert on invalid sequence number ranges.\\n  /// If that happens, prices will be updates in later rounds.\\n  function _report(bytes calldata encodedReport, uint40 epochAndRound) internal override whenNotPaused whenHealthy {\\n    CommitReport memory report = abi.decode(encodedReport, (CommitReport));\\n\\n    // Check if the report contains price updates\\n    if (report.priceUpdates.tokenPriceUpdates.length > 0 || report.priceUpdates.destChainSelector != 0) {\\n      // Check for price staleness based on the epoch and round\\n      if (s_latestPriceEpochAndRound < epochAndRound) {\\n        // If prices are not stale, update the latest epoch and round\\n        s_latestPriceEpochAndRound = epochAndRound;\\n        // And update the prices in the price registry\\n        IPriceRegistry(s_dynamicConfig.priceRegistry).updatePrices(report.priceUpdates);\\n\\n        // If there is no root, the report only contained fee updated and\\n        // we return to not revert on the empty root check below.\\n        if (report.merkleRoot == bytes32(0)) return;\\n      } else {\\n        // If prices are stale and the report doesn't contain a root, this report\\n        // does not have any valid information and we revert.\\n        // If it does contain a merkle root, continue to the root checking section.\\n        if (report.merkleRoot == bytes32(0)) revert StaleReport();\\n      }\\n    }\\n\\n    // If we reached this section, the report should contain a valid root\\n    if (s_minSeqNr != report.interval.min || report.interval.min > report.interval.max)\\n      revert InvalidInterval(report.interval);\\n\\n    if (report.merkleRoot == bytes32(0)) revert InvalidRoot();\\n    // Disallow duplicate roots as that would reset the timestamp and\\n    // delay potential manual execution.\\n    if (s_roots[report.merkleRoot] != 0) revert RootAlreadyCommitted();\\n\\n    s_minSeqNr = report.interval.max + 1;\\n    s_roots[report.merkleRoot] = block.timestamp;\\n    emit ReportAccepted(report);\\n  }\\n\\n  // ================================================================\\n  // |                           Config                             |\\n  // ================================================================\\n\\n  /// @notice Returns the static commit store config.\\n  /// @return the configuration.\\n  function getStaticConfig() external view returns (StaticConfig memory) {\\n    return\\n      StaticConfig({\\n        chainSelector: i_chainSelector,\\n        sourceChainSelector: i_sourceChainSelector,\\n        onRamp: i_onRamp,\\n        armProxy: i_armProxy\\n      });\\n  }\\n\\n  /// @notice Returns the dynamic commit store config.\\n  /// @return the configuration.\\n  function getDynamicConfig() external view returns (DynamicConfig memory) {\\n    return s_dynamicConfig;\\n  }\\n\\n  /// @notice Sets the dynamic config. This function is called during `setOCR2Config` flow\\n  function _beforeSetConfig(bytes memory onchainConfig) internal override {\\n    DynamicConfig memory dynamicConfig = abi.decode(onchainConfig, (DynamicConfig));\\n\\n    if (dynamicConfig.priceRegistry == address(0)) revert InvalidCommitStoreConfig();\\n\\n    s_dynamicConfig = dynamicConfig;\\n    // When the OCR config changes, we reset the price epoch and round\\n    // since epoch and rounds are scoped per config digest.\\n    // Note that s_minSeqNr/roots do not need to be reset as the roots persist\\n    // across reconfigurations and are de-duplicated separately.\\n    s_latestPriceEpochAndRound = 0;\\n\\n    emit ConfigSet(\\n      StaticConfig({\\n        chainSelector: i_chainSelector,\\n        sourceChainSelector: i_sourceChainSelector,\\n        onRamp: i_onRamp,\\n        armProxy: i_armProxy\\n      }),\\n      dynamicConfig\\n    );\\n  }\\n\\n  // ================================================================\\n  // |                        Access and ARM                        |\\n  // ================================================================\\n\\n  /// @notice Single function to check the status of the commitStore.\\n  function isUnpausedAndARMHealthy() external view returns (bool) {\\n    return !IARM(i_armProxy).isCursed() && !s_paused;\\n  }\\n\\n  /// @notice Support querying whether health checker is healthy.\\n  function isARMHealthy() external view returns (bool) {\\n    return !IARM(i_armProxy).isCursed();\\n  }\\n\\n  /// @notice Ensure that the ARM has not emitted a bad signal, and that the latest heartbeat is not stale.\\n  modifier whenHealthy() {\\n    if (IARM(i_armProxy).isCursed()) revert BadARMSignal();\\n    _;\\n  }\\n\\n  /// @notice Modifier to make a function callable only when the contract is not paused.\\n  modifier whenNotPaused() {\\n    if (paused()) revert PausedError();\\n    _;\\n  }\\n\\n  /// @notice Returns true if the contract is paused, and false otherwise.\\n  function paused() public view returns (bool) {\\n    return s_paused;\\n  }\\n\\n  /// @notice Pause the contract\\n  /// @dev only callable by the owner\\n  function pause() external onlyOwner {\\n    s_paused = true;\\n    emit Paused(msg.sender);\\n  }\\n\\n  /// @notice Unpause the contract\\n  /// @dev only callable by the owner\\n  function unpause() external onlyOwner {\\n    s_paused = false;\\n    emit Unpaused(msg.sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract TypeAndVersionInterface {\\n  function typeAndVersion() external pure virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/interfaces/ICommitStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface ICommitStore {\\n  /// @notice Returns timestamp of when root was accepted or 0 if verification fails.\\n  /// @dev This method uses a merkle tree within a merkle tree, with the hashedLeaves,\\n  /// proofs and proofFlagBits being used to get the root of the inner tree.\\n  /// This root is then used as the singular leaf of the outer tree.\\n  function verify(\\n    bytes32[] calldata hashedLeaves,\\n    bytes32[] calldata proofs,\\n    uint256 proofFlagBits\\n  ) external view returns (uint256 timestamp);\\n\\n  /// @notice Returns the expected next sequence number\\n  function getExpectedNextSequenceNumber() external view returns (uint64 sequenceNumber);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/interfaces/IARM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/// @notice This interface contains the only ARM-related functions that might be used on-chain by other CCIP contracts.\\ninterface IARM {\\n  /// @notice A Merkle root tagged with the address of the commit store contract it is destined for.\\n  struct TaggedRoot {\\n    address commitStore;\\n    bytes32 root;\\n  }\\n\\n  /// @notice Callers MUST NOT cache the return value as a blessed tagged root could become unblessed.\\n  function isBlessed(TaggedRoot calldata taggedRoot) external view returns (bool);\\n\\n  /// @notice When the ARM is \\\"cursed\\\", CCIP pauses until the curse is lifted.\\n  function isCursed() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/interfaces/IPriceRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {Internal} from \\\"../libraries/Internal.sol\\\";\\n\\ninterface IPriceRegistry {\\n  /// @notice Update the price for given tokens and destination chain.\\n  /// @param priceUpdates The price updates to apply.\\n  function updatePrices(Internal.PriceUpdates memory priceUpdates) external;\\n\\n  /// @notice Get the `tokenPrice` for a given token.\\n  /// @param token The token to get the price for.\\n  /// @return tokenPrice The tokenPrice for the given token.\\n  function getTokenPrice(address token) external view returns (Internal.TimestampedUint192Value memory);\\n\\n  /// @notice Get the `tokenPrice` for a given token, checks if the price is valid.\\n  /// @param token The token to get the price for.\\n  /// @return tokenPrice The tokenPrice for the given token if it exists and is valid.\\n  function getValidatedTokenPrice(address token) external view returns (uint192);\\n\\n  /// @notice Get the `tokenPrice` for an array of tokens.\\n  /// @param tokens The tokens to get prices for.\\n  /// @return tokenPrices The tokenPrices for the given tokens.\\n  function getTokenPrices(address[] calldata tokens) external view returns (Internal.TimestampedUint192Value[] memory);\\n\\n  /// @notice Get the `gasPrice` for a given destination chain ID.\\n  /// @param destChainSelector The destination chain to get the price for.\\n  /// @return gasPrice The gasPrice for the given destination chain ID.\\n  function getDestinationChainGasPrice(\\n    uint64 destChainSelector\\n  ) external view returns (Internal.TimestampedUint192Value memory);\\n\\n  /// @notice Gets the fee token price and the gas price, both denominated in dollars.\\n  /// @param token The source token to get the price for.\\n  /// @param destChainSelector The destination chain to get the gas price for.\\n  /// @return tokenPrice The price of the feeToken in 1e18 dollars per base unit.\\n  /// @return gasPrice The price of gas in 1e18 dollars per base unit.\\n  function getTokenAndGasPrices(\\n    address token,\\n    uint64 destChainSelector\\n  ) external view returns (uint192 tokenPrice, uint192 gasPrice);\\n\\n  /// @notice Convert a given token amount to target token amount.\\n  /// @param fromToken The given token address.\\n  /// @param fromTokenAmount The given token amount.\\n  /// @param toToken The target token address.\\n  /// @return toTokenAmount The target token amount.\\n  function convertTokenAmount(\\n    address fromToken,\\n    uint256 fromTokenAmount,\\n    address toToken\\n  ) external view returns (uint256 toTokenAmount);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/ocr/OCR2Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {OwnerIsCreator} from \\\"../../shared/access/OwnerIsCreator.sol\\\";\\nimport {OCR2Abstract} from \\\"./OCR2Abstract.sol\\\";\\n\\n/// @notice Onchain verification of reports from the offchain reporting protocol\\n/// @dev For details on its operation, see the offchain reporting protocol design\\n/// doc, which refers to this contract as simply the \\\"contract\\\".\\nabstract contract OCR2Base is OwnerIsCreator, OCR2Abstract {\\n  error InvalidConfig(string message);\\n  error WrongMessageLength(uint256 expected, uint256 actual);\\n  error ConfigDigestMismatch(bytes32 expected, bytes32 actual);\\n  error ForkedChain(uint256 expected, uint256 actual);\\n  error WrongNumberOfSignatures();\\n  error SignaturesOutOfRegistration();\\n  error UnauthorizedTransmitter();\\n  error UnauthorizedSigner();\\n  error NonUniqueSignatures();\\n  error OracleCannotBeZeroAddress();\\n\\n  // Packing these fields used on the hot path in a ConfigInfo variable reduces the\\n  // retrieval of all of them to a minimum number of SLOADs.\\n  struct ConfigInfo {\\n    bytes32 latestConfigDigest;\\n    uint8 f;\\n    uint8 n;\\n  }\\n\\n  // Used for s_oracles[a].role, where a is an address, to track the purpose\\n  // of the address, or to indicate that the address is unset.\\n  enum Role {\\n    // No oracle role has been set for address a\\n    Unset,\\n    // Signing address for the s_oracles[a].index'th oracle. I.e., report\\n    // signatures from this oracle should ecrecover back to address a.\\n    Signer,\\n    // Transmission address for the s_oracles[a].index'th oracle. I.e., if a\\n    // report is received by OCR2Aggregator.transmit in which msg.sender is\\n    // a, it is attributed to the s_oracles[a].index'th oracle.\\n    Transmitter\\n  }\\n\\n  struct Oracle {\\n    uint8 index; // Index of oracle in s_signers/s_transmitters\\n    Role role; // Role of the address which mapped to this struct\\n  }\\n\\n  // The current config\\n  ConfigInfo internal s_configInfo;\\n\\n  // incremented each time a new config is posted. This count is incorporated\\n  // into the config digest, to prevent replay attacks.\\n  uint32 internal s_configCount;\\n  // makes it easier for offchain systems to extract config from logs.\\n  uint32 internal s_latestConfigBlockNumber;\\n\\n  // signer OR transmitter address\\n  mapping(address signerOrTransmitter => Oracle oracle) internal s_oracles;\\n\\n  // s_signers contains the signing address of each oracle\\n  address[] internal s_signers;\\n\\n  // s_transmitters contains the transmission address of each oracle,\\n  // i.e. the address the oracle actually sends transactions to the contract from\\n  address[] internal s_transmitters;\\n\\n  // The constant-length components of the msg.data sent to transmit.\\n  // See the \\\"If we wanted to call sam\\\" example on for example reasoning\\n  // https://solidity.readthedocs.io/en/v0.7.2/abi-spec.html\\n  uint16 private constant TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT =\\n    4 + // function selector\\n      32 *\\n      3 + // 3 words containing reportContext\\n      32 + // word containing start location of abiencoded report value\\n      32 + // word containing location start of abiencoded rs value\\n      32 + // word containing start location of abiencoded ss value\\n      32 + // rawVs value\\n      32 + // word containing length of report\\n      32 + // word containing length rs\\n      32; // word containing length of ss\\n\\n  bool internal immutable i_uniqueReports;\\n  uint256 internal immutable i_chainID;\\n\\n  constructor(bool uniqueReports) {\\n    i_uniqueReports = uniqueReports;\\n    i_chainID = block.chainid;\\n  }\\n\\n  // Reverts transaction if config args are invalid\\n  modifier checkConfigValid(\\n    uint256 numSigners,\\n    uint256 numTransmitters,\\n    uint256 f\\n  ) {\\n    if (numSigners > MAX_NUM_ORACLES) revert InvalidConfig(\\\"too many signers\\\");\\n    if (f == 0) revert InvalidConfig(\\\"f must be positive\\\");\\n    if (numSigners != numTransmitters) revert InvalidConfig(\\\"oracle addresses out of registration\\\");\\n    if (numSigners <= 3 * f) revert InvalidConfig(\\\"faulty-oracle f too high\\\");\\n    _;\\n  }\\n\\n  /// @notice sets offchain reporting protocol configuration incl. participating oracles\\n  /// @param signers addresses with which oracles sign the reports\\n  /// @param transmitters addresses oracles use to transmit the reports\\n  /// @param f number of faulty oracles the system can tolerate\\n  /// @param onchainConfig encoded on-chain contract configuration\\n  /// @param offchainConfigVersion version number for offchainEncoding schema\\n  /// @param offchainConfig encoded off-chain oracle configuration\\n  function setOCR2Config(\\n    address[] memory signers,\\n    address[] memory transmitters,\\n    uint8 f,\\n    bytes memory onchainConfig,\\n    uint64 offchainConfigVersion,\\n    bytes memory offchainConfig\\n  ) external override checkConfigValid(signers.length, transmitters.length, f) onlyOwner {\\n    _beforeSetConfig(onchainConfig);\\n    uint256 oldSignerLength = s_signers.length;\\n    for (uint256 i = 0; i < oldSignerLength; ++i) {\\n      delete s_oracles[s_signers[i]];\\n      delete s_oracles[s_transmitters[i]];\\n    }\\n\\n    uint256 newSignersLength = signers.length;\\n    for (uint256 i = 0; i < newSignersLength; ++i) {\\n      // add new signer/transmitter addresses\\n      address signer = signers[i];\\n      if (s_oracles[signer].role != Role.Unset) revert InvalidConfig(\\\"repeated signer address\\\");\\n      if (signer == address(0)) revert OracleCannotBeZeroAddress();\\n      s_oracles[signer] = Oracle(uint8(i), Role.Signer);\\n\\n      address transmitter = transmitters[i];\\n      if (s_oracles[transmitter].role != Role.Unset) revert InvalidConfig(\\\"repeated transmitter address\\\");\\n      if (transmitter == address(0)) revert OracleCannotBeZeroAddress();\\n      s_oracles[transmitter] = Oracle(uint8(i), Role.Transmitter);\\n    }\\n\\n    s_signers = signers;\\n    s_transmitters = transmitters;\\n\\n    s_configInfo.f = f;\\n    s_configInfo.n = uint8(newSignersLength);\\n    s_configInfo.latestConfigDigest = _configDigestFromConfigData(\\n      block.chainid,\\n      address(this),\\n      ++s_configCount,\\n      signers,\\n      transmitters,\\n      f,\\n      onchainConfig,\\n      offchainConfigVersion,\\n      offchainConfig\\n    );\\n\\n    uint32 previousConfigBlockNumber = s_latestConfigBlockNumber;\\n    s_latestConfigBlockNumber = uint32(block.number);\\n\\n    emit ConfigSet(\\n      previousConfigBlockNumber,\\n      s_configInfo.latestConfigDigest,\\n      s_configCount,\\n      signers,\\n      transmitters,\\n      f,\\n      onchainConfig,\\n      offchainConfigVersion,\\n      offchainConfig\\n    );\\n  }\\n\\n  /// @dev Hook that is run from setOCR2Config() right after validating configuration.\\n  /// Empty by default, please provide an implementation in a child contract if you need additional configuration processing\\n  function _beforeSetConfig(bytes memory _onchainConfig) internal virtual {}\\n\\n  /// @return list of addresses permitted to transmit reports to this contract\\n  /// @dev The list will match the order used to specify the transmitter during setConfig\\n  function getTransmitters() external view returns (address[] memory) {\\n    return s_transmitters;\\n  }\\n\\n  /// @notice transmit is called to post a new report to the contract\\n  /// @param report serialized report, which the signatures are signing.\\n  /// @param rs ith element is the R components of the ith signature on report. Must have at most MAX_NUM_ORACLES entries\\n  /// @param ss ith element is the S components of the ith signature on report. Must have at most MAX_NUM_ORACLES entries\\n  /// @param rawVs ith element is the the V component of the ith signature\\n  function transmit(\\n    // NOTE: If these parameters are changed, expectedMsgDataLength and/or\\n    // TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT need to be changed accordingly\\n    bytes32[3] calldata reportContext,\\n    bytes calldata report,\\n    bytes32[] calldata rs,\\n    bytes32[] calldata ss,\\n    bytes32 rawVs // signatures\\n  ) external override {\\n    // Scoping this reduces stack pressure and gas usage\\n    {\\n      // report and epochAndRound\\n      _report(report, uint40(uint256(reportContext[1])));\\n    }\\n\\n    // reportContext consists of:\\n    // reportContext[0]: ConfigDigest\\n    // reportContext[1]: 27 byte padding, 4-byte epoch and 1-byte round\\n    // reportContext[2]: ExtraHash\\n    bytes32 configDigest = reportContext[0];\\n    ConfigInfo memory configInfo = s_configInfo;\\n\\n    if (configInfo.latestConfigDigest != configDigest)\\n      revert ConfigDigestMismatch(configInfo.latestConfigDigest, configDigest);\\n    // If the cached chainID at time of deployment doesn't match the current chainID, we reject all signed reports.\\n    // This avoids a (rare) scenario where chain A forks into chain A and A', A' still has configDigest\\n    // calculated from chain A and so OCR reports will be valid on both forks.\\n    if (i_chainID != block.chainid) revert ForkedChain(i_chainID, block.chainid);\\n\\n    emit Transmitted(configDigest, uint32(uint256(reportContext[1]) >> 8));\\n\\n    uint256 expectedNumSignatures;\\n    if (i_uniqueReports) {\\n      expectedNumSignatures = (configInfo.n + configInfo.f) / 2 + 1;\\n    } else {\\n      expectedNumSignatures = configInfo.f + 1;\\n    }\\n    if (rs.length != expectedNumSignatures) revert WrongNumberOfSignatures();\\n    if (rs.length != ss.length) revert SignaturesOutOfRegistration();\\n\\n    // Scoping this reduces stack pressure and gas usage\\n    {\\n      Oracle memory transmitter = s_oracles[msg.sender];\\n      // Check that sender is authorized to report\\n      if (!(transmitter.role == Role.Transmitter && msg.sender == s_transmitters[transmitter.index]))\\n        revert UnauthorizedTransmitter();\\n    }\\n    // Scoping this reduces stack pressure and gas usage\\n    {\\n      uint256 expectedDataLength = uint256(TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT) +\\n        report.length + // one byte pure entry in _report\\n        rs.length *\\n        32 + // 32 bytes per entry in _rs\\n        ss.length *\\n        32; // 32 bytes per entry in _ss)\\n      if (msg.data.length != expectedDataLength) revert WrongMessageLength(expectedDataLength, msg.data.length);\\n    }\\n\\n    // Verify signatures attached to report\\n    bytes32 h = keccak256(abi.encodePacked(keccak256(report), reportContext));\\n    bool[MAX_NUM_ORACLES] memory signed;\\n\\n    uint256 numberOfSignatures = rs.length;\\n    for (uint256 i = 0; i < numberOfSignatures; ++i) {\\n      address signer = ecrecover(h, uint8(rawVs[i]) + 27, rs[i], ss[i]);\\n      // Since we disallow address(0) as a valid signer address, it can\\n      // never have a signer role.\\n      Oracle memory oracle = s_oracles[signer];\\n      if (oracle.role != Role.Signer) revert UnauthorizedSigner();\\n      if (signed[oracle.index]) revert NonUniqueSignatures();\\n      signed[oracle.index] = true;\\n    }\\n  }\\n\\n  /// @notice information about current offchain reporting protocol configuration\\n  /// @return configCount ordinal number of current config, out of all configs applied to this contract so far\\n  /// @return blockNumber block at which this config was set\\n  /// @return configDigest domain-separation tag for current config (see _configDigestFromConfigData)\\n  function latestConfigDetails()\\n    external\\n    view\\n    override\\n    returns (uint32 configCount, uint32 blockNumber, bytes32 configDigest)\\n  {\\n    return (s_configCount, s_latestConfigBlockNumber, s_configInfo.latestConfigDigest);\\n  }\\n\\n  /// @inheritdoc OCR2Abstract\\n  function latestConfigDigestAndEpoch()\\n    external\\n    view\\n    virtual\\n    override\\n    returns (bool scanLogs, bytes32 configDigest, uint32 epoch)\\n  {\\n    return (true, bytes32(0), uint32(0));\\n  }\\n\\n  function _report(bytes calldata report, uint40 epochAndRound) internal virtual;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/libraries/Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"./Client.sol\\\";\\nimport {MerkleMultiProof} from \\\"../libraries/MerkleMultiProof.sol\\\";\\n\\n// Library for CCIP internal definitions common to multiple contracts.\\nlibrary Internal {\\n  struct PriceUpdates {\\n    TokenPriceUpdate[] tokenPriceUpdates;\\n    uint64 destChainSelector; // --\u2510 Destination chain selector\\n    uint192 usdPerUnitGas; // -----\u2518 1e18 USD per smallest unit (e.g. wei) of destination chain gas\\n  }\\n\\n  struct TokenPriceUpdate {\\n    address sourceToken; // Source token\\n    uint192 usdPerToken; // 1e18 USD per smallest unit of token\\n  }\\n\\n  struct TimestampedUint192Value {\\n    uint192 value; // -------\u2510 The price, in 1e18 USD.\\n    uint64 timestamp; // ----\u2518 Timestamp of the most recent price update.\\n  }\\n\\n  struct PoolUpdate {\\n    address token; // The IERC20 token address\\n    address pool; // The token pool address\\n  }\\n\\n  struct ExecutionReport {\\n    EVM2EVMMessage[] messages;\\n    // Contains a bytes array for each message\\n    // each inner bytes array contains bytes per transferred token\\n    bytes[][] offchainTokenData;\\n    bytes32[] proofs;\\n    uint256 proofFlagBits;\\n  }\\n\\n  // @notice The cross chain message that gets committed to EVM chains\\n  struct EVM2EVMMessage {\\n    uint64 sourceChainSelector;\\n    uint64 sequenceNumber;\\n    uint256 feeTokenAmount;\\n    address sender;\\n    uint64 nonce;\\n    uint256 gasLimit;\\n    bool strict;\\n    // User fields\\n    address receiver;\\n    bytes data;\\n    Client.EVMTokenAmount[] tokenAmounts;\\n    address feeToken;\\n    bytes32 messageId;\\n  }\\n\\n  function _toAny2EVMMessage(\\n    EVM2EVMMessage memory original,\\n    Client.EVMTokenAmount[] memory destTokenAmounts\\n  ) internal pure returns (Client.Any2EVMMessage memory message) {\\n    message = Client.Any2EVMMessage({\\n      messageId: original.messageId,\\n      sourceChainSelector: original.sourceChainSelector,\\n      sender: abi.encode(original.sender),\\n      data: original.data,\\n      destTokenAmounts: destTokenAmounts\\n    });\\n  }\\n\\n  bytes32 internal constant EVM_2_EVM_MESSAGE_HASH = keccak256(\\\"EVM2EVMMessageEvent\\\");\\n\\n  function _hash(EVM2EVMMessage memory original, bytes32 metadataHash) internal pure returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encode(\\n          MerkleMultiProof.LEAF_DOMAIN_SEPARATOR,\\n          metadataHash,\\n          original.sequenceNumber,\\n          original.nonce,\\n          original.sender,\\n          original.receiver,\\n          keccak256(original.data),\\n          keccak256(abi.encode(original.tokenAmounts)),\\n          original.gasLimit,\\n          original.strict,\\n          original.feeToken,\\n          original.feeTokenAmount\\n        )\\n      );\\n  }\\n\\n  /// @notice Enum listing the possible message execution states within\\n  /// the offRamp contract.\\n  /// UNTOUCHED never executed\\n  /// IN_PROGRESS currently being executed, used a replay protection\\n  /// SUCCESS successfully executed. End state\\n  /// FAILURE unsuccessfully executed, manual execution is now enabled.\\n  enum MessageExecutionState {\\n    UNTOUCHED,\\n    IN_PROGRESS,\\n    SUCCESS,\\n    FAILURE\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/libraries/MerkleMultiProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary MerkleMultiProof {\\n  /// @notice Leaf domain separator, should be used as the first 32 bytes of a leaf's preimage.\\n  bytes32 internal constant LEAF_DOMAIN_SEPARATOR = 0x0000000000000000000000000000000000000000000000000000000000000000;\\n  /// @notice Internal domain separator, should be used as the first 32 bytes of an internal node's preiimage.\\n  bytes32 internal constant INTERNAL_DOMAIN_SEPARATOR =\\n    0x0000000000000000000000000000000000000000000000000000000000000001;\\n\\n  uint256 internal constant MAX_NUM_HASHES = 256;\\n\\n  error InvalidProof();\\n  error LeavesCannotBeEmpty();\\n\\n  /// @notice Computes the root based on provided pre-hashed leaf nodes in\\n  /// leaves, internal nodes in proofs, and using proofFlagBits' i-th bit to\\n  /// determine if an element of proofs or one of the previously computed leafs\\n  /// or internal nodes will be used for the i-th hash.\\n  /// @param leaves Should be pre-hashed and the first 32 bytes of a leaf's\\n  /// preimage should match LEAF_DOMAIN_SEPARATOR.\\n  /// @param proofs The hashes to be used instead of a leaf hash when the proofFlagBits\\n  ///  indicates a proof should be used.\\n  /// @param proofFlagBits A single uint256 of which each bit indicates whether a leaf or\\n  ///  a proof needs to be used in a hash operation.\\n  /// @dev the maximum number of hash operations it set to 256. Any input that would require\\n  ///  more than 256 hashes to get to a root will revert.\\n  /// @dev For given input `leaves` = [a,b,c] `proofs` = [D] and `proofFlagBits` = 5\\n  ///     totalHashes = 3 + 1 - 1 = 3\\n  ///  ** round 1 **\\n  ///    proofFlagBits = (5 >> 0) & 1 = true\\n  ///    hashes[0] = hashPair(a, b)\\n  ///    (leafPos, hashPos, proofPos) = (2, 0, 0);\\n  ///\\n  ///  ** round 2 **\\n  ///    proofFlagBits = (5 >> 1) & 1 = false\\n  ///    hashes[1] = hashPair(D, c)\\n  ///    (leafPos, hashPos, proofPos) = (3, 0, 1);\\n  ///\\n  ///  ** round 3 **\\n  ///    proofFlagBits = (5 >> 2) & 1 = true\\n  ///    hashes[2] = hashPair(hashes[0], hashes[1])\\n  ///    (leafPos, hashPos, proofPos) = (3, 2, 1);\\n  ///\\n  ///    i = 3 and no longer < totalHashes. The algorithm is done\\n  ///    return hashes[totalHashes - 1] = hashes[2]; the last hash we computed.\\n  // We mark this function as internal to force it to be inlined in contracts\\n  // that use it, but semantically it is public.\\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\\n  function merkleRoot(\\n    bytes32[] memory leaves,\\n    bytes32[] memory proofs,\\n    uint256 proofFlagBits\\n  ) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 leavesLen = leaves.length;\\n      uint256 proofsLen = proofs.length;\\n      if (leavesLen == 0) revert LeavesCannotBeEmpty();\\n      if (!(leavesLen <= MAX_NUM_HASHES + 1 && proofsLen <= MAX_NUM_HASHES + 1)) revert InvalidProof();\\n      uint256 totalHashes = leavesLen + proofsLen - 1;\\n      if (!(totalHashes <= MAX_NUM_HASHES)) revert InvalidProof();\\n      if (totalHashes == 0) {\\n        return leaves[0];\\n      }\\n      bytes32[] memory hashes = new bytes32[](totalHashes);\\n      (uint256 leafPos, uint256 hashPos, uint256 proofPos) = (0, 0, 0);\\n\\n      for (uint256 i = 0; i < totalHashes; ++i) {\\n        // Checks if the bit flag signals the use of a supplied proof or a leaf/previous hash.\\n        bytes32 a;\\n        if (proofFlagBits & (1 << i) == (1 << i)) {\\n          // Use a leaf or a previously computed hash.\\n          if (leafPos < leavesLen) {\\n            a = leaves[leafPos++];\\n          } else {\\n            a = hashes[hashPos++];\\n          }\\n        } else {\\n          // Use a supplied proof.\\n          a = proofs[proofPos++];\\n        }\\n\\n        // The second part of the hashed pair is never a proof as hashing two proofs would result in a\\n        // hash that can already be computed offchain.\\n        bytes32 b;\\n        if (leafPos < leavesLen) {\\n          b = leaves[leafPos++];\\n        } else {\\n          b = hashes[hashPos++];\\n        }\\n\\n        if (!(hashPos <= i)) revert InvalidProof();\\n\\n        hashes[i] = _hashPair(a, b);\\n      }\\n      if (!(hashPos == totalHashes - 1 && leafPos == leavesLen && proofPos == proofsLen)) revert InvalidProof();\\n      // Return the last hash.\\n      return hashes[totalHashes - 1];\\n    }\\n  }\\n\\n  /// @notice Hashes two bytes32 objects in their given order, prepended by the\\n  /// INTERNAL_DOMAIN_SEPARATOR.\\n  function _hashInternalNode(bytes32 left, bytes32 right) private pure returns (bytes32 hash) {\\n    return keccak256(abi.encode(INTERNAL_DOMAIN_SEPARATOR, left, right));\\n  }\\n\\n  /// @notice Hashes two bytes32 objects. The order is taken into account,\\n  /// using the lower value first.\\n  function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n    return a < b ? _hashInternalNode(a, b) : _hashInternalNode(b, a);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/access/OwnerIsCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {ConfirmedOwner} from \\\"../../ConfirmedOwner.sol\\\";\\n\\n/// @title The OwnerIsCreator contract\\n/// @notice A contract with helpers for basic contract ownership.\\ncontract OwnerIsCreator is ConfirmedOwner {\\n  constructor() ConfirmedOwner(msg.sender) {}\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/ocr/OCR2Abstract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {TypeAndVersionInterface} from \\\"../../interfaces/TypeAndVersionInterface.sol\\\";\\n\\nabstract contract OCR2Abstract is TypeAndVersionInterface {\\n  // Maximum number of oracles the offchain reporting protocol is designed for\\n  uint256 internal constant MAX_NUM_ORACLES = 31;\\n\\n  /// @notice triggers a new run of the offchain reporting protocol\\n  /// @param previousConfigBlockNumber block in which the previous config was set, to simplify historic analysis\\n  /// @param configDigest configDigest of this configuration\\n  /// @param configCount ordinal number of this config setting among all config settings over the life of this contract\\n  /// @param signers ith element is address ith oracle uses to sign a report\\n  /// @param transmitters ith element is address ith oracle uses to transmit a report via the transmit method\\n  /// @param f maximum number of faulty/dishonest oracles the protocol can tolerate while still working correctly\\n  /// @param onchainConfig serialized configuration used by the contract (and possibly oracles)\\n  /// @param offchainConfigVersion version of the serialization format used for \\\"offchainConfig\\\" parameter\\n  /// @param offchainConfig serialized configuration used by the oracles exclusively and only passed through the contract\\n  event ConfigSet(\\n    uint32 previousConfigBlockNumber,\\n    bytes32 configDigest,\\n    uint64 configCount,\\n    address[] signers,\\n    address[] transmitters,\\n    uint8 f,\\n    bytes onchainConfig,\\n    uint64 offchainConfigVersion,\\n    bytes offchainConfig\\n  );\\n\\n  /// @notice sets offchain reporting protocol configuration incl. participating oracles\\n  /// @param signers addresses with which oracles sign the reports\\n  /// @param transmitters addresses oracles use to transmit the reports\\n  /// @param f number of faulty oracles the system can tolerate\\n  /// @param onchainConfig serialized configuration used by the contract (and possibly oracles)\\n  /// @param offchainConfigVersion version number for offchainEncoding schema\\n  /// @param offchainConfig serialized configuration used by the oracles exclusively and only passed through the contract\\n  function setOCR2Config(\\n    address[] memory signers,\\n    address[] memory transmitters,\\n    uint8 f,\\n    bytes memory onchainConfig,\\n    uint64 offchainConfigVersion,\\n    bytes memory offchainConfig\\n  ) external virtual;\\n\\n  /// @notice information about current offchain reporting protocol configuration\\n  /// @return configCount ordinal number of current config, out of all configs applied to this contract so far\\n  /// @return blockNumber block at which this config was set\\n  /// @return configDigest domain-separation tag for current config (see _configDigestFromConfigData)\\n  function latestConfigDetails()\\n    external\\n    view\\n    virtual\\n    returns (uint32 configCount, uint32 blockNumber, bytes32 configDigest);\\n\\n  function _configDigestFromConfigData(\\n    uint256 chainId,\\n    address contractAddress,\\n    uint64 configCount,\\n    address[] memory signers,\\n    address[] memory transmitters,\\n    uint8 f,\\n    bytes memory onchainConfig,\\n    uint64 offchainConfigVersion,\\n    bytes memory offchainConfig\\n  ) internal pure returns (bytes32) {\\n    uint256 h = uint256(\\n      keccak256(\\n        abi.encode(\\n          chainId,\\n          contractAddress,\\n          configCount,\\n          signers,\\n          transmitters,\\n          f,\\n          onchainConfig,\\n          offchainConfigVersion,\\n          offchainConfig\\n        )\\n      )\\n    );\\n    uint256 prefixMask = type(uint256).max << (256 - 16); // 0xFFFF00..00\\n    uint256 prefix = 0x0001 << (256 - 16); // 0x000100..00\\n    return bytes32((prefix & prefixMask) | (h & ~prefixMask));\\n  }\\n\\n  /// @notice optionally emitted to indicate the latest configDigest and epoch for\\n  /// which a report was successfully transmitted. Alternatively, the contract may\\n  /// use latestConfigDigestAndEpoch with scanLogs set to false.\\n  event Transmitted(bytes32 configDigest, uint32 epoch);\\n\\n  /// @notice optionally returns the latest configDigest and epoch for which a\\n  /// report was successfully transmitted. Alternatively, the contract may return\\n  /// scanLogs set to true and use Transmitted events to provide this information\\n  /// to offchain watchers.\\n  /// @return scanLogs indicates whether to rely on the configDigest and epoch\\n  /// returned or whether to scan logs for the Transmitted event instead.\\n  /// @return configDigest\\n  /// @return epoch\\n  function latestConfigDigestAndEpoch()\\n    external\\n    view\\n    virtual\\n    returns (bool scanLogs, bytes32 configDigest, uint32 epoch);\\n\\n  /// @notice transmit is called to post a new report to the contract\\n  /// @param report serialized report, which the signatures are signing.\\n  /// @param rs ith element is the R components of the ith signature on report. Must have at most MAX_NUM_ORACLES entries\\n  /// @param ss ith element is the S components of the ith signature on report. Must have at most MAX_NUM_ORACLES entries\\n  /// @param rawVs ith element is the the V component of the ith signature\\n  function transmit(\\n    // NOTE: If these parameters are changed, expectedMsgDataLength and/or\\n    // TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT need to be changed accordingly\\n    bytes32[3] calldata reportContext,\\n    bytes calldata report,\\n    bytes32[] calldata rs,\\n    bytes32[] calldata ss,\\n    bytes32 rawVs // signatures\\n  ) external virtual;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/libraries/Client.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\\n    bytes data; // Data payload\\n    EVMTokenAmount[] tokenAmounts; // Token transfers\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\\n  }\\n\\n  // extraArgs will evolve to support new features\\n  // bytes4(keccak256(\\\"CCIP EVMExtraArgsV1\\\"));\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\\n    bool strict; // See strict sequencing details below.\\n  }\\n\\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"ds-test/=foundry-lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=foundry-lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=foundry-lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"openzeppelin-contracts/=foundry-lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 26000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"onRamp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"armProxy\",\"type\":\"address\"}],\"internalType\":\"struct CommitStore.StaticConfig\",\"name\":\"staticConfig\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadARMSignal\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"expected\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"actual\",\"type\":\"bytes32\"}],\"name\":\"ConfigDigestMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"ForkedChain\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCommitStoreConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"InvalidConfig\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"min\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"}],\"internalType\":\"struct CommitStore.Interval\",\"name\":\"interval\",\"type\":\"tuple\"}],\"name\":\"InvalidInterval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRoot\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LeavesCannotBeEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonUniqueSignatures\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OracleCannotBeZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PausedError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootAlreadyCommitted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignaturesOutOfRegistration\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StaleReport\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorizedSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorizedTransmitter\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"WrongMessageLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongNumberOfSignatures\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"onRamp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"armProxy\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct CommitStore.StaticConfig\",\"name\":\"staticConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"priceRegistry\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct CommitStore.DynamicConfig\",\"name\":\"dynamicConfig\",\"type\":\"tuple\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"previousConfigBlockNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"configDigest\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"configCount\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"transmitters\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"f\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"onchainConfig\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"offchainConfigVersion\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"offchainConfig\",\"type\":\"bytes\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"internalType\":\"uint192\",\"name\":\"usdPerToken\",\"type\":\"uint192\"}],\"internalType\":\"struct Internal.TokenPriceUpdate[]\",\"name\":\"tokenPriceUpdates\",\"type\":\"tuple[]\"},{\"internalType\":\"uint64\",\"name\":\"destChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint192\",\"name\":\"usdPerUnitGas\",\"type\":\"uint192\"}],\"internalType\":\"struct Internal.PriceUpdates\",\"name\":\"priceUpdates\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"min\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"}],\"internalType\":\"struct CommitStore.Interval\",\"name\":\"interval\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct CommitStore.CommitReport\",\"name\":\"report\",\"type\":\"tuple\"}],\"name\":\"ReportAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"RootRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"configDigest\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"}],\"name\":\"Transmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDynamicConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"priceRegistry\",\"type\":\"address\"}],\"internalType\":\"struct CommitStore.DynamicConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExpectedNextSequenceNumber\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPriceEpochAndRound\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"getMerkleRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStaticConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"chainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"onRamp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"armProxy\",\"type\":\"address\"}],\"internalType\":\"struct CommitStore.StaticConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransmitters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isARMHealthy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"isBlessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUnpausedAndARMHealthy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestConfigDetails\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"configCount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"configDigest\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestConfigDigestAndEpoch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"scanLogs\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"configDigest\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"rootToReset\",\"type\":\"bytes32[]\"}],\"name\":\"resetUnblessedRoots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"latestPriceEpochAndRound\",\"type\":\"uint40\"}],\"name\":\"setLatestPriceEpochAndRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"minSeqNr\",\"type\":\"uint64\"}],\"name\":\"setMinSeqNr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"transmitters\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"f\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"onchainConfig\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"offchainConfigVersion\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"offchainConfig\",\"type\":\"bytes\"}],\"name\":\"setOCR2Config\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[3]\",\"name\":\"reportContext\",\"type\":\"bytes32[3]\"},{\"internalType\":\"bytes\",\"name\":\"report\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"ss\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"rawVs\",\"type\":\"bytes32\"}],\"name\":\"transmit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"hashedLeaves\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"proofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"proofFlagBits\",\"type\":\"uint256\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CommitStore", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "26000", "ConstructorArguments": "00000000000000000000000000000000000000000000000045849994fc9c7b1500000000000000000000000000000000000000000000000033d343f77863cab8000000000000000000000000ad1b1f2a6dd55627e3893b771a00cd43f69dce35000000000000000000000000411de17f12d1a34ecc7f45f49844626267c75e81", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}