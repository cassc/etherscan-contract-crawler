{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ShipStore.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.18;\\n\\nimport \\\"openzeppelin/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"./Interfaces.sol\\\";\\n\\n/// @title ShipStore contract\\n/// @notice Allows anyone to create and manage any number of ShipStacks, and for other users to purchase ships from these stacks.\\n/// @author Logan Brutsche\\ncontract ShipStore {\\n    IAzimuth public azimuthContract;\\n\\n    /// @param _azimuthContract The address of the azimuth contract.\\n    constructor(IAzimuth _azimuthContract) {\\n        azimuthContract = _azimuthContract;\\n    }\\n\\n    ShipStack[] public shipStacks;\\n\\n    /// @notice Struct to represent a ship stack.\\n    struct ShipStack {\\n        address owner; // 0 indicates the stack has not been initialized\\n        address operator;\\n        address depositor;\\n        uint price;\\n        address exclusiveBuyer; // if not 0x0, this is the only address that can buy ships from this stack\\n        address payable revenueRecipient;\\n        bool deployed; // has the operator called deployStack yet?\\n        uint32[] ships;\\n    }\\n\\n    /// @notice Prepare a ShipStack to be deployed later\\n    /// @param _owner The owner of the stack. Can change operator and revenueRecipient, and transfer ownership\\n    /// @param _operator The address that will be allowed to deploy and manage the stack.\\n    /// @param _revenueRecipient The address to which revenue from pill sales will be sent.\\n    function prepStack(address _owner, address _operator, address _depositor, address payable _revenueRecipient)\\n        external\\n        returns (uint stackId)\\n    {\\n        require(_operator != address(0), \\\"can't set operator 0x0\\\");\\n\\n        // implicitly returns\\n        stackId = shipStacks.length;\\n\\n        ShipStack memory stack;\\n        stack.owner = _owner;\\n        stack.operator = _operator;\\n        stack.depositor = _depositor;\\n        stack.revenueRecipient = _revenueRecipient;\\n        \\n        shipStacks.push(stack);\\n    }\\n\\n    // onlyOwner funcs\\n\\n    /// @notice Set a new owner for a specific stack.\\n    /// @param _stackId The ID of the stack.\\n    /// @param _owner The new owner's address.\\n    /// @dev The caller must be the current owner.\\n    function setOwner(uint _stackId, address _owner)\\n        external\\n        onlyStackOwner(_stackId)\\n    {\\n        _setOwner(_stackId, _owner);\\n    }\\n    /// @notice Set a new operator for a specific stack.\\n    /// @param _stackId The ID of the stack.\\n    /// @param _operator The new operator's address.\\n    /// @dev The caller must be the current owner.\\n    function setOperator(uint _stackId, address _operator)\\n        external\\n        onlyStackOwner(_stackId)\\n    {\\n        _setOperator(_stackId, _operator);\\n    }\\n    /// @notice Sets the revenue recipient for a ship stack at shipStacks[msg.sender][_stackId].\\n    /// @dev Stack must be initialized.\\n    /// @param _stackId The identifier of the ship stack.\\n    /// @param _revenueRecipient The address to receive the revenue.\\n    function setRevenueRecipient(uint _stackId, address payable _revenueRecipient)\\n        public\\n        onlyStackOwner(_stackId)\\n    {\\n        _setRevenueRecipient(_stackId, _revenueRecipient);\\n    }\\n\\n    // onlyOperator funcs\\n\\n    /// @notice Sets the depositor for a ship stack.\\n    /// @dev Stack must be initialized.\\n    /// @dev Only callable by operator\\n    /// @param _stackId The identifier of the ship stack.\\n    /// @param _depositor The address allowed to deposit ships.\\n    function setDepositor(uint _stackId, address _depositor)\\n        external\\n        onlyStackOperator(_stackId)\\n    {\\n        _setDepositor(_stackId, _depositor);\\n    }\\n    /// @notice Deploy a stack with specified properties.\\n    /// @param _stackId The ID of the stack.\\n    /// @param _price The price for the stack.\\n    /// @param _exclusiveBuyer If set, only this address can buy a ship from this stack.\\n    /// @dev The caller must be the current operator.\\n    /// @dev Throws if the stack is already deployed.\\n    /// @dev Throws if the stack has not been prepped via prepStack.\\n    function deployStack(uint _stackId, uint _price, address _exclusiveBuyer)\\n        external\\n        onlyStackOperator(_stackId)\\n    {\\n        ShipStack storage stack = shipStacks[_stackId];\\n        require(!stack.deployed, \\\"stack already deployed\\\");\\n\\n        _setPrice(_stackId, _price);\\n        _setExclusiveBuyer(_stackId, _exclusiveBuyer);\\n        stack.deployed = true;\\n    }\\n    /// @notice Sets the price for a ship stack.\\n    /// @dev Stack must be initialized.\\n    /// @dev Only callable by the stack operator.\\n    /// @param _stackId The identifier of the ship stack.\\n    /// @param _price The new price for the ship stack.\\n    function setPrice(uint _stackId, uint _price)\\n        external\\n        onlyStackOperator(_stackId)\\n    {\\n        _setPrice(_stackId, _price);\\n    }\\n    /// @notice Sets exclusive buyer for a ship stack.\\n    /// @dev Stack must be initialized.\\n    /// @dev Only callable by the stack operator.\\n    /// @param _stackId The identifier of the ship stack.\\n    /// @param _exclusiveBuyer The address of the exclusive buyer.\\n    function setExclusiveBuyer(uint _stackId, address _exclusiveBuyer)\\n        public\\n        onlyStackOperator(_stackId)\\n    {\\n        _setExclusiveBuyer(_stackId, _exclusiveBuyer);\\n    }\\n\\n    // internal setters\\n\\n    /// @notice Internal function to set the owner of a stack.\\n    /// @param _stackId The ID of the stack.\\n    /// @param _owner The new owner address.\\n    function _setOwner(uint _stackId, address _owner) internal {\\n        shipStacks[_stackId].owner = _owner;\\n    }\\n    /// @notice Internal function to set the operator of a stack.\\n    /// @param _stackId The ID of the stack.\\n    /// @param _operator The new operator address.\\n    function _setOperator(uint _stackId, address _operator) internal {\\n        shipStacks[_stackId].operator = _operator;\\n    }\\n    /// @notice Internal function to set the depositor of a stack.\\n    /// @param _stackId The ID of the stack.\\n    /// @param _depositor The new depositor address.\\n    function _setDepositor(uint _stackId, address _depositor) internal {\\n        shipStacks[_stackId].depositor = _depositor;\\n    }\\n    /// @notice Internal function to set the revenue recipient of a stack.\\n    /// @param _stackId The ID of the stack.\\n    /// @param _revenueRecipient The new revenue recipient address.\\n    function _setRevenueRecipient(uint _stackId, address payable _revenueRecipient) internal {\\n        shipStacks[_stackId].revenueRecipient = _revenueRecipient;\\n    }\\n    /// @notice Internal function to set the price of a stack.\\n    /// @param _stackId The ID of the stack.\\n    /// @param _price The new price.\\n    function _setPrice(uint _stackId, uint _price) internal {\\n        shipStacks[_stackId].price = _price;\\n    }\\n    /// @notice Internal function to set the exclusive buyer of a stack.\\n    /// @param _stackId The ID of the stack.\\n    /// @param _exclusiveBuyer The new value of exclusiveBuyer.\\n    function _setExclusiveBuyer(uint _stackId, address _exclusiveBuyer) internal {\\n        shipStacks[_stackId].exclusiveBuyer = _exclusiveBuyer;\\n    }\\n\\n    /// @notice Modifier to ensure only the stack owner can call the function.\\n    /// @param _stackId The ID of the stack.\\n    modifier onlyStackOwner(uint _stackId) {\\n        requireValidStackId(_stackId);\\n        require(msg.sender == shipStacks[_stackId].owner, \\\"msg.sender != owner\\\");\\n        _;\\n    }\\n\\n    /// @notice Modifier to ensure only the stack operator can call the function.\\n    /// @param _stackId The ID of the stack.\\n    modifier onlyStackOperator(uint _stackId) {\\n        requireValidStackId(_stackId);\\n        require(msg.sender == shipStacks[_stackId].operator, \\\"msg.sender != operator\\\");\\n        _;\\n    }\\n\\n    /// @notice Modifier to ensure only the stack depositor can call the function.\\n    /// @param _stackId The ID of the stack.\\n    modifier onlyStackDepositor(uint _stackId) {\\n        requireValidStackId(_stackId);\\n        require(msg.sender == shipStacks[_stackId].depositor, \\\"msg.sender != depositor\\\");\\n        _;\\n    }\\n\\n    /// @notice Internal function to validate the given stack ID.\\n    /// @param _stackId The ID of the stack to validate.\\n    /// @dev Throws if the stack ID is out of range.\\n    function requireValidStackId(uint _stackId)\\n        internal\\n        view\\n    {\\n        require(_stackId < shipStacks.length, \\\"Invalid _stackId\\\");\\n    }\\n    \\n    /// @notice Retrieve information about a specific ship stack.\\n    /// @param _stackId The ID of the ship stack.\\n    /// @dev Stack must be initialized.\\n    /// @return owner The owner of the ship stack.\\n    /// @return operator The operator authorized for the ship stack.\\n    /// @return price The price to buy a ship.\\n    /// @return onlyBuyerIfSet If not the zero address, only this address can buy from this stack.\\n    /// @return revenueRecipient Address where revenue is forwarded.\\n    /// @return numShips The number of ships in this stack.\\n    function getStackInfo(uint _stackId)\\n        external\\n        view\\n        returns(\\n            address owner,\\n            address operator,\\n            uint price,\\n            address onlyBuyerIfSet,\\n            address payable revenueRecipient,\\n            uint numShips\\n        )\\n    {\\n        requireValidStackId(_stackId);\\n\\n        return(\\n            shipStacks[_stackId].owner,\\n            shipStacks[_stackId].operator,\\n            shipStacks[_stackId].price,\\n            shipStacks[_stackId].exclusiveBuyer,\\n            shipStacks[_stackId].revenueRecipient,\\n            shipStacks[_stackId].ships.length\\n        );\\n    }\\n\\n    /// @notice Deposits ships into a ship stack.\\n    /// @dev This contract must be approved to send each id (i.e. by calling setApprovalForAll)\\n    /// @dev msg.sender must be approved to send each id as defined by azimuthContract.canTransfer\\n    /// @param _stackId The identifier of the ship stack.\\n    /// @param _ids The array of ship IDs to deposit.\\n    function depositShips(uint _stackId, uint32[] calldata _ids)\\n        external\\n        onlyStackDepositor(_stackId)\\n    {\\n        ShipStack storage shipStack = shipStacks[_stackId];\\n\\n        IEcliptic ecliptic = IEcliptic(azimuthContract.owner());\\n        for (uint i; i<_ids.length;) {\\n            require(azimuthContract.canTransfer(_ids[i], msg.sender), \\\"msg.sender can't transfer point\\\");\\n\\n            ecliptic.transferPoint(_ids[i], address(this), false);\\n            shipStack.ships.push(_ids[i]);\\n\\n            unchecked { i ++ ;}\\n        }\\n    }\\n\\n    /// @notice Recalls ships from a ship stack.\\n    /// @dev Stack must be initialized.\\n    /// @param _stackId The identifier of the ship stack.\\n    /// @param _amount The number of ships to recall.\\n    /// @param _recipient The recipient of the recalled ships.\\n    /// @param breach Whether to breach the ship.\\n    function recallShips(uint _stackId, uint _amount, address _recipient, bool breach)\\n        external\\n        onlyStackDepositor(_stackId)\\n    {\\n        ShipStack storage shipStack = shipStacks[_stackId];\\n\\n        require(_amount <= shipStack.ships.length, \\\"Not that many ships in that stack\\\");\\n\\n        IEcliptic ecliptic = IEcliptic(azimuthContract.owner());\\n        for (uint i = 0; i < _amount;) {\\n            ecliptic.transferPoint(shipStack.ships[shipStack.ships.length - 1], _recipient, breach);\\n            shipStack.ships.pop();\\n\\n            unchecked { i ++ ;}\\n        }\\n    }\\n\\n    /// @notice Event emitted when a ship is bought.\\n    /// @param stackId The ID of the ship stack.\\n    /// @param recipient The address receiving the ship.\\n    event ShipBought(uint indexed stackId, address indexed recipient);\\n\\n    /// @notice Allows a user to buy a ship from a specific stack.\\n    /// @dev Checks for sufficient Ether and permissions before executing the purchase.\\n    /// @param _stackId The ID of the ship stack.\\n    /// @param _recipient The address to which the bought ship will be sent.\\n    /// @return shipId The ID of the bought ship.\\n    function buyShip(uint _stackId, address _recipient)\\n        external\\n        payable\\n        returns(uint32 shipId)\\n    {\\n        requireValidStackId(_stackId);\\n        require(shipStacks[_stackId].deployed, \\\"Ship stack not deployed\\\");\\n\\n        ShipStack storage shipStack = shipStacks[_stackId];\\n\\n        require(msg.value == shipStack.price, \\\"Incorrect ether amount included\\\");\\n        require(shipStack.ships.length > 0, \\\"Stack has no ships\\\");\\n        \\n        if (shipStack.exclusiveBuyer != address(0)) {\\n            require(msg.sender == shipStack.exclusiveBuyer, \\\"buyer not approved\\\");\\n        }\\n\\n        shipId = shipStack.ships[shipStack.ships.length - 1];\\n\\n        IEcliptic ecliptic = IEcliptic(azimuthContract.owner());\\n        ecliptic.transferPoint(shipId, _recipient, false);\\n        \\n        shipStack.ships.pop();\\n\\n        (bool success,) = shipStack.revenueRecipient.call{value: msg.value}(\\\"\\\");\\n        require(success, \\\"failed to forward revenue\\\");\\n\\n        emit ShipBought(_stackId, _recipient);\\n    }\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"src/Interfaces.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.18;\\n\\nimport \\\"openzeppelin/token/ERC721/IERC721.sol\\\";\\n\\ninterface IEcliptic is IERC721 {\\n    function transferPoint(uint32 _point, address _newOwner, bool _reset) external;\\n    function setTransferProxy(uint32 _point, address _transferProxy) external;\\n}\\n\\ninterface IAzimuth {\\n    function getOwner(uint32 _point) external view returns (address);\\n    function getOwnedPoints(address) external view returns (uint32[] memory);\\n    function owner() external view returns (address);\\n    function canTransfer(uint32 _point, address who) external view returns(bool);\\n}\\n\\ninterface ISoulboundAccessories {\\n    function miladyAuthority() external view returns(address);\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"sstore2/=lib/sstore2/contracts/\",\r\n      \"TokenGatedAccount/=lib/TokenGatedAccount/src/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IAzimuth\",\"name\":\"_azimuthContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stackId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"ShipBought\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"azimuthContract\",\"outputs\":[{\"internalType\":\"contract IAzimuth\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stackId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"buyShip\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"shipId\",\"type\":\"uint32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stackId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_exclusiveBuyer\",\"type\":\"address\"}],\"name\":\"deployStack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stackId\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"_ids\",\"type\":\"uint32[]\"}],\"name\":\"depositShips\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stackId\",\"type\":\"uint256\"}],\"name\":\"getStackInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onlyBuyerIfSet\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"revenueRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numShips\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_revenueRecipient\",\"type\":\"address\"}],\"name\":\"prepStack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stackId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stackId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"breach\",\"type\":\"bool\"}],\"name\":\"recallShips\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stackId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"setDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stackId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_exclusiveBuyer\",\"type\":\"address\"}],\"name\":\"setExclusiveBuyer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stackId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stackId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stackId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stackId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_revenueRecipient\",\"type\":\"address\"}],\"name\":\"setRevenueRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shipStacks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusiveBuyer\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"revenueRecipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"deployed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ShipStore", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000223c067f8cf28ae173ee5cafea60ca44c335fecb", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}