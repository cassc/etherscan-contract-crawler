// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol";

import {AccessControlEnumerable, IAccessControlEnumerable} from "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import {LicenseVersion, CantBeEvil} from "./CantBeEvil.sol";
import {IAnomuraEquipment} from "./interfaces/IAnomuraEquipment.sol";
import {IEquipmentData} from "./EquipmentData.sol";
import {IAnomuraEquipment, EquipmentMetadata, EquipmentType, EquipmentRarity} from "./interfaces/IAnomuraEquipment.sol";
import {IAnomuraSeeder} from "./interfaces/IAnomuraSeeder.sol";

///@dev seeder for equipment contract. This is not upgradeable
contract AnomuraSeeder is
    IAnomuraSeeder,
    VRFConsumerBaseV2,
    AccessControlEnumerable,
    CantBeEvil,
    AutomationCompatibleInterface
{
    IEquipmentData public equipmentData;
    IAnomuraEquipment public equipmentContract;
    VRFCoordinatorV2Interface public coordinator;

    address private _automationRegistry;

    bytes32 public keyHash;
    bytes32 public constant SEEDER_ROLE = keccak256("SEEDER_ROLE");

    uint16 private constant REQUEST_CONFIRMATIONS = 3;
    uint32 private constant CALLBACK_GAS_LIMIT = 240000;
    uint32 private constant NUM_WORDS = 1;
    uint64 public subscriptionId;
    uint256 private constant BATCH_SIZE = 50;

    mapping(uint256 => uint256) private _requestIdToGeneration;

    // genId => seed
    mapping(uint256 => uint256) private genSeed;

    /// @notice emitted when a random number is returned from Vrf callback
    /// @param requestId the request identifier, initially returned by {requestRandomness}
    /// @param randomness random number generated by chainlink vrf
    event RequestSeedFulfilled(uint256 indexed requestId, uint256 randomness);

    constructor(
        address coordinator_,
        bytes32 keyHash_,
        uint64 subscriptionId_,
        address equipmentData_
    )
        VRFConsumerBaseV2(address(coordinator_))
        CantBeEvil(LicenseVersion.PUBLIC)
    {
        coordinator = VRFCoordinatorV2Interface(address(coordinator_));
        keyHash = keyHash_;
        subscriptionId = subscriptionId_;
        equipmentData = IEquipmentData(equipmentData_);

        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(SEEDER_ROLE, _msgSender());
    }

    function requestSeed(uint256 _generationId)
        external
        onlyRole(SEEDER_ROLE)
        returns (uint256 requestId)
    {
        require(
            address(equipmentContract) != address(0x0),
            "Equipment contract not set"
        );
        if (equipmentContract.totalSupply() == 0) {
            revert("No token minted yet.");
        }
        uint256 divider = equipmentContract.totalSupply() / BATCH_SIZE;

        if (_generationId < 1 || _generationId > divider + 1) {
            revert("Invalid Generation Id");
        }
        if (genSeed[_generationId] != 0) {
            revert("Seed already set!");
        }
        requestId = coordinator.requestRandomWords(
            keyHash,
            subscriptionId,
            REQUEST_CONFIRMATIONS,
            CALLBACK_GAS_LIMIT,
            NUM_WORDS
        );

        _requestIdToGeneration[requestId] = _generationId;
    }

    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords)
        internal
        override
    {
        uint256 _generationId = _requestIdToGeneration[requestId];

        genSeed[_generationId] = randomWords[0];
        emit RequestSeedFulfilled(_generationId, randomWords[0]);
    }

    /// @dev To set the metadata manually instead of Chainlink Nodes, provided there is a seed for the tokenId.
    function setMetadataForToken(uint256 _tokenId) external
    {
        require(
            address(equipmentContract) != address(0x0),
            "Equipment contract not set"
        );
         require(
            address(equipmentData) != address(0x0),
            "Equipment data not set"
        );
        require(equipmentContract.isTokenExists(_tokenId), "Token not exists");
        require(equipmentContract.isMetadataReveal(_tokenId) == false, "Metadata revealed");

        uint256 _generationId = getGenerationOfToken(_tokenId);
        uint256 _generationSeed = genSeed[_generationId];

        require(_generationSeed != 0, "Seed not set for gen");

        uint256 _seedForThisToken = uint256(
            keccak256(abi.encode(_generationSeed, _tokenId))
        );

        string memory equipmentName;
        EquipmentRarity rarity;
        EquipmentType typeOf = equipmentData.pluckType(_seedForThisToken);

        if (typeOf == EquipmentType.BODY) {
            (equipmentName, rarity) = equipmentData.pluckBody(
                _seedForThisToken
            );
        } else if (typeOf == EquipmentType.CLAWS) {
            (equipmentName, rarity) = equipmentData.pluckClaws(
                _seedForThisToken
            );
        } else if (typeOf == EquipmentType.LEGS) {
            (equipmentName, rarity) = equipmentData.pluckLegs(
                _seedForThisToken
            );
        } else if (typeOf == EquipmentType.SHELL) {
            (equipmentName, rarity) = equipmentData.pluckShell(
                _seedForThisToken
            );
        } else if (typeOf == EquipmentType.HABITAT) {
            (equipmentName, rarity) = equipmentData.pluckHabitat(
                _seedForThisToken
            );
        } else if (typeOf == EquipmentType.HEADPIECES) {
            (equipmentName, rarity) = equipmentData.pluckHeadpieces(
                _seedForThisToken
            );
        } else {
            revert InvalidValue();
        }

        EquipmentMetadata memory metaData = EquipmentMetadata({
            name: equipmentName,
            equipmentRarity: rarity,
            equipmentType: typeOf
        });

        bytes memory _dataToSet = abi.encode(_tokenId, metaData);
        equipmentContract.revealMetadataForToken(_dataToSet);
    }

    function getGenerationOfToken(uint256 _tokenId)
        public
        view
        returns (uint256)
    {
        if (!equipmentContract.isTokenExists(_tokenId)) {
            /* 
            As we want to allow the upkeep to keep running for token that existed within the range.
            We just return 0 and check that the 0 generation is an invalid generation 
             */
            return 0;
        }
        uint256 divider = _tokenId / BATCH_SIZE;
        return divider + 1;
    }

    /// @dev Check() to be called by Chainlink automation nodes
    /// @param checkerData the data can be decoded into lower and upper bound.
    /// 1. Read the token metadata
    /// 2. If metadata not set, then put into array to be processed
    /// 3. Processing the array of token, get its seed and calculate its equipment type, name, rarity
    /// 4. Hash the data for the perform function.
    function checkUpkeep(bytes calldata checkerData)
        external
        view
        override
        returns (bool canExec, bytes memory execPayload)
    {
        (uint256 lowerBound, uint256 upperBound) = abi.decode(
            checkerData,
            (uint256, uint256)
        );

        require(
            lowerBound > 0 &&
                upperBound <= equipmentContract.totalSupply() &&
                lowerBound <= upperBound,
            "Lower and Upper not correct"
        );
        require(
            address(equipmentContract) != address(0x0),
            "Equipment not set"
        );
        require(
            address(equipmentData) != address(0x0),
            "Equipment Data not set"
        );

        uint256 counter = 0;

        for (uint256 i = 0; i < upperBound - lowerBound + 1; i++) {
            uint256 tokenId = lowerBound + i;

            if (
                !equipmentContract.isTokenExists(tokenId) ||
                equipmentContract.isMetadataReveal(tokenId) == true
            ) {
                continue;
            }

            uint256 _generationId = getGenerationOfToken(tokenId);
            uint256 _seed = genSeed[_generationId];

            /* When generation Id is 0 or genSeed mapping is not set by Chainlink VRF, then _seed is 0 */
            if (_seed == 0) {
                continue;
            }

            counter++;
            if (counter == 10) {
                /* 
                1. Due to gas limit on chainlink vs gelato, we split this into chunks, allowing the nodes to execute multiple times
                2. Each chunk processing only 10 tokens, provided the range may have 100 tokens.
                3. The next chunk only process the tokens that do not have metadata set yet.
                 */
                break;
            }
        }

        if (counter == 0) {
            return (false, "Meta set for range");
        }

        canExec = false;

        /* to determine how many elements in an array need to update */
        uint256[] memory tokenIds = new uint256[](counter);
        EquipmentMetadata[] memory metaDataArray = new EquipmentMetadata[](
            counter
        );

        uint256 indexToAdd = 0;
        for (uint256 i = 0; i < upperBound - lowerBound + 1; i++) {
            uint256 tokenId = lowerBound + i;

            uint256 _generationId = getGenerationOfToken(tokenId);
            uint256 _generationSeed = genSeed[_generationId];

            if (
                equipmentContract.isTokenExists(tokenId) &&
                _generationSeed != 0 &&
                equipmentContract.isMetadataReveal(tokenId) == false
            ) {
                // do not access array index using tokenId as it is not be the correct index of the array
                canExec = true;
                tokenIds[indexToAdd] = tokenId;

                uint256 _seedForThisToken = uint256(
                    keccak256(abi.encode(_generationSeed, tokenId))
                );
                string memory equipmentName;
                EquipmentRarity rarity;
                EquipmentType typeOf = equipmentData.pluckType(
                    _seedForThisToken
                );

                if (typeOf == EquipmentType.BODY) {
                    (equipmentName, rarity) = equipmentData.pluckBody(
                        _seedForThisToken
                    );
                } else if (typeOf == EquipmentType.CLAWS) {
                    (equipmentName, rarity) = equipmentData.pluckClaws(
                        _seedForThisToken
                    );
                } else if (typeOf == EquipmentType.LEGS) {
                    (equipmentName, rarity) = equipmentData.pluckLegs(
                        _seedForThisToken
                    );
                } else if (typeOf == EquipmentType.SHELL) {
                    (equipmentName, rarity) = equipmentData.pluckShell(
                        _seedForThisToken
                    );
                } else if (typeOf == EquipmentType.HABITAT) {
                    (equipmentName, rarity) = equipmentData.pluckHabitat(
                        _seedForThisToken
                    );
                } else if (typeOf == EquipmentType.HEADPIECES) {
                    (equipmentName, rarity) = equipmentData.pluckHeadpieces(
                        _seedForThisToken
                    );
                } else {
                    return (false, "Invalid equipment type");
                }

                metaDataArray[indexToAdd] = EquipmentMetadata({
                    name: equipmentName,
                    equipmentRarity: rarity,
                    equipmentType: typeOf
                });

                indexToAdd++;
            }
            if (indexToAdd == 10) { /*index to add and counter must match, there should be 10 items to process each chunk */
                break;
            }
        }

        if (canExec == false) {
            return (false, "Nothing to set");
        }

        bytes memory performData = abi.encode(tokenIds, metaDataArray);
        return (canExec, performData);
    }

    /// @dev Function to be executed by Chainlink automation node, based on the data returned by checkUpkeep()
    /// @param performData the data returned by checkUpkeep
    /// Should only be called by automation registry.
    function performUpkeep(bytes calldata performData) external {
        require(
            _automationRegistry == msg.sender ||
                hasRole(DEFAULT_ADMIN_ROLE, msg.sender),
            "Not approved to perform upkeep"
        );

        (
            uint256[] memory tokenIds,
            EquipmentMetadata[] memory metaDataArray
        ) = abi.decode(performData, (uint256[], EquipmentMetadata[]));

        if (tokenIds.length != metaDataArray.length) {
            revert("Invalid performData");
        }

        // cross check that the data provided by the Automation Nodes is not corrupted.
        for (uint256 index = 0; index < tokenIds.length; index++) {
            uint256 tokenId = tokenIds[index];

            uint256 _generationId = getGenerationOfToken(tokenId);
            uint256 _generationSeed = genSeed[_generationId];

            if (
                _generationSeed == 0 ||
                equipmentContract.isMetadataReveal(tokenId)== true
            ) {
                continue;
            }

            bytes memory _dataToSet = abi.encode(tokenId, metaDataArray[index]);
            equipmentContract.revealMetadataForToken(_dataToSet);
        }
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(CantBeEvil, AccessControlEnumerable)
        returns (bool)
    {
        return
            type(IAccessControlEnumerable).interfaceId == interfaceId ||
            CantBeEvil.supportsInterface(interfaceId) ||
            super.supportsInterface(interfaceId);
    }

    function setEquipmentContractAddress(address _equipmentContract)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        equipmentContract = IAnomuraEquipment(_equipmentContract);
    }

    /**
    @dev Manual set the address of the Anomura Equipment Data contract
    @param equipmentData_ Address of Equipment Data
    */
    function setEquipmentDataAddress(address equipmentData_)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        equipmentData = IEquipmentData(equipmentData_);
    }

    /**
    @dev Manual set the address of Chainlink automation registry
    @param automationRegistry_ new registry address
    */
    function setAutomationRegistry(address automationRegistry_)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        _automationRegistry = automationRegistry_;
    }

    /**
    @dev Manual set the subscription of Chainlink automation registry. Used when we move to another chainlink subscription on mainnet
    @param subscriptionId_ new subscriptionId
    */
    function setSubscriptionId(uint64 subscriptionId_)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        subscriptionId = subscriptionId_;
    }

    /**
    @dev Manual set the keyash for Chainlink
    @param keyHash_ new keyHash
    */
    function setKeyHash(bytes32 keyHash_)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        keyHash = keyHash_;
    }
}