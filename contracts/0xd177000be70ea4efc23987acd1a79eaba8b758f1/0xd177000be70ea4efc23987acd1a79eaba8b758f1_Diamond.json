{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Diamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.21;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {LibDiamond} from \\\"contracts/libraries/LibDiamond.sol\\\";\\n\\nimport {IDiamondLoupe} from \\\"contracts/interfaces/IDiamondLoupe.sol\\\";\\nimport {IDiamondCut} from \\\"contracts/interfaces/IDiamondCut.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport {AppStorage} from \\\"contracts/libraries/AppStorage.sol\\\";\\nimport {Errors} from \\\"contracts/libraries/Errors.sol\\\";\\nimport {Constants} from \\\"contracts/libraries/Constants.sol\\\";\\n\\n// See https://github.com/mudgen/diamond-2-hardhat/blob/main/contracts/Diamond.sol\\n// All code taken from diamond implementation, other than init code\\n\\ncontract Diamond {\\n    AppStorage internal s;\\n\\n    constructor(address _contractOwner, address _diamondCutFacet, address _baseOracle)\\n        payable\\n    {\\n        require(_contractOwner != address(0), \\\"Diamond: owner can't be address(0)\\\");\\n        LibDiamond.setContractOwner(_contractOwner);\\n        s.admin = _contractOwner;\\n\\n        // Add the diamondCut external function from the diamondCutFacet\\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n        cut[0] = IDiamondCut.FacetCut({\\n            facetAddress: _diamondCutFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n        LibDiamond.diamondCut(cut, address(0), \\\"\\\");\\n\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        // adding ERC165 data\\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\\n        ds.supportedInterfaces[type(IERC721).interfaceId] = true;\\n\\n        // @dev init code\\n        // reentrantStatus needs to be initialized or else the first time nonreentrant is called reentrancy is possible\\n        s.reentrantStatus = Constants.NOT_ENTERED;\\n        // initialize to set slot\\n        s.tokenIdCounter = s.flaggerIdCounter = Constants.HEAD;\\n        s.name = \\\"DITTO_NFT\\\";\\n        s.symbol = \\\"DNFT\\\";\\n        require(_baseOracle != address(0), \\\"Base oracle can't be address(0)\\\");\\n        s.baseOracle = _baseOracle;\\n    }\\n\\n    // Find facet for function that is called and execute the\\n    // function if a facet is found and return any value.\\n    fallback() external payable {\\n        LibDiamond.DiamondStorage storage ds;\\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n        // get diamond storage\\n        assembly {\\n            ds.slot := position\\n        }\\n\\n        // get facet from function selector\\n        address facet = address(bytes20(ds.facets[msg.sig]));\\n        if (facet == address(0)) revert Errors.FunctionNotFound(msg.sig);\\n\\n        // Execute external function from facet using delegatecall and return any value.\\n        assembly {\\n            // copy function selector and any arguments\\n            calldatacopy(0, 0, calldatasize())\\n            // execute function call using the facet\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            // get any return value\\n            returndatacopy(0, 0, returndatasize())\\n            // return any return value or error back to the caller\\n            switch result\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    receive() external payable {\\n        revert(\\\"Diamond: Does not accept ether\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/**\\n * \\\\\\n * Author: Nick Mudge\\n *\\n * Implementation of Diamond facet.\\n * Uses the diamond-2 version 1.3.4 implementation:\\n * https://github.com/mudgen/diamond-2\\n *\\n * This is gas optimized by reducing storage reads and storage writes.\\n * This code is as complex as it is to reduce gas costs.\\n * /*****************************************************************************\\n */\\n\\nimport {IDiamondCut} from \\\"contracts/interfaces/IDiamondCut.sol\\\";\\n\\n/* solhint-disable */\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // owner of the contract\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(\\n            msg.sender == diamondStorage().contractOwner,\\n            \\\"LibDiamond: Must be contract owner\\\"\\n        );\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        if (selectorCount % 8 > 0) {\\n            // get last selectorSlot\\n            selectorSlot = ds.selectorSlots[selectorCount / 8];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        if (selectorCount % 8 > 0) {\\n            ds.selectorSlots[selectorCount / 8] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_selectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            require(\\n                _newFacetAddress != address(0),\\n                \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n            );\\n            enforceHasContractCode(\\n                _newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\"\\n            );\\n            for (\\n                uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++\\n            ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(\\n                    address(bytes20(oldFacet)) == address(0),\\n                    \\\"LibDiamondCut: Can't add function that already exists\\\"\\n                );\\n                // add facet for selector\\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                uint256 selectorInSlotPosition = (_selectorCount % 8) * 32;\\n                // clear selector position in slot and add selector\\n                _selectorSlot = (\\n                    _selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)\\n                ) | (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    ds.selectorSlots[_selectorCount / 8] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            require(\\n                _newFacetAddress != address(0),\\n                \\\"LibDiamondCut: Replace facet can't be address(0)\\\"\\n            );\\n            enforceHasContractCode(\\n                _newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\"\\n            );\\n            for (\\n                uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++\\n            ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(\\n                    oldFacetAddress != address(this),\\n                    \\\"LibDiamondCut: Can't replace immutable function\\\"\\n                );\\n                require(\\n                    oldFacetAddress != _newFacetAddress,\\n                    \\\"LibDiamondCut: Can't replace function with same function\\\"\\n                );\\n                require(\\n                    oldFacetAddress != address(0),\\n                    \\\"LibDiamondCut: Can't replace function that doesn't exist\\\"\\n                );\\n                // replace old facet address\\n                ds.facets[selector] =\\n                    (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(\\n                _newFacetAddress == address(0),\\n                \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\n            );\\n            uint256 selectorSlotCount = _selectorCount / 8;\\n            uint256 selectorInSlotIndex = (_selectorCount % 8) - 1;\\n            for (\\n                uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++\\n            ) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(\\n                        address(bytes20(oldFacet)) != address(0),\\n                        \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n                    );\\n                    // only useful if immutable functions exist\\n                    require(\\n                        address(bytes20(oldFacet)) != address(this),\\n                        \\\"LibDiamondCut: Can't remove immutable function\\\"\\n                    );\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex * 32));\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK)\\n                            | bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount / 8;\\n                    oldSelectorInSlotPosition = (oldSelectorCount % 8) * 32;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n                    // clears the selector being deleted and puts the last selector in its place.\\n                    oldSelectorSlot = (\\n                        oldSelectorSlot\\n                            & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)\\n                    ) | (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector being deleted and puts the last selector in its place.\\n                    _selectorSlot = (\\n                        _selectorSlot\\n                            & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)\\n                    ) | (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n                selectorInSlotIndex--;\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex + 1;\\n        } else {\\n            revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(\\n                _calldata.length == 0,\\n                \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\"\\n            );\\n        } else {\\n            require(\\n                _calldata.length > 0,\\n                \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\"\\n            );\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (success == false) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage)\\n        internal\\n        view\\n    {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/*\\n * Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n */\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet)\\n        external\\n        view\\n        returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector)\\n        external\\n        view\\n        returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n/*\\n * Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n */\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AppStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.21;\\n\\nimport {STypes, F, SR} from \\\"contracts/libraries/DataTypes.sol\\\";\\nimport {LibDiamond} from \\\"contracts/libraries/LibDiamond.sol\\\";\\nimport {Errors} from \\\"contracts/libraries/Errors.sol\\\";\\nimport {Constants} from \\\"contracts/libraries/Constants.sol\\\";\\n\\n// import {console} from \\\"contracts/libraries/console.sol\\\";\\n\\nstruct AppStorage {\\n    address admin;\\n    address ownerCandidate;\\n    address baseOracle;\\n    uint24 flaggerIdCounter;\\n    uint40 tokenIdCounter; //NFT - As of 2023, Ethereum had ~2B total tx. Uint40 max value is 1T, which is more than enough for NFTs\\n    uint8 reentrantStatus;\\n    // DETH\\n    mapping(address deth => uint256 vault) dethVault;\\n    // Bridge\\n    mapping(address bridge => STypes.Bridge) bridge;\\n    // Vault\\n    mapping(uint256 vault => STypes.Vault) vault;\\n    mapping(uint256 vault => address[]) vaultBridges;\\n    mapping(uint256 vault => mapping(address account => STypes.VaultUser)) vaultUser;\\n    // Assets\\n    mapping(address asset => STypes.Asset) asset;\\n    mapping(address asset => mapping(address account => STypes.AssetUser)) assetUser;\\n    // Assets - Orderbook\\n    mapping(address asset => mapping(uint16 id => STypes.Order)) bids;\\n    mapping(address asset => mapping(uint16 id => STypes.Order)) asks;\\n    mapping(address asset => mapping(uint16 id => STypes.Order)) shorts;\\n    mapping(\\n        address asset\\n            => mapping(address account => mapping(uint8 id => STypes.ShortRecord))\\n        ) shortRecords;\\n    mapping(uint24 flaggerId => address flagger) flagMapping;\\n    // ERC721\\n    mapping(uint256 tokenId => STypes.NFT) nftMapping;\\n    mapping(uint256 tokenId => address) getApproved;\\n    mapping(address owner => mapping(address operator => bool)) isApprovedForAll;\\n    // ERC721 - Assets\\n    address[] assets;\\n    mapping(uint256 assetId => address) assetMapping;\\n    // ERC721 - METADATA STORAGE/LOGIC\\n    string name;\\n    string symbol;\\n}\\n\\nfunction appStorage() pure returns (AppStorage storage s) {\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n        s.slot := 0\\n    }\\n}\\n\\ncontract Modifiers {\\n    AppStorage internal s;\\n\\n    modifier onlyDAO() {\\n        LibDiamond.enforceIsContractOwner();\\n        _;\\n    }\\n\\n    modifier onlyAdminOrDAO() {\\n        if (msg.sender != LibDiamond.contractOwner() && msg.sender != s.admin) {\\n            revert Errors.NotOwnerOrAdmin();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyDiamond() {\\n        if (msg.sender != address(this)) revert Errors.NotDiamond();\\n        _;\\n    }\\n\\n    modifier onlyValidAsset(address asset) {\\n        if (s.asset[asset].vault == 0) revert Errors.InvalidAsset();\\n        _;\\n    }\\n\\n    modifier isNotFrozen(address asset) {\\n        if (s.asset[asset].frozen != F.Unfrozen) revert Errors.AssetIsFrozen();\\n        _;\\n    }\\n\\n    modifier isPermanentlyFrozen(address asset) {\\n        if (s.asset[asset].frozen != F.Permanent) {\\n            revert Errors.AssetIsNotPermanentlyFrozen();\\n        }\\n        _;\\n    }\\n\\n    function _onlyValidShortRecord(address asset, address shorter, uint8 id)\\n        internal\\n        view\\n    {\\n        uint8 maxId = s.assetUser[asset][shorter].shortRecordIdCounter;\\n        if (id >= maxId) revert Errors.InvalidShortId();\\n        if (id < Constants.SHORT_STARTING_ID) revert Errors.InvalidShortId();\\n        if (s.shortRecords[asset][shorter][id].status == SR.Closed) {\\n            revert Errors.InvalidShortId();\\n        }\\n    }\\n\\n    modifier onlyValidShortRecord(address asset, address shorter, uint8 id) {\\n        _onlyValidShortRecord(asset, shorter, id);\\n        _;\\n    }\\n\\n    modifier nonReentrant() {\\n        if (s.reentrantStatus == Constants.ENTERED) revert Errors.ReentrantCall();\\n        s.reentrantStatus = Constants.ENTERED;\\n        _;\\n        s.reentrantStatus = Constants.NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrantView() {\\n        if (s.reentrantStatus == Constants.ENTERED) revert Errors.ReentrantCallView();\\n        _;\\n    }\\n\\n    modifier onlyValidBridge(address bridge) {\\n        if (s.bridge[bridge].vault == 0) revert Errors.InvalidBridge();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.21;\\n\\nlibrary Errors {\\n    error AlreadyMinted();\\n    error AssetIsFrozen();\\n    error AssetIsNotPermanentlyFrozen();\\n    error BadHintIdArray();\\n    error BadShortHint();\\n    error BridgeAlreadyCreated();\\n    error CannotCancelMoreThan1000Orders();\\n    error CannotExitPartialFillSR();\\n    error CannotFlagSelf();\\n    error CannotLeaveDustAmount();\\n    error CannotLiquidateSelf();\\n    error CannotMintAnymoreNFTs();\\n    error CannotMintLastShortRecord();\\n    error CannotSocializeDebt();\\n    error CannotTransferFlaggableShort();\\n    error CannotTransferFlaggedShort();\\n    error CollateralHigherThanMax();\\n    error CRLowerThanMin();\\n    error DifferentVaults();\\n    error ExitShortPriceTooLow();\\n    error FirstShortDeleted();\\n    error FirstShortMustBeNFT();\\n    error FunctionNotFound(bytes4 _functionSelector);\\n    error AlreadyLiquidatable();\\n    error InvalidAmount();\\n    error InvalidAsset();\\n    error InvalidBridge();\\n    error InvalidBuyback();\\n    error InvalidFlaggerHint();\\n    error InvalidInitialCR();\\n    error InvalidMsgValue();\\n    error InvalidPrice();\\n    error InvalidShortId();\\n    error InvalidTithe();\\n    error InvalidTokenId();\\n    error InvalidTwapPrice();\\n    error InvalidTWAPSecondsAgo();\\n    error InvalidVault();\\n    error InvalidDeth();\\n    error InsufficientWalletBalance();\\n    error InsufficientCollateral();\\n    error InsufficientERCEscrowed();\\n    error InsufficientETHEscrowed();\\n    error InsufficientEthInLiquidityPool();\\n    error InsufficientNumberOfShorts();\\n    error IsNotNFT();\\n    error LiquidationAlreadyFlagged();\\n    error LiquidationIneligibleWindow();\\n    error SecondaryLiquidationNoValidShorts();\\n    error MarketAlreadyCreated();\\n    error NoDittoReward();\\n    error NoSells();\\n    error NoShares();\\n    error NotActiveOrder();\\n    error NotBridgeForBaseCollateral();\\n    error NotDiamond();\\n    error NotLastOrder();\\n    error NotMinted();\\n    error NotOwner();\\n    error NotOwnerOrAdmin();\\n    error NotOwnerCandidate();\\n    error NoYield();\\n    error OrderIdCountTooLow();\\n    error OrderUnderMinimumSize();\\n    error OriginalShortRecordCancelled();\\n    error ParameterIsZero();\\n    error PostExitCRLtPreExitCR();\\n    error PriceOrAmountIs0();\\n    error ReceiverExceededShortRecordLimit();\\n    error ReentrantCall();\\n    error ReentrantCallView();\\n    error ShortNotFlagged();\\n    error ShortRecordIdOverflow();\\n    error ShortRecordIdsNotSorted();\\n    error SufficientCollateral();\\n    error TooManyHints();\\n    error UnderMinimum();\\n    error UnderMinimumDeposit();\\n    error VaultAlreadyCreated();\\n\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.21;\\n\\nlibrary Constants {\\n    // @dev mark start of orders mapping\\n    uint8 internal constant HEAD = 1;\\n    // @dev only used as an alias since it's the same id\\n    uint8 internal constant TAIL = 1;\\n    // for all order types, starting point of orders\\n    uint8 internal constant STARTING_ID = 100;\\n    uint8 internal constant SHORT_MAX_ID = 254; // max uint8\\n    uint8 internal constant SHORT_STARTING_ID = 2;\\n\\n    uint256 internal constant DUST_FACTOR = 0.5 ether;\\n    uint256 internal constant MIN_DURATION = 14 days;\\n    uint256 internal constant CRATIO_MAX = 15 ether;\\n    uint256 internal constant YIELD_DELAY_SECONDS = 60; // just need enough to prevent flash loan\\n    uint256 internal constant BRIDGE_YIELD_UPDATE_THRESHOLD = 1000 ether;\\n    uint256 internal constant BRIDGE_YIELD_PERCENT_THRESHOLD = 0.01 ether; // 1%\\n\\n    // Bridge\\n    // @dev Matching RocketPool min deposit for now, Lido is 100 wei\\n    uint88 internal constant MIN_DEPOSIT = 0.01 ether;\\n\\n    // re-entrancy\\n    uint8 internal constant NOT_ENTERED = 1;\\n    uint8 internal constant ENTERED = 2;\\n    uint256 internal constant ONE_DECIMAL_PLACES = 10;\\n    uint256 internal constant TWO_DECIMAL_PLACES = 100;\\n    uint256 internal constant THREE_DECIMAL_PLACES = 1000;\\n    uint256 internal constant FOUR_DECIMAL_PLACES = 10000;\\n    uint256 internal constant FIVE_DECIMAL_PLACES = 100000;\\n    uint256 internal constant SIX_DECIMAL_PLACES = 1000000;\\n\\n    // set this to a datetime closer to deployment\\n    // @dev changing this will likely break the end to end fork test\\n    uint256 internal constant STARTING_TIME = 1660353637;\\n\\n    int256 internal constant PREV = -1;\\n    int256 internal constant EXACT = 0;\\n    int256 internal constant NEXT = 1;\\n\\n    bool internal constant MARKET_ORDER = true;\\n    bool internal constant LIMIT_ORDER = false;\\n\\n    // Oracle\\n    // Base Oracle needs to be adjust 10**10 to have full 18 precision\\n    int256 internal constant BASE_ORACLE_DECIMALS = 10 ** 10;\\n\\n    // Mainnet TWAP\\n    address internal constant USDC_WETH =\\n        address(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640);\\n    address internal constant USDC = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\\n    address internal constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n    uint128 internal constant UNISWAP_WETH_BASE_AMT = 1 ether;\\n    uint256 internal constant DECIMAL_USDC = 10 ** 6; //USDC's ERC contract sets to 6 decimals\\n}\\n\\nlibrary Vault {\\n    // ONE is the default vault\\n    uint256 internal constant ONE = 1;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.21;\\n\\n// import {console} from \\\"contracts/libraries/console.sol\\\";\\n\\n//@dev leave room for others frozen types\\n//@dev Asset frozen status\\nenum F {\\n    Unfrozen,\\n    Permanent\\n}\\n\\n// @dev if this is changed, modify orderTypetoString in libraries/console.sol\\n// @dev Order types\\nenum O {\\n    Uninitialized,\\n    LimitBid,\\n    LimitAsk,\\n    MarketBid,\\n    MarketAsk,\\n    LimitShort,\\n    Cancelled,\\n    Matched\\n}\\n\\n// @dev ShortRecord status\\nenum SR {\\n    PartialFill,\\n    FullyFilled,\\n    Closed\\n}\\n\\n// @dev oracle frequency\\nenum OF {\\n    OneHour,\\n    FifteenMinutes\\n}\\n\\n// 2**n-1 with 18 decimals (prices, amount)\\n// uint64 = 18.45\\n// uint72 = 4.722k\\n// uint80 = 1.2m\\n// uint88 = 300m\\n// uint96 = 79B\\n// uint104 = 1.2t\\n\\n// DataTypes used in storage\\nlibrary STypes {\\n    // 2 slots\\n    struct Order {\\n        // SLOT 1: 88 + 80 + 16 + 16 + 16 + 8 + 8 + 16 + 8 = 256\\n        uint88 ercAmount; // max 300m erc\\n        uint80 price; // max 1.2m eth\\n        // max orders 65k, with id re-use\\n        uint16 prevId;\\n        uint16 id;\\n        uint16 nextId;\\n        O orderType;\\n        // @dev diff against contract creation timestamp to prevent overflow in 2106\\n        uint32 creationTime; // seconds\\n        // SLOT 2: 160 + 32 = 192 (64 unused)\\n        address addr; // 160\\n        O prevOrderType;\\n        // @dev storing as 170 with 2 decimals -> 1.70 ether\\n        uint16 initialCR; // @dev only used for LimitShort\\n        uint8 shortRecordId; // @dev only used for LimitShort\\n        uint64 filler;\\n    }\\n\\n    // 2 slots\\n    // @dev dethYieldRate should match Vault\\n    struct ShortRecord {\\n        // SLOT 1: 88 + 88 + 80 = 256\\n        uint88 collateral; // price * ercAmount * initialCR\\n        uint88 ercDebt; // same as Order.ercAmount\\n        uint80 dethYieldRate;\\n        // SLOT 2: 64 + 40 + 32 + 24 + 8 + 8 + 8 + 8 = 184 (64 remaining)\\n        SR status;\\n        uint8 prevId;\\n        uint8 id;\\n        uint8 nextId;\\n        uint64 ercDebtRate; // socialized penalty rate\\n        uint32 updatedAt; // seconds\\n        uint32 flaggedAt; // seconds\\n        uint24 flaggerId;\\n        uint40 tokenId; // As of 2023, Ethereum had ~2B total tx. Uint40 max value is 1T, which is more than enough\\n    }\\n\\n    struct NFT {\\n        // SLOT 1: 160 + 8 + 8 = 176 (80 unused)\\n        address owner;\\n        uint8 assetId;\\n        uint8 shortRecordId;\\n    }\\n\\n    // uint8:  [0-255]\\n    // uint16: [0-65_535]\\n    // @dev see testMultiAssetSettings()\\n    struct Asset {\\n        // SLOT 1: 104 + 88 + 16 + 16 + 16 + 8 + 8 = 256 (0 unused)\\n        uint104 ercDebt; // max 20.2T\\n        uint88 dethCollateral;\\n        uint16 startingShortId;\\n        uint16 orderIdCounter; // max is uint16 but need to throw/handle that?\\n        uint16 initialCR; // 5 ether -> [1-10, 2 decimals]\\n        F frozen; // 0 or 1\\n        uint8 vault;\\n        // SLOT 2 (Liquidation Parameters)\\n        // 64 + 16*3 + 8*10 = 192 (64 unused)\\n        uint8 minBidEth; // 10 -> (1 * 10**18 / 10**2) = 0.1 ether\\n        uint8 minAskEth; // 10 -> (1 * 10**18 / 10**2) = 0.1 ether\\n        uint16 minShortErc; // 2000 -> (2000 * 10**18) -> 2000 ether\\n        uint8 minimumCR; // 1.1 ether -> [1-2, 2 decimals]\\n        uint8 tappFeePct; // 0.025 ether -> [0-2.5%, 3 decimals]\\n        uint8 callerFeePct; // 0.005 ether -> [0-2.5%, 3 decimals]\\n        uint8 forcedBidPriceBuffer; // 1.1 ether -> [1-2, 2 decimals]\\n        uint8 assetId;\\n        uint64 ercDebtRate; // max 18x, socialized penalty rate\\n        uint16 primaryLiquidationCR; // 1.5 ether -> [1-5, 2 decimals]\\n        uint16 secondaryLiquidationCR; // 1.4 ether -> [1-5, 2 decimals]\\n        uint8 resetLiquidationTime; // 12 hours -> [1-48 hours, 0 decimals]\\n        uint8 secondLiquidationTime; // 8 hours -> [1-48 hours, 0 decimals]\\n        uint8 firstLiquidationTime; // 6 hours -> [1-48 hours, 0 decimals]\\n        uint64 filler; // keep slots distinct\\n        // SLOT 3 (Chainlink)\\n        address oracle; // for non-usd asset\\n    }\\n\\n    // 3 slots\\n    // @dev dethYieldRate should match ShortRecord\\n    struct Vault {\\n        // SLOT 1: 88 + 88 + 80 = 256 (0 unused)\\n        uint88 dethCollateral; // max 309m, 18 decimals\\n        uint88 dethTotal; // max 309m, 18 decimals\\n        uint80 dethYieldRate; // onlyUp\\n        // SLOT 2: 88 + 16 + 16 = 136 (128 unused)\\n        // tracked for shorter ditto rewards\\n        uint88 dethCollateralReward; // onlyUp\\n        uint16 dethTithePercent; // [0-100, 2 decimals]\\n        uint16 dittoShorterRate; // per unit of dethCollateral\\n        uint128 filler2;\\n        // SLOT 3: 128 + 96 + 16 + 16 = 256\\n        uint128 dittoMatchedShares;\\n        uint96 dittoMatchedReward; // max 79B, 18 decimals\\n        uint16 dittoMatchedRate;\\n        uint16 dittoMatchedTime; // last claim (in days) from STARTING_TIME\\n    }\\n\\n    // 1 slots\\n    struct AssetUser {\\n        // SLOT 1: 104 + 24 + 32 + 8 = 168 (88 unused)\\n        uint104 ercEscrowed;\\n        uint24 g_flaggerId;\\n        uint32 g_flaggedAt; // represents the most recent flag - in hours\\n        uint8 shortRecordIdCounter;\\n        uint96 filler;\\n    }\\n\\n    // 1 slots\\n    struct VaultUser {\\n        // SLOT 1: 88 + 88 + 80 = 256 (0 unused)\\n        uint88 ethEscrowed;\\n        uint88 dittoMatchedShares;\\n        uint80 dittoReward; // max 1.2m, 18 decimals\\n    }\\n\\n    struct Bridge {\\n        // SLOT 1: 16 + 8 + 8 = 32 (224 unused)\\n        uint8 vault;\\n        uint16 withdrawalFee;\\n        uint8 unstakeFee;\\n    }\\n}\\n\\n// @dev DataTypes only used in memory\\nlibrary MTypes {\\n    struct OrderHint {\\n        uint16 hintId;\\n        uint256 creationTime;\\n    }\\n\\n    struct BatchLiquidation {\\n        address shorter;\\n        uint8 shortId;\\n    }\\n\\n    struct Match {\\n        uint88 fillEth;\\n        uint88 fillErc;\\n        uint88 colUsed;\\n        uint88 dittoMatchedShares;\\n        // Below used only for bids\\n        uint88 shortFillEth; // Includes colUsed + fillEth from shorts\\n        uint96 askFillErc; // Subset of fillErc\\n        bool ratesQueried; // Save gas when matching shorts\\n        uint80 dethYieldRate;\\n        uint64 ercDebtRate;\\n    }\\n\\n    struct ExitShort {\\n        address asset;\\n        uint256 ercDebt;\\n        uint88 collateral;\\n        uint88 ethFilled;\\n        uint88 ercAmountLeft;\\n        uint88 ercFilled;\\n        uint256 beforeExitCR;\\n    }\\n\\n    struct CombineShorts {\\n        bool shortFlagExists;\\n        uint32 shortUpdatedAt;\\n    }\\n\\n    struct PrimaryLiquidation {\\n        address asset;\\n        uint256 vault;\\n        STypes.ShortRecord short;\\n        address shorter;\\n        uint256 cRatio;\\n        uint80 oraclePrice;\\n        uint256 forcedBidPriceBuffer;\\n        uint256 ethDebt;\\n        uint88 ethFilled;\\n        uint88 ercDebtMatched;\\n        bool loseCollateral;\\n        uint256 tappFeePct;\\n        uint256 callerFeePct;\\n        uint88 gasFee;\\n        uint88 totalFee; // gasFee + tappFee + callerFee\\n        uint256 minimumCR;\\n    }\\n\\n    struct SecondaryLiquidation {\\n        address asset;\\n        uint256 vault;\\n        STypes.ShortRecord short;\\n        address shorter;\\n        uint256 cRatio;\\n        uint256 minimumCR;\\n        uint88 liquidatorCollateral;\\n        uint256 oraclePrice;\\n    }\\n\\n    struct BidMatchAlgo {\\n        uint16 askId;\\n        uint16 shortHintId;\\n        uint16 shortId;\\n        uint16 prevShortId;\\n        uint16 firstShortIdBelowOracle;\\n        uint16 matchedAskId;\\n        uint16 matchedShortId;\\n        bool isMovingBack;\\n        bool isMovingFwd;\\n        uint256 oraclePrice;\\n        uint16 dustAskId;\\n        uint16 dustShortId;\\n    }\\n\\n    struct CreateVaultParams {\\n        uint16 dethTithePercent;\\n        uint16 dittoMatchedRate;\\n        uint16 dittoShorterRate;\\n    }\\n\\n    struct CreateLimitShortParam {\\n        address asset;\\n        uint256 eth;\\n        uint256 minShortErc;\\n        uint256 minAskEth;\\n        uint16 startingId;\\n        uint256 oraclePrice;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"interfaces/=interfaces/\",\r\n      \"contracts/=contracts/\",\r\n      \"test/=test/\",\r\n      \"test-gas/=test-gas/\",\r\n      \"deploy/=deploy/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@chainlink/=node_modules/@chainlink/\",\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"@prb/=node_modules/@prb/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diamondCutFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_baseOracle\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"FunctionNotFound\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Diamond", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000f846f3635e9e3f5c193eda1c155c985d7a57d225000000000000000000000000e518176203d28b8e556c9d3cde1039aefdb81f3a0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xcc7c8eb5addec694fc2eb29ae6c762d9ebcc9deb", "SwarmSource": ""}