{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ProxyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Business Source License 1.1\\npragma solidity 0.8.20;\\nimport \\\"IProxyManager.sol\\\";\\nimport \\\"IUpgradable.sol\\\";\\nimport \\\"Extensible.sol\\\";\\n\\ninterface IBootstrap {\\n    function bootstrap() external;\\n}\\n\\ncontract ProxyManager is Extensible {\\n    event Created(\\n        bytes32 indexed implementation_id,\\n        address indexed clone,\\n        uint256 timestamp\\n    );\\n\\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @notice mapping of the contract id e.g. keccak256(\\\"TestExample\\\") to\\n    /// @notice its actual deployed implementation address.\\n    mapping(bytes32 => address) public implementations;\\n\\n    /// @notice mapping of the contract id e.g. keccak256(\\\"TestExample\\\") to\\n    /// @notice all of its \\\"instances\\\", e.g. proxy contract clones.\\n    mapping(bytes32 => address[]) public instances;\\n    mapping(address => bytes32) public secnatsni; // reverse instances\\n\\n    /// @dev this is a generic proxy contract which is cloned for each instance\\n    /// @dev to make it super cheap to create new instances.\\n    address internal owner;\\n\\n    /// @dev Constructor\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"#B26D413B\\\");\\n        _;\\n    }\\n\\n    function extend(address _extension) external onlyOwner {\\n        _extend(_extension);\\n    }\\n\\n    /// @dev returns the bytes32 representation of a string\\n    /// @param _string string memory\\n    /// @return bytes32\\n    function ID(string memory _string) public pure returns (bytes32) {\\n        return keccak256(bytes(_string));\\n    }\\n\\n    function implementationOfStr(\\n        string memory id\\n    ) public view returns (address) {\\n        return implementations[ID(id)];\\n    }\\n\\n    function computeAddress(\\n        bytes memory _byteCode,\\n        uint256 _salt\\n    ) public view returns (address) {\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                bytes1(0xff),\\n                address(this),\\n                _salt,\\n                keccak256(_byteCode)\\n            )\\n        );\\n        return address(uint160(uint256(hash)));\\n    }\\n\\n    function computeSalt(\\n        bytes32 implementation_id,\\n        bytes memory init_data\\n    ) internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(address(this), implementation_id, init_data)\\n            );\\n    }\\n\\n    /**\\n     * @notice Deploys a given master Contract as a clone.\\n     * @notice Any ETH transferred with this call is forwarded to the new clone.\\n     * @notice Emits `LogDeploy`.\\n     * @param masterContract The address of the contract to clone.\\n     * @param salt bytes32 salt data to use.\\n     * @return clone_address Address of the created clone contract.\\n     */\\n    function _cloneAddress(\\n        address masterContract,\\n        bytes32 salt\\n    ) internal view returns (address) {\\n        require(masterContract != address(0), \\\"#B798D699\\\");\\n        bytes memory _byteCode = generateCloneBytecode(masterContract);\\n        return computeAddress(_byteCode, uint256(salt));\\n    }\\n\\n    function generateCloneBytecode(\\n        bytes20 targetBytes\\n    ) internal pure returns (bytes memory cloneBytecode) {\\n        cloneBytecode = new bytes(123);\\n\\n        assembly {\\n            let clone := add(cloneBytecode, 0x20) // Adjust pointer for length prefix\\n            mstore8(clone, 0x73)\\n            mstore(add(clone, 0x1), targetBytes)\\n            mstore8(add(clone, 0x15), 0x7f)\\n            mstore(add(clone, 0x16), _IMPLEMENTATION_SLOT)\\n            mstore(\\n                add(clone, 0x36),\\n                0x553d603a8060413d3981f3363d3d373d3d3d363d7f360894a13ba1a3210667c8\\n            )\\n            mstore(add(clone, 0x4b), _IMPLEMENTATION_SLOT)\\n            mstore(\\n                add(clone, 0x6b),\\n                0x545af43d82803e903d91603857fd5bf300000000000000000000000000000000\\n            )\\n        }\\n    }\\n\\n    function generateCloneBytecode(\\n        address masterContract\\n    ) internal pure returns (bytes memory) {\\n        require(masterContract != address(0), \\\"#B798D699\\\");\\n        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address\\n        return generateCloneBytecode(targetBytes);\\n    }\\n\\n    /**\\n     * @notice Deploys a given master Contract as a clone.\\n     * @notice Any ETH transferred with this call is forwarded to the new clone.\\n     * @notice Emits `LogDeploy`.\\n     * @param masterContract The address of the contract to clone.\\n     * @param salt bytes32 salt data to use.\\n     * @return clone_address Address of the created clone contract.\\n     */\\n    function _clone(\\n        address masterContract,\\n        bytes32 salt\\n    ) internal returns (address clone_address) {\\n        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address\\n        bytes memory cloneBytecode = generateCloneBytecode(targetBytes);\\n\\n        assembly {\\n            let clone := add(cloneBytecode, 0x20) // Adjust pointer for length prefix\\n            switch salt\\n            case 0 {\\n                clone_address := create(0, clone, 0x7b)\\n            }\\n            default {\\n                clone_address := create2(0, clone, 0x7b, salt)\\n            }\\n        }\\n        return clone_address;\\n    }\\n\\n    /**\\n     * @notice Instantiate a new logic contract\\n     * @param implementation_id - bytes32 id of the contract to instantiate.\\n     * @param init_data - Bytes data that is passed to the contract's constructor.\\n     * @param salt - Salt used for the CREATE2 opcode if 0 use CREATE opcode\\n     * @return clone_address Address of the created clone contract.\\n     */\\n    function create(\\n        bytes32 implementation_id,\\n        bytes memory init_data,\\n        bytes32 salt\\n    ) public payable onlyOwner returns (address clone_address) {\\n        address implementation = implementations[implementation_id];\\n        require(implementation != address(0), \\\"#F7DE9E64\\\");\\n        require(implementation.code.length > 0, \\\"#F49B7998\\\");\\n        clone_address = _clone(implementation, salt);\\n        require(clone_address != address(0), \\\"#AC7BF371\\\");\\n        instances[implementation_id].push(clone_address);\\n        secnatsni[clone_address] = implementation_id;\\n        IBootstrap(clone_address).bootstrap(); // set _proxyOwner to ourselves\\n        IUpgradable(clone_address).init{value: msg.value}(init_data);\\n        emit Created(implementation_id, clone_address, block.timestamp);\\n    }\\n\\n    function createAddress(\\n        bytes32 implementation_id,\\n        bytes32 salt\\n    ) public view returns (address) {\\n        address implementation = implementations[implementation_id];\\n        require(implementation != address(0), \\\"#F7DE9E64\\\");\\n        require(implementation.code.length > 0, \\\"#F49B7998\\\");\\n        return _cloneAddress(implementation, salt);\\n    }\\n\\n    function setImplementation(\\n        bytes32 implementation_id,\\n        address implementation,\\n        bytes calldata upgrade_data\\n    ) public onlyOwner {\\n        setImplementation(\\n            implementation_id,\\n            implementation,\\n            upgrade_data,\\n            true\\n        );\\n    }\\n\\n    function setImplementationStr(\\n        string memory implementation_id,\\n        address implementation,\\n        bytes calldata upgrade_data\\n    ) public onlyOwner {\\n        return\\n            setImplementation(\\n                ID(implementation_id),\\n                implementation,\\n                upgrade_data\\n            );\\n    }\\n\\n    /**\\n     * @notice Instantiate a new logic contract\\n     * @param implementation_id - bytes32 id of the contract to instantiate.\\n     * @param init_data - Bytes data that is passed to the contract's constructor.\\n     * @return clone_address Address of the created clone contract.\\n     */\\n    function create(\\n        bytes32 implementation_id,\\n        bytes memory init_data\\n    ) public payable onlyOwner returns (address clone_address) {\\n        return\\n            create(\\n                implementation_id,\\n                init_data,\\n                computeSalt(implementation_id, init_data)\\n            );\\n    }\\n\\n    function createAddress(\\n        bytes32 implementation_id,\\n        bytes memory init_data\\n    ) public view returns (address) {\\n        return\\n            createAddress(\\n                implementation_id,\\n                computeSalt(implementation_id, init_data)\\n            );\\n    }\\n\\n    function createStr(\\n        string memory impl_str,\\n        bytes memory init_data\\n    ) public payable onlyOwner returns (address clone_address) {\\n        bytes32 implementation_id = ID(impl_str);\\n        return create(implementation_id, init_data);\\n    }\\n\\n    function createStrAddress(\\n        string memory impl_str,\\n        bytes memory init_data\\n    ) public view returns (address) {\\n        bytes32 implementation_id = ID(impl_str);\\n        return createAddress(implementation_id, init_data);\\n    }\\n\\n    /**\\n     * @notice When a master logic contract is deployed, it should register itself. Each clone\\n     * @notice can then request a logic of this type using getlogic(address(this), logic_id)\\n     * @param implementation_id bytes32 identifier of logic type, e.g. keccak256(abi.encodePacked(\\\"String\\\"))\\n     * @param implementation address of the master contract implementing that type.\\n     */\\n    function setImplementation(\\n        bytes32 implementation_id,\\n        address implementation,\\n        bytes calldata upgrade_data,\\n        bool callUpdate\\n    ) public onlyOwner {\\n        require(implementation.code.length > 0, \\\"#075051C6\\\");\\n        implementations[implementation_id] = implementation;\\n\\n        // for each item in instances, change the implementation\\n        for (uint i = 0; i < instances[implementation_id].length; i++) {\\n            IUpgradable(instances[implementation_id][i]).updateImplementation(\\n                implementation\\n            );\\n            if (callUpdate)\\n                IUpgradable(instances[implementation_id][i]).upgrade(\\n                    upgrade_data\\n                );\\n        }\\n    }\\n\\n    function upgradeContract(\\n        address clone_address,\\n        bytes calldata upgrade_data\\n    ) external onlyOwner {\\n        require(secnatsni[clone_address] != 0, \\\"#85494455\\\");\\n        IUpgradable(clone_address).upgrade(upgrade_data);\\n    }\\n}\\n\"\r\n    },\r\n    \"IProxyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\ninterface IProxyManager {\\n    function ID(string memory _string) external pure returns (bytes32);\\n\\n    function instances(bytes32 id, uint256 i) external view returns (address);\\n\\n    function instances(\\n        string memory id,\\n        uint256 i\\n    ) external view returns (address);\\n\\n    function contractOf(address clone) external view returns (bytes32);\\n\\n    function create(\\n        bytes32 contract_id,\\n        bytes memory init_data\\n    ) external payable returns (address clone_address);\\n\\n    function createStr(\\n        string memory contract_id,\\n        bytes memory init_data\\n    ) external payable returns (address clone_address);\\n\\n    function setImplementation(\\n        bytes32 logic_type,\\n        address logic_contract,\\n        bytes calldata upgrade_data\\n    ) external;\\n\\n    function setImplementationStr(\\n        string memory implementation_id,\\n        address implementation,\\n        bytes calldata upgrade_data\\n    ) external;\\n\\n    function implementationOf(bytes32 id) external returns (address);\\n\\n    function implementationOfStr(string memory id) external returns (address);\\n}\\n\"\r\n    },\r\n    \"IUpgradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\nimport \\\"IClonable.sol\\\";\\n\\ninterface IUpgradable is IClonable {\\n    function init(bytes memory init_data) external payable;\\n\\n    function updateImplementation(address implementation) external;\\n\\n    function upgrade(bytes memory upgrade_data) external;\\n}\\n\"\r\n    },\r\n    \"IClonable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\ninterface IClonable {\\n    function init(bytes memory data) external payable;\\n}\\n\"\r\n    },\r\n    \"Extensible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.20;\\n\\nabstract contract Extensible {\\n    address public extension;\\n\\n    function _extend(address _extension) internal {\\n        extension = _extension;\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        address _extension = extension;\\n        if (_extension != address(0)) {\\n            assembly {\\n                calldatacopy(0, 0, calldatasize())\\n                let result := delegatecall(\\n                    gas(),\\n                    _extension,\\n                    0,\\n                    calldatasize(),\\n                    0,\\n                    0\\n                )\\n                returndatacopy(0, 0, returndatasize())\\n                switch result\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n            }\\n        } else {\\n            revert(\\\"#3A8A89AA\\\");\\n        }\\n    }\\n\\n    receive() external payable virtual {\\n        address _extension = extension;\\n        if (_extension != address(0)) {\\n            assembly {\\n                calldatacopy(0, 0, calldatasize())\\n                let result := delegatecall(\\n                    gas(),\\n                    _extension,\\n                    0,\\n                    calldatasize(),\\n                    0,\\n                    0\\n                )\\n                returndatacopy(0, 0, returndatasize())\\n                switch result\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n            }\\n        } else {\\n            revert(\\\"#44B5D5AB\\\");\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"ProxyManager.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"implementation_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_string\",\"type\":\"string\"}],\"name\":\"ID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_byteCode\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"computeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"implementation_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"init_data\",\"type\":\"bytes\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"clone_address\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"implementation_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"init_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"clone_address\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"implementation_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"createAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"implementation_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"init_data\",\"type\":\"bytes\"}],\"name\":\"createAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"impl_str\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"init_data\",\"type\":\"bytes\"}],\"name\":\"createStr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"clone_address\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"impl_str\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"init_data\",\"type\":\"bytes\"}],\"name\":\"createStrAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_extension\",\"type\":\"address\"}],\"name\":\"extend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extension\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"}],\"name\":\"implementationOfStr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"implementations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"instances\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"secnatsni\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"implementation_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"upgrade_data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"callUpdate\",\"type\":\"bool\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"implementation_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"upgrade_data\",\"type\":\"bytes\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"implementation_id\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"upgrade_data\",\"type\":\"bytes\"}],\"name\":\"setImplementationStr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"clone_address\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"upgrade_data\",\"type\":\"bytes\"}],\"name\":\"upgradeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ProxyManager", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}