{"SourceCode": "pragma solidity 0.6.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract GebMath {\r\n    uint256 public constant RAY = 10 ** 27;\r\n    uint256 public constant WAD = 10 ** 18;\r\n\r\n    function ray(uint x) public pure returns (uint z) {\r\n        z = multiply(x, 10 ** 9);\r\n    }\r\n    function rad(uint x) public pure returns (uint z) {\r\n        z = multiply(x, 10 ** 27);\r\n    }\r\n    function minimum(uint x, uint y) public pure returns (uint z) {\r\n        z = (x <= y) ? x : y;\r\n    }\r\n    function addition(uint x, uint y) public pure returns (uint z) {\r\n        z = x + y;\r\n        require(z >= x, \"uint-uint-add-overflow\");\r\n    }\r\n    function subtract(uint x, uint y) public pure returns (uint z) {\r\n        z = x - y;\r\n        require(z <= x, \"uint-uint-sub-underflow\");\r\n    }\r\n    function multiply(uint x, uint y) public pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"uint-uint-mul-overflow\");\r\n    }\r\n    function rmultiply(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, y) / RAY;\r\n    }\r\n    function rdivide(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, RAY) / y;\r\n    }\r\n    function wdivide(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, WAD) / y;\r\n    }\r\n    function wmultiply(uint x, uint y) public pure returns (uint z) {\r\n        z = multiply(x, y) / WAD;\r\n    }\r\n    function rpower(uint x, uint n, uint base) public pure returns (uint z) {\r\n        assembly {\r\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\r\n            default {\r\n                switch mod(n, 2) case 0 { z := base } default { z := x }\r\n                let half := div(base, 2)  // for rounding.\r\n                for { n := div(n, 2) } n { n := div(n,2) } {\r\n                    let xx := mul(x, x)\r\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n                    let xxRound := add(xx, half)\r\n                    if lt(xxRound, xx) { revert(0,0) }\r\n                    x := div(xxRound, base)\r\n                    if mod(n,2) {\r\n                        let zx := mul(z, x)\r\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n                        let zxRound := add(zx, half)\r\n                        if lt(zxRound, zx) { revert(0,0) }\r\n                        z := div(zxRound, base)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface ITellor {\r\n    //Controller\r\n    function addresses(bytes32) external view returns (address);\r\n\r\n    function uints(bytes32) external view returns (uint256);\r\n\r\n    function burn(uint256 _amount) external;\r\n\r\n    function changeDeity(address _newDeity) external;\r\n\r\n    function changeOwner(address _newOwner) external;\r\n    function changeUint(bytes32 _target, uint256 _amount) external;\r\n\r\n    function migrate() external;\r\n\r\n    function mint(address _reciever, uint256 _amount) external;\r\n\r\n    function init() external;\r\n\r\n    function getAllDisputeVars(uint256 _disputeId)\r\n        external\r\n        view\r\n        returns (\r\n            bytes32,\r\n            bool,\r\n            bool,\r\n            bool,\r\n            address,\r\n            address,\r\n            address,\r\n            uint256[9] memory,\r\n            int256\r\n        );\r\n\r\n    function getDisputeIdByDisputeHash(bytes32 _hash)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getLastNewValueById(uint256 _requestId)\r\n        external\r\n        view\r\n        returns (uint256, bool);\r\n\r\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getNewValueCountbyRequestId(uint256 _requestId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getAddressVars(bytes32 _data) external view returns (address);\r\n\r\n    function getUintVar(bytes32 _data) external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function isMigrated(address _addy) external view returns (bool);\r\n\r\n    function allowance(address _user, address _spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function allowedToTrade(address _user, uint256 _amount)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function approve(address _spender, uint256 _amount) external returns (bool);\r\n\r\n    function approveAndTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    function balanceOf(address _user) external view returns (uint256);\r\n\r\n    function balanceOfAt(address _user, uint256 _blockNumber)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _amount)\r\n        external\r\n        returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external returns (bool success);\r\n\r\n    function depositStake() external;\r\n\r\n    function requestStakingWithdraw() external;\r\n\r\n    function withdrawStake() external;\r\n\r\n    function changeStakingStatus(address _reporter, uint256 _status) external;\r\n\r\n    function slashReporter(address _reporter, address _disputer) external;\r\n\r\n    function getStakerInfo(address _staker)\r\n        external\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    function getTimestampbyRequestIDandIndex(uint256 _requestId, uint256 _index)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getNewCurrentVariables()\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 _c,\r\n            uint256[5] memory _r,\r\n            uint256 _d,\r\n            uint256 _t\r\n        );\r\n\r\n    function getNewValueCountbyQueryId(bytes32 _queryId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bytes memory);\r\n\r\n    //Governance\r\n    enum VoteResult {\r\n        FAILED,\r\n        PASSED,\r\n        INVALID\r\n    }\r\n\r\n    function setApprovedFunction(bytes4 _func, bool _val) external;\r\n\r\n    function beginDispute(bytes32 _queryId, uint256 _timestamp) external;\r\n\r\n    function delegate(address _delegate) external;\r\n\r\n    function delegateOfAt(address _user, uint256 _blockNumber)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function executeVote(uint256 _disputeId) external;\r\n\r\n    function proposeVote(\r\n        address _contract,\r\n        bytes4 _function,\r\n        bytes calldata _data,\r\n        uint256 _timestamp\r\n    ) external;\r\n\r\n    function tallyVotes(uint256 _disputeId) external;\r\n\r\n    function governance() external view returns (address);\r\n\r\n    function updateMinDisputeFee() external;\r\n\r\n    function verify() external pure returns (uint256);\r\n\r\n    function vote(\r\n        uint256 _disputeId,\r\n        bool _supports,\r\n        bool _invalidQuery\r\n    ) external;\r\n\r\n    function voteFor(\r\n        address[] calldata _addys,\r\n        uint256 _disputeId,\r\n        bool _supports,\r\n        bool _invalidQuery\r\n    ) external;\r\n\r\n    function getDelegateInfo(address _holder)\r\n        external\r\n        view\r\n        returns (address, uint256);\r\n\r\n    function isFunctionApproved(bytes4 _func) external view returns (bool);\r\n\r\n    function isApprovedGovernanceContract(address _contract)\r\n        external\r\n        returns (bool);\r\n\r\n    function getVoteRounds(bytes32 _hash)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function getVoteCount() external view returns (uint256);\r\n\r\n    function getVoteInfo(uint256 _disputeId)\r\n        external\r\n        view\r\n        returns (\r\n            bytes32,\r\n            uint256[9] memory,\r\n            bool[2] memory,\r\n            VoteResult,\r\n            bytes memory,\r\n            bytes4,\r\n            address[2] memory\r\n        );\r\n\r\n    function getDisputeInfo(uint256 _disputeId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            bytes memory,\r\n            address\r\n        );\r\n\r\n    function getOpenDisputesOnId(bytes32 _queryId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function didVote(uint256 _disputeId, address _voter)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    //Oracle\r\n    function getReportTimestampByIndex(bytes32 _queryId, uint256 _index)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getValueByTimestamp(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bytes memory);\r\n\r\n    function getBlockNumberByTimestamp(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getReportingLock() external view returns (uint256);\r\n\r\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function reportingLock() external view returns (uint256);\r\n\r\n    function removeValue(bytes32 _queryId, uint256 _timestamp) external;\r\n    function getTipsByUser(address _user) external view returns(uint256);\r\n    function tipQuery(bytes32 _queryId, uint256 _tip, bytes calldata _queryData) external;\r\n    function submitValue(bytes32 _queryId, bytes calldata _value, uint256 _nonce, bytes calldata _queryData) external;\r\n    function burnTips() external;\r\n\r\n    function changeReportingLock(uint256 _newReportingLock) external;\r\n    function getReportsSubmittedByAddress(address _reporter) external view returns(uint256);\r\n    function changeTimeBasedReward(uint256 _newTimeBasedReward) external;\r\n    function getReporterLastTimestamp(address _reporter) external view returns(uint256);\r\n    function getTipsById(bytes32 _queryId) external view returns(uint256);\r\n    function getTimeBasedReward() external view returns(uint256);\r\n    function getTimestampCountById(bytes32 _queryId) external view returns(uint256);\r\n    function getTimestampIndexByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(uint256);\r\n    function getCurrentReward(bytes32 _queryId) external view returns(uint256, uint256);\r\n    function getCurrentValue(bytes32 _queryId) external view returns(bytes memory);\r\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp) external view returns(bool _ifRetrieve, bytes memory _value, uint256 _timestampRetrieved);\r\n    function getTimeOfLastNewValue() external view returns(uint256);\r\n    function depositStake(uint256 _amount) external;\r\n    function requestStakingWithdraw(uint256 _amount) external;\r\n\r\n    //Test functions\r\n    function changeAddressVar(bytes32 _id, address _addy) external;\r\n\r\n    //parachute functions\r\n    function killContract() external;\r\n\r\n    function migrateFor(address _destination, uint256 _amount) external;\r\n\r\n    function rescue51PercentAttack(address _tokenHolder) external;\r\n\r\n    function rescueBrokenDataReporting() external;\r\n\r\n    function rescueFailedUpdate() external;\r\n\r\n    //Tellor 360\r\n    function addStakingRewards(uint256 _amount) external;\r\n\r\n    function _sliceUint(bytes calldata _b)\r\n        external\r\n        pure\r\n        returns (uint256 _number);\r\n\r\n    function claimOneTimeTip(bytes32 _queryId, uint256[] calldata _timestamps)\r\n        external;\r\n\r\n    function claimTip(\r\n        bytes32 _feedId,\r\n        bytes32 _queryId,\r\n        uint256[] calldata _timestamps\r\n    ) external;\r\n\r\n    function fee() external view returns (uint256);\r\n\r\n    function feedsWithFunding(uint256) external view returns (bytes32);\r\n\r\n    function fundFeed(\r\n        bytes32 _feedId,\r\n        bytes32 _queryId,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    function getCurrentFeeds(bytes32 _queryId)\r\n        external\r\n        view\r\n        returns (bytes32[] memory);\r\n\r\n    function getCurrentTip(bytes32 _queryId) external view returns (uint256);\r\n\r\n    function getDataAfter(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bytes memory _value, uint256 _timestampRetrieved);\r\n\r\n    function getDataFeed(bytes32 _feedId)\r\n        external\r\n        view\r\n        returns (Autopay.FeedDetails memory);\r\n\r\n    function getFundedFeeds() external view returns (bytes32[] memory);\r\n\r\n    function getFundedQueryIds() external view returns (bytes32[] memory);\r\n\r\n    function getIndexForDataAfter(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bool _found, uint256 _index);\r\n\r\n    function getIndexForDataBefore(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bool _found, uint256 _index);\r\n\r\n    function getMultipleValuesBefore(\r\n        bytes32 _queryId,\r\n        uint256 _timestamp,\r\n        uint256 _maxAge,\r\n        uint256 _maxCount\r\n    )\r\n        external\r\n        view\r\n        returns (uint256[] memory _values, uint256[] memory _timestamps);\r\n\r\n    function getPastTipByIndex(bytes32 _queryId, uint256 _index)\r\n        external\r\n        view\r\n        returns (Autopay.Tip memory);\r\n\r\n    function getPastTipCount(bytes32 _queryId) external view returns (uint256);\r\n\r\n    function getPastTips(bytes32 _queryId)\r\n        external\r\n        view\r\n        returns (Autopay.Tip[] memory);\r\n\r\n    function getQueryIdFromFeedId(bytes32 _feedId)\r\n        external\r\n        view\r\n        returns (bytes32);\r\n\r\n    function getRewardAmount(\r\n        bytes32 _feedId,\r\n        bytes32 _queryId,\r\n        uint256[] calldata _timestamps\r\n    ) external view returns (uint256 _cumulativeReward);\r\n\r\n    function getRewardClaimedStatus(\r\n        bytes32 _feedId,\r\n        bytes32 _queryId,\r\n        uint256 _timestamp\r\n    ) external view returns (bool);\r\n\r\n    function getTipsByAddress(address _user) external view returns (uint256);\r\n\r\n    function isInDispute(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function queryIdFromDataFeedId(bytes32) external view returns (bytes32);\r\n\r\n    function queryIdsWithFunding(uint256) external view returns (bytes32);\r\n\r\n    function queryIdsWithFundingIndex(bytes32) external view returns (uint256);\r\n\r\n    function setupDataFeed(\r\n        bytes32 _queryId,\r\n        uint256 _reward,\r\n        uint256 _startTime,\r\n        uint256 _interval,\r\n        uint256 _window,\r\n        uint256 _priceThreshold,\r\n        uint256 _rewardIncreasePerSecond,\r\n        bytes calldata _queryData,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    function tellor() external view returns (address);\r\n\r\n    function tip(\r\n        bytes32 _queryId,\r\n        uint256 _amount,\r\n        bytes calldata _queryData\r\n    ) external;\r\n\r\n    function tips(bytes32, uint256)\r\n        external\r\n        view\r\n        returns (uint256 amount, uint256 timestamp);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function userTipsTotal(address) external view returns (uint256);\r\n\r\n    function valueFor(bytes32 _id)\r\n        external\r\n        view\r\n        returns (\r\n            int256 _value,\r\n            uint256 _timestamp,\r\n            uint256 _statusCode\r\n        );\r\n}\r\n\r\ninterface Autopay {\r\n    struct FeedDetails {\r\n        uint256 reward;\r\n        uint256 balance;\r\n        uint256 startTime;\r\n        uint256 interval;\r\n        uint256 window;\r\n        uint256 priceThreshold;\r\n        uint256 rewardIncreasePerSecond;\r\n        uint256 feedsWithFundingIndex;\r\n    }\r\n\r\n    struct Tip {\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n    }\r\n    function getStakeAmount() external view returns(uint256);\r\n    function stakeAmount() external view returns(uint256);\r\n    function token() external view returns(address);\r\n}\r\n\r\n/**\r\n    * @dev EIP2362 Interface for pull oracles\r\n    * https://github.com/tellor-io/EIP-2362\r\n*/\r\ninterface IERC2362\r\n{\r\n\t/**\r\n\t * @dev Exposed function pertaining to EIP standards\r\n\t * @param _id bytes32 ID of the query\r\n\t * @return int,uint,uint returns the value, timestamp, and status code of query\r\n\t */\r\n\tfunction valueFor(bytes32 _id) external view returns(int256,uint256,uint256);\r\n}\r\n\r\ninterface IMappingContract{\r\n    function getTellorID(bytes32 _id) external view returns(bytes32);\r\n}\r\n\r\n/**\r\n @author Tellor Inc\r\n @title UsingTellor\r\n @dev This contract helps smart contracts read data from Tellor\r\n */\r\ncontract UsingTellor is IERC2362 {\r\n    ITellor public tellor;\r\n    IMappingContract public idMappingContract;\r\n\r\n    /*Constructor*/\r\n    /**\r\n     * @dev the constructor sets the oracle address in storage\r\n     * @param _tellor is the Tellor Oracle address\r\n     */\r\n    constructor(address payable _tellor) public {\r\n        tellor = ITellor(_tellor);\r\n    }\r\n\r\n    /*Getters*/\r\n    /**\r\n     * @dev Retrieves the next value for the queryId after the specified timestamp\r\n     * @param _queryId is the queryId to look up the value for\r\n     * @param _timestamp after which to search for next value\r\n     * @return _value the value retrieved\r\n     * @return _timestampRetrieved the value's timestamp\r\n     */\r\n    function getDataAfter(bytes32 _queryId, uint256 _timestamp)\r\n        public\r\n        view\r\n        returns (bytes memory _value, uint256 _timestampRetrieved)\r\n    {\r\n        (bool _found, uint256 _index) = getIndexForDataAfter(\r\n            _queryId,\r\n            _timestamp\r\n        );\r\n        if (!_found) {\r\n            return (\"\", 0);\r\n        }\r\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _index);\r\n        _value = retrieveData(_queryId, _timestampRetrieved);\r\n        return (_value, _timestampRetrieved);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves the latest value for the queryId before the specified timestamp\r\n     * @param _queryId is the queryId to look up the value for\r\n     * @param _timestamp before which to search for latest value\r\n     * @return _value the value retrieved\r\n     * @return _timestampRetrieved the value's timestamp\r\n     */\r\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bytes memory _value, uint256 _timestampRetrieved)\r\n    {\r\n        (, _value, _timestampRetrieved) = tellor.getDataBefore(\r\n            _queryId,\r\n            _timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\r\n     * @param _queryId is the queryId to look up the index for\r\n     * @param _timestamp is the timestamp before which to search for the latest index\r\n     * @return _found whether the index was found\r\n     * @return _index the latest index found before the specified timestamp\r\n     */\r\n    // slither-disable-next-line calls-loop\r\n    function getIndexForDataAfter(bytes32 _queryId, uint256 _timestamp)\r\n        public\r\n        view\r\n        returns (bool _found, uint256 _index)\r\n    {\r\n        uint256 _count = getNewValueCountbyQueryId(_queryId);\r\n        if (_count == 0) return (false, 0);\r\n        _count--;\r\n        bool _search = true; // perform binary search\r\n        uint256 _middle = 0;\r\n        uint256 _start = 0;\r\n        uint256 _end = _count;\r\n        uint256 _timestampRetrieved;\r\n        // checking boundaries to short-circuit the algorithm\r\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _end);\r\n        if (_timestampRetrieved <= _timestamp) return (false, 0);\r\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _start);\r\n        if (_timestampRetrieved > _timestamp) {\r\n            // candidate found, check for disputes\r\n            _search = false;\r\n        }\r\n        // since the value is within our boundaries, do a binary search\r\n        while (_search) {\r\n            _middle = (_end + _start) / 2;\r\n            _timestampRetrieved = getTimestampbyQueryIdandIndex(\r\n                _queryId,\r\n                _middle\r\n            );\r\n            if (_timestampRetrieved > _timestamp) {\r\n                // get immediate previous value\r\n                uint256 _prevTime = getTimestampbyQueryIdandIndex(\r\n                    _queryId,\r\n                    _middle - 1\r\n                );\r\n                if (_prevTime <= _timestamp) {\r\n                    // candidate found, check for disputes\r\n                    _search = false;\r\n                } else {\r\n                    // look from start to middle -1(prev value)\r\n                    _end = _middle - 1;\r\n                }\r\n            } else {\r\n                // get immediate next value\r\n                uint256 _nextTime = getTimestampbyQueryIdandIndex(\r\n                    _queryId,\r\n                    _middle + 1\r\n                );\r\n                if (_nextTime > _timestamp) {\r\n                    // candidate found, check for disputes\r\n                    _search = false;\r\n                    _middle++;\r\n                    _timestampRetrieved = _nextTime;\r\n                } else {\r\n                    // look from middle + 1(next value) to end\r\n                    _start = _middle + 1;\r\n                }\r\n            }\r\n        }\r\n        // candidate found, check for disputed values\r\n        if (!isInDispute(_queryId, _timestampRetrieved)) {\r\n            // _timestampRetrieved is correct\r\n            return (true, _middle);\r\n        } else {\r\n            // iterate forward until we find a non-disputed value\r\n            while (\r\n                isInDispute(_queryId, _timestampRetrieved) && _middle < _count\r\n            ) {\r\n                _middle++;\r\n                _timestampRetrieved = getTimestampbyQueryIdandIndex(\r\n                    _queryId,\r\n                    _middle\r\n                );\r\n            }\r\n            if (\r\n                _middle == _count && isInDispute(_queryId, _timestampRetrieved)\r\n            ) {\r\n                return (false, 0);\r\n            }\r\n            // _timestampRetrieved is correct\r\n            return (true, _middle);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\r\n     * @param _queryId is the queryId to look up the index for\r\n     * @param _timestamp is the timestamp before which to search for the latest index\r\n     * @return _found whether the index was found\r\n     * @return _index the latest index found before the specified timestamp\r\n     */\r\n    // slither-disable-next-line calls-loop\r\n    function getIndexForDataBefore(bytes32 _queryId, uint256 _timestamp)\r\n        public\r\n        view\r\n        returns (bool _found, uint256 _index)\r\n    {\r\n        return tellor.getIndexForDataBefore(_queryId, _timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Counts the number of values that have been submitted for the queryId\r\n     * @param _queryId the id to look up\r\n     * @return uint256 count of the number of values received for the queryId\r\n     */\r\n    function getNewValueCountbyQueryId(bytes32 _queryId)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return tellor.getNewValueCountbyQueryId(_queryId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the reporter who submitted a value for a data ID at a specific time\r\n     * @param _queryId is ID of the specific data feed\r\n     * @param _timestamp is the timestamp to find a corresponding reporter for\r\n     * @return address of the reporter who reported the value for the data ID at the given timestamp\r\n     */\r\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return tellor.getReporterByTimestamp(_queryId, _timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the timestamp for the value based on their index\r\n     * @param _queryId is the id to look up\r\n     * @param _index is the value index to look up\r\n     * @return uint256 timestamp\r\n     */\r\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return tellor.getTimestampbyQueryIdandIndex(_queryId, _index);\r\n    }\r\n\r\n    /**\r\n     * @dev Determines whether a value with a given queryId and timestamp has been disputed\r\n     * @param _queryId is the value id to look up\r\n     * @param _timestamp is the timestamp of the value to look up\r\n     * @return bool true if queryId/timestamp is under dispute\r\n     */\r\n    function isInDispute(bytes32 _queryId, uint256 _timestamp)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return tellor.isInDispute(_queryId, _timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve value from oracle based on queryId/timestamp\r\n     * @param _queryId being requested\r\n     * @param _timestamp to retrieve data/value from\r\n     * @return bytes value for query/timestamp submitted\r\n     */\r\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\r\n        public\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return tellor.retrieveData(_queryId, _timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev allows dev to set mapping contract for valueFor (EIP2362)\r\n     * @param _addy address of mapping contract\r\n     */\r\n    function setIdMappingContract(address _addy) external {\r\n        require(address(idMappingContract) == address(0));\r\n        idMappingContract = IMappingContract(_addy);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve most recent int256 value from oracle based on queryId\r\n     * @param _id being requested\r\n     * @return _value most recent value submitted\r\n     * @return _timestamp timestamp of most recent value\r\n     * @return _statusCode 200 if value found, 404 if not found\r\n     */\r\n    function valueFor(bytes32 _id)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            int256 _value,\r\n            uint256 _timestamp,\r\n            uint256 _statusCode\r\n        )\r\n    {\r\n        bytes32 _queryId = idMappingContract.getTellorID(_id);\r\n        bytes memory _valueBytes;\r\n        (_valueBytes, _timestamp) = this.getDataBefore(\r\n            _queryId,\r\n            block.timestamp + 1\r\n        );\r\n        if (_timestamp == 0) {\r\n            return (0, 0, 404);\r\n        }\r\n        uint256 _valueUint = _sliceUint(_valueBytes);\r\n        _value = int256(_valueUint);\r\n        return (_value, _timestamp, 200);\r\n    }\r\n\r\n    // Internal functions\r\n    /**\r\n     * @dev Convert bytes to uint256\r\n     * @param _b bytes value to convert to uint256\r\n     * @return _number uint256 converted from bytes\r\n     */\r\n    function _sliceUint(bytes memory _b)\r\n        internal\r\n        pure\r\n        returns (uint256 _number)\r\n    {\r\n        for (uint256 _i = 0; _i < _b.length; _i++) {\r\n            _number = _number * 256 + uint8(_b[_i]);\r\n        }\r\n    }\r\n}\r\n\r\ncontract TellorRelayer is GebMath, UsingTellor {\r\n    // --- Auth ---\r\n    mapping (address => uint) public authorizedAccounts;\r\n    /**\r\n     * @notice Add auth to an account\r\n     * @param account Account to add auth to\r\n     */\r\n    function addAuthorization(address account) virtual external isAuthorized {\r\n        authorizedAccounts[account] = 1;\r\n        emit AddAuthorization(account);\r\n    }\r\n    /**\r\n     * @notice Remove auth from an account\r\n     * @param account Account to remove auth from\r\n     */\r\n    function removeAuthorization(address account) virtual external isAuthorized {\r\n        authorizedAccounts[account] = 0;\r\n        emit RemoveAuthorization(account);\r\n    }\r\n    /**\r\n    * @notice Checks whether msg.sender can call an authed function\r\n    **/\r\n    modifier isAuthorized {\r\n        require(authorizedAccounts[msg.sender] == 1, \"TellorRelayer/account-not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Variables ---\r\n    // Multiplier for the Tellor price feed in order to scaled it to 18 decimals.\r\n    uint8   public constant multiplier = 0;\r\n    // Time threshold after which a Tellor response is considered stale\r\n    uint256 public staleThreshold;\r\n\r\n    bytes32 public constant symbol = \"oetheth\";\r\n\r\n    // Time delay to get prices before (15 minutes)\r\n    uint256 public constant timeDelay = 900;\r\n\r\n    // Tellor\r\n    bytes32 public immutable queryId;\r\n\r\n    // --- Events ---\r\n    event AddAuthorization(address account);\r\n    event RemoveAuthorization(address account);\r\n    event ModifyParameters(\r\n      bytes32 parameter,\r\n      address addr\r\n    );\r\n    event ModifyParameters(\r\n      bytes32 parameter,\r\n      uint256 val\r\n    );\r\n\r\n    constructor(\r\n      address payable tellorAddress_,\r\n      bytes32 queryId_,\r\n      uint256 staleThreshold_\r\n    ) public UsingTellor(tellorAddress_) {\r\n        require(tellorAddress_ != address(0), \"TellorTWAP/null-tellor-address\");\r\n        require(queryId_ != bytes32(0), \"TellorTWAP/null-tellor-query-id\");\r\n        require(staleThreshold_ > 0, \"TellorRelayer/null-stale-threshold\");\r\n\r\n        authorizedAccounts[msg.sender] = 1;\r\n\r\n        staleThreshold                 = staleThreshold_;\r\n        queryId                        = queryId_;\r\n\r\n        emit AddAuthorization(msg.sender);\r\n        emit ModifyParameters(\"staleThreshold\", staleThreshold);\r\n    }\r\n\r\n    // --- General Utils ---\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n\r\n    // --- Administration ---\r\n    /*\r\n    * @notify Modify an uin256 parameter\r\n    * @param parameter The name of the parameter to change\r\n    * @param data The new parameter value\r\n    */\r\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\r\n        if (parameter == \"staleThreshold\") {\r\n          require(data > 0, \"TellorRelayer/invalid-stale-threshold\");\r\n          staleThreshold = data;\r\n        }\r\n        else revert(\"TellorRelayer/modify-unrecognized-param\");\r\n        emit ModifyParameters(parameter, data);\r\n    }\r\n\r\n    // --- Main Getters ---\r\n    /**\r\n    * @notice Fetch the latest medianResult or revert if is is null, if the price is stale or if TellorAggregator is null\r\n    **/\r\n    function read() external view returns (uint256) {\r\n        // Fetch values from Tellor\r\n        try this.getDataBefore(queryId, subtract(block.timestamp, timeDelay)) returns (bytes memory _value, uint256 _timestampRetrieved) {\r\n            uint256 medianPrice = multiply(abi.decode(_value, (uint256)), 10 ** uint(multiplier));\r\n            require(both(medianPrice > 0, subtract(now, _timestampRetrieved) <= staleThreshold), \"TellorRelayer/invalid-price-feed\");\r\n            return medianPrice;\r\n        } catch {\r\n            revert(\"TellorRelayer/failed-to-query-tellor\");\r\n        }\r\n    }\r\n    /**\r\n    * @notice Fetch the latest medianResult and whether it is valid or not\r\n    **/\r\n    function getResultWithValidity() external view returns (uint256, bool) {\r\n        // Fetch values from Tellor\r\n        try this.getDataBefore(queryId, subtract(block.timestamp, timeDelay)) returns (bytes memory _value, uint256 _timestampRetrieved) {\r\n            uint256 medianPrice = multiply(abi.decode(_value, (uint256)), 10 ** uint(multiplier));\r\n            return (medianPrice, both(medianPrice > 0, subtract(now, _timestampRetrieved) <= staleThreshold));\r\n        } catch  {\r\n            revert(\"TellorRelayer/failed-to-query-tellor\");\r\n        }\r\n    }\r\n\r\n    // --- Median Updates ---\r\n    /*\r\n    * @notice Remnant from other Tellor medians\r\n    */\r\n    function updateResult(address feeReceiver) external {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"tellorAddress_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"queryId_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"staleThreshold_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemoveAuthorization\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"addition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getDataAfter\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"_value\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getDataBefore\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"_value\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getIndexForDataAfter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_found\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getIndexForDataBefore\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_found\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"getNewValueCountbyQueryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getReporterByTimestamp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getResultWithValidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTimestampbyQueryIdandIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idMappingContract\",\"outputs\":[{\"internalType\":\"contract IMappingContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"isInDispute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"minimum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiplier\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"multiply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"rad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"ray\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"rdivide\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"read\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"retrieveData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"rmultiply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"base\",\"type\":\"uint256\"}],\"name\":\"rpower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"setIdMappingContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staleThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"subtract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tellor\",\"outputs\":[{\"internalType\":\"contract ITellor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"}],\"name\":\"updateResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"valueFor\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"_value\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_statusCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"wdivide\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"wmultiply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"z\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "TellorRelayer", "CompilerVersion": "v0.6.7+commit.b8d736ae", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008cfc184c877154a8f9ffe0fe75649dbe5e2dbebf6a41ccdfe1b8e77b2b2f0302d58bdeaff1244ccb830db6bdd04b204c7e7a73d70000000000000000000000000000000000000000000000000000000000005460", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6e98ae546fa8ae0e5d0d8b1a0700c6ab5adbf45d20fb63dea379aec1b55e3138"}