{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/booster/BoosterBronze.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {StakeBooster} from \\\"../StakeBooster.sol\\\";\\n\\ncontract BoosterBronze is StakeBooster {\\n    constructor(address _soph, string memory _uri3, string memory _uri6, string memory _uri12, address _owner)\\n        StakeBooster(_soph, 1000 ether, _uri3, _uri6, _uri12, _owner)\\n    {}\\n}\\n\"\r\n    },\r\n    \"src/StakeBooster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n///@author SophiaVerse\\n///@title Stake Booster contract for staking soph tokens\\n///@notice This contract allows users to stake a minimum amount of soph tokens for 90, 180 or 360 days\\n///@dev This contract is pausable and reentrant guard is used to prevent reentrancy attacks, pausable for emergency situations if needed to stop staking\\n///@dev This contract uses ERC1155 to mint soulbound nfts for users who unstake their soph tokens\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport {Pausable} from \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract StakeBooster is ERC1155, ReentrancyGuard, Pausable, Ownable {\\n    //address of soph token\\n    address public soph;\\n    uint256 public minimumAmount;\\n    string public uri3;\\n    string public uri6;\\n    string public uri12;\\n\\n    //mapping of address to stake time\\n    mapping(address => uint256 time) public wallet_stakeEndTimer;\\n    mapping(address => uint256 stakeTimeType) public wallet_stakeTimeType;\\n\\n    //events\\n    event Staked(address indexed user, uint256 stakeType);\\n    event Upgraded(address indexed user, uint256 stakeType);\\n    event Unstaked(address indexed user, uint256 stakeType);\\n\\n    ///@notice constructor to set the soph token address and the minimum amount of soph tokens to stake\\n    ///@param _soph address of soph token\\n    ///@param _minimumAmount minimum amount of soph tokens to stake\\n    ///@param _uri3 uri of the nft for 90 days stake\\n    ///@param _uri6 uri of the nft for 180 days stake\\n    ///@param _uri12 uri of the nft for 360 days stake\\n    constructor(\\n        address _soph,\\n        uint256 _minimumAmount,\\n        string memory _uri3,\\n        string memory _uri6,\\n        string memory _uri12,\\n        address _owner\\n    ) ERC1155(\\\"\\\") Ownable(_owner) {\\n        require(_soph != address(0), \\\"Invalid address\\\");\\n\\n        //set soph token address\\n        soph = _soph;\\n        minimumAmount = _minimumAmount;\\n\\n        //set uris\\n        uri3 = _uri3;\\n        uri6 = _uri6;\\n        uri12 = _uri12;\\n    }\\n\\n    ///@notice function to pause the contract\\n    ///@dev only the owner can pause the contract\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    ///@notice function to unpause the contract\\n    ///@dev only the owner can unpause the contract\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    ///@notice function to stake soph tokens\\n    ///@param _timeType time type of the stake, either 90, 180 or 360 days\\n    ///@dev the user must not have a stake already\\n    ///@dev the user must not have a nft with the same id as the stake type\\n    ///@dev the user must have the minimum amount of soph tokens to stake\\n    function stake(uint256 _timeType) external nonReentrant whenNotPaused {\\n        //require _timeType to be 90, 180 or 360 days\\n        require(_timeType == 90 days || _timeType == 180 days || _timeType == 360 days, \\\"Invalid time type\\\"); //3 months, 6 months, 12 months\\n\\n        //if stake type is 90 days , then mint id = 3\\n        //if stake type is 180 days , then mint id = 6\\n        //if stake type is 360 days , then mint id = 12\\n        uint256 mint_id;\\n        if (_timeType == 90 days) mint_id = 3;\\n        else if (_timeType == 180 days) mint_id = 6;\\n        else if (_timeType == 360 days) mint_id = 12;\\n\\n        uint256 _amount = minimumAmount;\\n        address _wallet = msg.sender;\\n\\n        //require user does not have nft with id = _timeType\\n        require(balanceOf(_wallet, mint_id) == 0, \\\"You already have a stake badge of this type\\\");\\n\\n        //require user does not have a stake\\n        uint256 current_stakeTimeType = wallet_stakeTimeType[_wallet];\\n        if (current_stakeTimeType > 0) {\\n            revert(\\\"You already have a stake, you should unstake or upgrade it\\\");\\n        }\\n\\n        //set the sender's stake time\\n        wallet_stakeEndTimer[_wallet] = block.timestamp + _timeType;\\n        wallet_stakeTimeType[_wallet] = _timeType;\\n\\n        //transfer soph tokens from sender to this contract\\n        require(IERC20(soph).transferFrom(_wallet, address(this), _amount), \\\"Transfer failed\\\");\\n\\n        emit Staked(_wallet, _timeType);\\n    }\\n\\n    ///@notice function to unstake soph tokens if the sender already has a stake and the stake has matured, then mint a soulbound nft\\n    ///@param _receiver address to receive the unstaked soph tokens\\n    ///@dev the user must have a stake\\n    function unstake(address _receiver) external nonReentrant {\\n        address _wallet = msg.sender;\\n        //require user has a stake\\n        require(wallet_stakeEndTimer[_wallet] > 0, \\\"You have no stake\\\");\\n        //require that the sender's stake has matured\\n        require(block.timestamp >= wallet_stakeEndTimer[_wallet], \\\"Your stake has not matured yet\\\");\\n\\n        //if stake type is 90 days , then mint id = 3\\n        //if stake type is 180 days , then mint id = 6\\n        //if stake type is 360 days , then mint id = 12\\n        uint256 mint_id;\\n        uint256 _timeType = wallet_stakeTimeType[_wallet];\\n        if (_timeType == 90 days) mint_id = 3;\\n        else if (_timeType == 180 days) mint_id = 6;\\n        else if (_timeType == 360 days) mint_id = 12;\\n\\n        //reset the user's stake time\\n        wallet_stakeEndTimer[_wallet] = 0;\\n        //reset the user's stake type\\n        wallet_stakeTimeType[_wallet] = 0;\\n\\n        uint256 amount = minimumAmount;\\n\\n        //transfer the sender's stake back to the sender\\n        require(IERC20(soph).transfer(_receiver, amount), \\\"Transfer failed\\\");\\n\\n        //mint soulbound nft\\n        _mint(_receiver, mint_id, amount, \\\"\\\");\\n\\n        emit Unstaked(_wallet, mint_id);\\n    }\\n\\n    ///@notice add time to the sender's stake and changing the stake type\\n    ///@param _timeType time type of the stake, either 180 or 360 days\\n    ///@dev the user must have a stake\\n    ///@dev the user must upgrade to a longer stake time\\n    function upgradeStake(uint256 _timeType) external nonReentrant whenNotPaused {\\n        address _wallet = msg.sender;\\n        uint256 current_stakeTimeType = wallet_stakeTimeType[_wallet];\\n        require(current_stakeTimeType > 0, \\\"You have no stake to upgrade\\\");\\n\\n        //require _timeType to be 180 or 360 days\\n        require(_timeType == 180 days || _timeType == 360 days, \\\"Invalid time type\\\"); //6 months, 12 months\\n\\n        require(_timeType > current_stakeTimeType, \\\"You can only upgrade to a longer stake time\\\");\\n\\n        //increase the sender's stake time\\n        wallet_stakeEndTimer[_wallet] += _timeType - current_stakeTimeType;\\n        wallet_stakeTimeType[_wallet] = _timeType;\\n    }\\n\\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    /// override transfer functions to only allow this contract to call them\\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public override {\\n        revert(\\\"This function is not allowed\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    ) public override {\\n        revert(\\\"This function is not allowed\\\");\\n    }\\n\\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    /// override uri function to return the id with uri for all token types\\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     * @param _id The ID of the token\\n     * @notice _id must be 3, 6 or 12 as these are the only valid ids\\n     */\\n    function uri(uint256 _id) public view override returns (string memory) {\\n        if (_id == 3) return uri3;\\n        else if (_id == 6) return uri6;\\n        else if (_id == 12) return uri12;\\n        else return \\\"\\\";\\n    }\\n\\n    function setURIs(string memory _uri3, string memory _uri6, string memory _uri12) external onlyOwner {\\n        uri3 = _uri3;\\n        uri6 = _uri6;\\n        uri12 = _uri12;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\r\\n     * caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `value` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/ERC1155.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {IERC1155} from \\\"./IERC1155.sol\\\";\\r\\nimport {IERC1155MetadataURI} from \\\"./extensions/IERC1155MetadataURI.sol\\\";\\r\\nimport {ERC1155Utils} from \\\"./utils/ERC1155Utils.sol\\\";\\r\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\r\\nimport {IERC165, ERC165} from \\\"../../utils/introspection/ERC165.sol\\\";\\r\\nimport {Arrays} from \\\"../../utils/Arrays.sol\\\";\\r\\nimport {IERC1155Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the basic standard multi-token.\\r\\n * See https://eips.ethereum.org/EIPS/eip-1155\\r\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\r\\n */\\r\\nabstract contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI, IERC1155Errors {\\r\\n    using Arrays for uint256[];\\r\\n    using Arrays for address[];\\r\\n\\r\\n    mapping(uint256 id => mapping(address account => uint256)) private _balances;\\r\\n\\r\\n    mapping(address account => mapping(address operator => bool)) private _operatorApprovals;\\r\\n\\r\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\r\\n    string private _uri;\\r\\n\\r\\n    /**\\r\\n     * @dev See {_setURI}.\\r\\n     */\\r\\n    constructor(string memory uri_) {\\r\\n        _setURI(uri_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\r\\n        return\\r\\n            interfaceId == type(IERC1155).interfaceId ||\\r\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\r\\n            super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155MetadataURI-uri}.\\r\\n     *\\r\\n     * This implementation returns the same URI for *all* token types. It relies\\r\\n     * on the token type ID substitution mechanism\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].\\r\\n     *\\r\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\r\\n     * actual token type ID.\\r\\n     */\\r\\n    function uri(uint256 /* id */) public view virtual returns (string memory) {\\r\\n        return _uri;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\\r\\n        return _balances[id][account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-balanceOfBatch}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(\\r\\n        address[] memory accounts,\\r\\n        uint256[] memory ids\\r\\n    ) public view virtual returns (uint256[] memory) {\\r\\n        if (accounts.length != ids.length) {\\r\\n            revert ERC1155InvalidArrayLength(ids.length, accounts.length);\\r\\n        }\\r\\n\\r\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\r\\n\\r\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\r\\n            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));\\r\\n        }\\r\\n\\r\\n        return batchBalances;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-setApprovalForAll}.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\r\\n        _setApprovalForAll(_msgSender(), operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-isApprovedForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\\r\\n        return _operatorApprovals[account][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) public virtual {\\r\\n        address sender = _msgSender();\\r\\n        if (from != sender && !isApprovedForAll(from, sender)) {\\r\\n            revert ERC1155MissingApprovalForAll(sender, from);\\r\\n        }\\r\\n        _safeTransferFrom(from, to, id, value, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory values,\\r\\n        bytes memory data\\r\\n    ) public virtual {\\r\\n        address sender = _msgSender();\\r\\n        if (from != sender && !isApprovedForAll(from, sender)) {\\r\\n            revert ERC1155MissingApprovalForAll(sender, from);\\r\\n        }\\r\\n        _safeBatchTransferFrom(from, to, ids, values, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from`\\r\\n     * (or `to`) is the zero address.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event if the arrays contain one element, and {TransferBatch} otherwise.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - If `to` refers to a smart contract, it must implement either {IERC1155Receiver-onERC1155Received}\\r\\n     *   or {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.\\r\\n     * - `ids` and `values` must have the same length.\\r\\n     *\\r\\n     * NOTE: The ERC-1155 acceptance check is not performed in this function. See {_updateWithAcceptanceCheck} instead.\\r\\n     */\\r\\n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values) internal virtual {\\r\\n        if (ids.length != values.length) {\\r\\n            revert ERC1155InvalidArrayLength(ids.length, values.length);\\r\\n        }\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; ++i) {\\r\\n            uint256 id = ids.unsafeMemoryAccess(i);\\r\\n            uint256 value = values.unsafeMemoryAccess(i);\\r\\n\\r\\n            if (from != address(0)) {\\r\\n                uint256 fromBalance = _balances[id][from];\\r\\n                if (fromBalance < value) {\\r\\n                    revert ERC1155InsufficientBalance(from, fromBalance, value, id);\\r\\n                }\\r\\n                unchecked {\\r\\n                    // Overflow not possible: value <= fromBalance\\r\\n                    _balances[id][from] = fromBalance - value;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (to != address(0)) {\\r\\n                _balances[id][to] += value;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (ids.length == 1) {\\r\\n            uint256 id = ids.unsafeMemoryAccess(0);\\r\\n            uint256 value = values.unsafeMemoryAccess(0);\\r\\n            emit TransferSingle(operator, from, to, id, value);\\r\\n        } else {\\r\\n            emit TransferBatch(operator, from, to, ids, values);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Version of {_update} that performs the token acceptance check by calling\\r\\n     * {IERC1155Receiver-onERC1155Received} or {IERC1155Receiver-onERC1155BatchReceived} on the receiver address if it\\r\\n     * contains code (eg. is a smart contract at the moment of execution).\\r\\n     *\\r\\n     * IMPORTANT: Overriding this function is discouraged because it poses a reentrancy risk from the receiver. So any\\r\\n     * update to the contract state after this function would break the check-effect-interaction pattern. Consider\\r\\n     * overriding {_update} instead.\\r\\n     */\\r\\n    function _updateWithAcceptanceCheck(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory values,\\r\\n        bytes memory data\\r\\n    ) internal virtual {\\r\\n        _update(from, to, ids, values);\\r\\n        if (to != address(0)) {\\r\\n            address operator = _msgSender();\\r\\n            if (ids.length == 1) {\\r\\n                uint256 id = ids.unsafeMemoryAccess(0);\\r\\n                uint256 value = values.unsafeMemoryAccess(0);\\r\\n                ERC1155Utils.checkOnERC1155Received(operator, from, to, id, value, data);\\r\\n            } else {\\r\\n                ERC1155Utils.checkOnERC1155BatchReceived(operator, from, to, ids, values, data);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers a `value` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) internal {\\r\\n        if (to == address(0)) {\\r\\n            revert ERC1155InvalidReceiver(address(0));\\r\\n        }\\r\\n        if (from == address(0)) {\\r\\n            revert ERC1155InvalidSender(address(0));\\r\\n        }\\r\\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\\r\\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     * - `ids` and `values` must have the same length.\\r\\n     */\\r\\n    function _safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory values,\\r\\n        bytes memory data\\r\\n    ) internal {\\r\\n        if (to == address(0)) {\\r\\n            revert ERC1155InvalidReceiver(address(0));\\r\\n        }\\r\\n        if (from == address(0)) {\\r\\n            revert ERC1155InvalidSender(address(0));\\r\\n        }\\r\\n        _updateWithAcceptanceCheck(from, to, ids, values, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\r\\n     * substitution mechanism\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the ERC].\\r\\n     *\\r\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\r\\n     * URI or any of the values in the JSON file at said URI will be replaced by\\r\\n     * clients with the token type ID.\\r\\n     *\\r\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\r\\n     * interpreted by clients as\\r\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\r\\n     * for token type ID 0x4cce0.\\r\\n     *\\r\\n     * See {uri}.\\r\\n     *\\r\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\r\\n     * this function emits no events.\\r\\n     */\\r\\n    function _setURI(string memory newuri) internal virtual {\\r\\n        _uri = newuri;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates a `value` amount of tokens of type `id`, and assigns them to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal {\\r\\n        if (to == address(0)) {\\r\\n            revert ERC1155InvalidReceiver(address(0));\\r\\n        }\\r\\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\\r\\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `values` must have the same length.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal {\\r\\n        if (to == address(0)) {\\r\\n            revert ERC1155InvalidReceiver(address(0));\\r\\n        }\\r\\n        _updateWithAcceptanceCheck(address(0), to, ids, values, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys a `value` amount of tokens of type `id` from `from`\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `from` must have at least `value` amount of tokens of type `id`.\\r\\n     */\\r\\n    function _burn(address from, uint256 id, uint256 value) internal {\\r\\n        if (from == address(0)) {\\r\\n            revert ERC1155InvalidSender(address(0));\\r\\n        }\\r\\n        (uint256[] memory ids, uint256[] memory values) = _asSingletonArrays(id, value);\\r\\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `from` must have at least `value` amount of tokens of type `id`.\\r\\n     * - `ids` and `values` must have the same length.\\r\\n     */\\r\\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory values) internal {\\r\\n        if (from == address(0)) {\\r\\n            revert ERC1155InvalidSender(address(0));\\r\\n        }\\r\\n        _updateWithAcceptanceCheck(from, address(0), ids, values, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `operator` cannot be the zero address.\\r\\n     */\\r\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\r\\n        if (operator == address(0)) {\\r\\n            revert ERC1155InvalidOperator(address(0));\\r\\n        }\\r\\n        _operatorApprovals[owner][operator] = approved;\\r\\n        emit ApprovalForAll(owner, operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates an array in memory with only one value for each of the elements provided.\\r\\n     */\\r\\n    function _asSingletonArrays(\\r\\n        uint256 element1,\\r\\n        uint256 element2\\r\\n    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Load the free memory pointer\\r\\n            array1 := mload(0x40)\\r\\n            // Set array length to 1\\r\\n            mstore(array1, 1)\\r\\n            // Store the single element at the next word after the length (where content starts)\\r\\n            mstore(add(array1, 0x20), element1)\\r\\n\\r\\n            // Repeat for next array locating it right after the first array\\r\\n            array2 := add(array1, 0x40)\\r\\n            mstore(array2, 1)\\r\\n            mstore(add(array2, 0x20), element2)\\r\\n\\r\\n            // Update the free memory pointer by pointing after the second array\\r\\n            mstore(0x40, add(array2, 0x40))\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler's defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant NOT_ENTERED = 1;\\r\\n    uint256 private constant ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    /**\\r\\n     * @dev Unauthorized reentrant call.\\r\\n     */\\r\\n    error ReentrancyGuardReentrantCall();\\r\\n\\r\\n    constructor() {\\r\\n        _status = NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _nonReentrantBefore();\\r\\n        _;\\r\\n        _nonReentrantAfter();\\r\\n    }\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\r\\n        if (_status == ENTERED) {\\r\\n            revert ReentrancyGuardReentrantCall();\\r\\n        }\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = ENTERED;\\r\\n    }\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\r\\n     * `nonReentrant` function in the call stack.\\r\\n     */\\r\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\r\\n        return _status == ENTERED;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {Context} from \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which allows children to implement an emergency stop\\r\\n * mechanism that can be triggered by an authorized account.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the\\r\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\r\\n * the functions of your contract. Note that they will not be pausable by\\r\\n * simply including this module, only once the modifiers are put in place.\\r\\n */\\r\\nabstract contract Pausable is Context {\\r\\n    bool private _paused;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pause is triggered by `account`.\\r\\n     */\\r\\n    event Paused(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pause is lifted by `account`.\\r\\n     */\\r\\n    event Unpaused(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev The operation failed because the contract is paused.\\r\\n     */\\r\\n    error EnforcedPause();\\r\\n\\r\\n    /**\\r\\n     * @dev The operation failed because the contract is not paused.\\r\\n     */\\r\\n    error ExpectedPause();\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract in unpaused state.\\r\\n     */\\r\\n    constructor() {\\r\\n        _paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        _requireNotPaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        _requirePaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the contract is paused, and false otherwise.\\r\\n     */\\r\\n    function paused() public view virtual returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the contract is paused.\\r\\n     */\\r\\n    function _requireNotPaused() internal view virtual {\\r\\n        if (paused()) {\\r\\n            revert EnforcedPause();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the contract is not paused.\\r\\n     */\\r\\n    function _requirePaused() internal view virtual {\\r\\n        if (!paused()) {\\r\\n            revert ExpectedPause();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers stopped state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    function _pause() internal virtual whenNotPaused {\\r\\n        _paused = true;\\r\\n        emit Paused(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns to normal state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    function _unpause() internal virtual whenPaused {\\r\\n        _paused = false;\\r\\n        emit Unpaused(_msgSender());\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {Context} from \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * The initial owner is set to the address provided by the deployer. This can\\r\\n * later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    /**\\r\\n     * @dev The caller account is not authorized to perform an operation.\\r\\n     */\\r\\n    error OwnableUnauthorizedAccount(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\r\\n     */\\r\\n    error OwnableInvalidOwner(address owner);\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\r\\n     */\\r\\n    constructor(address initialOwner) {\\r\\n        if (initialOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(initialOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        if (owner() != _msgSender()) {\\r\\n            revert OwnableUnauthorizedAccount(_msgSender());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby disabling any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        if (newOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\\r\\n */\\r\\ninterface IERC1155 is IERC165 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\r\\n     */\\r\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n    event TransferBatch(\\r\\n        address indexed operator,\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256[] ids,\\r\\n        uint256[] values\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\r\\n     * `approved`.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\r\\n     *\\r\\n     * If an {URI} event was emitted for `id`, the standard\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\r\\n     * returned by {IERC1155MetadataURI-uri}.\\r\\n     */\\r\\n    event URI(string value, uint256 indexed id);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(\\r\\n        address[] calldata accounts,\\r\\n        uint256[] calldata ids\\r\\n    ) external view returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `operator` cannot be the zero address.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\r\\n     *\\r\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\r\\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\\r\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\r\\n     * reentrancy guards when interacting with untrusted contracts.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\r\\n     *\\r\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\r\\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\\r\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\r\\n     * reentrancy guards when interacting with untrusted contracts.\\r\\n     *\\r\\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `values` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {IERC1155} from \\\"../IERC1155.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\r\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[ERC].\\r\\n */\\r\\ninterface IERC1155MetadataURI is IERC1155 {\\r\\n    /**\\r\\n     * @dev Returns the URI for token type `id`.\\r\\n     *\\r\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\r\\n     * clients with the actual token type ID.\\r\\n     */\\r\\n    function uri(uint256 id) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {IERC1155Receiver} from \\\"../IERC1155Receiver.sol\\\";\\r\\nimport {IERC1155Errors} from \\\"../../../interfaces/draft-IERC6093.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Library that provide common ERC-1155 utility functions.\\r\\n *\\r\\n * See https://eips.ethereum.org/EIPS/eip-1155[ERC-1155].\\r\\n */\\r\\nlibrary ERC1155Utils {\\r\\n    /**\\r\\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC1155-onERC1155Received}\\r\\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\\r\\n     *\\r\\n     * The acceptance call is not executed and treated as a no-op if the target address is doesn't contain code (i.e. an EOA).\\r\\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\\r\\n     * the transfer.\\r\\n     */\\r\\n    function checkOnERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes memory data\\r\\n    ) internal {\\r\\n        if (to.code.length > 0) {\\r\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\\r\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\r\\n                    // Tokens rejected\\r\\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\\r\\n                }\\r\\n            } catch (bytes memory reason) {\\r\\n                if (reason.length == 0) {\\r\\n                    // non-IERC1155Receiver implementer\\r\\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\\r\\n                } else {\\r\\n                    /// @solidity memory-safe-assembly\\r\\n                    assembly {\\r\\n                        revert(add(32, reason), mload(reason))\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a batch acceptance check for the provided `operator` by calling {IERC1155-onERC1155BatchReceived}\\r\\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\\r\\n     *\\r\\n     * The acceptance call is not executed and treated as a no-op if the target address is doesn't contain code (i.e. an EOA).\\r\\n     * Otherwise, the recipient must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value to accept\\r\\n     * the transfer.\\r\\n     */\\r\\n    function checkOnERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory values,\\r\\n        bytes memory data\\r\\n    ) internal {\\r\\n        if (to.code.length > 0) {\\r\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (\\r\\n                bytes4 response\\r\\n            ) {\\r\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\r\\n                    // Tokens rejected\\r\\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\\r\\n                }\\r\\n            } catch (bytes memory reason) {\\r\\n                if (reason.length == 0) {\\r\\n                    // non-IERC1155Receiver implementer\\r\\n                    revert IERC1155Errors.ERC1155InvalidReceiver(to);\\r\\n                } else {\\r\\n                    /// @solidity memory-safe-assembly\\r\\n                    assembly {\\r\\n                        revert(add(32, reason), mload(reason))\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n\\r\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\r\\n        return 0;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\r\\n * for the additional interface id that will be supported. For example:\\r\\n *\\r\\n * ```solidity\\r\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\r\\n * }\\r\\n * ```\\r\\n */\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Arrays.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Arrays.sol)\\r\\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {SlotDerivation} from \\\"./SlotDerivation.sol\\\";\\r\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\r\\nimport {Math} from \\\"./math/Math.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to array types.\\r\\n */\\r\\nlibrary Arrays {\\r\\n    using SlotDerivation for bytes32;\\r\\n    using StorageSlot for bytes32;\\r\\n\\r\\n    /**\\r\\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\\r\\n     *\\r\\n     * This function does the sorting \\\"in place\\\", meaning that it overrides the input. The object is returned for\\r\\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\\r\\n     *\\r\\n     * NOTE: this function's cost is `O(n \u00b7 log(n))` in average and `O(n\u00b2)` in the worst case, with n the length of the\\r\\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\\r\\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\\r\\n     * consume more gas than is available in a block, leading to potential DoS.\\r\\n     */\\r\\n    function sort(\\r\\n        bytes32[] memory array,\\r\\n        function(bytes32, bytes32) pure returns (bool) comp\\r\\n    ) internal pure returns (bytes32[] memory) {\\r\\n        _quickSort(_begin(array), _end(array), comp);\\r\\n        return array;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\\r\\n     */\\r\\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\\r\\n        sort(array, _defaultComp);\\r\\n        return array;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sort an array of address (in memory) following the provided comparator function.\\r\\n     *\\r\\n     * This function does the sorting \\\"in place\\\", meaning that it overrides the input. The object is returned for\\r\\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\\r\\n     *\\r\\n     * NOTE: this function's cost is `O(n \u00b7 log(n))` in average and `O(n\u00b2)` in the worst case, with n the length of the\\r\\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\\r\\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\\r\\n     * consume more gas than is available in a block, leading to potential DoS.\\r\\n     */\\r\\n    function sort(\\r\\n        address[] memory array,\\r\\n        function(address, address) pure returns (bool) comp\\r\\n    ) internal pure returns (address[] memory) {\\r\\n        sort(_castToBytes32Array(array), _castToBytes32Comp(comp));\\r\\n        return array;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\\r\\n     */\\r\\n    function sort(address[] memory array) internal pure returns (address[] memory) {\\r\\n        sort(_castToBytes32Array(array), _defaultComp);\\r\\n        return array;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\\r\\n     *\\r\\n     * This function does the sorting \\\"in place\\\", meaning that it overrides the input. The object is returned for\\r\\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\\r\\n     *\\r\\n     * NOTE: this function's cost is `O(n \u00b7 log(n))` in average and `O(n\u00b2)` in the worst case, with n the length of the\\r\\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\\r\\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\\r\\n     * consume more gas than is available in a block, leading to potential DoS.\\r\\n     */\\r\\n    function sort(\\r\\n        uint256[] memory array,\\r\\n        function(uint256, uint256) pure returns (bool) comp\\r\\n    ) internal pure returns (uint256[] memory) {\\r\\n        sort(_castToBytes32Array(array), _castToBytes32Comp(comp));\\r\\n        return array;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\\r\\n     */\\r\\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\\r\\n        sort(_castToBytes32Array(array), _defaultComp);\\r\\n        return array;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\\r\\n     * at end (exclusive). Sorting follows the `comp` comparator.\\r\\n     *\\r\\n     * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.\\r\\n     *\\r\\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\\r\\n     * be used only if the limits are within a memory array.\\r\\n     */\\r\\n    function _quickSort(uint256 begin, uint256 end, function(bytes32, bytes32) pure returns (bool) comp) private pure {\\r\\n        unchecked {\\r\\n            if (end - begin < 0x40) return;\\r\\n\\r\\n            // Use first element as pivot\\r\\n            bytes32 pivot = _mload(begin);\\r\\n            // Position where the pivot should be at the end of the loop\\r\\n            uint256 pos = begin;\\r\\n\\r\\n            for (uint256 it = begin + 0x20; it < end; it += 0x20) {\\r\\n                if (comp(_mload(it), pivot)) {\\r\\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\\r\\n                    // position of the pivot and move the value there.\\r\\n                    pos += 0x20;\\r\\n                    _swap(pos, it);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            _swap(begin, pos); // Swap pivot into place\\r\\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\\r\\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Pointer to the memory location of the first element of `array`.\\r\\n     */\\r\\n    function _begin(bytes32[] memory array) private pure returns (uint256 ptr) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            ptr := add(array, 0x20)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\\r\\n     * that comes just after the last element of the array.\\r\\n     */\\r\\n    function _end(bytes32[] memory array) private pure returns (uint256 ptr) {\\r\\n        unchecked {\\r\\n            return _begin(array) + array.length * 0x20;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Load memory word (as a bytes32) at location `ptr`.\\r\\n     */\\r\\n    function _mload(uint256 ptr) private pure returns (bytes32 value) {\\r\\n        assembly {\\r\\n            value := mload(ptr)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\\r\\n     */\\r\\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\\r\\n        assembly {\\r\\n            let value1 := mload(ptr1)\\r\\n            let value2 := mload(ptr2)\\r\\n            mstore(ptr1, value2)\\r\\n            mstore(ptr2, value1)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Comparator for sorting arrays in increasing order.\\r\\n    function _defaultComp(bytes32 a, bytes32 b) private pure returns (bool) {\\r\\n        return a < b;\\r\\n    }\\r\\n\\r\\n    /// @dev Helper: low level cast address memory array to uint256 memory array\\r\\n    function _castToBytes32Array(address[] memory input) private pure returns (bytes32[] memory output) {\\r\\n        assembly {\\r\\n            output := input\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Helper: low level cast uint256 memory array to uint256 memory array\\r\\n    function _castToBytes32Array(uint256[] memory input) private pure returns (bytes32[] memory output) {\\r\\n        assembly {\\r\\n            output := input\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Helper: low level cast address comp function to bytes32 comp function\\r\\n    function _castToBytes32Comp(\\r\\n        function(address, address) pure returns (bool) input\\r\\n    ) private pure returns (function(bytes32, bytes32) pure returns (bool) output) {\\r\\n        assembly {\\r\\n            output := input\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Helper: low level cast uint256 comp function to bytes32 comp function\\r\\n    function _castToBytes32Comp(\\r\\n        function(uint256, uint256) pure returns (bool) input\\r\\n    ) private pure returns (function(bytes32, bytes32) pure returns (bool) output) {\\r\\n        assembly {\\r\\n            output := input\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Searches a sorted `array` and returns the first index that contains\\r\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\r\\n     * values in the array are strictly less than `element`), the array length is\\r\\n     * returned. Time complexity O(log n).\\r\\n     *\\r\\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\\r\\n     * contain no repeated elements.\\r\\n     *\\r\\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\\r\\n     * support for repeated elements in the array. The {lowerBound} function should\\r\\n     * be used instead.\\r\\n     */\\r\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\r\\n        uint256 low = 0;\\r\\n        uint256 high = array.length;\\r\\n\\r\\n        if (high == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        while (low < high) {\\r\\n            uint256 mid = Math.average(low, high);\\r\\n\\r\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\r\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\r\\n            if (unsafeAccess(array, mid).value > element) {\\r\\n                high = mid;\\r\\n            } else {\\r\\n                low = mid + 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\r\\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\\r\\n            return low - 1;\\r\\n        } else {\\r\\n            return low;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Searches an `array` sorted in ascending order and returns the first\\r\\n     * index that contains a value greater or equal than `element`. If no such index\\r\\n     * exists (i.e. all values in the array are strictly less than `element`), the array\\r\\n     * length is returned. Time complexity O(log n).\\r\\n     *\\r\\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\\r\\n     */\\r\\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\r\\n        uint256 low = 0;\\r\\n        uint256 high = array.length;\\r\\n\\r\\n        if (high == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        while (low < high) {\\r\\n            uint256 mid = Math.average(low, high);\\r\\n\\r\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\r\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\r\\n            if (unsafeAccess(array, mid).value < element) {\\r\\n                // this cannot overflow because mid < high\\r\\n                unchecked {\\r\\n                    low = mid + 1;\\r\\n                }\\r\\n            } else {\\r\\n                high = mid;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return low;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Searches an `array` sorted in ascending order and returns the first\\r\\n     * index that contains a value strictly greater than `element`. If no such index\\r\\n     * exists (i.e. all values in the array are strictly less than `element`), the array\\r\\n     * length is returned. Time complexity O(log n).\\r\\n     *\\r\\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\\r\\n     */\\r\\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\r\\n        uint256 low = 0;\\r\\n        uint256 high = array.length;\\r\\n\\r\\n        if (high == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        while (low < high) {\\r\\n            uint256 mid = Math.average(low, high);\\r\\n\\r\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\r\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\r\\n            if (unsafeAccess(array, mid).value > element) {\\r\\n                high = mid;\\r\\n            } else {\\r\\n                // this cannot overflow because mid < high\\r\\n                unchecked {\\r\\n                    low = mid + 1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return low;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {lowerBound}, but with an array in memory.\\r\\n     */\\r\\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\\r\\n        uint256 low = 0;\\r\\n        uint256 high = array.length;\\r\\n\\r\\n        if (high == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        while (low < high) {\\r\\n            uint256 mid = Math.average(low, high);\\r\\n\\r\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\r\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\r\\n            if (unsafeMemoryAccess(array, mid) < element) {\\r\\n                // this cannot overflow because mid < high\\r\\n                unchecked {\\r\\n                    low = mid + 1;\\r\\n                }\\r\\n            } else {\\r\\n                high = mid;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return low;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {upperBound}, but with an array in memory.\\r\\n     */\\r\\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\\r\\n        uint256 low = 0;\\r\\n        uint256 high = array.length;\\r\\n\\r\\n        if (high == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        while (low < high) {\\r\\n            uint256 mid = Math.average(low, high);\\r\\n\\r\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\r\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\r\\n            if (unsafeMemoryAccess(array, mid) > element) {\\r\\n                high = mid;\\r\\n            } else {\\r\\n                // this cannot overflow because mid < high\\r\\n                unchecked {\\r\\n                    low = mid + 1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return low;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\r\\n     *\\r\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\r\\n     */\\r\\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\\r\\n        bytes32 slot;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            slot := arr.slot\\r\\n        }\\r\\n        return slot.deriveArray().offset(pos).getAddressSlot();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\r\\n     *\\r\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\r\\n     */\\r\\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\\r\\n        bytes32 slot;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            slot := arr.slot\\r\\n        }\\r\\n        return slot.deriveArray().offset(pos).getBytes32Slot();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\r\\n     *\\r\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\r\\n     */\\r\\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\\r\\n        bytes32 slot;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            slot := arr.slot\\r\\n        }\\r\\n        return slot.deriveArray().offset(pos).getUint256Slot();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\r\\n     *\\r\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\r\\n     */\\r\\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\\r\\n        assembly {\\r\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\r\\n     *\\r\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\r\\n     */\\r\\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\\r\\n        assembly {\\r\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\r\\n     *\\r\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\r\\n     */\\r\\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\\r\\n        assembly {\\r\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Helper to set the length of an dynamic array. Directly writing to `.length` is forbidden.\\r\\n     *\\r\\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\\r\\n     */\\r\\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\\r\\n        assembly {\\r\\n            sstore(array.slot, len)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Helper to set the length of an dynamic array. Directly writing to `.length` is forbidden.\\r\\n     *\\r\\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\\r\\n     */\\r\\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\\r\\n        assembly {\\r\\n            sstore(array.slot, len)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Helper to set the length of an dynamic array. Directly writing to `.length` is forbidden.\\r\\n     *\\r\\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\\r\\n     */\\r\\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\\r\\n        assembly {\\r\\n            sstore(array.slot, len)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Standard ERC-20 Errors\\r\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\\r\\n */\\r\\ninterface IERC20Errors {\\r\\n    /**\\r\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\r\\n     * @param sender Address whose tokens are being transferred.\\r\\n     * @param balance Current balance for the interacting account.\\r\\n     * @param needed Minimum amount required to perform a transfer.\\r\\n     */\\r\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\r\\n     * @param sender Address whose tokens are being transferred.\\r\\n     */\\r\\n    error ERC20InvalidSender(address sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\r\\n     * @param receiver Address to which tokens are being transferred.\\r\\n     */\\r\\n    error ERC20InvalidReceiver(address receiver);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\r\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\r\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\r\\n     * @param needed Minimum amount required to perform a transfer.\\r\\n     */\\r\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\r\\n     * @param approver Address initiating an approval operation.\\r\\n     */\\r\\n    error ERC20InvalidApprover(address approver);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\r\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\r\\n     */\\r\\n    error ERC20InvalidSpender(address spender);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Standard ERC-721 Errors\\r\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\\r\\n */\\r\\ninterface IERC721Errors {\\r\\n    /**\\r\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\r\\n     * Used in balance queries.\\r\\n     * @param owner Address of the current owner of a token.\\r\\n     */\\r\\n    error ERC721InvalidOwner(address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\r\\n     * @param tokenId Identifier number of a token.\\r\\n     */\\r\\n    error ERC721NonexistentToken(uint256 tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\r\\n     * @param sender Address whose tokens are being transferred.\\r\\n     * @param tokenId Identifier number of a token.\\r\\n     * @param owner Address of the current owner of a token.\\r\\n     */\\r\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\r\\n     * @param sender Address whose tokens are being transferred.\\r\\n     */\\r\\n    error ERC721InvalidSender(address sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\r\\n     * @param receiver Address to which tokens are being transferred.\\r\\n     */\\r\\n    error ERC721InvalidReceiver(address receiver);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\r\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\r\\n     * @param tokenId Identifier number of a token.\\r\\n     */\\r\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\r\\n     * @param approver Address initiating an approval operation.\\r\\n     */\\r\\n    error ERC721InvalidApprover(address approver);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\r\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\r\\n     */\\r\\n    error ERC721InvalidOperator(address operator);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Standard ERC-1155 Errors\\r\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\\r\\n */\\r\\ninterface IERC1155Errors {\\r\\n    /**\\r\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\r\\n     * @param sender Address whose tokens are being transferred.\\r\\n     * @param balance Current balance for the interacting account.\\r\\n     * @param needed Minimum amount required to perform a transfer.\\r\\n     * @param tokenId Identifier number of a token.\\r\\n     */\\r\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\r\\n     * @param sender Address whose tokens are being transferred.\\r\\n     */\\r\\n    error ERC1155InvalidSender(address sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\r\\n     * @param receiver Address to which tokens are being transferred.\\r\\n     */\\r\\n    error ERC1155InvalidReceiver(address receiver);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\r\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\r\\n     * @param owner Address of the current owner of a token.\\r\\n     */\\r\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\r\\n     * @param approver Address initiating an approval operation.\\r\\n     */\\r\\n    error ERC1155InvalidApprover(address approver);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\r\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\r\\n     */\\r\\n    error ERC1155InvalidOperator(address operator);\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\r\\n     * Used in batch transfers.\\r\\n     * @param idsLength Length of the array of token identifiers\\r\\n     * @param valuesLength Length of the array of token amounts\\r\\n     */\\r\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC-165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface that must be implemented by smart contracts in order to receive\\r\\n * ERC-1155 token transfers.\\r\\n */\\r\\ninterface IERC1155Receiver is IERC165 {\\r\\n    /**\\r\\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\\r\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer, this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n     * (i.e. 0xf23a6e61, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param id The ID of the token being transferred\\r\\n     * @param value The amount of tokens being transferred\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n\\r\\n    /**\\r\\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\\r\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\r\\n     * been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer(s), this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n     * (i.e. 0xbc197c81, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\r\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/SlotDerivation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\\r\\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\\r\\n * the solidity language / compiler.\\r\\n *\\r\\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\\r\\n *\\r\\n * Example usage:\\r\\n * ```solidity\\r\\n * contract Example {\\r\\n *     // Add the library methods\\r\\n *     using StorageSlot for bytes32;\\r\\n *     using SlotDerivation for bytes32;\\r\\n *\\r\\n *     // Declare a namespace\\r\\n *     string private constant _NAMESPACE = \\\"<namespace>\\\" // eg. OpenZeppelin.Slot\\r\\n *\\r\\n *     function setValueInNamespace(uint256 key, address newValue) internal {\\r\\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\\r\\n *     }\\r\\n *\\r\\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\\r\\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\\r\\n *     }\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * TIP: Consider using this library along with {StorageSlot}.\\r\\n *\\r\\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\\r\\n * upgrade safety will ignore the slots accessed through this library.\\r\\n */\\r\\nlibrary SlotDerivation {\\r\\n    /**\\r\\n     * @dev Derive an ERC-7201 slot from a string (namespace).\\r\\n     */\\r\\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\\r\\n            slot := and(keccak256(0x00, 0x20), not(0xff))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\\r\\n     */\\r\\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\\r\\n        unchecked {\\r\\n            return bytes32(uint256(slot) + pos);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\\r\\n     */\\r\\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, slot)\\r\\n            result := keccak256(0x00, 0x20)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Derive the location of a mapping element from the key.\\r\\n     */\\r\\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, key)\\r\\n            mstore(0x20, slot)\\r\\n            result := keccak256(0x00, 0x40)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Derive the location of a mapping element from the key.\\r\\n     */\\r\\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, key)\\r\\n            mstore(0x20, slot)\\r\\n            result := keccak256(0x00, 0x40)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Derive the location of a mapping element from the key.\\r\\n     */\\r\\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, key)\\r\\n            mstore(0x20, slot)\\r\\n            result := keccak256(0x00, 0x40)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Derive the location of a mapping element from the key.\\r\\n     */\\r\\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, key)\\r\\n            mstore(0x20, slot)\\r\\n            result := keccak256(0x00, 0x40)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Derive the location of a mapping element from the key.\\r\\n     */\\r\\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, key)\\r\\n            mstore(0x20, slot)\\r\\n            result := keccak256(0x00, 0x40)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Derive the location of a mapping element from the key.\\r\\n     */\\r\\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let length := mload(key)\\r\\n            let begin := add(key, 0x20)\\r\\n            let end := add(begin, length)\\r\\n            let cache := mload(end)\\r\\n            mstore(end, slot)\\r\\n            result := keccak256(begin, add(length, 0x20))\\r\\n            mstore(end, cache)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Derive the location of a mapping element from the key.\\r\\n     */\\r\\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let length := mload(key)\\r\\n            let begin := add(key, 0x20)\\r\\n            let end := add(begin, length)\\r\\n            let cache := mload(end)\\r\\n            mstore(end, slot)\\r\\n            result := keccak256(begin, add(length, 0x20))\\r\\n            mstore(end, cache)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\r\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Library for reading and writing primitive types to specific storage slots.\\r\\n *\\r\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\r\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\r\\n *\\r\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\r\\n *\\r\\n * Example usage to set ERC-1967 implementation slot:\\r\\n * ```solidity\\r\\n * contract ERC1967 {\\r\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\r\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n *\\r\\n *     function _getImplementation() internal view returns (address) {\\r\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\r\\n *     }\\r\\n *\\r\\n *     function _setImplementation(address newImplementation) internal {\\r\\n *         require(newImplementation.code.length > 0);\\r\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\r\\n *     }\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * TIP: Consider using this library along with {SlotDerivation}.\\r\\n */\\r\\nlibrary StorageSlot {\\r\\n    struct AddressSlot {\\r\\n        address value;\\r\\n    }\\r\\n\\r\\n    struct BooleanSlot {\\r\\n        bool value;\\r\\n    }\\r\\n\\r\\n    struct Bytes32Slot {\\r\\n        bytes32 value;\\r\\n    }\\r\\n\\r\\n    struct Uint256Slot {\\r\\n        uint256 value;\\r\\n    }\\r\\n\\r\\n    struct Int256Slot {\\r\\n        int256 value;\\r\\n    }\\r\\n\\r\\n    struct StringSlot {\\r\\n        string value;\\r\\n    }\\r\\n\\r\\n    struct BytesSlot {\\r\\n        bytes value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `Int256Slot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\r\\n     */\\r\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            r.slot := store.slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\r\\n     */\\r\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\r\\n     */\\r\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            r.slot := store.slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {Panic} from \\\"../Panic.sol\\\";\\r\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    enum Rounding {\\r\\n        Floor, // Toward negative infinity\\r\\n        Ceil, // Toward positive infinity\\r\\n        Trunc, // Toward zero\\r\\n        Expand // Away from zero\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c < a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\r\\n        unchecked {\\r\\n            if (b > a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n            // benefit is lost if 'b' is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a > b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow.\\r\\n        return (a & b) + (a ^ b) / 2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the ceiling of the division of two numbers.\\r\\n     *\\r\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\r\\n     * of rounding towards zero.\\r\\n     */\\r\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (b == 0) {\\r\\n            // Guarantee the same behavior as in a regular Solidity division.\\r\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\r\\n        }\\r\\n\\r\\n        // The following calculation ensures accurate ceiling division without overflow.\\r\\n        // Since a is non-zero, (a - 1) / b will not overflow.\\r\\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\r\\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\\r\\n        // when a = type(uint256).max and b = 1.\\r\\n        unchecked {\\r\\n            return a == 0 ? 0 : (a - 1) / b + 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\r\\n     * denominator == 0.\\r\\n     *\\r\\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\r\\n     * Uniswap Labs also under MIT license.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\r\\n        unchecked {\\r\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2\u00b2\u2075\u2076 and mod 2\u00b2\u2075\u2076 - 1, then use\\r\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n            // variables such that product = prod1 * 2\u00b2\u2075\u2076 + prod0.\\r\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\r\\n            uint256 prod1; // Most significant 256 bits of the product\\r\\n            assembly {\\r\\n                let mm := mulmod(x, y, not(0))\\r\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n            }\\r\\n\\r\\n            // Handle non-overflow cases, 256 by 256 division.\\r\\n            if (prod1 == 0) {\\r\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\r\\n                // The surrounding unchecked block does not change this fact.\\r\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\r\\n                return prod0 / denominator;\\r\\n            }\\r\\n\\r\\n            // Make sure the result is less than 2\u00b2\u2075\u2076. Also prevents denominator == 0.\\r\\n            if (denominator <= prod1) {\\r\\n                Panic.panic(denominator == 0 ? Panic.DIVISION_BY_ZERO : Panic.UNDER_OVERFLOW);\\r\\n            }\\r\\n\\r\\n            ///////////////////////////////////////////////\\r\\n            // 512 by 256 division.\\r\\n            ///////////////////////////////////////////////\\r\\n\\r\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n            uint256 remainder;\\r\\n            assembly {\\r\\n                // Compute remainder using mulmod.\\r\\n                remainder := mulmod(x, y, denominator)\\r\\n\\r\\n                // Subtract 256 bit number from 512 bit number.\\r\\n                prod1 := sub(prod1, gt(remainder, prod0))\\r\\n                prod0 := sub(prod0, remainder)\\r\\n            }\\r\\n\\r\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\r\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\r\\n\\r\\n            uint256 twos = denominator & (0 - denominator);\\r\\n            assembly {\\r\\n                // Divide denominator by twos.\\r\\n                denominator := div(denominator, twos)\\r\\n\\r\\n                // Divide [prod1 prod0] by twos.\\r\\n                prod0 := div(prod0, twos)\\r\\n\\r\\n                // Flip twos such that it is 2\u00b2\u2075\u2076 / twos. If twos is zero, then it becomes one.\\r\\n                twos := add(div(sub(0, twos), twos), 1)\\r\\n            }\\r\\n\\r\\n            // Shift in bits from prod1 into prod0.\\r\\n            prod0 |= prod1 * twos;\\r\\n\\r\\n            // Invert denominator mod 2\u00b2\u2075\u2076. Now that denominator is an odd number, it has an inverse modulo 2\u00b2\u2075\u2076 such\\r\\n            // that denominator * inv \u2261 1 mod 2\u00b2\u2075\u2076. Compute the inverse by starting with a seed that is correct for\\r\\n            // four bits. That is, denominator * inv \u2261 1 mod 2\u2074.\\r\\n            uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\r\\n            // works in modular arithmetic, doubling the correct bits in each step.\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\u2078\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\u00b9\u2076\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\u00b3\u00b2\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\u2076\u2074\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\u00b9\u00b2\u2078\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2\u00b2\u2075\u2076\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n            // This will give us the correct result modulo 2\u00b2\u2075\u2076. Since the preconditions guarantee that the outcome is\\r\\n            // less than 2\u00b2\u2075\u2076, this is the final result. We don't need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inverse;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\r\\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\\r\\n     *\\r\\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, expect 0.\\r\\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\\r\\n     *\\r\\n     * If the input value is not inversible, 0 is returned.\\r\\n     *\\r\\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Ferma's little theorem and get the\\r\\n     * inverse using `Math.modExp(a, n - 2, n)`.\\r\\n     */\\r\\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            if (n == 0) return 0;\\r\\n\\r\\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\\r\\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\\r\\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\\r\\n            // ax + ny = 1\\r\\n            // ax = 1 + (-y)n\\r\\n            // ax \u2261 1 (mod n) # x is the inverse of a modulo n\\r\\n\\r\\n            // If the remainder is 0 the gcd is n right away.\\r\\n            uint256 remainder = a % n;\\r\\n            uint256 gcd = n;\\r\\n\\r\\n            // Therefore the initial coefficients are:\\r\\n            // ax + ny = gcd(a, n) = n\\r\\n            // 0a + 1n = n\\r\\n            int256 x = 0;\\r\\n            int256 y = 1;\\r\\n\\r\\n            while (remainder != 0) {\\r\\n                uint256 quotient = gcd / remainder;\\r\\n\\r\\n                (gcd, remainder) = (\\r\\n                    // The old remainder is the next gcd to try.\\r\\n                    remainder,\\r\\n                    // Compute the next remainder.\\r\\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\\r\\n                    // where gcd is at most n (capped to type(uint256).max)\\r\\n                    gcd - remainder * quotient\\r\\n                );\\r\\n\\r\\n                (x, y) = (\\r\\n                    // Increment the coefficient of a.\\r\\n                    y,\\r\\n                    // Decrement the coefficient of n.\\r\\n                    // Can overflow, but the result is casted to uint256 so that the\\r\\n                    // next value of y is \\\"wrapped around\\\" to a value between 0 and n - 1.\\r\\n                    x - y * int256(quotient)\\r\\n                );\\r\\n            }\\r\\n\\r\\n            if (gcd != 1) return 0; // No inverse exists.\\r\\n            return x < 0 ? (n - uint256(-x)) : uint256(x); // Wrap the result if it's negative.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - modulus can't be zero\\r\\n     * - underlying staticcall to precompile must succeed\\r\\n     *\\r\\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\\r\\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\\r\\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\\r\\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\\r\\n     * interpreted as 0.\\r\\n     */\\r\\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\\r\\n        (bool success, uint256 result) = tryModExp(b, e, m);\\r\\n        if (!success) {\\r\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\\r\\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked has failed if trying\\r\\n     * to operate modulo 0 or if the underlying precompile reverted.\\r\\n     *\\r\\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\\r\\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\\r\\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\\r\\n     * of a revert, but the result may be incorrectly interpreted as 0.\\r\\n     */\\r\\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\\r\\n        if (m == 0) return (false, 0);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let ptr := mload(0x40)\\r\\n            // | Offset    | Content    | Content (Hex)                                                      |\\r\\n            // |-----------|------------|--------------------------------------------------------------------|\\r\\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\r\\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\r\\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\r\\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\\r\\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\\r\\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\\r\\n            mstore(ptr, 0x20)\\r\\n            mstore(add(ptr, 0x20), 0x20)\\r\\n            mstore(add(ptr, 0x40), 0x20)\\r\\n            mstore(add(ptr, 0x60), b)\\r\\n            mstore(add(ptr, 0x80), e)\\r\\n            mstore(add(ptr, 0xa0), m)\\r\\n\\r\\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\\r\\n            // so we can use the memory scratch space located at offset 0.\\r\\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\\r\\n            result := mload(0x00)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\\r\\n     */\\r\\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory result) = tryModExp(b, e, m);\\r\\n        if (!success) {\\r\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\\r\\n     */\\r\\n    function tryModExp(\\r\\n        bytes memory b,\\r\\n        bytes memory e,\\r\\n        bytes memory m\\r\\n    ) internal view returns (bool success, bytes memory result) {\\r\\n        if (_zeroBytes(m)) return (false, new bytes(0));\\r\\n\\r\\n        uint256 mLen = m.length;\\r\\n\\r\\n        // Encode call args in result and move the free memory pointer\\r\\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\\r\\n\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let dataPtr := add(result, 0x20)\\r\\n            // Write result on top of args to avoid allocating extra memory.\\r\\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\\r\\n            // Overwrite the length.\\r\\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\\r\\n            mstore(result, mLen)\\r\\n            // Set the memory pointer after the returned data.\\r\\n            mstore(0x40, add(dataPtr, mLen))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether the provided byte array is zero.\\r\\n     */\\r\\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\\r\\n        for (uint256 i = 0; i < byteArray.length; ++i) {\\r\\n            if (byteArray[i] != 0) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\r\\n     * towards zero.\\r\\n     *\\r\\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\\r\\n     * using integer operations.\\r\\n     */\\r\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            // Take care of easy edge cases when a == 0 or a == 1\\r\\n            if (a <= 1) {\\r\\n                return a;\\r\\n            }\\r\\n\\r\\n            // In this function, we use Newton's method to get a root of `f(x) := x\u00b2 - a`. It involves building a\\r\\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\\r\\n            // the current value as `\u03b5_n = | x_n - sqrt(a) |`.\\r\\n            //\\r\\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\\r\\n            // of the target. (i.e. `2**(e-1) \u2264 sqrt(a) < 2**e`). We know that `e \u2264 128` because `(2\u00b9\u00b2\u2078)\u00b2 = 2\u00b2\u2075\u2076` is\\r\\n            // bigger than any uint256.\\r\\n            //\\r\\n            // By noticing that\\r\\n            // `2**(e-1) \u2264 sqrt(a) < 2**e \u2192 (2**(e-1))\u00b2 \u2264 a < (2**e)\u00b2 \u2192 2**(2*e-2) \u2264 a < 2**(2*e)`\\r\\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\\r\\n            // to the msb function.\\r\\n            uint256 aa = a;\\r\\n            uint256 xn = 1;\\r\\n\\r\\n            if (aa >= (1 << 128)) {\\r\\n                aa >>= 128;\\r\\n                xn <<= 64;\\r\\n            }\\r\\n            if (aa >= (1 << 64)) {\\r\\n                aa >>= 64;\\r\\n                xn <<= 32;\\r\\n            }\\r\\n            if (aa >= (1 << 32)) {\\r\\n                aa >>= 32;\\r\\n                xn <<= 16;\\r\\n            }\\r\\n            if (aa >= (1 << 16)) {\\r\\n                aa >>= 16;\\r\\n                xn <<= 8;\\r\\n            }\\r\\n            if (aa >= (1 << 8)) {\\r\\n                aa >>= 8;\\r\\n                xn <<= 4;\\r\\n            }\\r\\n            if (aa >= (1 << 4)) {\\r\\n                aa >>= 4;\\r\\n                xn <<= 2;\\r\\n            }\\r\\n            if (aa >= (1 << 2)) {\\r\\n                xn <<= 1;\\r\\n            }\\r\\n\\r\\n            // We now have x_n such that `x_n = 2**(e-1) \u2264 sqrt(a) < 2**e = 2 * x_n`. This implies \u03b5_n \u2264 2**(e-1).\\r\\n            //\\r\\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\\r\\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to \u03b5_n \u2264 2**(e-2).\\r\\n            // This is going to be our x_0 (and \u03b5_0)\\r\\n            xn = (3 * xn) >> 1; // \u03b5_0 := | x_0 - sqrt(a) | \u2264 2**(e-2)\\r\\n\\r\\n            // From here, Newton's method give us:\\r\\n            // x_{n+1} = (x_n + a / x_n) / 2\\r\\n            //\\r\\n            // One should note that:\\r\\n            // x_{n+1}\u00b2 - a = ((x_n + a / x_n) / 2)\u00b2 - a\\r\\n            //              = ((x_n\u00b2 + a) / (2 * x_n))\u00b2 - a\\r\\n            //              = (x_n\u2074 + 2 * a * x_n\u00b2 + a\u00b2) / (4 * x_n\u00b2) - a\\r\\n            //              = (x_n\u2074 + 2 * a * x_n\u00b2 + a\u00b2 - 4 * a * x_n\u00b2) / (4 * x_n\u00b2)\\r\\n            //              = (x_n\u2074 - 2 * a * x_n\u00b2 + a\u00b2) / (4 * x_n\u00b2)\\r\\n            //              = (x_n\u00b2 - a)\u00b2 / (2 * x_n)\u00b2\\r\\n            //              = ((x_n\u00b2 - a) / (2 * x_n))\u00b2\\r\\n            //              \u2265 0\\r\\n            // Which proves that for all n \u2265 1, sqrt(a) \u2264 x_n\\r\\n            //\\r\\n            // This gives us the proof of quadratic convergence of the sequence:\\r\\n            // \u03b5_{n+1} = | x_{n+1} - sqrt(a) |\\r\\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\\r\\n            //         = | (x_n\u00b2 + a - 2*x_n*sqrt(a)) / (2 * x_n) |\\r\\n            //         = | (x_n - sqrt(a))\u00b2 / (2 * x_n) |\\r\\n            //         = | \u03b5_n\u00b2 / (2 * x_n) |\\r\\n            //         = \u03b5_n\u00b2 / | (2 * x_n) |\\r\\n            //\\r\\n            // For the first iteration, we have a special case where x_0 is known:\\r\\n            // \u03b5_1 = \u03b5_0\u00b2 / | (2 * x_0) |\\r\\n            //     \u2264 (2**(e-2))\u00b2 / (2 * (2**(e-1) + 2**(e-2)))\\r\\n            //     \u2264 2**(2*e-4) / (3 * 2**(e-1))\\r\\n            //     \u2264 2**(e-3) / 3\\r\\n            //     \u2264 2**(e-3-log2(3))\\r\\n            //     \u2264 2**(e-4.5)\\r\\n            //\\r\\n            // For the following iterations, we use the fact that, 2**(e-1) \u2264 sqrt(a) \u2264 x_n:\\r\\n            // \u03b5_{n+1} = \u03b5_n\u00b2 / | (2 * x_n) |\\r\\n            //         \u2264 (2**(e-k))\u00b2 / (2 * 2**(e-1))\\r\\n            //         \u2264 2**(2*e-2*k) / 2**e\\r\\n            //         \u2264 2**(e-2*k)\\r\\n            xn = (xn + a / xn) >> 1; // \u03b5_1 := | x_1 - sqrt(a) | \u2264 2**(e-4.5)  -- special case, see above\\r\\n            xn = (xn + a / xn) >> 1; // \u03b5_2 := | x_2 - sqrt(a) | \u2264 2**(e-9)    -- general case with k = 4.5\\r\\n            xn = (xn + a / xn) >> 1; // \u03b5_3 := | x_3 - sqrt(a) | \u2264 2**(e-18)   -- general case with k = 9\\r\\n            xn = (xn + a / xn) >> 1; // \u03b5_4 := | x_4 - sqrt(a) | \u2264 2**(e-36)   -- general case with k = 18\\r\\n            xn = (xn + a / xn) >> 1; // \u03b5_5 := | x_5 - sqrt(a) | \u2264 2**(e-72)   -- general case with k = 36\\r\\n            xn = (xn + a / xn) >> 1; // \u03b5_6 := | x_6 - sqrt(a) | \u2264 2**(e-144)  -- general case with k = 72\\r\\n\\r\\n            // Because e \u2264 128 (as discussed during the first estimation phase), we know have reached a precision\\r\\n            // \u03b5_6 \u2264 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\\r\\n            // sqrt(a) or sqrt(a) + 1.\\r\\n            return xn - SafeCast.toUint(xn > a / xn);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates sqrt(a), following the selected rounding direction.\\r\\n     */\\r\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = sqrt(a);\\r\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        uint256 exp;\\r\\n        unchecked {\\r\\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\\r\\n            value >>= exp;\\r\\n            result += exp;\\r\\n\\r\\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\\r\\n            value >>= exp;\\r\\n            result += exp;\\r\\n\\r\\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\\r\\n            value >>= exp;\\r\\n            result += exp;\\r\\n\\r\\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\\r\\n            value >>= exp;\\r\\n            result += exp;\\r\\n\\r\\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\\r\\n            value >>= exp;\\r\\n            result += exp;\\r\\n\\r\\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\\r\\n            value >>= exp;\\r\\n            result += exp;\\r\\n\\r\\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\\r\\n            value >>= exp;\\r\\n            result += exp;\\r\\n\\r\\n            result += SafeCast.toUint(value > 1);\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log2(value);\\r\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >= 10 ** 64) {\\r\\n                value /= 10 ** 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >= 10 ** 32) {\\r\\n                value /= 10 ** 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >= 10 ** 16) {\\r\\n                value /= 10 ** 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >= 10 ** 8) {\\r\\n                value /= 10 ** 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >= 10 ** 4) {\\r\\n                value /= 10 ** 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >= 10 ** 2) {\\r\\n                value /= 10 ** 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >= 10 ** 1) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log10(value);\\r\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     *\\r\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\r\\n     */\\r\\n    function log256(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        uint256 isGt;\\r\\n        unchecked {\\r\\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\\r\\n            value >>= isGt * 128;\\r\\n            result += isGt * 16;\\r\\n\\r\\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\\r\\n            value >>= isGt * 64;\\r\\n            result += isGt * 8;\\r\\n\\r\\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\\r\\n            value >>= isGt * 32;\\r\\n            result += isGt * 4;\\r\\n\\r\\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\\r\\n            value >>= isGt * 16;\\r\\n            result += isGt * 2;\\r\\n\\r\\n            result += SafeCast.toUint(value > (1 << 8) - 1);\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log256(value);\\r\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\r\\n     */\\r\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\r\\n        return uint8(rounding) % 2 == 1;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Panic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Helper library for emitting standardized panic codes.\\r\\n *\\r\\n * ```solidity\\r\\n * contract Example {\\r\\n *      using Panic for uint256;\\r\\n *\\r\\n *      // Use any of the declared internal constants\\r\\n *      function foo() { Panic.GENERIC.panic(); }\\r\\n *\\r\\n *      // Alternatively\\r\\n *      function foo() { Panic.panic(Panic.GENERIC); }\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\\r\\n */\\r\\n// slither-disable-next-line unused-state\\r\\nlibrary Panic {\\r\\n    /// @dev generic / unspecified error\\r\\n    uint256 internal constant GENERIC = 0x00;\\r\\n    /// @dev used by the assert() builtin\\r\\n    uint256 internal constant ASSERT = 0x01;\\r\\n    /// @dev arithmetic underflow or overflow\\r\\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\\r\\n    /// @dev division or modulo by zero\\r\\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\\r\\n    /// @dev enum conversion error\\r\\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\\r\\n    /// @dev invalid encoding in storage\\r\\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\\r\\n    /// @dev empty array pop\\r\\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\\r\\n    /// @dev array out of bounds access\\r\\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\\r\\n    /// @dev resource error (too large allocation or too large array)\\r\\n    uint256 internal constant RESOURCE_ERROR = 0x41;\\r\\n    /// @dev calling invalid internal function\\r\\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\\r\\n\\r\\n    /// @dev Reverts with a panic code. Recommended to use with\\r\\n    /// the internal constants with predefined codes.\\r\\n    function panic(uint256 code) internal pure {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, 0x4e487b71)\\r\\n            mstore(0x20, code)\\r\\n            revert(0x1c, 0x24)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\r\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\r\\n * easily result in undesired exploitation or bugs, since developers usually\\r\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\r\\n * reverting the transaction when such an operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeCast {\\r\\n    /**\\r\\n     * @dev Value doesn't fit in an uint of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedIntToUint(int256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Value doesn't fit in an int of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedUintToInt(uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     */\\r\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\r\\n        if (value > type(uint248).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(248, value);\\r\\n        }\\r\\n        return uint248(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     */\\r\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\r\\n        if (value > type(uint240).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(240, value);\\r\\n        }\\r\\n        return uint240(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     */\\r\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\r\\n        if (value > type(uint232).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(232, value);\\r\\n        }\\r\\n        return uint232(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     */\\r\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\r\\n        if (value > type(uint224).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(224, value);\\r\\n        }\\r\\n        return uint224(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     */\\r\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\r\\n        if (value > type(uint216).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(216, value);\\r\\n        }\\r\\n        return uint216(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     */\\r\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\r\\n        if (value > type(uint208).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(208, value);\\r\\n        }\\r\\n        return uint208(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     */\\r\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\r\\n        if (value > type(uint200).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(200, value);\\r\\n        }\\r\\n        return uint200(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     */\\r\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\r\\n        if (value > type(uint192).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(192, value);\\r\\n        }\\r\\n        return uint192(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     */\\r\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\r\\n        if (value > type(uint184).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(184, value);\\r\\n        }\\r\\n        return uint184(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     */\\r\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\r\\n        if (value > type(uint176).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(176, value);\\r\\n        }\\r\\n        return uint176(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     */\\r\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\r\\n        if (value > type(uint168).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(168, value);\\r\\n        }\\r\\n        return uint168(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     */\\r\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\r\\n        if (value > type(uint160).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(160, value);\\r\\n        }\\r\\n        return uint160(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     */\\r\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\r\\n        if (value > type(uint152).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(152, value);\\r\\n        }\\r\\n        return uint152(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     */\\r\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\r\\n        if (value > type(uint144).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(144, value);\\r\\n        }\\r\\n        return uint144(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     */\\r\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\r\\n        if (value > type(uint136).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(136, value);\\r\\n        }\\r\\n        return uint136(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     */\\r\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\r\\n        if (value > type(uint128).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(128, value);\\r\\n        }\\r\\n        return uint128(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     */\\r\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\r\\n        if (value > type(uint120).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(120, value);\\r\\n        }\\r\\n        return uint120(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     */\\r\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\r\\n        if (value > type(uint112).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(112, value);\\r\\n        }\\r\\n        return uint112(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     */\\r\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\r\\n        if (value > type(uint104).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(104, value);\\r\\n        }\\r\\n        return uint104(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     */\\r\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\r\\n        if (value > type(uint96).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(96, value);\\r\\n        }\\r\\n        return uint96(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     */\\r\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\r\\n        if (value > type(uint88).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(88, value);\\r\\n        }\\r\\n        return uint88(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     */\\r\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\r\\n        if (value > type(uint80).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(80, value);\\r\\n        }\\r\\n        return uint80(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     */\\r\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\r\\n        if (value > type(uint72).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(72, value);\\r\\n        }\\r\\n        return uint72(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     */\\r\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\r\\n        if (value > type(uint64).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(64, value);\\r\\n        }\\r\\n        return uint64(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     */\\r\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\r\\n        if (value > type(uint56).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(56, value);\\r\\n        }\\r\\n        return uint56(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     */\\r\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\r\\n        if (value > type(uint48).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(48, value);\\r\\n        }\\r\\n        return uint48(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     */\\r\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\r\\n        if (value > type(uint40).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(40, value);\\r\\n        }\\r\\n        return uint40(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     */\\r\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\r\\n        if (value > type(uint32).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(32, value);\\r\\n        }\\r\\n        return uint32(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     */\\r\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\r\\n        if (value > type(uint24).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(24, value);\\r\\n        }\\r\\n        return uint24(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     */\\r\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\r\\n        if (value > type(uint16).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(16, value);\\r\\n        }\\r\\n        return uint16(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     */\\r\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\r\\n        if (value > type(uint8).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(8, value);\\r\\n        }\\r\\n        return uint8(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a signed int256 into an unsigned uint256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be greater than or equal to 0.\\r\\n     */\\r\\n    function toUint256(int256 value) internal pure returns (uint256) {\\r\\n        if (value < 0) {\\r\\n            revert SafeCastOverflowedIntToUint(value);\\r\\n        }\\r\\n        return uint256(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int248 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int248 or\\r\\n     * greater than largest int248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     */\\r\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\r\\n        downcasted = int248(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(248, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int240 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int240 or\\r\\n     * greater than largest int240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     */\\r\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\r\\n        downcasted = int240(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(240, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int232 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int232 or\\r\\n     * greater than largest int232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     */\\r\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\r\\n        downcasted = int232(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(232, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int224 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int224 or\\r\\n     * greater than largest int224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     */\\r\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\r\\n        downcasted = int224(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(224, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int216 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int216 or\\r\\n     * greater than largest int216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     */\\r\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\r\\n        downcasted = int216(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(216, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int208 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int208 or\\r\\n     * greater than largest int208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     */\\r\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\r\\n        downcasted = int208(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(208, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int200 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int200 or\\r\\n     * greater than largest int200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     */\\r\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\r\\n        downcasted = int200(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(200, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int192 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int192 or\\r\\n     * greater than largest int192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     */\\r\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\r\\n        downcasted = int192(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(192, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int184 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int184 or\\r\\n     * greater than largest int184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     */\\r\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\r\\n        downcasted = int184(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(184, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int176 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int176 or\\r\\n     * greater than largest int176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     */\\r\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\r\\n        downcasted = int176(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(176, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int168 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int168 or\\r\\n     * greater than largest int168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     */\\r\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\r\\n        downcasted = int168(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(168, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int160 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int160 or\\r\\n     * greater than largest int160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     */\\r\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\r\\n        downcasted = int160(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(160, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int152 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int152 or\\r\\n     * greater than largest int152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     */\\r\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\r\\n        downcasted = int152(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(152, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int144 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int144 or\\r\\n     * greater than largest int144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     */\\r\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\r\\n        downcasted = int144(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(144, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int136 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int136 or\\r\\n     * greater than largest int136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     */\\r\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\r\\n        downcasted = int136(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(136, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int128 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int128 or\\r\\n     * greater than largest int128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     */\\r\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\r\\n        downcasted = int128(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(128, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int120 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int120 or\\r\\n     * greater than largest int120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     */\\r\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\r\\n        downcasted = int120(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(120, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int112 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int112 or\\r\\n     * greater than largest int112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     */\\r\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\r\\n        downcasted = int112(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(112, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int104 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int104 or\\r\\n     * greater than largest int104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     */\\r\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\r\\n        downcasted = int104(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(104, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int96 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int96 or\\r\\n     * greater than largest int96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     */\\r\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\r\\n        downcasted = int96(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(96, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int88 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int88 or\\r\\n     * greater than largest int88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     */\\r\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\r\\n        downcasted = int88(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(88, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int80 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int80 or\\r\\n     * greater than largest int80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     */\\r\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\r\\n        downcasted = int80(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(80, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int72 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int72 or\\r\\n     * greater than largest int72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     */\\r\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\r\\n        downcasted = int72(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(72, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int64 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int64 or\\r\\n     * greater than largest int64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     */\\r\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\r\\n        downcasted = int64(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(64, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int56 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int56 or\\r\\n     * greater than largest int56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     */\\r\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\r\\n        downcasted = int56(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(56, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int48 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int48 or\\r\\n     * greater than largest int48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     */\\r\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\r\\n        downcasted = int48(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(48, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int40 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int40 or\\r\\n     * greater than largest int40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     */\\r\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\r\\n        downcasted = int40(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(40, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int32 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int32 or\\r\\n     * greater than largest int32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     */\\r\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\r\\n        downcasted = int32(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(32, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int24 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int24 or\\r\\n     * greater than largest int24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     */\\r\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\r\\n        downcasted = int24(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(24, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int16 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int16 or\\r\\n     * greater than largest int16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     */\\r\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\r\\n        downcasted = int16(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(16, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int8 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int8 or\\r\\n     * greater than largest int8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     */\\r\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\r\\n        downcasted = int8(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(8, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an unsigned uint256 into a signed int256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be less than or equal to maxInt256.\\r\\n     */\\r\\n    function toInt256(uint256 value) internal pure returns (int256) {\\r\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\r\\n        if (value > uint256(type(int256).max)) {\\r\\n            revert SafeCastOverflowedUintToInt(value);\\r\\n        }\\r\\n        return int256(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\\r\\n     */\\r\\n    function toUint(bool b) internal pure returns (uint256 u) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            u := iszero(iszero(b))\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_soph\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_uri3\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_uri6\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_uri12\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC1155InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valuesLength\",\"type\":\"uint256\"}],\"name\":\"ERC1155InvalidArrayLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC1155MissingApprovalForAll\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeType\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeType\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeType\",\"type\":\"uint256\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri3\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_uri6\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_uri12\",\"type\":\"string\"}],\"name\":\"setURIs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"soph\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeType\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeType\",\"type\":\"uint256\"}],\"name\":\"upgradeStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uri12\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uri3\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uri6\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wallet_stakeEndTimer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wallet_stakeTimeType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeTimeType\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BoosterBronze", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000073fbd93bfda83b111ddc092aa3a4ca77fd30d38000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000027a5ce58fc466d0e3a9d1990404354029398541000000000000000000000000000000000000000000000000000000000000005f68747470733a2f2f6261667962656961706a716c6a6c76627970737a37706e6368327234706263676b7769727071347879676f676d6c636f7a7734376f7665727733712e697066732e6e667473746f726167652e6c696e6b2f312e6a736f6e00000000000000000000000000000000000000000000000000000000000000005f68747470733a2f2f6261667962656961706a716c6a6c76627970737a37706e6368327234706263676b7769727071347879676f676d6c636f7a7734376f7665727733712e697066732e6e667473746f726167652e6c696e6b2f322e6a736f6e00000000000000000000000000000000000000000000000000000000000000005f68747470733a2f2f6261667962656961706a716c6a6c76627970737a37706e6368327234706263676b7769727071347879676f676d6c636f7a7734376f7665727733712e697066732e6e667473746f726167652e6c696e6b2f332e6a736f6e00", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}