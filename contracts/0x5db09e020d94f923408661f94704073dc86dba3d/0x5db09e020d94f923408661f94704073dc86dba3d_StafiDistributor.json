{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/deposit/IStafiUserDeposit.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface IStafiUserDeposit {\\n    function getBalance() external view returns (uint256);\\n    function getExcessBalance() external view returns (uint256);\\n    function deposit() external payable;\\n    function recycleDissolvedDeposit() external payable;\\n    function recycleWithdrawDeposit() external payable;\\n    function recycleDistributorDeposit() external payable;\\n    function assignDeposits() external;\\n    function withdrawExcessBalance(uint256 _amount) external;\\n    function withdrawExcessBalanceForSuperNode(uint256 _amount) external;\\n    function withdrawExcessBalanceForLightNode(uint256 _amount) external;\\n    function withdrawExcessBalanceForWithdraw(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStafiEther.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface IStafiEther {\\n    function balanceOf(address _contractAddress) external view returns (uint256);\\n    function depositEther() external payable;\\n    function withdrawEther(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStafiEtherWithdrawer.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface IStafiEtherWithdrawer {\\n    function receiveEtherWithdrawal() external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/node/IStafiNodeManager.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface IStafiNodeManager {\\n    function getNodeCount() external view returns (uint256);\\n    function getNodeAt(uint256 _index) external view returns (address);\\n    function getTrustedNodeCount() external view returns (uint256);\\n    function getTrustedNodeAt(uint256 _index) external view returns (address);\\n    function getSuperNodeCount() external view returns (uint256);\\n    function getSuperNodeAt(uint256 _index) external view returns (address);\\n    function getNodeExists(address _nodeAddress) external view returns (bool);\\n    function getNodeTrusted(address _nodeAddress) external view returns (bool);\\n    function getSuperNodeExists(address _nodeAddress) external view returns (bool);\\n    function registerNode(address _nodeAddress) external;\\n    function setNodeTrusted(address _nodeAddress, bool _trusted) external;\\n    function setNodeSuper(address _nodeAddress, bool _super) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reward/IStafiDistributor.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface IStafiDistributor {\\n    function distributeWithdrawals() external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reward/IStafiFeePool.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface IStafiFeePool {\\n    function withdrawEther(address _to, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/reward/IStafiSuperNodeFeePool.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface IStafiSuperNodeFeePool {\\n    function withdrawEther(address _to, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/settings/IStafiNetworkSettings.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface IStafiNetworkSettings {\\n    function getNodeConsensusThreshold() external view returns (uint256);\\n    function getSubmitBalancesEnabled() external view returns (bool);\\n    function getProcessWithdrawalsEnabled() external view returns (bool);\\n    function getNodeFee() external view returns (uint256);\\n    function getPlatformFee() external view returns (uint256);\\n    function getNodeRefundRatio() external view returns (uint256);\\n    function getNodeTrustedRefundRatio() external view returns (uint256);\\n    function getWithdrawalCredentials() external view returns (bytes memory);\\n    function getSuperNodePubkeyLimit() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/storage/IStafiStorage.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\ninterface IStafiStorage {\\n\\n    // Getters\\n    function getAddress(bytes32 _key) external view returns (address);\\n    function getUint(bytes32 _key) external view returns (uint);\\n    function getString(bytes32 _key) external view returns (string memory);\\n    function getBytes(bytes32 _key) external view returns (bytes memory);\\n    function getBool(bytes32 _key) external view returns (bool);\\n    function getInt(bytes32 _key) external view returns (int);\\n    function getBytes32(bytes32 _key) external view returns (bytes32);\\n\\n    // Setters\\n    function setAddress(bytes32 _key, address _value) external;\\n    function setUint(bytes32 _key, uint _value) external;\\n    function setString(bytes32 _key, string calldata _value) external;\\n    function setBytes(bytes32 _key, bytes calldata _value) external;\\n    function setBool(bytes32 _key, bool _value) external;\\n    function setInt(bytes32 _key, int _value) external;\\n    function setBytes32(bytes32 _key, bytes32 _value) external;\\n\\n    // Deleters\\n    function deleteAddress(bytes32 _key) external;\\n    function deleteUint(bytes32 _key) external;\\n    function deleteString(bytes32 _key) external;\\n    function deleteBytes(bytes32 _key) external;\\n    function deleteBool(bytes32 _key) external;\\n    function deleteInt(bytes32 _key) external;\\n    function deleteBytes32(bytes32 _key) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/reward/StafiDistributor.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/MerkleProof.sol\\\";\\nimport \\\"../StafiBase.sol\\\";\\nimport \\\"../interfaces/IStafiEther.sol\\\";\\nimport \\\"../interfaces/deposit/IStafiUserDeposit.sol\\\";\\nimport \\\"../interfaces/settings/IStafiNetworkSettings.sol\\\";\\nimport \\\"../interfaces/reward/IStafiFeePool.sol\\\";\\nimport \\\"../interfaces/reward/IStafiSuperNodeFeePool.sol\\\";\\nimport \\\"../interfaces/reward/IStafiDistributor.sol\\\";\\nimport \\\"../interfaces/IStafiEtherWithdrawer.sol\\\";\\nimport \\\"../interfaces/node/IStafiNodeManager.sol\\\";\\nimport \\\"../types/ClaimType.sol\\\";\\n\\n// Distribute network validator priorityFees/withdrawals/slashs\\ncontract StafiDistributor is StafiBase, IStafiEtherWithdrawer, IStafiDistributor {\\n    // Libs\\n    using SafeMath for uint256;\\n\\n    event Claimed(\\n        uint256 index,\\n        address account,\\n        uint256 claimableReward,\\n        uint256 claimableDeposit,\\n        ClaimType claimType\\n    );\\n    event VoteProposal(bytes32 indexed proposalId, address voter);\\n    event ProposalExecuted(bytes32 indexed proposalId);\\n    event DistributeFee(uint256 dealedHeight, uint256 userAmount, uint256 nodeAmount, uint256 platformAmount);\\n    event DistributeSuperNodeFee(uint256 dealedHeight, uint256 userAmount, uint256 nodeAmount, uint256 platformAmount);\\n    event DistributeSlash(uint256 dealedHeight, uint256 slashAmount);\\n    event SetMerkleRoot(uint256 dealedEpoch, bytes32 merkleRoot);\\n    event SetPlatformTotalAmount(uint256 dealedEpoch, uint256 totalAmount);\\n\\n    // Construct\\n    constructor(address _stafiStorageAddress) StafiBase(_stafiStorageAddress) {\\n        version = 1;\\n    }\\n\\n    receive() external payable {}\\n\\n    // Receive a ether withdrawal\\n    // Only accepts calls from the StafiEther contract\\n    function receiveEtherWithdrawal()\\n        external\\n        payable\\n        override\\n        onlyLatestContract(\\\"stafiDistributor\\\", address(this))\\n        onlyLatestContract(\\\"stafiEther\\\", msg.sender)\\n    {}\\n\\n    // distribute withdrawals for node/platform, accept calls from stafiWithdraw\\n    function distributeWithdrawals() external payable override onlyLatestContract(\\\"stafiDistributor\\\", address(this)) {\\n        require(msg.value > 0, \\\"zero amount\\\");\\n\\n        IStafiEther stafiEther = IStafiEther(getContractAddress(\\\"stafiEther\\\"));\\n        stafiEther.depositEther{value: msg.value}();\\n    }\\n\\n    // ------------ getter ------------\\n\\n    function getCurrentNodeDepositAmount() public view returns (uint256) {\\n        return getUint(\\\"settings.node.deposit.amount\\\");\\n    }\\n\\n    function getMerkleDealedEpoch() public view returns (uint256) {\\n        return getUint(keccak256(abi.encodePacked(\\\"stafiDistributor.merkleRoot.dealedEpoch\\\")));\\n    }\\n\\n    function getTotalClaimedReward(address _account) public view returns (uint256) {\\n        return getUint(keccak256(abi.encodePacked(\\\"stafiDistributor.node.totalClaimedReward\\\", _account)));\\n    }\\n\\n    function getTotalClaimedDeposit(address _account) public view returns (uint256) {\\n        return getUint(keccak256(abi.encodePacked(\\\"stafiDistributor.node.totalClaimedDeposit\\\", _account)));\\n    }\\n\\n    function getMerkleRoot() public view returns (bytes32) {\\n        return getBytes32(keccak256(abi.encodePacked(\\\"stafiDistributor.merkleRoot\\\")));\\n    }\\n\\n    function getDistributeFeeDealedHeight() public view returns (uint256) {\\n        return getUint(keccak256(abi.encodePacked(\\\"stafiDistributor.distributeFee.dealedHeight\\\")));\\n    }\\n\\n    function getDistributeSuperNodeFeeDealedHeight() public view returns (uint256) {\\n        return getUint(keccak256(abi.encodePacked(\\\"stafiDistributor.distributeSuperNodeFee.dealedHeight\\\")));\\n    }\\n\\n    function getDistributeSlashDealedHeight() public view returns (uint256) {\\n        return getUint(keccak256(abi.encodePacked(\\\"stafiDistributor.distributeSlashAmount.dealedHeight\\\")));\\n    }\\n\\n    function getPlatformTotalAmount() public view returns (uint256) {\\n        return getUint(keccak256(abi.encodePacked(\\\"stafiDistributor.platform.totalAmount\\\")));\\n    }\\n\\n    function getPlatformTotalClaimedAmount() public view returns (uint256) {\\n        return getUint(keccak256(abi.encodePacked(\\\"stafiDistributor.platform.totalClaimedAmount\\\")));\\n    }\\n\\n    // ------------ settings ------------\\n\\n    function updateMerkleRoot(\\n        bytes32 _merkleRoot\\n    ) external onlyLatestContract(\\\"stafiDistributor\\\", address(this)) onlySuperUser {\\n        setMerkleRoot(_merkleRoot);\\n    }\\n\\n    function claimPlatformFee(\\n        address _receiver\\n    ) external onlyLatestContract(\\\"stafiDistributor\\\", address(this)) onlySuperUser {\\n        uint256 totalAmount = getPlatformTotalAmount();\\n        uint256 willClaimAmount = totalAmount.sub(getPlatformTotalClaimedAmount());\\n        if (willClaimAmount > 0) {\\n            setPlatformTotalClaimedAmount(totalAmount);\\n\\n            IStafiEther stafiEther = IStafiEther(getContractAddress(\\\"stafiEther\\\"));\\n            stafiEther.withdrawEther(willClaimAmount);\\n\\n            (bool success, ) = _receiver.call{value: willClaimAmount}(\\\"\\\");\\n            require(success, \\\"failed to claim ETH\\\");\\n        }\\n    }\\n\\n    // ------------ vote ------------\\n\\n    // v1: platform = 10% node = 90%*(nodedeposit/32)+90%*(1- nodedeposit/32)*10%  user = 90%*(1- nodedeposit/32)*90%\\n    // v2: platform = 5%  node = 5% + (90% * nodedeposit/32) user = 90%*(1-nodedeposit/32)\\n    // distribute fee of feePool for user/node/platform\\n    function distributeFee(\\n        uint256 _dealedHeight,\\n        uint256 _userAmount,\\n        uint256 _nodeAmount,\\n        uint256 _platformAmount\\n    ) external onlyLatestContract(\\\"stafiDistributor\\\", address(this)) onlyTrustedNode(msg.sender) {\\n        uint256 totalAmount = _userAmount.add(_nodeAmount).add(_platformAmount);\\n        require(totalAmount > 0, \\\"zero amount\\\");\\n\\n        require(_dealedHeight > getDistributeFeeDealedHeight(), \\\"height already dealed\\\");\\n\\n        bytes32 proposalId = keccak256(\\n            abi.encodePacked(\\\"distributeFee\\\", _dealedHeight, _userAmount, _nodeAmount, _platformAmount)\\n        );\\n        bool needExe = _voteProposal(proposalId);\\n\\n        // Finalize if Threshold has been reached\\n        if (needExe) {\\n            IStafiFeePool feePool = IStafiFeePool(getContractAddress(\\\"stafiFeePool\\\"));\\n            IStafiUserDeposit stafiUserDeposit = IStafiUserDeposit(getContractAddress(\\\"stafiUserDeposit\\\"));\\n            IStafiEther stafiEther = IStafiEther(getContractAddress(\\\"stafiEther\\\"));\\n\\n            feePool.withdrawEther(address(this), totalAmount);\\n\\n            uint256 nodeAndPlatformAmount = _nodeAmount.add(_platformAmount);\\n\\n            if (_userAmount > 0) {\\n                stafiUserDeposit.recycleDistributorDeposit{value: _userAmount}();\\n            }\\n            if (nodeAndPlatformAmount > 0) {\\n                stafiEther.depositEther{value: nodeAndPlatformAmount}();\\n            }\\n\\n            setDistributeFeeDealedHeight(_dealedHeight);\\n\\n            _afterExecProposal(proposalId);\\n\\n            emit DistributeFee(_dealedHeight, _userAmount, _nodeAmount, _platformAmount);\\n        }\\n    }\\n\\n    // v1: platform = 10% node = 9%  user = 81%\\n    // v2: platform = 5%  node = 5%  user = 90%\\n    // distribute fee of superNode feePool for user/node/platform\\n    function distributeSuperNodeFee(\\n        uint256 _dealedHeight,\\n        uint256 _userAmount,\\n        uint256 _nodeAmount,\\n        uint256 _platformAmount\\n    ) external onlyLatestContract(\\\"stafiDistributor\\\", address(this)) onlyTrustedNode(msg.sender) {\\n        uint256 totalAmount = _userAmount.add(_nodeAmount).add(_platformAmount);\\n        require(totalAmount > 0, \\\"zero amount\\\");\\n\\n        require(_dealedHeight > getDistributeSuperNodeFeeDealedHeight(), \\\"height already dealed\\\");\\n\\n        bytes32 proposalId = keccak256(\\n            abi.encodePacked(\\\"distributeSuperNodeFee\\\", _dealedHeight, _userAmount, _nodeAmount, _platformAmount)\\n        );\\n        bool needExe = _voteProposal(proposalId);\\n\\n        // Finalize if Threshold has been reached\\n        if (needExe) {\\n            IStafiFeePool feePool = IStafiFeePool(getContractAddress(\\\"stafiSuperNodeFeePool\\\"));\\n            IStafiUserDeposit stafiUserDeposit = IStafiUserDeposit(getContractAddress(\\\"stafiUserDeposit\\\"));\\n            IStafiEther stafiEther = IStafiEther(getContractAddress(\\\"stafiEther\\\"));\\n\\n            feePool.withdrawEther(address(this), totalAmount);\\n\\n            uint256 nodeAndPlatformAmount = _nodeAmount.add(_platformAmount);\\n\\n            if (_userAmount > 0) {\\n                stafiUserDeposit.recycleDistributorDeposit{value: _userAmount}();\\n            }\\n            if (nodeAndPlatformAmount > 0) {\\n                stafiEther.depositEther{value: nodeAndPlatformAmount}();\\n            }\\n\\n            setDistributeSuperNodeFeeDealedHeight(_dealedHeight);\\n\\n            _afterExecProposal(proposalId);\\n\\n            emit DistributeSuperNodeFee(_dealedHeight, _userAmount, _nodeAmount, _platformAmount);\\n        }\\n    }\\n\\n    // distribute slash amount for user\\n    function distributeSlashAmount(\\n        uint256 _dealedHeight,\\n        uint256 _amount\\n    ) external onlyLatestContract(\\\"stafiDistributor\\\", address(this)) onlyTrustedNode(msg.sender) {\\n        require(_amount > 0, \\\"zero amount\\\");\\n\\n        require(_dealedHeight > getDistributeSlashDealedHeight(), \\\"height already dealed\\\");\\n\\n        bytes32 proposalId = keccak256(abi.encodePacked(\\\"distributeSlashAmount\\\", _dealedHeight, _amount));\\n        bool needExe = _voteProposal(proposalId);\\n\\n        // Finalize if Threshold has been reached\\n        if (needExe) {\\n            IStafiEther stafiEther = IStafiEther(getContractAddress(\\\"stafiEther\\\"));\\n            IStafiUserDeposit stafiUserDeposit = IStafiUserDeposit(getContractAddress(\\\"stafiUserDeposit\\\"));\\n\\n            stafiEther.withdrawEther(_amount);\\n            stafiUserDeposit.recycleDistributorDeposit{value: _amount}();\\n            setDistributeSlashDealedHeight(_dealedHeight);\\n\\n            _afterExecProposal(proposalId);\\n\\n            emit DistributeSlash(_dealedHeight, _amount);\\n        }\\n    }\\n\\n    function setMerkleRoot(\\n        uint256 _dealedEpoch,\\n        bytes32 _merkleRoot\\n    ) external onlyLatestContract(\\\"stafiDistributor\\\", address(this)) onlyTrustedNode(msg.sender) {\\n        uint256 predealedEpoch = getMerkleDealedEpoch();\\n        require(_dealedEpoch > predealedEpoch, \\\"epoch already dealed\\\");\\n\\n        bytes32 proposalId = keccak256(abi.encodePacked(\\\"setMerkleRoot\\\", _dealedEpoch, _merkleRoot));\\n        bool needExe = _voteProposal(proposalId);\\n\\n        // Finalize if Threshold has been reached\\n        if (needExe) {\\n            setMerkleRoot(_merkleRoot);\\n            setMerkleDealedEpoch(_dealedEpoch);\\n\\n            _afterExecProposal(proposalId);\\n\\n            emit SetMerkleRoot(_dealedEpoch, _merkleRoot);\\n        }\\n    }\\n\\n    function setPlatformTotalAmount(\\n        uint256 _dealedEpoch,\\n        uint256 _totalAmount\\n    ) external onlyLatestContract(\\\"stafiDistributor\\\", address(this)) onlyTrustedNode(msg.sender) {\\n        bytes32 proposalId = keccak256(abi.encodePacked(\\\"setPlatformTotalAmount\\\", _dealedEpoch, _totalAmount));\\n        bool needExe = _voteProposal(proposalId);\\n\\n        // Finalize if Threshold has been reached\\n        if (needExe) {\\n            setPlatformTotalAmount(_totalAmount);\\n\\n            _afterExecProposal(proposalId);\\n\\n            emit SetPlatformTotalAmount(_dealedEpoch, _totalAmount);\\n        }\\n    }\\n\\n    // ----- node claim --------------\\n\\n    function claim(\\n        uint256 _index,\\n        address _account,\\n        uint256 _totalRewardAmount,\\n        uint256 _totalExitDepositAmount,\\n        bytes32[] calldata _merkleProof,\\n        ClaimType _claimType\\n    ) external onlyLatestContract(\\\"stafiDistributor\\\", address(this)) {\\n        uint256 claimableReward = _totalRewardAmount.sub(getTotalClaimedReward(_account));\\n        uint256 claimableDeposit = _totalExitDepositAmount.sub(getTotalClaimedDeposit(_account));\\n\\n        // Verify the merkle proof.\\n        bytes32 node = keccak256(abi.encodePacked(_index, _account, _totalRewardAmount, _totalExitDepositAmount));\\n        require(MerkleProof.verify(_merkleProof, getMerkleRoot(), node), \\\"invalid proof\\\");\\n\\n        uint256 willClaimAmount;\\n        if (_claimType == ClaimType.CLAIMREWARD) {\\n            require(claimableReward > 0, \\\"no claimable reward\\\");\\n\\n            setTotalClaimedReward(_account, _totalRewardAmount);\\n            willClaimAmount = claimableReward;\\n        } else if (_claimType == ClaimType.CLAIMDEPOSIT) {\\n            require(claimableDeposit > 0, \\\"no claimable deposit\\\");\\n\\n            setTotalClaimedDeposit(_account, _totalExitDepositAmount);\\n            willClaimAmount = claimableDeposit;\\n        } else if (_claimType == ClaimType.CLAIMTOTAL) {\\n            willClaimAmount = claimableReward.add(claimableDeposit);\\n            require(willClaimAmount > 0, \\\"no claimable amount\\\");\\n\\n            setTotalClaimedReward(_account, _totalRewardAmount);\\n            setTotalClaimedDeposit(_account, _totalExitDepositAmount);\\n        } else {\\n            revert(\\\"unknown claimType\\\");\\n        }\\n\\n        IStafiEther stafiEther = IStafiEther(getContractAddress(\\\"stafiEther\\\"));\\n        stafiEther.withdrawEther(willClaimAmount);\\n        (bool success, ) = _account.call{value: willClaimAmount}(\\\"\\\");\\n        require(success, \\\"failed to claim ETH\\\");\\n\\n        emit Claimed(_index, _account, claimableReward, claimableDeposit, _claimType);\\n    }\\n\\n    // --- helper ----\\n\\n    function setTotalClaimedReward(address _account, uint256 _totalAmount) internal {\\n        setUint(keccak256(abi.encodePacked(\\\"stafiDistributor.node.totalClaimedReward\\\", _account)), _totalAmount);\\n    }\\n\\n    function setTotalClaimedDeposit(address _account, uint256 _totalAmount) internal {\\n        setUint(keccak256(abi.encodePacked(\\\"stafiDistributor.node.totalClaimedDeposit\\\", _account)), _totalAmount);\\n    }\\n\\n    function setMerkleDealedEpoch(uint256 _dealedEpoch) internal {\\n        setUint(keccak256(abi.encodePacked(\\\"stafiDistributor.merkleRoot.dealedEpoch\\\")), _dealedEpoch);\\n    }\\n\\n    function setMerkleRoot(bytes32 _merkleRoot) internal {\\n        setBytes32(keccak256(abi.encodePacked(\\\"stafiDistributor.merkleRoot\\\")), _merkleRoot);\\n    }\\n\\n    function setDistributeFeeDealedHeight(uint256 _dealedHeight) internal {\\n        setUint(keccak256(abi.encodePacked(\\\"stafiDistributor.distributeFee.dealedHeight\\\")), _dealedHeight);\\n    }\\n\\n    function setDistributeSuperNodeFeeDealedHeight(uint256 _dealedHeight) internal {\\n        setUint(keccak256(abi.encodePacked(\\\"stafiDistributor.distributeSuperNodeFee.dealedHeight\\\")), _dealedHeight);\\n    }\\n\\n    function setDistributeSlashDealedHeight(uint256 _dealedHeight) internal {\\n        setUint(keccak256(abi.encodePacked(\\\"stafiDistributor.distributeSlashAmount.dealedHeight\\\")), _dealedHeight);\\n    }\\n\\n    function setPlatformTotalAmount(uint256 _totalAmount) internal {\\n        setUint(keccak256(abi.encodePacked(\\\"stafiDistributor.platform.totalAmount\\\")), _totalAmount);\\n    }\\n\\n    function setPlatformTotalClaimedAmount(uint256 _totalClaimedAmount) internal {\\n        setUint(keccak256(abi.encodePacked(\\\"stafiDistributor.platform.totalClaimedAmount\\\")), _totalClaimedAmount);\\n    }\\n\\n    function _voteProposal(bytes32 _proposalId) internal returns (bool) {\\n        // Get submission keys\\n        bytes32 proposalNodeKey = keccak256(\\n            abi.encodePacked(\\\"stafiDistributor.proposal.node.key\\\", _proposalId, msg.sender)\\n        );\\n        bytes32 proposalKey = keccak256(abi.encodePacked(\\\"stafiDistributor.proposal.key\\\", _proposalId));\\n\\n        require(!getBool(proposalKey), \\\"proposal already executed\\\");\\n\\n        // Check & update node submission status\\n        require(!getBool(proposalNodeKey), \\\"duplicate vote\\\");\\n        setBool(proposalNodeKey, true);\\n\\n        // Increment submission count\\n        uint256 voteCount = getUint(proposalKey).add(1);\\n        setUint(proposalKey, voteCount);\\n\\n        emit VoteProposal(_proposalId, msg.sender);\\n\\n        // Check submission count & update network balances\\n        uint256 calcBase = 1 ether;\\n        IStafiNodeManager stafiNodeManager = IStafiNodeManager(getContractAddress(\\\"stafiNodeManager\\\"));\\n        IStafiNetworkSettings stafiNetworkSettings = IStafiNetworkSettings(getContractAddress(\\\"stafiNetworkSettings\\\"));\\n        uint256 threshold = stafiNetworkSettings.getNodeConsensusThreshold();\\n        if (calcBase.mul(voteCount) >= stafiNodeManager.getTrustedNodeCount().mul(threshold)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function _afterExecProposal(bytes32 _proposalId) internal {\\n        bytes32 proposalKey = keccak256(abi.encodePacked(\\\"stafiDistributor.proposal.key\\\", _proposalId));\\n        setBool(proposalKey, true);\\n\\n        emit ProposalExecuted(_proposalId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StafiBase.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\nimport \\\"./interfaces/storage/IStafiStorage.sol\\\";\\n\\nabstract contract StafiBase {\\n\\n    // Version of the contract\\n    uint8 public version;\\n\\n    // The main storage contract where primary persistant storage is maintained\\n    IStafiStorage stafiStorage = IStafiStorage(0);\\n\\n\\n    /**\\n    * @dev Throws if called by any sender that doesn't match a network contract\\n    */\\n    modifier onlyLatestNetworkContract() {\\n        require(getBool(keccak256(abi.encodePacked(\\\"contract.exists\\\", msg.sender))), \\\"Invalid or outdated network contract\\\");\\n        _;\\n    }\\n\\n\\n    /**\\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\\n    */\\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\\\"contract.address\\\", _contractName))), \\\"Invalid or outdated contract\\\");\\n        _;\\n    }\\n\\n\\n    /**\\n    * @dev Throws if called by any sender that isn't a trusted node\\n    */\\n    modifier onlyTrustedNode(address _nodeAddress) {\\n        require(getBool(keccak256(abi.encodePacked(\\\"node.trusted\\\", _nodeAddress))), \\\"Invalid trusted node\\\");\\n        _;\\n    }\\n    \\n    /**\\n    * @dev Throws if called by any sender that isn't a super node\\n    */\\n    modifier onlySuperNode(address _nodeAddress) {\\n        require(getBool(keccak256(abi.encodePacked(\\\"node.super\\\", _nodeAddress))), \\\"Invalid super node\\\");\\n        _;\\n    }\\n\\n\\n    /**\\n    * @dev Throws if called by any sender that isn't a registered staking pool\\n    */\\n    modifier onlyRegisteredStakingPool(address _stakingPoolAddress) {\\n        require(getBool(keccak256(abi.encodePacked(\\\"stakingpool.exists\\\", _stakingPoolAddress))), \\\"Invalid staking pool\\\");\\n        _;\\n    }\\n\\n\\n    /**\\n    * @dev Throws if called by any account other than the owner.\\n    */\\n    modifier onlyOwner() {\\n        require(roleHas(\\\"owner\\\", msg.sender), \\\"Account is not the owner\\\");\\n        _;\\n    }\\n\\n\\n    /**\\n    * @dev Modifier to scope access to admins\\n    */\\n    modifier onlyAdmin() {\\n        require(roleHas(\\\"admin\\\", msg.sender), \\\"Account is not an admin\\\");\\n        _;\\n    }\\n\\n\\n    /**\\n    * @dev Modifier to scope access to admins\\n    */\\n    modifier onlySuperUser() {\\n        require(roleHas(\\\"owner\\\", msg.sender) || roleHas(\\\"admin\\\", msg.sender), \\\"Account is not a super user\\\");\\n        _;\\n    }\\n\\n\\n    /**\\n    * @dev Reverts if the address doesn't have this role\\n    */\\n    modifier onlyRole(string memory _role) {\\n        require(roleHas(_role, msg.sender), \\\"Account does not match the specified role\\\");\\n        _;\\n    }\\n\\n\\n    /// @dev Set the main Storage address\\n    constructor(address _stafiStorageAddress) {\\n        // Update the contract address\\n        stafiStorage = IStafiStorage(_stafiStorageAddress);\\n    }\\n\\n\\n    /// @dev Get the address of a network contract by name\\n    function getContractAddress(string memory _contractName) internal view returns (address) {\\n        // Get the current contract address\\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\\\"contract.address\\\", _contractName)));\\n        // Check it\\n        require(contractAddress != address(0x0), \\\"Contract not found\\\");\\n        // Return\\n        return contractAddress;\\n    }\\n\\n\\n    /// @dev Get the name of a network contract by address\\n    function getContractName(address _contractAddress) internal view returns (string memory) {\\n        // Get the contract name\\n        string memory contractName = getString(keccak256(abi.encodePacked(\\\"contract.name\\\", _contractAddress)));\\n        // Check it\\n        require(keccak256(abi.encodePacked(contractName)) != keccak256(abi.encodePacked(\\\"\\\")), \\\"Contract not found\\\");\\n        // Return\\n        return contractName;\\n    }\\n\\n\\n    /// @dev Storage get methods\\n    function getAddress(bytes32 _key) internal view returns (address) { return stafiStorage.getAddress(_key); }\\n    function getUint(bytes32 _key) internal view returns (uint256) { return stafiStorage.getUint(_key); }\\n    function getString(bytes32 _key) internal view returns (string memory) { return stafiStorage.getString(_key); }\\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return stafiStorage.getBytes(_key); }\\n    function getBool(bytes32 _key) internal view returns (bool) { return stafiStorage.getBool(_key); }\\n    function getInt(bytes32 _key) internal view returns (int256) { return stafiStorage.getInt(_key); }\\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return stafiStorage.getBytes32(_key); }\\n    function getAddressS(string memory _key) internal view returns (address) { return stafiStorage.getAddress(keccak256(abi.encodePacked(_key))); }\\n    function getUintS(string memory _key) internal view returns (uint256) { return stafiStorage.getUint(keccak256(abi.encodePacked(_key))); }\\n    function getStringS(string memory _key) internal view returns (string memory) { return stafiStorage.getString(keccak256(abi.encodePacked(_key))); }\\n    function getBytesS(string memory _key) internal view returns (bytes memory) { return stafiStorage.getBytes(keccak256(abi.encodePacked(_key))); }\\n    function getBoolS(string memory _key) internal view returns (bool) { return stafiStorage.getBool(keccak256(abi.encodePacked(_key))); }\\n    function getIntS(string memory _key) internal view returns (int256) { return stafiStorage.getInt(keccak256(abi.encodePacked(_key))); }\\n    function getBytes32S(string memory _key) internal view returns (bytes32) { return stafiStorage.getBytes32(keccak256(abi.encodePacked(_key))); }\\n\\n    /// @dev Storage set methods\\n    function setAddress(bytes32 _key, address _value) internal { stafiStorage.setAddress(_key, _value); }\\n    function setUint(bytes32 _key, uint256 _value) internal { stafiStorage.setUint(_key, _value); }\\n    function setString(bytes32 _key, string memory _value) internal { stafiStorage.setString(_key, _value); }\\n    function setBytes(bytes32 _key, bytes memory _value) internal { stafiStorage.setBytes(_key, _value); }\\n    function setBool(bytes32 _key, bool _value) internal { stafiStorage.setBool(_key, _value); }\\n    function setInt(bytes32 _key, int256 _value) internal { stafiStorage.setInt(_key, _value); }\\n    function setBytes32(bytes32 _key, bytes32 _value) internal { stafiStorage.setBytes32(_key, _value); }\\n    function setAddressS(string memory _key, address _value) internal { stafiStorage.setAddress(keccak256(abi.encodePacked(_key)), _value); }\\n    function setUintS(string memory _key, uint256 _value) internal { stafiStorage.setUint(keccak256(abi.encodePacked(_key)), _value); }\\n    function setStringS(string memory _key, string memory _value) internal { stafiStorage.setString(keccak256(abi.encodePacked(_key)), _value); }\\n    function setBytesS(string memory _key, bytes memory _value) internal { stafiStorage.setBytes(keccak256(abi.encodePacked(_key)), _value); }\\n    function setBoolS(string memory _key, bool _value) internal { stafiStorage.setBool(keccak256(abi.encodePacked(_key)), _value); }\\n    function setIntS(string memory _key, int256 _value) internal { stafiStorage.setInt(keccak256(abi.encodePacked(_key)), _value); }\\n    function setBytes32S(string memory _key, bytes32 _value) internal { stafiStorage.setBytes32(keccak256(abi.encodePacked(_key)), _value); }\\n\\n    /// @dev Storage delete methods\\n    function deleteAddress(bytes32 _key) internal { stafiStorage.deleteAddress(_key); }\\n    function deleteUint(bytes32 _key) internal { stafiStorage.deleteUint(_key); }\\n    function deleteString(bytes32 _key) internal { stafiStorage.deleteString(_key); }\\n    function deleteBytes(bytes32 _key) internal { stafiStorage.deleteBytes(_key); }\\n    function deleteBool(bytes32 _key) internal { stafiStorage.deleteBool(_key); }\\n    function deleteInt(bytes32 _key) internal { stafiStorage.deleteInt(_key); }\\n    function deleteBytes32(bytes32 _key) internal { stafiStorage.deleteBytes32(_key); }\\n    function deleteAddressS(string memory _key) internal { stafiStorage.deleteAddress(keccak256(abi.encodePacked(_key))); }\\n    function deleteUintS(string memory _key) internal { stafiStorage.deleteUint(keccak256(abi.encodePacked(_key))); }\\n    function deleteStringS(string memory _key) internal { stafiStorage.deleteString(keccak256(abi.encodePacked(_key))); }\\n    function deleteBytesS(string memory _key) internal { stafiStorage.deleteBytes(keccak256(abi.encodePacked(_key))); }\\n    function deleteBoolS(string memory _key) internal { stafiStorage.deleteBool(keccak256(abi.encodePacked(_key))); }\\n    function deleteIntS(string memory _key) internal { stafiStorage.deleteInt(keccak256(abi.encodePacked(_key))); }\\n    function deleteBytes32S(string memory _key) internal { stafiStorage.deleteBytes32(keccak256(abi.encodePacked(_key))); }\\n\\n\\n    /**\\n    * @dev Check if an address has this role\\n    */\\n    function roleHas(string memory _role, address _address) internal view returns (bool) {\\n        return getBool(keccak256(abi.encodePacked(\\\"access.role\\\", _role, _address)));\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/types/ClaimType.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\n// Represents the type of deposits\\nenum ClaimType {\\n    None,\\n    CLAIMREWARD,\\n    CLAIMDEPOSIT,\\n    CLAIMTOTAL\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stafiStorageAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimableReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimableDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum ClaimType\",\"name\":\"claimType\",\"type\":\"uint8\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dealedHeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"platformAmount\",\"type\":\"uint256\"}],\"name\":\"DistributeFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dealedHeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slashAmount\",\"type\":\"uint256\"}],\"name\":\"DistributeSlash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dealedHeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"platformAmount\",\"type\":\"uint256\"}],\"name\":\"DistributeSuperNodeFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dealedEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"SetMerkleRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dealedEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"SetPlatformTotalAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"VoteProposal\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalRewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalExitDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"enum ClaimType\",\"name\":\"_claimType\",\"type\":\"uint8\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"claimPlatformFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dealedHeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nodeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_platformAmount\",\"type\":\"uint256\"}],\"name\":\"distributeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dealedHeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"distributeSlashAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dealedHeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nodeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_platformAmount\",\"type\":\"uint256\"}],\"name\":\"distributeSuperNodeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeWithdrawals\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentNodeDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDistributeFeeDealedHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDistributeSlashDealedHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDistributeSuperNodeFeeDealedHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMerkleDealedEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformTotalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformTotalClaimedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getTotalClaimedDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getTotalClaimedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiveEtherWithdrawal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dealedEpoch\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dealedEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalAmount\",\"type\":\"uint256\"}],\"name\":\"setPlatformTotalAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"updateMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "StafiDistributor", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006c2f7b6110a37b3b0fbdd811876be368df02e8b0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}