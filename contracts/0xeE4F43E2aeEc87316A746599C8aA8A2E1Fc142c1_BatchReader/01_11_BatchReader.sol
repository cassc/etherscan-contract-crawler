// SPDX-License-Identifier: MIT-BROUGKR
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.16;
import {IERC721} from "@openzeppelin/contracts/interfaces/IERC721.sol";
import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
contract BatchReader 
{
    struct CitizenCity
    {
        string Name;
        address ContractAddress;
        uint StartingTokenID;
        uint EndingTokenID;
    }
    CitizenCity[] CitizenCities;
    mapping(address=>bool) Roles;
    event NewCity(string Name, address ContractAddress, uint StartingTokenID, uint EndingTokenID);
    event ModifiedCity(string Name, address ContractAddress, uint StartingTokenID, uint EndingTokenID);
    constructor()
    {
        Roles[msg.sender] = true; // deployer.brightmoments.eth
        Roles[0x18B7511938FBe2EE08ADf3d4A24edB00A5C9B783] = true; // phil.brightmoments.eth
        Roles[0xB96E81f80b3AEEf65CB6d0E280b15FD5DBE71937] = true; // brightmoments.eth
        CitizenCities.push(CitizenCity('CryptoGalacticans', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 0, 999));
        CitizenCities.push(CitizenCity('CryptoVenetians', 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, 95000000, 95000999));
        CitizenCities.push(CitizenCity('CryptoNewYorkers', 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270, 189000000, 189000999));
        CitizenCities.push(CitizenCity('CryptoBerliners', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 3000000, 3000999));
        CitizenCities.push(CitizenCity('CryptoLondoners', 0xbDdE08BD57e5C9fD563eE7aC61618CB2ECdc0ce0, 4000000, 4000999));
    }

    /*******************
     * ADMIN FUNCTIONS *
     ******************/
    
    /**
     * @dev Adds Citizen City
     */
    function AddCitizenCity(
        string calldata Name,
        address ContractAddress, 
        uint StartingTokenID, 
        uint EndingTokenID
    ) external onlyBRTAdmin {   
        CitizenCities.push(CitizenCity(Name, ContractAddress, StartingTokenID, EndingTokenID));
        emit NewCity(Name, ContractAddress, StartingTokenID, EndingTokenID);
    }

    /**
     * @dev Modifies Citizen City
     */
    function ModifyCitizenCity(
        uint CityNumber, 
        string calldata Name, 
        address ContractAddress, 
        uint StartingTokenID, 
        uint EndingTokenID
    ) external onlyBRTAdmin {
        CitizenCities[CityNumber].Name = Name;
        CitizenCities[CityNumber].ContractAddress = ContractAddress;
        CitizenCities[CityNumber].StartingTokenID = StartingTokenID;
        CitizenCities[CityNumber].EndingTokenID = EndingTokenID;
        emit ModifiedCity(Name, ContractAddress, StartingTokenID, EndingTokenID);
    }

    /******************
     * VIEW FUNCTIONS *
     *****************/

    /**
     * @dev Returns Citizens Owned By Wallet
     */
    function readWalletOwnedCitizens(address Wallet) public view returns(uint[][] memory)
    {
        uint[][] memory Owners = new uint[][](CitizenCities.length);
        for(uint x; x < CitizenCities.length; x++)
        {
            uint Range = CitizenCities[x].EndingTokenID - CitizenCities[x].StartingTokenID + 1;
            IERC721 NFT = IERC721(CitizenCities[x].ContractAddress);
            uint[] memory temp = new uint[](Range);
            uint counter;
            for(uint TokenID = CitizenCities[x].StartingTokenID; TokenID <= CitizenCities[x].EndingTokenID; TokenID++)
            {
                try NFT.ownerOf(TokenID) 
                {
                    if(NFT.ownerOf(TokenID) == Wallet)
                    {
                        temp[counter] = TokenID;
                        counter++;   
                    }
                } catch { }
            }
            uint[] memory FormattedOwnedIDs = new uint[](counter);
            uint index;
            for(uint z; z < counter; z++)
            {
                if(temp[z] != 0 || (z == 0 && temp[z] == 0))
                {
                    FormattedOwnedIDs[index] = temp[z];
                    index++;
                }
            }
            Owners[x] = FormattedOwnedIDs;
        }
        return Owners;
    }

    /**
     * @dev Batch Returns If Wallet Owns Multiple TokenIDs Of Multiple NFTs
     */
    function readNFTsOwnedTokenIDs(
        address Wallet, 
        address[] calldata NFTAddresses, 
        uint Range
    ) public view returns (uint[][] memory) {
        uint[][] memory OwnedIDs = new uint[][](NFTAddresses.length);
        for(uint x; x < NFTAddresses.length; x++)
        {
            IERC721 NFT = IERC721(NFTAddresses[x]);
            uint[] memory temp = new uint[](Range);
            uint counter;
            for(uint y; y <= Range; y++)
            {
                try NFT.ownerOf(y) 
                {
                    if(NFT.ownerOf(y) == Wallet)
                    {
                        temp[counter] = y;
                        counter++;   
                    }
                } catch { }
            }
            uint[] memory FormattedOwnedIDs = new uint[](counter);
            uint index;
            for(uint z; z < counter; z++)
            {
                if(temp[z] != 0 || (z == 0 && temp[z] == 0))
                {
                    FormattedOwnedIDs[index] = temp[z];
                    index++;
                }
            }
            OwnedIDs[x] = FormattedOwnedIDs;
        }
        return OwnedIDs;
    }

    /**
     * @dev Batch Returns Owners Of Collection
     */
    function readNFTOwners(
        address[] calldata NFTAddresses, 
        uint Range
    ) public view returns (address[][] memory) {
        address[][] memory Owners = new address[][](NFTAddresses.length);
        for(uint x; x < NFTAddresses.length; x++)
        {
            IERC721 NFT = IERC721(NFTAddresses[x]);
            address[] memory temp = new address[](Range);
            uint counter;
            for(uint y; y <= Range; y++)
            {
                try NFT.ownerOf(y) 
                {
                    if(NFT.ownerOf(y) != address(0))
                    {
                        temp[counter] = NFT.ownerOf(y);
                        counter++;   
                    }
    
                } 
                catch 
                { 
                    temp[counter] = address(0);
                    counter++;
                }
            }
            address[] memory FormattedOwnedIDs = new address[](counter);
            uint index;
            for(uint z; z < counter; z++)
            {
                if(temp[z] != address(0))
                {
                    FormattedOwnedIDs[index] = temp[z];
                    index++;
                }
            }
            Owners[x] = FormattedOwnedIDs;
        }
        return Owners;
    }

    /**
     * @dev Batch Returns All Citizen Owners
     */
    function readCitizenOwners() public view returns (address[][] memory) {
        address[][] memory Owners = new address[][](CitizenCities.length);
        for(uint CityID; CityID < CitizenCities.length; CityID++)
        {
            uint Range = CitizenCities[CityID].EndingTokenID - CitizenCities[CityID].StartingTokenID + 1;
            IERC721 NFT = IERC721(CitizenCities[CityID].ContractAddress);
            address[] memory temp = new address[](Range);
            uint counter;
            for(uint TokenID = CitizenCities[CityID].StartingTokenID; TokenID <= CitizenCities[CityID].EndingTokenID; TokenID++)
            {
                try NFT.ownerOf(TokenID) 
                {
                    if(NFT.ownerOf(TokenID) != address(0))
                    {
                        temp[counter] = NFT.ownerOf(TokenID);
                        counter++;   
                    }
                } 
                catch 
                { 
                    temp[counter] = address(0);
                    counter++;
                }
            }
            address[] memory FormattedOwnedIDs = new address[](counter);
            uint index;
            for(uint z; z < counter; z++)
            {
                FormattedOwnedIDs[index] = temp[z];
                index++;
            }
            Owners[CityID] = FormattedOwnedIDs;
        }
        return Owners;
    }

    /**
     * @dev Returns Batch Metadata
     */
    function readBatchMetadata(
        address[] calldata ContractAddresses, 
        uint[][] calldata TokenIDs
    ) public view returns(string[][] memory) {
        string[][] memory Metadata = new string[][](TokenIDs.length);
        for(uint ProjectID; ProjectID < ContractAddresses.length; ProjectID++)
        {
            string[] memory ProjectMetadata = new string[](TokenIDs[ProjectID].length);
            for(uint TokenID; TokenID < TokenIDs[ProjectID].length; TokenID++)
            {
                ProjectMetadata[TokenID] = ERC721(ContractAddresses[ProjectID]).tokenURI(TokenIDs[ProjectID][TokenID]);
            }
            Metadata[ProjectID] = ProjectMetadata;
        }
        return Metadata;
    }

    /**
     * @dev Returns Batch Metadata Of Citizens Held By `Wallet`
     */
    function readBatchMetadataCitizens(
        address Wallet
    ) public view returns(string[][] memory) {
        string[][] memory Metadata = new string[][](CitizenCities.length);
        uint[][] memory TokenIDs = readWalletOwnedCitizens(Wallet);
        for(uint ProjectID; ProjectID < CitizenCities.length; ProjectID++)
        {
            string[] memory ProjectMetadata = new string[](TokenIDs[ProjectID].length);
            for(uint TokenID; TokenID < TokenIDs[ProjectID].length; TokenID++)
            {
                ProjectMetadata[TokenID] = ERC721(CitizenCities[ProjectID].ContractAddress).tokenURI(TokenIDs[ProjectID][TokenID]);
            }
            Metadata[ProjectID] = ProjectMetadata;
        }
        return Metadata;
    }

    /**
     * @dev BRT Admin Modifier
     */
    modifier onlyBRTAdmin
    {
        require(Roles[msg.sender]);
        _;
    }
}