{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/D4AUniversalClaimer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.10;\\n\\nimport { ID4AProtocolReadable } from \\\"contracts/interface/ID4AProtocolReadable.sol\\\";\\nimport { ID4AProtocol } from \\\"contracts/interface/ID4AProtocol.sol\\\";\\n\\ncontract D4AUniversalClaimer {\\n    struct ClaimMultiRewardParam {\\n        address protocol;\\n        bytes32[] canvasIds;\\n        bytes32[] daoIds;\\n    }\\n\\n    function claimMultiReward(ClaimMultiRewardParam[] calldata params) public returns (uint256 tokenAmount) {\\n        for (uint256 i; i < params.length;) {\\n            for (uint256 j; j < params[i].canvasIds.length;) {\\n                tokenAmount += ID4AProtocol(params[i].protocol).claimCanvasReward(params[i].canvasIds[j]);\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n            for (uint256 j; j < params[i].daoIds.length;) {\\n                tokenAmount += ID4AProtocol(params[i].protocol).claimProjectERC20Reward(params[i].daoIds[j]);\\n                tokenAmount += ID4AProtocol(params[i].protocol).claimNftMinterReward(params[i].daoIds[j], msg.sender);\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return tokenAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ID4AProtocolReadable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport { RewardStorage } from \\\"contracts/storages/RewardStorage.sol\\\";\\n\\ninterface ID4AProtocolReadable {\\n    // legacy functions\\n    function getProjectCanvasAt(bytes32 daoId, uint256 index) external view returns (bytes32);\\n\\n    function getProjectInfo(bytes32 daoId)\\n        external\\n        view\\n        returns (\\n            uint256 startRound,\\n            uint256 mintableRound,\\n            uint256 maxNftAmount,\\n            address daoFeePool,\\n            uint96 royaltyFeeRatioInBps,\\n            uint256 index,\\n            string memory daoUri,\\n            uint256 erc20TotalSupply\\n        );\\n\\n    function getProjectFloorPrice(bytes32 daoId) external view returns (uint256);\\n\\n    function getProjectTokens(bytes32 daoId) external view returns (address token, address nft);\\n\\n    function getCanvasNFTCount(bytes32 canvasId) external view returns (uint256);\\n\\n    function getTokenIDAt(bytes32 canvasId, uint256 index) external view returns (uint256);\\n\\n    function getCanvasProject(bytes32 canvasId) external view returns (bytes32);\\n\\n    function getCanvasURI(bytes32 canvasId) external view returns (string memory);\\n\\n    function getProjectCanvasCount(bytes32 daoId) external view returns (uint256);\\n\\n    // new functions\\n    // DAO related functions\\n    function getDaoStartRound(bytes32 daoId) external view returns (uint256 startRound);\\n\\n    function getDaoMintableRound(bytes32 daoId) external view returns (uint256 mintableRound);\\n\\n    function getDaoIndex(bytes32 daoId) external view returns (uint256 index);\\n\\n    function getDaoUri(bytes32 daoId) external view returns (string memory daoUri);\\n\\n    function getDaoFeePool(bytes32 daoId) external view returns (address daoFeePool);\\n\\n    function getDaoToken(bytes32 daoId) external view returns (address token);\\n\\n    function getDaoTokenMaxSupply(bytes32 daoId) external view returns (uint256 tokenMaxSupply);\\n\\n    function getDaoNft(bytes32 daoId) external view returns (address nft);\\n\\n    function getDaoNftMaxSupply(bytes32 daoId) external view returns (uint256 nftMaxSupply);\\n\\n    function getDaoNftTotalSupply(bytes32 daoId) external view returns (uint256 nftTotalSupply);\\n\\n    function getDaoNftRoyaltyFeeRatioInBps(bytes32 daoId) external view returns (uint96 royaltyFeeRatioInBps);\\n\\n    function getDaoExist(bytes32 daoId) external view returns (bool);\\n\\n    function getDaoCanvases(bytes32 daoId) external view returns (bytes32[] memory canvases);\\n\\n    function getDaoPriceTemplate(bytes32 daoId) external view returns (address priceTemplate);\\n\\n    function getDaoPriceFactor(bytes32 daoId) external view returns (uint256 priceFactor);\\n\\n    function getDaoRewardTemplate(bytes32 daoId) external view returns (address rewardTemplate);\\n\\n    function getDaoMintCap(bytes32 daoId) external view returns (uint32);\\n\\n    function getUserMintInfo(\\n        bytes32 daoId,\\n        address account\\n    )\\n        external\\n        view\\n        returns (uint32 minted, uint32 userMintCap);\\n\\n    function getDaoFeePoolETHRatio(bytes32 daoId) external view returns (uint256);\\n\\n    function getDaoFeePoolETHRatioFlatPrice(bytes32 daoId) external view returns (uint256);\\n\\n    // canvas related functions\\n    function getCanvasDaoId(bytes32 canvasId) external view returns (bytes32 daoId);\\n\\n    function getCanvasTokenIds(bytes32 canvasId) external view returns (uint256[] memory tokenIds);\\n\\n    function getCanvasIndex(bytes32 canvasId) external view returns (uint256);\\n\\n    function getCanvasUri(bytes32 canvasId) external view returns (string memory canvasUri);\\n\\n    function getCanvasRebateRatioInBps(bytes32 canvasId) external view returns (uint256 rebateRatioInBps);\\n\\n    function getCanvasExist(bytes32 canvasId) external view returns (bool);\\n\\n    // prices related functions\\n    function getCanvasLastPrice(bytes32 canvasId) external view returns (uint256 round, uint256 price);\\n\\n    function getCanvasNextPrice(bytes32 canvasId) external view returns (uint256 price);\\n\\n    function getDaoMaxPriceInfo(bytes32 daoId) external view returns (uint256 round, uint256 price);\\n\\n    function getDaoFloorPrice(bytes32 daoId) external view returns (uint256 floorPrice);\\n\\n    // reward related functions\\n    function getDaoRewardStartRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 startRound);\\n\\n    function getDaoRewardTotalRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 totalRound);\\n\\n    function getDaoTotalReward(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 totalReward);\\n\\n    function getDaoRewardDecayFactor(bytes32 daoId) external view returns (uint256 rewardDecayFactor);\\n\\n    function getDaoRewardIsProgressiveJackpot(bytes32 daoId) external view returns (bool isProgressiveJackpot);\\n\\n    function getDaoRewardLastActiveRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256 lastActiveRound);\\n\\n    function getDaoRewardActiveRounds(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointIndex\\n    )\\n        external\\n        view\\n        returns (uint256[] memory activeRounds);\\n\\n    function getDaoCreatorClaimableRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointsIndex\\n    )\\n        external\\n        view\\n        returns (uint256 claimableRound);\\n\\n    function getCanvasCreatorClaimableRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointsIndex,\\n        bytes32 canvasId\\n    )\\n        external\\n        view\\n        returns (uint256 claimableRound);\\n\\n    function getNftMinterClaimableRound(\\n        bytes32 daoId,\\n        uint256 rewardCheckpointsIndex,\\n        address nftMinter\\n    )\\n        external\\n        view\\n        returns (uint256 claimableRound);\\n\\n    function getTotalWeight(bytes32 daoId, uint256 round) external view returns (uint256 totalWeight);\\n\\n    function getProtocolWeight(bytes32 daoId, uint256 round) external view returns (uint256 protocolWeight);\\n\\n    function getDaoCreatorWeight(bytes32 daoId, uint256 round) external view returns (uint256 creatorWeight);\\n\\n    function getCanvasCreatorWeight(\\n        bytes32 daoId,\\n        uint256 round,\\n        bytes32 canvasId\\n    )\\n        external\\n        view\\n        returns (uint256 creatorWeight);\\n\\n    function getNftMinterWeight(\\n        bytes32 daoId,\\n        uint256 round,\\n        address nftMinter\\n    )\\n        external\\n        view\\n        returns (uint256 minterWeight);\\n\\n    function getDaoCreatorERC20Ratio(bytes32 daoId) external view returns (uint256 ratioInBps);\\n\\n    function getCanvasCreatorERC20Ratio(bytes32 daoId) external view returns (uint256 ratioInBps);\\n\\n    function getNftMinterERC20Ratio(bytes32 daoId) external view returns (uint256 ratioInBps);\\n\\n    function getRoundReward(bytes32 daoId, uint256 round) external view returns (uint256);\\n\\n    function getRewardTillRound(bytes32 daoId, uint256 round) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ID4AProtocol.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport { DaoMetadataParam, UserMintCapParam, TemplateParam } from \\\"./D4AStructs.sol\\\";\\nimport { IPermissionControl } from \\\"contracts/interface/IPermissionControl.sol\\\";\\n\\ninterface ID4AProtocol {\\n    event NewProject(\\n        bytes32 daoId, string daoUri, address daoFeePool, address token, address nft, uint256 royaltyFeeRatioInBps\\n    );\\n\\n    event NewCanvas(bytes32 daoId, bytes32 canvasId, string canvasUri);\\n\\n    event D4AMintNFT(bytes32 daoId, bytes32 canvasId, uint256 tokenId, string tokenUri, uint256 price);\\n\\n    event D4AClaimProjectERC20Reward(bytes32 daoId, address token, uint256 amount);\\n\\n    event D4AClaimCanvasReward(bytes32 daoId, bytes32 canvasId, address token, uint256 amount);\\n\\n    event D4AClaimNftMinterReward(bytes32 daoId, address token, uint256 amount);\\n\\n    event D4AExchangeERC20ToETH(bytes32 daoId, address owner, address to, uint256 tokenAmount, uint256 ethAmount);\\n\\n    function createProject(\\n        uint256 startRound,\\n        uint256 mintableRound,\\n        uint256 daoFloorPriceRank,\\n        uint256 maxNftRank,\\n        uint96 royaltyFeeRatioInBps,\\n        string memory daoUri\\n    )\\n        external\\n        payable\\n        returns (bytes32 daoId);\\n\\n    function createOwnerProject(DaoMetadataParam calldata daoMetadata) external payable returns (bytes32 daoId);\\n\\n    function claimProjectERC20Reward(bytes32 daoId) external returns (uint256);\\n\\n    function claimCanvasReward(bytes32 canvasId) external returns (uint256);\\n\\n    function claimNftMinterReward(bytes32 daoId, address minter) external returns (uint256);\\n\\n    function exchangeERC20ToETH(bytes32 daoId, uint256 amount, address to) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/storages/RewardStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nlibrary RewardStorage {\\n    struct RewardCheckpoint {\\n        uint256 startRound;\\n        uint256 totalRound;\\n        uint256 totalReward;\\n        uint256 lastActiveRound; // deprecated\\n        uint256[] activeRounds;\\n        // claimable round index\\n        uint256 daoCreatorClaimableRoundIndex;\\n        mapping(bytes32 canvasId => uint256 claimableRoundIndex) canvasCreatorClaimableRoundIndexes;\\n        mapping(address nftMinter => uint256 claimableRoundIndex) nftMinterClaimableRoundIndexes;\\n    }\\n\\n    struct RewardInfo {\\n        RewardCheckpoint[] rewardCheckpoints;\\n        uint256 rewardIssuePendingRound;\\n        uint256 rewardDecayFactor;\\n        bool isProgressiveJackpot;\\n        // weights\\n        mapping(uint256 round => uint256 totalWeight) totalWeights; // also total ETH in DAO fee pool at given round\\n        mapping(uint256 round => uint256 weight) protocolWeights;\\n        mapping(uint256 round => uint256 weight) daoCreatorWeights;\\n        mapping(uint256 round => mapping(bytes32 canvasId => uint256 weight)) canvasCreatorWeights;\\n        mapping(uint256 round => mapping(address nftMinter => uint256 weight)) nftMinterWeights;\\n        uint256 daoCreatorERC20RatioInBps;\\n        uint256 canvasCreatorERC20RatioInBps;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 daoId => RewardInfo rewardInfo) rewardInfos;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"D4Av2.contracts.storage.RewardStorage\\\");\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/D4AStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport { PriceTemplateType, RewardTemplateType } from \\\"./D4AEnums.sol\\\";\\n\\nstruct DaoMetadataParam {\\n    uint256 startDrb;\\n    uint256 mintableRounds;\\n    uint256 floorPriceRank;\\n    uint256 maxNftRank;\\n    uint96 royaltyFee;\\n    string projectUri;\\n    uint256 projectIndex;\\n}\\n\\nstruct DaoMintInfo {\\n    uint32 daoMintCap;\\n    mapping(address minter => UserMintInfo) userMintInfos;\\n}\\n\\nstruct UserMintInfo {\\n    uint32 minted;\\n    uint32 mintCap;\\n}\\n\\nstruct DaoMintCapParam {\\n    uint32 daoMintCap;\\n    UserMintCapParam[] userMintCapParams;\\n}\\n\\nstruct UserMintCapParam {\\n    address minter;\\n    uint32 mintCap;\\n}\\n\\nstruct DaoETHAndERC20SplitRatioParam {\\n    uint256 daoCreatorERC20Ratio;\\n    uint256 canvasCreatorERC20Ratio;\\n    uint256 nftMinterERC20Ratio;\\n    uint256 daoFeePoolETHRatio;\\n    uint256 daoFeePoolETHRatioFlatPrice;\\n}\\n\\nstruct TemplateParam {\\n    PriceTemplateType priceTemplateType;\\n    uint256 priceFactor;\\n    RewardTemplateType rewardTemplateType;\\n    uint256 rewardDecayFactor;\\n    bool isProgressiveJackpot;\\n}\\n\\nstruct UpdateRewardParam {\\n    bytes32 daoId;\\n    bytes32 canvasId;\\n    address token;\\n    uint256 startRound;\\n    uint256 currentRound;\\n    uint256 totalRound;\\n    uint256 daoFeeAmount;\\n    uint256 protocolERC20RatioInBps;\\n    uint256 daoCreatorERC20RatioInBps;\\n    uint256 canvasCreatorERC20RatioInBps;\\n    uint256 nftMinterERC20RatioInBps;\\n    uint256 canvasRebateRatioInBps;\\n}\\n\\nstruct MintNftInfo {\\n    string tokenUri;\\n    uint256 flatPrice;\\n}\\n\\nstruct MintVars {\\n    uint256 price;\\n    uint256 daoTotalShare;\\n    uint256 totalPrice;\\n    uint256 daoFee;\\n    bool needUpdatePrice;\\n}\\n\\nstruct Blacklist {\\n    address[] minterAccounts;\\n    address[] canvasCreatorAccounts;\\n}\\n\\nstruct Whitelist {\\n    bytes32 minterMerkleRoot;\\n    address[] minterNFTHolderPasses;\\n    bytes32 canvasCreatorMerkleRoot;\\n    address[] canvasCreatorNFTHolderPasses;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPermissionControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.10;\\n\\nimport { Whitelist, Blacklist } from \\\"contracts/interface/D4AStructs.sol\\\";\\nimport { ID4AOwnerProxy } from \\\"contracts/interface/ID4AOwnerProxy.sol\\\";\\n\\ninterface IPermissionControl {\\n    event MinterBlacklisted(bytes32 indexed daoId, address indexed account);\\n\\n    event CanvasCreatorBlacklisted(bytes32 indexed daoId, address indexed account);\\n\\n    event MinterUnBlacklisted(bytes32 indexed daoId, address indexed account);\\n\\n    event CanvasCreatorUnBlacklisted(bytes32 indexed daoId, address indexed account);\\n\\n    event WhitelistModified(bytes32 indexed daoId, Whitelist whitelist);\\n\\n    function getWhitelist(bytes32 daoId) external view returns (Whitelist calldata whitelist);\\n\\n    function addPermissionWithSignature(\\n        bytes32 daoId,\\n        Whitelist calldata whitelist,\\n        Blacklist calldata blacklist,\\n        bytes calldata signature\\n    )\\n        external;\\n\\n    function addPermission(bytes32 daoId, Whitelist calldata whitelist, Blacklist calldata blacklist) external;\\n\\n    function modifyPermission(\\n        bytes32 daoId,\\n        Whitelist calldata whitelist,\\n        Blacklist calldata blacklist,\\n        Blacklist calldata unblacklist\\n    )\\n        external;\\n\\n    function isMinterBlacklisted(bytes32 daoId, address _account) external view returns (bool);\\n\\n    function isCanvasCreatorBlacklisted(bytes32 daoId, address _account) external view returns (bool);\\n\\n    function inMinterWhitelist(\\n        bytes32 daoId,\\n        address _account,\\n        bytes32[] calldata _proof\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    function inCanvasCreatorWhitelist(\\n        bytes32 daoId,\\n        address _account,\\n        bytes32[] calldata _proof\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    function setOwnerProxy(ID4AOwnerProxy _ownerProxy) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/D4AEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nenum PriceTemplateType {\\n    EXPONENTIAL_PRICE_VARIATION,\\n    LINEAR_PRICE_VARIATION\\n}\\n\\nenum RewardTemplateType {\\n    LINEAR_REWARD_ISSUANCE,\\n    EXPONENTIAL_REWARD_ISSUANCE\\n}\\n\\nenum TemplateChoice {\\n    PRICE,\\n    REWARD\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ID4AOwnerProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.10;\\n\\ninterface ID4AOwnerProxy {\\n    function ownerOf(bytes32 hash) external view returns (address);\\n    function initOwnerOf(bytes32 hash, address addr) external returns (bool);\\n    function transferOwnership(bytes32 hash, address newOwner) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@chainlink/=node_modules/@chainlink/\",\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@solidstate/=node_modules/@solidstate/\",\r\n      \"@uniswap/=node_modules/@uniswap/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/solady:ds-test/=lib/solady/lib/ds-test/src/\",\r\n      \"lib/solady:forge-std/=lib/solady/test/utils/forge-std/\",\r\n      \"lib/solmate:ds-test/=lib/solmate/lib/ds-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"canvasIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"daoIds\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct D4AUniversalClaimer.ClaimMultiRewardParam[]\",\"name\":\"params\",\"type\":\"tuple[]\"}],\"name\":\"claimMultiReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "D4AUniversalClaimer", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}