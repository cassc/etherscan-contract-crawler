{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/infiniteProxy/IProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IProxy {\\n    function setAdmin(address newAdmin_) external;\\n\\n    function setDummyImplementation(address newDummyImplementation_) external;\\n\\n    function addImplementation(address implementation_, bytes4[] calldata sigs_)\\n        external;\\n\\n    function removeImplementation(address implementation_) external;\\n\\n    function getAdmin() external view returns (address);\\n\\n    function getDummyImplementation() external view returns (address);\\n\\n    function getImplementationSigs(address impl_)\\n        external\\n        view\\n        returns (bytes4[] memory);\\n\\n    function getSigsImplementation(bytes4 sig_) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/vault/common/helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./variablesBufferHelper.sol\\\";\\nimport \\\"../../infiniteProxy/IProxy.sol\\\";\\nimport {TickMath} from \\\"./tickmath.sol\\\";\\nimport \\\"./interfaces.sol\\\";\\n\\ncontract Helpers is VariablesBufferHelper {\\n    struct ProtocolAssetsInStETH {\\n        uint256 stETH; // supply\\n        uint256 wETH; // borrow\\n    }\\n\\n    struct ProtocolAssetsInWstETH {\\n        uint256 wstETH; // supply\\n        uint256 wETH; // borrow\\n    }\\n\\n    struct IdealBalances {\\n        uint256 stETH;\\n        uint256 wstETH;\\n        uint256 wETH;\\n    }\\n\\n    struct NetAssetsHelper {\\n        ProtocolAssetsInStETH aaveV2;\\n        ProtocolAssetsInWstETH aaveV3;\\n        ProtocolAssetsInWstETH compoundV3;\\n        ProtocolAssetsInWstETH euler;\\n        ProtocolAssetsInStETH morphoAaveV2;\\n        ProtocolAssetsInWstETH morphoAaveV3;\\n        ProtocolAssetsInWstETH spark;\\n        ProtocolAssetsInWstETH fluid;\\n        IdealBalances vaultBalances;\\n        IdealBalances dsaBalances;\\n    }\\n\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\n        z = ((x * y) + RAY / 2) / RAY;\\n    }\\n\\n    /// @dev Executes the ray-based multiplication of 2 numbers, rounded down.\\n    /// @param x Ray.\\n    /// @param y Ray.\\n    /// @return z The result of x * y, in ray.\\n    function rayMulDown(\\n        uint256 x,\\n        uint256 y\\n    ) internal pure returns (uint256 z) {\\n        // Load the state variable into a local variable so it can be accessed to inline assembly\\n        uint256 maxUint = MAX_UINT256;\\n        // Overflow if\\n        //     x * y > type(uint256).max\\n        // <=> y > 0 and x > type(uint256).max / y\\n        assembly {\\n            if mul(y, gt(x, div(maxUint, y))) {\\n                revert(0, 0)\\n            }\\n\\n            z := div(mul(x, y), RAY)\\n        }\\n    }\\n\\n    /// @dev Executes the ray-based multiplication of 2 numbers, rounded up.\\n    /// @param x Ray.\\n    /// @param y Wad.\\n    /// @return z The result of x * y, in ray.\\n    function rayMulUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        uint256 maxUintMinusRayMinusOne = MAX_UINT256_MINUS_RAY_MINUS_ONE;\\n        uint256 rayMinusOne = RAY_MINUS_ONE;\\n        // Overflow if\\n        //     x * y + RAY_MINUS_ONE > type(uint256).max\\n        // <=> x * y > type(uint256).max - RAY_MINUS_ONE\\n        // <=> y > 0 and x > (type(uint256).max - RAY_MINUS_ONE) / y\\n        assembly {\\n            if mul(y, gt(x, div(maxUintMinusRayMinusOne, y))) {\\n                revert(0, 0)\\n            }\\n\\n            z := div(add(mul(x, y), rayMinusOne), RAY)\\n        }\\n    }\\n\\n    /// Returns ratio of Aave V2 in terms of `WETH` and `STETH`.\\n    function getRatioAaveV2()\\n        public\\n        view\\n        returns (uint256 stEthAmount_, uint256 ethAmount_, uint256 ratio_)\\n    {\\n        stEthAmount_ = IERC20(A_STETH_ADDRESS).balanceOf(address(vaultDSA));\\n        ethAmount_ = IERC20(D_WETH_ADDRESS).balanceOf(address(vaultDSA));\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// @param stEthPerWsteth_ Amount of stETH for one wstETH.\\n    /// `stEthPerWsteth_` can be sent as 0 and it will internally calculate the conversion rate.\\n    /// This is done to save on gas by removing conversion rate calculation for each protocol.\\n    /// Returns ratio of Aave V3 in terms of `WETH` and `STETH`.\\n    function getRatioAaveV3(\\n        uint256 stEthPerWsteth_\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 wstEthAmount_,\\n            uint256 stEthAmount_,\\n            uint256 ethAmount_,\\n            uint256 ratio_\\n        )\\n    {\\n        wstEthAmount_ = IERC20(A_WSTETH_ADDRESS_AAVEV3).balanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        if (stEthPerWsteth_ > 0) {\\n            // Convert wstETH collateral balance to stETH.\\n            stEthAmount_ = (wstEthAmount_ * stEthPerWsteth_) / 1e18;\\n        } else {\\n            stEthAmount_ = WSTETH_CONTRACT.getStETHByWstETH(wstEthAmount_);\\n        }\\n        ethAmount_ = IERC20(D_WETH_ADDRESS_AAVEV3).balanceOf(address(vaultDSA));\\n\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// @param stEthPerWsteth_ Amount of stETH for one wstETH.\\n    /// `stEthPerWsteth_` can be sent as 0 and it will internally calculate the conversion rate.\\n    /// This is done to save on gas by removing conversion rate calculation for each protocol.\\n    /// Returns ratio of Compound V3 in terms of `ETH` and `STETH`.\\n    function getRatioCompoundV3(\\n        uint256 stEthPerWsteth_\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 wstEthAmount_,\\n            uint256 stEthAmount_,\\n            uint256 ethAmount_,\\n            uint256 ratio_\\n        )\\n    {\\n        ethAmount_ = COMP_ETH_MARKET_CONTRACT.borrowBalanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        ICompoundMarket.UserCollateral\\n            memory collateralData_ = COMP_ETH_MARKET_CONTRACT.userCollateral(\\n                address(vaultDSA),\\n                WSTETH_ADDRESS\\n            );\\n\\n        wstEthAmount_ = uint256(collateralData_.balance);\\n\\n        if (stEthPerWsteth_ > 0) {\\n            // Convert wstETH collateral balance to stETH.\\n            stEthAmount_ = (wstEthAmount_ * stEthPerWsteth_) / 1e18;\\n        } else {\\n            stEthAmount_ = WSTETH_CONTRACT.getStETHByWstETH(wstEthAmount_);\\n        }\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// @param stEthPerWsteth_ Amount of stETH for one wstETH.\\n    /// `stEthPerWsteth_` can be sent as 0 and it will internally calculate the conversion rate.\\n    /// This is done to save on gas by removing conversion rate calculation for each protocol.\\n    /// Returns ratio of Euler in terms of `ETH` and `STETH`.\\n    function getRatioEuler(\\n        uint256 stEthPerWsteth_\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 wstEthAmount_,\\n            uint256 stEthAmount_,\\n            uint256 ethAmount_,\\n            uint256 ratio_\\n        )\\n    {\\n        wstEthAmount_ = 0;\\n        stEthAmount_ = 0;\\n        ethAmount_ = 0;\\n        ratio_ = 0;\\n\\n        // wstEthAmount_ = IEulerTokens(E_WSTETH_ADDRESS).balanceOfUnderlying(\\n        //     address(vaultDSA)\\n        // );\\n\\n        // if (stEthPerWsteth_ > 0) {\\n        //     // Convert wstETH collateral balance to stETH.\\n        //     stEthAmount_ = (wstEthAmount_ * stEthPerWsteth_) / 1e18;\\n        // } else {\\n        //     stEthAmount_ = WSTETH_CONTRACT.getStETHByWstETH(wstEthAmount_);\\n        // }\\n        // ethAmount_ = IEulerTokens(D_WETH_ADDRESS_EULER).balanceOf(\\n        //     address(vaultDSA)\\n        // );\\n\\n        // ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// Returns ratio of Morpho Aave in terms of `ETH` and `STETH`.\\n    function getRatioMorphoAaveV2()\\n        public\\n        view\\n        returns (\\n            uint256 stEthAmount_, // Aggreagted value of stETH in Pool and P2P\\n            uint256 stEthAmountPool_,\\n            uint256 stEthAmountP2P_,\\n            uint256 ethAmount_, // Aggreagted value of eth in Pool and P2P\\n            uint256 ethAmountPool_,\\n            uint256 ethAmountP2P_,\\n            uint256 ratio_\\n        )\\n    {\\n        // `supplyBalanceInOf` => The supply balance of a user. aToken -> user -> balances.\\n        IMorphoAaveV2.SupplyBalance memory supplyBalanceSteth_ = MORPHO_CONTRACT\\n            .supplyBalanceInOf(A_STETH_ADDRESS, address(vaultDSA));\\n\\n        // For a given market, the borrow balance of a user. aToken -> user -> balances.\\n        IMorphoAaveV2.BorrowBalance memory borrowBalanceWeth_ = MORPHO_CONTRACT\\n            .borrowBalanceInOf(\\n                A_WETH_ADDRESS, // aToken is used in mapping\\n                address(vaultDSA)\\n            );\\n\\n        stEthAmountPool_ = rmul(\\n            supplyBalanceSteth_.onPool,\\n            (MORPHO_CONTRACT.poolIndexes(A_STETH_ADDRESS).poolSupplyIndex)\\n        );\\n\\n        stEthAmountP2P_ = rmul(\\n            supplyBalanceSteth_.inP2P,\\n            MORPHO_CONTRACT.p2pSupplyIndex(A_STETH_ADDRESS)\\n        );\\n\\n        // Supply balance = (pool supply * pool supply index) + (p2p supply * p2p supply index)\\n        stEthAmount_ = stEthAmountPool_ + stEthAmountP2P_;\\n\\n        ethAmountPool_ = rmul(\\n            borrowBalanceWeth_.onPool,\\n            (MORPHO_CONTRACT.poolIndexes(A_WETH_ADDRESS).poolBorrowIndex)\\n        );\\n\\n        ethAmountP2P_ = rmul(\\n            borrowBalanceWeth_.inP2P,\\n            (MORPHO_CONTRACT.p2pBorrowIndex(A_WETH_ADDRESS))\\n        );\\n\\n        // Borrow balance = (pool borrow * pool borrow index) + (p2p borrow * p2p borrow index)\\n        ethAmount_ = ethAmountPool_ + ethAmountP2P_;\\n\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// @notice Returns the borrow balance in underlying in a given market.\\n    /// @param underlying_ The address of the underlying asset.\\n    /// @return totalBalance_ The total balance of the user (in underlying). Includes pool and P2P amounts.\\n    function borrowBalanceMorphoAaveV3(\\n        address underlying_\\n    ) public view returns (uint256 totalBalance_) {\\n        IMorphoAaveV3.Indexes256 memory indexes_ = MORPHO_AAVE_V3\\n            .updatedIndexes(underlying_);\\n\\n        uint256 borrowedBalanceP2P_ = rayMulUp(\\n            MORPHO_AAVE_V3.scaledP2PBorrowBalance(\\n                underlying_,\\n                address(vaultDSA)\\n            ),\\n            indexes_.borrow.p2pIndex\\n        );\\n\\n        uint256 borrowedBalancePool_ = rayMulUp(\\n            MORPHO_AAVE_V3.scaledPoolBorrowBalance(\\n                underlying_,\\n                address(vaultDSA)\\n            ),\\n            indexes_.borrow.poolIndex\\n        );\\n\\n        // Includes Pool and P2P amounts.\\n        totalBalance_ = borrowedBalanceP2P_ + borrowedBalancePool_;\\n    }\\n\\n    /// @notice Returns the supply collateral balance on the `underlying` market (in underlying).\\n    /// @param underlying_ The address of the underlying asset.\\n    function collateralBalanceMorphoAaveV3(\\n        address underlying_\\n    ) public view returns (uint256 collateralBalance_) {\\n        IMorphoAaveV3.Indexes256 memory indexes_ = MORPHO_AAVE_V3\\n            .updatedIndexes(underlying_);\\n\\n        collateralBalance_ = rayMulDown(\\n            MORPHO_AAVE_V3.scaledCollateralBalance(\\n                underlying_,\\n                address(vaultDSA)\\n            ),\\n            indexes_.supply.poolIndex\\n        );\\n    }\\n\\n    /// @param stEthPerWsteth_ Amount of stETH for one wstETH.\\n    /// `stEthPerWsteth_` can be sent as 0 and it will internally calculate the conversion rate.\\n    /// This is done to save on gas by removing conversion rate calculation for each protocol.\\n    /// Returns ratio of Morpho Aave V3 in terms of `WETH` and `STETH`.\\n    function getRatioMorphoAaveV3(\\n        uint256 stEthPerWsteth_\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 wstEthAmount_,\\n            uint256 stEthAmount_,\\n            uint256 ethAmount_,\\n            uint256 ratio_\\n        )\\n    {\\n        wstEthAmount_ = collateralBalanceMorphoAaveV3(WSTETH_ADDRESS);\\n\\n        if (stEthPerWsteth_ > 0) {\\n            // Convert wstETH collateral balance to stETH.\\n            stEthAmount_ = (wstEthAmount_ * stEthPerWsteth_) / 1e18;\\n        } else {\\n            stEthAmount_ = WSTETH_CONTRACT.getStETHByWstETH(wstEthAmount_);\\n        }\\n        ethAmount_ = borrowBalanceMorphoAaveV3(WETH_ADDRESS);\\n\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// @param stEthPerWsteth_ Amount of stETH for one wstETH.\\n    /// `stEthPerWsteth_` can be sent as 0 and it will internally calculate the conversion rate.\\n    /// This is done to save on gas by removing conversion rate calculation for each protocol.\\n    /// Returns ratio of Spark in terms of `WETH` and `STETH`.\\n    function getRatioSpark(\\n        uint256 stEthPerWsteth_\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 wstEthAmount_,\\n            uint256 stEthAmount_,\\n            uint256 ethAmount_,\\n            uint256 ratio_\\n        )\\n    {\\n        wstEthAmount_ = IERC20(SP_WSTETH_ADDRESS_SPARK).balanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        if (stEthPerWsteth_ > 0) {\\n            // Convert wstETH collateral balance to stETH.\\n            stEthAmount_ = (wstEthAmount_ * stEthPerWsteth_) / 1e18;\\n        } else {\\n            stEthAmount_ = WSTETH_CONTRACT.getStETHByWstETH(wstEthAmount_);\\n        }\\n        ethAmount_ = IERC20(D_WETH_ADDRESS_SPARK).balanceOf(address(vaultDSA));\\n\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping\\n    function calculateStorageSlotUintMapping(\\n        uint256 slot_,\\n        uint256 key_\\n    ) private pure returns (bytes32) {\\n        return keccak256(abi.encode(key_, slot_));\\n    }\\n\\n    /// @param stEthPerWsteth_ Amount of stETH for one wstETH.\\n    /// `stEthPerWsteth_` can be sent as 0 and it will internally calculate the conversion rate.\\n    /// This is done to save on gas by removing conversion rate calculation for each protocol.\\n    /// Returns ratio of Fluid in terms of `ETH` and `STETH`.\\n    function getRatioFluid(\\n        uint256 stEthPerWsteth_\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 wstEthAmount_,\\n            uint256 stEthAmount_,\\n            uint256 ethAmount_,\\n            uint256 ratio_\\n        )\\n    {\\n        uint256 positionData_ = FLUID_VAULT.readFromStorage(\\n            calculateStorageSlotUintMapping(3, FLUID_NFT_ID)\\n        );\\n\\n        bool isSupplyPosition_ = (positionData_ & 1) == 1;\\n\\n        wstEthAmount_ = (positionData_ >> 45) & X64;\\n        wstEthAmount_ = (wstEthAmount_ >> 8) << (wstEthAmount_ & X8);\\n\\n        if (!isSupplyPosition_) {\\n            uint256 dustBorrow_ = (positionData_ >> 109) & X64;\\n            // Converting big number into normal number\\n            dustBorrow_ = (dustBorrow_ >> 8) << (dustBorrow_ & X8);\\n\\n            int tick_ = (positionData_ & 2) == 2\\n                ? int((positionData_ >> 2) & X19)\\n                : -int((positionData_ >> 2) & X19);\\n\\n            ethAmount_ = (TickMath.getRatioAtTick(tick_) * wstEthAmount_) >> 96;\\n\\n            ethAmount_ = ethAmount_ - dustBorrow_;\\n        }\\n\\n        (\\n            ,\\n            ,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        ) = FLUID_VAULT.updateExchangePrices(\\n                FLUID_VAULT.readFromStorage(bytes32(uint256(1)))\\n            );\\n\\n        wstEthAmount_ = (wstEthAmount_ * vaultSupplyExPrice_) / 1e12;\\n        ethAmount_ = (ethAmount_ * vaultBorrowExPrice_) / 1e12;\\n\\n        if (stEthPerWsteth_ > 0) {\\n            // Convert wstETH collateral balance to stETH.\\n            stEthAmount_ = (wstEthAmount_ * stEthPerWsteth_) / 1e18;\\n        } else {\\n            stEthAmount_ = WSTETH_CONTRACT.getStETHByWstETH(wstEthAmount_);\\n        }\\n\\n        ratio_ = stEthAmount_ == 0 ? 0 : (ethAmount_ * 1e6) / stEthAmount_;\\n    }\\n\\n    function getProtocolRatio(\\n        uint8 protocolId_\\n    ) public view returns (uint256 ratio_) {\\n        if (protocolId_ == 1) {\\n            // stETH based protocol\\n            (, , ratio_) = getRatioAaveV2();\\n        } else if (protocolId_ == 2) {\\n            // wstETH based protocol\\n            uint256 stEthPerWsteth_ = WSTETH_CONTRACT.stEthPerToken();\\n            (, , , ratio_) = getRatioAaveV3(stEthPerWsteth_);\\n        } else if (protocolId_ == 3) {\\n            // wstETH based protocol\\n            uint256 stEthPerWsteth_ = WSTETH_CONTRACT.stEthPerToken();\\n            (, , , ratio_) = getRatioCompoundV3(stEthPerWsteth_);\\n        } else if (protocolId_ == 4) {\\n            // wstETH based protocol\\n            uint256 stEthPerWsteth_ = WSTETH_CONTRACT.stEthPerToken();\\n            (, , , ratio_) = getRatioEuler(stEthPerWsteth_);\\n        } else if (protocolId_ == 5) {\\n            // stETH based protocol\\n            (, , , , , , ratio_) = getRatioMorphoAaveV2();\\n        } else if (protocolId_ == 6) {\\n            // wstETH based protocol\\n            uint256 stEthPerWsteth_ = WSTETH_CONTRACT.stEthPerToken();\\n            (, , , ratio_) = getRatioMorphoAaveV3(stEthPerWsteth_);\\n        } else if (protocolId_ == 7) {\\n            // wstETH based protocol\\n            uint256 stEthPerWsteth_ = WSTETH_CONTRACT.stEthPerToken();\\n            (, , , ratio_) = getRatioSpark(stEthPerWsteth_);\\n        } else if (protocolId_ == 8) {\\n            // wstETH based protocol\\n            uint256 stEthPerWsteth_ = WSTETH_CONTRACT.stEthPerToken();\\n            (, , , ratio_) = getRatioFluid(stEthPerWsteth_);\\n        } else {\\n            revert Helpers__UnsupportedProtocolId();\\n        }\\n    }\\n\\n    function getNetAssets()\\n        public\\n        view\\n        returns (\\n            uint256 totalAssets_, // Total assets(collaterals + ideal balances) inlcuding reveune\\n            uint256 totalDebt_, // Total debt\\n            uint256 netAssets_, // Total assets - Total debt - Reveune\\n            uint256 aggregatedRatio_, // Aggregated ratio of vault (Total debt/ (Total assets - revenue))\\n            NetAssetsHelper memory assets_\\n        )\\n    {\\n        uint256 stETHPerWstETH_ = WSTETH_CONTRACT.stEthPerToken();\\n\\n        // Calculate collateral and debt values for all the protocols\\n\\n        // stETH based protocols\\n        (assets_.aaveV2.stETH, assets_.aaveV2.wETH, ) = getRatioAaveV2();\\n\\n        (\\n            assets_.morphoAaveV2.stETH,\\n            ,\\n            ,\\n            assets_.morphoAaveV2.wETH,\\n            ,\\n            ,\\n\\n        ) = getRatioMorphoAaveV2();\\n\\n        // wstETH based protocols\\n        (assets_.aaveV3.wstETH, , assets_.aaveV3.wETH, ) = getRatioAaveV3(\\n            stETHPerWstETH_\\n        );\\n\\n        (\\n            assets_.compoundV3.wstETH,\\n            ,\\n            assets_.compoundV3.wETH,\\n\\n        ) = getRatioCompoundV3(stETHPerWstETH_);\\n\\n        (assets_.euler.wstETH, , assets_.euler.wETH, ) = getRatioEuler(\\n            stETHPerWstETH_\\n        );\\n\\n        // wstETH based protocols\\n        (\\n            assets_.morphoAaveV3.wstETH,\\n            ,\\n            assets_.morphoAaveV3.wETH,\\n\\n        ) = getRatioMorphoAaveV3(stETHPerWstETH_);\\n\\n        // wstETH based protocols\\n        (assets_.spark.wstETH, , assets_.spark.wETH, ) = getRatioSpark(\\n            stETHPerWstETH_\\n        );\\n\\n        // wstETH based protocols\\n        (assets_.fluid.wstETH, , assets_.fluid.wETH, ) = getRatioFluid(\\n            stETHPerWstETH_\\n        );\\n\\n        // Ideal wstETH balances in vault and DSA\\n        assets_.vaultBalances.wstETH = IERC20(WSTETH_ADDRESS).balanceOf(\\n            address(this)\\n        );\\n        assets_.dsaBalances.wstETH = IERC20(WSTETH_ADDRESS).balanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        // Ideal stETH balances in vault and DSA\\n        assets_.vaultBalances.stETH = IERC20(STETH_ADDRESS).balanceOf(\\n            address(this)\\n        );\\n        assets_.dsaBalances.stETH = IERC20(STETH_ADDRESS).balanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        // Ideal wETH balances in vault and DSA\\n        assets_.vaultBalances.wETH = IERC20(WETH_ADDRESS).balanceOf(\\n            address(this)\\n        );\\n        assets_.dsaBalances.wETH = IERC20(WETH_ADDRESS).balanceOf(\\n            address(vaultDSA)\\n        );\\n\\n        // Aggregating total wstETH\\n        uint256 totalWstETH_ = assets_.aaveV3.wstETH + // Protocols\\n            assets_.compoundV3.wstETH +\\n            assets_.euler.wstETH +\\n            assets_.morphoAaveV3.wstETH +\\n            assets_.spark.wstETH +\\n            assets_.fluid.wstETH +\\n            // Ideal balances\\n            assets_.vaultBalances.wstETH +\\n            assets_.dsaBalances.wstETH;\\n\\n        // Net assets are always calculated as STETH supplied - ETH borrowed.\\n\\n        // Convert all wstETH to stETH to get the same base token.\\n        uint256 convertedStETH = IWstETH(WSTETH_ADDRESS).getStETHByWstETH(\\n            totalWstETH_\\n        );\\n\\n        // Aggregating total stETH + wETH including revenue\\n        totalAssets_ =\\n            // Protocol stETH collateral\\n            assets_.vaultBalances.stETH +\\n            assets_.dsaBalances.stETH +\\n            assets_.aaveV2.stETH +\\n            assets_.morphoAaveV2.stETH +\\n            convertedStETH +\\n            // Ideal wETH balance and assuming wETH 1:1 stETH\\n            assets_.vaultBalances.wETH +\\n            assets_.dsaBalances.wETH +\\n            // Lido queued withdraw assets\\n            queuedWithdrawStEth;\\n\\n        // Aggregating total wETH debt from protocols\\n        totalDebt_ =\\n            assets_.aaveV2.wETH +\\n            assets_.aaveV3.wETH +\\n            assets_.compoundV3.wETH +\\n            assets_.morphoAaveV2.wETH +\\n            assets_.euler.wETH +\\n            assets_.morphoAaveV3.wETH +\\n            assets_.spark.wETH +\\n            assets_.fluid.wETH;\\n\\n        netAssets_ = totalAssets_ - totalDebt_ - revenue; // Assuming wETH 1:1 stETH\\n        aggregatedRatio_ = totalAssets_ == 0\\n            ? 0\\n            : ((totalDebt_ * 1e6) / (totalAssets_ - revenue));\\n    }\\n\\n    /// @notice calculates the withdraw fee: max(percentage amount, absolute amount)\\n    /// @param stETHAmount_ the amount of assets being withdrawn\\n    /// @return the withdraw fee amount in assets\\n    function getWithdrawFee(\\n        uint256 stETHAmount_\\n    ) public view returns (uint256) {\\n        // percentage is in 1e4(1% is 10_000) here we want to have 100% as denominator\\n        uint256 withdrawFee = (stETHAmount_ * withdrawalFeePercentage) / 1e6;\\n\\n        if (withdrawFeeAbsoluteMin > withdrawFee) {\\n            return withdrawFeeAbsoluteMin;\\n        }\\n        return withdrawFee;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault/common/interfaces.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface TokenInterface {\\n    function approve(address, uint256) external;\\n\\n    function transfer(address, uint) external;\\n\\n    function transferFrom(address, address, uint) external;\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint) external;\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    function decimals() external view returns (uint);\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n}\\n\\ninterface IInstaIndex {\\n    function build(\\n        address owner_,\\n        uint256 accountVersion_,\\n        address origin_\\n    ) external returns (address account_);\\n}\\n\\ninterface IDSA {\\n    function cast(\\n        string[] calldata _targetNames,\\n        bytes[] calldata _datas,\\n        address _origin\\n    ) external payable returns (bytes32);\\n}\\n\\ninterface IWstETH {\\n    function tokensPerStEth() external view returns (uint256);\\n\\n    function getStETHByWstETH(\\n        uint256 _wstETHAmount\\n    ) external view returns (uint256);\\n\\n    function getWstETHByStETH(\\n        uint256 _stETHAmount\\n    ) external view returns (uint256);\\n\\n    function stEthPerToken() external view returns (uint256);\\n}\\n\\ninterface ICompoundMarket {\\n    struct UserCollateral {\\n        uint128 balance;\\n        uint128 _reserved;\\n    }\\n\\n    function borrowBalanceOf(address account) external view returns (uint256);\\n\\n    function userCollateral(\\n        address,\\n        address\\n    ) external view returns (UserCollateral memory);\\n}\\n\\ninterface IEulerTokens {\\n    function balanceOfUnderlying(\\n        address account\\n    ) external view returns (uint256); //To be used for E-Tokens\\n\\n    function balanceOf(address) external view returns (uint256); //To be used for D-Tokens\\n}\\n\\ninterface ILiteVaultV1 {\\n    function deleverageAndWithdraw(\\n        uint256 deleverageAmt_,\\n        uint256 withdrawAmount_,\\n        address to_\\n    ) external;\\n\\n    function getCurrentExchangePrice()\\n        external\\n        view\\n        returns (uint256 exchangePrice_, uint256 newRevenue_);\\n}\\n\\ninterface IAavePoolProviderInterface {\\n    function getLendingPool() external view returns (address);\\n}\\n\\ninterface IAavePool {\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256); // Returns underlying amount withdrawn.\\n}\\n\\ninterface IMorphoAaveV2 {\\n    struct PoolIndexes {\\n        uint32 lastUpdateTimestamp; // The last time the local pool and peer-to-peer indexes were updated.\\n        uint112 poolSupplyIndex; // Last pool supply index. Note that for the stEth market, the pool supply index is tweaked to take into account the staking rewards.\\n        uint112 poolBorrowIndex; // Last pool borrow index. Note that for the stEth market, the pool borrow index is tweaked to take into account the staking rewards.\\n    }\\n\\n    function poolIndexes(address) external view returns (PoolIndexes memory);\\n\\n    // Current index from supply peer-to-peer unit to underlying (in ray).\\n    function p2pSupplyIndex(address) external view returns (uint256);\\n\\n    // Current index from borrow peer-to-peer unit to underlying (in ray).\\n    function p2pBorrowIndex(address) external view returns (uint256);\\n\\n    struct SupplyBalance {\\n        uint256 inP2P; // In peer-to-peer supply scaled unit, a unit that grows in underlying value, to keep track of the interests earned by suppliers in peer-to-peer. Multiply by the peer-to-peer supply index to get the underlying amount.\\n        uint256 onPool; // In pool supply scaled unit. Multiply by the pool supply index to get the underlying amount.\\n    }\\n\\n    struct BorrowBalance {\\n        uint256 inP2P; // In peer-to-peer borrow scaled unit, a unit that grows in underlying value, to keep track of the interests paid by borrowers in peer-to-peer. Multiply by the peer-to-peer borrow index to get the underlying amount.\\n        uint256 onPool; // In pool borrow scaled unit, a unit that grows in value, to keep track of the debt increase when borrowers are on Aave. Multiply by the pool borrow index to get the underlying amount.\\n    }\\n\\n    // For a given market, the supply balance of a user. aToken -> user -> balances.\\n    function supplyBalanceInOf(\\n        address,\\n        address\\n    ) external view returns (SupplyBalance memory);\\n\\n    // For a given market, the borrow balance of a user. aToken -> user -> balances.\\n    function borrowBalanceInOf(\\n        address,\\n        address\\n    ) external view returns (BorrowBalance memory);\\n\\n    /// @notice Updates the peer-to-peer indexes and pool indexes (only stored locally).\\n    function updateIndexes(address _poolToken) external;\\n}\\n\\ninterface ILidoWithdrawalQueue {\\n    // code below from Lido WithdrawalQueueBase.sol\\n    // see https://github.com/lidofinance/lido-dao/blob/v2.0.0-beta.3/contracts/0.8.9/WithdrawalQueueBase.sol\\n\\n    /// @notice output format struct for `_getWithdrawalStatus()` method\\n    struct WithdrawalRequestStatus {\\n        /// @notice stETH token amount that was locked on withdrawal queue for this request\\n        uint256 amountOfStETH;\\n        /// @notice amount of stETH shares locked on withdrawal queue for this request\\n        uint256 amountOfShares;\\n        /// @notice address that can claim or transfer this request\\n        address owner;\\n        /// @notice timestamp of when the request was created, in seconds\\n        uint256 timestamp;\\n        /// @notice true, if request is finalized\\n        bool isFinalized;\\n        /// @notice true, if request is claimed. Request is claimable if (isFinalized && !isClaimed)\\n        bool isClaimed;\\n    }\\n\\n    /// @notice length of the checkpoints. Last possible value for the claim hint\\n    function getLastCheckpointIndex() external view returns (uint256);\\n\\n    // code below from Lido WithdrawalQueue.sol\\n    // see https://github.com/lidofinance/lido-dao/blob/v2.0.0-beta.3/contracts/0.8.9/WithdrawalQueue.sol\\n\\n    /// @notice Request the sequence of stETH withdrawals according to passed `withdrawalRequestInputs` data\\n    /// @param amounts an array of stETH amount values. The standalone withdrawal request will\\n    ///  be created for each item in the passed list.\\n    /// @param _owner address that will be able to transfer or claim the request.\\n    ///  If `owner` is set to `address(0)`, `msg.sender` will be used as owner.\\n    /// @return requestIds an array of the created withdrawal requests\\n    function requestWithdrawals(\\n        uint256[] calldata amounts,\\n        address _owner\\n    ) external returns (uint256[] memory requestIds);\\n\\n    /// @notice Claim one`_requestId` request once finalized sending locked ether to the owner\\n    /// @param _requestId request id to claim\\n    /// @dev use unbounded loop to find a hint, which can lead to OOG\\n    /// @dev\\n    ///  Reverts if requestId or hint are not valid\\n    ///  Reverts if request is not finalized or already claimed\\n    ///  Reverts if msg sender is not an owner of request\\n    function claimWithdrawal(uint256 _requestId) external;\\n\\n    /// @notice Claim a batch of withdrawal requests once finalized (claimable) sending locked ether to the owner\\n    /// @param _requestIds array of request ids to claim\\n    /// @param _hints checkpoint hint for each id.\\n    ///   Can be retrieved with `findCheckpointHints()`\\n    /// @dev\\n    ///  Reverts if any requestId or hint in arguments are not valid\\n    ///  Reverts if any request is not finalized or already claimed\\n    ///  Reverts if msg sender is not an owner of the requests\\n    function claimWithdrawals(\\n        uint256[] calldata _requestIds,\\n        uint256[] calldata _hints\\n    ) external;\\n\\n    /// @notice Returns all withdrawal requests that belongs to the `_owner` address\\n    ///\\n    /// WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n    /// to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n    /// this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n    /// uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n    function getWithdrawalRequests(\\n        address _owner\\n    ) external view returns (uint256[] memory requestsIds);\\n\\n    /// @notice Finds the list of hints for the given `_requestIds` searching among the checkpoints with indices\\n    ///  in the range  `[_firstIndex, _lastIndex]`. NB! Array of request ids should be sorted\\n    /// @param _requestIds ids of the requests sorted in the ascending order to get hints for\\n    /// @param _firstIndex left boundary of the search range\\n    /// @param _lastIndex right boundary of the search range\\n    /// @return hintIds the hints for `claimWithdrawal` to find the checkpoint for the passed request ids\\n    function findCheckpointHints(\\n        uint256[] calldata _requestIds,\\n        uint256 _firstIndex,\\n        uint256 _lastIndex\\n    ) external view returns (uint256[] memory hintIds);\\n\\n    /// @notice Returns statuses for the array of request ids\\n    /// @param _requestIds array of withdrawal request ids\\n    function getWithdrawalStatus(\\n        uint256[] calldata _requestIds\\n    ) external view returns (WithdrawalRequestStatus[] memory statuses);\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n}\\n\\ninterface IWeth {\\n    function deposit() external payable;\\n\\n    function transfer(address dst, uint wad) external returns (bool);\\n}\\n\\ninterface IMorphoAaveV3 {\\n    function marketsCreated() external view returns (address[] memory);\\n\\n    /// @notice Contains the market side indexes as uint256 instead of uint128.\\n    struct MarketSideIndexes256 {\\n        uint256 poolIndex; // The pool index (in ray).\\n        uint256 p2pIndex; // The peer-to-peer index (in ray).\\n    }\\n\\n    /// @notice Contains the indexes as uint256 instead of uint128.\\n    struct Indexes256 {\\n        MarketSideIndexes256 supply; // The `MarketSideIndexes` related to the supply as uint256.\\n        MarketSideIndexes256 borrow; // The `MarketSideIndexes` related to the borrow as uint256.\\n    }\\n\\n    /// @notice Returns the updated indexes (peer-to-peer and pool).\\n    function updatedIndexes(\\n        address underlying\\n    ) external view returns (Indexes256 memory);\\n\\n    /// @notice Returns the total borrow balance of `user` on the `underlying` market (in underlying).\\n    function borrowBalance(\\n        address underlying,\\n        address user\\n    ) external view returns (uint256);\\n\\n    /// @notice Returns the supply collateral balance of `user` on the `underlying` market (in underlying).\\n    function collateralBalance(\\n        address underlying,\\n        address user\\n    ) external view returns (uint256);\\n\\n    /// @notice Returns the scaled balance of `user` on the `underlying` market, supplied on pool & used as collateral (with `underlying` decimals).\\n    function scaledCollateralBalance(\\n        address underlying,\\n        address user\\n    ) external view returns (uint256);\\n\\n    /// @notice Returns the scaled balance of `user` on the `underlying` market, borrowed peer-to-peer (with `underlying` decimals).\\n    function scaledP2PBorrowBalance(\\n        address underlying,\\n        address user\\n    ) external view returns (uint256);\\n\\n    /// @notice Returns the scaled balance of `user` on the `underlying` market, borrowed from pool (with `underlying` decimals).\\n    function scaledPoolBorrowBalance(\\n        address underlying,\\n        address user\\n    ) external view returns (uint256);\\n}\\n\\ninterface IFluidVaultT1 {\\n    /// @notice reads uint256 data `result_` from storage at a bytes32 storage `slot_` key.\\n    function readFromStorage(\\n        bytes32 slot_\\n    ) external view returns (uint256 result_);\\n\\n    /// @notice calculates the updated vault exchange prices\\n    function updateExchangePrices(\\n        uint256 vaultVariables2_\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 liqSupplyExPrice_,\\n            uint256 liqBorrowExPrice_,\\n            uint256 vaultSupplyExPrice_,\\n            uint256 vaultBorrowExPrice_\\n        );\\n\\n    function operate(\\n        uint256 nftId_, // if 0 then new position\\n        int256 newCol_, // if negative then withdraw\\n        int256 newDebt_, // if negative then payback\\n        address to_ // address at which the borrow & withdraw amount should go to. If address(0) then it'll go to msg.sender\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256, // nftId_\\n            int256, // final supply amount. if - then withdraw\\n            int256 // final borrow amount. if - then payback\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/vault/common/tickmath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/// @title library that calculates number \\\"tick\\\" and \\\"ratioX96\\\" from this: ratioX96 = (1.0015^tick) * 2^96\\n/// @notice this library is used in Fluid Vault protocol for optimiziation.\\n/// @dev \\\"tick\\\" supports between -32767 and 32767. \\\"ratioX96\\\" supports between 37075072 and 169307877264527972847801929085841449095838922544595\\nlibrary TickMath {\\n    /// The minimum tick that can be passed in getRatioAtTick. 1.0015**-32767\\n    int24 internal constant MIN_TICK = -32767;\\n    /// The maximum tick that can be passed in getRatioAtTick. 1.0015**32767\\n    int24 internal constant MAX_TICK = 32767;\\n\\n    uint256 internal constant FACTOR00 = 0x100000000000000000000000000000000;\\n    uint256 internal constant FACTOR01 = 0xff9dd7de423466c20352b1246ce4856f; // 2^128/1.0015**1 = 339772707859149738855091969477551883631\\n    uint256 internal constant FACTOR02 = 0xff3bd55f4488ad277531fa1c725a66d0; // 2^128/1.0015**2 = 339263812140938331358054887146831636176\\n    uint256 internal constant FACTOR03 = 0xfe78410fd6498b73cb96a6917f853259; // 2^128/1.0015**4 = 338248306163758188337119769319392490073\\n    uint256 internal constant FACTOR04 = 0xfcf2d9987c9be178ad5bfeffaa123273; // 2^128/1.0015**8 = 336226404141693512316971918999264834163\\n    uint256 internal constant FACTOR05 = 0xf9ef02c4529258b057769680fc6601b3; // 2^128/1.0015**16 = 332218786018727629051611634067491389875\\n    uint256 internal constant FACTOR06 = 0xf402d288133a85a17784a411f7aba082; // 2^128/1.0015**32 = 324346285652234375371948336458280706178\\n    uint256 internal constant FACTOR07 = 0xe895615b5beb6386553757b0352bda90; // 2^128/1.0015**64 = 309156521885964218294057947947195947664\\n    uint256 internal constant FACTOR08 = 0xd34f17a00ffa00a8309940a15930391a; // 2^128/1.0015**128 = 280877777739312896540849703637713172762\\n    uint256 internal constant FACTOR09 = 0xae6b7961714e20548d88ea5123f9a0ff; // 2^128/1.0015**256 = 231843708922198649176471782639349113087\\n    uint256 internal constant FACTOR10 = 0x76d6461f27082d74e0feed3b388c0ca1; // 2^128/1.0015**512 = 157961477267171621126394973980180876449\\n    uint256 internal constant FACTOR11 = 0x372a3bfe0745d8b6b19d985d9a8b85bb; // 2^128/1.0015**1024 = 73326833024599564193373530205717235131\\n    uint256 internal constant FACTOR12 = 0x0be32cbee48979763cf7247dd7bb539d; // 2^128/1.0015**2048 = 15801066890623697521348224657638773661\\n    uint256 internal constant FACTOR13 = 0x8d4f70c9ff4924dac37612d1e2921e; // 2^128/1.0015**4096 = 733725103481409245883800626999235102\\n    uint256 internal constant FACTOR14 = 0x4e009ae5519380809a02ca7aec77; // 2^128/1.0015**8192 = 1582075887005588088019997442108535\\n    uint256 internal constant FACTOR15 = 0x17c45e641b6e95dee056ff10; // 2^128/1.0015**16384 = 7355550435635883087458926352\\n\\n    /// The minimum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MIN_TICK). ~ Equivalent to `(1 << 96) * (1.0015**-32767)`\\n    uint256 internal constant MIN_RATIOX96 = 37075072;\\n    /// The maximum value that can be returned from getRatioAtTick. Equivalent to getRatioAtTick(MAX_TICK).\\n    /// ~ Equivalent to `(1 << 96) * (1.0015**32767)`, rounding etc. leading to minor difference\\n    uint256 internal constant MAX_RATIOX96 =\\n        169307877264527972847801929085841449095838922544595;\\n\\n    uint256 internal constant ZERO_TICK_SCALED_RATIO =\\n        0x1000000000000000000000000; // 1 << 96 // 79228162514264337593543950336\\n    uint256 internal constant _1E26 = 1e26;\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return ratioX96 ratio = (debt amount/collateral amount)\\n    function getRatioAtTick(int tick) internal pure returns (uint256 ratioX96) {\\n        assembly {\\n            let absTick_ := sub(xor(tick, sar(255, tick)), sar(255, tick))\\n\\n            if gt(absTick_, MAX_TICK) {\\n                revert(0, 0)\\n            }\\n            let factor_ := FACTOR00\\n            if and(absTick_, 0x1) {\\n                factor_ := FACTOR01\\n            }\\n            if and(absTick_, 0x2) {\\n                factor_ := shr(128, mul(factor_, FACTOR02))\\n            }\\n            if and(absTick_, 0x4) {\\n                factor_ := shr(128, mul(factor_, FACTOR03))\\n            }\\n            if and(absTick_, 0x8) {\\n                factor_ := shr(128, mul(factor_, FACTOR04))\\n            }\\n            if and(absTick_, 0x10) {\\n                factor_ := shr(128, mul(factor_, FACTOR05))\\n            }\\n            if and(absTick_, 0x20) {\\n                factor_ := shr(128, mul(factor_, FACTOR06))\\n            }\\n            if and(absTick_, 0x40) {\\n                factor_ := shr(128, mul(factor_, FACTOR07))\\n            }\\n            if and(absTick_, 0x80) {\\n                factor_ := shr(128, mul(factor_, FACTOR08))\\n            }\\n            if and(absTick_, 0x100) {\\n                factor_ := shr(128, mul(factor_, FACTOR09))\\n            }\\n            if and(absTick_, 0x200) {\\n                factor_ := shr(128, mul(factor_, FACTOR10))\\n            }\\n            if and(absTick_, 0x400) {\\n                factor_ := shr(128, mul(factor_, FACTOR11))\\n            }\\n            if and(absTick_, 0x800) {\\n                factor_ := shr(128, mul(factor_, FACTOR12))\\n            }\\n            if and(absTick_, 0x1000) {\\n                factor_ := shr(128, mul(factor_, FACTOR13))\\n            }\\n            if and(absTick_, 0x2000) {\\n                factor_ := shr(128, mul(factor_, FACTOR14))\\n            }\\n            if and(absTick_, 0x4000) {\\n                factor_ := shr(128, mul(factor_, FACTOR15))\\n            }\\n\\n            let precision_ := 0\\n            if iszero(\\n                and(\\n                    tick,\\n                    0x8000000000000000000000000000000000000000000000000000000000000000\\n                )\\n            ) {\\n                factor_ := div(\\n                    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\\n                    factor_\\n                )\\n                // we round up in the division so getTickAtRatio of the output price is always consistent\\n                if mod(factor_, 0x100000000) {\\n                    precision_ := 1\\n                }\\n            }\\n            ratioX96 := add(shr(32, factor_), precision_)\\n        }\\n    }\\n\\n    /// @notice ratioX96 = (1.0015^tick) * 2^96\\n    /// @dev Throws if ratioX96 > max ratio || ratioX96 < min ratio\\n    /// @param ratioX96 The input ratio; ratio = (debt amount/collateral amount)\\n    /// @return tick The output tick for the above formula. Returns in round down form. if tick is 123.23 then 123, if tick is -123.23 then returns -124\\n    /// @return perfectRatioX96 perfect ratio for the above tick\\n    function getTickAtRatio(\\n        uint256 ratioX96\\n    ) internal pure returns (int tick, uint perfectRatioX96) {\\n        assembly {\\n            if or(gt(ratioX96, MAX_RATIOX96), lt(ratioX96, MIN_RATIOX96)) {\\n                revert(0, 0)\\n            }\\n\\n            let cond := lt(ratioX96, ZERO_TICK_SCALED_RATIO)\\n            let factor_\\n\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ratioX96, _1E26), ZERO_TICK_SCALED_RATIO)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                factor_ := div(mul(ZERO_TICK_SCALED_RATIO, _1E26), ratioX96)\\n            }\\n\\n            // put in https://www.wolframalpha.com/ whole equation: (1.0015^tick) * 2^96 * 10^26 / 79228162514264337593543950336\\n\\n            // for tick = 16384\\n            // ratioX96 = (1.0015^16384) * 2^96 = 3665252098134783297721995888537077351735\\n            // 3665252098134783297721995888537077351735 * 10^26 / 79228162514264337593543950336 =\\n            // 4626198540796508716348404308345255985.06131964639489434655721\\n            if iszero(lt(factor_, 4626198540796508716348404308345255985)) {\\n                tick := or(tick, 0x4000)\\n                factor_ := div(\\n                    mul(factor_, _1E26),\\n                    4626198540796508716348404308345255985\\n                )\\n            }\\n            // for tick = 8192\\n            // ratioX96 = (1.0015^8192) * 2^96 = 17040868196391020479062776466509865\\n            // 17040868196391020479062776466509865 * 10^26 / 79228162514264337593543950336 =\\n            // 21508599537851153911767490449162.3037648642153898377655505172\\n            if iszero(lt(factor_, 21508599537851153911767490449162)) {\\n                tick := or(tick, 0x2000)\\n                factor_ := div(\\n                    mul(factor_, _1E26),\\n                    21508599537851153911767490449162\\n                )\\n            }\\n            // for tick = 4096\\n            // ratioX96 = (1.0015^4096) * 2^96 = 36743933851015821532611831851150\\n            // 36743933851015821532611831851150 * 10^26 / 79228162514264337593543950336 =\\n            // 46377364670549310883002866648.9777607649742626173648716941385\\n            if iszero(lt(factor_, 46377364670549310883002866649)) {\\n                tick := or(tick, 0x1000)\\n                factor_ := div(\\n                    mul(factor_, _1E26),\\n                    46377364670549310883002866649\\n                )\\n            }\\n            // for tick = 2048\\n            // ratioX96 = (1.0015^2048) * 2^96 = 1706210527034005899209104452335\\n            // 1706210527034005899209104452335 * 10^26 / 79228162514264337593543950336 =\\n            // 2153540449365864845468344760.06357108484096046743300420319322\\n            if iszero(lt(factor_, 2153540449365864845468344760)) {\\n                tick := or(tick, 0x800)\\n                factor_ := div(\\n                    mul(factor_, _1E26),\\n                    2153540449365864845468344760\\n                )\\n            }\\n            // for tick = 1024\\n            // ratioX96 = (1.0015^1024) * 2^96 = 367668226692760093024536487236\\n            // 367668226692760093024536487236 * 10^26 / 79228162514264337593543950336 =\\n            // 464062544207767844008185024.950588990554136265212906454481127\\n            if iszero(lt(factor_, 464062544207767844008185025)) {\\n                tick := or(tick, 0x400)\\n                factor_ := div(mul(factor_, _1E26), 464062544207767844008185025)\\n            }\\n            // for tick = 512\\n            // ratioX96 = (1.0015^512) * 2^96 = 170674186729409605620119663668\\n            // 170674186729409605620119663668 * 10^26 / 79228162514264337593543950336 =\\n            // 215421109505955298802281577.031879604792139232258508172947569\\n            if iszero(lt(factor_, 215421109505955298802281577)) {\\n                tick := or(tick, 0x200)\\n                factor_ := div(mul(factor_, _1E26), 215421109505955298802281577)\\n            }\\n            // for tick = 256\\n            // ratioX96 = (1.0015^256) * 2^96 = 116285004205991934861656513301\\n            // 116285004205991934861656513301 * 10^26 / 79228162514264337593543950336 =\\n            // 146772309890508740607270614.667650899656438875541505058062410\\n            if iszero(lt(factor_, 146772309890508740607270615)) {\\n                tick := or(tick, 0x100)\\n                factor_ := div(mul(factor_, _1E26), 146772309890508740607270615)\\n            }\\n            // for tick = 128\\n            // ratioX96 = (1.0015^128) * 2^96 = 95984619659632141743747099590\\n            // 95984619659632141743747099590 * 10^26 / 79228162514264337593543950336 =\\n            // 121149622323187099817270416.157248837742741760456796835775887\\n            if iszero(lt(factor_, 121149622323187099817270416)) {\\n                tick := or(tick, 0x80)\\n                factor_ := div(mul(factor_, _1E26), 121149622323187099817270416)\\n            }\\n            // for tick = 64\\n            // ratioX96 = (1.0015^64) * 2^96 = 87204845308406958006717891124\\n            // 87204845308406958006717891124 * 10^26 / 79228162514264337593543950336 =\\n            // 110067989135437147685980801.568068573422377364214113968609839\\n            if iszero(lt(factor_, 110067989135437147685980801)) {\\n                tick := or(tick, 0x40)\\n                factor_ := div(mul(factor_, _1E26), 110067989135437147685980801)\\n            }\\n            // for tick = 32\\n            // ratioX96 = (1.0015^32) * 2^96 = 83120873769022354029916374475\\n            // 83120873769022354029916374475 * 10^26 / 79228162514264337593543950336 =\\n            // 104913292358707887270979599.831816586773651266562785765558183\\n            if iszero(lt(factor_, 104913292358707887270979600)) {\\n                tick := or(tick, 0x20)\\n                factor_ := div(mul(factor_, _1E26), 104913292358707887270979600)\\n            }\\n            // for tick = 16\\n            // ratioX96 = (1.0015^16) * 2^96 = 81151180492336368327184716176\\n            // 81151180492336368327184716176 * 10^26 / 79228162514264337593543950336 =\\n            // 102427189924701091191840927.762844039579442328381455567932128\\n            if iszero(lt(factor_, 102427189924701091191840928)) {\\n                tick := or(tick, 0x10)\\n                factor_ := div(mul(factor_, _1E26), 102427189924701091191840928)\\n            }\\n            // for tick = 8\\n            // ratioX96 = (1.0015^8) * 2^96 = 80183906840906820640659903620\\n            // 80183906840906820640659903620 * 10^26 / 79228162514264337593543950336 =\\n            // 101206318935480056907421312.890625\\n            if iszero(lt(factor_, 101206318935480056907421313)) {\\n                tick := or(tick, 0x8)\\n                factor_ := div(mul(factor_, _1E26), 101206318935480056907421313)\\n            }\\n            // for tick = 4\\n            // ratioX96 = (1.0015^4) * 2^96 = 79704602139525152702959747603\\n            // 79704602139525152702959747603 * 10^26 / 79228162514264337593543950336 =\\n            // 100601351350506250000000000\\n            if iszero(lt(factor_, 100601351350506250000000000)) {\\n                tick := or(tick, 0x4)\\n                factor_ := div(mul(factor_, _1E26), 100601351350506250000000000)\\n            }\\n            // for tick = 2\\n            // ratioX96 = (1.0015^2) * 2^96 = 79466025265172787701084167660\\n            // 79466025265172787701084167660 * 10^26 / 79228162514264337593543950336 =\\n            // 100300225000000000000000000\\n            if iszero(lt(factor_, 100300225000000000000000000)) {\\n                tick := or(tick, 0x2)\\n                factor_ := div(mul(factor_, _1E26), 100300225000000000000000000)\\n            }\\n            // for tick = 1\\n            // ratioX96 = (1.0015^1) * 2^96 = 79347004758035734099934266261\\n            // 79347004758035734099934266261 * 10^26 / 79228162514264337593543950336 =\\n            // 100150000000000000000000000\\n            if iszero(lt(factor_, 100150000000000000000000000)) {\\n                tick := or(tick, 0x1)\\n                factor_ := div(mul(factor_, _1E26), 100150000000000000000000000)\\n            }\\n            if iszero(cond) {\\n                // if ratioX96 >= ZERO_TICK_SCALED_RATIO\\n                perfectRatioX96 := div(mul(ratioX96, _1E26), factor_)\\n            }\\n            if cond {\\n                // ratioX96 < ZERO_TICK_SCALED_RATIO\\n                tick := not(tick)\\n                perfectRatioX96 := div(\\n                    mul(ratioX96, factor_),\\n                    100150000000000000000000000\\n                )\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault/common/variables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./interfaces.sol\\\";\\nimport \\\"../../infiniteProxy/IProxy.sol\\\";\\n\\n/// @title      Variables\\n/// @notice     Contains common storage variables of all modules of Infinite proxy.\\ncontract ConstantVariables {\\n    uint256 internal constant RAY = 10 ** 27;\\n    uint256 internal constant MAX_UINT256 = type(uint256).max;\\n    uint256 internal constant RAY_MINUS_ONE = RAY - 1;\\n    uint256 internal constant MAX_UINT256_MINUS_RAY_MINUS_ONE =\\n        MAX_UINT256 - RAY_MINUS_ONE;\\n\\n    uint256 internal constant MORPHO_V3_MAX_ITERATIONS = 10;\\n\\n    IInstaIndex internal constant INSTA_INDEX_CONTRACT =\\n        IInstaIndex(0x2971AdFa57b20E5a416aE5a708A8655A9c74f723);\\n    address internal constant IETH_TOKEN_V1 =\\n        0xc383a3833A87009fD9597F8184979AF5eDFad019;\\n\\n    /***********************************|\\n    |           STETH ADDRESSES         |\\n    |__________________________________*/\\n    address internal constant STETH_ADDRESS =\\n        0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\\n    // IERC20 internal constant STETH_CONTRACT = IERC20(STETH_ADDRESS);\\n    address internal constant A_STETH_ADDRESS =\\n        0x1982b2F5814301d4e9a8b0201555376e62F82428;\\n\\n    /***********************************|\\n    |           WSTETH ADDRESSES        |\\n    |__________________________________*/\\n    address internal constant WSTETH_ADDRESS =\\n        0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\\n    IWstETH internal constant WSTETH_CONTRACT = IWstETH(WSTETH_ADDRESS);\\n    address internal constant A_WSTETH_ADDRESS_AAVEV3 =\\n        0x0B925eD163218f6662a35e0f0371Ac234f9E9371;\\n    address internal constant E_WSTETH_ADDRESS =\\n        0xbd1bd5C956684f7EB79DA40f582cbE1373A1D593;\\n    address internal constant SP_WSTETH_ADDRESS_SPARK =\\n        0x12B54025C112Aa61fAce2CDB7118740875A566E9;\\n\\n    /***********************************|\\n    |           ETH ADDRESSES           |\\n    |__________________________________*/\\n    address internal constant ETH_ADDRESS =\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address internal constant WETH_ADDRESS =\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address internal constant A_WETH_ADDRESS =\\n        0x030bA81f1c18d280636F32af80b9AAd02Cf0854e;\\n    address internal constant D_WETH_ADDRESS =\\n        0xF63B34710400CAd3e044cFfDcAb00a0f32E33eCf;\\n    address internal constant D_WETH_ADDRESS_AAVEV3 =\\n        0xeA51d7853EEFb32b6ee06b1C12E6dcCA88Be0fFE;\\n    address internal constant D_WETH_ADDRESS_EULER =\\n        0x62e28f054efc24b26A794F5C1249B6349454352C;\\n    address internal constant D_WETH_ADDRESS_SPARK =\\n        0x2e7576042566f8D6990e07A1B61Ad1efd86Ae70d;\\n\\n    address internal constant COMP_ETH_MARKET_ADDRESS =\\n        0xA17581A9E3356d9A858b789D68B4d866e593aE94;\\n\\n    ILiteVaultV1 internal constant LITE_VAULT_V1 = ILiteVaultV1(IETH_TOKEN_V1);\\n\\n    ICompoundMarket internal constant COMP_ETH_MARKET_CONTRACT =\\n        ICompoundMarket(COMP_ETH_MARKET_ADDRESS);\\n\\n    IMorphoAaveV2 internal constant MORPHO_CONTRACT =\\n        IMorphoAaveV2(0x777777c9898D384F785Ee44Acfe945efDFf5f3E0);\\n\\n    IAavePoolProviderInterface internal constant AAVE_POOL_PROVIDER =\\n        IAavePoolProviderInterface(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\\n\\n    ILidoWithdrawalQueue internal constant LIDO_WITHDRAWAL_QUEUE =\\n        ILidoWithdrawalQueue(0x889edC2eDab5f40e902b864aD4d7AdE8E412F9B1);\\n\\n    IMorphoAaveV3 internal constant MORPHO_AAVE_V3 =\\n        IMorphoAaveV3(0x33333aea097c193e66081E930c33020272b33333);\\n\\n    IFluidVaultT1 internal constant FLUID_VAULT =\\n        IFluidVaultT1(FLUID_VAULT_ADDRESS);\\n\\n    address internal constant FLUID_VAULT_ADDRESS =\\n        0xA0F83Fc5885cEBc0420ce7C7b139Adc80c4F4D91;\\n\\n    uint256 internal constant FLUID_NFT_ID = 3;\\n\\n    uint256 internal constant X8 = 0xff;\\n\\n    uint256 internal constant X19 = 0x7ffff;\\n\\n    uint256 internal constant X64 = 0xffffffffffffffff;\\n}\\n\\ncontract Variables is ConstantVariables {\\n    /****************************************************************************|\\n    |   @notice Ids associated with protocols at the time of deployment.         |\\n    |   New protocols might have been added or removed at the time of viewing.   |\\n    |                          AAVE_V2 => 1                                      |\\n    |                          AAVE_V3 => 2                                      |\\n    |                          COMPOUND_V3 => 3                                  |\\n    |                          EULER => 4 // Disabled                            |\\n    |                          MORPHO_AAVE_V2 => 5                               |\\n    |                          MORPHO_AAVE_V3 => 6                               |\\n    |                          SPARK => 7                                        |\\n    |                          FLUID => 8                                        |\\n    |___________________________________________________________________________*/\\n\\n    /***********************************|\\n    |           STATE VARIABLES         |\\n    |__________________________________*/\\n\\n    // 1: open; 2: closed\\n    uint8 internal _status;\\n\\n    IDSA public vaultDSA;\\n\\n    /// @notice Max limit (in wei) allowed for wsteth per eth unit amount.\\n    uint256 public leverageMaxUnitAmountLimit;\\n\\n    /// @notice Secondary auth that only has the power to reduce max risk ratio.\\n    address public secondaryAuth;\\n\\n    // Current exchange price.\\n    uint256 public exchangePrice;\\n\\n    // Revenue exchange price (helps in calculating revenue).\\n    // Exchange price when revenue got updated last. It'll only increase overtime.\\n    uint256 public revenueExchangePrice;\\n\\n    /// @notice mapping to store allowed rebalancers\\n    ///         modifiable by auth\\n    mapping(address => bool) public isRebalancer;\\n\\n    // Mapping of protocol id => max risk ratio, scaled to factor 4.\\n    // i.e. 1% would equal 10,000; 10% would be 100,000 etc.\\n    // 1 = Aave v2\\n    // 2 = Aave v3\\n    // 3 = Compound v3 (ETH market)\\n    // 4 = Euler // Disabled\\n    // 5 = Morpho Aave v2\\n    // 6 = Morpho Aave v3\\n    // 7 = Spark\\n    // 8 = Fluid\\n    mapping(uint8 => uint256) public maxRiskRatio;\\n\\n    // Max aggregated risk ratio of the vault that can be reached, scaled to factor 4.\\n    // i.e. 1% would equal 10,000; 10% would be 100,000 etc.\\n    uint256 public aggrMaxVaultRatio;\\n\\n    /// @notice withdraw fee is either amount in percentage or absolute minimum. This var defines the percentage in 1e6\\n    /// this number is given in 1e4, i.e. 1% would equal 10,000; 10% would be 100,000 etc.\\n    /// modifiable by owner\\n    uint256 public withdrawalFeePercentage;\\n\\n    /// @notice withdraw fee is either amount in percentage or absolute minimum. This var defines the absolute minimum\\n    /// this number is given in decimals for the respective asset of the vault.\\n    /// modifiable by owner\\n    uint256 public withdrawFeeAbsoluteMin; // in underlying base asset, i.e. stEth\\n\\n    // charge from the profits, scaled to factor 4.\\n    // 100,000 would be 10% cut from profit\\n    uint256 public revenueFeePercentage;\\n\\n    /// @notice Stores profit revenue and withdrawal fees collected.\\n    uint256 public revenue;\\n\\n    /// @notice Revenue will be transffered to this address upon collection.\\n    address public treasury;\\n\\n    /// @notice Tracker for amount of stETH queued for withdrawal.\\n    uint256 public queuedWithdrawStEth;\\n}\\n\\n/// @title      PrimaryHelpers\\n/// @notice     Contains common modifiers of all modules of Infinite proxy.\\ncontract PrimaryHelpers is Variables {\\n    /***********************************|\\n    |              ERRORS               |\\n    |__________________________________*/\\n    error Helpers__UnsupportedProtocolId();\\n    error Helpers__NotRebalancer();\\n    error Helpers__Reentrant();\\n    error Helpers__EulerDisabled();\\n\\n    /***********************************|\\n    |              MODIFIERS            |\\n    |__________________________________*/\\n    modifier onlyRebalancer() {\\n        if (\\n            !(isRebalancer[msg.sender] ||\\n                IProxy(address(this)).getAdmin() == msg.sender)\\n        ) {\\n            revert Helpers__NotRebalancer();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev reentrancy gaurd.\\n     */\\n    modifier nonReentrant() {\\n        if (_status == 2) revert Helpers__Reentrant();\\n        _status = 2;\\n        _;\\n        _status = 1;\\n    }\\n\\n    /// @notice Implements a method to read uint256 data from storage at a bytes32 storage slot key.\\n    function readFromStorage(bytes32 slot_) public view returns (uint256 result_) {\\n        assembly {\\n            result_ := sload(slot_) // read value from the storage slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vault/common/variablesBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @title      VariablesBuffer\\n/// @notice     Allocates space of 151 slots to maintain storage \\n///             consistency with imported variables in VariablesPrimaryHelper.\\n\\ncontract VariablesBuffer {\\n    uint[151] internal __buffergap;\\n}\"\r\n    },\r\n    \"contracts/vault/common/variablesBufferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @title      VariablesBufferHelper\\n/// @notice     Buffer Helper for variables that imports all the primary \\n///             helpers from the storage slot 152.\\n\\nimport {VariablesBuffer} from \\\"./variablesBuffer.sol\\\";\\nimport {PrimaryHelpers} from \\\"./variables.sol\\\";\\n\\n// Buffer & variables\\ncontract VariablesBufferHelper is VariablesBuffer, PrimaryHelpers {\\n}\"\r\n    },\r\n    \"contracts/vault/modules/viewModule/main.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../../common/helpers.sol\\\";\\n\\ncontract ViewModule is Helpers {\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"Helpers__EulerDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helpers__NotRebalancer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helpers__Reentrant\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Helpers__UnsupportedProtocolId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"aggrMaxVaultRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"}],\"name\":\"borrowBalanceMorphoAaveV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBalance_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"}],\"name\":\"collateralBalanceMorphoAaveV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralBalance_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNetAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAssets_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netAssets_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aggregatedRatio_\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInStETH\",\"name\":\"aaveV2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInWstETH\",\"name\":\"aaveV3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInWstETH\",\"name\":\"compoundV3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInWstETH\",\"name\":\"euler\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInStETH\",\"name\":\"morphoAaveV2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInWstETH\",\"name\":\"morphoAaveV3\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInWstETH\",\"name\":\"spark\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.ProtocolAssetsInWstETH\",\"name\":\"fluid\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.IdealBalances\",\"name\":\"vaultBalances\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wstETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wETH\",\"type\":\"uint256\"}],\"internalType\":\"struct Helpers.IdealBalances\",\"name\":\"dsaBalances\",\"type\":\"tuple\"}],\"internalType\":\"struct Helpers.NetAssetsHelper\",\"name\":\"assets_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"protocolId_\",\"type\":\"uint8\"}],\"name\":\"getProtocolRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRatioAaveV2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthPerWsteth_\",\"type\":\"uint256\"}],\"name\":\"getRatioAaveV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wstEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthPerWsteth_\",\"type\":\"uint256\"}],\"name\":\"getRatioCompoundV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wstEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthPerWsteth_\",\"type\":\"uint256\"}],\"name\":\"getRatioEuler\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wstEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthPerWsteth_\",\"type\":\"uint256\"}],\"name\":\"getRatioFluid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wstEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRatioMorphoAaveV2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmountPool_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmountP2P_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmountPool_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmountP2P_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthPerWsteth_\",\"type\":\"uint256\"}],\"name\":\"getRatioMorphoAaveV3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wstEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stEthPerWsteth_\",\"type\":\"uint256\"}],\"name\":\"getRatioSpark\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wstEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stETHAmount_\",\"type\":\"uint256\"}],\"name\":\"getWithdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRebalancer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leverageMaxUnitAmountLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"maxRiskRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queuedWithdrawStEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot_\",\"type\":\"bytes32\"}],\"name\":\"readFromStorage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenueExchangePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenueFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondaryAuth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultDSA\",\"outputs\":[{\"internalType\":\"contract IDSA\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFeeAbsoluteMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ViewModule", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}