{"SourceCode": "pragma solidity ^0.4.18;\r\n\r\n\r\ncontract FUTR {\r\n\r\n    uint256 constant MAX_UINT256 = 2**256 - 1;\r\n    \r\n    uint256 MAX_SUBMITTED = 500067157619455000000000;\r\n\r\n    // (no premine)\r\n    uint256 _totalSupply = 0;\r\n    \r\n    // The following 2 variables are essentially a lookup table.\r\n    // They are not constant because they are memory.\r\n    // I came up with this because calculating it was expensive,\r\n    // especially so when crossing tiers.\r\n    \r\n    // Sum of each tier by ether submitted.\r\n   uint256[] levels = [ \r\n      8771929824561400000000,\r\n     19895525330179400000000,\r\n     37350070784724800000000,\r\n     64114776667077800000000,\r\n     98400490952792100000000,\r\n    148400490952792000000000,\r\n    218400490952792000000000,\r\n    308400490952792000000000,\r\n    415067157619459000000000,\r\n    500067157619455000000000\r\n    ];\r\n    \r\n    // Token amounts for each tier.\r\n    uint256[] ratios = [\r\n      114,\r\n      89,\r\n      55,\r\n      34,\r\n      21,\r\n      13,\r\n       8,\r\n       5,\r\n       3,\r\n       2 ];\r\n     \r\n    // total ether submitted before fees.\r\n    uint256 _submitted = 0;\r\n    \r\n    uint256 public tier = 0;\r\n    \r\n    // ERC20 events.\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n    \r\n    // FUTR events.\r\n    event Mined(address indexed _miner, uint _value);\r\n    event WaitStarted(uint256 endTime);\r\n    event SwapStarted(uint256 endTime);\r\n    event MiningStart(uint256 end_time, uint256 swap_time, uint256 swap_end_time);\r\n    event MiningExtended(uint256 end_time, uint256 swap_time, uint256 swap_end_time);\r\n\r\n \r\n    // Optional ERC20 values.\r\n    string public name = \"Futereum Token\";\r\n    uint8 public decimals = 18;\r\n    string public symbol = \"FUTR\";\r\n    \r\n    // Public variables so the curious can check the state.\r\n    bool public swap = false;\r\n    bool public wait = false;\r\n    bool public extended = false;\r\n    \r\n    // Public end time for the current state.\r\n    uint256 public endTime;\r\n    \r\n    // These are calculated at mining start.\r\n    uint256 swapTime;\r\n    uint256 swapEndTime;\r\n    uint256 endTimeExtended;\r\n    uint256 swapTimeExtended;\r\n    uint256 swapEndTimeExtended;\r\n    \r\n    // Pay rate calculated from balance later.\r\n    uint256 public payRate = 0;\r\n    \r\n    // Fee variables.  Fees are reserved and then withdrawn  later.\r\n    uint256 submittedFeesPaid = 0;\r\n    uint256 penalty = 0;\r\n    uint256 reservedFees = 0;\r\n    \r\n    // Storage.\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n   // Fallback function mines the tokens.\r\n   // Send from a wallet you control.\r\n   // DON'T send from an exchange wallet!\r\n   // We recommend sending using a method that calculates gas for you.\r\n   // Here are some estimates (not guaranteed to be accurate):\r\n   // It usually costs around 90k gas.  It cost more if you cross a tier.\r\n   // Maximum around 190k gas.\r\n   function () external payable {\r\n   \r\n       require(msg.sender != address(0) &&\r\n                tier != 10 &&\r\n                swap == false &&\r\n                wait == false);\r\n    \r\n        uint256 issued = mint(msg.sender, msg.value);\r\n        \r\n        Mined(msg.sender, issued);\r\n        Transfer(this, msg.sender, issued);\r\n    }\r\n    \r\n    // Constructor.\r\n    function FUTR() public {\r\n        _start();\r\n    }\r\n    \r\n    // This gets called by constructor AND after the swap to restart evertying.\r\n    function _start() internal \r\n    {\r\n        swap = false;\r\n        wait = false;\r\n        extended = false;\r\n    \r\n        endTime = now + 366 days;\r\n        swapTime = endTime + 30 days;\r\n        swapEndTime = swapTime + 5 days;\r\n        endTimeExtended = now + 1096 days;\r\n        swapTimeExtended = endTimeExtended + 30 days;\r\n        swapEndTimeExtended = swapTimeExtended + 5 days;\r\n        \r\n        submittedFeesPaid = 0;\r\n        _submitted = 0;\r\n        \r\n        reservedFees = 0;\r\n        \r\n        payRate = 0;\r\n        \r\n        tier = 0;\r\n                \r\n        MiningStart(endTime, swapTime, swapEndTime);\r\n    }\r\n    \r\n    // Restarts everything after swap.\r\n    // This is expensive, so we make someone call it and pay for the gas.\r\n    // Any holders that miss the swap get to keep their tokens.\r\n    // Ether stays in contract, minus 20% penalty fee.\r\n    function restart() public {\r\n        require(swap && now >= endTime);\r\n        \r\n        penalty = this.balance * 2000 / 10000;\r\n        \r\n        payFees();\r\n        \r\n        _start();\r\n    }\r\n    \r\n    // ERC20 standard supply function.\r\n    function totalSupply() public constant returns (uint)\r\n    {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    // Mints new tokens when they are mined.\r\n    function mint(address _to, uint256 _value) internal returns (uint256) \r\n    {\r\n        uint256 total = _submitted + _value;\r\n        \r\n        if (total > MAX_SUBMITTED)\r\n        {\r\n            uint256 refund = total - MAX_SUBMITTED - 1;\r\n            _value = _value - refund;\r\n            \r\n            // refund money and continue.\r\n            _to.transfer(refund);\r\n        }\r\n        \r\n        _submitted += _value;\r\n        \r\n        total -= refund;\r\n        \r\n        uint256 tokens = calculateTokens(total, _value);\r\n        \r\n        balances[_to] += tokens;\r\n       \r\n        _totalSupply += tokens;\r\n        \r\n        return tokens;\r\n    }\r\n    \r\n    // Calculates the tokens mined based on the tier.\r\n    function calculateTokens(uint256 total, uint256 _value) internal returns (uint256)\r\n    {\r\n        if (tier == 10) \r\n        {\r\n            // This just rounds it off to an even number.\r\n            return 7400000000;\r\n        }\r\n        \r\n        uint256 tokens = 0;\r\n        \r\n        if (total > levels[tier])\r\n        {\r\n            uint256 remaining = total - levels[tier];\r\n            _value -= remaining;\r\n            tokens = (_value) * ratios[tier];\r\n           \r\n            tier += 1;\r\n            \r\n            tokens += calculateTokens(total, remaining);\r\n        }\r\n        else\r\n        {\r\n            tokens = _value * ratios[tier];\r\n        }\r\n        \r\n        return tokens;\r\n    }\r\n    \r\n    // This is basically so you don't have to add 1 to the last completed tier.\r\n    //  You're welcome.\r\n    function currentTier() public view returns (uint256) {\r\n        if (tier == 10)\r\n        {\r\n            return 10;\r\n        }\r\n        else\r\n        {\r\n            return tier + 1;\r\n        }\r\n    }\r\n    \r\n    // Ether remaining for tier.\r\n    function leftInTier() public view returns (uint256) {\r\n        if (tier == 10) {\r\n            return 0;\r\n        }\r\n        else\r\n        {\r\n            return levels[tier] - _submitted;\r\n        }\r\n    }\r\n    \r\n    // Total sumbitted for mining.\r\n    function submitted() public view returns (uint256) {\r\n        return _submitted;\r\n    }\r\n    \r\n    // Balance minus oustanding fees.\r\n    function balanceMinusFeesOutstanding() public view returns (uint256) {\r\n        return this.balance - (penalty + (_submitted - submittedFeesPaid) * 1530 / 10000);  // fees are 15.3 % total.\r\n    }\r\n    \r\n    // Calculates the amount of ether per token from the balance.\r\n    // This is calculated once by the first account to swap.\r\n    function calulateRate() internal {\r\n        reservedFees = penalty + (_submitted - submittedFeesPaid) * 1530 / 10000;  // fees are 15.3 % total.\r\n        \r\n        uint256 tokens = _totalSupply / 1 ether;\r\n        payRate = (this.balance - reservedFees);\r\n\r\n        payRate = payRate / tokens;\r\n    }\r\n    \r\n    // This function is called on token transfer and fee payment.\r\n    // It checks the next deadline and then updates the deadline and state.\r\n    // \r\n    // It uses the block time, but the time periods are days and months,\r\n    // so it should be pretty safe  \u00af\\_(\u30c4)_/\u00af \r\n    function _updateState() internal {\r\n        // Most of the time, this will just be skipped.\r\n        if (now >= endTime)\r\n        {\r\n            // We are not currently swapping or waiting to swap\r\n            if(!swap && !wait)\r\n            {\r\n                if (extended)\r\n                {\r\n                    // It's been 36 months.\r\n                    wait = true;\r\n                    endTime = swapTimeExtended;\r\n                    WaitStarted(endTime);\r\n                }\r\n                else if (tier == 10)\r\n                {\r\n                    // Tiers filled\r\n                    wait = true;\r\n                    endTime = swapTime;\r\n                    WaitStarted(endTime);\r\n                } \r\n                else\r\n                {\r\n                    // Extended to 36 months\r\n                    endTime = endTimeExtended;\r\n                    extended = true;\r\n                    \r\n                    MiningExtended(endTime, swapTime, swapEndTime);\r\n                }\r\n            } \r\n            else if (wait)\r\n            {\r\n                // It's time to swap.\r\n                swap = true;\r\n                wait = false;\r\n                \r\n                if (extended) \r\n                {\r\n                    endTime = swapEndTimeExtended;\r\n                }\r\n                else\r\n                {\r\n                    endTime = swapEndTime;\r\n                }\r\n                \r\n                SwapStarted(endTime);\r\n            }\r\n        }\r\n    }\r\n   \r\n    // Standard ERC20 transfer plus state check and token swap logic.\r\n    //\r\n    // We recommend sending using a method that calculates gas for you.\r\n    //\r\n    // Here are some estimates (not guaranteed to be accurate):\r\n    // It usually costs around 37k gas.  It cost more if the state changes.\r\n    // State change means around 55k - 65k gas.\r\n    // Swapping tokens for ether costs around 46k gas. (around 93k for the first account to swap)\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        \r\n        require(balances[msg.sender] >= _value);\r\n        \r\n         // Normal transfers check if time is expired.  \r\n        _updateState();\r\n\r\n        // Check if sending in for swap.\r\n        if (_to == address(this)) \r\n        {\r\n            // throw if they can't swap yet.\r\n            require(swap);\r\n            \r\n            if (payRate == 0)\r\n            {\r\n                calulateRate(); // Gas to calc the rate paid by first unlucky soul.\r\n            }\r\n            \r\n            uint256 amount = _value * payRate;\r\n            // Adjust for decimals\r\n            amount /= 1 ether;\r\n            \r\n            // Burn tokens.\r\n            balances[msg.sender] -= _value;\r\n             _totalSupply -= _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            \r\n            //send ether\r\n            msg.sender.transfer(amount);\r\n        } else\r\n        {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    // Standard ERC20.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n       \r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // Standard ERC20.\r\n    function balanceOf(address _owner) view public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    // Standard ERC20.\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n    \r\n    // ********************\r\n    // Fee stuff.\r\n\r\n    // Addresses for fees.\r\n    address public foundation = 0x950ec4ef693d90f8519c4213821e462426d30905;\r\n    address public owner = 0x78BFCA5E20B0D710EbEF98249f68d9320eE423be;\r\n    address public dev = 0x5d2b9f5345e69e2390ce4c26ccc9c2910a097520;\r\n    \r\n    // Pays fees to the foundation, the owner, and the dev.\r\n    // It also updates the state.  Anyone can call this.\r\n    function payFees() public {\r\n         // Check state to see if swap needs to happen.\r\n         _updateState();\r\n         \r\n        uint256 fees = penalty + (_submitted - submittedFeesPaid) * 1530 / 10000;  // fees are 15.3 % total.\r\n        submittedFeesPaid = _submitted;\r\n        \r\n        reservedFees = 0;\r\n        penalty = 0;\r\n        \r\n        if (fees > 0) \r\n        {\r\n            foundation.transfer(fees / 2);\r\n            owner.transfer(fees / 4);\r\n            dev.transfer(fees / 4);\r\n        }\r\n    }\r\n    \r\n    function changeFoundation (address _receiver) public\r\n    {\r\n        require(msg.sender == foundation);\r\n        foundation = _receiver;\r\n    }\r\n    \r\n    \r\n    function changeOwner (address _receiver) public\r\n    {\r\n        require(msg.sender == owner);\r\n        owner = _receiver;\r\n    }\r\n    \r\n    function changeDev (address _receiver) public\r\n    {\r\n        require(msg.sender == dev);\r\n        dev = _receiver;\r\n    }    \r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceMinusFeesOutstanding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wait\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"changeFoundation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extended\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"submitted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"changeDev\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leftInTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_miner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Mined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"WaitStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"SwapStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"end_time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"swap_time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"swap_end_time\",\"type\":\"uint256\"}],\"name\":\"MiningStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"end_time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"swap_time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"swap_end_time\",\"type\":\"uint256\"}],\"name\":\"MiningExtended\",\"type\":\"event\"}]", "ContractName": "FUTR", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://0e1f6ef7222650f9aa3fc1a5c68b59e8274615befce0b79f66062dc0b5c00df4"}