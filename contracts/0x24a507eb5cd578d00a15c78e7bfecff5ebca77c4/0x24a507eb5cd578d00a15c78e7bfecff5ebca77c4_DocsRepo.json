{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lib/DocsRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nlibrary DocsRepo {\\n    \\n    struct Head {\\n        uint32 typeOfDoc;\\n        uint32 version;\\n        uint64 seqOfDoc;\\n        uint40 author;\\n        uint40 creator;\\n        uint48 createDate;\\n    }\\n \\n    struct Body {\\n        uint64 seq;\\n        address addr;\\n    }\\n\\n    struct Doc {\\n        Head head;\\n        address body;\\n    }\\n\\n    struct Repo {\\n        // typeOfDoc => version => seqOfDoc => Body\\n        mapping(uint256 => mapping(uint256 => mapping(uint256 => Body))) bodies;\\n        mapping(address => Head) heads;\\n    }\\n\\n    //##################\\n    //##  Write I/O   ##\\n    //##################\\n\\n    function snParser(bytes32 sn) public pure returns(Head memory head) {\\n        uint _sn = uint(sn);\\n\\n        head.typeOfDoc = uint32(_sn >> 224);\\n        head.version = uint32(_sn >> 192);\\n        head.seqOfDoc = uint64(_sn >> 128);\\n        head.author = uint40(_sn >> 88);\\n    }\\n\\n    function codifyHead(Head memory head) public pure returns(bytes32 sn) {\\n        bytes memory _sn = abi.encodePacked(\\n                            head.typeOfDoc,\\n                            head.version,\\n                            head.seqOfDoc,\\n                            head.author,\\n                            head.creator,\\n                            head.createDate);  \\n        assembly {\\n            sn := mload(add(_sn, 0x20))\\n        }\\n    }\\n\\n    function setTemplate(\\n        Repo storage repo,\\n        uint typeOfDoc, \\n        address body,\\n        uint author,\\n        uint caller\\n    ) public returns (Head memory head) {\\n        head.typeOfDoc = uint32(typeOfDoc);\\n        head.author = uint40(author);\\n        head.creator = uint40(caller);\\n\\n        require(body != address(0), \\\"DR.setTemplate: zero address\\\");\\n        require(head.typeOfDoc > 0, \\\"DR.setTemplate: zero typeOfDoc\\\");\\n        if (head.typeOfDoc > counterOfTypes(repo))\\n            head.typeOfDoc = _increaseCounterOfTypes(repo);\\n\\n        require(head.author > 0, \\\"DR.setTemplate: zero author\\\");\\n        require(head.creator > 0, \\\"DR.setTemplate: zero creator\\\");\\n        // if (counterOfVersions(repo, typeOfDoc) > 0)\\n        //     require( repo.heads[repo.bodies[head.typeOfDoc][1][0].addr].creator \\n        //         == head.creator, \\\"DR.setTemplate: not Template creator\\\");\\n\\n        head.version = _increaseCounterOfVersions(repo, head.typeOfDoc);\\n        head.createDate = uint48(block.timestamp);\\n\\n        repo.bodies[head.typeOfDoc][head.version][0].addr = body;\\n        repo.heads[body] = head;\\n    }\\n\\n    function createDoc(\\n        Repo storage repo, \\n        bytes32 snOfDoc,\\n        uint creator\\n    ) public returns (Doc memory doc)\\n    {\\n        doc.head = snParser(snOfDoc);\\n        doc.head.creator = uint40(creator);\\n\\n        require(doc.head.typeOfDoc > 0, \\\"DR.createDoc: zero typeOfDoc\\\");\\n        require(doc.head.version > 0, \\\"DR.createDoc: zero version\\\");\\n        require(doc.head.creator > 0, \\\"DR.createDoc: zero creator\\\");\\n\\n        address temp = repo.bodies[doc.head.typeOfDoc][doc.head.version][0].addr;\\n        require(temp != address(0), \\\"DR.createDoc: template not ready\\\");\\n\\n        doc.head.author = repo.heads[temp].author;\\n        doc.head.seqOfDoc = _increaseCounterOfDocs(repo, doc.head.typeOfDoc, doc.head.version);            \\n        doc.head.createDate = uint48(block.timestamp);\\n\\n        doc.body = _createClone(temp);\\n\\n        repo.bodies[doc.head.typeOfDoc][doc.head.version][doc.head.seqOfDoc].addr = doc.body;\\n        repo.heads[doc.body] = doc.head;\\n\\n    }\\n\\n    function transferIPR(\\n        Repo storage repo,\\n        uint typeOfDoc,\\n        uint version,\\n        uint transferee,\\n        uint caller \\n    ) public {\\n        require (caller == getAuthor(repo, typeOfDoc, version),\\n            \\\"DR.transferIPR: not author\\\");\\n        repo.heads[repo.bodies[typeOfDoc][version][0].addr].author = uint40(transferee);\\n    }\\n\\n    function _increaseCounterOfTypes(Repo storage repo) \\n        private returns(uint32) \\n    {\\n        repo.bodies[0][0][0].seq++;\\n        return uint32(repo.bodies[0][0][0].seq);\\n    }\\n\\n    function _increaseCounterOfVersions(\\n        Repo storage repo, \\n        uint256 typeOfDoc\\n    ) private returns(uint32) {\\n        repo.bodies[typeOfDoc][0][0].seq++;\\n        return uint32(repo.bodies[typeOfDoc][0][0].seq);\\n    }\\n\\n    function _increaseCounterOfDocs(\\n        Repo storage repo, \\n        uint256 typeOfDoc, \\n        uint256 version\\n    ) private returns(uint64) {\\n        repo.bodies[typeOfDoc][version][0].seq++;\\n        return repo.bodies[typeOfDoc][version][0].seq;\\n    }\\n\\n    // ==== CloneFactory ====\\n\\n/*\\nThe MIT License (MIT)\\nCopyright (c) 2018 Murray Software, LLC.\\nPermission is hereby granted, free of charge, to any person obtaining\\na copy of this software and associated documentation files (the\\n\\\"Software\\\"), to deal in the Software without restriction, including\\nwithout limitation the rights to use, copy, modify, merge, publish,\\ndistribute, sublicense, and/or sell copies of the Software, and to\\npermit persons to whom the Software is furnished to do so, subject to\\nthe following conditions:\\nThe above copyright notice and this permission notice shall be included\\nin all copies or substantial portions of the Software.\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n*/\\n//solhint-disable max-line-length\\n//solhint-disable no-inline-assembly\\n\\n\\n    function _createClone(address temp) private returns (address result) {\\n        bytes20 tempBytes = bytes20(temp);\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(\\n                clone,\\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\\n            )\\n            mstore(add(clone, 0x14), tempBytes)\\n            mstore(\\n                add(clone, 0x28),\\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\\n            )\\n            result := create(0, clone, 0x37)\\n        }\\n    }\\n\\n    function _isClone(address temp, address query)\\n        private view returns (bool result)\\n    {\\n        bytes20 tempBytes = bytes20(temp);\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(\\n                clone,\\n                0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000\\n            )\\n            mstore(add(clone, 0xa), tempBytes)\\n            mstore(\\n                add(clone, 0x1e),\\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\\n            )\\n\\n            let other := add(clone, 0x40)\\n            extcodecopy(query, other, 0, 0x2d)\\n            result := and(\\n                eq(mload(clone), mload(other)),\\n                eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\\n            )\\n        }\\n    }\\n\\n    //##################\\n    //##   read I/O   ##\\n    //##################\\n\\n\\n    function counterOfTypes(Repo storage repo) public view returns(uint32) {\\n        return uint32(repo.bodies[0][0][0].seq);\\n    }\\n\\n    function counterOfVersions(Repo storage repo, uint typeOfDoc) public view returns(uint32) {\\n        return uint32(repo.bodies[uint32(typeOfDoc)][0][0].seq);\\n    }\\n\\n    function counterOfDocs(Repo storage repo, uint typeOfDoc, uint version) public view returns(uint64) {\\n        return repo.bodies[uint32(typeOfDoc)][uint32(version)][0].seq;\\n    }\\n\\n    function getAuthor(\\n        Repo storage repo,\\n        uint typeOfDoc,\\n        uint version\\n    ) public view returns(uint40) {\\n        address temp = repo.bodies[typeOfDoc][version][0].addr;\\n        require(temp != address(0), \\\"getAuthor: temp not exist\\\");\\n\\n        return repo.heads[temp].author;\\n    }\\n\\n    function getAuthorByBody(\\n        Repo storage repo,\\n        address body\\n    ) public view returns(uint40) {\\n        Head memory head = getHeadByBody(repo, body);\\n        return getAuthor(repo, head.typeOfDoc, head.version);\\n    }\\n\\n    function docExist(Repo storage repo, address body) public view returns(bool) {\\n        Head memory head = repo.heads[body];\\n        if (   body == address(0) \\n            || head.typeOfDoc == 0 \\n            || head.version == 0 \\n            || head.seqOfDoc == 0\\n        ) return false;\\n   \\n        return repo.bodies[head.typeOfDoc][head.version][head.seqOfDoc].addr == body;\\n    }\\n\\n    function getHeadByBody(\\n        Repo storage repo,\\n        address body\\n    ) public view returns (Head memory ) {\\n        return repo.heads[body];\\n    }\\n\\n\\n    function getDoc(\\n        Repo storage repo,\\n        bytes32 snOfDoc\\n    ) public view returns(Doc memory doc) {\\n        doc.head = snParser(snOfDoc);\\n\\n        doc.body = repo.bodies[doc.head.typeOfDoc][doc.head.version][doc.head.seqOfDoc].addr;\\n        doc.head = repo.heads[doc.body];\\n    }\\n\\n    function getVersionsList(\\n        Repo storage repo,\\n        uint typeOfDoc\\n    ) public view returns(Doc[] memory)\\n    {\\n        uint32 len = counterOfVersions(repo, typeOfDoc);\\n        Doc[] memory out = new Doc[](len);\\n\\n        while (len > 0) {\\n            Head memory head;\\n            head.typeOfDoc = uint32(typeOfDoc);\\n            head.version = len;\\n\\n            out[len - 1] = getDoc(repo, codifyHead(head));\\n            len--;\\n        }\\n\\n        return out;\\n    }\\n\\n    function getDocsList(\\n        Repo storage repo,\\n        bytes32 snOfDoc\\n    ) public view returns(Doc[] memory) {\\n        Head memory head = snParser(snOfDoc);\\n                \\n        uint64 len = counterOfDocs(repo, head.typeOfDoc, head.version);\\n        Doc[] memory out = new Doc[](len);\\n\\n        while (len > 0) {\\n            head.seqOfDoc = len;\\n            out[len - 1] = getDoc(repo, codifyHead(head));\\n            len--;\\n        }\\n\\n        return out;\\n    }\\n\\n    function verifyDoc(\\n        Repo storage repo, \\n        bytes32 snOfDoc\\n    ) public view returns(bool) {\\n        Head memory head = snParser(snOfDoc);\\n\\n        address temp = repo.bodies[head.typeOfDoc][head.version][0].addr;\\n        address target = repo.bodies[head.typeOfDoc][head.version][head.seqOfDoc].addr;\\n\\n        return _isClone(temp, target);\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"typeOfDoc\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"seqOfDoc\",\"type\":\"uint64\"},{\"internalType\":\"uint40\",\"name\":\"author\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"creator\",\"type\":\"uint40\"},{\"internalType\":\"uint48\",\"name\":\"createDate\",\"type\":\"uint48\"}],\"internalType\":\"struct DocsRepo.Head\",\"name\":\"head\",\"type\":\"tuple\"}],\"name\":\"codifyHead\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"sn\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sn\",\"type\":\"bytes32\"}],\"name\":\"snParser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"typeOfDoc\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"seqOfDoc\",\"type\":\"uint64\"},{\"internalType\":\"uint40\",\"name\":\"author\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"creator\",\"type\":\"uint40\"},{\"internalType\":\"uint48\",\"name\":\"createDate\",\"type\":\"uint48\"}],\"internalType\":\"struct DocsRepo.Head\",\"name\":\"head\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "DocsRepo", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}