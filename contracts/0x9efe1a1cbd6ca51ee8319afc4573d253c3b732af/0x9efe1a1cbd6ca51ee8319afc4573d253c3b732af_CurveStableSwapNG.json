{"SourceCode": "# pragma version 0.3.10\r\n# pragma optimize codesize\r\n# pragma evm-version shanghai\r\n\"\"\"\r\n@title CurveStableSwapNG\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n@notice Stableswap implementation for up to 8 coins with no rehypothecation,\r\n        i.e. the AMM does not deposit tokens into other contracts. The Pool contract also\r\n        records exponential moving averages for coins relative to coin 0.\r\n@dev Asset Types:\r\n        0. Standard ERC20 token with no additional features.\r\n                          Note: Users are advised to do careful due-diligence on\r\n                                ERC20 tokens that they interact with, as this\r\n                                contract cannot differentiate between harmless and\r\n                                malicious ERC20 tokens.\r\n        1. Oracle - token with rate oracle (e.g. wstETH)\r\n                    Note: Oracles may be controlled externally by an EOA. Users\r\n                          are advised to proceed with caution.\r\n        2. Rebasing - token with rebase (e.g. stETH).\r\n                      Note: Users and Integrators are advised to understand how\r\n                            the AMM contract works with rebasing balances.\r\n        3. ERC4626 - token with convertToAssets method (e.g. sDAI).\r\n                     Note: Some ERC4626 implementations may be susceptible to\r\n                           Donation/Inflation attacks. Users are advised to\r\n                           proceed with caution.\r\n        NOTE: Pool Cannot support tokens with multiple asset types: e.g. ERC4626\r\n              with fees are not supported.\r\n     Supports:\r\n        1. ERC20 support for return True/revert, return True/False, return None\r\n        2. ERC20 tokens can have arbitrary decimals (<=18).\r\n        3. ERC20 tokens that rebase (either positive or fee on transfer)\r\n        4. ERC20 tokens that have a rate oracle (e.g. wstETH, cbETH, sDAI, etc.)\r\n           Note: Oracle precision _must_ be 10**18.\r\n        5. ERC4626 tokens with arbitrary precision (<=18) of Vault token and underlying\r\n           asset.\r\n     Additional features include:\r\n        1. Adds price oracles based on AMM State Price (and _not_ last traded price).\r\n        2. Adds TVL oracle based on D.\r\n        3. `exchange_received`: swaps that expect an ERC20 transfer to have occurred\r\n           prior to executing the swap.\r\n           Note: a. If pool contains rebasing tokens and one of the `asset_types` is 2 (Rebasing)\r\n                    then calling `exchange_received` will REVERT.\r\n                 b. If pool contains rebasing token and `asset_types` does not contain 2 (Rebasing)\r\n                    then this is an incorrect implementation and rebases can be\r\n                    stolen.\r\n        4. Adds `get_dx`: Similar to `get_dy` which returns an expected output\r\n           of coin[j] for given `dx` amount of coin[i], `get_dx` returns expected\r\n           input of coin[i] for an output amount of coin[j].\r\n        5. Fees are dynamic: AMM will charge a higher fee if pool depegs. This can cause very\r\n                             slight discrepancies between calculated fees and realised fees.\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\nfrom vyper.interfaces import ERC20Detailed\r\nfrom vyper.interfaces import ERC4626\r\n\r\nimplements: ERC20\r\n\r\n# ------------------------------- Interfaces ---------------------------------\r\n\r\ninterface Factory:\r\n    def fee_receiver() -> address: view\r\n    def admin() -> address: view\r\n    def views_implementation() -> address: view\r\n\r\ninterface ERC1271:\r\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes32: view\r\n\r\ninterface StableSwapViews:\r\n    def get_dx(i: int128, j: int128, dy: uint256, pool: address) -> uint256: view\r\n    def get_dy(i: int128, j: int128, dx: uint256, pool: address) -> uint256: view\r\n    def dynamic_fee(i: int128, j: int128, pool: address) -> uint256: view\r\n    def calc_token_amount(\r\n        _amounts: DynArray[uint256, MAX_COINS],\r\n        _is_deposit: bool,\r\n        _pool: address\r\n    ) -> uint256: view\r\n\r\n# --------------------------------- Events -----------------------------------\r\n\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    value: uint256\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    value: uint256\r\n\r\nevent TokenExchange:\r\n    buyer: indexed(address)\r\n    sold_id: int128\r\n    tokens_sold: uint256\r\n    bought_id: int128\r\n    tokens_bought: uint256\r\n\r\nevent TokenExchangeUnderlying:\r\n    buyer: indexed(address)\r\n    sold_id: int128\r\n    tokens_sold: uint256\r\n    bought_id: int128\r\n    tokens_bought: uint256\r\n\r\nevent AddLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: DynArray[uint256, MAX_COINS]\r\n    fees: DynArray[uint256, MAX_COINS]\r\n    invariant: uint256\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: DynArray[uint256, MAX_COINS]\r\n    fees: DynArray[uint256, MAX_COINS]\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidityOne:\r\n    provider: indexed(address)\r\n    token_id: int128\r\n    token_amount: uint256\r\n    coin_amount: uint256\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidityImbalance:\r\n    provider: indexed(address)\r\n    token_amounts: DynArray[uint256, MAX_COINS]\r\n    fees: DynArray[uint256, MAX_COINS]\r\n    invariant: uint256\r\n    token_supply: uint256\r\n\r\nevent RampA:\r\n    old_A: uint256\r\n    new_A: uint256\r\n    initial_time: uint256\r\n    future_time: uint256\r\n\r\nevent StopRampA:\r\n    A: uint256\r\n    t: uint256\r\n\r\nevent ApplyNewFee:\r\n    fee: uint256\r\n    offpeg_fee_multiplier: uint256\r\n\r\nevent SetNewMATime:\r\n    ma_exp_time: uint256\r\n    D_ma_time: uint256\r\n\r\n\r\nMAX_COINS: constant(uint256) = 8  # max coins is 8 in the factory\r\nMAX_COINS_128: constant(int128) = 8\r\n\r\n# ---------------------------- Pool Variables --------------------------------\r\n\r\nN_COINS: public(immutable(uint256))\r\nN_COINS_128: immutable(int128)\r\nPRECISION: constant(uint256) = 10 ** 18\r\n\r\nfactory: immutable(Factory)\r\ncoins: public(immutable(DynArray[address, MAX_COINS]))\r\nasset_types: immutable(DynArray[uint8, MAX_COINS])\r\npool_contains_rebasing_tokens: immutable(bool)\r\nstored_balances: DynArray[uint256, MAX_COINS]\r\n\r\n# Fee specific vars\r\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\r\nfee: public(uint256)  # fee * 1e10\r\noffpeg_fee_multiplier: public(uint256)  # * 1e10\r\nadmin_fee: public(constant(uint256)) = 5000000000\r\nMAX_FEE: constant(uint256) = 5 * 10 ** 9\r\n\r\n# ---------------------- Pool Amplification Parameters -----------------------\r\n\r\nA_PRECISION: constant(uint256) = 100\r\nMAX_A: constant(uint256) = 10 ** 6\r\nMAX_A_CHANGE: constant(uint256) = 10\r\n\r\ninitial_A: public(uint256)\r\nfuture_A: public(uint256)\r\ninitial_A_time: public(uint256)\r\nfuture_A_time: public(uint256)\r\n\r\n# ---------------------------- Admin Variables -------------------------------\r\n\r\nMIN_RAMP_TIME: constant(uint256) = 86400\r\nadmin_balances: public(DynArray[uint256, MAX_COINS])\r\n\r\n# ----------------------- Oracle Specific vars -------------------------------\r\n\r\nrate_multipliers: immutable(DynArray[uint256, MAX_COINS])\r\n# [bytes4 method_id][bytes8 <empty>][bytes20 oracle]\r\nrate_oracles: immutable(DynArray[uint256, MAX_COINS])\r\n\r\n# For ERC4626 tokens, we need:\r\ncall_amount: immutable(DynArray[uint256, MAX_COINS])\r\nscale_factor: immutable(DynArray[uint256, MAX_COINS])\r\n\r\nlast_prices_packed: DynArray[uint256, MAX_COINS]  #  packing: last_price, ma_price\r\nlast_D_packed: uint256                            #  packing: last_D, ma_D\r\nma_exp_time: public(uint256)\r\nD_ma_time: public(uint256)\r\nma_last_time: public(uint256)                     # packing: ma_last_time_p, ma_last_time_D\r\n# ma_last_time has a distinction for p and D because p is _not_ updated if\r\n# users remove_liquidity, but D is.\r\n\r\n# shift(2**32 - 1, 224)\r\nORACLE_BIT_MASK: constant(uint256) = (2**32 - 1) * 256**28\r\n\r\n# --------------------------- ERC20 Specific Vars ----------------------------\r\n\r\nname: public(immutable(String[64]))\r\nsymbol: public(immutable(String[32]))\r\ndecimals: public(constant(uint8)) = 18\r\nversion: public(constant(String[8])) = \"v7.0.0\"\r\n\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowance: public(HashMap[address, HashMap[address, uint256]])\r\ntotal_supply: uint256\r\nnonces: public(HashMap[address, uint256])\r\n\r\n# keccak256(\"isValidSignature(bytes32,bytes)\")[:4] << 224\r\nERC1271_MAGIC_VAL: constant(bytes32) = 0x1626ba7e00000000000000000000000000000000000000000000000000000000\r\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\")\r\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\r\n\r\nVERSION_HASH: constant(bytes32) = keccak256(version)\r\nNAME_HASH: immutable(bytes32)\r\nCACHED_CHAIN_ID: immutable(uint256)\r\nsalt: public(immutable(bytes32))\r\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\r\n\r\n\r\n# ------------------------------ AMM Setup -----------------------------------\r\n\r\n\r\n@external\r\ndef __init__(\r\n    _name: String[32],\r\n    _symbol: String[10],\r\n    _A: uint256,\r\n    _fee: uint256,\r\n    _offpeg_fee_multiplier: uint256,\r\n    _ma_exp_time: uint256,\r\n    _coins: DynArray[address, MAX_COINS],\r\n    _rate_multipliers: DynArray[uint256, MAX_COINS],\r\n    _asset_types: DynArray[uint8, MAX_COINS],\r\n    _method_ids: DynArray[bytes4, MAX_COINS],\r\n    _oracles: DynArray[address, MAX_COINS],\r\n):\r\n    \"\"\"\r\n    @notice Initialize the pool contract\r\n    @param _name Name of the new plain pool.\r\n    @param _symbol Symbol for the new plain pool.\r\n    @param _A Amplification co-efficient - a lower value here means\r\n              less tolerance for imbalance within the pool's assets.\r\n              Suggested values include:\r\n               * Uncollateralized algorithmic stablecoins: 5-10\r\n               * Non-redeemable, collateralized assets: 100\r\n               * Redeemable assets: 200-400\r\n    @param _fee Trade fee, given as an integer with 1e10 precision. The\r\n                the maximum is 1% (100000000).\r\n                50% of the fee is distributed to veCRV holders.\r\n    @param _offpeg_fee_multiplier A multiplier that determines how much to increase\r\n                                  Fees by when assets in the AMM depeg. Example value: 20000000000\r\n    @param _ma_exp_time Averaging window of oracle. Set as time_in_seconds / ln(2)\r\n                        Example: for 10 minute EMA, _ma_exp_time is 600 / ln(2) ~= 866\r\n    @param _coins List of addresses of the coins being used in the pool.\r\n    @param _rate_multipliers An array of: [10 ** (36 - _coins[n].decimals()), ... for n in range(N_COINS)]\r\n    @param _asset_types Array of uint8 representing tokens in pool\r\n    @param _method_ids Array of first four bytes of the Keccak-256 hash of the function signatures\r\n                       of the oracle addresses that gives rate oracles.\r\n                       Calculated as: keccak(text=event_signature.replace(\" \", \"\"))[:4]\r\n    @param _oracles Array of rate oracle addresses.\r\n    \"\"\"\r\n\r\n    coins = _coins\r\n    asset_types = _asset_types\r\n    pool_contains_rebasing_tokens = 2 in asset_types\r\n    __n_coins: uint256 = len(_coins)\r\n    N_COINS = __n_coins\r\n    N_COINS_128 = convert(__n_coins, int128)\r\n\r\n    rate_multipliers = _rate_multipliers\r\n\r\n    factory = Factory(msg.sender)\r\n\r\n    A: uint256 = unsafe_mul(_A, A_PRECISION)\r\n    self.initial_A = A\r\n    self.future_A = A\r\n    self.fee = _fee\r\n    self.offpeg_fee_multiplier = _offpeg_fee_multiplier\r\n\r\n    assert _ma_exp_time != 0\r\n    self.ma_exp_time = _ma_exp_time\r\n    self.D_ma_time = 62324  # <--------- 12 hours default on contract start.\r\n    self.ma_last_time = self.pack_2(block.timestamp, block.timestamp)\r\n\r\n    #  ------------------- initialize storage for DynArrays ------------------\r\n\r\n    _call_amount: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\r\n    _scale_factor: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\r\n    _rate_oracles: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\r\n    for i in range(N_COINS_128, bound=MAX_COINS_128):\r\n\r\n        if i < N_COINS_128 - 1:\r\n            self.last_prices_packed.append(self.pack_2(10**18, 10**18))\r\n\r\n        _rate_oracles.append(convert(_method_ids[i], uint256) * 2**224 | convert(_oracles[i], uint256))\r\n        self.stored_balances.append(0)\r\n        self.admin_balances.append(0)\r\n\r\n        if _asset_types[i] == 3:\r\n\r\n            _call_amount.append(10**convert(ERC20Detailed(_coins[i]).decimals(), uint256))\r\n            _underlying_asset: address = ERC4626(_coins[i]).asset()\r\n            _scale_factor.append(10**(18 - convert(ERC20Detailed(_underlying_asset).decimals(), uint256)))\r\n\r\n        else:\r\n\r\n            _call_amount.append(0)\r\n            _scale_factor.append(0)\r\n\r\n    call_amount = _call_amount\r\n    scale_factor = _scale_factor\r\n    rate_oracles = _rate_oracles\r\n\r\n    # ----------------------------- ERC20 stuff ------------------------------\r\n\r\n    name = _name\r\n    symbol = _symbol\r\n\r\n    # EIP712 related params -----------------\r\n    NAME_HASH = keccak256(name)\r\n    salt = block.prevhash\r\n    CACHED_CHAIN_ID = chain.id\r\n    CACHED_DOMAIN_SEPARATOR = keccak256(\r\n        _abi_encode(\r\n            EIP712_TYPEHASH,\r\n            NAME_HASH,\r\n            VERSION_HASH,\r\n            chain.id,\r\n            self,\r\n            salt,\r\n        )\r\n    )\r\n\r\n    # ------------------------ Fire a transfer event -------------------------\r\n\r\n    log Transfer(empty(address), msg.sender, 0)\r\n\r\n\r\n# ------------------ Token transfers in and out of the AMM -------------------\r\n\r\n\r\n@internal\r\ndef _transfer_in(\r\n    coin_idx: int128,\r\n    dx: uint256,\r\n    sender: address,\r\n    expect_optimistic_transfer: bool,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Contains all logic to handle ERC20 token transfers.\r\n    @param coin_idx Index of the coin to transfer in.\r\n    @param dx amount of `_coin` to transfer into the pool.\r\n    @param sender address to transfer `_coin` from.\r\n    @param receiver address to transfer `_coin` to.\r\n    @param expect_optimistic_transfer True if contract expects an optimistic coin transfer\r\n    \"\"\"\r\n    _dx: uint256 = ERC20(coins[coin_idx]).balanceOf(self)\r\n\r\n    # ------------------------- Handle Transfers -----------------------------\r\n\r\n    if expect_optimistic_transfer:\r\n\r\n        _dx = _dx - self.stored_balances[coin_idx]\r\n        assert _dx >= dx\r\n\r\n    else:\r\n\r\n        assert dx > 0  # dev : do not transferFrom 0 tokens into the pool\r\n        assert ERC20(coins[coin_idx]).transferFrom(\r\n            sender, self, dx, default_return_value=True\r\n        )\r\n\r\n        _dx = ERC20(coins[coin_idx]).balanceOf(self) - _dx\r\n\r\n    # --------------------------- Store transferred in amount ---------------------------\r\n\r\n    self.stored_balances[coin_idx] += _dx\r\n\r\n    return _dx\r\n\r\n\r\n@internal\r\ndef _transfer_out(_coin_idx: int128, _amount: uint256, receiver: address):\r\n    \"\"\"\r\n    @notice Transfer a single token from the pool to receiver.\r\n    @dev This function is called by `remove_liquidity` and\r\n         `remove_liquidity_one_coin`, `_exchange`, `_withdraw_admin_fees` and\r\n         `remove_liquidity_imbalance` methods.\r\n    @param _coin_idx Index of the token to transfer out\r\n    @param _amount Amount of token to transfer out\r\n    @param receiver Address to send the tokens to\r\n    \"\"\"\r\n    assert receiver != empty(address)  # dev: do not send tokens to zero_address\r\n\r\n    if not pool_contains_rebasing_tokens:\r\n\r\n        # we need not cache balanceOf pool before swap out\r\n        self.stored_balances[_coin_idx] -= _amount\r\n        assert ERC20(coins[_coin_idx]).transfer(\r\n            receiver, _amount, default_return_value=True\r\n        )\r\n\r\n    else:\r\n\r\n        # cache balances pre and post to account for fee on transfers etc.\r\n        coin_balance: uint256 = ERC20(coins[_coin_idx]).balanceOf(self)\r\n        assert ERC20(coins[_coin_idx]).transfer(\r\n            receiver, _amount, default_return_value=True\r\n        )\r\n        self.stored_balances[_coin_idx] = coin_balance - _amount\r\n\r\n\r\n# -------------------------- AMM Special Methods -----------------------------\r\n\r\n\r\n@view\r\n@internal\r\ndef _stored_rates() -> DynArray[uint256, MAX_COINS]:\r\n    \"\"\"\r\n    @notice Gets rate multipliers for each coin.\r\n    @dev If the coin has a rate oracle that has been properly initialised,\r\n         this method queries that rate by static-calling an external\r\n         contract.\r\n    \"\"\"\r\n    rates: DynArray[uint256, MAX_COINS] = rate_multipliers\r\n\r\n    for i in range(N_COINS_128, bound=MAX_COINS_128):\r\n\r\n        if asset_types[i] == 1 and not rate_oracles[i] == 0:\r\n\r\n            # NOTE: fetched_rate is assumed to be 10**18 precision\r\n            oracle_response: Bytes[32] = raw_call(\r\n                convert(rate_oracles[i] % 2**160, address),\r\n                _abi_encode(rate_oracles[i] & ORACLE_BIT_MASK),\r\n                max_outsize=32,\r\n                is_static_call=True,\r\n            )\r\n            assert len(oracle_response) == 32\r\n            fetched_rate: uint256 = convert(oracle_response, uint256)\r\n\r\n            rates[i] = unsafe_div(rates[i] * fetched_rate, PRECISION)\r\n\r\n        elif asset_types[i] == 3:  # ERC4626\r\n\r\n            # fetched_rate: uint256 = ERC4626(coins[i]).convertToAssets(call_amount[i]) * scale_factor[i]\r\n            # here: call_amount has ERC4626 precision, but the returned value is scaled up to 18\r\n            # using scale_factor which is (18 - n) if underlying asset has n decimals.\r\n            rates[i] = unsafe_div(\r\n                rates[i] * ERC4626(coins[i]).convertToAssets(call_amount[i]) * scale_factor[i],\r\n                PRECISION\r\n            )  # 1e18 precision\r\n\r\n    return rates\r\n\r\n\r\n@view\r\n@internal\r\ndef _balances() -> DynArray[uint256, MAX_COINS]:\r\n    \"\"\"\r\n    @notice Calculates the pool's balances _excluding_ the admin's balances.\r\n    @dev If the pool contains rebasing tokens, this method ensures LPs keep all\r\n            rebases and admin only claims swap fees. This also means that, since\r\n            admin's balances are stored in an array and not inferred from read balances,\r\n            the fees in the rebasing token that the admin collects is immune to\r\n            slashing events.\r\n    \"\"\"\r\n    result: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\r\n    balances_i: uint256 = 0\r\n\r\n    for i in range(N_COINS_128, bound=MAX_COINS_128):\r\n\r\n        if pool_contains_rebasing_tokens:\r\n            # Read balances by gulping to account for rebases\r\n            balances_i = ERC20(coins[i]).balanceOf(self) - self.admin_balances[i]\r\n        else:\r\n            # Use cached balances\r\n            balances_i = self.stored_balances[i] - self.admin_balances[i]\r\n\r\n        result.append(balances_i)\r\n\r\n    return result\r\n\r\n\r\n# -------------------------- AMM Main Functions ------------------------------\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange(\r\n    i: int128,\r\n    j: int128,\r\n    _dx: uint256,\r\n    _min_dy: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange between two coins\r\n    @dev Index values can be found via the `coins` public getter method\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @param _dx Amount of `i` being exchanged\r\n    @param _min_dy Minimum amount of `j` to receive\r\n    @param _receiver Address that receives `j`\r\n    @return Actual amount of `j` received\r\n    \"\"\"\r\n    return self._exchange(\r\n        msg.sender,\r\n        i,\r\n        j,\r\n        _dx,\r\n        _min_dy,\r\n        _receiver,\r\n        False\r\n    )\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange_received(\r\n    i: int128,\r\n    j: int128,\r\n    _dx: uint256,\r\n    _min_dy: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange between two coins without transferring token in\r\n    @dev The contract swaps tokens based on a change in balance of coin[i]. The\r\n         dx = ERC20(coin[i]).balanceOf(self) - self.stored_balances[i]. Users of\r\n         this method are dex aggregators, arbitrageurs, or other users who do not\r\n         wish to grant approvals to the contract: they would instead send tokens\r\n         directly to the contract and call `exchange_received`.\r\n         Note: This is disabled if pool contains rebasing tokens.\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @param _dx Amount of `i` being exchanged\r\n    @param _min_dy Minimum amount of `j` to receive\r\n    @param _receiver Address that receives `j`\r\n    @return Actual amount of `j` received\r\n    \"\"\"\r\n    assert not pool_contains_rebasing_tokens  # dev: exchange_received not supported if pool contains rebasing tokens\r\n    return self._exchange(\r\n        msg.sender,\r\n        i,\r\n        j,\r\n        _dx,\r\n        _min_dy,\r\n        _receiver,\r\n        True,  # <--------------------------------------- swap optimistically.\r\n    )\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef add_liquidity(\r\n    _amounts: DynArray[uint256, MAX_COINS],\r\n    _min_mint_amount: uint256,\r\n    _receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Deposit coins into the pool\r\n    @param _amounts List of amounts of coins to deposit\r\n    @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit\r\n    @param _receiver Address that owns the minted LP tokens\r\n    @return Amount of LP tokens received by depositing\r\n    \"\"\"\r\n    assert _receiver != empty(address)  # dev: do not send LP tokens to zero_address\r\n\r\n    amp: uint256 = self._A()\r\n    old_balances: DynArray[uint256, MAX_COINS] = self._balances()\r\n    rates: DynArray[uint256, MAX_COINS] = self._stored_rates()\r\n\r\n    # Initial invariant\r\n    D0: uint256 = self.get_D_mem(rates, old_balances, amp)\r\n\r\n    total_supply: uint256 = self.total_supply\r\n    new_balances: DynArray[uint256, MAX_COINS] = old_balances\r\n\r\n    # -------------------------- Do Transfers In -----------------------------\r\n\r\n    for i in range(N_COINS_128, bound=MAX_COINS_128):\r\n\r\n        if _amounts[i] > 0:\r\n\r\n            new_balances[i] += self._transfer_in(\r\n                i,\r\n                _amounts[i],\r\n                msg.sender,\r\n                False,  # expect_optimistic_transfer\r\n            )\r\n\r\n        else:\r\n\r\n            assert total_supply != 0  # dev: initial deposit requires all coins\r\n\r\n    # ------------------------------------------------------------------------\r\n\r\n    # Invariant after change\r\n    D1: uint256 = self.get_D_mem(rates, new_balances, amp)\r\n    assert D1 > D0\r\n\r\n    # We need to recalculate the invariant accounting for fees\r\n    # to calculate fair user's share\r\n    fees: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\r\n    mint_amount: uint256 = 0\r\n\r\n    if total_supply > 0:\r\n\r\n        ideal_balance: uint256 = 0\r\n        difference: uint256 = 0\r\n        new_balance: uint256 = 0\r\n\r\n        ys: uint256 = unsafe_div(D0 + D1, N_COINS)\r\n        xs: uint256 = 0\r\n        _dynamic_fee_i: uint256 = 0\r\n\r\n        # Only account for fees if we are not the first to deposit\r\n        base_fee: uint256 = unsafe_div(\r\n            unsafe_mul(self.fee, N_COINS),\r\n            unsafe_mul(4, unsafe_sub(N_COINS, 1))\r\n        )\r\n\r\n        for i in range(N_COINS_128, bound=MAX_COINS_128):\r\n\r\n            ideal_balance = D1 * old_balances[i] / D0\r\n            difference = 0\r\n            new_balance = new_balances[i]\r\n\r\n            if ideal_balance > new_balance:\r\n                difference = unsafe_sub(ideal_balance, new_balance)\r\n            else:\r\n                difference = unsafe_sub(new_balance, ideal_balance)\r\n\r\n            # fee[i] = _dynamic_fee(i, j) * difference / FEE_DENOMINATOR\r\n            xs = unsafe_div(rates[i] * (old_balances[i] + new_balance), PRECISION)\r\n            _dynamic_fee_i = self._dynamic_fee(xs, ys, base_fee)\r\n            fees.append(unsafe_div(_dynamic_fee_i * difference, FEE_DENOMINATOR))\r\n            self.admin_balances[i] += unsafe_div(fees[i] * admin_fee, FEE_DENOMINATOR)\r\n            new_balances[i] -= fees[i]\r\n\r\n        xp: DynArray[uint256, MAX_COINS] = self._xp_mem(rates, new_balances)\r\n        D1 = self.get_D(xp, amp)  # <--------------- Reuse D1 for new D value.\r\n        mint_amount = unsafe_div(total_supply * (D1 - D0), D0)\r\n        self.upkeep_oracles(xp, amp, D1)\r\n\r\n    else:\r\n\r\n        mint_amount = D1  # Take the dust if there was any\r\n\r\n        # (re)instantiate D oracle if totalSupply is zero.\r\n        self.last_D_packed = self.pack_2(D1, D1)\r\n\r\n        # Update D ma time:\r\n        ma_last_time_unpacked: uint256[2] = self.unpack_2(self.ma_last_time)\r\n        if ma_last_time_unpacked[1] < block.timestamp:\r\n            ma_last_time_unpacked[1] = block.timestamp\r\n            self.ma_last_time = self.pack_2(ma_last_time_unpacked[0], ma_last_time_unpacked[1])\r\n\r\n    assert mint_amount >= _min_mint_amount, \"Slippage screwed you\"\r\n\r\n    # Mint pool tokens\r\n    total_supply += mint_amount\r\n    self.balanceOf[_receiver] += mint_amount\r\n    self.total_supply = total_supply\r\n    log Transfer(empty(address), _receiver, mint_amount)\r\n\r\n    log AddLiquidity(msg.sender, _amounts, fees, D1, total_supply)\r\n\r\n    return mint_amount\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity_one_coin(\r\n    _burn_amount: uint256,\r\n    i: int128,\r\n    _min_received: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw a single coin from the pool\r\n    @param _burn_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @param _min_received Minimum amount of coin to receive\r\n    @param _receiver Address that receives the withdrawn coins\r\n    @return Amount of coin received\r\n    \"\"\"\r\n    assert _burn_amount > 0  # dev: do not remove 0 LP tokens\r\n    dy: uint256 = 0\r\n    fee: uint256 = 0\r\n    xp: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\r\n    amp: uint256 = empty(uint256)\r\n    D: uint256 = empty(uint256)\r\n\r\n    dy, fee, xp, amp, D = self._calc_withdraw_one_coin(_burn_amount, i)\r\n    assert dy >= _min_received, \"Not enough coins removed\"\r\n\r\n    self.admin_balances[i] += unsafe_div(fee * admin_fee, FEE_DENOMINATOR)\r\n\r\n    self._burnFrom(msg.sender, _burn_amount)\r\n\r\n    self._transfer_out(i, dy, _receiver)\r\n\r\n    log RemoveLiquidityOne(msg.sender, i, _burn_amount, dy, self.total_supply)\r\n\r\n    self.upkeep_oracles(xp, amp, D)\r\n\r\n    return dy\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity_imbalance(\r\n    _amounts: DynArray[uint256, MAX_COINS],\r\n    _max_burn_amount: uint256,\r\n    _receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw coins from the pool in an imbalanced amount\r\n    @param _amounts List of amounts of underlying coins to withdraw\r\n    @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal\r\n    @param _receiver Address that receives the withdrawn coins\r\n    @return Actual amount of the LP token burned in the withdrawal\r\n    \"\"\"\r\n    amp: uint256 = self._A()\r\n    rates: DynArray[uint256, MAX_COINS] = self._stored_rates()\r\n    old_balances: DynArray[uint256, MAX_COINS] = self._balances()\r\n    D0: uint256 = self.get_D_mem(rates, old_balances, amp)\r\n    new_balances: DynArray[uint256, MAX_COINS] = old_balances\r\n\r\n    for i in range(N_COINS_128, bound=MAX_COINS_128):\r\n\r\n        if _amounts[i] != 0:\r\n            new_balances[i] -= _amounts[i]\r\n            self._transfer_out(i, _amounts[i], _receiver)\r\n\r\n    D1: uint256 = self.get_D_mem(rates, new_balances, amp)\r\n    base_fee: uint256 = unsafe_div(\r\n        unsafe_mul(self.fee, N_COINS),\r\n        unsafe_mul(4, unsafe_sub(N_COINS, 1))\r\n    )\r\n    ys: uint256 = unsafe_div((D0 + D1), N_COINS)\r\n\r\n    fees: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\r\n    dynamic_fee: uint256 = 0\r\n    xs: uint256 = 0\r\n    ideal_balance: uint256 = 0\r\n    difference: uint256 = 0\r\n    new_balance: uint256 = 0\r\n\r\n    for i in range(N_COINS_128, bound=MAX_COINS_128):\r\n\r\n        ideal_balance = D1 * old_balances[i] / D0\r\n        difference = 0\r\n        new_balance = new_balances[i]\r\n\r\n        if ideal_balance > new_balance:\r\n            difference = unsafe_sub(ideal_balance, new_balance)\r\n        else:\r\n            difference = unsafe_sub(new_balance, ideal_balance)\r\n\r\n        xs = unsafe_div(rates[i] * (old_balances[i] + new_balance), PRECISION)\r\n        dynamic_fee = self._dynamic_fee(xs, ys, base_fee)\r\n        fees.append(unsafe_div(dynamic_fee * difference, FEE_DENOMINATOR))\r\n\r\n        self.admin_balances[i] += unsafe_div(fees[i] * admin_fee, FEE_DENOMINATOR)\r\n        new_balances[i] -= fees[i]\r\n\r\n    D1 = self.get_D_mem(rates, new_balances, amp)  # dev: reuse D1 for new D.\r\n    self.upkeep_oracles(self._xp_mem(rates, new_balances), amp, D1)\r\n\r\n    total_supply: uint256 = self.total_supply\r\n    burn_amount: uint256 = unsafe_div((D0 - D1) * total_supply, D0) + 1\r\n    assert burn_amount > 1  # dev: zero tokens burned\r\n    assert burn_amount <= _max_burn_amount, \"Slippage screwed you\"\r\n\r\n    self._burnFrom(msg.sender, burn_amount)\r\n\r\n    log RemoveLiquidityImbalance(\r\n        msg.sender,\r\n        _amounts,\r\n        fees,\r\n        D1,\r\n        total_supply - burn_amount\r\n    )\r\n\r\n    return burn_amount\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity(\r\n    _burn_amount: uint256,\r\n    _min_amounts: DynArray[uint256, MAX_COINS],\r\n    _receiver: address = msg.sender,\r\n    _claim_admin_fees: bool = True,\r\n) -> DynArray[uint256, MAX_COINS]:\r\n    \"\"\"\r\n    @notice Withdraw coins from the pool\r\n    @dev Withdrawal amounts are based on current deposit ratios\r\n    @param _burn_amount Quantity of LP tokens to burn in the withdrawal\r\n    @param _min_amounts Minimum amounts of underlying coins to receive\r\n    @param _receiver Address that receives the withdrawn coins\r\n    @return List of amounts of coins that were withdrawn\r\n    \"\"\"\r\n    total_supply: uint256 = self.total_supply\r\n    assert _burn_amount > 0  # dev: invalid burn amount\r\n    assert len(_min_amounts) == N_COINS  # dev: invalid array length for _min_amounts\r\n\r\n    amounts: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\r\n    balances: DynArray[uint256, MAX_COINS] = self._balances()\r\n\r\n    value: uint256 = 0\r\n    for i in range(N_COINS_128, bound=MAX_COINS_128):\r\n\r\n        value = unsafe_div(balances[i] * _burn_amount, total_supply)\r\n        assert value >= _min_amounts[i], \"Withdrawal resulted in fewer coins than expected\"\r\n        amounts.append(value)\r\n        self._transfer_out(i, value, _receiver)\r\n\r\n    self._burnFrom(msg.sender, _burn_amount)  # <---- Updates self.total_supply\r\n\r\n    # --------------------------- Upkeep D_oracle ----------------------------\r\n\r\n    ma_last_time_unpacked: uint256[2] = self.unpack_2(self.ma_last_time)\r\n    last_D_packed_current: uint256 = self.last_D_packed\r\n    old_D: uint256 = last_D_packed_current & (2**128 - 1)\r\n\r\n    self.last_D_packed = self.pack_2(\r\n        old_D - unsafe_div(old_D * _burn_amount, total_supply),  # new_D = proportionally reduce D.\r\n        self._calc_moving_average(\r\n            last_D_packed_current,\r\n            self.D_ma_time,\r\n            ma_last_time_unpacked[1]\r\n        )\r\n    )\r\n\r\n    if ma_last_time_unpacked[1] < block.timestamp:\r\n        ma_last_time_unpacked[1] = block.timestamp\r\n        self.ma_last_time = self.pack_2(ma_last_time_unpacked[0], ma_last_time_unpacked[1])\r\n\r\n    # ------------------------------- Log event ------------------------------\r\n\r\n    log RemoveLiquidity(\r\n        msg.sender,\r\n        amounts,\r\n        empty(DynArray[uint256, MAX_COINS]),\r\n        unsafe_sub(total_supply, _burn_amount)\r\n    )\r\n\r\n    # ------- Withdraw admin fees if _claim_admin_fees is set to True --------\r\n    if _claim_admin_fees:\r\n        self._withdraw_admin_fees()\r\n\r\n    return amounts\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw_admin_fees():\r\n    \"\"\"\r\n    @notice Claim admin fees. Callable by anyone.\r\n    \"\"\"\r\n    self._withdraw_admin_fees()\r\n\r\n\r\n# ------------------------ AMM Internal Functions ----------------------------\r\n\r\n\r\n@view\r\n@internal\r\ndef _dynamic_fee(xpi: uint256, xpj: uint256, _fee: uint256) -> uint256:\r\n\r\n    _offpeg_fee_multiplier: uint256 = self.offpeg_fee_multiplier\r\n    if _offpeg_fee_multiplier <= FEE_DENOMINATOR:\r\n        return _fee\r\n\r\n    xps2: uint256 = (xpi + xpj) ** 2\r\n    return unsafe_div(\r\n        unsafe_mul(_offpeg_fee_multiplier, _fee),\r\n        unsafe_add(\r\n            unsafe_sub(_offpeg_fee_multiplier, FEE_DENOMINATOR) * 4 * xpi * xpj / xps2,\r\n            FEE_DENOMINATOR\r\n        )\r\n    )\r\n\r\n\r\n@internal\r\ndef __exchange(\r\n    x: uint256,\r\n    _xp: DynArray[uint256, MAX_COINS],\r\n    rates: DynArray[uint256, MAX_COINS],\r\n    i: int128,\r\n    j: int128,\r\n) -> uint256:\r\n\r\n    amp: uint256 = self._A()\r\n    D: uint256 = self.get_D(_xp, amp)\r\n    y: uint256 = self.get_y(i, j, x, _xp, amp, D)\r\n\r\n    dy: uint256 = _xp[j] - y - 1  # -1 just in case there were some rounding errors\r\n    dy_fee: uint256 = unsafe_div(\r\n        dy * self._dynamic_fee(\r\n            unsafe_div(_xp[i] + x, 2), unsafe_div(_xp[j] + y, 2), self.fee\r\n        ),\r\n        FEE_DENOMINATOR\r\n    )\r\n\r\n    # Convert all to real units\r\n    dy = (dy - dy_fee) * PRECISION / rates[j]\r\n\r\n    self.admin_balances[j] += unsafe_div(\r\n        unsafe_div(dy_fee * admin_fee, FEE_DENOMINATOR) * PRECISION,\r\n        rates[j]\r\n    )\r\n\r\n    # Calculate and store state prices:\r\n    xp: DynArray[uint256, MAX_COINS] = _xp\r\n    xp[i] = x\r\n    xp[j] = y\r\n    # D is not changed because we did not apply a fee\r\n    self.upkeep_oracles(xp, amp, D)\r\n\r\n    return dy\r\n\r\n\r\n@internal\r\ndef _exchange(\r\n    sender: address,\r\n    i: int128,\r\n    j: int128,\r\n    _dx: uint256,\r\n    _min_dy: uint256,\r\n    receiver: address,\r\n    expect_optimistic_transfer: bool\r\n) -> uint256:\r\n\r\n    assert i != j  # dev: coin index out of range\r\n    assert _dx > 0  # dev: do not exchange 0 coins\r\n\r\n    rates: DynArray[uint256, MAX_COINS] = self._stored_rates()\r\n    old_balances: DynArray[uint256, MAX_COINS] = self._balances()\r\n    xp: DynArray[uint256, MAX_COINS] = self._xp_mem(rates, old_balances)\r\n\r\n    # --------------------------- Do Transfer in -----------------------------\r\n\r\n    # `dx` is whatever the pool received after ERC20 transfer:\r\n    dx: uint256 = self._transfer_in(\r\n        i,\r\n        _dx,\r\n        sender,\r\n        expect_optimistic_transfer\r\n    )\r\n\r\n    # ------------------------------- Exchange -------------------------------\r\n\r\n    x: uint256 = xp[i] + unsafe_div(dx * rates[i], PRECISION)\r\n    dy: uint256 = self.__exchange(x, xp, rates, i, j)\r\n    assert dy >= _min_dy, \"Exchange resulted in fewer coins than expected\"\r\n\r\n    # --------------------------- Do Transfer out ----------------------------\r\n\r\n    self._transfer_out(j, dy, receiver)\r\n\r\n    # ------------------------------------------------------------------------\r\n\r\n    log TokenExchange(msg.sender, i, dx, j, dy)\r\n\r\n    return dy\r\n\r\n\r\n@internal\r\ndef _withdraw_admin_fees():\r\n    fee_receiver: address = factory.fee_receiver()\r\n    if fee_receiver == empty(address):\r\n        return  # Do nothing.\r\n\r\n    admin_balances: DynArray[uint256, MAX_COINS] = self.admin_balances\r\n    for i in range(N_COINS_128, bound=MAX_COINS_128):\r\n\r\n        if admin_balances[i] > 0:\r\n\r\n            self._transfer_out(i, admin_balances[i], fee_receiver)\r\n            admin_balances[i] = 0\r\n\r\n    self.admin_balances = admin_balances\r\n\r\n\r\n# --------------------------- AMM Math Functions -----------------------------\r\n\r\n\r\n@view\r\n@internal\r\ndef get_y(\r\n    i: int128,\r\n    j: int128,\r\n    x: uint256,\r\n    xp: DynArray[uint256, MAX_COINS],\r\n    _amp: uint256,\r\n    _D: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    Calculate x[j] if one makes x[i] = x\r\n\r\n    Done by solving quadratic equation iteratively.\r\n    x_1**2 + x_1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n    x_1**2 + b*x_1 = c\r\n\r\n    x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n    \"\"\"\r\n    # x in the input is converted to the same price/precision\r\n\r\n    assert i != j       # dev: same coin\r\n    assert j >= 0       # dev: j below zero\r\n    assert j < N_COINS_128  # dev: j above N_COINS\r\n\r\n    # should be unreachable, but good for safety\r\n    assert i >= 0\r\n    assert i < N_COINS_128\r\n\r\n    amp: uint256 = _amp\r\n    D: uint256 = _D\r\n\r\n    S_: uint256 = 0\r\n    _x: uint256 = 0\r\n    y_prev: uint256 = 0\r\n    c: uint256 = D\r\n    Ann: uint256 = amp * N_COINS\r\n\r\n    for _i in range(MAX_COINS_128):\r\n\r\n        if _i == N_COINS_128:\r\n            break\r\n\r\n        if _i == i:\r\n            _x = x\r\n        elif _i != j:\r\n            _x = xp[_i]\r\n        else:\r\n            continue\r\n\r\n        S_ += _x\r\n        c = c * D / (_x * N_COINS)\r\n\r\n    c = c * D * A_PRECISION / (Ann * N_COINS)\r\n    b: uint256 = S_ + D * A_PRECISION / Ann  # - D\r\n    y: uint256 = D\r\n\r\n    for _i in range(255):\r\n        y_prev = y\r\n        y = (y*y + c) / (2 * y + b - D)\r\n        # Equality with the precision of 1\r\n        if y > y_prev:\r\n            if y - y_prev <= 1:\r\n                return y\r\n        else:\r\n            if y_prev - y <= 1:\r\n                return y\r\n    raise\r\n\r\n\r\n@pure\r\n@internal\r\ndef get_D(_xp: DynArray[uint256, MAX_COINS], _amp: uint256) -> uint256:\r\n    \"\"\"\r\n    D invariant calculation in non-overflowing integer operations\r\n    iteratively\r\n\r\n    A * sum(x_i) * n**n + D = A * D * n**n + D**(n+1) / (n**n * prod(x_i))\r\n\r\n    Converging solution:\r\n    D[j+1] = (A * n**n * sum(x_i) - D[j]**(n+1) / (n**n prod(x_i))) / (A * n**n - 1)\r\n    \"\"\"\r\n    S: uint256 = 0\r\n    for x in _xp:\r\n        S += x\r\n    if S == 0:\r\n        return 0\r\n\r\n    D: uint256 = S\r\n    Ann: uint256 = _amp * N_COINS\r\n\r\n    for i in range(255):\r\n\r\n        D_P: uint256 = D\r\n        for x in _xp:\r\n            D_P = D_P * D / x\r\n        D_P /= pow_mod256(N_COINS, N_COINS)\r\n        Dprev: uint256 = D\r\n\r\n        # (Ann * S / A_PRECISION + D_P * N_COINS) * D / ((Ann - A_PRECISION) * D / A_PRECISION + (N_COINS + 1) * D_P)\r\n        D = (\r\n            (unsafe_div(Ann * S, A_PRECISION) + D_P * N_COINS) * D\r\n            /\r\n            (\r\n                unsafe_div((Ann - A_PRECISION) * D, A_PRECISION) +\r\n                unsafe_add(N_COINS, 1) * D_P\r\n            )\r\n        )\r\n\r\n        # Equality with the precision of 1\r\n        if D > Dprev:\r\n            if D - Dprev <= 1:\r\n                return D\r\n        else:\r\n            if Dprev - D <= 1:\r\n                return D\r\n    # convergence typically occurs in 4 rounds or less, this should be unreachable!\r\n    # if it does happen the pool is borked and LPs can withdraw via `remove_liquidity`\r\n    raise\r\n\r\n\r\n@pure\r\n@internal\r\ndef get_y_D(\r\n    A: uint256,\r\n    i: int128,\r\n    xp: DynArray[uint256, MAX_COINS],\r\n    D: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    Calculate x[i] if one reduces D from being calculated for xp to D\r\n\r\n    Done by solving quadratic equation iteratively.\r\n    x_1**2 + x_1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n    x_1**2 + b*x_1 = c\r\n\r\n    x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n    \"\"\"\r\n    # x in the input is converted to the same price/precision\r\n\r\n    assert i >= 0  # dev: i below zero\r\n    assert i < N_COINS_128  # dev: i above N_COINS\r\n\r\n    S_: uint256 = 0\r\n    _x: uint256 = 0\r\n    y_prev: uint256 = 0\r\n    c: uint256 = D\r\n    Ann: uint256 = A * N_COINS\r\n\r\n    for _i in range(MAX_COINS_128):\r\n\r\n        if _i == N_COINS_128:\r\n            break\r\n\r\n        if _i != i:\r\n            _x = xp[_i]\r\n        else:\r\n            continue\r\n        S_ += _x\r\n        c = c * D / (_x * N_COINS)\r\n\r\n    c = c * D * A_PRECISION / (Ann * N_COINS)\r\n    b: uint256 = S_ + D * A_PRECISION / Ann\r\n    y: uint256 = D\r\n\r\n    for _i in range(255):\r\n        y_prev = y\r\n        y = (y*y + c) / (2 * y + b - D)\r\n        # Equality with the precision of 1\r\n        if y > y_prev:\r\n            if y - y_prev <= 1:\r\n                return y\r\n        else:\r\n            if y_prev - y <= 1:\r\n                return y\r\n    raise\r\n\r\n\r\n@view\r\n@internal\r\ndef _A() -> uint256:\r\n    \"\"\"\r\n    Handle ramping A up or down\r\n    \"\"\"\r\n    t1: uint256 = self.future_A_time\r\n    A1: uint256 = self.future_A\r\n\r\n    if block.timestamp < t1:\r\n        A0: uint256 = self.initial_A\r\n        t0: uint256 = self.initial_A_time\r\n        # Expressions in uint256 cannot have negative numbers, thus \"if\"\r\n        if A1 > A0:\r\n            return A0 + unsafe_sub(A1, A0) * (block.timestamp - t0) / (t1 - t0)\r\n        else:\r\n            return A0 - unsafe_sub(A0, A1) * (block.timestamp - t0) / (t1 - t0)\r\n\r\n    else:  # when t1 == 0 or block.timestamp >= t1\r\n        return A1\r\n\r\n\r\n@pure\r\n@internal\r\ndef _xp_mem(\r\n    _rates: DynArray[uint256, MAX_COINS],\r\n    _balances: DynArray[uint256, MAX_COINS]\r\n) -> DynArray[uint256, MAX_COINS]:\r\n\r\n    result: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\r\n    for i in range(N_COINS_128, bound=MAX_COINS_128):\r\n        result.append(unsafe_div(_rates[i] * _balances[i], PRECISION))\r\n    return result\r\n\r\n\r\n@view\r\n@internal\r\ndef get_D_mem(\r\n    _rates: DynArray[uint256, MAX_COINS],\r\n    _balances: DynArray[uint256, MAX_COINS],\r\n    _amp: uint256\r\n) -> uint256:\r\n    xp: DynArray[uint256, MAX_COINS] = self._xp_mem(_rates, _balances)\r\n    return self.get_D(xp, _amp)\r\n\r\n\r\n@view\r\n@internal\r\ndef _calc_withdraw_one_coin(\r\n    _burn_amount: uint256,\r\n    i: int128\r\n) -> (\r\n    uint256,\r\n    uint256,\r\n    DynArray[uint256, MAX_COINS],\r\n    uint256,\r\n    uint256\r\n):\r\n    # First, need to calculate\r\n    # * Get current D\r\n    # * Solve Eqn against y_i for D - _token_amount\r\n    amp: uint256 = self._A()\r\n    rates: DynArray[uint256, MAX_COINS] = self._stored_rates()\r\n    xp: DynArray[uint256, MAX_COINS] = self._xp_mem(rates, self._balances())\r\n    D0: uint256 = self.get_D(xp, amp)\r\n\r\n    total_supply: uint256 = self.total_supply\r\n    D1: uint256 = D0 - _burn_amount * D0 / total_supply\r\n    new_y: uint256 = self.get_y_D(amp, i, xp, D1)\r\n\r\n    base_fee: uint256 = unsafe_div(\r\n        unsafe_mul(self.fee, N_COINS),\r\n        unsafe_mul(4, unsafe_sub(N_COINS, 1))\r\n    )\r\n    xp_reduced: DynArray[uint256, MAX_COINS] = xp\r\n    ys: uint256 = unsafe_div((D0 + D1), unsafe_mul(2, N_COINS))\r\n\r\n    dx_expected: uint256 = 0\r\n    xp_j: uint256 = 0\r\n    xavg: uint256 = 0\r\n    dynamic_fee: uint256 = 0\r\n\r\n    for j in range(MAX_COINS_128):\r\n\r\n        if j == N_COINS_128:\r\n            break\r\n\r\n        dx_expected = 0\r\n        xp_j = xp[j]\r\n\r\n        if j == i:\r\n            dx_expected = xp_j * D1 / D0 - new_y\r\n            xavg = unsafe_div((xp_j + new_y), 2)\r\n        else:\r\n            dx_expected = xp_j - xp_j * D1 / D0\r\n            xavg = xp_j\r\n\r\n        dynamic_fee = self._dynamic_fee(xavg, ys, base_fee)\r\n        xp_reduced[j] = xp_j - unsafe_div(dynamic_fee * dx_expected, FEE_DENOMINATOR)\r\n\r\n    dy: uint256 = xp_reduced[i] - self.get_y_D(amp, i, xp_reduced, D1)\r\n    dy_0: uint256 = (xp[i] - new_y) * PRECISION / rates[i]  # w/o fees\r\n    dy = unsafe_div((dy - 1) * PRECISION, rates[i])  # Withdraw less to account for rounding errors\r\n\r\n    # update xp with new_y for p calculations.\r\n    xp[i] = new_y\r\n\r\n    return dy, dy_0 - dy, xp, amp, D1\r\n\r\n\r\n# -------------------------- AMM Price Methods -------------------------------\r\n\r\n@pure\r\n@internal\r\ndef pack_2(p1: uint256, p2: uint256) -> uint256:\r\n    assert p1 < 2**128\r\n    assert p2 < 2**128\r\n    return p1 | (p2 << 128)\r\n\r\n\r\n@pure\r\n@internal\r\ndef unpack_2(packed: uint256) -> uint256[2]:\r\n    return [packed & (2**128 - 1), packed >> 128]\r\n\r\n\r\n@internal\r\n@pure\r\ndef _get_p(\r\n    xp: DynArray[uint256, MAX_COINS],\r\n    amp: uint256,\r\n    D: uint256,\r\n) -> DynArray[uint256, MAX_COINS]:\r\n\r\n    # dx_0 / dx_1 only, however can have any number of coins in pool\r\n    ANN: uint256 = unsafe_mul(amp, N_COINS)\r\n    Dr: uint256 = unsafe_div(D, pow_mod256(N_COINS, N_COINS))\r\n\r\n    for i in range(N_COINS_128, bound=MAX_COINS_128):\r\n        Dr = Dr * D / xp[i]\r\n\r\n    p: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\r\n    xp0_A: uint256 = unsafe_div(ANN * xp[0], A_PRECISION)\r\n\r\n    for i in range(1, MAX_COINS):\r\n\r\n        if i == N_COINS:\r\n            break\r\n\r\n        p.append(10**18 * (xp0_A + unsafe_div(Dr * xp[0], xp[i])) / (xp0_A + Dr))\r\n\r\n    return p\r\n\r\n\r\n@internal\r\ndef upkeep_oracles(xp: DynArray[uint256, MAX_COINS], amp: uint256, D: uint256):\r\n    \"\"\"\r\n    @notice Upkeeps price and D oracles.\r\n    \"\"\"\r\n    ma_last_time_unpacked: uint256[2] = self.unpack_2(self.ma_last_time)\r\n    last_prices_packed_current: DynArray[uint256, MAX_COINS] = self.last_prices_packed\r\n    last_prices_packed_new: DynArray[uint256, MAX_COINS] = last_prices_packed_current\r\n\r\n    spot_price: DynArray[uint256, MAX_COINS] = self._get_p(xp, amp, D)\r\n\r\n    # -------------------------- Upkeep price oracle -------------------------\r\n\r\n    for i in range(MAX_COINS):\r\n\r\n        if i == N_COINS - 1:\r\n            break\r\n\r\n        if spot_price[i] != 0:\r\n\r\n            # Update packed prices -----------------\r\n            last_prices_packed_new[i] = self.pack_2(\r\n                min(spot_price[i], 2 * 10**18),  # <----- Cap spot value by 2.\r\n                self._calc_moving_average(\r\n                    last_prices_packed_current[i],\r\n                    self.ma_exp_time,\r\n                    ma_last_time_unpacked[0],  # index 0 is ma_last_time for prices\r\n                )\r\n            )\r\n\r\n    self.last_prices_packed = last_prices_packed_new\r\n\r\n    # ---------------------------- Upkeep D oracle ---------------------------\r\n\r\n    last_D_packed_current: uint256 = self.last_D_packed\r\n    self.last_D_packed = self.pack_2(\r\n        D,\r\n        self._calc_moving_average(\r\n            last_D_packed_current,\r\n            self.D_ma_time,\r\n            ma_last_time_unpacked[1],  # index 1 is ma_last_time for D\r\n        )\r\n    )\r\n\r\n    # Housekeeping: Update ma_last_time for p and D oracles ------------------\r\n    for i in range(2):\r\n        if ma_last_time_unpacked[i] < block.timestamp:\r\n            ma_last_time_unpacked[i] = block.timestamp\r\n\r\n    self.ma_last_time = self.pack_2(ma_last_time_unpacked[0], ma_last_time_unpacked[1])\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_moving_average(\r\n    packed_value: uint256,\r\n    averaging_window: uint256,\r\n    ma_last_time: uint256\r\n) -> uint256:\r\n\r\n    last_spot_value: uint256 = packed_value & (2**128 - 1)\r\n    last_ema_value: uint256 = (packed_value >> 128)\r\n\r\n    if ma_last_time < block.timestamp:  # calculate new_ema_value and return that.\r\n        alpha: uint256 = self.exp(\r\n            -convert(\r\n                unsafe_div(unsafe_mul(unsafe_sub(block.timestamp, ma_last_time), 10**18), averaging_window), int256\r\n            )\r\n        )\r\n        return unsafe_div(last_spot_value * (10**18 - alpha) + last_ema_value * alpha, 10**18)\r\n\r\n    return last_ema_value\r\n\r\n\r\n@view\r\n@external\r\ndef last_price(i: uint256) -> uint256:\r\n    return self.last_prices_packed[i] & (2**128 - 1)\r\n\r\n\r\n@view\r\n@external\r\ndef ema_price(i: uint256) -> uint256:\r\n    return (self.last_prices_packed[i] >> 128)\r\n\r\n\r\n@external\r\n@view\r\ndef get_p(i: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Returns the AMM State price of token\r\n    @dev if i = 0, it will return the state price of coin[1].\r\n    @param i index of state price (0 for coin[1], 1 for coin[2], ...)\r\n    @return uint256 The state price quoted by the AMM for coin[i+1]\r\n    \"\"\"\r\n    amp: uint256 = self._A()\r\n    xp: DynArray[uint256, MAX_COINS] = self._xp_mem(\r\n        self._stored_rates(), self._balances()\r\n    )\r\n    D: uint256 = self.get_D(xp, amp)\r\n    return self._get_p(xp, amp, D)[i]\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef price_oracle(i: uint256) -> uint256:\r\n    return self._calc_moving_average(\r\n        self.last_prices_packed[i],\r\n        self.ma_exp_time,\r\n        self.ma_last_time & (2**128 - 1)\r\n    )\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef D_oracle() -> uint256:\r\n    return self._calc_moving_average(\r\n        self.last_D_packed,\r\n        self.D_ma_time,\r\n        self.ma_last_time >> 128\r\n    )\r\n\r\n\r\n# ----------------------------- Math Utils -----------------------------------\r\n\r\n\r\n@internal\r\n@pure\r\ndef exp(x: int256) -> uint256:\r\n    \"\"\"\r\n    @dev Calculates the natural exponential function of a signed integer with\r\n         a precision of 1e18.\r\n    @notice Note that this function consumes about 810 gas units. The implementation\r\n            is inspired by Remco Bloemen's implementation under the MIT license here:\r\n            https://xn--2-umb.com/22/exp-ln.\r\n    @dev This implementation is derived from Snekmate, which is authored\r\n         by pcaversaccio (Snekmate), distributed under the AGPL-3.0 license.\r\n         https://github.com/pcaversaccio/snekmate\r\n    @param x The 32-byte variable.\r\n    @return int256 The 32-byte calculation result.\r\n    \"\"\"\r\n    value: int256 = x\r\n\r\n    # If the result is `< 0.5`, we return zero. This happens when we have the following:\r\n    # \"x <= floor(log(0.5e18) * 1e18) ~ -42e18\".\r\n    if (x <= -41446531673892822313):\r\n        return empty(uint256)\r\n\r\n    # When the result is \"> (2 ** 255 - 1) / 1e18\" we cannot represent it as a signed integer.\r\n    # This happens when \"x >= floor(log((2 ** 255 - 1) / 1e18) * 1e18) ~ 135\".\r\n    assert x < 135305999368893231589, \"wad_exp overflow\"\r\n\r\n    # `x` is now in the range \"(-42, 136) * 1e18\". Convert to \"(-42, 136) * 2 ** 96\" for higher\r\n    # intermediate precision and a binary base. This base conversion is a multiplication with\r\n    # \"1e18 / 2 ** 96 = 5 ** 18 / 2 ** 78\".\r\n    value = unsafe_div(x << 78, 5 ** 18)\r\n\r\n    # Reduce the range of `x` to \"(-\u00bd ln 2, \u00bd ln 2) * 2 ** 96\" by factoring out powers of two\r\n    # so that \"exp(x) = exp(x') * 2 ** k\", where `k` is a signer integer. Solving this gives\r\n    # \"k = round(x / log(2))\" and \"x' = x - k * log(2)\". Thus, `k` is in the range \"[-61, 195]\".\r\n    k: int256 = unsafe_add(unsafe_div(value << 96, 54916777467707473351141471128), 2 ** 95) >> 96\r\n    value = unsafe_sub(value, unsafe_mul(k, 54916777467707473351141471128))\r\n\r\n    # Evaluate using a \"(6, 7)\"-term rational approximation. Since `p` is monic,\r\n    # we will multiply by a scaling factor later.\r\n    y: int256 = unsafe_add(unsafe_mul(unsafe_add(value, 1346386616545796478920950773328), value) >> 96, 57155421227552351082224309758442)\r\n    p: int256 = unsafe_add(unsafe_mul(unsafe_add(unsafe_mul(unsafe_sub(unsafe_add(y, value), 94201549194550492254356042504812), y) >> 96,\\\r\n                           28719021644029726153956944680412240), value), 4385272521454847904659076985693276 << 96)\r\n\r\n    # We leave `p` in the \"2 ** 192\" base so that we do not have to scale it up\r\n    # again for the division.\r\n    q: int256 = unsafe_add(unsafe_mul(unsafe_sub(value, 2855989394907223263936484059900), value) >> 96, 50020603652535783019961831881945)\r\n    q = unsafe_sub(unsafe_mul(q, value) >> 96, 533845033583426703283633433725380)\r\n    q = unsafe_add(unsafe_mul(q, value) >> 96, 3604857256930695427073651918091429)\r\n    q = unsafe_sub(unsafe_mul(q, value) >> 96, 14423608567350463180887372962807573)\r\n    q = unsafe_add(unsafe_mul(q, value) >> 96, 26449188498355588339934803723976023)\r\n\r\n    # The polynomial `q` has no zeros in the range because all its roots are complex.\r\n    # No scaling is required, as `p` is already \"2 ** 96\" too large. Also,\r\n    # `r` is in the range \"(0.09, 0.25) * 2**96\" after the division.\r\n    r: int256 = unsafe_div(p, q)\r\n\r\n    # To finalise the calculation, we have to multiply `r` by:\r\n    #   - the scale factor \"s = ~6.031367120\",\r\n    #   - the factor \"2 ** k\" from the range reduction, and\r\n    #   - the factor \"1e18 / 2 ** 96\" for the base conversion.\r\n    # We do this all at once, with an intermediate result in \"2**213\" base,\r\n    # so that the final right shift always gives a positive value.\r\n\r\n    # Note that to circumvent Vyper's safecast feature for the potentially\r\n    # negative parameter value `r`, we first convert `r` to `bytes32` and\r\n    # subsequently to `uint256`. Remember that the EVM default behaviour is\r\n    # to use two's complement representation to handle signed integers.\r\n    return unsafe_mul(convert(convert(r, bytes32), uint256), 3822833074963236453042738258902158003155416615667) >> convert(unsafe_sub(195, k), uint256)\r\n\r\n\r\n# ---------------------------- ERC20 Utils -----------------------------------\r\n\r\n@view\r\n@internal\r\ndef _domain_separator() -> bytes32:\r\n    if chain.id != CACHED_CHAIN_ID:\r\n        return keccak256(\r\n            _abi_encode(\r\n                EIP712_TYPEHASH,\r\n                NAME_HASH,\r\n                VERSION_HASH,\r\n                chain.id,\r\n                self,\r\n                salt,\r\n            )\r\n        )\r\n    return CACHED_DOMAIN_SEPARATOR\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _value: uint256):\r\n    # # NOTE: vyper does not allow underflows\r\n    # #       so the following subtraction would revert on insufficient balance\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n\r\n    log Transfer(_from, _to, _value)\r\n\r\n\r\n@internal\r\ndef _burnFrom(_from: address, _burn_amount: uint256):\r\n\r\n    self.total_supply -= _burn_amount\r\n    self.balanceOf[_from] -= _burn_amount\r\n    log Transfer(_from, empty(address), _burn_amount)\r\n\r\n\r\n@external\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @dev Transfer token for a specified address\r\n    @param _to The address to transfer to.\r\n    @param _value The amount to be transferred.\r\n    \"\"\"\r\n    self._transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n     @dev Transfer tokens from one address to another.\r\n     @param _from address The address which you want to send tokens from\r\n     @param _to address The address which you want to transfer to\r\n     @param _value uint256 the amount of tokens to be transferred\r\n    \"\"\"\r\n    self._transfer(_from, _to, _value)\r\n\r\n    _allowance: uint256 = self.allowance[_from][msg.sender]\r\n    if _allowance != max_value(uint256):\r\n        _new_allowance: uint256 = _allowance - _value\r\n        self.allowance[_from][msg.sender] = _new_allowance\r\n        log Approval(_from, msg.sender, _new_allowance)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Approve the passed address to transfer the specified amount of\r\n            tokens on behalf of msg.sender\r\n    @dev Beware that changing an allowance via this method brings the risk that\r\n         someone may use both the old and new allowance by unfortunate transaction\r\n         ordering: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will transfer the funds\r\n    @param _value The amount of tokens that may be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    self.allowance[msg.sender][_spender] = _value\r\n\r\n    log Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef permit(\r\n    _owner: address,\r\n    _spender: address,\r\n    _value: uint256,\r\n    _deadline: uint256,\r\n    _v: uint8,\r\n    _r: bytes32,\r\n    _s: bytes32\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Approves spender by owner's signature to expend owner's tokens.\r\n        See https://eips.ethereum.org/EIPS/eip-2612.\r\n    @dev Inspired by https://github.com/yearn/yearn-vaults/blob/main/contracts/Vault.vy#L753-L793\r\n    @dev Supports smart contract wallets which implement ERC1271\r\n        https://eips.ethereum.org/EIPS/eip-1271\r\n    @param _owner The address which is a source of funds and has signed the Permit.\r\n    @param _spender The address which is allowed to spend the funds.\r\n    @param _value The amount of tokens to be spent.\r\n    @param _deadline The timestamp after which the Permit is no longer valid.\r\n    @param _v The bytes[64] of the valid secp256k1 signature of permit by owner\r\n    @param _r The bytes[0:32] of the valid secp256k1 signature of permit by owner\r\n    @param _s The bytes[32:64] of the valid secp256k1 signature of permit by owner\r\n    @return True, if transaction completes successfully\r\n    \"\"\"\r\n    assert _owner != empty(address)\r\n    assert block.timestamp <= _deadline\r\n\r\n    nonce: uint256 = self.nonces[_owner]\r\n    digest: bytes32 = keccak256(\r\n        concat(\r\n            b\"\\x19\\x01\",\r\n            self._domain_separator(),\r\n            keccak256(_abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline))\r\n        )\r\n    )\r\n\r\n    if _owner.is_contract:\r\n        sig: Bytes[65] = concat(_abi_encode(_r, _s), slice(convert(_v, bytes32), 31, 1))\r\n        # reentrancy not a concern since this is a staticcall\r\n        assert ERC1271(_owner).isValidSignature(digest, sig) == ERC1271_MAGIC_VAL\r\n    else:\r\n        assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\r\n\r\n    self.allowance[_owner][_spender] = _value\r\n    self.nonces[_owner] = unsafe_add(nonce, 1)\r\n\r\n    log Approval(_owner, _spender, _value)\r\n    return True\r\n\r\n\r\n@view\r\n@external\r\ndef DOMAIN_SEPARATOR() -> bytes32:\r\n    \"\"\"\r\n    @notice EIP712 domain separator.\r\n    @return bytes32 Domain Separator set for the current chain.\r\n    \"\"\"\r\n    return self._domain_separator()\r\n\r\n\r\n# ------------------------- AMM View Functions -------------------------------\r\n\r\n\r\n@view\r\n@external\r\ndef get_dx(i: int128, j: int128, dy: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the current input dx given output dy\r\n    @dev Index values can be found via the `coins` public getter method\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @param dy Amount of `j` being received after exchange\r\n    @return Amount of `i` predicted\r\n    \"\"\"\r\n    return StableSwapViews(factory.views_implementation()).get_dx(i, j, dy, self)\r\n\r\n\r\n@view\r\n@external\r\ndef get_dy(i: int128, j: int128, dx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the current output dy given input dx\r\n    @dev Index values can be found via the `coins` public getter method\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @param dx Amount of `i` being exchanged\r\n    @return Amount of `j` predicted\r\n    \"\"\"\r\n    return StableSwapViews(factory.views_implementation()).get_dy(i, j, dx, self)\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(_burn_amount: uint256, i: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount received when withdrawing a single coin\r\n    @param _burn_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @return Amount of coin received\r\n    \"\"\"\r\n    return self._calc_withdraw_one_coin(_burn_amount, i)[0]\r\n\r\n\r\n@view\r\n@external\r\n@nonreentrant('lock')\r\ndef totalSupply() -> uint256:\r\n    \"\"\"\r\n    @notice The total supply of pool LP tokens\r\n    @return self.total_supply, 18 decimals.\r\n    \"\"\"\r\n    return self.total_supply\r\n\r\n\r\n@view\r\n@external\r\n@nonreentrant('lock')\r\ndef get_virtual_price() -> uint256:\r\n    \"\"\"\r\n    @notice The current virtual price of the pool LP token\r\n    @dev Useful for calculating profits.\r\n         The method may be vulnerable to donation-style attacks if implementation\r\n         contains rebasing tokens. For integrators, caution is advised.\r\n    @return LP token virtual price normalized to 1e18\r\n    \"\"\"\r\n    amp: uint256 = self._A()\r\n    xp: DynArray[uint256, MAX_COINS] = self._xp_mem(\r\n        self._stored_rates(), self._balances()\r\n    )\r\n    D: uint256 = self.get_D(xp, amp)\r\n    # D is in the units similar to DAI (e.g. converted to precision 1e18)\r\n    # When balanced, D = n * x_u - total virtual value of the portfolio\r\n    return D * PRECISION / self.total_supply\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(\r\n    _amounts: DynArray[uint256, MAX_COINS],\r\n    _is_deposit: bool\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate addition or reduction in token supply from a deposit or withdrawal\r\n    @param _amounts Amount of each coin being deposited\r\n    @param _is_deposit set True for deposits, False for withdrawals\r\n    @return Expected amount of LP tokens received\r\n    \"\"\"\r\n    return StableSwapViews(factory.views_implementation()).calc_token_amount(_amounts, _is_deposit, self)\r\n\r\n\r\n@view\r\n@external\r\ndef A() -> uint256:\r\n    return unsafe_div(self._A(), A_PRECISION)\r\n\r\n\r\n@view\r\n@external\r\ndef A_precise() -> uint256:\r\n    return self._A()\r\n\r\n\r\n@view\r\n@external\r\ndef balances(i: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current balance of a coin within the\r\n            pool, less the accrued admin fees\r\n    @param i Index value for the coin to query balance of\r\n    @return Token balance\r\n    \"\"\"\r\n    return self._balances()[i]\r\n\r\n\r\n@view\r\n@external\r\ndef get_balances() -> DynArray[uint256, MAX_COINS]:\r\n    return self._balances()\r\n\r\n\r\n@view\r\n@external\r\ndef stored_rates() -> DynArray[uint256, MAX_COINS]:\r\n    return self._stored_rates()\r\n\r\n\r\n@view\r\n@external\r\ndef dynamic_fee(i: int128, j: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Return the fee for swapping between `i` and `j`\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @return Swap fee expressed as an integer with 1e10 precision\r\n    \"\"\"\r\n    return StableSwapViews(factory.views_implementation()).dynamic_fee(i, j, self)\r\n\r\n\r\n# --------------------------- AMM Admin Functions ----------------------------\r\n\r\n\r\n@external\r\ndef ramp_A(_future_A: uint256, _future_time: uint256):\r\n    assert msg.sender == factory.admin()  # dev: only owner\r\n    assert block.timestamp >= self.initial_A_time + MIN_RAMP_TIME\r\n    assert _future_time >= block.timestamp + MIN_RAMP_TIME  # dev: insufficient time\r\n\r\n    _initial_A: uint256 = self._A()\r\n    _future_A_p: uint256 = _future_A * A_PRECISION\r\n\r\n    assert _future_A > 0 and _future_A < MAX_A\r\n    if _future_A_p < _initial_A:\r\n        assert _future_A_p * MAX_A_CHANGE >= _initial_A\r\n    else:\r\n        assert _future_A_p <= _initial_A * MAX_A_CHANGE\r\n\r\n    self.initial_A = _initial_A\r\n    self.future_A = _future_A_p\r\n    self.initial_A_time = block.timestamp\r\n    self.future_A_time = _future_time\r\n\r\n    log RampA(_initial_A, _future_A_p, block.timestamp, _future_time)\r\n\r\n\r\n@external\r\ndef stop_ramp_A():\r\n    assert msg.sender == factory.admin()  # dev: only owner\r\n\r\n    current_A: uint256 = self._A()\r\n    self.initial_A = current_A\r\n    self.future_A = current_A\r\n    self.initial_A_time = block.timestamp\r\n    self.future_A_time = block.timestamp\r\n    # now (block.timestamp < t1) is always False, so we return saved A\r\n\r\n    log StopRampA(current_A, block.timestamp)\r\n\r\n\r\n@external\r\ndef set_new_fee(_new_fee: uint256, _new_offpeg_fee_multiplier: uint256):\r\n\r\n    assert msg.sender == factory.admin()\r\n\r\n    # set new fee:\r\n    assert _new_fee <= MAX_FEE\r\n    self.fee = _new_fee\r\n\r\n    # set new offpeg_fee_multiplier:\r\n    assert _new_offpeg_fee_multiplier * _new_fee <= MAX_FEE * FEE_DENOMINATOR  # dev: offpeg multiplier exceeds maximum\r\n    self.offpeg_fee_multiplier = _new_offpeg_fee_multiplier\r\n\r\n    log ApplyNewFee(_new_fee, _new_offpeg_fee_multiplier)\r\n\r\n\r\n@external\r\ndef set_ma_exp_time(_ma_exp_time: uint256, _D_ma_time: uint256):\r\n    \"\"\"\r\n    @notice Set the moving average window of the price oracles.\r\n    @param _ma_exp_time Moving average window for the price oracle. It is time_in_seconds / ln(2).\r\n    @param _D_ma_time Moving average window for the D oracle. It is time_in_seconds / ln(2).\r\n    \"\"\"\r\n    assert msg.sender == factory.admin()  # dev: only owner\r\n    assert unsafe_mul(_ma_exp_time, _D_ma_time) > 0  # dev: 0 in input values\r\n\r\n    self.ma_exp_time = _ma_exp_time\r\n    self.D_ma_time = _D_ma_time\r\n\r\n    log SetNewMATime(_ma_exp_time, _D_ma_time)", "ABI": "[{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenExchange\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"sold_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"tokens_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"bought_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"tokens_bought\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenExchangeUnderlying\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"sold_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"tokens_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"bought_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"tokens_bought\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"fees\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"invariant\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"fees\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidityOne\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"token_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"coin_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidityImbalance\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"fees\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"invariant\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RampA\",\"inputs\":[{\"name\":\"old_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"initial_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StopRampA\",\"inputs\":[{\"name\":\"A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"t\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyNewFee\",\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"offpeg_fee_multiplier\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetNewMATime\",\"inputs\":[{\"name\":\"ma_exp_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"D_ma_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_A\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_offpeg_fee_multiplier\",\"type\":\"uint256\"},{\"name\":\"_ma_exp_time\",\"type\":\"uint256\"},{\"name\":\"_coins\",\"type\":\"address[]\"},{\"name\":\"_rate_multipliers\",\"type\":\"uint256[]\"},{\"name\":\"_asset_types\",\"type\":\"uint8[]\"},{\"name\":\"_method_ids\",\"type\":\"bytes4[]\"},{\"name\":\"_oracles\",\"type\":\"address[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_received\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_received\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_received\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_received\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_claim_admin_fees\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw_admin_fees\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_price\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ema_price\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_p\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_oracle\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"D_oracle\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"permit\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_virtual_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_is_deposit\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"A_precise\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balances\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_balances\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"stored_rates\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"dynamic_fee\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"ramp_A\",\"inputs\":[{\"name\":\"_future_A\",\"type\":\"uint256\"},{\"name\":\"_future_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stop_ramp_A\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_new_fee\",\"inputs\":[{\"name\":\"_new_fee\",\"type\":\"uint256\"},{\"name\":\"_new_offpeg_fee_multiplier\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_ma_exp_time\",\"inputs\":[{\"name\":\"_ma_exp_time\",\"type\":\"uint256\"},{\"name\":\"_D_ma_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"N_COINS\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"coins\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"offpeg_fee_multiplier\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_balances\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ma_exp_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"D_ma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ma_last_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nonces\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"salt\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]}]", "ContractName": "CurveStableSwapNG", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000ba43b7400000000000000000000000000000000000000000000000000000000000000036200000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000002a0000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003600000000000000000000000000000000000000000000000000000000000000009774554482f724554480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000877455448724554480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000ae78736cd615f374d3085123a210448e74fc639300000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e6aa216c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ae78736cd615f374d3085123a210448e74fc6393", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}