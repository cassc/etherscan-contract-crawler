{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Dnner.sol\": {\r\n      \"content\": \"// @dev Dnner Note:\\n// - Dnner(DN404ND) does not possess the fragmentability, nor does\\n//   it have the feature of NFT transactions without the\\n//   need for a third party, characteristic of ERC404/DN404.\\n//\\n//   DN404 can easily create efficient hybrid tokens and\\n//   define the ratio between NFT and tokens.\\n//   We aim to leverage the foundation of DN404 to enable\\n//   NFT to drive the increase in token value.\\n//\\n//   Another way of putting it is to avoid turning NFTs\\n//   into purely tokenized assets.\\n//\\n//   This is an experimental project not conforming to\\n//   the 404 standard, DYOR and read more from our website.\\n\\n//   Twitter: https://twitter.com/DN404ND\\n//   Website: https://dnner.shop\\n//\\n// SPX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../DN404ND.sol\\\";\\nimport \\\"../DN404Mirror.sol\\\";\\nimport \\\"solady/utils/ReentrancyGuard.sol\\\";\\nimport {ECDSA} from \\\"solady/utils/ECDSA.sol\\\";\\nimport {Base64} from \\\"solady/utils/Base64.sol\\\";\\nimport {Ownable} from \\\"solady/auth/Ownable.sol\\\";\\nimport {LibString} from \\\"solady/utils/LibString.sol\\\";\\nimport {SafeTransferLib} from \\\"solady/utils/SafeTransferLib.sol\\\";\\n\\ncontract Dnner is DN404ND, Ownable, ReentrancyGuard {\\n    string private _name;\\n    string private _symbol;\\n    string private _baseURI;\\n\\n    uint256 private constant BURN_REWARD_RATIO = 40000;\\n    uint256 private constant BURNT_ALLOC_RATIO = 20000;\\n    uint256 public initialNFTValue = _NFTUnit();\\n    uint256 public maxNFTSupply = 10000;\\n    uint256 public maxMint = 9500;\\n    uint256 public price = 0.005 ether;\\n    uint256 public maxBuy = 60;\\n\\n    bool public openSetSkipNFT = false;\\n    bool public openNextStage = false;\\n    bool public openUnlock = false;\\n    bool public openBuy = true;\\n\\n    address signer;\\n    address team;\\n\\n    /* ------------------ */\\n    /*    Custom Event    */\\n    /* ------------------ */\\n\\n    event Burn(uint256 amount, uint256 reward, uint256 fee);\\n    event Buy(uint256 amount);\\n\\n    /* ------------------ */\\n    /*    Custom Error    */\\n    /* ------------------ */\\n\\n    error InvalidSender();\\n    error InvalidSignature();\\n    error ReachedMaxBuy();\\n    error InvalidOperation();\\n\\n    modifier onlyEOA() {\\n        if (msg.sender != tx.origin) {\\n            revert InvalidSender();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyHolder(address from) {\\n        if (msg.sender != from) {\\n            revert InvalidSender();\\n        }\\n        _;\\n    }\\n\\n    /* ------------------ */\\n    /*     Constructor    */\\n    /* ------------------ */\\n\\n    constructor() {\\n        _name = \\\"Dnner\\\";\\n        _symbol = \\\"DNNER\\\";\\n\\n        _initializeOwner(msg.sender);\\n        _setMaxNFTSupply(maxNFTSupply);\\n        _setSkipNFT(address(this), true);\\n        setTeamWallet(msg.sender);\\n        setSigner(0x59d5Fbf6297F58D0E6e29edDa4457e860Ac3935a);\\n\\n        address mirror = address(new DN404Mirror(msg.sender));\\n        _initializeDN404(\\n            uint96(maxNFTSupply * 19 * _unit()),\\n            msg.sender,\\n            mirror\\n        );\\n    }\\n\\n    /* ------------------ */\\n    /*         Buy        */\\n    /* ------------------ */\\n\\n    function buyDnner(uint256 amount, bytes calldata signature)\\n        public\\n        payable\\n        onlyEOA\\n    {\\n        uint256 payAmount = amount - 1;\\n        uint256 mintAmount = amount > 1 ? amount > 10 ? 10 : amount : 1;\\n        if (openBuy == false) {\\n            revert InvalidOperation();\\n        }\\n        if (addressAlias(msg.sender) > 0) {\\n            revert InvalidOperation();\\n        }\\n        if (amount > maxBuy) {\\n            revert ReachedMaxBuy();\\n        }\\n        if (amount > 1 && (price * payAmount) > msg.value) {\\n            revert InsufficientBalance();\\n        }\\n        if (_totalNFTSupply() + amount > maxMint) {\\n            revert TotalSupplyOverflow();\\n        }\\n        if (!verify(signature)) {\\n            revert InvalidSignature();\\n        }\\n        _mint(msg.sender, mintAmount * _NFTUnit());\\n\\n        emit Buy(amount);\\n    }\\n\\n    function verify(bytes calldata s) private view returns (bool) {\\n        bytes32 hash = ECDSA.toEthSignedMessageHash(\\n            keccak256(abi.encodePacked(msg.sender))\\n        );\\n\\n        address a = ECDSA.recover(hash, s);\\n\\n        return signer == a;\\n    }\\n\\n    /* ------------------ */\\n    /*        Wrap        */\\n    /* ------------------ */\\n\\n    // Wrap tokens to NFT, will add `initialNFTValue` token to reward pool.\\n    function wrap(address from, uint256 amount)\\n        public\\n        onlyHolder(from)\\n        onlyEOA\\n    {\\n        uint256 wrapCost = amount * initialNFTValue;\\n        if (openNextStage == false) revert InvalidOperation();\\n        if (_totalNFTSupply() + amount > _getMaxNFTSupply())\\n            revert TotalSupplyOverflow();\\n        if (balanceOf(msg.sender) < wrapCost) revert InsufficientBalance();\\n\\n        _mint(msg.sender, amount * _NFTUnit());\\n        _transfer(from, address(this), wrapCost);\\n    }\\n\\n    /* ------------------ */\\n    /*        Burn        */\\n    /* ------------------ */\\n\\n    // Burn amount of NFT, the fee which will back to reward pool.\\n    function eat(address from, uint256 amount)\\n        public\\n        nonReentrant\\n        onlyHolder(from)\\n        onlyEOA\\n    {\\n        uint256 fees = initialNFTValue * amount;\\n        if (openNextStage == false) revert InvalidOperation();\\n        if (_balanceOfNFT(msg.sender) < amount) revert InsufficientBalance();\\n        if (balanceOf(msg.sender) < fees) revert InsufficientBalance();\\n\\n        uint256 totalReward = 0;\\n        uint256 lastSupply = _totalNFTSupply();\\n\\n        for (uint256 i = 0; i < amount; i++) {\\n            totalReward += burnReward();\\n            unchecked {\\n                lastSupply--;\\n            }\\n            initialNFTValue +=\\n                ((initialNFTValue * BURN_REWARD_RATIO * BURNT_ALLOC_RATIO) /\\n                    lastSupply) /\\n                10**8;\\n        }\\n\\n        _burn(msg.sender, amount * _NFTUnit(), true);\\n        _transfer(address(this), msg.sender, totalReward - fees);\\n\\n        emit Burn(amount, totalReward, fees);\\n    }\\n\\n    function burnReward() public view returns (uint256) {\\n        return (initialNFTValue * BURN_REWARD_RATIO) / 10000;\\n    }\\n\\n    /* ------------------ */\\n    /*       Unlock       */\\n    /* ------------------ */\\n\\n    function unlock(address from) public nonReentrant onlyHolder(from) onlyEOA {\\n        if (openUnlock == false) revert InvalidOperation();\\n        _unlock(from);\\n    }\\n\\n    function lockedBalance(address from)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _getDN404Storage().addressData[from].lockedBalance;\\n    }\\n\\n    /* ------------------ */\\n    /*         DEV        */\\n    /* ------------------ */\\n\\n    function reserve(uint256 amount) public {\\n        if (msg.sender != team) {\\n            revert InvalidSender();\\n        }\\n        if (_totalNFTSupply() + amount > _getMaxNFTSupply()) {\\n            revert TotalSupplyOverflow();\\n        }\\n\\n        _mint(msg.sender, amount * _NFTUnit());\\n    }\\n\\n    function setBaseURI(string calldata baseURI_) public onlyOwner {\\n        _baseURI = baseURI_;\\n    }\\n\\n    function setPrices(uint120 price_) public onlyOwner {\\n        price = price_;\\n    }\\n\\n    function setMaxBuy(uint256 maxBuy_) public onlyOwner {\\n        maxBuy = maxBuy_;\\n    }\\n\\n    function setMaxNFTSupply(uint256 value) public onlyOwner {\\n        _setMaxNFTSupply(value);\\n    }\\n\\n    function setTeamWallet(address a) public onlyOwner {\\n        team = a;\\n    }\\n\\n    function setSigner(address a) public onlyOwner {\\n        signer = a;\\n    }\\n\\n    function toggleOpenSetSkipNFT() public onlyOwner {\\n        openSetSkipNFT = !openSetSkipNFT;\\n    }\\n\\n    function toggleOpenUnlock() public onlyOwner {\\n        openUnlock = !openUnlock;\\n    }\\n\\n    function toggleOpenNextStage() public onlyOwner {\\n        openNextStage = !openNextStage;\\n    }\\n\\n    function toggleOpenBuy() public onlyOwner {\\n        openBuy = !openBuy;\\n    }\\n\\n    function withdraw() public onlyOwner nonReentrant {\\n        SafeTransferLib.safeTransferAllETH(team);\\n    }\\n\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function _unit() internal view override returns (uint256) {\\n        return initialNFTValue;\\n    }\\n\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (string memory result)\\n    {\\n        if (bytes(_baseURI).length != 0) {\\n            result = string(\\n                abi.encodePacked(_baseURI, LibString.toString(tokenId))\\n            );\\n        }\\n    }\\n\\n    function getTokensOfOwner(address a)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return _tokensOfWithChecks(a);\\n    }\\n\\n    function getNFTSupply() public view returns (uint256) {\\n        return _totalNFTSupply();\\n    }\\n\\n    function lastNFTUnit(uint256 id) public view returns (uint256) {\\n        return _get(_getDN404Storage().NFTUnit, id);\\n    }\\n\\n    function addressAlias(address a) public view returns (uint32) {\\n        return _getDN404Storage().addressData[a].addressAlias;\\n    }\\n\\n    /* ---------------------- */\\n    /*   Override Operation   */\\n    /* ---------------------- */\\n\\n    // setSkipNFT lokced before all NFT minted.\\n    function setSkipNFT(bool skip) public override returns (bool) {\\n        if (openSetSkipNFT == false) revert InvalidOperation();\\n\\n        _setSkipNFT(msg.sender, skip);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\r\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\r\\n///\\r\\n/// @dev Note:\\r\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\r\\n/// - For ERC20s, this implementation won't check that a token has code,\\r\\n///   responsibility is delegated to the caller.\\r\\nlibrary SafeTransferLib {\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                       CUSTOM ERRORS                        */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The ETH transfer has failed.\\r\\n    error ETHTransferFailed();\\r\\n\\r\\n    /// @dev The ERC20 `transferFrom` has failed.\\r\\n    error TransferFromFailed();\\r\\n\\r\\n    /// @dev The ERC20 `transfer` has failed.\\r\\n    error TransferFailed();\\r\\n\\r\\n    /// @dev The ERC20 `approve` has failed.\\r\\n    error ApproveFailed();\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                         CONSTANTS                          */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\r\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\r\\n\\r\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\r\\n    /// storage reads and writes, but low enough to prevent griefing.\\r\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                       ETH OPERATIONS                       */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\r\\n    //\\r\\n    // The regular variants:\\r\\n    // - Forwards all remaining gas to the target.\\r\\n    // - Reverts if the target reverts.\\r\\n    // - Reverts if the current contract has insufficient balance.\\r\\n    //\\r\\n    // The force variants:\\r\\n    // - Forwards with an optional gas stipend\\r\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\r\\n    // - If the target reverts, or if the gas stipend is exhausted,\\r\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\r\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\r\\n    // - Reverts if the current contract has insufficient balance.\\r\\n    //\\r\\n    // The try variants:\\r\\n    // - Forwards with a mandatory gas stipend.\\r\\n    // - Instead of reverting, returns whether the transfer succeeded.\\r\\n\\r\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\r\\n    function safeTransferETH(address to, uint256 amount) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\r\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sends all the ETH in the current contract to `to`.\\r\\n    function safeTransferAllETH(address to) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Transfer all the ETH and check if it succeeded or not.\\r\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\r\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\r\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if lt(selfbalance(), amount) {\\r\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\r\\n                mstore(0x00, to) // Store the address in scratch space.\\r\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\r\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\r\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\r\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\r\\n                mstore(0x00, to) // Store the address in scratch space.\\r\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\r\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\r\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\r\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if lt(selfbalance(), amount) {\\r\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\r\\n                mstore(0x00, to) // Store the address in scratch space.\\r\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\r\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\r\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\r\\n    function forceSafeTransferAllETH(address to) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // forgefmt: disable-next-item\\r\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\r\\n                mstore(0x00, to) // Store the address in scratch space.\\r\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\r\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\r\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\r\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\r\\n        internal\\r\\n        returns (bool success)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\r\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\r\\n        internal\\r\\n        returns (bool success)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                      ERC20 OPERATIONS                      */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\r\\n    /// Reverts upon failure.\\r\\n    ///\\r\\n    /// The `from` account must have at least `amount` approved for\\r\\n    /// the current contract to manage.\\r\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x60, amount) // Store the `amount` argument.\\r\\n            mstore(0x40, to) // Store the `to` argument.\\r\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\r\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\r\\n            // Perform the transfer, reverting upon failure.\\r\\n            if iszero(\\r\\n                and( // The arguments of `and` are evaluated from right to left.\\r\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\r\\n    /// Reverts upon failure.\\r\\n    ///\\r\\n    /// The `from` account must have their entire balance approved for\\r\\n    /// the current contract to manage.\\r\\n    function safeTransferAllFrom(address token, address from, address to)\\r\\n        internal\\r\\n        returns (uint256 amount)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x40, to) // Store the `to` argument.\\r\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\r\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\r\\n            // Read the balance, reverting upon failure.\\r\\n            if iszero(\\r\\n                and( // The arguments of `and` are evaluated from right to left.\\r\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\r\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\r\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\r\\n            // Perform the transfer, reverting upon failure.\\r\\n            if iszero(\\r\\n                and( // The arguments of `and` are evaluated from right to left.\\r\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\r\\n    /// Reverts upon failure.\\r\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x14, to) // Store the `to` argument.\\r\\n            mstore(0x34, amount) // Store the `amount` argument.\\r\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\r\\n            // Perform the transfer, reverting upon failure.\\r\\n            if iszero(\\r\\n                and( // The arguments of `and` are evaluated from right to left.\\r\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\r\\n    /// Reverts upon failure.\\r\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\r\\n            mstore(0x20, address()) // Store the address of the current contract.\\r\\n            // Read the balance, reverting upon failure.\\r\\n            if iszero(\\r\\n                and( // The arguments of `and` are evaluated from right to left.\\r\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\r\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x14, to) // Store the `to` argument.\\r\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\r\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\r\\n            // Perform the transfer, reverting upon failure.\\r\\n            if iszero(\\r\\n                and( // The arguments of `and` are evaluated from right to left.\\r\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\r\\n    /// Reverts upon failure.\\r\\n    function safeApprove(address token, address to, uint256 amount) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x14, to) // Store the `to` argument.\\r\\n            mstore(0x34, amount) // Store the `amount` argument.\\r\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\r\\n            // Perform the approval, reverting upon failure.\\r\\n            if iszero(\\r\\n                and( // The arguments of `and` are evaluated from right to left.\\r\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\r\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\r\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\r\\n    /// Reverts upon failure.\\r\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x14, to) // Store the `to` argument.\\r\\n            mstore(0x34, amount) // Store the `amount` argument.\\r\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\r\\n            // Perform the approval, retrying upon failure.\\r\\n            if iszero(\\r\\n                and( // The arguments of `and` are evaluated from right to left.\\r\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\r\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\r\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\r\\n                mstore(0x34, amount) // Store back the original `amount`.\\r\\n                // Retry the approval, reverting upon failure.\\r\\n                if iszero(\\r\\n                    and(\\r\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\r\\n                    )\\r\\n                ) {\\r\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\r\\n                    revert(0x1c, 0x04)\\r\\n                }\\r\\n            }\\r\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\r\\n    /// Returns zero if the `token` does not exist.\\r\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x14, account) // Store the `account` argument.\\r\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\r\\n            amount :=\\r\\n                mul(\\r\\n                    mload(0x20),\\r\\n                    and( // The arguments of `and` are evaluated from right to left.\\r\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\r\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\r\\n                    )\\r\\n                )\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"solady/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Library for converting numbers into strings and other string operations.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\r\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\r\\n///\\r\\n/// @dev Note:\\r\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\r\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\r\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\r\\n/// can lead to undefined behavior.\\r\\nlibrary LibString {\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                        CUSTOM ERRORS                       */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The length of the output is too small to contain all the hex digits.\\r\\n    error HexLengthInsufficient();\\r\\n\\r\\n    /// @dev The length of the string is more than 32 bytes.\\r\\n    error TooBigForSmallString();\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                         CONSTANTS                          */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The constant returned when the `search` is not found in the string.\\r\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                     DECIMAL OPERATIONS                     */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns the base 10 decimal representation of `value`.\\r\\n    function toString(uint256 value) internal pure returns (string memory str) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\r\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\r\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\r\\n            // and 3 words for a maximum of 78 digits.\\r\\n            str := add(mload(0x40), 0x80)\\r\\n            // Update the free memory pointer to allocate.\\r\\n            mstore(0x40, add(str, 0x20))\\r\\n            // Zeroize the slot after the string.\\r\\n            mstore(str, 0)\\r\\n\\r\\n            // Cache the end of the memory to calculate the length later.\\r\\n            let end := str\\r\\n\\r\\n            let w := not(0) // Tsk.\\r\\n            // We write the string from rightmost digit to leftmost digit.\\r\\n            // The following is essentially a do-while loop that also handles the zero case.\\r\\n            for { let temp := value } 1 {} {\\r\\n                str := add(str, w) // `sub(str, 1)`.\\r\\n                // Write the character to the pointer.\\r\\n                // The ASCII index of the '0' character is 48.\\r\\n                mstore8(str, add(48, mod(temp, 10)))\\r\\n                // Keep dividing `temp` until zero.\\r\\n                temp := div(temp, 10)\\r\\n                if iszero(temp) { break }\\r\\n            }\\r\\n\\r\\n            let length := sub(end, str)\\r\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\r\\n            str := sub(str, 0x20)\\r\\n            // Store the length.\\r\\n            mstore(str, length)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the base 10 decimal representation of `value`.\\r\\n    function toString(int256 value) internal pure returns (string memory str) {\\r\\n        if (value >= 0) {\\r\\n            return toString(uint256(value));\\r\\n        }\\r\\n        unchecked {\\r\\n            str = toString(~uint256(value) + 1);\\r\\n        }\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // We still have some spare memory space on the left,\\r\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\r\\n            let length := mload(str) // Load the string length.\\r\\n            mstore(str, 0x2d) // Store the '-' character.\\r\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\r\\n            mstore(str, add(length, 1)) // Update the string length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   HEXADECIMAL OPERATIONS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`,\\r\\n    /// left-padded to an input length of `length` bytes.\\r\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\r\\n    /// giving a total length of `length * 2 + 2` bytes.\\r\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\r\\n        str = toHexStringNoPrefix(value, length);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let strLength := add(mload(str), 2) // Compute the length.\\r\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\r\\n            str := sub(str, 2) // Move the pointer.\\r\\n            mstore(str, strLength) // Write the length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`,\\r\\n    /// left-padded to an input length of `length` bytes.\\r\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\r\\n    /// giving a total length of `length * 2` bytes.\\r\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\r\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory str)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\r\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\r\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\r\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\r\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\r\\n            // Allocate the memory.\\r\\n            mstore(0x40, add(str, 0x20))\\r\\n            // Zeroize the slot after the string.\\r\\n            mstore(str, 0)\\r\\n\\r\\n            // Cache the end to calculate the length later.\\r\\n            let end := str\\r\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\r\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\r\\n\\r\\n            let start := sub(str, add(length, length))\\r\\n            let w := not(1) // Tsk.\\r\\n            let temp := value\\r\\n            // We write the string from rightmost digit to leftmost digit.\\r\\n            // The following is essentially a do-while loop that also handles the zero case.\\r\\n            for {} 1 {} {\\r\\n                str := add(str, w) // `sub(str, 2)`.\\r\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\r\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\r\\n                temp := shr(8, temp)\\r\\n                if iszero(xor(str, start)) { break }\\r\\n            }\\r\\n\\r\\n            if temp {\\r\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n\\r\\n            // Compute the string's length.\\r\\n            let strLength := sub(end, str)\\r\\n            // Move the pointer and write the length.\\r\\n            str := sub(str, 0x20)\\r\\n            mstore(str, strLength)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\r\\n    /// As address are 20 bytes long, the output will left-padded to have\\r\\n    /// a length of `20 * 2 + 2` bytes.\\r\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\r\\n        str = toHexStringNoPrefix(value);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let strLength := add(mload(str), 2) // Compute the length.\\r\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\r\\n            str := sub(str, 2) // Move the pointer.\\r\\n            mstore(str, strLength) // Write the length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output is prefixed with \\\"0x\\\".\\r\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\r\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\r\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\r\\n        str = toHexStringNoPrefix(value);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\r\\n            let strLength := add(mload(str), 2) // Compute the length.\\r\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\r\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\r\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\r\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\r\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\r\\n        str = toHexStringNoPrefix(value);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\r\\n            let strLength := mload(str) // Get the length.\\r\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\r\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\r\\n    /// As address are 20 bytes long, the output will left-padded to have\\r\\n    /// a length of `20 * 2` bytes.\\r\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\r\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\r\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\r\\n            str := add(mload(0x40), 0x80)\\r\\n            // Allocate the memory.\\r\\n            mstore(0x40, add(str, 0x20))\\r\\n            // Zeroize the slot after the string.\\r\\n            mstore(str, 0)\\r\\n\\r\\n            // Cache the end to calculate the length later.\\r\\n            let end := str\\r\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\r\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\r\\n\\r\\n            let w := not(1) // Tsk.\\r\\n            // We write the string from rightmost digit to leftmost digit.\\r\\n            // The following is essentially a do-while loop that also handles the zero case.\\r\\n            for { let temp := value } 1 {} {\\r\\n                str := add(str, w) // `sub(str, 2)`.\\r\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\r\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\r\\n                temp := shr(8, temp)\\r\\n                if iszero(temp) { break }\\r\\n            }\\r\\n\\r\\n            // Compute the string's length.\\r\\n            let strLength := sub(end, str)\\r\\n            // Move the pointer and write the length.\\r\\n            str := sub(str, 0x20)\\r\\n            mstore(str, strLength)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\r\\n    /// and the alphabets are capitalized conditionally according to\\r\\n    /// https://eips.ethereum.org/EIPS/eip-55\\r\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\r\\n        str = toHexString(value);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\r\\n            let o := add(str, 0x22)\\r\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\r\\n            let t := shl(240, 136) // `0b10001000 << 240`\\r\\n            for { let i := 0 } 1 {} {\\r\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\r\\n                i := add(i, 1)\\r\\n                if eq(i, 20) { break }\\r\\n            }\\r\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\r\\n            o := add(o, 0x20)\\r\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\r\\n    function toHexString(address value) internal pure returns (string memory str) {\\r\\n        str = toHexStringNoPrefix(value);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let strLength := add(mload(str), 2) // Compute the length.\\r\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\r\\n            str := sub(str, 2) // Move the pointer.\\r\\n            mstore(str, strLength) // Write the length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\r\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            str := mload(0x40)\\r\\n\\r\\n            // Allocate the memory.\\r\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\r\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\r\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\r\\n            mstore(0x40, add(str, 0x80))\\r\\n\\r\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\r\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\r\\n\\r\\n            str := add(str, 2)\\r\\n            mstore(str, 40)\\r\\n\\r\\n            let o := add(str, 0x20)\\r\\n            mstore(add(o, 40), 0)\\r\\n\\r\\n            value := shl(96, value)\\r\\n\\r\\n            // We write the string from rightmost digit to leftmost digit.\\r\\n            // The following is essentially a do-while loop that also handles the zero case.\\r\\n            for { let i := 0 } 1 {} {\\r\\n                let p := add(o, add(i, i))\\r\\n                let temp := byte(i, value)\\r\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\r\\n                mstore8(p, mload(shr(4, temp)))\\r\\n                i := add(i, 1)\\r\\n                if eq(i, 20) { break }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hex encoded string from the raw bytes.\\r\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\r\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\r\\n        str = toHexStringNoPrefix(raw);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let strLength := add(mload(str), 2) // Compute the length.\\r\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\r\\n            str := sub(str, 2) // Move the pointer.\\r\\n            mstore(str, strLength) // Write the length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hex encoded string from the raw bytes.\\r\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\r\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let length := mload(raw)\\r\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\r\\n            mstore(str, add(length, length)) // Store the length of the output.\\r\\n\\r\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\r\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\r\\n\\r\\n            let o := add(str, 0x20)\\r\\n            let end := add(raw, length)\\r\\n\\r\\n            for {} iszero(eq(raw, end)) {} {\\r\\n                raw := add(raw, 1)\\r\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\r\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\r\\n                o := add(o, 2)\\r\\n            }\\r\\n            mstore(o, 0) // Zeroize the slot after the string.\\r\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   RUNE STRING OPERATIONS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns the number of UTF characters in the string.\\r\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if mload(s) {\\r\\n                mstore(0x00, div(not(0), 255))\\r\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\r\\n                let o := add(s, 0x20)\\r\\n                let end := add(o, mload(s))\\r\\n                for { result := 1 } 1 { result := add(result, 1) } {\\r\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\r\\n                    if iszero(lt(o, end)) { break }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\r\\n    /// (i.e. all characters codes are in [0..127])\\r\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let mask := shl(7, div(not(0), 255))\\r\\n            result := 1\\r\\n            let n := mload(s)\\r\\n            if n {\\r\\n                let o := add(s, 0x20)\\r\\n                let end := add(o, n)\\r\\n                let last := mload(end)\\r\\n                mstore(end, 0)\\r\\n                for {} 1 {} {\\r\\n                    if and(mask, mload(o)) {\\r\\n                        result := 0\\r\\n                        break\\r\\n                    }\\r\\n                    o := add(o, 0x20)\\r\\n                    if iszero(lt(o, end)) { break }\\r\\n                }\\r\\n                mstore(end, last)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   BYTE STRING OPERATIONS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    // For performance and bytecode compactness, byte string operations are restricted\\r\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\r\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\r\\n    // can lead to undefined behavior.\\r\\n\\r\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\r\\n    function replace(string memory subject, string memory search, string memory replacement)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let subjectLength := mload(subject)\\r\\n            let searchLength := mload(search)\\r\\n            let replacementLength := mload(replacement)\\r\\n\\r\\n            subject := add(subject, 0x20)\\r\\n            search := add(search, 0x20)\\r\\n            replacement := add(replacement, 0x20)\\r\\n            result := add(mload(0x40), 0x20)\\r\\n\\r\\n            let subjectEnd := add(subject, subjectLength)\\r\\n            if iszero(gt(searchLength, subjectLength)) {\\r\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\r\\n                let h := 0\\r\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\r\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\r\\n                let s := mload(search)\\r\\n                for {} 1 {} {\\r\\n                    let t := mload(subject)\\r\\n                    // Whether the first `searchLength % 32` bytes of\\r\\n                    // `subject` and `search` matches.\\r\\n                    if iszero(shr(m, xor(t, s))) {\\r\\n                        if h {\\r\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\r\\n                                mstore(result, t)\\r\\n                                result := add(result, 1)\\r\\n                                subject := add(subject, 1)\\r\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\r\\n                                continue\\r\\n                            }\\r\\n                        }\\r\\n                        // Copy the `replacement` one word at a time.\\r\\n                        for { let o := 0 } 1 {} {\\r\\n                            mstore(add(result, o), mload(add(replacement, o)))\\r\\n                            o := add(o, 0x20)\\r\\n                            if iszero(lt(o, replacementLength)) { break }\\r\\n                        }\\r\\n                        result := add(result, replacementLength)\\r\\n                        subject := add(subject, searchLength)\\r\\n                        if searchLength {\\r\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\r\\n                            continue\\r\\n                        }\\r\\n                    }\\r\\n                    mstore(result, t)\\r\\n                    result := add(result, 1)\\r\\n                    subject := add(subject, 1)\\r\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            let resultRemainder := result\\r\\n            result := add(mload(0x40), 0x20)\\r\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\r\\n            // Copy the rest of the string one word at a time.\\r\\n            for {} lt(subject, subjectEnd) {} {\\r\\n                mstore(resultRemainder, mload(subject))\\r\\n                resultRemainder := add(resultRemainder, 0x20)\\r\\n                subject := add(subject, 0x20)\\r\\n            }\\r\\n            result := sub(result, 0x20)\\r\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\r\\n            mstore(last, 0)\\r\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\r\\n            mstore(result, k) // Store the length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\r\\n    /// searching from left to right, starting from `from`.\\r\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\r\\n    function indexOf(string memory subject, string memory search, uint256 from)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            for { let subjectLength := mload(subject) } 1 {} {\\r\\n                if iszero(mload(search)) {\\r\\n                    if iszero(gt(from, subjectLength)) {\\r\\n                        result := from\\r\\n                        break\\r\\n                    }\\r\\n                    result := subjectLength\\r\\n                    break\\r\\n                }\\r\\n                let searchLength := mload(search)\\r\\n                let subjectStart := add(subject, 0x20)\\r\\n\\r\\n                result := not(0) // Initialize to `NOT_FOUND`.\\r\\n\\r\\n                subject := add(subjectStart, from)\\r\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\r\\n\\r\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\r\\n                let s := mload(add(search, 0x20))\\r\\n\\r\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\r\\n\\r\\n                if iszero(lt(searchLength, 0x20)) {\\r\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\r\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\r\\n                            if eq(keccak256(subject, searchLength), h) {\\r\\n                                result := sub(subject, subjectStart)\\r\\n                                break\\r\\n                            }\\r\\n                        }\\r\\n                        subject := add(subject, 1)\\r\\n                        if iszero(lt(subject, end)) { break }\\r\\n                    }\\r\\n                    break\\r\\n                }\\r\\n                for {} 1 {} {\\r\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\r\\n                        result := sub(subject, subjectStart)\\r\\n                        break\\r\\n                    }\\r\\n                    subject := add(subject, 1)\\r\\n                    if iszero(lt(subject, end)) { break }\\r\\n                }\\r\\n                break\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\r\\n    /// searching from left to right.\\r\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\r\\n    function indexOf(string memory subject, string memory search)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        result = indexOf(subject, search, 0);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\r\\n    /// searching from right to left, starting from `from`.\\r\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\r\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            for {} 1 {} {\\r\\n                result := not(0) // Initialize to `NOT_FOUND`.\\r\\n                let searchLength := mload(search)\\r\\n                if gt(searchLength, mload(subject)) { break }\\r\\n                let w := result\\r\\n\\r\\n                let fromMax := sub(mload(subject), searchLength)\\r\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\r\\n\\r\\n                let end := add(add(subject, 0x20), w)\\r\\n                subject := add(add(subject, 0x20), from)\\r\\n                if iszero(gt(subject, end)) { break }\\r\\n                // As this function is not too often used,\\r\\n                // we shall simply use keccak256 for smaller bytecode size.\\r\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\r\\n                    if eq(keccak256(subject, searchLength), h) {\\r\\n                        result := sub(subject, add(end, 1))\\r\\n                        break\\r\\n                    }\\r\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\r\\n                    if iszero(gt(subject, end)) { break }\\r\\n                }\\r\\n                break\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\r\\n    /// searching from right to left.\\r\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\r\\n    function lastIndexOf(string memory subject, string memory search)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\r\\n    }\\r\\n\\r\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\r\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\r\\n        return indexOf(subject, search) != NOT_FOUND;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `subject` starts with `search`.\\r\\n    function startsWith(string memory subject, string memory search)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let searchLength := mload(search)\\r\\n            // Just using keccak256 directly is actually cheaper.\\r\\n            // forgefmt: disable-next-item\\r\\n            result := and(\\r\\n                iszero(gt(searchLength, mload(subject))),\\r\\n                eq(\\r\\n                    keccak256(add(subject, 0x20), searchLength),\\r\\n                    keccak256(add(search, 0x20), searchLength)\\r\\n                )\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `subject` ends with `search`.\\r\\n    function endsWith(string memory subject, string memory search)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let searchLength := mload(search)\\r\\n            let subjectLength := mload(subject)\\r\\n            // Whether `search` is not longer than `subject`.\\r\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\r\\n            // Just using keccak256 directly is actually cheaper.\\r\\n            // forgefmt: disable-next-item\\r\\n            result := and(\\r\\n                withinRange,\\r\\n                eq(\\r\\n                    keccak256(\\r\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\r\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\r\\n                        searchLength\\r\\n                    ),\\r\\n                    keccak256(add(search, 0x20), searchLength)\\r\\n                )\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns `subject` repeated `times`.\\r\\n    function repeat(string memory subject, uint256 times)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let subjectLength := mload(subject)\\r\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\r\\n                subject := add(subject, 0x20)\\r\\n                result := mload(0x40)\\r\\n                let output := add(result, 0x20)\\r\\n                for {} 1 {} {\\r\\n                    // Copy the `subject` one word at a time.\\r\\n                    for { let o := 0 } 1 {} {\\r\\n                        mstore(add(output, o), mload(add(subject, o)))\\r\\n                        o := add(o, 0x20)\\r\\n                        if iszero(lt(o, subjectLength)) { break }\\r\\n                    }\\r\\n                    output := add(output, subjectLength)\\r\\n                    times := sub(times, 1)\\r\\n                    if iszero(times) { break }\\r\\n                }\\r\\n                mstore(output, 0) // Zeroize the slot after the string.\\r\\n                let resultLength := sub(output, add(result, 0x20))\\r\\n                mstore(result, resultLength) // Store the length.\\r\\n                // Allocate the memory.\\r\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\r\\n    /// `start` and `end` are byte offsets.\\r\\n    function slice(string memory subject, uint256 start, uint256 end)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let subjectLength := mload(subject)\\r\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\r\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\r\\n            if lt(start, end) {\\r\\n                result := mload(0x40)\\r\\n                let resultLength := sub(end, start)\\r\\n                mstore(result, resultLength)\\r\\n                subject := add(subject, start)\\r\\n                let w := not(0x1f)\\r\\n                // Copy the `subject` one word at a time, backwards.\\r\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\r\\n                    mstore(add(result, o), mload(add(subject, o)))\\r\\n                    o := add(o, w) // `sub(o, 0x20)`.\\r\\n                    if iszero(o) { break }\\r\\n                }\\r\\n                // Zeroize the slot after the string.\\r\\n                mstore(add(add(result, 0x20), resultLength), 0)\\r\\n                // Allocate memory for the length and the bytes,\\r\\n                // rounded up to a multiple of 32.\\r\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\r\\n    /// `start` is a byte offset.\\r\\n    function slice(string memory subject, uint256 start)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        result = slice(subject, start, uint256(int256(-1)));\\r\\n    }\\r\\n\\r\\n    /// @dev Returns all the indices of `search` in `subject`.\\r\\n    /// The indices are byte offsets.\\r\\n    function indicesOf(string memory subject, string memory search)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256[] memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let subjectLength := mload(subject)\\r\\n            let searchLength := mload(search)\\r\\n\\r\\n            if iszero(gt(searchLength, subjectLength)) {\\r\\n                subject := add(subject, 0x20)\\r\\n                search := add(search, 0x20)\\r\\n                result := add(mload(0x40), 0x20)\\r\\n\\r\\n                let subjectStart := subject\\r\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\r\\n                let h := 0\\r\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\r\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\r\\n                let s := mload(search)\\r\\n                for {} 1 {} {\\r\\n                    let t := mload(subject)\\r\\n                    // Whether the first `searchLength % 32` bytes of\\r\\n                    // `subject` and `search` matches.\\r\\n                    if iszero(shr(m, xor(t, s))) {\\r\\n                        if h {\\r\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\r\\n                                subject := add(subject, 1)\\r\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\r\\n                                continue\\r\\n                            }\\r\\n                        }\\r\\n                        // Append to `result`.\\r\\n                        mstore(result, sub(subject, subjectStart))\\r\\n                        result := add(result, 0x20)\\r\\n                        // Advance `subject` by `searchLength`.\\r\\n                        subject := add(subject, searchLength)\\r\\n                        if searchLength {\\r\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\r\\n                            continue\\r\\n                        }\\r\\n                    }\\r\\n                    subject := add(subject, 1)\\r\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\r\\n                }\\r\\n                let resultEnd := result\\r\\n                // Assign `result` to the free memory pointer.\\r\\n                result := mload(0x40)\\r\\n                // Store the length of `result`.\\r\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\r\\n                // Allocate memory for result.\\r\\n                // We allocate one more word, so this array can be recycled for {split}.\\r\\n                mstore(0x40, add(resultEnd, 0x20))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\r\\n    function split(string memory subject, string memory delimiter)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string[] memory result)\\r\\n    {\\r\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let w := not(0x1f)\\r\\n            let indexPtr := add(indices, 0x20)\\r\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\r\\n            mstore(add(indicesEnd, w), mload(subject))\\r\\n            mstore(indices, add(mload(indices), 1))\\r\\n            let prevIndex := 0\\r\\n            for {} 1 {} {\\r\\n                let index := mload(indexPtr)\\r\\n                mstore(indexPtr, 0x60)\\r\\n                if iszero(eq(index, prevIndex)) {\\r\\n                    let element := mload(0x40)\\r\\n                    let elementLength := sub(index, prevIndex)\\r\\n                    mstore(element, elementLength)\\r\\n                    // Copy the `subject` one word at a time, backwards.\\r\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\r\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\r\\n                        o := add(o, w) // `sub(o, 0x20)`.\\r\\n                        if iszero(o) { break }\\r\\n                    }\\r\\n                    // Zeroize the slot after the string.\\r\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\r\\n                    // Allocate memory for the length and the bytes,\\r\\n                    // rounded up to a multiple of 32.\\r\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\r\\n                    // Store the `element` into the array.\\r\\n                    mstore(indexPtr, element)\\r\\n                }\\r\\n                prevIndex := add(index, mload(delimiter))\\r\\n                indexPtr := add(indexPtr, 0x20)\\r\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\r\\n            }\\r\\n            result := indices\\r\\n            if iszero(mload(delimiter)) {\\r\\n                result := add(indices, 0x20)\\r\\n                mstore(result, sub(mload(indices), 2))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a concatenated string of `a` and `b`.\\r\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\r\\n    function concat(string memory a, string memory b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let w := not(0x1f)\\r\\n            result := mload(0x40)\\r\\n            let aLength := mload(a)\\r\\n            // Copy `a` one word at a time, backwards.\\r\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\r\\n                mstore(add(result, o), mload(add(a, o)))\\r\\n                o := add(o, w) // `sub(o, 0x20)`.\\r\\n                if iszero(o) { break }\\r\\n            }\\r\\n            let bLength := mload(b)\\r\\n            let output := add(result, aLength)\\r\\n            // Copy `b` one word at a time, backwards.\\r\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\r\\n                mstore(add(output, o), mload(add(b, o)))\\r\\n                o := add(o, w) // `sub(o, 0x20)`.\\r\\n                if iszero(o) { break }\\r\\n            }\\r\\n            let totalLength := add(aLength, bLength)\\r\\n            let last := add(add(result, 0x20), totalLength)\\r\\n            // Zeroize the slot after the string.\\r\\n            mstore(last, 0)\\r\\n            // Stores the length.\\r\\n            mstore(result, totalLength)\\r\\n            // Allocate memory for the length and the bytes,\\r\\n            // rounded up to a multiple of 32.\\r\\n            mstore(0x40, and(add(last, 0x1f), w))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\r\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\r\\n    function toCase(string memory subject, bool toUpper)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let length := mload(subject)\\r\\n            if length {\\r\\n                result := add(mload(0x40), 0x20)\\r\\n                subject := add(subject, 1)\\r\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\r\\n                let w := not(0)\\r\\n                for { let o := length } 1 {} {\\r\\n                    o := add(o, w)\\r\\n                    let b := and(0xff, mload(add(subject, o)))\\r\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\r\\n                    if iszero(o) { break }\\r\\n                }\\r\\n                result := mload(0x40)\\r\\n                mstore(result, length) // Store the length.\\r\\n                let last := add(add(result, 0x20), length)\\r\\n                mstore(last, 0) // Zeroize the slot after the string.\\r\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a string from a small bytes32 string.\\r\\n    /// `s` must be null-terminated, or behavior will be undefined.\\r\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := mload(0x40)\\r\\n            let n := 0\\r\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\r\\n            mstore(result, n)\\r\\n            let o := add(result, 0x20)\\r\\n            mstore(o, s)\\r\\n            mstore(add(o, n), 0)\\r\\n            mstore(0x40, add(result, 0x40))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\r\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\r\\n            mstore(0x00, s)\\r\\n            mstore(result, 0x00)\\r\\n            result := mload(0x00)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the string as a normalized null-terminated small string.\\r\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := mload(s)\\r\\n            if iszero(lt(result, 33)) {\\r\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a lowercased copy of the string.\\r\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\r\\n    function lower(string memory subject) internal pure returns (string memory result) {\\r\\n        result = toCase(subject, false);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns an UPPERCASED copy of the string.\\r\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\r\\n    function upper(string memory subject) internal pure returns (string memory result) {\\r\\n        result = toCase(subject, true);\\r\\n    }\\r\\n\\r\\n    /// @dev Escapes the string to be used within HTML tags.\\r\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let end := add(s, mload(s))\\r\\n            result := add(mload(0x40), 0x20)\\r\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\r\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\r\\n            mstore(0x1f, 0x900094)\\r\\n            mstore(0x08, 0xc0000000a6ab)\\r\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\r\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\r\\n            for {} iszero(eq(s, end)) {} {\\r\\n                s := add(s, 1)\\r\\n                let c := and(mload(s), 0xff)\\r\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\r\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\r\\n                    mstore8(result, c)\\r\\n                    result := add(result, 1)\\r\\n                    continue\\r\\n                }\\r\\n                let t := shr(248, mload(c))\\r\\n                mstore(result, mload(and(t, 0x1f)))\\r\\n                result := add(result, shr(5, t))\\r\\n            }\\r\\n            let last := result\\r\\n            mstore(last, 0) // Zeroize the slot after the string.\\r\\n            result := mload(0x40)\\r\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\r\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\r\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\r\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let end := add(s, mload(s))\\r\\n            result := add(mload(0x40), 0x20)\\r\\n            if addDoubleQuotes {\\r\\n                mstore8(result, 34)\\r\\n                result := add(1, result)\\r\\n            }\\r\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\r\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\r\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\r\\n            // into the scratch space.\\r\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\r\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\r\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\r\\n            for {} iszero(eq(s, end)) {} {\\r\\n                s := add(s, 1)\\r\\n                let c := and(mload(s), 0xff)\\r\\n                if iszero(lt(c, 0x20)) {\\r\\n                    if iszero(and(shl(c, 1), e)) {\\r\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\r\\n                        mstore8(result, c)\\r\\n                        result := add(result, 1)\\r\\n                        continue\\r\\n                    }\\r\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\r\\n                    mstore8(add(result, 1), c)\\r\\n                    result := add(result, 2)\\r\\n                    continue\\r\\n                }\\r\\n                if iszero(and(shl(c, 1), 0x3700)) {\\r\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\r\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\r\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\r\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\r\\n                    result := add(result, 6)\\r\\n                    continue\\r\\n                }\\r\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\r\\n                mstore8(add(result, 1), mload(add(c, 8)))\\r\\n                result := add(result, 2)\\r\\n            }\\r\\n            if addDoubleQuotes {\\r\\n                mstore8(result, 34)\\r\\n                result := add(1, result)\\r\\n            }\\r\\n            let last := result\\r\\n            mstore(last, 0) // Zeroize the slot after the string.\\r\\n            result := mload(0x40)\\r\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\r\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\r\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\r\\n        result = escapeJSON(s, false);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `a` equals `b`.\\r\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\r\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // These should be evaluated on compile time, as far as possible.\\r\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\r\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\r\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\r\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\r\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\r\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\r\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\r\\n            // forgefmt: disable-next-item\\r\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\r\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Packs a single string with its length into a single word.\\r\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\r\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // We don't need to zero right pad the string,\\r\\n            // since this is our own custom non-standard packing scheme.\\r\\n            result :=\\r\\n                mul(\\r\\n                    // Load the length and the bytes.\\r\\n                    mload(add(a, 0x1f)),\\r\\n                    // `length != 0 && length < 32`. Abuses underflow.\\r\\n                    // Assumes that the length is valid and within the block gas limit.\\r\\n                    lt(sub(mload(a), 1), 0x1f)\\r\\n                )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Unpacks a string packed using {packOne}.\\r\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\r\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\r\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Grab the free memory pointer.\\r\\n            result := mload(0x40)\\r\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\r\\n            mstore(0x40, add(result, 0x40))\\r\\n            // Zeroize the length slot.\\r\\n            mstore(result, 0)\\r\\n            // Store the length and bytes.\\r\\n            mstore(add(result, 0x1f), packed)\\r\\n            // Right pad with zeroes.\\r\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Packs two strings with their lengths into a single word.\\r\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\r\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let aLength := mload(a)\\r\\n            // We don't need to zero right pad the strings,\\r\\n            // since this is our own custom non-standard packing scheme.\\r\\n            result :=\\r\\n                mul(\\r\\n                    // Load the length and the bytes of `a` and `b`.\\r\\n                    or(\\r\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\r\\n                        mload(sub(add(b, 0x1e), aLength))\\r\\n                    ),\\r\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\r\\n                    // Assumes that the lengths are valid and within the block gas limit.\\r\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\r\\n                )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Unpacks strings packed using {packTwo}.\\r\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\r\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\r\\n    function unpackTwo(bytes32 packed)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory resultA, string memory resultB)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Grab the free memory pointer.\\r\\n            resultA := mload(0x40)\\r\\n            resultB := add(resultA, 0x40)\\r\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\r\\n            mstore(0x40, add(resultB, 0x40))\\r\\n            // Zeroize the length slots.\\r\\n            mstore(resultA, 0)\\r\\n            mstore(resultB, 0)\\r\\n            // Store the lengths and bytes.\\r\\n            mstore(add(resultA, 0x1f), packed)\\r\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\r\\n            // Right pad with zeroes.\\r\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\r\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Directly returns `a` without copying.\\r\\n    function directReturn(string memory a) internal pure {\\r\\n        assembly {\\r\\n            // Assumes that the string does not start from the scratch space.\\r\\n            let retStart := sub(a, 0x20)\\r\\n            let retSize := add(mload(a), 0x40)\\r\\n            // Right pad with zeroes. Just in case the string is produced\\r\\n            // by a method that doesn't zero right pad.\\r\\n            mstore(add(retStart, retSize), 0)\\r\\n            // Store the return offset.\\r\\n            mstore(retStart, 0x20)\\r\\n            // End the transaction, returning the string.\\r\\n            return(retStart, retSize)\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"solady/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Simple single owner authorization mixin.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\r\\n///\\r\\n/// @dev Note:\\r\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\r\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\r\\n///\\r\\n/// While the ownable portion follows\\r\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\r\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\r\\nabstract contract Ownable {\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                       CUSTOM ERRORS                        */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The caller is not authorized to call the function.\\r\\n    error Unauthorized();\\r\\n\\r\\n    /// @dev The `newOwner` cannot be the zero address.\\r\\n    error NewOwnerIsZeroAddress();\\r\\n\\r\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\r\\n    error NoHandoverRequest();\\r\\n\\r\\n    /// @dev Cannot double-initialize.\\r\\n    error AlreadyInitialized();\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                           EVENTS                           */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\r\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\r\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\r\\n    /// despite it not being as lightweight as a single argument event.\\r\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\r\\n\\r\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\r\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\r\\n\\r\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\r\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\r\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\r\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\r\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\r\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\r\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\r\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                          STORAGE                           */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The owner slot is given by:\\r\\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))))`.\\r\\n    /// It is intentionally chosen to be a high value\\r\\n    /// to avoid collision with lower slots.\\r\\n    /// The choice of manual storage layout is to enable compatibility\\r\\n    /// with both regular and upgradeable contracts.\\r\\n    bytes32 internal constant _OWNER_SLOT =\\r\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\\r\\n\\r\\n    /// The ownership handover slot of `newOwner` is given by:\\r\\n    /// ```\\r\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\r\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\r\\n    /// ```\\r\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\r\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                     INTERNAL FUNCTIONS                     */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\\r\\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\\r\\n\\r\\n    /// @dev Initializes the owner directly without authorization guard.\\r\\n    /// This function must be called upon initialization,\\r\\n    /// regardless of whether the contract is upgradeable or not.\\r\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\r\\n    /// and to save gas in case the initial owner is not the caller.\\r\\n    /// For performance reasons, this function will not check if there\\r\\n    /// is an existing owner.\\r\\n    function _initializeOwner(address newOwner) internal virtual {\\r\\n        if (_guardInitializeOwner()) {\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let ownerSlot := _OWNER_SLOT\\r\\n                if sload(ownerSlot) {\\r\\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\\r\\n                    revert(0x1c, 0x04)\\r\\n                }\\r\\n                // Clean the upper 96 bits.\\r\\n                newOwner := shr(96, shl(96, newOwner))\\r\\n                // Store the new value.\\r\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\r\\n                // Emit the {OwnershipTransferred} event.\\r\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\r\\n            }\\r\\n        } else {\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                // Clean the upper 96 bits.\\r\\n                newOwner := shr(96, shl(96, newOwner))\\r\\n                // Store the new value.\\r\\n                sstore(_OWNER_SLOT, newOwner)\\r\\n                // Emit the {OwnershipTransferred} event.\\r\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets the owner directly without authorization guard.\\r\\n    function _setOwner(address newOwner) internal virtual {\\r\\n        if (_guardInitializeOwner()) {\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let ownerSlot := _OWNER_SLOT\\r\\n                // Clean the upper 96 bits.\\r\\n                newOwner := shr(96, shl(96, newOwner))\\r\\n                // Emit the {OwnershipTransferred} event.\\r\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\r\\n                // Store the new value.\\r\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\r\\n            }\\r\\n        } else {\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let ownerSlot := _OWNER_SLOT\\r\\n                // Clean the upper 96 bits.\\r\\n                newOwner := shr(96, shl(96, newOwner))\\r\\n                // Emit the {OwnershipTransferred} event.\\r\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\r\\n                // Store the new value.\\r\\n                sstore(ownerSlot, newOwner)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Throws if the sender is not the owner.\\r\\n    function _checkOwner() internal view virtual {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // If the caller is not the stored owner, revert.\\r\\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\\r\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\r\\n    /// Override to return a different value if needed.\\r\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\r\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\r\\n        return 48 * 3600;\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\r\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if iszero(shl(96, newOwner)) {\\r\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n        _setOwner(newOwner);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows the owner to renounce their ownership.\\r\\n    function renounceOwnership() public payable virtual onlyOwner {\\r\\n        _setOwner(address(0));\\r\\n    }\\r\\n\\r\\n    /// @dev Request a two-step ownership handover to the caller.\\r\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\r\\n    function requestOwnershipHandover() public payable virtual {\\r\\n        unchecked {\\r\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                // Compute and set the handover slot to `expires`.\\r\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\r\\n                mstore(0x00, caller())\\r\\n                sstore(keccak256(0x0c, 0x20), expires)\\r\\n                // Emit the {OwnershipHandoverRequested} event.\\r\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\r\\n    function cancelOwnershipHandover() public payable virtual {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Compute and set the handover slot to 0.\\r\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\r\\n            mstore(0x00, caller())\\r\\n            sstore(keccak256(0x0c, 0x20), 0)\\r\\n            // Emit the {OwnershipHandoverCanceled} event.\\r\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\r\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\r\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Compute and set the handover slot to 0.\\r\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\r\\n            mstore(0x00, pendingOwner)\\r\\n            let handoverSlot := keccak256(0x0c, 0x20)\\r\\n            // If the handover does not exist, or has expired.\\r\\n            if gt(timestamp(), sload(handoverSlot)) {\\r\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            // Set the handover slot to 0.\\r\\n            sstore(handoverSlot, 0)\\r\\n        }\\r\\n        _setOwner(pendingOwner);\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   PUBLIC READ FUNCTIONS                    */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns the owner of the contract.\\r\\n    function owner() public view virtual returns (address result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := sload(_OWNER_SLOT)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\r\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Compute the handover slot.\\r\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\r\\n            mstore(0x00, pendingOwner)\\r\\n            // Load the handover slot.\\r\\n            result := sload(keccak256(0x0c, 0x20))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                         MODIFIERS                          */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Marks a function as only callable by the owner.\\r\\n    modifier onlyOwner() virtual {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"solady/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Library to encode strings in Base64.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\r\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\r\\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\\r\\nlibrary Base64 {\\r\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\r\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\r\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\r\\n    /// @param noPadding Whether to strip away the padding.\\r\\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let dataLength := mload(data)\\r\\n\\r\\n            if dataLength {\\r\\n                // Multiply by 4/3 rounded up.\\r\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\r\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\r\\n\\r\\n                // Set `result` to point to the start of the free memory.\\r\\n                result := mload(0x40)\\r\\n\\r\\n                // Store the table into the scratch space.\\r\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\r\\n                // We will rewrite the free memory pointer at `0x40` later with\\r\\n                // the allocated size.\\r\\n                // The magic constant 0x0670 will turn \\\"-_\\\" into \\\"+/\\\".\\r\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\r\\n                mstore(0x3f, xor(\\\"ghijklmnopqrstuvwxyz0123456789-_\\\", mul(iszero(fileSafe), 0x0670)))\\r\\n\\r\\n                // Skip the first slot, which stores the length.\\r\\n                let ptr := add(result, 0x20)\\r\\n                let end := add(ptr, encodedLength)\\r\\n\\r\\n                // Run over the input, 3 bytes at a time.\\r\\n                for {} 1 {} {\\r\\n                    data := add(data, 3) // Advance 3 bytes.\\r\\n                    let input := mload(data)\\r\\n\\r\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\r\\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\\r\\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\\r\\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\\r\\n                    mstore8(3, mload(and(input, 0x3F)))\\r\\n                    mstore(ptr, mload(0x00))\\r\\n\\r\\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\r\\n                    if iszero(lt(ptr, end)) { break }\\r\\n                }\\r\\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\\r\\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\\r\\n                let o := div(2, mod(dataLength, 3))\\r\\n                // Offset `ptr` and pad with '='. We can simply write over the end.\\r\\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\\r\\n                // Set `o` to zero if there is padding.\\r\\n                o := mul(iszero(iszero(noPadding)), o)\\r\\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\\r\\n                mstore(result, sub(encodedLength, o)) // Store the length.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\r\\n    /// Equivalent to `encode(data, false, false)`.\\r\\n    function encode(bytes memory data) internal pure returns (string memory result) {\\r\\n        result = encode(data, false, false);\\r\\n    }\\r\\n\\r\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\r\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\r\\n    function encode(bytes memory data, bool fileSafe)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        result = encode(data, fileSafe, false);\\r\\n    }\\r\\n\\r\\n    /// @dev Decodes base64 encoded `data`.\\r\\n    ///\\r\\n    /// Supports:\\r\\n    /// - RFC 4648 (both standard and file-safe mode).\\r\\n    /// - RFC 3501 (63: ',').\\r\\n    ///\\r\\n    /// Does not support:\\r\\n    /// - Line breaks.\\r\\n    ///\\r\\n    /// Note: For performance reasons,\\r\\n    /// this function will NOT revert on invalid `data` inputs.\\r\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\r\\n    /// It is the user's responsibility to ensure that the `data`\\r\\n    /// is a valid base64 encoded string.\\r\\n    function decode(string memory data) internal pure returns (bytes memory result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let dataLength := mload(data)\\r\\n\\r\\n            if dataLength {\\r\\n                let decodedLength := mul(shr(2, dataLength), 3)\\r\\n\\r\\n                for {} 1 {} {\\r\\n                    // If padded.\\r\\n                    if iszero(and(dataLength, 3)) {\\r\\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\\r\\n                        // forgefmt: disable-next-item\\r\\n                        decodedLength := sub(\\r\\n                            decodedLength,\\r\\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\\r\\n                        )\\r\\n                        break\\r\\n                    }\\r\\n                    // If non-padded.\\r\\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\\r\\n                    break\\r\\n                }\\r\\n                result := mload(0x40)\\r\\n\\r\\n                // Write the length of the bytes.\\r\\n                mstore(result, decodedLength)\\r\\n\\r\\n                // Skip the first slot, which stores the length.\\r\\n                let ptr := add(result, 0x20)\\r\\n                let end := add(ptr, decodedLength)\\r\\n\\r\\n                // Load the table into the scratch space.\\r\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\r\\n                // `m` also doubles as the mask of the upper 6 bits.\\r\\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\r\\n                mstore(0x5b, m)\\r\\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\\r\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\r\\n\\r\\n                for {} 1 {} {\\r\\n                    // Read 4 bytes.\\r\\n                    data := add(data, 4)\\r\\n                    let input := mload(data)\\r\\n\\r\\n                    // Write 3 bytes.\\r\\n                    // forgefmt: disable-next-item\\r\\n                    mstore(ptr, or(\\r\\n                        and(m, mload(byte(28, input))),\\r\\n                        shr(6, or(\\r\\n                            and(m, mload(byte(29, input))),\\r\\n                            shr(6, or(\\r\\n                                and(m, mload(byte(30, input))),\\r\\n                                shr(6, mload(byte(31, input)))\\r\\n                            ))\\r\\n                        ))\\r\\n                    ))\\r\\n                    ptr := add(ptr, 3)\\r\\n                    if iszero(lt(ptr, end)) { break }\\r\\n                }\\r\\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\\r\\n                mstore(end, 0) // Zeroize the slot after the bytes.\\r\\n                mstore(0x60, 0) // Restore the zero slot.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"solady/utils/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Gas optimized ECDSA wrapper.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\\r\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\\r\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\r\\n///\\r\\n/// @dev Note:\\r\\n/// - The recovery functions use the ecrecover precompile (0x1).\\r\\n/// - As of Solady version 0.0.68, the `recover` variants will revert upon recovery failure.\\r\\n///   This is for more safety by default.\\r\\n///   Use the `tryRecover` variants if you need to get the zero address back\\r\\n///   upon recovery failure instead.\\r\\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\\r\\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\\r\\n///   See: https://eips.ethereum.org/EIPS/eip-2098\\r\\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\\r\\n///\\r\\n/// WARNING! Do NOT use signatures as unique identifiers:\\r\\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\\r\\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\\r\\n///   EIP-712 also enables readable signing of typed data for better user safety.\\r\\n/// This implementation does NOT check if a signature is non-malleable.\\r\\nlibrary ECDSA {\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                        CUSTOM ERRORS                       */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The signature is invalid.\\r\\n    error InvalidSignature();\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                    RECOVERY OPERATIONS                     */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\r\\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := 1\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            for {} 1 {} {\\r\\n                mstore(0x00, hash)\\r\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\r\\n                if eq(mload(signature), 64) {\\r\\n                    let vs := mload(add(signature, 0x40))\\r\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\r\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\r\\n                    break\\r\\n                }\\r\\n                if eq(mload(signature), 65) {\\r\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\r\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\r\\n                    break\\r\\n                }\\r\\n                result := 0\\r\\n                break\\r\\n            }\\r\\n            result :=\\r\\n                mload(\\r\\n                    staticcall(\\r\\n                        gas(), // Amount of gas left for the transaction.\\r\\n                        result, // Address of `ecrecover`.\\r\\n                        0x00, // Start of input.\\r\\n                        0x80, // Size of input.\\r\\n                        0x01, // Start of output.\\r\\n                        0x20 // Size of output.\\r\\n                    )\\r\\n                )\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            if iszero(returndatasize()) {\\r\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\r\\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\\r\\n        internal\\r\\n        view\\r\\n        returns (address result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := 1\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            for {} 1 {} {\\r\\n                if eq(signature.length, 64) {\\r\\n                    let vs := calldataload(add(signature.offset, 0x20))\\r\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\r\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\r\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\r\\n                    break\\r\\n                }\\r\\n                if eq(signature.length, 65) {\\r\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\r\\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\r\\n                    break\\r\\n                }\\r\\n                result := 0\\r\\n                break\\r\\n            }\\r\\n            result :=\\r\\n                mload(\\r\\n                    staticcall(\\r\\n                        gas(), // Amount of gas left for the transaction.\\r\\n                        result, // Address of `ecrecover`.\\r\\n                        0x00, // Start of input.\\r\\n                        0x80, // Size of input.\\r\\n                        0x01, // Start of output.\\r\\n                        0x20 // Size of output.\\r\\n                    )\\r\\n                )\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            if iszero(returndatasize()) {\\r\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\r\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\r\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\r\\n            mstore(0x40, r)\\r\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\r\\n            result :=\\r\\n                mload(\\r\\n                    staticcall(\\r\\n                        gas(), // Amount of gas left for the transaction.\\r\\n                        1, // Address of `ecrecover`.\\r\\n                        0x00, // Start of input.\\r\\n                        0x80, // Size of input.\\r\\n                        0x01, // Start of output.\\r\\n                        0x20 // Size of output.\\r\\n                    )\\r\\n                )\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            if iszero(returndatasize()) {\\r\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\r\\n    /// and the signature defined by `v`, `r`, `s`.\\r\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\r\\n        internal\\r\\n        view\\r\\n        returns (address result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            mstore(0x20, and(v, 0xff))\\r\\n            mstore(0x40, r)\\r\\n            mstore(0x60, s)\\r\\n            result :=\\r\\n                mload(\\r\\n                    staticcall(\\r\\n                        gas(), // Amount of gas left for the transaction.\\r\\n                        1, // Address of `ecrecover`.\\r\\n                        0x00, // Start of input.\\r\\n                        0x80, // Size of input.\\r\\n                        0x01, // Start of output.\\r\\n                        0x20 // Size of output.\\r\\n                    )\\r\\n                )\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            if iszero(returndatasize()) {\\r\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   TRY-RECOVER OPERATIONS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    // WARNING!\\r\\n    // These functions will NOT revert upon recovery failure.\\r\\n    // Instead, they will return the zero address upon recovery failure.\\r\\n    // It is critical that the returned address is NEVER compared against\\r\\n    // a zero address (e.g. an uninitialized address variable).\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\r\\n    function tryRecover(bytes32 hash, bytes memory signature)\\r\\n        internal\\r\\n        view\\r\\n        returns (address result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := 1\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            for {} 1 {} {\\r\\n                mstore(0x00, hash)\\r\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\r\\n                if eq(mload(signature), 64) {\\r\\n                    let vs := mload(add(signature, 0x40))\\r\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\r\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\r\\n                    break\\r\\n                }\\r\\n                if eq(mload(signature), 65) {\\r\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\r\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\r\\n                    break\\r\\n                }\\r\\n                result := 0\\r\\n                break\\r\\n            }\\r\\n            pop(\\r\\n                staticcall(\\r\\n                    gas(), // Amount of gas left for the transaction.\\r\\n                    result, // Address of `ecrecover`.\\r\\n                    0x00, // Start of input.\\r\\n                    0x80, // Size of input.\\r\\n                    0x40, // Start of output.\\r\\n                    0x20 // Size of output.\\r\\n                )\\r\\n            )\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            result := mload(xor(0x60, returndatasize()))\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\r\\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\\r\\n        internal\\r\\n        view\\r\\n        returns (address result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := 1\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            for {} 1 {} {\\r\\n                if eq(signature.length, 64) {\\r\\n                    let vs := calldataload(add(signature.offset, 0x20))\\r\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\r\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\r\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\r\\n                    break\\r\\n                }\\r\\n                if eq(signature.length, 65) {\\r\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\r\\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\r\\n                    break\\r\\n                }\\r\\n                result := 0\\r\\n                break\\r\\n            }\\r\\n            pop(\\r\\n                staticcall(\\r\\n                    gas(), // Amount of gas left for the transaction.\\r\\n                    result, // Address of `ecrecover`.\\r\\n                    0x00, // Start of input.\\r\\n                    0x80, // Size of input.\\r\\n                    0x40, // Start of output.\\r\\n                    0x20 // Size of output.\\r\\n                )\\r\\n            )\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            result := mload(xor(0x60, returndatasize()))\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\r\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\r\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\\r\\n        internal\\r\\n        view\\r\\n        returns (address result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\r\\n            mstore(0x40, r)\\r\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\r\\n            pop(\\r\\n                staticcall(\\r\\n                    gas(), // Amount of gas left for the transaction.\\r\\n                    1, // Address of `ecrecover`.\\r\\n                    0x00, // Start of input.\\r\\n                    0x80, // Size of input.\\r\\n                    0x40, // Start of output.\\r\\n                    0x20 // Size of output.\\r\\n                )\\r\\n            )\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            result := mload(xor(0x60, returndatasize()))\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\r\\n    /// and the signature defined by `v`, `r`, `s`.\\r\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\r\\n        internal\\r\\n        view\\r\\n        returns (address result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x00, hash)\\r\\n            mstore(0x20, and(v, 0xff))\\r\\n            mstore(0x40, r)\\r\\n            mstore(0x60, s)\\r\\n            pop(\\r\\n                staticcall(\\r\\n                    gas(), // Amount of gas left for the transaction.\\r\\n                    1, // Address of `ecrecover`.\\r\\n                    0x00, // Start of input.\\r\\n                    0x80, // Size of input.\\r\\n                    0x40, // Start of output.\\r\\n                    0x20 // Size of output.\\r\\n                )\\r\\n            )\\r\\n            mstore(0x60, 0) // Restore the zero slot.\\r\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\r\\n            result := mload(xor(0x60, returndatasize()))\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                     HASHING OPERATIONS                     */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\r\\n    /// This produces a hash corresponding to the one signed with the\\r\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\r\\n    /// JSON-RPC method as part of EIP-191.\\r\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\r\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\r\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\r\\n    /// This produces a hash corresponding to the one signed with the\\r\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\r\\n    /// JSON-RPC method as part of EIP-191.\\r\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\r\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let sLength := mload(s)\\r\\n            let o := 0x20\\r\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\r\\n            mstore(0x00, 0x00)\\r\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\r\\n            for { let temp := sLength } 1 {} {\\r\\n                o := sub(o, 1)\\r\\n                mstore8(o, add(48, mod(temp, 10)))\\r\\n                temp := div(temp, 10)\\r\\n                if iszero(temp) { break }\\r\\n            }\\r\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\r\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\r\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\r\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\r\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\r\\n            mstore(s, sLength) // Restore the length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   EMPTY CALLDATA HELPERS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns an empty calldata bytes.\\r\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            signature.length := 0\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"solady/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Reentrancy guard mixin.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ReentrancyGuard.sol)\\r\\nabstract contract ReentrancyGuard {\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                       CUSTOM ERRORS                        */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Unauthorized reentrant call.\\r\\n    error Reentrancy();\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                          STORAGE                           */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Equivalent to: `uint72(bytes9(keccak256(\\\"_REENTRANCY_GUARD_SLOT\\\")))`.\\r\\n    /// 9 bytes is large enough to avoid collisions with lower slots,\\r\\n    /// but not too large to result in excessive bytecode bloat.\\r\\n    uint256 private constant _REENTRANCY_GUARD_SLOT = 0x929eee149b4bd21268;\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                      REENTRANCY GUARD                      */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Guards a function from reentrancy.\\r\\n    modifier nonReentrant() virtual {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {\\r\\n                mstore(0x00, 0xab143c06) // `Reentrancy()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            sstore(_REENTRANCY_GUARD_SLOT, address())\\r\\n        }\\r\\n        _;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            sstore(_REENTRANCY_GUARD_SLOT, codesize())\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Guards a view function from read-only reentrancy.\\r\\n    modifier nonReadReentrant() virtual {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {\\r\\n                mstore(0x00, 0xab143c06) // `Reentrancy()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"DN404Mirror.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n/// @dev Dnner Note:\\r\\n/// - Dnner(DN404ND) does not possess the fragmentability, nor does \\r\\n///   it have the feature of NFT transactions without the \\r\\n///   need for a third party, characteristic of ERC404/DN404. \\r\\n///   \\r\\n///   DN404 can easily create efficient hybrid tokens and \\r\\n///   define the ratio between NFT and tokens. \\r\\n///   We aim to leverage the foundation of DN404 to enable\\r\\n///   NFT to drive the increase in token value.\\r\\n///  \\r\\n///   Another way of putting it is to avoid turning NFTs \\r\\n///   into purely tokenized assets. \\r\\n///  \\r\\n///   This is an experimental project not conforming to \\r\\n///   the 404 standard, DYOR and read more from our website.\\r\\n///\\r\\n///   Twitter: https://twitter.com/DN404ND\\r\\n///   Website: https://dnner.shop\\r\\n\\r\\n/// @title DN404Mirror\\r\\n/// @notice DN404Mirror provides an interface for interacting with the\\r\\n/// NFT tokens in a DN404 implementation.\\r\\n///\\r\\n/// @author vectorized.eth (@optimizoor)\\r\\n/// @author Quit (@0xQuit)\\r\\n/// @author Michael Amadi (@AmadiMichaels)\\r\\n/// @author cygaar (@0xCygaar)\\r\\n/// @author Thomas (@0xjustadev)\\r\\n/// @author Harrison (@PopPunkOnChain)\\r\\n///\\r\\n/// @dev Note:\\r\\n/// - The ERC721 data is stored in the base DN404 contract.\\r\\ncontract DN404Mirror {\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                           EVENTS                           */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\r\\n\\r\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\r\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\r\\n\\r\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\r\\n\\r\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\r\\n    /// This is for marketplace signaling purposes. This contract has a `pullOwner()`\\r\\n    /// function that will sync the owner from the base contract.\\r\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\r\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\r\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\r\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\r\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\r\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\r\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                        CUSTOM ERRORS                       */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Thrown when a call for an NFT function did not originate\\r\\n    /// from the base DN404 contract.\\r\\n    error SenderNotBase();\\r\\n\\r\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\r\\n    error SenderNotDeployer();\\r\\n\\r\\n    /// @dev Thrown when transferring an NFT to a contract address that\\r\\n    /// does not implement ERC721Receiver.\\r\\n    error TransferToNonERC721ReceiverImplementer();\\r\\n\\r\\n    /// @dev Thrown when linking to the DN404 base contract and the\\r\\n    /// DN404 supportsInterface check fails or the call reverts.\\r\\n    error CannotLink();\\r\\n\\r\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\r\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\r\\n    error AlreadyLinked();\\r\\n\\r\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\r\\n    /// been established.\\r\\n    error NotLinked();\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                          STORAGE                           */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Struct contain the NFT mirror contract storage.\\r\\n    struct DN404NFTStorage {\\r\\n        address baseERC20;\\r\\n        address deployer;\\r\\n        address owner;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\r\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\r\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                        CONSTRUCTOR                         */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    constructor(address deployer) {\\r\\n        // For non-proxies, we will store the deployer so that only the deployer can\\r\\n        // link the base contract.\\r\\n        _getDN404NFTStorage().deployer = deployer;\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                     ERC721 OPERATIONS                      */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the token collection name from the base DN404 contract.\\r\\n    function name() public view virtual returns (string memory result) {\\r\\n        return _readString(0x06fdde03, 0); // `name()`.\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\r\\n    function symbol() public view virtual returns (string memory result) {\\r\\n        return _readString(0x95d89b41, 0); // `symbol()`.\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\r\\n    /// the base DN404 contract.\\r\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\r\\n        return _readString(0xc87b56dd, id); // `tokenURI()`.\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\r\\n    function totalSupply() public view virtual returns (uint256 result) {\\r\\n        return _readWord(0xe2c79281, 0, 0); // `totalNFTSupply()`.\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the number of NFT tokens owned by `nftOwner` from the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - `nftOwner` must not be the zero address.\\r\\n    function balanceOf(address nftOwner) public view virtual returns (uint256 result) {\\r\\n        return _readWord(0xf5b100ea, uint160(nftOwner), 0); // `balanceOfNFT(address)`.\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\r\\n        return address(uint160(_readWord(0x6352211e, id, 0))); // `ownerOf(uint256)`.\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\r\\n    /// Returns `address(0)` instead of reverting if the token does not exist.\\r\\n    function ownerAt(uint256 id) public view virtual returns (address result) {\\r\\n        return address(uint160(_readWord(0x24359879, id, 0))); // `ownerAt(uint256)`.\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\r\\n    /// the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    /// - The caller must be the owner of the token,\\r\\n    ///   or an approved operator for the token owner.\\r\\n    ///\\r\\n    /// Emits an {Approval} event.\\r\\n    function approve(address spender, uint256 id) public virtual {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            spender := shr(96, shl(96, spender))\\r\\n            let m := mload(0x40)\\r\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\r\\n            mstore(0x20, spender)\\r\\n            mstore(0x40, id)\\r\\n            mstore(0x60, caller())\\r\\n            if iszero(\\r\\n                and(\\r\\n                    gt(returndatasize(), 0x1f),\\r\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n            mstore(0x60, 0) // Restore the zero pointer.\\r\\n            // Emit the {Approval} event.\\r\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the account approved to manage token `id` from\\r\\n    /// the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    function getApproved(uint256 id) public view virtual returns (address) {\\r\\n        return address(uint160(_readWord(0x081812fc, id, 0))); // `getApproved(uint256)`.\\r\\n    }\\r\\n\\r\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\r\\n    /// the base DN404 contract.\\r\\n    ///\\r\\n    /// Emits an {ApprovalForAll} event.\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            operator := shr(96, shl(96, operator))\\r\\n            let m := mload(0x40)\\r\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\r\\n            mstore(0x20, operator)\\r\\n            mstore(0x40, iszero(iszero(approved)))\\r\\n            mstore(0x60, caller())\\r\\n            if iszero(\\r\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            // Emit the {ApprovalForAll} event.\\r\\n            // The `approved` value is already at 0x40.\\r\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n            mstore(0x60, 0) // Restore the zero pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `nftOwner` from\\r\\n    /// the base DN404 contract.\\r\\n    function isApprovedForAll(address nftOwner, address operator)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (bool result)\\r\\n    {\\r\\n        // `isApprovedForAll(address,address)`.\\r\\n        return _readWord(0xe985e9c5, uint160(nftOwner), uint160(operator)) != 0;\\r\\n    }\\r\\n\\r\\n    /// @dev Transfers token `id` from `from` to `to`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    ///\\r\\n    /// - Token `id` must exist.\\r\\n    /// - `from` must be the owner of the token.\\r\\n    /// - `to` cannot be the zero address.\\r\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            from := shr(96, shl(96, from))\\r\\n            to := shr(96, shl(96, to))\\r\\n            let m := mload(0x40)\\r\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\r\\n            mstore(add(m, 0x20), from)\\r\\n            mstore(add(m, 0x40), to)\\r\\n            mstore(add(m, 0x60), id)\\r\\n            mstore(add(m, 0x80), caller())\\r\\n            if iszero(\\r\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            // Emit the {Transfer} event.\\r\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\r\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev Transfers token `id` from `from` to `to`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    ///\\r\\n    /// - Token `id` must exist.\\r\\n    /// - `from` must be the owner of the token.\\r\\n    /// - `to` cannot be the zero address.\\r\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\r\\n    /// - If `to` refers to a smart contract, it must implement\\r\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\r\\n        public\\r\\n        virtual\\r\\n    {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\r\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\r\\n    /// This function call must use less than 30000 gas.\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let s := shr(224, interfaceId)\\r\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\r\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                  OWNER SYNCING OPERATIONS                  */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the `owner` of the contract, for marketplace signaling purposes.\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _getDN404NFTStorage().owner;\\r\\n    }\\r\\n\\r\\n    /// @dev Permissionless function to pull the owner from the base DN404 contract\\r\\n    /// if it implements ownable, for marketplace signaling purposes.\\r\\n    function pullOwner() public virtual {\\r\\n        address newOwner;\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, 0x8da5cb5b) // `owner()`.\\r\\n            if and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20)) {\\r\\n                newOwner := shr(96, mload(0x0c))\\r\\n            }\\r\\n        }\\r\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\r\\n        address oldOwner = $.owner;\\r\\n        if (oldOwner != newOwner) {\\r\\n            $.owner = newOwner;\\r\\n            emit OwnershipTransferred(oldOwner, newOwner);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                     MIRROR OPERATIONS                      */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the address of the base DN404 contract.\\r\\n    function baseERC20() public view virtual returns (address base) {\\r\\n        base = _getDN404NFTStorage().baseERC20;\\r\\n        if (base == address(0)) revert NotLinked();\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\r\\n    modifier dn404NFTFallback() virtual {\\r\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\r\\n\\r\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\r\\n\\r\\n        // `logTransfer(uint256[])`.\\r\\n        if (fnSelector == 0x263c69d6) {\\r\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\r\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\r\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\r\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\r\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\r\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\r\\n\\r\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\r\\n                    let d := calldataload(o) // Entry in the packed logs.\\r\\n                    let a := shr(96, d) // The address.\\r\\n                    let b := and(1, d) // Whether it is a burn.\\r\\n                    log4(\\r\\n                        codesize(),\\r\\n                        0x00,\\r\\n                        _TRANSFER_EVENT_SIGNATURE,\\r\\n                        mul(a, b), // `from`.\\r\\n                        mul(a, iszero(b)), // `to`.\\r\\n                        shr(168, shl(160, d)) // `id`.\\r\\n                    )\\r\\n                }\\r\\n                mstore(0x00, 0x01)\\r\\n                return(0x00, 0x20)\\r\\n            }\\r\\n        }\\r\\n        // `linkMirrorContract(address)`.\\r\\n        if (fnSelector == 0x0f4599e5) {\\r\\n            if ($.deployer != address(0)) {\\r\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\r\\n                    revert SenderNotDeployer();\\r\\n                }\\r\\n            }\\r\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\r\\n            $.baseERC20 = msg.sender;\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                mstore(0x00, 0x01)\\r\\n                return(0x00, 0x20)\\r\\n            }\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback function for calls from base DN404 contract.\\r\\n    fallback() external payable virtual dn404NFTFallback {}\\r\\n\\r\\n    receive() external payable virtual {}\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                      PRIVATE HELPERS                       */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Helper to read a string from the base DN404 contract.\\r\\n    function _readString(uint256 fnSelector, uint256 arg0)\\r\\n        private\\r\\n        view\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := mload(0x40)\\r\\n            mstore(0x00, fnSelector)\\r\\n            mstore(0x20, arg0)\\r\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\r\\n                returndatacopy(result, 0x00, returndatasize())\\r\\n                revert(result, returndatasize())\\r\\n            }\\r\\n            returndatacopy(0x00, 0x00, 0x20) // Copy the offset of the string in returndata.\\r\\n            returndatacopy(result, mload(0x00), 0x20) // Copy the length of the string.\\r\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result)) // Copy the string.\\r\\n            mstore(0x40, add(add(result, 0x20), mload(result))) // Allocate memory.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Helper to read a word from the base DN404 contract.\\r\\n    function _readWord(uint256 fnSelector, uint256 arg0, uint256 arg1)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40)\\r\\n            mstore(0x00, fnSelector)\\r\\n            mstore(0x20, arg0)\\r\\n            mstore(0x40, arg1)\\r\\n            if iszero(\\r\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n            result := mload(0x00)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the calldata value at `offset`.\\r\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            value := calldataload(offset)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\r\\n    function _hasCode(address a) private view returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := extcodesize(a) // Can handle dirty upper bits.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\r\\n    /// Reverts if the target does not support the function correctly.\\r\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\r\\n        private\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Prepare the calldata.\\r\\n            let m := mload(0x40)\\r\\n            let onERC721ReceivedSelector := 0x150b7a02\\r\\n            mstore(m, onERC721ReceivedSelector)\\r\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\r\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\r\\n            mstore(add(m, 0x60), id)\\r\\n            mstore(add(m, 0x80), 0x80)\\r\\n            let n := mload(data)\\r\\n            mstore(add(m, 0xa0), n)\\r\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\r\\n            // Revert if the call reverts.\\r\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\r\\n                if returndatasize() {\\r\\n                    // Bubble up the revert if the call reverts.\\r\\n                    returndatacopy(m, 0x00, returndatasize())\\r\\n                    revert(m, returndatasize())\\r\\n                }\\r\\n            }\\r\\n            // Load the returndata and compare it.\\r\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\r\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"DN404ND.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @dev Dnner Note:\\n/// - Dnner(DN404ND) does not possess the fragmentability, nor does\\n///   it have the feature of NFT transactions without the\\n///   need for a third party, characteristic of ERC404/DN404.\\n///\\n///   DN404 can easily create efficient hybrid tokens and\\n///   define the ratio between NFT and tokens.\\n///   We aim to leverage the foundation of DN404 to enable\\n///   NFT to drive the increase in token value.\\n///\\n///   Another way of putting it is to avoid turning NFTs\\n///   into purely tokenized assets.\\n///\\n///   This is an experimental project not conforming to\\n///   the 404 standard, DYOR and read more from our website.\\n///\\n///   Twitter: https://twitter.com/DN404ND\\n///   Website: https://dnner.shop\\n\\n/// @title DN404\\n/// @notice DN404 is a hybrid ERC20 and ERC721 implementation that mints\\n/// and burns NFTs based on an account's ERC20 token balance.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in this base DN404 contract, however a\\n///   DN404Mirror contract ***MUST*** be deployed and linked during\\n///   initialization.\\n///\\n\\nabstract contract DN404ND {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n\\n    /// @dev Emitted when `target` sets their skipNFT flag to `status`.\\n    event SkipNFTSet(address indexed target, bool status);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"SkipNFTSet(address,bool)\\\"))`.\\n    uint256 private constant _SKIP_NFT_SET_EVENT_SIGNATURE =\\n        0xb5a1de456fff688115a4f75380060c23c8532d14ff85f687cc871456d6420393;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when attempting to double-initialize the contract.\\n    error DNAlreadyInitialized();\\n\\n    /// @dev Thrown when attempting to transfer or burn more tokens than sender's balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Thrown when a spender attempts to transfer tokens with an insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev Thrown when minting an amount of tokens that would overflow the max tokens.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev The unit cannot be zero.\\n    error UnitIsZero();\\n\\n    /// @dev Thrown when the caller for a fallback NFT function is not the mirror contract.\\n    error SenderNotMirror();\\n\\n    /// @dev Thrown when attempting to transfer tokens to the zero address.\\n    error TransferToZeroAddress();\\n\\n    /// @dev Thrown when the mirror address provided for initialization is the zero address.\\n    error MirrorAddressIsZero();\\n\\n    /// @dev Thrown when the link call to the mirror contract reverts.\\n    error LinkMirrorContractFailed();\\n\\n    /// @dev Thrown when setting an NFT token approval\\n    /// and the caller is not the owner or an approved operator.\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT\\n    /// and the caller is not the owner or an approved operator.\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT and the from address is not the current owner.\\n    error TransferFromIncorrectOwner();\\n\\n    /// @dev Thrown when checking the owner or approved address for a non-existent NFT.\\n    error TokenDoesNotExist();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         CONSTANTS                          */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev The flag to denote that the address data is initialized.\\n    uint8 internal constant _ADDRESS_DATA_INITIALIZED_FLAG = 1 << 0;\\n\\n    /// @dev The flag to denote that the address should skip NFTs.\\n    uint8 internal constant _ADDRESS_DATA_SKIP_NFT_FLAG = 1 << 1;\\n\\n    /// @dev The flag to denote that the address has overridden the default Permit2 allowance.\\n    uint8 internal constant _ADDRESS_DATA_OVERRIDE_PERMIT2_FLAG = 1 << 2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// For signature-based allowance granting for single transaction ERC20 `transferFrom`.\\n    /// To enable, override `_givePermit2DefaultInfiniteAllowance()`.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant _PERMIT2 =\\n        0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing an address's token data and settings.\\n    struct AddressData {\\n        // Flags for `initialized` and `skipNFT`.\\n        uint8 flags;\\n        // The alias for the address. Zero means absence of an alias.\\n        uint32 addressAlias;\\n        // The number of NFT tokens.\\n        uint32 ownedLength;\\n        // The token balance in wei.\\n        uint96 balance;\\n        //\\n        // Lock the token balance from received(NFT) or mint(NFT) to prevent\\n        // from being mistakenly transferred, which could lead to\\n        // NFT transaction errors. You can use unlock to release them,\\n        // which will also destroy a corresponding amount of NFTs.\\n        //\\n        // These tokens will be deducted when the NFT is transferred\\n        // and increased when the NFT is received.\\n        uint96 lockedBalance;\\n    }\\n\\n    /// @dev A uint32 map in storage.\\n    struct Uint32Map {\\n        uint256 spacer;\\n    }\\n\\n    /// @dev A uint32 map in storage.\\n    struct Uint256Map {\\n        uint256 spacer;\\n    }\\n\\n    /// @dev A bitmap in storage.\\n    struct Bitmap {\\n        uint256 spacer;\\n    }\\n\\n    /// @dev A struct to wrap a uint256 in storage.\\n    struct Uint256Ref {\\n        uint256 value;\\n    }\\n\\n    /// @dev A mapping of an address pair to a Uint256Ref.\\n    struct AddressPairToUint256RefMap {\\n        uint256 spacer;\\n    }\\n\\n    /// @dev Struct containing the base token contract storage.\\n    struct DN404Storage {\\n        // Current number of address aliases assigned.\\n        uint32 numAliases;\\n        // Next NFT ID to assign for a mint.\\n        uint32 nextTokenId;\\n        // Total number of NFT IDs in the burned pool.\\n        uint32 burnedPoolSize;\\n        // Total supply of minted NFTs.\\n        uint32 totalNFTSupply;\\n        // Max NFT supply.\\n        uint256 maxNFTSupply;\\n        // Total supply of tokens.\\n        uint96 totalSupply;\\n        // Address of the NFT mirror contract.\\n        address mirrorERC721;\\n        // Mapping of a user alias number to their address.\\n        mapping(uint32 => address) aliasToAddress;\\n        // Mapping of user operator approvals for NFTs.\\n        AddressPairToUint256RefMap operatorApprovals;\\n        // Mapping of NFT approvals to approved operators.\\n        mapping(uint256 => address) nftApprovals;\\n        // Bitmap of whether an non-zero NFT approval may exist.\\n        Bitmap mayHaveNFTApproval;\\n        // Mapping of user allowances for ERC20 spenders.\\n        AddressPairToUint256RefMap allowance;\\n        // Mapping of NFT IDs owned by an address.\\n        mapping(address => Uint32Map) owned;\\n        // The pool of burned NFT IDs.\\n        Uint32Map burnedPool;\\n        // Even indices: owner aliases. Odd indices: owned indices.\\n        Uint32Map oo;\\n        // Mapping of user account AddressData.\\n        mapping(address => AddressData) addressData;\\n        // Mapping of nftID to check last value(unit).\\n        Uint256Map NFTUnit;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404Storage.\\n    function _getDN404Storage()\\n        internal\\n        pure\\n        virtual\\n        returns (DN404Storage storage $)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_STORAGE\\\")))`.\\n            $.slot := 0xa20d6e21d0e5255308 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         INITIALIZER                        */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Initializes the DN404 contract with an\\n    /// `initialTokenSupply`, `initialTokenOwner` and `mirror` NFT contract address.\\n    function _initializeDN404(\\n        uint256 initialTokenSupply,\\n        address initialSupplyOwner,\\n        address mirror\\n    ) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if ($.nextTokenId != 0) revert DNAlreadyInitialized();\\n\\n        if (mirror == address(0)) revert MirrorAddressIsZero();\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Make the call to link the mirror contract.\\n            mstore(0x00, 0x0f4599e5) // `linkMirrorContract(address)`.\\n            mstore(0x20, caller())\\n            if iszero(\\n                and(\\n                    eq(mload(0x00), 1),\\n                    call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0xd125259c) // `LinkMirrorContractFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        $.nextTokenId = 1;\\n        $.mirrorERC721 = mirror;\\n\\n        if (_unit() == 0) revert UnitIsZero();\\n\\n        if (initialTokenSupply != 0) {\\n            if (initialSupplyOwner == address(0))\\n                revert TransferToZeroAddress();\\n            if (_totalSupplyOverflows(initialTokenSupply))\\n                revert TotalSupplyOverflow();\\n\\n            $.totalSupply = uint96(initialTokenSupply);\\n            AddressData storage initialOwnerAddressData = _addressData(\\n                initialSupplyOwner\\n            );\\n            initialOwnerAddressData.balance = uint96(initialTokenSupply);\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Emit the {Transfer} event.\\n                mstore(0x00, initialTokenSupply)\\n                log3(\\n                    0x00,\\n                    0x20,\\n                    _TRANSFER_EVENT_SIGNATURE,\\n                    0,\\n                    shr(96, shl(96, initialSupplyOwner))\\n                )\\n            }\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*               BASE UNIT FUNCTION TO OVERRIDE               */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Amount of token balance that is equal to one NFT.\\n    function _unit() internal view virtual returns (uint256) {\\n        return 10**18;\\n    }\\n\\n    function _NFTUnit() internal view virtual returns (uint256) {\\n        return 10**18;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*               METADATA FUNCTIONS TO OVERRIDE               */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the decimals places of the token. Always 18.\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256) {\\n        return uint256(_getDN404Storage().totalSupply);\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].balance;\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (_givePermit2DefaultInfiniteAllowance() && spender == _PERMIT2) {\\n            uint8 flags = _getDN404Storage().addressData[owner].flags;\\n            if (flags & _ADDRESS_DATA_OVERRIDE_PERMIT2_FLAG == 0)\\n                return type(uint256).max;\\n        }\\n        return _ref(_getDN404Storage().allowance, owner, spender).value;\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        Uint256Ref storage a = _ref(\\n            _getDN404Storage().allowance,\\n            from,\\n            msg.sender\\n        );\\n\\n        uint256 allowed = _givePermit2DefaultInfiniteAllowance() &&\\n            msg.sender == _PERMIT2 &&\\n            (_getDN404Storage().addressData[from].flags &\\n                _ADDRESS_DATA_OVERRIDE_PERMIT2_FLAG) ==\\n            0\\n            ? type(uint256).max\\n            : a.value;\\n\\n        if (allowed != type(uint256).max) {\\n            if (amount > allowed) revert InsufficientAllowance();\\n            unchecked {\\n                a.value = allowed - amount;\\n            }\\n        }\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          PERMIT2                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Whether Permit2 has infinite allowances by default for all owners.\\n    /// For signature-based allowance granting for single transaction ERC20 `transferFrom`.\\n    /// To enable, override this function to return true.\\n    function _givePermit2DefaultInfiniteAllowance()\\n        internal\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        return false;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        unchecked {\\n            uint256 maxId;\\n            {\\n                uint256 totalSupply_ = uint256($.totalSupply) + amount;\\n                $.totalSupply = uint96(totalSupply_);\\n                maxId = $.totalNFTSupply + amount;\\n            }\\n            uint256 toEnd;\\n            {\\n                uint256 toBalance = uint256(toAddressData.lockedBalance) +\\n                    amount;\\n                toAddressData.lockedBalance = uint96(toBalance);\\n                toEnd = amount / _NFTUnit() + toAddressData.ownedLength;\\n            }\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                Uint32Map storage oo = $.oo;\\n                uint256 toIndex = toAddressData.ownedLength;\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(\\n                    _zeroFloorSub(toEnd, toIndex)\\n                );\\n\\n                if (packedLogs.logs.length != 0) {\\n                    _packedLogsSet(packedLogs, to, 0);\\n                    uint256 burnedPoolSize = $.burnedPoolSize;\\n                    uint256 nextTokenId = $.nextTokenId;\\n                    uint32 toAlias = _registerAndResolveAlias(\\n                        toAddressData,\\n                        to\\n                    );\\n                    $.totalNFTSupply += uint32(packedLogs.logs.length);\\n                    toAddressData.ownedLength = uint32(toEnd);\\n                    // Mint loop.\\n                    do {\\n                        uint256 id;\\n                        if (burnedPoolSize != 0) {\\n                            id = _get($.burnedPool, --burnedPoolSize);\\n                            _set($.NFTUnit, id, _NFTUnit());\\n                        } else {\\n                            id = nextTokenId;\\n                            while (_get(oo, _ownershipIndex(id)) != 0) {\\n                                id = _wrapNFTId(id + 1, maxId);\\n                            }\\n                            nextTokenId = _wrapNFTId(id + 1, maxId);\\n                        }\\n                        _set(toOwned, toIndex, uint32(id));\\n                        _setOwnerAliasAndOwnedIndex(\\n                            oo,\\n                            id,\\n                            toAlias,\\n                            uint32(toIndex++)\\n                        );\\n                        _packedLogsAppend(packedLogs, id);\\n                    } while (toIndex != toEnd);\\n\\n                    $.nextTokenId = uint32(nextTokenId);\\n                    $.burnedPoolSize = uint32(burnedPoolSize);\\n                    _packedLogsSend(packedLogs, $.mirrorERC721);\\n                }\\n            }\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, shl(96, to)))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(\\n        address from,\\n        uint256 amount,\\n        bool burnNFT\\n    ) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n        AddressData storage fromAddressData = _addressData(from);\\n\\n        unchecked {\\n            if (burnNFT) {\\n                Uint32Map storage fromOwned = $.owned[from];\\n                uint256 fromIndex = fromAddressData.ownedLength;\\n                uint256 numNFTBurns = amount / _NFTUnit();\\n\\n                if (numNFTBurns != 0) {\\n                    _PackedLogs memory packedLogs = _packedLogsMalloc(\\n                        numNFTBurns\\n                    );\\n                    _packedLogsSet(packedLogs, from, 1);\\n                    uint256 totalNFTSupply = uint256($.totalNFTSupply) -\\n                        numNFTBurns;\\n                    $.totalNFTSupply = uint32(totalNFTSupply);\\n\\n                    Uint32Map storage oo = $.oo;\\n                    uint256 fromEnd = fromIndex - numNFTBurns;\\n                    fromAddressData.ownedLength = uint32(fromEnd);\\n                    uint256 burnedPoolSize = $.burnedPoolSize;\\n                    uint256 lockedBalanceToRemove = 0;\\n                    // Burn loop.\\n                    do {\\n                        uint256 id = _get(fromOwned, --fromIndex);\\n\\n                        uint256 lastNFTUnit = _get($.NFTUnit, id);\\n                        lockedBalanceToRemove += lastNFTUnit > _NFTUnit()\\n                            ? lastNFTUnit\\n                            : _NFTUnit();\\n\\n                        _setOwnerAliasAndOwnedIndex(oo, id, 0, 0);\\n                        _packedLogsAppend(packedLogs, id);\\n                        _set($.burnedPool, burnedPoolSize++, uint32(id));\\n                    } while (fromIndex != fromEnd);\\n\\n                    fromAddressData.lockedBalance -= uint96(\\n                        lockedBalanceToRemove\\n                    );\\n                    $.burnedPoolSize = uint32(burnedPoolSize);\\n                    _packedLogsSend(packedLogs, $.mirrorERC721);\\n                }\\n            } else {\\n                uint256 fromBalance = fromAddressData.balance;\\n                if (amount > fromBalance) revert InsufficientBalance();\\n\\n                fromAddressData.balance = uint96(fromBalance -= amount);\\n            }\\n\\n            uint256 totalSupply_ = uint256($.totalSupply) - amount;\\n            $.totalSupply = uint96(totalSupply_);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            log3(\\n                0x00,\\n                0x20,\\n                _TRANSFER_EVENT_SIGNATURE,\\n                shr(96, shl(96, from)),\\n                0\\n            )\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        _TransferTemps memory t;\\n        t.fromOwnedLength = fromAddressData.ownedLength;\\n        t.toOwnedLength = toAddressData.ownedLength;\\n        t.totalSupply = $.totalSupply;\\n\\n        if (amount > (t.fromBalance = fromAddressData.balance))\\n            revert InsufficientBalance();\\n\\n        unchecked {\\n            fromAddressData.balance = uint96(t.fromBalance -= amount);\\n            toAddressData.balance = uint96(\\n                t.toBalance = uint256(toAddressData.balance) + amount\\n            );\\n\\n            // @dev Dnner note:\\n            // - The minting and burning methods have been removed here;\\n            //   users transfer the corresponding tokens simultaneously when transferring NFTs.\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            // forgefmt: disable-next-item\\n            log3(\\n                0x00,\\n                0x20,\\n                _TRANSFER_EVENT_SIGNATURE,\\n                shr(96, shl(96, from)),\\n                shr(96, shl(96, to))\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns if burns should be added to the burn pool.\\n    function _addToBurnedPool(\\n        uint256 totalNFTSupplyAfterBurn,\\n        uint256 totalSupplyAfterBurn\\n    ) internal view virtual returns (bool) {\\n        // Add to burned pool if the load factor > 50%, and collection is not small.\\n        uint256 thres = (totalSupplyAfterBurn / _unit()) >> 1;\\n        return\\n            _toUint(totalNFTSupplyAfterBurn > thres) & _toUint(thres > 128) !=\\n            0;\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Call must originate from the mirror contract.\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    ///   `msgSender` must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transferFromNFT(\\n        address from,\\n        address to,\\n        uint256 id,\\n        address msgSender\\n    ) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        Uint32Map storage oo = $.oo;\\n\\n        if (from != $.aliasToAddress[_get(oo, _ownershipIndex(id))]) {\\n            revert TransferFromIncorrectOwner();\\n        }\\n\\n        if (msgSender != from) {\\n            if (_ref($.operatorApprovals, from, msgSender).value == 0) {\\n                if (msgSender != $.nftApprovals[id]) {\\n                    revert TransferCallerNotOwnerNorApproved();\\n                }\\n            }\\n        }\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        uint256 unit = _unit();\\n\\n        unchecked {\\n            {\\n                uint256 fromBalance = fromAddressData.lockedBalance;\\n\\n                // Get last transfer unit.\\n                uint256 lastNFTUnit = _get($.NFTUnit, id);\\n\\n                uint256 nftValue = lastNFTUnit > _NFTUnit()\\n                    ? lastNFTUnit\\n                    : _NFTUnit();\\n\\n                if (nftValue > fromBalance) revert InsufficientBalance();\\n                fromAddressData.lockedBalance = uint96(fromBalance - nftValue);\\n\\n                // Save the last unit for next transfer.\\n                _set($.NFTUnit, id, unit);\\n\\n                toAddressData.lockedBalance += uint96(unit);\\n            }\\n            mapping(address => Uint32Map) storage owned = $.owned;\\n            Uint32Map storage fromOwned = owned[from];\\n\\n            if (_get($.mayHaveNFTApproval, id)) {\\n                _set($.mayHaveNFTApproval, id, false);\\n                delete $.nftApprovals[id];\\n            }\\n\\n            {\\n                uint32 updatedId = _get(\\n                    fromOwned,\\n                    --fromAddressData.ownedLength\\n                );\\n                uint32 i = _get(oo, _ownedIndex(id));\\n                _set(fromOwned, i, updatedId);\\n                _set(oo, _ownedIndex(updatedId), i);\\n            }\\n            uint32 n = toAddressData.ownedLength++;\\n            _set(owned[to], n, uint32(id));\\n            _setOwnerAliasAndOwnedIndex(\\n                oo,\\n                id,\\n                _registerAndResolveAlias(toAddressData, to),\\n                n\\n            );\\n        }\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Emit the {Transfer} event.\\n            mstore(0x00, unit)\\n            // forgefmt: disable-next-item\\n            log3(\\n                0x00,\\n                0x20,\\n                _TRANSFER_EVENT_SIGNATURE,\\n                shr(96, shl(96, from)),\\n                shr(96, shl(96, to))\\n            )\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                 INTERNAL APPROVE FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        if (_givePermit2DefaultInfiniteAllowance() && spender == _PERMIT2) {\\n            _getDN404Storage()\\n                .addressData[owner]\\n                .flags |= _ADDRESS_DATA_OVERRIDE_PERMIT2_FLAG;\\n        }\\n        _ref(_getDN404Storage().allowance, owner, spender).value = amount;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            // forgefmt: disable-next-item\\n            log3(\\n                0x00,\\n                0x20,\\n                _APPROVAL_EVENT_SIGNATURE,\\n                shr(96, shl(96, owner)),\\n                shr(96, shl(96, spender))\\n            )\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL CUSTOM FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev\\n    /// - Unlock the locked balance from receiving or minting NFTs,\\n    ///   while simultaneously destroying a corresponding amount of NFTs.\\n    function _unlock(address from) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n        AddressData storage fromAddressData = $.addressData[from];\\n\\n        uint96 lockedBalance = fromAddressData.lockedBalance;\\n        _burn(from, lockedBalance, true);\\n        fromAddressData.balance += lockedBalance;\\n        fromAddressData.lockedBalance = 0;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Emit the {Transfer} event.\\n            mstore(0x00, lockedBalance)\\n            log3(\\n                0x00,\\n                0x20,\\n                _TRANSFER_EVENT_SIGNATURE,\\n                0,\\n                shr(96, shl(96, from))\\n            )\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     SKIP NFT FUNCTIONS                     */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns true if minting and transferring ERC20s to `owner` will skip minting NFTs.\\n    /// Returns false otherwise.\\n    function getSkipNFT(address owner) public view virtual returns (bool) {\\n        AddressData storage d = _getDN404Storage().addressData[owner];\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0)\\n            return _hasCode(owner);\\n        return d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0;\\n    }\\n\\n    /// @dev Sets the caller's skipNFT flag to `skipNFT`. Returns true.\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function setSkipNFT(bool skipNFT) public virtual returns (bool) {\\n        _setSkipNFT(msg.sender, skipNFT);\\n        return true;\\n    }\\n\\n    /// @dev Internal function to set account `owner` skipNFT flag to `state`\\n    ///\\n    /// Initializes account `owner` AddressData if it is not currently initialized.\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function _setSkipNFT(address owner, bool state) internal virtual {\\n        AddressData storage d = _addressData(owner);\\n        if ((d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0) != state) {\\n            d.flags ^= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, iszero(iszero(state)))\\n            log2(\\n                0x00,\\n                0x20,\\n                _SKIP_NFT_SET_EVENT_SIGNATURE,\\n                shr(96, shl(96, owner))\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns a storage data pointer for account `owner` AddressData\\n    ///\\n    /// Initializes account `owner` AddressData if it is not currently initialized.\\n    function _addressData(address owner)\\n        internal\\n        virtual\\n        returns (AddressData storage d)\\n    {\\n        d = _getDN404Storage().addressData[owner];\\n        unchecked {\\n            if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) {\\n                uint256 skipNFT = (_toUint(_hasCode(owner)) *\\n                    _ADDRESS_DATA_SKIP_NFT_FLAG);\\n                d.flags = uint8(skipNFT | _ADDRESS_DATA_INITIALIZED_FLAG);\\n            }\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      CUSTOM FUNCTIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    function _tokensOfWithChecks(address owner)\\n        internal\\n        view\\n        returns (uint256[] memory result)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n        uint256 n = $.addressData[owner].ownedLength;\\n        result = new uint256[](n);\\n        for (uint256 i; i < n; ++i) {\\n            uint256 id = _get($.owned[owner], i);\\n            result[i] = id;\\n            // Check invariants.\\n            require(_ownerAt(id) == owner);\\n            require(_get($.oo, _ownedIndex(id)) == i);\\n        }\\n    }\\n\\n    function _setMaxNFTSupply(uint256 num) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n        $.maxNFTSupply = num;\\n    }\\n\\n    function _getMaxNFTSupply() internal view virtual returns (uint256) {\\n        return _getDN404Storage().maxNFTSupply;\\n    }\\n\\n    /// @dev Returns the `addressAlias` of account `to`.\\n    ///\\n    /// Assigns and registers the next alias if `to` alias was not previously registered.\\n    function _registerAndResolveAlias(\\n        AddressData storage toAddressData,\\n        address to\\n    ) internal virtual returns (uint32 addressAlias) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        addressAlias = toAddressData.addressAlias;\\n        if (addressAlias == 0) {\\n            unchecked {\\n                addressAlias = ++$.numAliases;\\n            }\\n            toAddressData.addressAlias = addressAlias;\\n            $.aliasToAddress[addressAlias] = to;\\n            if (addressAlias == 0) revert(); // Overflow.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the mirror NFT contract.\\n    function mirrorERC721() public view virtual returns (address) {\\n        return _getDN404Storage().mirrorERC721;\\n    }\\n\\n    /// @dev Returns the total NFT supply.\\n    function _totalNFTSupply() internal view virtual returns (uint256) {\\n        return _getDN404Storage().totalNFTSupply;\\n    }\\n\\n    /// @dev Returns `owner` NFT balance.\\n    function _balanceOfNFT(address owner)\\n        internal\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        return _getDN404Storage().addressData[owner].ownedLength;\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    /// Returns the zero address instead of reverting if the token does not exist.\\n    function _ownerAt(uint256 id) internal view virtual returns (address) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        return $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _ownerAt(id);\\n    }\\n\\n    /// @dev Returns if token `id` exists.\\n    function _exists(uint256 id) internal view virtual returns (bool) {\\n        return _ownerAt(id) != address(0);\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _getApproved(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _getDN404Storage().nftApprovals[id];\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id`, using `msgSender`.\\n    ///\\n    /// Requirements:\\n    /// - `msgSender` must be the owner or an approved operator for the token owner.\\n    function _approveNFT(\\n        address spender,\\n        uint256 id,\\n        address msgSender\\n    ) internal virtual returns (address owner) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (msgSender != owner) {\\n            if (_ref($.operatorApprovals, owner, msgSender).value == 0) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n        }\\n\\n        $.nftApprovals[id] = spender;\\n        _set($.mayHaveNFTApproval, id, spender != address(0));\\n    }\\n\\n    /// @dev Approve or remove the `operator` as an operator for `msgSender`,\\n    /// without authorization checks.\\n    function _setApprovalForAll(\\n        address operator,\\n        bool approved,\\n        address msgSender\\n    ) internal virtual {\\n        _ref(_getDN404Storage().operatorApprovals, msgSender, operator)\\n            .value = _toUint(approved);\\n    }\\n\\n    /// @dev Fallback modifier to dispatch calls from the mirror NFT contract\\n    /// to internal functions in this contract.\\n    modifier dn404Fallback() virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `transferFromNFT(address,address,uint256,address)`.\\n        if (fnSelector == 0xe5eb36c8) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x84) revert();\\n\\n            address from = address(uint160(_calldataload(0x04)));\\n            address to = address(uint160(_calldataload(0x24)));\\n            uint256 id = _calldataload(0x44);\\n            address msgSender = address(uint160(_calldataload(0x64)));\\n\\n            _transferFromNFT(from, to, id, msgSender);\\n            _return(1);\\n        }\\n        // `setApprovalForAll(address,bool,address)`.\\n        if (fnSelector == 0x813500fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            bool status = _calldataload(0x24) != 0;\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _setApprovalForAll(spender, status, msgSender);\\n            _return(1);\\n        }\\n        // `isApprovedForAll(address,address)`.\\n        if (fnSelector == 0xe985e9c5) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x44) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n            address operator = address(uint160(_calldataload(0x24)));\\n\\n            _return(_ref($.operatorApprovals, owner, operator).value);\\n        }\\n        // `ownerOf(uint256)`.\\n        if (fnSelector == 0x6352211e) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_ownerOf(id)));\\n        }\\n        // `ownerAt(uint256)`.\\n        if (fnSelector == 0x24359879) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_ownerAt(id)));\\n        }\\n        // `approveNFT(address,uint256,address)`.\\n        if (fnSelector == 0xd10b6e0c) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            uint256 id = _calldataload(0x24);\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _return(uint160(_approveNFT(spender, id, msgSender)));\\n        }\\n        // `getApproved(uint256)`.\\n        if (fnSelector == 0x081812fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_getApproved(id)));\\n        }\\n        // `balanceOfNFT(address)`.\\n        if (fnSelector == 0xf5b100ea) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n\\n            _return(_balanceOfNFT(owner));\\n        }\\n        // `totalNFTSupply()`.\\n        if (fnSelector == 0xe2c79281) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x04) revert();\\n\\n            _return(_totalNFTSupply());\\n        }\\n        // `implementsDN404()`.\\n        if (fnSelector == 0xb7a94eb8) {\\n            _return(1);\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from mirror NFT contract.\\n    fallback() external payable virtual dn404Fallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                 INTERNAL / PRIVATE HELPERS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns `(i - 1) << 1`.\\n    function _ownershipIndex(uint256 i) internal pure returns (uint256) {\\n        unchecked {\\n            return (i - 1) << 1; // Minus 1 as token IDs start from 1.\\n        }\\n    }\\n\\n    /// @dev Returns `((i - 1) << 1) + 1`.\\n    function _ownedIndex(uint256 i) internal pure returns (uint256) {\\n        unchecked {\\n            return ((i - 1) << 1) + 1; // Minus 1 as token IDs start from 1.\\n        }\\n    }\\n\\n    /// @dev Returns the uint32 value at `index` in `map`.\\n    function _get(Uint32Map storage map, uint256 index)\\n        internal\\n        view\\n        returns (uint32 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := add(shl(96, map.slot), shr(3, index)) // Storage slot.\\n            result := and(0xffffffff, shr(shl(5, and(index, 7)), sload(s)))\\n        }\\n    }\\n\\n    /// @dev Updates the uint32 value at `index` in `map`.\\n    function _set(\\n        Uint32Map storage map,\\n        uint256 index,\\n        uint32 value\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := add(shl(96, map.slot), shr(3, index)) // Storage slot.\\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint256 value at `index` in `map`.\\n    function _get(Uint256Map storage map, uint256 index)\\n        internal\\n        view\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := add(map.slot, index) // Storage slot calculation.\\n            result := sload(s)\\n        }\\n    }\\n\\n    /// @dev Updates the uint256 value at `index` in `map`.\\n    function _set(\\n        Uint256Map storage map,\\n        uint256 index,\\n        uint256 value\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := add(map.slot, index) // Storage slot calculation.\\n            sstore(s, value)\\n        }\\n    }\\n\\n    /// @dev Sets the owner alias and the owned index together.\\n    function _setOwnerAliasAndOwnedIndex(\\n        Uint32Map storage map,\\n        uint256 id,\\n        uint32 ownership,\\n        uint32 ownedIndex\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let i := sub(id, 1) // Index of the uint64 combined value.\\n            let s := add(shl(96, map.slot), shr(2, i)) // Storage slot.\\n            let o := shl(6, and(i, 3)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffff // Value mask.\\n            let combined := or(shl(32, ownedIndex), and(0xffffffff, ownership))\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), combined)))))\\n        }\\n    }\\n\\n    /// @dev Returns the boolean value of the bit at `index` in `bitmap`.\\n    function _get(Bitmap storage bitmap, uint256 index)\\n        internal\\n        view\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := add(shl(96, bitmap.slot), shr(8, index)) // Storage slot.\\n            result := and(1, shr(and(0xff, index), sload(s)))\\n        }\\n    }\\n\\n    /// @dev Updates the bit at `index` in `bitmap` to `value`.\\n    function _set(\\n        Bitmap storage bitmap,\\n        uint256 index,\\n        bool value\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := add(shl(96, bitmap.slot), shr(8, index)) // Storage slot.\\n            let o := and(0xff, index) // Storage slot offset (bits).\\n            sstore(\\n                s,\\n                or(and(sload(s), not(shl(o, 1))), shl(o, iszero(iszero(value))))\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns the index of the least significant unset bit in `[begin, end)`.\\n    /// If no set bit is found, returns `type(uint256).max`.\\n    function _findFirstUnset(\\n        Bitmap storage bitmap,\\n        uint256 begin,\\n        uint256 end\\n    ) internal view returns (uint256 unsetBitIndex) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            unsetBitIndex := not(0) // Initialize to `type(uint256).max`.\\n            let s := shl(96, bitmap.slot) // Storage offset of the bitmap.\\n            let bucket := add(s, shr(8, begin))\\n            let lastBucket := add(s, shr(8, end))\\n            let negBits := shl(\\n                and(0xff, begin),\\n                shr(and(0xff, begin), not(sload(bucket)))\\n            )\\n            if iszero(negBits) {\\n                for {\\n\\n                } 1 {\\n\\n                } {\\n                    bucket := add(bucket, 1)\\n                    negBits := not(sload(bucket))\\n                    if or(negBits, gt(bucket, lastBucket)) {\\n                        break\\n                    }\\n                }\\n                if gt(bucket, lastBucket) {\\n                    negBits := shr(\\n                        and(0xff, not(end)),\\n                        shl(and(0xff, not(end)), negBits)\\n                    )\\n                }\\n            }\\n            if negBits {\\n                // Find-first-set routine.\\n                let b := and(negBits, add(not(negBits), 1)) // Isolate the least significant bit.\\n                let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, b))\\n                r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, b))))\\n                r := or(r, shl(5, lt(0xffffffff, shr(r, b))))\\n                // For the remaining 32 bits, use a De Bruijn lookup.\\n                // forgefmt: disable-next-item\\n                r := or(\\n                    r,\\n                    byte(\\n                        and(div(0xd76453e0, shr(r, b)), 0x1f),\\n                        0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405\\n                    )\\n                )\\n                r := or(shl(8, sub(bucket, s)), r)\\n                unsetBitIndex := or(\\n                    r,\\n                    sub(0, or(iszero(lt(r, end)), lt(r, begin)))\\n                )\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a storage reference to the value at (`a0`, `a1`) in `map`.\\n    function _ref(\\n        AddressPairToUint256RefMap storage map,\\n        address a0,\\n        address a1\\n    ) internal pure returns (Uint256Ref storage ref) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x28, a1)\\n            mstore(0x14, a0)\\n            mstore(0x00, map.slot)\\n            ref.slot := keccak256(0x00, 0x48)\\n            // Clear the part of the free memory pointer that was overwritten.\\n            mstore(0x28, 0x00)\\n        }\\n    }\\n\\n    /// @dev Wraps the NFT ID.\\n    function _wrapNFTId(uint256 id, uint256 maxId)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := or(mul(iszero(gt(id, maxId)), id), gt(id, maxId))\\n        }\\n    }\\n\\n    /// @dev Returns whether `amount` is a valid `totalSupply`.\\n    function _totalSupplyOverflows(uint256 amount)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        unchecked {\\n            return\\n                _toUint(amount > type(uint96).max) |\\n                    _toUint(amount / _unit() > type(uint32).max - 1) !=\\n                0;\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function _zeroFloorSub(uint256 x, uint256 y)\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns `b ? 1 : 0`.\\n    function _toUint(bool b) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(iszero(b))\\n        }\\n    }\\n\\n    /// @dev Struct containing packed log data for {Transfer} events to be\\n    /// emitted by the mirror NFT contract.\\n    struct _PackedLogs {\\n        uint256 offset;\\n        uint256 addressAndBit;\\n        uint256[] logs;\\n    }\\n\\n    /// @dev Initiates memory allocation for packed logs with `n` log items.\\n    function _packedLogsMalloc(uint256 n)\\n        private\\n        pure\\n        returns (_PackedLogs memory p)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Note that `p` implicitly allocates and advances the free memory pointer by\\n            // 3 words, which we can safely mutate in `_packedLogsSend`.\\n            let logs := mload(0x40)\\n            mstore(logs, n) // Store the length.\\n            let offset := add(0x20, logs) // Skip the word for `p.logs.length`.\\n            mstore(0x40, add(offset, shl(5, n))) // Allocate memory.\\n            mstore(add(0x40, p), logs) // Set `p.logs`.\\n            mstore(p, offset) // Set `p.offset`.\\n        }\\n    }\\n\\n    /// @dev Set the current address and the burn bit.\\n    function _packedLogsSet(\\n        _PackedLogs memory p,\\n        address a,\\n        uint256 burnBit\\n    ) private pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(add(p, 0x20), or(shl(96, a), burnBit)) // Set `p.addressAndBit`.\\n        }\\n    }\\n\\n    /// @dev Adds a packed log item to `p` with token `id`.\\n    function _packedLogsAppend(_PackedLogs memory p, uint256 id) private pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let offset := mload(p)\\n            mstore(offset, or(mload(add(p, 0x20)), shl(8, id))) // `p.addressAndBit | (id << 8)`.\\n            mstore(p, add(offset, 0x20))\\n        }\\n    }\\n\\n    /// @dev Calls the `mirror` NFT contract to emit {Transfer} events for packed logs `p`.\\n    function _packedLogsSend(_PackedLogs memory p, address mirror) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := mload(add(p, 0x40))\\n            let o := sub(logs, 0x40) // Start of calldata to send.\\n            mstore(o, 0x263c69d6) // `logTransfer(uint256[])`.\\n            mstore(add(o, 0x20), 0x20) // Offset of `logs` in the calldata to send.\\n            let n := add(0x44, shl(5, mload(logs))) // Length of calldata to send.\\n            if iszero(\\n                and(\\n                    eq(mload(o), 1),\\n                    call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20)\\n                )\\n            ) {\\n                revert(o, 0x00)\\n            }\\n        }\\n    }\\n\\n    /// @dev Struct of temporary variables for transfers.\\n    struct _TransferTemps {\\n        uint256 numNFTBurns;\\n        uint256 numNFTMints;\\n        uint256 fromBalance;\\n        uint256 toBalance;\\n        uint256 fromOwnedLength;\\n        uint256 toOwnedLength;\\n        uint256 totalSupply;\\n        uint256 totalNFTSupply;\\n    }\\n\\n    /// @dev Struct of temporary variables for mints.\\n    struct _DNMintTemps {\\n        uint256 toEnd;\\n        uint32 toAlias;\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset)\\n        private\\n        pure\\n        returns (uint256 value)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Executes a return opcode to return `x` and end the current call frame.\\n    function _return(uint256 x) private pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, x)\\n            return(0x00, 0x20)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DNAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkMirrorContractFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MirrorAddressIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReachedMaxBuy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotMirror\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnitIsZero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SkipNFTSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"addressAlias\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"buyDnner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"eat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNFTSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getSkipNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"getTokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialNFTValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"lastNFTUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"lockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxNFTSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mirrorERC721\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openBuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openNextStage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openSetSkipNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openUnlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxBuy_\",\"type\":\"uint256\"}],\"name\":\"setMaxBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMaxNFTSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint120\",\"name\":\"price_\",\"type\":\"uint120\"}],\"name\":\"setPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"skip\",\"type\":\"bool\"}],\"name\":\"setSkipNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleOpenBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleOpenNextStage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleOpenSetSkipNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleOpenUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Dnner", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}