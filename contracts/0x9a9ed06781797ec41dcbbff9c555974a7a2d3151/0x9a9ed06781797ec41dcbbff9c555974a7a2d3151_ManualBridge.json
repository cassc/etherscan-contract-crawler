{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ManualBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"IManualBridge.sol\\\";\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\n\\n// This is a totally centralized (ie not trustless) manual bridge contract for DFP2\\n// bridging between Ethereum and Radix. Requires trust in contract owner.\\ncontract ManualBridge is IManualBridge, Ownable {\\n  IERC20 constant token = IERC20(0x2F57430a6ceDA85a67121757785877b4a71b8E6D);\\n\\n  uint16 constant UNLOCKED = 0x0000;\\n  uint16 constant LOCKED = 0x0001;\\n  address admin;\\n\\n  Config public bridgeConfig = Config({\\n    locked: LOCKED,                     // 2nd bit is admin lock\\n    forwardBaseFee: 100,                // Base fee\\n    forwardFeeFraction: 655,            // Approximately 1%\\n    backwardBaseFee: 500,               // Base fee\\n    backwardFeeFraction: 655,           // Approximately 1%\\n    totalFees: 0                        // Total fees collected\\n  });\\n\\n  constructor(){\\n    admin = 0x3C7791728AdCA8C8ca5A46d6170a9c1fd24408e2;\\n  }\\n\\n  // used for bridge (un)lock functions which may only be called by admin or owner\\n  modifier onlyAdmin() {\\n    if (msg.sender != admin && msg.sender != owner()) { revert AdminRightsRequired(); }\\n    _;\\n  }\\n\\n  /**\\n   * @inheritdoc IManualBridge\\n   */\\n  function bridge(\\n    uint256 inputAmount,\\n    bytes32[2] calldata radixAddress\\n  ) external override\\n  {\\n    Config storage c = bridgeConfig;\\n    if (c.locked == LOCKED) { revert BridgeLocked(); }\\n    if (inputAmount <= c.forwardBaseFee) { revert InsufficientInput(); }\\n    if (token.transferFrom(msg.sender, address(this), inputAmount) != true) { revert TokenTransferFailure(); }\\n\\n    uint256 baseFee = uint256(c.forwardBaseFee) * 10**18;\\n    uint256 fractionalFee = (inputAmount * c.forwardFeeFraction) >> 16;\\n    uint256 fee = baseFee > fractionalFee ? baseFee : fractionalFee;\\n    c.totalFees += uint96(fee);\\n\\n    emit Bridged(msg.sender, inputAmount - fee, fee, radixAddress);\\n  }\\n\\n  /**\\n   * @notice Bridge tokens back from Radix to Ethereum. Release these tokens to the user.\\n   * @param inputAmount Amount of tokens bridged back to Ethereum.\\n   * @param destination Address of the user to receive the funds.\\n   * @param radixHash Transaction on the Radix network removing supply on Radix.\\n   */\\n  function release(\\n    uint256 inputAmount,\\n    address destination,\\n    bytes32[2] calldata radixHash\\n  ) external onlyOwner()\\n  {\\n    Config storage c = bridgeConfig;\\n    if (c.locked == LOCKED) { revert BridgeLocked(); }\\n    if (inputAmount <= c.backwardBaseFee) { revert InsufficientInput(); }\\n\\n    uint256 baseFee = uint256(c.backwardBaseFee) * 10**18;\\n    uint256 fractionalFee = (inputAmount * c.backwardFeeFraction) >> 16;\\n    uint256 fee = baseFee > fractionalFee ? baseFee : fractionalFee;\\n    c.totalFees += uint96(fee);\\n\\n    if (token.transfer(destination, inputAmount - fee) != true) { revert TokenTransferFailure(); }\\n    emit Released(destination, inputAmount - fee, fee, radixHash);\\n  }\\n\\n  /**\\n   * @notice Sets admin address for emergency exchange locking.\\n   * @dev Can only be called by the owner of the contract.\\n   * @param adminAddress Address of the admin to set\\n   */\\n  function setAdmin(address adminAddress) external onlyOwner() {\\n    admin = adminAddress;\\n    emit AdminChanged(adminAddress);\\n  }\\n\\n  /**\\n   * @notice Sets exchange lock, under which swap and liquidity add (but not remove) are disabled.\\n   * @dev Can only be called by the admin of the contract.\\n   */\\n  function lockBridge() external onlyAdmin() {\\n    bridgeConfig.locked = LOCKED;\\n    emit LockChanged(msg.sender, bridgeConfig.locked);\\n  }\\n\\n  /**\\n   * @notice Resets exchange lock.\\n   * @dev Can only be called by the admin of the contract.\\n   */\\n  function unlockBridge() external onlyAdmin() {\\n    bridgeConfig.locked = UNLOCKED;\\n    emit LockChanged(msg.sender, bridgeConfig.locked);\\n  }\\n\\n  /**\\n   * @notice Updates bridge fees.\\n   * @param newForwardBaseFee New forward base fee level in whole tokens\\n   * @param newForwardFeeFraction New forward fractional fee (times 2^-16)\\n   * @param newBackwardBaseFee New backward base fee level in whole tokens\\n   * @param newBackwardFeeFraction New backward fractional fee (times 2^-16)\\n   */\\n  function setFees(\\n    uint16 newForwardBaseFee,\\n    uint16 newForwardFeeFraction,\\n    uint16 newBackwardBaseFee,\\n    uint16 newBackwardFeeFraction\\n  ) external onlyOwner()\\n  {\\n    Config storage c = bridgeConfig;\\n    c.forwardBaseFee = newForwardBaseFee;\\n    c.forwardFeeFraction = newForwardFeeFraction;\\n    c.backwardBaseFee = newBackwardBaseFee;\\n    c.backwardFeeFraction = newBackwardFeeFraction;\\n\\n    emit ConfigUpdated(c);\\n  }\\n\\n  /**\\n   * @notice Claims fees collected by the bridge and transfers to selected address\\n   * @param destination Address that the fees will be transferred to\\n   */\\n  function claimFees(address destination) external onlyOwner() {\\n    Config storage c = bridgeConfig;\\n    uint256 totalFees = uint256(c.totalFees);\\n    if (token.transfer(destination, totalFees) != true) { revert TokenTransferFailure(); }\\n    c.totalFees = 0;\\n\\n    emit FeesClaimed(totalFees);\\n  }\\n}\\n\"\r\n    },\r\n    \"IManualBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title ManualBridge interface\\n * @author Jazzer9F\\n */\\ninterface IManualBridge {\\n  error AdminRightsRequired();\\n  error TokenTransferFailure();\\n  error InsufficientInput();\\n  error BridgeLocked();\\n\\n  // bridge configuration\\n  struct Config {\\n    uint16 locked;                    // variable to keep track of whether the exchnage is locked\\n    uint16 forwardBaseFee;            // base fee level in # of whole tokens\\n    uint16 forwardFeeFraction;        // variable part of fee\\n    uint16 backwardBaseFee;           // base fee level in # of whole tokens\\n    uint16 backwardFeeFraction;       // variable part of fee\\n    uint96 totalFees;                 // total fees currently held by the contract\\n  }\\n\\n /**\\n  * @notice Bridge the token towards Radix. Forwards the tokens to the team address.\\n  * @param amountToBridge Amount of tokens to bridge to Radix\\n  * @param radixAddress Address on the Radix public network that tokens should be sent to\\n  */\\n  function bridge(\\n    uint256 amountToBridge,\\n    bytes32[2] calldata radixAddress\\n  ) external;\\n\\n /**\\n  * @notice Emit Bridged event when tokens are bridged to the Radix network\\n  * @param source Address of the caller\\n  * @param netAmountBridged Amount of tokens sent to the Radix network (held in team wallet)\\n  * @param feePayed Fee withheld from the bridged amount\\n  * @param radixAddress The address on the Radix network that the tokens are to be sent to\\n  */\\n  event Bridged(\\n    address source,\\n    uint256 netAmountBridged,\\n    uint256 feePayed,\\n    bytes32[2] radixAddress\\n  );\\n\\n  /**\\n   * @notice Emit Released event when tokens are bridged back from the Radix network\\n   * @param destination Address of the bridge user\\n   * @param radixHash Transaction on Radix network paying for this release\\n   * @param feePayed Amount of fee payed\\n   * @param amountReleased Amount of DFP2 released to the user\\n   */\\n  event Released(\\n    address destination,\\n    uint256 amountReleased,\\n    uint256 feePayed,\\n    bytes32[2] radixHash\\n  );\\n\\n  /**\\n   * @notice Emit adminChanged event when the bridge config (ie fees) is updated.\\n   * @param newConfig The updated config struct\\n   */\\n  event ConfigUpdated(\\n    Config newConfig\\n  );\\n\\n  /**\\n   * @notice Emit adminChanged event when the exchange admin address is changed\\n   * @param newAdmin Address of new admin, who can (un)lock the exchange\\n   */\\n  event AdminChanged(\\n    address newAdmin\\n  );\\n\\n  /**\\n   * @notice Emit LockChanged event when the exchange is (un)locked by an admin\\n   * @param exchangeAdmin Address of the admin making the change\\n   * @param newLockValue The updated value of the lock variable\\n   */\\n  event LockChanged(\\n    address exchangeAdmin,\\n    uint256 newLockValue\\n  );\\n\\n  /**\\n   * @notice Emit FeesClaimed when the fees collected by the bridge are claimed by the owner\\n   * @param amountClaimed Amount of fees withdrawn. This is always the total amount of fees collected until now.\\n   */\\n  event FeesClaimed(\\n    uint256 amountClaimed\\n  );\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"ManualBridge.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AdminRightsRequired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BridgeLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTransferFailure\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"netAmountBridged\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePayed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32[2]\",\"name\":\"radixAddress\",\"type\":\"bytes32[2]\"}],\"name\":\"Bridged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"locked\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"forwardBaseFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"forwardFeeFraction\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"backwardBaseFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"backwardFeeFraction\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"totalFees\",\"type\":\"uint96\"}],\"indexed\":false,\"internalType\":\"struct IManualBridge.Config\",\"name\":\"newConfig\",\"type\":\"tuple\"}],\"name\":\"ConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"}],\"name\":\"FeesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchangeAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLockValue\",\"type\":\"uint256\"}],\"name\":\"LockChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountReleased\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePayed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32[2]\",\"name\":\"radixHash\",\"type\":\"bytes32[2]\"}],\"name\":\"Released\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[2]\",\"name\":\"radixAddress\",\"type\":\"bytes32[2]\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeConfig\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"locked\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"forwardBaseFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"forwardFeeFraction\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"backwardBaseFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"backwardFeeFraction\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"totalFees\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"bytes32[2]\",\"name\":\"radixHash\",\"type\":\"bytes32[2]\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adminAddress\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newForwardBaseFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"newForwardFeeFraction\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"newBackwardBaseFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"newBackwardFeeFraction\",\"type\":\"uint16\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ManualBridge", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}