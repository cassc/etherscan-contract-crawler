{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ScribeOptimistic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.16;\\n\\nimport {IChronicle} from \\\"chronicle-std/IChronicle.sol\\\";\\n\\nimport {IScribeOptimistic} from \\\"./IScribeOptimistic.sol\\\";\\n\\nimport {IScribe} from \\\"./IScribe.sol\\\";\\nimport {Scribe} from \\\"./Scribe.sol\\\";\\n\\nimport {LibSchnorr} from \\\"./libs/LibSchnorr.sol\\\";\\nimport {LibSecp256k1} from \\\"./libs/LibSecp256k1.sol\\\";\\n\\n/**\\n * @title ScribeOptimistic\\n *\\n * @notice Scribe based optimistic Oracle with onchain fault resolution\\n */\\ncontract ScribeOptimistic is IScribeOptimistic, Scribe {\\n    using LibSchnorr for LibSecp256k1.Point;\\n    using LibSecp256k1 for LibSecp256k1.Point;\\n    using LibSecp256k1 for LibSecp256k1.Point[];\\n\\n    /// @dev The initial opChallengePeriod set during construction.\\n    uint16 private constant _INITIAL_OP_CHALLENGE_PERIOD = 1 hours;\\n\\n    // -- Storage --\\n\\n    /// @inheritdoc IScribeOptimistic\\n    uint16 public opChallengePeriod;\\n\\n    /// @inheritdoc IScribeOptimistic\\n    uint8 public opFeedIndex;\\n\\n    /// @dev The truncated hash of the schnorrData provided in last opPoke.\\n    ///      Binds the opFeed to their schnorrData.\\n    uint160 internal _schnorrDataCommitment;\\n\\n    /// @dev The age of the pokeData provided in last opPoke.\\n    ///      Ensures Schnorr signature can be verified after setting pokeData's\\n    ///      age to block.timestamp during opPoke.\\n    uint32 internal _originalOpPokeDataAge;\\n\\n    /// @dev opScribe's last opPoke'd value and corresponding age.\\n    PokeData internal _opPokeData;\\n\\n    /// @inheritdoc IScribeOptimistic\\n    uint public maxChallengeReward;\\n\\n    // -- Constructor and Receive Functionality --\\n\\n    constructor(address initialAuthed, bytes32 wat_)\\n        Scribe(initialAuthed, wat_)\\n    {\\n        // Note to have a non-zero challenge period.\\n        _setOpChallengePeriod(_INITIAL_OP_CHALLENGE_PERIOD);\\n    }\\n\\n    receive() external payable {}\\n\\n    // -- Poke Functionality --\\n\\n    function _poke(PokeData calldata pokeData, SchnorrData calldata schnorrData)\\n        internal\\n        override(Scribe)\\n    {\\n        // Load current age from storage.\\n        uint32 age = _currentPokeData().age;\\n\\n        // Revert if pokeData stale.\\n        if (pokeData.age <= age) {\\n            revert StaleMessage(pokeData.age, age);\\n        }\\n        // Revert if pokeData from the future.\\n        if (pokeData.age > uint32(block.timestamp)) {\\n            revert FutureMessage(pokeData.age, uint32(block.timestamp));\\n        }\\n\\n        // Revert if schnorrData does not prove integrity of pokeData.\\n        bool ok;\\n        bytes memory err;\\n        // forgefmt: disable-next-item\\n        (ok, err) = _verifySchnorrSignature(\\n            constructPokeMessage(pokeData),\\n            schnorrData\\n        );\\n        if (!ok) {\\n            _revert(err);\\n        }\\n\\n        // Store pokeData's val in _pokeData storage and set its age to now.\\n        _pokeData.val = pokeData.val;\\n        _pokeData.age = uint32(block.timestamp);\\n\\n        emit Poked(msg.sender, pokeData.val, pokeData.age);\\n    }\\n\\n    // -- opPoke Functionality --\\n\\n    /// @dev Optimized function selector: 0x00000000.\\n    ///      Note that this function is _not_ defined via the IScribe interface\\n    ///      and one should _not_ depend on it.\\n    function opPoke_optimized_397084999(\\n        PokeData calldata pokeData,\\n        SchnorrData calldata schnorrData,\\n        ECDSAData calldata ecdsaData\\n    ) external payable {\\n        _opPoke(pokeData, schnorrData, ecdsaData);\\n    }\\n\\n    /// @inheritdoc IScribeOptimistic\\n    function opPoke(\\n        PokeData calldata pokeData,\\n        SchnorrData calldata schnorrData,\\n        ECDSAData calldata ecdsaData\\n    ) external {\\n        _opPoke(pokeData, schnorrData, ecdsaData);\\n    }\\n\\n    function _opPoke(\\n        PokeData calldata pokeData,\\n        SchnorrData calldata schnorrData,\\n        ECDSAData calldata ecdsaData\\n    ) internal {\\n        // Load _opPokeData from storage.\\n        PokeData memory opPokeData = _opPokeData;\\n\\n        // Decide whether _opPokeData finalized.\\n        bool opPokeDataFinalized =\\n            opPokeData.age + opChallengePeriod <= uint32(block.timestamp);\\n\\n        // Revert if _opPokeData not finalized, i.e. still challengeable.\\n        if (!opPokeDataFinalized) {\\n            revert InChallengePeriod();\\n        }\\n\\n        // Decide current age.\\n        uint32 age =\\n            opPokeData.age > _pokeData.age ? opPokeData.age : _pokeData.age;\\n\\n        // Revert if pokeData stale.\\n        if (pokeData.age <= age) {\\n            revert StaleMessage(pokeData.age, age);\\n        }\\n        // Revert if pokeData from the future.\\n        if (pokeData.age > uint32(block.timestamp)) {\\n            revert FutureMessage(pokeData.age, uint32(block.timestamp));\\n        }\\n\\n        // Recover ECDSA signer.\\n        address signer = ecrecover(\\n            _constructOpPokeMessage(pokeData, schnorrData),\\n            ecdsaData.v,\\n            ecdsaData.r,\\n            ecdsaData.s\\n        );\\n\\n        // Load signer's index.\\n        uint signerIndex = _feeds[signer];\\n\\n        // Revert if signer not feed.\\n        if (signerIndex == 0) {\\n            revert SignerNotFeed(signer);\\n        }\\n\\n        // Store the signerIndex as opFeedIndex and bind them to their provided\\n        // schnorrData.\\n        //\\n        // Note that cast is safe as _feed's image is [0, _pubKeys.length) and\\n        // _pubKeys' length is bounded by maxFeeds, i.e. type(uint8).max - 1.\\n        opFeedIndex = uint8(signerIndex);\\n        _schnorrDataCommitment = uint160(\\n            uint(\\n                keccak256(\\n                    abi.encodePacked(\\n                        schnorrData.signature,\\n                        schnorrData.commitment,\\n                        schnorrData.signersBlob\\n                    )\\n                )\\n            )\\n        );\\n\\n        // If _opPokeData provides the current val, move it to the _pokeData\\n        // storage to free _opPokeData storage. If the current val is provided\\n        // by _pokeData, _opPokeData can be overwritten.\\n        if (opPokeData.age == age) {\\n            _pokeData = opPokeData;\\n        }\\n\\n        // Store provided pokeData's val in _opPokeData storage.\\n        _opPokeData.val = pokeData.val;\\n        _opPokeData.age = uint32(block.timestamp);\\n\\n        // Store pokeData's age to allow recreating original pokeMessage.\\n        _originalOpPokeDataAge = pokeData.age;\\n\\n        emit OpPoked(msg.sender, signer, schnorrData, pokeData);\\n    }\\n\\n    /// @inheritdoc IScribeOptimistic\\n    function opChallenge(SchnorrData calldata schnorrData)\\n        external\\n        returns (bool)\\n    {\\n        // Load _opPokeData from storage.\\n        PokeData memory opPokeData = _opPokeData;\\n\\n        // Decide whether _opPokeData is challengeable.\\n        bool opPokeDataChallengeable =\\n            opPokeData.age + opChallengePeriod > uint32(block.timestamp);\\n\\n        // Revert if _opPokeData is not challengeable.\\n        if (!opPokeDataChallengeable) {\\n            revert NoOpPokeToChallenge();\\n        }\\n\\n        // Construct truncated hash from schnorrData.\\n        uint160 schnorrDataHash = uint160(\\n            uint(\\n                keccak256(\\n                    abi.encodePacked(\\n                        schnorrData.signature,\\n                        schnorrData.commitment,\\n                        schnorrData.signersBlob\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Revert if schnorrDataHash does not match _schnorrDataCommitment.\\n        if (schnorrDataHash != _schnorrDataCommitment) {\\n            revert SchnorrDataMismatch(schnorrDataHash, _schnorrDataCommitment);\\n        }\\n\\n        // Decide whether schnorrData verifies opPokeData.\\n        bool ok;\\n        bytes memory err;\\n        (ok, err) = _verifySchnorrSignature(\\n            constructPokeMessage(\\n                PokeData({val: opPokeData.val, age: _originalOpPokeDataAge})\\n            ),\\n            schnorrData\\n        );\\n\\n        if (ok) {\\n            // Decide whether _opPokeData stale already.\\n            bool opPokeDataStale = opPokeData.age <= _pokeData.age;\\n\\n            // If _opPokeData not stale, finalize it by moving it to the\\n            // _pokeData storage. Note to also clean the _opPokeData storage to\\n            // not block new opPoke's as _opPokeData's challenge period not over.\\n            if (!opPokeDataStale) {\\n                _pokeData = _opPokeData;\\n                delete _opPokeData;\\n            }\\n\\n            emit OpPokeChallengedUnsuccessfully(msg.sender);\\n        } else {\\n            // Drop opFeed and delete invalid _opPokeData.\\n            // Note to use address(this) as caller to indicate self-governed\\n            // drop of feed.\\n            _drop(address(this), opFeedIndex);\\n\\n            // Pay ETH reward to challenger.\\n            uint reward = challengeReward();\\n            if (_sendETH(payable(msg.sender), reward)) {\\n                emit OpChallengeRewardPaid(msg.sender, reward);\\n            }\\n\\n            emit OpPokeChallengedSuccessfully(msg.sender, err);\\n        }\\n\\n        // Return whether challenging was successful.\\n        return !ok;\\n    }\\n\\n    /// @inheritdoc IScribeOptimistic\\n    function constructOpPokeMessage(\\n        PokeData calldata pokeData,\\n        SchnorrData calldata schnorrData\\n    ) external view returns (bytes32) {\\n        return _constructOpPokeMessage(pokeData, schnorrData);\\n    }\\n\\n    function _constructOpPokeMessage(\\n        PokeData calldata pokeData,\\n        SchnorrData calldata schnorrData\\n    ) internal view returns (bytes32) {\\n        return keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(\\n                    abi.encodePacked(\\n                        wat,\\n                        pokeData.val,\\n                        pokeData.age,\\n                        schnorrData.signature,\\n                        schnorrData.commitment,\\n                        schnorrData.signersBlob\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    // -- Toll'ed Read Functionality --\\n\\n    // - IChronicle Functions\\n\\n    /// @inheritdoc IChronicle\\n    /// @dev Only callable by toll'ed address.\\n    function read()\\n        external\\n        view\\n        override(IChronicle, Scribe)\\n        toll\\n        returns (uint)\\n    {\\n        uint val = _currentPokeData().val;\\n        require(val != 0);\\n        return val;\\n    }\\n\\n    /// @inheritdoc IChronicle\\n    /// @dev Only callable by toll'ed address.\\n    function tryRead()\\n        external\\n        view\\n        override(IChronicle, Scribe)\\n        toll\\n        returns (bool, uint)\\n    {\\n        uint val = _currentPokeData().val;\\n        return (val != 0, val);\\n    }\\n\\n    /// @inheritdoc IChronicle\\n    /// @dev Only callable by toll'ed address.\\n    function readWithAge()\\n        external\\n        view\\n        override(IChronicle, Scribe)\\n        toll\\n        returns (uint, uint)\\n    {\\n        PokeData memory pokeData = _currentPokeData();\\n        require(pokeData.val != 0);\\n        return (pokeData.val, pokeData.age);\\n    }\\n\\n    function tryReadWithAge()\\n        external\\n        view\\n        override(IChronicle, Scribe)\\n        toll\\n        returns (bool, uint, uint)\\n    {\\n        PokeData memory pokeData = _currentPokeData();\\n        return (pokeData.val != 0, pokeData.val, pokeData.age);\\n    }\\n\\n    // - MakerDAO Compatibility\\n\\n    /// @inheritdoc IScribe\\n    /// @dev Only callable by toll'ed address.\\n    function peek()\\n        external\\n        view\\n        override(IScribe, Scribe)\\n        toll\\n        returns (uint, bool)\\n    {\\n        uint val = _currentPokeData().val;\\n        return (val, val != 0);\\n    }\\n\\n    /// @inheritdoc IScribe\\n    /// @dev Only callable by toll'ed address.\\n    function peep()\\n        external\\n        view\\n        override(IScribe, Scribe)\\n        toll\\n        returns (uint, bool)\\n    {\\n        uint val = _currentPokeData().val;\\n        return (val, val != 0);\\n    }\\n\\n    // - Chainlink Compatibility\\n\\n    /// @inheritdoc IScribe\\n    /// @dev Only callable by toll'ed address.\\n    function latestRoundData()\\n        external\\n        view\\n        override(IScribe, Scribe)\\n        toll\\n        returns (\\n            uint80 roundId,\\n            int answer,\\n            uint startedAt,\\n            uint updatedAt,\\n            uint80 answeredInRound\\n        )\\n    {\\n        PokeData memory pokeData = _currentPokeData();\\n\\n        roundId = 1;\\n        answer = int(uint(pokeData.val));\\n        // assert(uint(answer) == uint(pokeData.val));\\n        startedAt = 0;\\n        updatedAt = pokeData.age;\\n        answeredInRound = roundId;\\n    }\\n\\n    function _currentPokeData() internal view returns (PokeData memory) {\\n        // Load pokeData slots from storage.\\n        PokeData memory pokeData = _pokeData;\\n        PokeData memory opPokeData = _opPokeData;\\n\\n        // Decide whether _opPokeData is finalized.\\n        bool opPokeDataFinalized =\\n            opPokeData.age + opChallengePeriod <= uint32(block.timestamp);\\n\\n        // Decide and return current pokeData.\\n        if (opPokeDataFinalized && opPokeData.age > pokeData.age) {\\n            return opPokeData;\\n        } else {\\n            return pokeData;\\n        }\\n    }\\n\\n    // -- Auth'ed Functionality --\\n\\n    /// @inheritdoc IScribeOptimistic\\n    function setOpChallengePeriod(uint16 opChallengePeriod_) external auth {\\n        _setOpChallengePeriod(opChallengePeriod_);\\n    }\\n\\n    function _setOpChallengePeriod(uint16 opChallengePeriod_) internal {\\n        require(opChallengePeriod_ != 0);\\n\\n        if (opChallengePeriod != opChallengePeriod_) {\\n            emit OpChallengePeriodUpdated(\\n                msg.sender, opChallengePeriod, opChallengePeriod_\\n            );\\n            opChallengePeriod = opChallengePeriod_;\\n        }\\n\\n        _afterAuthedAction();\\n    }\\n\\n    function _drop(address caller, uint feedIndex) internal override(Scribe) {\\n        super._drop(caller, feedIndex);\\n\\n        _afterAuthedAction();\\n    }\\n\\n    function _setBar(uint8 bar_) internal override(Scribe) {\\n        super._setBar(bar_);\\n\\n        _afterAuthedAction();\\n    }\\n\\n    /// @dev Ensures an auth'ed configuration update does not enable\\n    ///      successfully challenging a prior to the update valid opPoke.\\n    ///\\n    /// @custom:invariant Val is provided if _pokeData prior to the tx is\\n    ///                   non-empty. Note that this is the case if there were\\n    ///                   at least two valid calls \u220a {poke, opPoke}.\\n    ///                     preTx(_pokeData) != (0, 0)\\n    ///                       \u2192 (true, _) = postTx(tryRead())\\n    /// @custom:invariant Val is provided via _pokeData after the tx.\\n    ///                     postTx(readWithAge()) = postTx(_pokeData)\\n    /// @custom:invariant _opPokeData is empty after the tx.\\n    ///                     (0, 0) = postTx(_opPokeData)\\n    function _afterAuthedAction() internal {\\n        // Do nothing during deployment.\\n        if (address(this).code.length == 0) return;\\n\\n        // Load _opPokeData from storage.\\n        PokeData memory opPokeData = _opPokeData;\\n\\n        // Decide whether _opPokeData is finalized.\\n        //\\n        // Note that the decision is based on the possibly updated\\n        // opChallengePeriod! This means a once finalized opPoke may be dropped\\n        // if the opChallengePeriod was increased.\\n        bool opPokeDataFinalized =\\n            opPokeData.age + opChallengePeriod <= uint32(block.timestamp);\\n\\n        // Note that _opPokeData is in one of the following three states:\\n        // 1. finalized and newer than _pokeData\\n        // 2. finalized but older than _pokeData\\n        // 3. non-finalized\\n        //\\n        // Note that for state 1 _opPokeData can be moved to _pokeData and\\n        // afterwards deleted.\\n        // Note that for state 2 and 3 _opPokeData can be directly deleted.\\n\\n        // If _opPokeData is in state 1, move it to the _pokeData storage.\\n        //\\n        // Note that this ensures the current value is provided via _pokeData.\\n        if (opPokeDataFinalized && opPokeData.age > _pokeData.age) {\\n            _pokeData = opPokeData;\\n        }\\n\\n        // If _opPokeData is in state 3, emit event to indicate a possibly valid\\n        // opPoke was dropped.\\n        if (!opPokeDataFinalized) {\\n            emit OpPokeDataDropped(msg.sender, opPokeData);\\n        }\\n\\n        // Now it is safe to delete _opPokeData.\\n        delete _opPokeData;\\n\\n        // Note that the current value is now provided via _pokeData.\\n        // assert(_currentPokeData().val == _pokeData.val);\\n        // assert(_currentPokeData().age == _pokeData.age);\\n\\n        // Set the age of contract's current value to block.timestamp.\\n        //\\n        // Note that this ensures an already signed, but now possibly invalid\\n        // with regards to contract configurations, opPoke payload cannot be\\n        // opPoke'd anymore.\\n        _pokeData.age = uint32(block.timestamp);\\n    }\\n\\n    // -- Searcher Incentivization Logic --\\n\\n    /// @inheritdoc IScribeOptimistic\\n    function challengeReward() public view returns (uint) {\\n        uint balance = address(this).balance;\\n        return balance > maxChallengeReward ? maxChallengeReward : balance;\\n    }\\n\\n    /// @inheritdoc IScribeOptimistic\\n    function setMaxChallengeReward(uint maxChallengeReward_) external auth {\\n        if (maxChallengeReward != maxChallengeReward_) {\\n            emit MaxChallengeRewardUpdated(\\n                msg.sender, maxChallengeReward, maxChallengeReward_\\n            );\\n            maxChallengeReward = maxChallengeReward_;\\n        }\\n    }\\n\\n    function _sendETH(address payable to, uint amount)\\n        internal\\n        returns (bool)\\n    {\\n        (bool ok,) = to.call{value: amount}(\\\"\\\");\\n        return ok;\\n    }\\n}\\n\\n/**\\n * @dev Contract overwrite to deploy contract instances with specific naming.\\n *\\n *      For more info, see docs/Deployment.md.\\n */\\ncontract Chronicle_WSTETH_USD_1 is ScribeOptimistic {\\n    constructor(address initialAuthed, bytes32 wat_)\\n        ScribeOptimistic(initialAuthed, wat_)\\n    {}\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/IChronicle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n * @title IChronicle\\n *\\n * @notice Interface for Chronicle Protocol's oracle products\\n */\\ninterface IChronicle {\\n    /// @notice Returns the oracle's identifier.\\n    /// @return wat The oracle's identifier.\\n    function wat() external view returns (bytes32 wat);\\n\\n    /// @notice Returns the oracle's current value.\\n    /// @dev Reverts if no value set.\\n    /// @return value The oracle's current value.\\n    function read() external view returns (uint value);\\n\\n    /// @notice Returns the oracle's current value and its age.\\n    /// @dev Reverts if no value set.\\n    /// @return value The oracle's current value.\\n    /// @return age The value's age.\\n    function readWithAge() external view returns (uint value, uint age);\\n\\n    /// @notice Returns the oracle's current value.\\n    /// @return isValid True if value exists, false otherwise.\\n    /// @return value The oracle's current value if it exists, zero otherwise.\\n    function tryRead() external view returns (bool isValid, uint value);\\n\\n    /// @notice Returns the oracle's current value and its age.\\n    /// @return isValid True if value exists, false otherwise.\\n    /// @return value The oracle's current value if it exists, zero otherwise.\\n    /// @return age The value's age if value exists, zero otherwise.\\n    function tryReadWithAge()\\n        external\\n        view\\n        returns (bool isValid, uint value, uint age);\\n}\\n\"\r\n    },\r\n    \"src/IScribeOptimistic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {IScribe} from \\\"./IScribe.sol\\\";\\n\\ninterface IScribeOptimistic is IScribe {\\n    /// @notice Thrown if attempted to opPoke while a previous opPoke is still\\n    ///         in challenge period.\\n    error InChallengePeriod();\\n\\n    /// @notice Thrown if opChallenge called while no opPoke exists thats\\n    ///         challengeable.\\n    error NoOpPokeToChallenge();\\n\\n    /// @notice Thrown if opChallenge called with SchnorrData not matching\\n    ///         opPoke's SchnorrData.\\n    /// @param gotHash The truncated keccak256 hash of the SchnorrData argument.\\n    /// @param wantHash The truncated expected keccak256 hash of the SchnorrData\\n    ///                 argument.\\n    error SchnorrDataMismatch(uint160 gotHash, uint160 wantHash);\\n\\n    /// @notice Emitted when oracles was successfully opPoked.\\n    /// @param caller The caller's address.\\n    /// @param opFeed The feed that signed the opPoke.\\n    /// @param schnorrData The schnorrData opPoked.\\n    /// @param pokeData The pokeData opPoked.\\n    event OpPoked(\\n        address indexed caller,\\n        address indexed opFeed,\\n        IScribe.SchnorrData schnorrData,\\n        IScribe.PokeData pokeData\\n    );\\n\\n    /// @notice Emitted when successfully challenged an opPoke.\\n    /// @param caller The caller's address.\\n    /// @param schnorrErr The abi-encoded custom error returned from the failed\\n    ///                   Schnorr signature verification.\\n    event OpPokeChallengedSuccessfully(\\n        address indexed caller, bytes schnorrErr\\n    );\\n\\n    /// @notice Emitted when unsuccessfully challenged an opPoke.\\n    /// @param caller The caller's address.\\n    event OpPokeChallengedUnsuccessfully(address indexed caller);\\n\\n    /// @notice Emitted when ETH reward paid for successfully challenging an\\n    ///         opPoke.\\n    /// @param challenger The challenger to which the reward was send.\\n    /// @param reward The ETH rewards paid.\\n    event OpChallengeRewardPaid(address indexed challenger, uint reward);\\n\\n    /// @notice Emitted when an opPoke dropped.\\n    /// @dev opPoke's are dropped if security parameters are updated that could\\n    ///      lead to an initially valid opPoke becoming invalid or an opPoke was\\n    ///      was successfully challenged.\\n    /// @param caller The caller's address.\\n    /// @param pokeData The pokeData dropped.\\n    event OpPokeDataDropped(address indexed caller, IScribe.PokeData pokeData);\\n\\n    /// @notice Emitted when length of opChallengePeriod updated.\\n    /// @param caller The caller's address.\\n    /// @param oldOpChallengePeriod The old opChallengePeriod's length.\\n    /// @param newOpChallengePeriod The new opChallengePeriod's length.\\n    event OpChallengePeriodUpdated(\\n        address indexed caller,\\n        uint16 oldOpChallengePeriod,\\n        uint16 newOpChallengePeriod\\n    );\\n\\n    /// @notice Emitted when maxChallengeReward updated.\\n    /// @param caller The caller's address.\\n    /// @param oldMaxChallengeReward The old maxChallengeReward.\\n    /// @param newMaxChallengeReward The new maxChallengeReward.\\n    event MaxChallengeRewardUpdated(\\n        address indexed caller,\\n        uint oldMaxChallengeReward,\\n        uint newMaxChallengeReward\\n    );\\n\\n    /// @notice Optimistically pokes the oracle.\\n    /// @dev Expects `pokeData`'s age to be greater than the timestamp of the\\n    ///      last successful poke.\\n    /// @dev Expects `ecdsaData` to be a signature from a feed.\\n    /// @dev Expects `ecdsaData` to prove the integrity of the `pokeData` and\\n    ///      `schnorrData`.\\n    /// @dev If the `schnorrData` is proven to be invalid via the opChallenge\\n    ///      function, the `ecdsaData` signing feed will be dropped.\\n    /// @param pokeData The PokeData being poked.\\n    /// @param schnorrData The SchnorrData optimistically assumed to be\\n    ///                    proving the `pokeData`'s integrity.\\n    /// @param ecdsaData The ECDSAData proving the integrity of the\\n    ///                  `pokeData` and `schnorrData`.\\n    function opPoke(\\n        PokeData calldata pokeData,\\n        SchnorrData calldata schnorrData,\\n        ECDSAData calldata ecdsaData\\n    ) external;\\n\\n    /// @notice Challenges the current challengeable opPoke.\\n    /// @dev If opPoke is determined to be invalid, the caller receives an ETH\\n    ///      bounty. The bounty is defined via the `challengeReward()(uint)`\\n    ///      function.\\n    /// @dev If opPoke is determined to be invalid, the corresponding feed is\\n    ///      dropped.\\n    /// @param schnorrData The SchnorrData initially provided via\\n    ///                    opPoke.\\n    /// @return ok True if opPoke declared invalid, false otherwise.\\n    function opChallenge(SchnorrData calldata schnorrData)\\n        external\\n        returns (bool ok);\\n\\n    /// @notice Returns the message expected to be signed via ECDSA for calling\\n    ///         opPoke.\\n    /// @dev The message is defined as:\\n    ///         H(tag \u2016 H(wat \u2016 pokeData \u2016 schnorrData)), where H() is the keccak256 function.\\n    /// @param pokeData The pokeData being optimistically poked.\\n    /// @param schnorrData The schnorrData proving `pokeData`'s integrity.\\n    /// @return opPokeMessage Message to be signed for an opPoke for `pokeData`\\n    ///                       and `schnorrData`.\\n    function constructOpPokeMessage(\\n        PokeData calldata pokeData,\\n        SchnorrData calldata schnorrData\\n    ) external view returns (bytes32 opPokeMessage);\\n\\n    /// @notice Returns the feed index of the feed last opPoke'd.\\n    /// @return opFeedIndex Feed index of the feed last opPoke'd.\\n    function opFeedIndex() external view returns (uint8 opFeedIndex);\\n\\n    /// @notice Returns the opChallengePeriod security parameter.\\n    /// @return opChallengePeriod The opChallengePeriod security parameter.\\n    function opChallengePeriod()\\n        external\\n        view\\n        returns (uint16 opChallengePeriod);\\n\\n    /// @notice Returns the maxChallengeRewards parameter.\\n    /// @return maxChallengeReward The maxChallengeReward parameter.\\n    function maxChallengeReward()\\n        external\\n        view\\n        returns (uint maxChallengeReward);\\n\\n    /// @notice Returns the ETH rewards being paid for successfully challenging\\n    ///         an opPoke.\\n    /// @return challengeReward The ETH reward for successfully challenging an\\n    ///                         opPoke.\\n    function challengeReward() external view returns (uint challengeReward);\\n\\n    /// @notice Updates the opChallengePeriod security parameter.\\n    /// @dev Only callable by auth'ed address.\\n    /// @dev Reverts if opChallengePeriod is zero.\\n    /// @dev Note that evaluating whether an opPoke is finalized happens via the\\n    ///      _current_ opChallengePeriod.\\n    ///      This means a finalized opPoke is dropped if opChallengePeriod is\\n    ///      decreased to a value less than opPoke's age.\\n    /// @param opChallengePeriod The value to update opChallengePeriod to.\\n    function setOpChallengePeriod(uint16 opChallengePeriod) external;\\n\\n    /// @notice Updates the maxChallengeReward parameter.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param maxChallengeReward The value to update maxChallengeReward to.\\n    function setMaxChallengeReward(uint maxChallengeReward) external;\\n}\\n\"\r\n    },\r\n    \"src/IScribe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {IChronicle} from \\\"chronicle-std/IChronicle.sol\\\";\\n\\nimport {LibSecp256k1} from \\\"./libs/LibSecp256k1.sol\\\";\\n\\ninterface IScribe is IChronicle {\\n    /// @dev PokeData encapsulates a value and its age.\\n    struct PokeData {\\n        uint128 val;\\n        uint32 age;\\n    }\\n\\n    /// @dev SchnorrData encapsulates a (aggregated) Schnorr signature.\\n    ///      Schnorr signatures are used to prove a PokeData's integrity.\\n    struct SchnorrData {\\n        bytes32 signature;\\n        address commitment;\\n        bytes signersBlob;\\n    }\\n\\n    /// @dev ECDSAData encapsulates an ECDSA signature.\\n    struct ECDSAData {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice Thrown if a poked value's age is not greater than the oracle's\\n    ///         current value's age.\\n    /// @param givenAge The poked value's age.\\n    /// @param currentAge The oracle's current value's age.\\n    error StaleMessage(uint32 givenAge, uint32 currentAge);\\n\\n    /// @notice Thrown if a poked value's age is greater than the current\\n    ///         time.\\n    /// @param givenAge The poked value's age.\\n    /// @param currentTimestamp The current time.\\n    error FutureMessage(uint32 givenAge, uint32 currentTimestamp);\\n\\n    /// @notice Thrown if Schnorr signature not signed by exactly bar many\\n    ///         signers.\\n    /// @param numberSigners The number of signers for given Schnorr signature.\\n    /// @param bar The bar security parameter.\\n    error BarNotReached(uint8 numberSigners, uint8 bar);\\n\\n    /// @notice Thrown if signature signed by non-feed.\\n    /// @param signer The signer's address not being a feed.\\n    error SignerNotFeed(address signer);\\n\\n    /// @notice Thrown if signer indexes are not encoded so that their\\n    ///         addresses are in ascending order.\\n    error SignersNotOrdered();\\n\\n    /// @notice Thrown if Schnorr signature verification failed.\\n    error SchnorrSignatureInvalid();\\n\\n    /// @notice Emitted when oracle was successfully poked.\\n    /// @param caller The caller's address.\\n    /// @param val The value poked.\\n    /// @param age The age of the value poked.\\n    event Poked(address indexed caller, uint128 val, uint32 age);\\n\\n    /// @notice Emitted when new feed lifted.\\n    /// @param caller The caller's address.\\n    /// @param feed The feed address lifted.\\n    /// @param index The feed's index identifier.\\n    event FeedLifted(\\n        address indexed caller, address indexed feed, uint indexed index\\n    );\\n\\n    /// @notice Emitted when feed dropped.\\n    /// @param caller The caller's address.\\n    /// @param feed The feed address dropped.\\n    /// @param index The feed's index identifier.\\n    event FeedDropped(\\n        address indexed caller, address indexed feed, uint indexed index\\n    );\\n\\n    /// @notice Emitted when bar updated.\\n    /// @param caller The caller's address.\\n    /// @param oldBar The old bar's value.\\n    /// @param newBar The new bar's value.\\n    event BarUpdated(address indexed caller, uint8 oldBar, uint8 newBar);\\n\\n    /// @notice Returns the feed registration message.\\n    /// @dev This message must be signed by a feed in order to be lifted.\\n    /// @return feedRegistrationMessage Chronicle Protocol's feed registration\\n    ///                                 message.\\n    function feedRegistrationMessage()\\n        external\\n        view\\n        returns (bytes32 feedRegistrationMessage);\\n\\n    /// @notice The maximum number of feed lifts supported.\\n    /// @dev Note that the constraint comes from feed's indexes being encoded as\\n    ///      uint8 in SchnorrData.signersBlob.\\n    /// @return maxFeeds The maximum number of feed lifts supported.\\n    function maxFeeds() external view returns (uint maxFeeds);\\n\\n    /// @notice Returns the bar security parameter.\\n    /// @return bar The bar security parameter.\\n    function bar() external view returns (uint8 bar);\\n\\n    /// @notice Returns the number of decimals of the oracle's value.\\n    /// @dev Provides partial compatibility with Chainlink's\\n    ///      IAggregatorV3Interface.\\n    /// @return decimals The oracle value's number of decimals.\\n    function decimals() external view returns (uint8 decimals);\\n\\n    /// @notice Returns the oracle's latest value.\\n    /// @dev Provides partial compatibility with Chainlink's\\n    ///      IAggregatorV3Interface.\\n    /// @return roundId 1.\\n    /// @return answer The oracle's latest value.\\n    /// @return startedAt 0.\\n    /// @return updatedAt The timestamp of oracle's latest update.\\n    /// @return answeredInRound 1.\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int answer,\\n            uint startedAt,\\n            uint updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    /// @notice Pokes the oracle.\\n    /// @dev Expects `pokeData`'s age to be greater than the timestamp of the\\n    ///      last successful poke.\\n    /// @dev Expects `schnorrData` to prove `pokeData`'s integrity.\\n    ///      See `isAcceptableSchnorrSignatureNow(bytes32,SchnorrData)(bool)`.\\n    /// @param pokeData The PokeData being poked.\\n    /// @param schnorrData The SchnorrData proving the `pokeData`'s\\n    ///                    integrity.\\n    function poke(PokeData calldata pokeData, SchnorrData calldata schnorrData)\\n        external;\\n\\n    /// @notice Returns whether the Schnorr signature `schnorrData` is\\n    ///         currently acceptable for message `message`.\\n    /// @dev Note that a valid Schnorr signature is only acceptable if the\\n    ///      signature was signed by exactly bar many feeds.\\n    ///      For more info, see `bar()(uint8)` and `feeds()(address[],uint[])`.\\n    /// @dev Note that bar and feeds are configurable, meaning a once acceptable\\n    ///      Schnorr signature may become unacceptable in the future.\\n    /// @param message The message expected to be signed via `schnorrData`.\\n    /// @param schnorrData The SchnorrData to verify whether it proves\\n    ///                    the `message`'s integrity.\\n    /// @return ok True if Schnorr signature is acceptable, false otherwise.\\n    function isAcceptableSchnorrSignatureNow(\\n        bytes32 message,\\n        SchnorrData calldata schnorrData\\n    ) external view returns (bool ok);\\n\\n    /// @notice Returns the message expected to be signed via Schnorr for\\n    ///         `pokeData`.\\n    /// @dev The message is defined as:\\n    ///         H(tag \u2016 H(wat \u2016 pokeData)), where H() is the keccak256 function.\\n    /// @param pokeData The pokeData to create the message for.\\n    /// @return Message for `pokeData`.\\n    function constructPokeMessage(PokeData calldata pokeData)\\n        external\\n        view\\n        returns (bytes32);\\n\\n    /// @notice Returns whether address `who` is a feed and its feed index\\n    ///         identifier.\\n    /// @param who The address to check.\\n    /// @return isFeed True if `who` is feed, false otherwise.\\n    /// @return feedIndex Non-zero if `who` is feed, zero otherwise.\\n    function feeds(address who)\\n        external\\n        view\\n        returns (bool isFeed, uint feedIndex);\\n\\n    /// @notice Returns whether feedIndex `index` maps to a feed and, if so,\\n    ///         the feed's address.\\n    /// @param index The feedIndex to check.\\n    /// @return isFeed True if `index` maps to a feed, false otherwise.\\n    /// @return feed Address of the feed with feedIndex `index` if `index` maps\\n    ///              to feed, zero-address otherwise.\\n    function feeds(uint index)\\n        external\\n        view\\n        returns (bool isFeed, address feed);\\n\\n    /// @notice Returns list of feed addresses and their index identifiers.\\n    /// @return feeds List of feed addresses.\\n    /// @return feedIndexes List of feed's indexes.\\n    function feeds()\\n        external\\n        view\\n        returns (address[] memory feeds, uint[] memory feedIndexes);\\n\\n    /// @notice Lifts public key `pubKey` to being a feed.\\n    /// @dev Only callable by auth'ed address.\\n    /// @dev The message expected to be signed by `ecdsaData` is defined as via\\n    ///      `feedRegistrationMessage()(bytes32)` function.\\n    /// @param pubKey The public key of the feed.\\n    /// @param ecdsaData ECDSA signed message by the feed's public key.\\n    /// @return The feed index of the newly lifted feed.\\n    function lift(LibSecp256k1.Point memory pubKey, ECDSAData memory ecdsaData)\\n        external\\n        returns (uint);\\n\\n    /// @notice Lifts public keys `pubKeys` to being feeds.\\n    /// @dev Only callable by auth'ed address.\\n    /// @dev The message expected to be signed by `ecdsaDatas` is defined as via\\n    ///      `feedRegistrationMessage()(bytes32)` function.\\n    /// @param pubKeys The public keys of the feeds.\\n    /// @param ecdsaDatas ECDSA signed message by the feeds' public keys.\\n    /// @return List of feed indexes of the newly lifted feeds.\\n    function lift(\\n        LibSecp256k1.Point[] memory pubKeys,\\n        ECDSAData[] memory ecdsaDatas\\n    ) external returns (uint[] memory);\\n\\n    /// @notice Drops feed with index `feedIndex` from being a feed.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param feedIndex The feed index identifier of the feed to drop.\\n    function drop(uint feedIndex) external;\\n\\n    /// @notice Drops feeds with indexes `feedIndexes` from being feeds.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param feedIndexes The feed's index identifiers of the feeds to drop.\\n    function drop(uint[] memory feedIndexes) external;\\n\\n    /// @notice Updates the bar security parameters to `bar`.\\n    /// @dev Only callable by auth'ed address.\\n    /// @dev Reverts if `bar` is zero.\\n    /// @param bar The value to update bar to.\\n    function setBar(uint8 bar) external;\\n\\n    /// @notice Returns the oracle's current value.\\n    /// @custom:deprecated Use `tryRead()(bool,uint)` instead.\\n    /// @return value The oracle's current value if it exists, zero otherwise.\\n    /// @return isValid True if value exists, false otherwise.\\n    function peek() external view returns (uint value, bool isValid);\\n\\n    /// @notice Returns the oracle's current value.\\n    /// @custom:deprecated Use `tryRead()(bool,uint)` instead.\\n    /// @return value The oracle's current value if it exists, zero otherwise.\\n    /// @return isValid True if value exists, false otherwise.\\n    function peep() external view returns (uint value, bool isValid);\\n}\\n\"\r\n    },\r\n    \"src/Scribe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.16;\\n\\nimport {IChronicle} from \\\"chronicle-std/IChronicle.sol\\\";\\nimport {Auth} from \\\"chronicle-std/auth/Auth.sol\\\";\\nimport {Toll} from \\\"chronicle-std/toll/Toll.sol\\\";\\n\\nimport {IScribe} from \\\"./IScribe.sol\\\";\\n\\nimport {LibSchnorr} from \\\"./libs/LibSchnorr.sol\\\";\\nimport {LibSecp256k1} from \\\"./libs/LibSecp256k1.sol\\\";\\nimport {LibSchnorrData} from \\\"./libs/LibSchnorrData.sol\\\";\\n\\n/**\\n * @title Scribe\\n * @custom:version 1.1.0\\n *\\n * @notice Efficient Schnorr multi-signature based Oracle\\n */\\ncontract Scribe is IScribe, Auth, Toll {\\n    using LibSchnorr for LibSecp256k1.Point;\\n    using LibSecp256k1 for LibSecp256k1.Point;\\n    using LibSecp256k1 for LibSecp256k1.JacobianPoint;\\n    using LibSchnorrData for SchnorrData;\\n\\n    /// @inheritdoc IScribe\\n    uint public constant maxFeeds = type(uint8).max - 1;\\n\\n    /// @inheritdoc IScribe\\n    uint8 public constant decimals = 18;\\n\\n    /// @inheritdoc IScribe\\n    bytes32 public constant feedRegistrationMessage = keccak256(\\n        abi.encodePacked(\\n            \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n            keccak256(\\\"Chronicle Feed Registration\\\")\\n        )\\n    );\\n\\n    /// @inheritdoc IChronicle\\n    bytes32 public immutable wat;\\n\\n    /// @dev The storage slot of _pubKeys[0].\\n    uint internal immutable SLOT_pubKeys;\\n\\n    // -- Storage --\\n\\n    /// @dev Scribe's current value and corresponding age.\\n    PokeData internal _pokeData;\\n\\n    /// @dev List of feeds' public keys.\\n    LibSecp256k1.Point[] internal _pubKeys;\\n\\n    /// @dev Mapping of feeds' addresses to their public key indexes in\\n    ///      _pubKeys.\\n    mapping(address => uint) internal _feeds;\\n\\n    /// @inheritdoc IScribe\\n    /// @dev Note to have as last in storage to enable downstream contracts to\\n    ///      pack the slot.\\n    uint8 public bar;\\n\\n    // -- Constructor --\\n\\n    constructor(address initialAuthed, bytes32 wat_) Auth(initialAuthed) {\\n        require(wat_ != 0);\\n\\n        // Set wat immutable.\\n        wat = wat_;\\n\\n        // Let initial bar be 2.\\n        _setBar(2);\\n\\n        // Let _pubKeys[0] be the zero point.\\n        _pubKeys.push(LibSecp256k1.ZERO_POINT());\\n\\n        // Let SLOT_pubKeys be _pubKeys[0].slot.\\n        uint pubKeysSlot;\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, _pubKeys.slot)\\n            pubKeysSlot := keccak256(0x00, 0x20)\\n        }\\n        SLOT_pubKeys = pubKeysSlot;\\n    }\\n\\n    // -- Poke Functionality --\\n\\n    /// @dev Optimized function selector: 0x00000082.\\n    ///      Note that this function is _not_ defined via the IScribe interface\\n    ///      and one should _not_ depend on it.\\n    function poke_optimized_7136211(\\n        PokeData calldata pokeData,\\n        SchnorrData calldata schnorrData\\n    ) external {\\n        _poke(pokeData, schnorrData);\\n    }\\n\\n    /// @inheritdoc IScribe\\n    function poke(PokeData calldata pokeData, SchnorrData calldata schnorrData)\\n        external\\n    {\\n        _poke(pokeData, schnorrData);\\n    }\\n\\n    function _poke(PokeData calldata pokeData, SchnorrData calldata schnorrData)\\n        internal\\n        virtual\\n    {\\n        // Revert if pokeData stale.\\n        if (pokeData.age <= _pokeData.age) {\\n            revert StaleMessage(pokeData.age, _pokeData.age);\\n        }\\n        // Revert if pokeData from the future.\\n        if (pokeData.age > uint32(block.timestamp)) {\\n            revert FutureMessage(pokeData.age, uint32(block.timestamp));\\n        }\\n\\n        // Revert if schnorrData does not prove integrity of pokeData.\\n        bool ok;\\n        bytes memory err;\\n        // forgefmt: disable-next-item\\n        (ok, err) = _verifySchnorrSignature(\\n            constructPokeMessage(pokeData),\\n            schnorrData\\n        );\\n        if (!ok) {\\n            _revert(err);\\n        }\\n\\n        // Store pokeData's val in _pokeData storage and set its age to now.\\n        _pokeData.val = pokeData.val;\\n        _pokeData.age = uint32(block.timestamp);\\n\\n        emit Poked(msg.sender, pokeData.val, pokeData.age);\\n    }\\n\\n    /// @inheritdoc IScribe\\n    function constructPokeMessage(PokeData memory pokeData)\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(abi.encodePacked(wat, pokeData.val, pokeData.age))\\n            )\\n        );\\n    }\\n\\n    // -- Schnorr Signature Verification --\\n\\n    /// @inheritdoc IScribe\\n    function isAcceptableSchnorrSignatureNow(\\n        bytes32 message,\\n        SchnorrData calldata schnorrData\\n    ) external view returns (bool) {\\n        bool ok;\\n        (ok, /*err*/ ) = _verifySchnorrSignature(message, schnorrData);\\n\\n        return ok;\\n    }\\n\\n    /// @custom:invariant Reverts iff out of gas.\\n    /// @custom:invariant Runtime is \u0398(bar).\\n    function _verifySchnorrSignature(\\n        bytes32 message,\\n        SchnorrData calldata schnorrData\\n    ) internal view returns (bool, bytes memory) {\\n        // Let signerIndex be the current signer's index read from schnorrData.\\n        uint signerIndex;\\n        // Let signerPubKey be the public key stored for signerIndex.\\n        LibSecp256k1.Point memory signerPubKey;\\n        // Let signer be the address of signerPubKey.\\n        address signer;\\n        // Let lastSigner be the previous processed signer.\\n        address lastSigner;\\n        // Let aggPubKey be the sum of processed signers' public keys.\\n        // Note that Jacobian coordinates are used.\\n        LibSecp256k1.JacobianPoint memory aggPubKey;\\n\\n        // Fail if number signers unequal to bar.\\n        //\\n        // Note that requiring equality constrains the verification's runtime\\n        // from \u03a9(bar) to \u0398(bar).\\n        uint numberSigners = schnorrData.getSignerIndexLength();\\n        if (numberSigners != bar) {\\n            return (false, _errorBarNotReached(uint8(numberSigners), bar));\\n        }\\n\\n        // Initiate signer variables with schnorrData's 0's signer index.\\n        signerIndex = schnorrData.getSignerIndex(0);\\n        signerPubKey = _unsafeLoadPubKeyAt(signerIndex);\\n        signer = signerPubKey.toAddress();\\n\\n        // Fail if signer not feed.\\n        if (signerPubKey.isZeroPoint()) {\\n            return (false, _errorSignerNotFeed(signer));\\n        }\\n\\n        // Initiate aggPubKey with value of first signerPubKey.\\n        aggPubKey = signerPubKey.toJacobian();\\n\\n        // Aggregate remaining encoded signers.\\n        for (uint i = 1; i < bar;) {\\n            // Update Signer Variables.\\n            lastSigner = signer;\\n            signerIndex = schnorrData.getSignerIndex(i);\\n            signerPubKey = _unsafeLoadPubKeyAt(signerIndex);\\n            signer = signerPubKey.toAddress();\\n\\n            // Fail if signer not feed.\\n            if (signerPubKey.isZeroPoint()) {\\n                return (false, _errorSignerNotFeed(signer));\\n            }\\n\\n            // Fail if signers not strictly monotonically increasing.\\n            //\\n            // Note that this prevents double signing attacks and enforces\\n            // strict ordering.\\n            if (uint160(lastSigner) >= uint160(signer)) {\\n                return (false, _errorSignersNotOrdered());\\n            }\\n\\n            // assert(aggPubKey.x != signerPubKey.x); // Indicates rogue-key attack\\n\\n            // Add signerPubKey to already aggregated public keys.\\n            aggPubKey.addAffinePoint(signerPubKey);\\n\\n            // forgefmt: disable-next-item\\n            unchecked { ++i; }\\n        }\\n\\n        // Fail if signature verification fails.\\n        bool ok = aggPubKey.toAffine().verifySignature(\\n            message, schnorrData.signature, schnorrData.commitment\\n        );\\n        if (!ok) {\\n            return (false, _errorSchnorrSignatureInvalid());\\n        }\\n\\n        // Otherwise Schnorr signature is valid.\\n        return (true, new bytes(0));\\n    }\\n\\n    // -- Toll'ed Read Functionality --\\n\\n    // - IChronicle Functions\\n\\n    /// @inheritdoc IChronicle\\n    /// @dev Only callable by toll'ed address.\\n    function read() external view virtual toll returns (uint) {\\n        uint val = _pokeData.val;\\n        require(val != 0);\\n        return val;\\n    }\\n\\n    /// @inheritdoc IChronicle\\n    /// @dev Only callable by toll'ed address.\\n    function tryRead() external view virtual toll returns (bool, uint) {\\n        uint val = _pokeData.val;\\n        return (val != 0, val);\\n    }\\n\\n    /// @inheritdoc IChronicle\\n    /// @dev Only callable by toll'ed address.\\n    function readWithAge() external view virtual toll returns (uint, uint) {\\n        uint val = _pokeData.val;\\n        uint age = _pokeData.age;\\n        require(val != 0);\\n        return (val, age);\\n    }\\n\\n    /// @inheritdoc IChronicle\\n    /// @dev Only callable by toll'ed address.\\n    function tryReadWithAge()\\n        external\\n        view\\n        virtual\\n        toll\\n        returns (bool, uint, uint)\\n    {\\n        uint val = _pokeData.val;\\n        uint age = _pokeData.age;\\n        return (val != 0, val, age);\\n    }\\n\\n    // - MakerDAO Compatibility\\n\\n    /// @inheritdoc IScribe\\n    /// @dev Only callable by toll'ed address.\\n    function peek() external view virtual toll returns (uint, bool) {\\n        uint val = _pokeData.val;\\n        return (val, val != 0);\\n    }\\n\\n    /// @inheritdoc IScribe\\n    /// @dev Only callable by toll'ed address.\\n    function peep() external view virtual toll returns (uint, bool) {\\n        uint val = _pokeData.val;\\n        return (val, val != 0);\\n    }\\n\\n    // - Chainlink Compatibility\\n\\n    /// @inheritdoc IScribe\\n    /// @dev Only callable by toll'ed address.\\n    function latestRoundData()\\n        external\\n        view\\n        virtual\\n        toll\\n        returns (\\n            uint80 roundId,\\n            int answer,\\n            uint startedAt,\\n            uint updatedAt,\\n            uint80 answeredInRound\\n        )\\n    {\\n        roundId = 1;\\n        answer = int(uint(_pokeData.val));\\n        // assert(uint(answer) == uint(_pokeData.val));\\n        startedAt = 0;\\n        updatedAt = _pokeData.age;\\n        answeredInRound = roundId;\\n    }\\n\\n    // -- Public Read Functionality --\\n\\n    /// @inheritdoc IScribe\\n    function feeds(address who) external view returns (bool, uint) {\\n        uint index = _feeds[who];\\n        // assert(index != 0 ? !_pubKeys[index].isZeroPoint() : true);\\n        return (index != 0, index);\\n    }\\n\\n    /// @inheritdoc IScribe\\n    function feeds(uint index) external view returns (bool, address) {\\n        if (index >= _pubKeys.length) {\\n            return (false, address(0));\\n        }\\n\\n        LibSecp256k1.Point memory pubKey = _pubKeys[index];\\n        if (pubKey.isZeroPoint()) {\\n            return (false, address(0));\\n        }\\n\\n        return (true, pubKey.toAddress());\\n    }\\n\\n    /// @inheritdoc IScribe\\n    function feeds() external view returns (address[] memory, uint[] memory) {\\n        // Initiate arrays with upper limit length.\\n        uint upperLimitLength = _pubKeys.length;\\n        address[] memory feedsList = new address[](upperLimitLength);\\n        uint[] memory feedsIndexesList = new uint[](upperLimitLength);\\n\\n        // Iterate over feeds' public keys. If a public key is non-zero, their\\n        // corresponding address is a feed.\\n        uint ctr;\\n        LibSecp256k1.Point memory pubKey;\\n        address feed;\\n        uint feedIndex;\\n        for (uint i; i < upperLimitLength;) {\\n            pubKey = _pubKeys[i];\\n\\n            if (!pubKey.isZeroPoint()) {\\n                feed = pubKey.toAddress();\\n                // assert(feed != address(0));\\n\\n                feedIndex = _feeds[feed];\\n                // assert(feedIndex != 0);\\n\\n                feedsList[ctr] = feed;\\n                feedsIndexesList[ctr] = feedIndex;\\n\\n                ctr++;\\n            }\\n\\n            // forgefmt: disable-next-item\\n            unchecked { ++i; }\\n        }\\n\\n        // Set length of arrays to number of feeds actually included.\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(feedsList, ctr)\\n            mstore(feedsIndexesList, ctr)\\n        }\\n\\n        return (feedsList, feedsIndexesList);\\n    }\\n\\n    // -- Auth'ed Functionality --\\n\\n    /// @inheritdoc IScribe\\n    function lift(LibSecp256k1.Point memory pubKey, ECDSAData memory ecdsaData)\\n        external\\n        auth\\n        returns (uint)\\n    {\\n        return _lift(pubKey, ecdsaData);\\n    }\\n\\n    /// @inheritdoc IScribe\\n    function lift(\\n        LibSecp256k1.Point[] memory pubKeys,\\n        ECDSAData[] memory ecdsaDatas\\n    ) external auth returns (uint[] memory) {\\n        require(pubKeys.length == ecdsaDatas.length);\\n\\n        uint[] memory indexes = new uint[](pubKeys.length);\\n        for (uint i; i < pubKeys.length;) {\\n            indexes[i] = _lift(pubKeys[i], ecdsaDatas[i]);\\n\\n            // forgefmt: disable-next-item\\n            unchecked { ++i; }\\n        }\\n\\n        // Note that indexes contains duplicates iff duplicate pubKeys provided.\\n        return indexes;\\n    }\\n\\n    function _lift(LibSecp256k1.Point memory pubKey, ECDSAData memory ecdsaData)\\n        internal\\n        returns (uint)\\n    {\\n        address feed = pubKey.toAddress();\\n        // assert(feed != address(0));\\n\\n        // forgefmt: disable-next-item\\n        address recovered = ecrecover(\\n            feedRegistrationMessage,\\n            ecdsaData.v,\\n            ecdsaData.r,\\n            ecdsaData.s\\n        );\\n        require(feed == recovered);\\n\\n        uint index = _feeds[feed];\\n        if (index == 0) {\\n            _pubKeys.push(pubKey);\\n            index = _pubKeys.length - 1;\\n            _feeds[feed] = index;\\n\\n            emit FeedLifted(msg.sender, feed, index);\\n\\n            require(index <= maxFeeds);\\n        }\\n\\n        return index;\\n    }\\n\\n    /// @inheritdoc IScribe\\n    function drop(uint feedIndex) external auth {\\n        _drop(msg.sender, feedIndex);\\n    }\\n\\n    /// @inheritdoc IScribe\\n    function drop(uint[] memory feedIndexes) external auth {\\n        for (uint i; i < feedIndexes.length;) {\\n            _drop(msg.sender, feedIndexes[i]);\\n\\n            // forgefmt: disable-next-item\\n            unchecked { ++i; }\\n        }\\n    }\\n\\n    function _drop(address caller, uint feedIndex) internal virtual {\\n        require(feedIndex < _pubKeys.length);\\n        address feed = _pubKeys[feedIndex].toAddress();\\n\\n        if (_feeds[feed] != 0) {\\n            emit FeedDropped(caller, feed, _feeds[feed]);\\n\\n            _feeds[feed] = 0;\\n            _pubKeys[feedIndex] = LibSecp256k1.ZERO_POINT();\\n        }\\n    }\\n\\n    /// @inheritdoc IScribe\\n    function setBar(uint8 bar_) external auth {\\n        _setBar(bar_);\\n    }\\n\\n    function _setBar(uint8 bar_) internal virtual {\\n        require(bar_ != 0);\\n\\n        if (bar != bar_) {\\n            emit BarUpdated(msg.sender, bar, bar_);\\n            bar = bar_;\\n        }\\n    }\\n\\n    // -- Internal Helpers --\\n\\n    /// @dev Halts execution by reverting with `err`.\\n    function _revert(bytes memory err) internal pure {\\n        // assert(err.length != 0);\\n        assembly (\\\"memory-safe\\\") {\\n            let size := mload(err)\\n            let offset := add(err, 0x20)\\n            revert(offset, size)\\n        }\\n    }\\n\\n    /// @dev Returns the public key at `_pubKeys[index]`, or zero point if\\n    ///      `index` out of bounds.\\n    function _unsafeLoadPubKeyAt(uint index)\\n        internal\\n        view\\n        returns (LibSecp256k1.Point memory)\\n    {\\n        // Push immutable to stack as accessing through assembly not supported.\\n        uint slotPubKeys = SLOT_pubKeys;\\n\\n        LibSecp256k1.Point memory pubKey;\\n        assembly (\\\"memory-safe\\\") {\\n            // Note that a pubKey consists of two words.\\n            let realIndex := mul(index, 2)\\n\\n            // Compute slot of _pubKeys[index].\\n            let slot := add(slotPubKeys, realIndex)\\n\\n            // Load _pubKeys[index]'s coordinates to stack.\\n            let x := sload(slot)\\n            let y := sload(add(slot, 1))\\n\\n            // Store coordinates in pubKey memory location.\\n            mstore(pubKey, x)\\n            mstore(add(pubKey, 0x20), y)\\n        }\\n        // assert(index < _pubKeys.length || pubKey.isZeroPoint());\\n\\n        // Note that pubKey is zero if index out of bounds.\\n        return pubKey;\\n    }\\n\\n    function _errorBarNotReached(uint8 got, uint8 want)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        // assert(got != want);\\n        return abi.encodeWithSelector(IScribe.BarNotReached.selector, got, want);\\n    }\\n\\n    function _errorSignerNotFeed(address signer)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        // assert(_feeds[signer] == 0);\\n        return abi.encodeWithSelector(IScribe.SignerNotFeed.selector, signer);\\n    }\\n\\n    function _errorSignersNotOrdered() internal pure returns (bytes memory) {\\n        return abi.encodeWithSelector(IScribe.SignersNotOrdered.selector);\\n    }\\n\\n    function _errorSchnorrSignatureInvalid()\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encodeWithSelector(IScribe.SchnorrSignatureInvalid.selector);\\n    }\\n\\n    // -- Overridden Toll Functions --\\n\\n    /// @dev Defines authorization for IToll's authenticated functions.\\n    function toll_auth() internal override(Toll) auth {}\\n}\\n\\n/**\\n * @dev Contract overwrite to deploy contract instances with specific naming.\\n *\\n *      For more info, see docs/Deployment.md.\\n */\\ncontract Chronicle_BASE_QUOTE_COUNTER is Scribe {\\n    // @todo       ^^^^ ^^^^^ ^^^^^^^ Adjust name of Scribe instance.\\n    constructor(address initialAuthed, bytes32 wat_)\\n        Scribe(initialAuthed, wat_)\\n    {}\\n}\\n\"\r\n    },\r\n    \"src/libs/LibSchnorr.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {LibSecp256k1} from \\\"./LibSecp256k1.sol\\\";\\n\\n/**\\n * @title LibSchnorr\\n *\\n * @notice Custom-purpose library for Schnorr signature verification on the\\n *         secp256k1 curve\\n */\\nlibrary LibSchnorr {\\n    using LibSecp256k1 for LibSecp256k1.Point;\\n\\n    /// @dev Returns whether `signature` and `commitment` sign via `pubKey`\\n    ///      message `message`.\\n    ///\\n    /// @custom:invariant Reverts iff out of gas.\\n    /// @custom:invariant Uses constant amount of gas.\\n    function verifySignature(\\n        LibSecp256k1.Point memory pubKey,\\n        bytes32 message,\\n        bytes32 signature,\\n        address commitment\\n    ) internal pure returns (bool) {\\n        // Return false if signature or commitment is zero.\\n        if (signature == 0 || commitment == address(0)) {\\n            return false;\\n        }\\n\\n        // Note to enforce pubKey is valid secp256k1 point.\\n        //\\n        // While the Scribe contract ensures to only verify signatures for valid\\n        // public keys, this check is enabled as an additional defense\\n        // mechanism.\\n        if (!pubKey.isOnCurve()) {\\n            return false;\\n        }\\n\\n        // Note to enforce signature is less than Q to prevent signature\\n        // malleability.\\n        //\\n        // While the Scribe contract only accepts messages with strictly\\n        // monotonically increasing timestamps, circumventing replay attack\\n        // vectors and therefore also signature malleability issues at a higher\\n        // level, this check is enabled as an additional defense mechanism.\\n        if (uint(signature) >= LibSecp256k1.Q()) {\\n            return false;\\n        }\\n\\n        // Construct challenge = H(P\u2093 \u2016 P\u209a \u2016 m \u2016 R\u2091) mod Q\\n        uint challenge = uint(\\n            keccak256(\\n                abi.encodePacked(\\n                    pubKey.x, uint8(pubKey.yParity()), message, commitment\\n                )\\n            )\\n        ) % LibSecp256k1.Q();\\n\\n        // Compute msgHash = -sig * P\u2093      (mod Q)\\n        //                 = Q - (sig * P\u2093) (mod Q)\\n        //\\n        // Unchecked because the only protected operation performed is the\\n        // subtraction from Q where the subtrahend is the result of a (mod Q)\\n        // computation, i.e. the subtrahend is guaranteed to be less than Q.\\n        uint msgHash;\\n        unchecked {\\n            msgHash = LibSecp256k1.Q()\\n                - mulmod(uint(signature), pubKey.x, LibSecp256k1.Q());\\n        }\\n\\n        // Compute v = P\u209a + 27\\n        //\\n        // Unchecked because pubKey.yParity() \u220a {0, 1} which cannot overflow\\n        // by adding 27.\\n        uint v;\\n        unchecked {\\n            v = pubKey.yParity() + 27;\\n        }\\n\\n        // Set r = P\u2093\\n        uint r = pubKey.x;\\n\\n        // Compute s = Q - (e * P\u2093) (mod Q)\\n        //\\n        // Unchecked because the only protected operation performed is the\\n        // subtraction from Q where the subtrahend is the result of a (mod Q)\\n        // computation, i.e. the subtrahend is guaranteed to be less than Q.\\n        uint s;\\n        unchecked {\\n            s = LibSecp256k1.Q() - mulmod(challenge, pubKey.x, LibSecp256k1.Q());\\n        }\\n\\n        // Compute ([s]G - [e]P)\u2091 via ecrecover.\\n        address recovered =\\n            ecrecover(bytes32(msgHash), uint8(v), bytes32(r), bytes32(s));\\n\\n        // Verification succeeds iff ([s]G - [e]P)\u2091 = R\u2091.\\n        //\\n        // Note that commitment is guaranteed to not be zero.\\n        return commitment == recovered;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libs/LibSecp256k1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n * @title LibSecp256k1\\n *\\n * @notice Library for secp256k1 elliptic curve computations\\n *\\n * @dev This library was developed to efficiently compute aggregated public\\n *      keys for Schnorr signatures based on secp256k1, i.e. it is _not_ a\\n *      general purpose elliptic curve library!\\n *\\n *      References to the Ethereum Yellow Paper are based on the following\\n *      version: \\\"BERLIN VERSION beacfbd \u2013 2022-10-24\\\".\\n */\\nlibrary LibSecp256k1 {\\n    using LibSecp256k1 for LibSecp256k1.Point;\\n    using LibSecp256k1 for LibSecp256k1.JacobianPoint;\\n\\n    uint private constant ADDRESS_MASK =\\n        0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    // -- Secp256k1 Constants --\\n    //\\n    // Taken from https://www.secg.org/sec2-v2.pdf.\\n    // See section 2.4.1 \\\"Recommended Parameters secp256k1\\\".\\n\\n    uint private constant _A = 0;\\n    uint private constant _B = 7;\\n    uint private constant _P =\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\\n\\n    /// @dev Returns the order of the group.\\n    function Q() internal pure returns (uint) {\\n        return\\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\\n    }\\n\\n    /// @dev Returns the generator G.\\n    ///      Note that the generator is also called base point.\\n    function G() internal pure returns (Point memory) {\\n        return Point({\\n            x: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,\\n            y: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\\n        });\\n    }\\n\\n    /// @dev Returns the zero point.\\n    function ZERO_POINT() internal pure returns (Point memory) {\\n        return Point({x: 0, y: 0});\\n    }\\n\\n    // -- (Affine) Point --\\n\\n    /// @dev Point encapsulates a secp256k1 point in Affine coordinates.\\n    struct Point {\\n        uint x;\\n        uint y;\\n    }\\n\\n    /// @dev Returns the Ethereum address of `self`.\\n    ///\\n    /// @dev An Ethereum address is defined as the rightmost 160 bits of the\\n    ///      keccak256 hash of the concatenation of the hex-encoded x and y\\n    ///      coordinates of the corresponding ECDSA public key.\\n    ///      See \\\"Appendix F: Signing Transactions\\\" \u00a7134 in the Yellow Paper.\\n    function toAddress(Point memory self) internal pure returns (address) {\\n        address addr;\\n        // Functionally equivalent Solidity code:\\n        // addr = address(uint160(uint(keccak256(abi.encode(self.x, self.y)))));\\n        assembly (\\\"memory-safe\\\") {\\n            addr := and(keccak256(self, 0x40), ADDRESS_MASK)\\n        }\\n        return addr;\\n    }\\n\\n    /// @dev Returns Affine point `self` in Jacobian coordinates.\\n    function toJacobian(Point memory self)\\n        internal\\n        pure\\n        returns (JacobianPoint memory)\\n    {\\n        return JacobianPoint({x: self.x, y: self.y, z: 1});\\n    }\\n\\n    /// @dev Returns whether `self` is the zero point.\\n    function isZeroPoint(Point memory self) internal pure returns (bool) {\\n        return (self.x | self.y) == 0;\\n    }\\n\\n    /// @dev Returns whether `self` is a point on the curve.\\n    ///\\n    /// @dev The secp256k1 curve is specified as y\u00b2 \u2261 x\u00b3 + ax + b (mod P)\\n    ///      where:\\n    ///         a = 0\\n    ///         b = 7\\n    function isOnCurve(Point memory self) internal pure returns (bool) {\\n        uint left = mulmod(self.y, self.y, _P);\\n        // Note that adding a * x can be waived as \u2200x: a * x = 0.\\n        uint right =\\n            addmod(mulmod(self.x, mulmod(self.x, self.x, _P), _P), _B, _P);\\n\\n        return left == right;\\n    }\\n\\n    /// @dev Returns the parity of `self`'s y coordinate.\\n    ///\\n    /// @dev The value 0 represents an even y value and 1 represents an odd y\\n    ///      value.\\n    ///      See \\\"Appendix F: Signing Transactions\\\" in the Yellow Paper.\\n    function yParity(Point memory self) internal pure returns (uint) {\\n        return self.y & 1;\\n    }\\n\\n    // -- Jacobian Point --\\n\\n    /// @dev JacobianPoint encapsulates a secp256k1 point in Jacobian\\n    ///      coordinates.\\n    struct JacobianPoint {\\n        uint x;\\n        uint y;\\n        uint z;\\n    }\\n\\n    /// @dev Returns Jacobian point `self` in Affine coordinates.\\n    ///\\n    /// @custom:invariant Reverts iff out of gas.\\n    /// @custom:invariant Does not run into an infinite loop.\\n    function toAffine(JacobianPoint memory self)\\n        internal\\n        pure\\n        returns (Point memory)\\n    {\\n        Point memory result;\\n\\n        // Compute z\u207b\u00b9, i.e. the modular inverse of self.z.\\n        uint zInv = _invMod(self.z);\\n\\n        // Compute (z\u207b\u00b9)\u00b2 (mod P)\\n        uint zInv_2 = mulmod(zInv, zInv, _P);\\n\\n        // Compute self.x * (z\u207b\u00b9)\u00b2 (mod P), i.e. the x coordinate of given\\n        // Jacobian point in Affine representation.\\n        result.x = mulmod(self.x, zInv_2, _P);\\n\\n        // Compute self.y * (z\u207b\u00b9)\u00b3 (mod P), i.e. the y coordinate of given\\n        // Jacobian point in Affine representation.\\n        result.y = mulmod(self.y, mulmod(zInv, zInv_2, _P), _P);\\n\\n        return result;\\n    }\\n\\n    /// @dev Adds Affine point `p` to Jacobian point `self`.\\n    ///\\n    ///      It is the caller's responsibility to ensure given points are on the\\n    ///      curve!\\n    ///\\n    ///      Computation based on: https://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-madd-2007-bl.\\n    ///\\n    ///      Note that the formula assumes z2 = 1, which always holds if z2's\\n    ///      point is given in Affine coordinates.\\n    ///\\n    ///      Note that eventhough the function is marked as pure, to be\\n    ///      understood as only being dependent on the input arguments, it\\n    ///      nevertheless has side effects by writing the result into the\\n    ///      `self` memory variable.\\n    ///\\n    /// @custom:invariant Only mutates `self` memory variable.\\n    /// @custom:invariant Reverts iff out of gas.\\n    /// @custom:invariant Uses constant amount of gas.\\n    function addAffinePoint(JacobianPoint memory self, Point memory p)\\n        internal\\n        pure\\n    {\\n        // Addition formula:\\n        //      x = r\u00b2 - j - (2 * v)             (mod P)\\n        //      y = (r * (v - x)) - (2 * y1 * j) (mod P)\\n        //      z = (z1 + h)\u00b2 - z1\u00b2 - h\u00b2         (mod P)\\n        //\\n        // where:\\n        //      r = 2 * (s - y1) (mod P)\\n        //      j = h * i        (mod P)\\n        //      v = x1 * i       (mod P)\\n        //      h = u - x1       (mod P)\\n        //      s = y2 * z1\u00b3     (mod P)       Called s2 in reference\\n        //      i = 4 * h\u00b2       (mod P)\\n        //      u = x2 * z1\u00b2     (mod P)       Called u2 in reference\\n        //\\n        // and:\\n        //      x1 = self.x\\n        //      y1 = self.y\\n        //      z1 = self.z\\n        //      x2 = p.x\\n        //      y2 = p.y\\n        //\\n        // Note that in order to save memory allocations the result is stored\\n        // in the self variable, i.e. the following holds true after the\\n        // functions execution:\\n        //      x = self.x\\n        //      y = self.y\\n        //      z = self.z\\n\\n        // Cache self's coordinates on stack.\\n        uint x1 = self.x;\\n        uint y1 = self.y;\\n        uint z1 = self.z;\\n\\n        // Compute z1_2 = z1\u00b2     (mod P)\\n        //              = z1 * z1 (mod P)\\n        uint z1_2 = mulmod(z1, z1, _P);\\n\\n        // Compute h = u        - x1       (mod P)\\n        //           = u        + (P - x1) (mod P)\\n        //           = x2 * z1\u00b2 + (P - x1) (mod P)\\n        //\\n        // Unchecked because the only protected operation performed is P - x1\\n        // where x1 is guaranteed by the caller to be an x coordinate belonging\\n        // to a point on the curve, i.e. being less than P.\\n        uint h;\\n        unchecked {\\n            h = addmod(mulmod(p.x, z1_2, _P), _P - x1, _P);\\n        }\\n\\n        // Compute h_2 = h\u00b2    (mod P)\\n        //             = h * h (mod P)\\n        uint h_2 = mulmod(h, h, _P);\\n\\n        // Compute i = 4 * h\u00b2 (mod P)\\n        uint i = mulmod(4, h_2, _P);\\n\\n        // Compute z = (z1 + h)\u00b2 - z1\u00b2       - h\u00b2       (mod P)\\n        //           = (z1 + h)\u00b2 - z1\u00b2       + (P - h\u00b2) (mod P)\\n        //           = (z1 + h)\u00b2 + (P - z1\u00b2) + (P - h\u00b2) (mod P)\\n        //             \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f   \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f   \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u256f\\n        //               left         mid       right\\n        //\\n        // Unchecked because the only protected operations performed are\\n        // subtractions from P where the subtrahend is the result of a (mod P)\\n        // computation, i.e. the subtrahend being guaranteed to be less than P.\\n        unchecked {\\n            uint left = mulmod(addmod(z1, h, _P), addmod(z1, h, _P), _P);\\n            uint mid = _P - z1_2;\\n            uint right = _P - h_2;\\n\\n            self.z = addmod(left, addmod(mid, right, _P), _P);\\n        }\\n\\n        // Compute v = x1 * i (mod P)\\n        uint v = mulmod(x1, i, _P);\\n\\n        // Compute j = h * i (mod P)\\n        uint j = mulmod(h, i, _P);\\n\\n        // Compute r = 2 * (s               - y1)       (mod P)\\n        //           = 2 * (s               + (P - y1)) (mod P)\\n        //           = 2 * ((y2 * z1\u00b3)      + (P - y1)) (mod P)\\n        //           = 2 * ((y2 * z1\u00b2 * z1) + (P - y1)) (mod P)\\n        //\\n        // Unchecked because the only protected operation performed is P - y1\\n        // where y1 is guaranteed by the caller to be an y coordinate belonging\\n        // to a point on the curve, i.e. being less than P.\\n        uint r;\\n        unchecked {\\n            r = mulmod(\\n                2,\\n                addmod(mulmod(p.y, mulmod(z1_2, z1, _P), _P), _P - y1, _P),\\n                _P\\n            );\\n        }\\n\\n        // Compute x = r\u00b2 - j - (2 * v)             (mod P)\\n        //           = r\u00b2 - j + (P - (2 * v))       (mod P)\\n        //           = r\u00b2 + (P - j) + (P - (2 * v)) (mod P)\\n        //                  \u2570\u2500\u2500\u2500\u2500\u2500\u256f   \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\\n        //                    mid         right\\n        //\\n        // Unchecked because the only protected operations performed are\\n        // subtractions from P where the subtrahend is the result of a (mod P)\\n        // computation, i.e. the subtrahend being guaranteed to be less than P.\\n        unchecked {\\n            uint r_2 = mulmod(r, r, _P);\\n            uint mid = _P - j;\\n            uint right = _P - mulmod(2, v, _P);\\n\\n            self.x = addmod(r_2, addmod(mid, right, _P), _P);\\n        }\\n\\n        // Compute y = (r * (v - x))       - (2 * y1 * j)       (mod P)\\n        //           = (r * (v - x))       + (P - (2 * y1 * j)) (mod P)\\n        //           = (r * (v + (P - x))) + (P - (2 * y1 * j)) (mod P)\\n        //             \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f   \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\\n        //                    left                 right\\n        //\\n        // Unchecked because the only protected operations performed are\\n        // subtractions from P where the subtrahend is the result of a (mod P)\\n        // computation, i.e. the subtrahend being guaranteed to be less than P.\\n        unchecked {\\n            uint left = mulmod(r, addmod(v, _P - self.x, _P), _P);\\n            uint right = _P - mulmod(2, mulmod(y1, j, _P), _P);\\n\\n            self.y = addmod(left, right, _P);\\n        }\\n    }\\n\\n    // -- Private Helpers --\\n\\n    /// @dev Returns the modular inverse of `x` for modulo `_P`.\\n    ///\\n    ///      It is the caller's responsibility to ensure `x` is less than `_P`!\\n    ///\\n    ///      The modular inverse of `x` is x\u207b\u00b9 such that x * x\u207b\u00b9 \u2261 1 (mod P).\\n    ///\\n    /// @dev Modified from Jordi Baylina's [ecsol](https://github.com/jbaylina/ecsol/blob/c2256afad126b7500e6f879a9369b100e47d435d/ec.sol#L51-L67).\\n    ///\\n    /// @custom:invariant Reverts iff out of gas.\\n    /// @custom:invariant Does not run into an infinite loop.\\n    function _invMod(uint x) private pure returns (uint) {\\n        uint t;\\n        uint q;\\n        uint newT = 1;\\n        uint r = _P;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Implemented in assembly to circumvent division-by-zero\\n            // and over-/underflow protection.\\n            //\\n            // Functionally equivalent Solidity code:\\n            //      while (x != 0) {\\n            //          q = r / x;\\n            //          (t, newT) = (newT, addmod(t, (_P - mulmod(q, newT, _P)), _P));\\n            //          (r, x) = (x, r - (q * x));\\n            //      }\\n            //\\n            // For the division r / x, x is guaranteed to not be zero via the\\n            // loop condition.\\n            //\\n            // The subtraction of form P - mulmod(_, _, P) is guaranteed to not\\n            // underflow due to the subtrahend being a (mod P) result,\\n            // i.e. the subtrahend being guaranteed to be less than P.\\n            //\\n            // The subterm q * x is guaranteed to not overflow because\\n            // q * x \u2264 r due to q = \u23a3r / x\u23a6.\\n            //\\n            // The term r - (q * x) is guaranteed to not underflow because\\n            // q * x \u2264 r and therefore r - (q * x) \u2265 0.\\n            for {} x {} {\\n                q := div(r, x)\\n\\n                let tmp := t\\n                t := newT\\n                newT := addmod(tmp, sub(_P, mulmod(q, newT, _P)), _P)\\n\\n                tmp := r\\n                r := x\\n                x := sub(tmp, mul(q, x))\\n            }\\n        }\\n\\n        return t;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {IAuth} from \\\"./IAuth.sol\\\";\\n\\n/**\\n * @title Auth Module\\n *\\n * @dev The `Auth` contract module provides a basic access control mechanism,\\n *      where a set of addresses are granted access to protected functions.\\n *      These addresses are said to be _auth'ed_.\\n *\\n *      Initially, the address given as constructor argument is the only address\\n *      auth'ed. Through the `rely(address)` and `deny(address)` functions,\\n *      auth'ed callers are able to grant/renounce auth to/from addresses.\\n *\\n *      This module is used through inheritance. It will make available the\\n *      modifier `auth`, which can be applied to functions to restrict their\\n *      use to only auth'ed callers.\\n */\\nabstract contract Auth is IAuth {\\n    /// @dev Mapping storing whether address is auth'ed.\\n    /// @custom:invariant Image of mapping is {0, 1}.\\n    ///                     \u2200x \u220a Address: _wards[x] \u220a {0, 1}\\n    /// @custom:invariant Only address given as constructor argument is authenticated after deployment.\\n    ///                     deploy(initialAuthed) \u2192 (\u2200x \u220a Address: _wards[x] == 1 \u2192 x == initialAuthed)\\n    /// @custom:invariant Only functions `rely` and `deny` may mutate the mapping's state.\\n    ///                     \u2200x \u220a Address: preTx(_wards[x]) != postTx(_wards[x])\\n    ///                                     \u2192 (msg.sig == \\\"rely\\\" \u2228 msg.sig == \\\"deny\\\")\\n    /// @custom:invariant Mapping's state may only be mutated by authenticated caller.\\n    ///                     \u2200x \u220a Address: preTx(_wards[x]) != postTx(_wards[x]) \u2192 _wards[msg.sender] = 1\\n    mapping(address => uint) private _wards;\\n\\n    /// @dev List of addresses possibly being auth'ed.\\n    /// @dev May contain duplicates.\\n    /// @dev May contain addresses not being auth'ed anymore.\\n    /// @custom:invariant Every address being auth'ed once is element of the list.\\n    ///                     \u2200x \u220a Address: authed(x) -> x \u220a _wardsTouched\\n    address[] private _wardsTouched;\\n\\n    /// @dev Ensures caller is auth'ed.\\n    modifier auth() {\\n        assembly (\\\"memory-safe\\\") {\\n            // Compute slot of _wards[msg.sender].\\n            mstore(0x00, caller())\\n            mstore(0x20, _wards.slot)\\n            let slot := keccak256(0x00, 0x40)\\n\\n            // Revert if caller not auth'ed.\\n            let isAuthed := sload(slot)\\n            if iszero(isAuthed) {\\n                // Store selector of `NotAuthorized(address)`.\\n                mstore(0x00, 0x4a0bfec1)\\n                // Store msg.sender.\\n                mstore(0x20, caller())\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x24)\\n            }\\n        }\\n        _;\\n    }\\n\\n    constructor(address initialAuthed) {\\n        _wards[initialAuthed] = 1;\\n        _wardsTouched.push(initialAuthed);\\n\\n        // Note to use address(0) as caller to indicate address was auth'ed\\n        // during deployment.\\n        emit AuthGranted(address(0), initialAuthed);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function rely(address who) external auth {\\n        if (_wards[who] == 1) return;\\n\\n        _wards[who] = 1;\\n        _wardsTouched.push(who);\\n        emit AuthGranted(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function deny(address who) external auth {\\n        if (_wards[who] == 0) return;\\n\\n        _wards[who] = 0;\\n        emit AuthRenounced(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function authed(address who) public view returns (bool) {\\n        return _wards[who] == 1;\\n    }\\n\\n    /// @inheritdoc IAuth\\n    /// @custom:invariant Only contains auth'ed addresses.\\n    ///                     \u2200x \u220a authed(): _wards[x] == 1\\n    /// @custom:invariant Contains all auth'ed addresses.\\n    ///                     \u2200x \u220a Address: _wards[x] == 1 \u2192 x \u220a authed()\\n    function authed() public view returns (address[] memory) {\\n        // Initiate array with upper limit length.\\n        address[] memory wardsList = new address[](_wardsTouched.length);\\n\\n        // Iterate through all possible auth'ed addresses.\\n        uint ctr;\\n        for (uint i; i < wardsList.length; i++) {\\n            // Add address only if still auth'ed.\\n            if (_wards[_wardsTouched[i]] == 1) {\\n                wardsList[ctr++] = _wardsTouched[i];\\n            }\\n        }\\n\\n        // Set length of array to number of auth'ed addresses actually included.\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(wardsList, ctr)\\n        }\\n\\n        return wardsList;\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function wards(address who) public view returns (uint) {\\n        return _wards[who];\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/toll/Toll.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {IToll} from \\\"./IToll.sol\\\";\\n\\n/**\\n * @title Toll Module\\n *\\n * @notice \\\"Toll paid, we kiss - but dissension looms, maybe diss?\\\"\\n *\\n * @dev The `Toll` contract module provides a basic access control mechanism,\\n *      where a set of addresses are granted access to protected functions.\\n *      These addresses are said the be _tolled_.\\n *\\n *      Initially, no address is tolled. Through the `kiss(address)` and\\n *      `diss(address)` functions, auth'ed callers are able to toll/de-toll\\n *      addresses. Authentication for these functions is defined via the\\n *      downstream implemented `toll_auth()` function.\\n *\\n *      This module is used through inheritance. It will make available the\\n *      modifier `toll`, which can be applied to functions to restrict their\\n *      use to only tolled callers.\\n */\\nabstract contract Toll is IToll {\\n    /// @dev Mapping storing whether address is tolled.\\n    /// @custom:invariant Image of mapping is {0, 1}.\\n    ///                     \u2200x \u220a Address: _buds[x] \u220a {0, 1}\\n    /// @custom:invariant Only functions `kiss` and `diss` may mutate the mapping's state.\\n    ///                     \u2200x \u220a Address: preTx(_buds[x]) != postTx(_buds[x])\\n    ///                                     \u2192 (msg.sig == \\\"kiss\\\" \u2228 msg.sig == \\\"diss\\\")\\n    /// @custom:invariant Mapping's state may only be mutated by authenticated caller.\\n    ///                     \u2200x \u220a Address: preTx(_buds[x]) != postTx(_buds[x])\\n    ///                                     \u2192 toll_auth()\\n    mapping(address => uint) private _buds;\\n\\n    /// @dev List of addresses possibly being tolled.\\n    /// @dev May contain duplicates.\\n    /// @dev May contain addresses not being tolled anymore.\\n    /// @custom:invariant Every address being tolled once is element of the list.\\n    ///                     \u2200x \u220a Address: tolled(x) \u2192 x \u220a _budsTouched\\n    address[] private _budsTouched;\\n\\n    /// @dev Ensures caller is tolled.\\n    modifier toll() {\\n        assembly (\\\"memory-safe\\\") {\\n            // Compute slot of _buds[msg.sender].\\n            mstore(0x00, caller())\\n            mstore(0x20, _buds.slot)\\n            let slot := keccak256(0x00, 0x40)\\n\\n            // Revert if caller not tolled.\\n            let isTolled := sload(slot)\\n            if iszero(isTolled) {\\n                // Store selector of `NotTolled(address)`.\\n                mstore(0x00, 0xd957b595)\\n                // Store msg.sender.\\n                mstore(0x20, caller())\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x24)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Reverts if caller not allowed to access protected function.\\n    /// @dev Must be implemented in downstream contract.\\n    function toll_auth() internal virtual;\\n\\n    /// @inheritdoc IToll\\n    function kiss(address who) external {\\n        toll_auth();\\n\\n        if (_buds[who] == 1) return;\\n\\n        _buds[who] = 1;\\n        _budsTouched.push(who);\\n        emit TollGranted(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IToll\\n    function diss(address who) external {\\n        toll_auth();\\n\\n        if (_buds[who] == 0) return;\\n\\n        _buds[who] = 0;\\n        emit TollRenounced(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IToll\\n    function tolled(address who) public view returns (bool) {\\n        return _buds[who] == 1;\\n    }\\n\\n    /// @inheritdoc IToll\\n    /// @custom:invariant Only contains tolled addresses.\\n    ///                     \u2200x \u220a tolled(): _tolled[x]\\n    /// @custom:invariant Contains all tolled addresses.\\n    ///                     \u2200x \u220a Address: _tolled[x] == 1 \u2192 x \u220a tolled()\\n    function tolled() public view returns (address[] memory) {\\n        // Initiate array with upper limit length.\\n        address[] memory budsList = new address[](_budsTouched.length);\\n\\n        // Iterate through all possible tolled addresses.\\n        uint ctr;\\n        for (uint i; i < budsList.length; i++) {\\n            // Add address only if still tolled.\\n            if (_buds[_budsTouched[i]] == 1) {\\n                budsList[ctr++] = _budsTouched[i];\\n            }\\n        }\\n\\n        // Set length of array to number of tolled addresses actually included.\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(budsList, ctr)\\n        }\\n\\n        return budsList;\\n    }\\n\\n    /// @inheritdoc IToll\\n    function bud(address who) public view returns (uint) {\\n        return _buds[who];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libs/LibSchnorrData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {IScribe} from \\\"../IScribe.sol\\\";\\n\\nimport {LibBytes} from \\\"./LibBytes.sol\\\";\\n\\n/**\\n * @title LibSchnorrData\\n *\\n * @notice Library for working with IScribe.SchnorrData\\n */\\nlibrary LibSchnorrData {\\n    using LibBytes for uint;\\n\\n    /// @dev Size of a word is 32 bytes, i.e. 256 bits.\\n    uint private constant WORD_SIZE = 32;\\n\\n    /// @dev Returns the signer index from schnorrData.signersBlob with index\\n    ///      `index`.\\n    ///\\n    /// @dev Note that schnorrData.signersBlob is big-endian encoded and\\n    ///      counting starts at the highest order byte, i.e. the signer index 0\\n    ///      is the highest order byte of schnorrData.signersBlob.\\n    ///\\n    /// @custom:example SignersBlob encoding via Solidity:\\n    ///\\n    ///      ```solidity\\n    ///      bytes memory signersBlob;\\n    ///      uint8[] memory indexes = someFuncReturningUint8Array();\\n    ///      for (uint i; i < indexes.length; i++) {\\n    ///          signersBlob = abi.encodePacked(signersBlob, indexes[i]);\\n    ///      }\\n    ///      ```\\n    ///\\n    /// @dev Calldata layout for `schnorrData`:\\n    ///\\n    ///      [schnorrData]        signature             -> schnorrData.signature\\n    ///      [schnorrData + 0x20] commitment            -> schnorrData.commitment\\n    ///      [schnorrData + 0x40] offset(signersBlob)\\n    ///      [schnorrData + 0x60] len(signersBlob)      -> schnorrData.signersBlob.length\\n    ///      [schnorrData + 0x80] signersBlob[0]        -> schnorrData.signersBlob[0]\\n    ///      ...\\n    ///\\n    ///      Note that the `schnorrData` variable holds the offset to the\\n    ///      `schnorrData` struct:\\n    ///\\n    ///      ```solidity\\n    ///      bytes32 signature;\\n    ///      assembly {\\n    ///         signature := calldataload(schnorrData)\\n    ///      }\\n    ///      assert(signature == schnorrData.signature)\\n    ///      ```\\n    ///\\n    ///      Note that `offset(signersBlob)` is the offset to `signersBlob[0]`\\n    ///      from the index `offset(signersBlob)`.\\n    ///\\n    /// @custom:invariant Reverts iff out of gas.\\n    function getSignerIndex(\\n        IScribe.SchnorrData calldata schnorrData,\\n        uint index\\n    ) internal pure returns (uint) {\\n        uint word;\\n        assembly (\\\"memory-safe\\\") {\\n            let wordIndex := mul(div(index, WORD_SIZE), WORD_SIZE)\\n\\n            // Calldata index for schnorrData.signersBlob[0] is schnorrData's\\n            // offset plus 4 words, i.e. 0x80.\\n            let start := add(schnorrData, 0x80)\\n\\n            // Note that reading non-existing calldata returns zero.\\n            // Note that overflow is no concern because index's upper limit is\\n            // bounded by bar, which is of type uint8.\\n            word := calldataload(add(start, wordIndex))\\n        }\\n\\n        // Unchecked because the subtrahend is guaranteed to be less than or\\n        // equal to 31 due to being a (mod 32) result.\\n        uint byteIndex;\\n        unchecked {\\n            byteIndex = 31 - (index % WORD_SIZE);\\n        }\\n\\n        return word.getByteAtIndex(byteIndex);\\n    }\\n\\n    /// @dev Returns the number of signers encoded in schnorrData.signersBlob.\\n    function getSignerIndexLength(IScribe.SchnorrData calldata schnorrData)\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        uint index;\\n        assembly (\\\"memory-safe\\\") {\\n            // Calldata index for schnorrData.signersBlob.length is\\n            // schnorrData's offset plus 3 words, i.e. 0x60.\\n            index := calldataload(add(schnorrData, 0x60))\\n        }\\n        return index;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/auth/IAuth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IAuth {\\n    /// @notice Thrown by protected function if caller not auth'ed.\\n    /// @param caller The caller's address.\\n    error NotAuthorized(address caller);\\n\\n    /// @notice Emitted when auth granted to address.\\n    /// @param caller The caller's address.\\n    /// @param who The address auth got granted to.\\n    event AuthGranted(address indexed caller, address indexed who);\\n\\n    /// @notice Emitted when auth renounced from address.\\n    /// @param caller The caller's address.\\n    /// @param who The address auth got renounced from.\\n    event AuthRenounced(address indexed caller, address indexed who);\\n\\n    /// @notice Grants address `who` auth.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to grant auth.\\n    function rely(address who) external;\\n\\n    /// @notice Renounces address `who`'s auth.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to renounce auth.\\n    function deny(address who) external;\\n\\n    /// @notice Returns whether address `who` is auth'ed.\\n    /// @param who The address to check.\\n    /// @return True if `who` is auth'ed, false otherwise.\\n    function authed(address who) external view returns (bool);\\n\\n    /// @notice Returns full list of addresses granted auth.\\n    /// @dev May contain duplicates.\\n    /// @return List of addresses granted auth.\\n    function authed() external view returns (address[] memory);\\n\\n    /// @notice Returns whether address `who` is auth'ed.\\n    /// @custom:deprecated Use `authed(address)(bool)` instead.\\n    /// @param who The address to check.\\n    /// @return 1 if `who` is auth'ed, 0 otherwise.\\n    function wards(address who) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/toll/IToll.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IToll {\\n    /// @notice Thrown by protected function if caller not tolled.\\n    /// @param caller The caller's address.\\n    error NotTolled(address caller);\\n\\n    /// @notice Emitted when toll granted to address.\\n    /// @param caller The caller's address.\\n    /// @param who The address toll got granted to.\\n    event TollGranted(address indexed caller, address indexed who);\\n\\n    /// @notice Emitted when toll renounced from address.\\n    /// @param caller The caller's address.\\n    /// @param who The address toll got renounced from.\\n    event TollRenounced(address indexed caller, address indexed who);\\n\\n    /// @notice Grants address `who` toll.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to grant toll.\\n    function kiss(address who) external;\\n\\n    /// @notice Renounces address `who`'s toll.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to renounce toll.\\n    function diss(address who) external;\\n\\n    /// @notice Returns whether address `who` is tolled.\\n    /// @param who The address to check.\\n    /// @return True if `who` is tolled, false otherwise.\\n    function tolled(address who) external view returns (bool);\\n\\n    /// @notice Returns full list of addresses tolled.\\n    /// @dev May contain duplicates.\\n    /// @return List of addresses tolled.\\n    function tolled() external view returns (address[] memory);\\n\\n    /// @notice Returns whether address `who` is tolled.\\n    /// @custom:deprecated Use `tolled(address)(bool)` instead.\\n    /// @param who The address to check.\\n    /// @return 1 if `who` is tolled, 0 otherwise.\\n    function bud(address who) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"src/libs/LibBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n * @title LibBytes\\n *\\n * @notice Library for common byte operations\\n */\\nlibrary LibBytes {\\n    /// @dev Returns the `index`'s byte from `word`.\\n    ///\\n    ///      It is the caller's responsibility to ensure `index < 32`!\\n    ///\\n    /// @custom:invariant Uses constant amount of gas.\\n    function getByteAtIndex(uint word, uint index)\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        uint result;\\n        assembly (\\\"memory-safe\\\") {\\n            result := byte(sub(31, index), word)\\n        }\\n\\n        // Note that the resulting byte is returned as word.\\n        return result;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"chronicle-std/=lib/chronicle-std/src/\",\r\n      \"@script/chronicle-std/=lib/chronicle-std/script/\",\r\n      \"lib/chronicle-std:src/=lib/chronicle-std/src/\",\r\n      \"greenhouse/=lib/greenhouse/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialAuthed\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"wat_\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"numberSigners\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"bar\",\"type\":\"uint8\"}],\"name\":\"BarNotReached\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"givenAge\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"currentTimestamp\",\"type\":\"uint32\"}],\"name\":\"FutureMessage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InChallengePeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoOpPokeToChallenge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"NotTolled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"gotHash\",\"type\":\"uint160\"},{\"internalType\":\"uint160\",\"name\":\"wantHash\",\"type\":\"uint160\"}],\"name\":\"SchnorrDataMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SchnorrSignatureInvalid\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"SignerNotFeed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignersNotOrdered\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"givenAge\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"currentAge\",\"type\":\"uint32\"}],\"name\":\"StaleMessage\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AuthGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AuthRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"oldBar\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newBar\",\"type\":\"uint8\"}],\"name\":\"BarUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"FeedDropped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"FeedLifted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxChallengeReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxChallengeReward\",\"type\":\"uint256\"}],\"name\":\"MaxChallengeRewardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"oldOpChallengePeriod\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newOpChallengePeriod\",\"type\":\"uint16\"}],\"name\":\"OpChallengePeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"OpChallengeRewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"schnorrErr\",\"type\":\"bytes\"}],\"name\":\"OpPokeChallengedSuccessfully\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"OpPokeChallengedUnsuccessfully\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"val\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"age\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct IScribe.PokeData\",\"name\":\"pokeData\",\"type\":\"tuple\"}],\"name\":\"OpPokeDataDropped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"opFeed\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"signature\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"commitment\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signersBlob\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct IScribe.SchnorrData\",\"name\":\"schnorrData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"val\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"age\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct IScribe.PokeData\",\"name\":\"pokeData\",\"type\":\"tuple\"}],\"name\":\"OpPoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"val\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"age\",\"type\":\"uint32\"}],\"name\":\"Poked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"TollGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"TollRenounced\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"authed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authed\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bar\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"bud\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengeReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"val\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"age\",\"type\":\"uint32\"}],\"internalType\":\"struct IScribe.PokeData\",\"name\":\"pokeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"signature\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"commitment\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signersBlob\",\"type\":\"bytes\"}],\"internalType\":\"struct IScribe.SchnorrData\",\"name\":\"schnorrData\",\"type\":\"tuple\"}],\"name\":\"constructOpPokeMessage\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"val\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"age\",\"type\":\"uint32\"}],\"internalType\":\"struct IScribe.PokeData\",\"name\":\"pokeData\",\"type\":\"tuple\"}],\"name\":\"constructPokeMessage\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"diss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feedIndex\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"feedIndexes\",\"type\":\"uint256[]\"}],\"name\":\"drop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feedRegistrationMessage\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"feeds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"feeds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeds\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"signature\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"commitment\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signersBlob\",\"type\":\"bytes\"}],\"internalType\":\"struct IScribe.SchnorrData\",\"name\":\"schnorrData\",\"type\":\"tuple\"}],\"name\":\"isAcceptableSchnorrSignatureNow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"kiss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct LibSecp256k1.Point\",\"name\":\"pubKey\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IScribe.ECDSAData\",\"name\":\"ecdsaData\",\"type\":\"tuple\"}],\"name\":\"lift\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct LibSecp256k1.Point[]\",\"name\":\"pubKeys\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IScribe.ECDSAData[]\",\"name\":\"ecdsaDatas\",\"type\":\"tuple[]\"}],\"name\":\"lift\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxChallengeReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFeeds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"signature\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"commitment\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signersBlob\",\"type\":\"bytes\"}],\"internalType\":\"struct IScribe.SchnorrData\",\"name\":\"schnorrData\",\"type\":\"tuple\"}],\"name\":\"opChallenge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opChallengePeriod\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opFeedIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"val\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"age\",\"type\":\"uint32\"}],\"internalType\":\"struct IScribe.PokeData\",\"name\":\"pokeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"signature\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"commitment\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signersBlob\",\"type\":\"bytes\"}],\"internalType\":\"struct IScribe.SchnorrData\",\"name\":\"schnorrData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IScribe.ECDSAData\",\"name\":\"ecdsaData\",\"type\":\"tuple\"}],\"name\":\"opPoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"val\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"age\",\"type\":\"uint32\"}],\"internalType\":\"struct IScribe.PokeData\",\"name\":\"pokeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"signature\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"commitment\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signersBlob\",\"type\":\"bytes\"}],\"internalType\":\"struct IScribe.SchnorrData\",\"name\":\"schnorrData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IScribe.ECDSAData\",\"name\":\"ecdsaData\",\"type\":\"tuple\"}],\"name\":\"opPoke_optimized_397084999\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"val\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"age\",\"type\":\"uint32\"}],\"internalType\":\"struct IScribe.PokeData\",\"name\":\"pokeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"signature\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"commitment\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signersBlob\",\"type\":\"bytes\"}],\"internalType\":\"struct IScribe.SchnorrData\",\"name\":\"schnorrData\",\"type\":\"tuple\"}],\"name\":\"poke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"val\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"age\",\"type\":\"uint32\"}],\"internalType\":\"struct IScribe.PokeData\",\"name\":\"pokeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"signature\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"commitment\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signersBlob\",\"type\":\"bytes\"}],\"internalType\":\"struct IScribe.SchnorrData\",\"name\":\"schnorrData\",\"type\":\"tuple\"}],\"name\":\"poke_optimized_7136211\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"read\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"readWithAge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bar_\",\"type\":\"uint8\"}],\"name\":\"setBar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxChallengeReward_\",\"type\":\"uint256\"}],\"name\":\"setMaxChallengeReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"opChallengePeriod_\",\"type\":\"uint16\"}],\"name\":\"setOpChallengePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"tolled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tolled\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tryRead\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tryReadWithAge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wat\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Chronicle_WSTETH_USD_1", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000c50dfedb7e93ef7a3daccad7987d0960c4e2cd4b5753544554482f55534400000000000000000000000000000000000000000000", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}