{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Allowlist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {IAllowlist} from \\\"./IAllowlist.sol\\\";\\n\\n/**\\n * A contract that keeps track of a list of allowed addresses and code hashes. This is\\n * intended to be inherited by the Registry contract.\\n */\\ncontract Allowlist is IAllowlist {\\n    mapping(address => bool) public allowedContractAddresses;\\n    mapping(bytes32 => bool) public allowedCodeHashes;\\n\\n    bool public isAllowlistDisabled;\\n\\n    event AllowlistDisabled(bool indexed disabled);\\n    event AllowedContractAddressAdded(address indexed contractAddress);\\n    event AllowedContractAddressRemoved(address indexed contractAddress);\\n    event AllowedCodeHashAdded(bytes32 indexed codeHash);\\n    event AllowedCodeHashRemoved(bytes32 indexed codeHash);\\n\\n    /**\\n     * @notice A global killswitch to either enable or disable the allowlist. By default\\n   * it is not disabled.\\n   * @param disabled Status of the allowlist\\n   */\\n    function _setIsAllowlistDisabled(\\n        bool disabled\\n    )\\n    internal\\n    virtual\\n    {\\n        isAllowlistDisabled = disabled;\\n        emit AllowlistDisabled(disabled);\\n    }\\n\\n    /**\\n     * @notice Checks if operator is on the allowlist. If the operator is a contract\\n   * it also checks whether or not the codehash is on the allowlist.\\n   * Returns true if operator is an externally owned account.\\n   * @param operator Address of operator\\n   * @return Bool whether operator is allowed\\n   */\\n    function _isAllowed(\\n        address operator\\n    )\\n    internal\\n    virtual\\n    view\\n    returns (bool)\\n    {\\n        if (_isEOA(operator)) {\\n            return true;\\n        } else if (_isContract(operator)) {\\n            if (_isAllowedContractAddress(operator)) {\\n                return true;\\n            } else {\\n                return _isAllowedCodeHash(operator.codehash);\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    modifier onlyAllowlistAllowed(address operator) {\\n        if (_isAllowed(operator)) {\\n            _;\\n        } else {\\n            revert IAllowlist.NotAllowlisted();\\n        }\\n    }\\n\\n    /**\\n    * @notice Checks if operator is an externally owned account and not a contract\\n  * @param operator Address of operator\\n  * @return Bool whether operator is externally owned account\\n  */\\n    function _isEOA(address operator)\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        return tx.origin == operator;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is a contract. This can only positively\\n   * identify a contract, i.e. if it returns true, then the caller is definitely\\n   * a contract. If it returns false, you should not draw any conclusions,\\n   * since e.g. code is length 0 if the caller is a contract's caller (in which\\n   * case this method returns false, despite the caller being a contract).\\n   * @param operator Address of operator\\n   * @return Bool whether operator is a contract\\n   */\\n    function _isContract(address operator)\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        return (operator.code.length > 0);\\n    }\\n\\n    /**\\n     * @notice Calls the internal function _isAllowed that checks if operator is on the allowlist.\\n   * @param operator - Address of operator\\n   * @return Bool whether operator is allowed\\n   */\\n    function isAllowed(\\n        address operator\\n    )\\n    external\\n    view\\n    virtual\\n    returns (bool)\\n    {\\n        return _isAllowed(operator);\\n    }\\n\\n    /**\\n     * @notice Add a contract to the allowed registry\\n   * @param contractAddress - Contract address\\n   */\\n    function _addAllowedContractAddress(\\n        address contractAddress\\n    )\\n    internal\\n    virtual\\n    {\\n        allowedContractAddresses[contractAddress] = true;\\n\\n        emit AllowedContractAddressAdded(\\n            contractAddress\\n        );\\n    }\\n\\n    /**\\n     * @notice If the allowlist functionality has been disabled via the global killswitch,\\n   * always return true to let all requests through.\\n   * @param contractAddress - Contract address\\n   * @return Bool whether contract address is allowed\\n   */\\n    function _isAllowedContractAddress(\\n        address contractAddress\\n    )\\n    internal\\n    view\\n    virtual\\n    returns (bool)\\n    {\\n        if (isAllowlistDisabled) {\\n            return true;\\n        }\\n\\n        return allowedContractAddresses[contractAddress];\\n    }\\n\\n    /**\\n     * @notice External function that checks if contract address is on the allowlist\\n   * @param contractAddress - Contract address\\n   * @return Bool whether contract address is allowed\\n   */\\n    function isAllowedContractAddress(\\n        address contractAddress\\n    )\\n    external\\n    view\\n    virtual\\n    returns (bool)\\n    {\\n        return _isAllowedContractAddress(contractAddress);\\n    }\\n\\n    /**\\n     * @notice Removes a contract from the allowlist\\n   * @param contractAddress - Contract address\\n   */\\n    function _removeAllowedContractAddress(\\n        address contractAddress\\n    )\\n    internal\\n    virtual\\n    {\\n        delete allowedContractAddresses[contractAddress];\\n\\n        emit AllowedContractAddressRemoved(\\n            contractAddress\\n        );\\n    }\\n\\n    /**\\n     * @notice Adds a codehash to the allowlist\\n   * @param codeHash - Contract address\\n   */\\n    function _addAllowedCodeHash(\\n        bytes32 codeHash\\n    )\\n    internal\\n    virtual\\n    {\\n        allowedCodeHashes[codeHash] = true;\\n\\n        emit AllowedCodeHashAdded(\\n            codeHash\\n        );\\n    }\\n\\n    /**\\n     * @notice If the allowlist functionality has been disabled via the global killswitch,\\n   * always return true to let all requests through.\\n   * @param codeHash - Code hash\\n   * @return Bool whether code hash is allowed\\n   */\\n    function _isAllowedCodeHash(\\n        bytes32 codeHash\\n    )\\n    internal\\n    view\\n    virtual\\n    returns (bool)\\n    {\\n        if (isAllowlistDisabled) {\\n            return true;\\n        }\\n\\n        return allowedCodeHashes[codeHash];\\n    }\\n\\n    /**\\n     * @notice External function that checks if the codehash is on the allowlist\\n   * @param contractAddress - Contract address\\n   * @return Bool whether code hash is allowed\\n   */\\n    function isAllowedCodeHash(\\n        address contractAddress\\n    )\\n    external\\n    view\\n    virtual\\n    returns (bool)\\n    {\\n        return _isAllowedCodeHash(contractAddress.codehash);\\n    }\\n\\n    /**\\n     * @notice Removes a codehash from the allowlist\\n   * @param codeHash - Code hash\\n   */\\n    function _removeAllowedCodeHash(\\n        bytes32 codeHash\\n    )\\n    internal\\n    virtual\\n    {\\n        delete allowedCodeHashes[codeHash];\\n\\n        emit AllowedCodeHashRemoved(\\n            codeHash\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/Blocklist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {IBlocklist} from \\\"./IBlocklist.sol\\\";\\n\\n/**\\n * A contract that keeps track of a list of blocked addresses and code hashes. This is\\n * intended to be inherited by the Registry contract.\\n */\\ncontract Blocklist is\\nIBlocklist\\n{\\n    mapping(address => bool) public blockedContractAddresses;\\n    mapping(bytes32 => bool) public blockedCodeHashes;\\n\\n    bool public isBlocklistDisabled;\\n\\n    event BlocklistDisabled(bool indexed disabled);\\n    event BlockedContractAddressAdded(address indexed contractAddress);\\n    event BlockedContractAddressRemoved(address indexed contractAddress);\\n    event BlockedCodeHashAdded(bytes32 indexed codeHash);\\n    event BlockedCodeHashRemoved(bytes32 indexed codeHash);\\n\\n    /**\\n     * @notice A global killswitch to either enable or disable the blocklist. By default\\n   * it is not disabled.\\n   * @param disabled Status of the blocklist\\n   */\\n    function _setIsBlocklistDisabled(\\n        bool disabled\\n    )\\n    internal\\n    virtual\\n    {\\n        isBlocklistDisabled = disabled;\\n        emit BlocklistDisabled(disabled);\\n    }\\n\\n    /**\\n     * @notice External function that Checks if operator is on the blocklist.\\n   * @param operator Address of operator\\n   * @return Bool whether operator is blocked\\n   */\\n    function isBlocked(\\n        address operator\\n    )\\n    external\\n    virtual\\n    view\\n    returns (bool)\\n    {\\n        return _isBlocked(operator);\\n    }\\n\\n    /**\\n     * @notice Checks if operator is on the blocklist. First checks to see if blocklist\\n   * is enabled, then checks against the address and code hash.\\n   * @param operator Address of operator\\n   * @return Bool whether operator is blocked\\n   */\\n    function _isBlocked(\\n        address operator\\n    )\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        if (_isBlockedContractAddress(operator)) {\\n            return true;\\n        }\\n\\n        if (operator.code.length > 0) {\\n            if (_isBlockedCodeHash(operator.codehash)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice External function that checks if operator is on the blocklist\\n   * @param operator - Contract address\\n   * @return Bool whether operator is blocked\\n   */\\n    function isBlockedContractAddress(\\n        address operator\\n    )\\n    external\\n    view\\n    returns (bool)\\n    {\\n        return _isBlockedContractAddress(operator);\\n    }\\n\\n    /**\\n     * @notice Checks if operator is on the blocklist\\n   * @param operator - Contract address\\n   * @return Bool whether operator is blocked\\n   */\\n    function _isBlockedContractAddress(\\n        address operator\\n    )\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        return blockedContractAddresses[operator];\\n    }\\n\\n    /**\\n     * @notice External function that checks if codehash is on the blocklist\\n   * @param contractAddress - Contract address\\n   * @return Bool whether code hash is blocked\\n   */\\n    function isBlockedCodeHash(\\n        address contractAddress\\n    )\\n    external\\n    view\\n    returns (bool)\\n    {\\n        return _isBlockedCodeHash(contractAddress.codehash);\\n    }\\n\\n    /**\\n     * @notice Checks if codehash is on the blocklist\\n   * @param codeHash - Codehash\\n   * @return Bool whether code hash is blocked\\n   */\\n    function _isBlockedCodeHash(\\n        bytes32 codeHash\\n    )\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        return blockedCodeHashes[codeHash];\\n    }\\n\\n    /**\\n     * @notice Add a contract to a registry\\n   * @param contractAddress - Contract address\\n   */\\n    function _addBlockedContractAddress(\\n        address contractAddress\\n    )\\n    internal\\n    virtual\\n    {\\n        blockedContractAddresses[contractAddress] = true;\\n\\n        emit BlockedContractAddressAdded(contractAddress);\\n    }\\n\\n    /**\\n     * @notice Remove a contract from a registry\\n   * @param contractAddress - Contract address\\n   */\\n    function _removeBlockedContractAddress(\\n        address contractAddress\\n    )\\n    internal\\n    virtual\\n    {\\n        delete blockedContractAddresses[contractAddress];\\n\\n        emit BlockedContractAddressRemoved(contractAddress);\\n    }\\n\\n    /**\\n     * @notice Add a codehash to a registry\\n   * @param codeHash - Codehash\\n   */\\n    function _addBlockedCodeHash(\\n        bytes32 codeHash\\n    )\\n    internal\\n    virtual\\n    {\\n        blockedCodeHashes[codeHash] = true;\\n\\n        emit BlockedCodeHashAdded(codeHash);\\n    }\\n\\n    /**\\n     * @notice Remove a codehash from a registry\\n   * @param codeHash - Codehash\\n   */\\n    function _removeBlockedCodeHash(\\n        bytes32 codeHash\\n    )\\n    internal\\n    virtual\\n    {\\n        delete blockedCodeHashes[codeHash];\\n\\n        emit BlockedCodeHashRemoved(codeHash);\\n    }\\n}\"\r\n    },\r\n    \"contracts/IAllowlist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface for the allowlist contract\\n  */\\ninterface IAllowlist {\\n    /**\\n     * @dev Emitted when address trying to transfer is not on the allowlist\\n  */\\n    error NotAllowlisted();\\n\\n    /**\\n     * @dev Checks whether `operator` is allowed. If operator is a contract\\n  * it will also check if the codehash is allowed.\\n  * @param operator - Address of operator\\n  * @return Bool whether code hash is allowed\\n  */\\n    function isAllowed(address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Checks whether `operator` is on the allowlist\\n  * @param operator - Address of operator\\n  * @return Bool whether operator is allowed\\n  */\\n    function isAllowedContractAddress(address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Checks whether `contractAddress` codehash is on the allowlist\\n  * @param contractAddress - Contract address\\n  * @return Bool whether code hash is allowed\\n  */\\n    function isAllowedCodeHash(address contractAddress) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/IBlocklist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface for the blocklist contract\\n  */\\ninterface IBlocklist {\\n    /**\\n     * @dev Checks whether `operator` is blocked. Checks against both the operator address\\n  * along with the operator codehash\\n  * @param operator - Address of operator\\n  * @return Bool whether operator is blocked\\n  */\\n    function isBlocked(address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Checks whether `operator` is blocked.\\n  * @param operator - Address of operator\\n  * @return Bool whether operator is blocked\\n  */\\n    function isBlockedContractAddress(address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Checks whether `contractAddress` codehash is blocked.\\n  * @param contractAddress - Contract address\\n  * @return Bool whether code hash is allowed\\n  */\\n    function isBlockedCodeHash(address contractAddress) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Required interface of an Registry compliant contract.\\n */\\ninterface IRegistry {\\n    /**\\n     * @dev Emitted when address trying to transfer is not allowed on the registry\\n  */\\n    error NotAllowed();\\n\\n    /**\\n     * @dev Checks whether `operator` is valid on the registry; let the registry\\n  * decide across both allow and blocklists.\\n  * @param operator - Address of operator\\n  * @return Bool whether operator is valid against registry\\n  */\\n    function isAllowedOperator(address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Checks whether `operator` is allowed on the registry\\n  * @param operator - Address of operator\\n  * @return Bool whether operator is allowed\\n  */\\n    function isAllowed(address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Checks whether `operator` is blocked on the registry\\n  * @param operator - Address of operator\\n  * @return Bool whether operator is blocked\\n  */\\n    function isBlocked(address operator) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {Allowlist} from \\\"./Allowlist.sol\\\";\\nimport {Blocklist} from \\\"./Blocklist.sol\\\";\\nimport {IRegistry} from \\\"./IRegistry.sol\\\";\\n\\n/**\\n * A registry of allowlisted and blocklisted addresses and code hashes. This is intended to\\n * be deployed as a shared oracle, and it would be wise to set the `adminAddress` to an entity\\n * that's responsible (e.g. a smart contract that lets creators vote on which addresses/code\\n * hashes to add/remove, and then calls the related functions on this contract).\\n *\\n * @author this contract is based of Yuga Labs' regisry contract (https://etherscan.io/address/0x4fC5Da4607934cC80A0C6257B1F36909C58dD622#code)\\n */\\ncontract Registry is\\nAccessControl,\\nAllowlist,\\nBlocklist,\\nIRegistry\\n{\\n    constructor() {\\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\n        super._setIsAllowlistDisabled(true);\\n        super._setIsBlocklistDisabled(false);\\n    }\\n\\n    /**\\n    * @notice Checks against the allowlist and blocklist (depending if either is enabled\\n    * or disabled) to see if the operator is allowed.\\n    * @dev This function checks the blocklist before checking the allowlist, causing the\\n    * blocklist to take precedent over the allowlist. Be aware that if an operator is on\\n    * the blocklist and allowlist, it will still be blocked.\\n    * @param operator Address of operator\\n    * @return Bool whether the operator is allowed on based off the registry\\n    */\\n    function isAllowedOperator(\\n        address operator\\n    )\\n    external\\n    view\\n    virtual\\n    returns (bool)\\n    {\\n        if (isBlocklistDisabled == false) {\\n            bool blocked = _isBlocked(operator);\\n\\n            if (blocked) {\\n                return false;\\n            }\\n        }\\n\\n        if (isAllowlistDisabled == false) {\\n            bool allowed = _isAllowed(operator);\\n\\n            return allowed;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n    * @notice Global killswitch for the allowlist\\n    * @param disabled Enables or disables the allowlist\\n    */\\n    function setIsAllowlistDisabled(\\n        bool disabled\\n    )\\n    external\\n    virtual\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        super._setIsAllowlistDisabled(disabled);\\n    }\\n\\n    /**\\n    * @notice Global killswitch for the blocklist\\n    * @param disabled Enables or disables the blocklist\\n    */\\n    function setIsBlocklistDisabled(\\n        bool disabled\\n    )\\n    external\\n    virtual\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        super._setIsBlocklistDisabled(disabled);\\n    }\\n\\n    /**\\n    * @notice Checks if the operator is on the blocklist\\n    * @param operator Address of operator\\n    * @return Bool whether operator is blocked\\n    */\\n    function isBlocked(address operator)\\n    external\\n    view\\n    override(IRegistry, Blocklist)\\n    returns (bool)\\n    {\\n        return _isBlocked(operator);\\n    }\\n\\n    /**\\n    * @notice Checks if the operator is on the allowlist\\n    * @param operator Address of operator\\n    * @return Bool whether operator is allowed\\n    */\\n    function isAllowed(address operator)\\n    external\\n    view\\n    override(IRegistry, Allowlist)\\n    returns (bool)\\n    {\\n        return _isAllowed(operator);\\n    }\\n\\n    /**\\n    * @notice Adds a contract address to the allowlist\\n    * @param contractAddress Address of allowed operator\\n    */\\n    function addAllowedContractAddress(\\n        address contractAddress\\n    )\\n    external\\n    virtual\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        super._addAllowedContractAddress(contractAddress);\\n    }\\n\\n    /**\\n    * @notice Removes a contract address from the allowlist\\n    * @param contractAddress Address of allowed operator\\n    */\\n    function removeAllowedContractAddress(\\n        address contractAddress\\n    )\\n    external\\n    virtual\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        super._removeAllowedContractAddress(contractAddress);\\n    }\\n\\n    /**\\n    * @notice Adds a codehash to the allowlist\\n    * @param codeHash Code hash of allowed contract\\n    */\\n    function addAllowedCodeHash(\\n        bytes32 codeHash\\n    )\\n    external\\n    virtual\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        super._addAllowedCodeHash(codeHash);\\n    }\\n\\n    /**\\n    * @notice Removes a codehash from the allowlist\\n    * @param codeHash Code hash of allowed contract\\n    */\\n    function removeAllowedCodeHash(\\n        bytes32 codeHash\\n    )\\n    external\\n    virtual\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        super._removeAllowedCodeHash(codeHash);\\n    }\\n\\n    /**\\n    * @notice Adds a contract address to the blocklist\\n    * @param contractAddress Address of blocked operator\\n    */\\n    function addBlockedContractAddress(\\n        address contractAddress\\n    )\\n    external\\n    virtual\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        super._addBlockedContractAddress(contractAddress);\\n    }\\n\\n    /**\\n    * @notice Removes a contract address from the blocklist\\n    * @param contractAddress Address of blocked operator\\n    */\\n    function removeBlockedContractAddress(\\n        address contractAddress\\n    )\\n    external\\n    virtual\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        super._removeBlockedContractAddress(contractAddress);\\n    }\\n\\n    /**\\n    * @notice Adds a codehash to the blocklist\\n    * @param codeHash Code hash of blocked contract\\n    */\\n    function addBlockedCodeHash(\\n        bytes32 codeHash\\n    )\\n    external\\n    virtual\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        super._addBlockedCodeHash(codeHash);\\n    }\\n\\n    /**\\n    * @notice Removes a codehash from the blocklist\\n    * @param codeHash Code hash of blocked contract\\n    */\\n    function removeBlockedCodeHash(\\n        bytes32 codeHash\\n    )\\n    external\\n    virtual\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    {\\n        super._removeBlockedCodeHash(codeHash);\\n    }\\n\\n    /**\\n    * @notice Loads a predefined blocklist\\n    */\\n    function loadPredefinedBlocklist() external onlyRole(DEFAULT_ADMIN_ROLE) {\\n\\n        // blocklist from 2023-12-27\\n        super._addBlockedContractAddress(0xf42aa99F011A1fA7CDA90E5E98b277E306BcA83e);\\n        super._addBlockedContractAddress(0xFED24eC7E22f573c2e08AEF55aA6797Ca2b3A051);\\n        super._addBlockedContractAddress(0xD42638863462d2F21bb7D4275d7637eE5d5541eB);\\n        super._addBlockedContractAddress(0x08CE97807A81896E85841d74FB7E7B065ab3ef05);\\n        super._addBlockedContractAddress(0x92de3a1511EF22AbCf3526c302159882a4755B22);\\n        super._addBlockedContractAddress(0xCd80C916B1194beB48aBF007D0b79a7238436D56);\\n        super._addBlockedContractAddress(0xb16c1342E617A5B6E4b631EB114483FDB289c0A4);\\n        super._addBlockedContractAddress(0x0fc584529a2AEfA997697FAfAcbA5831faC0c22d);\\n        super._addBlockedContractAddress(0x0000000000E655fAe4d56241588680F86E3b2377);\\n        super._addBlockedContractAddress(0x000000000060C4Ca14CfC4325359062ace33Fe3D);\\n        super._addBlockedContractAddress(0x00000000005228B791a99a61f36A130d50600106);\\n        super._addBlockedContractAddress(0x00000000000000ADc04C56Bf30aC9d3c0aAF14dC);\\n        super._addBlockedContractAddress(0x000000000000Ad05Ccc4F10045630fb830B95127);\\n        super._addBlockedContractAddress(0x0000000000A39bb272e79075ade125fd351887Ac);\\n        super._addBlockedContractAddress(0x29469395eAf6f95920E59F858042f0e28D98a20B);\\n        super._addBlockedContractAddress(0x39da41747a83aeE658334415666f3EF92DD0D541);\\n        super._addBlockedContractAddress(0xb2ecfE4E4D61f8790bbb9DE2D1259B9e2410CEA5);\\n        super._addBlockedContractAddress(0xb2ecfE4E4D61f8790bbb9DE2D1259B9e2410CEA5);\\n        super._addBlockedContractAddress(0x2f18F339620a63e43f0839Eeb18D7de1e1Be4DfB);\\n        super._addBlockedContractAddress(0x1E0049783F008A0085193E00003D00cd54003c71);\\n\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowlisted\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"codeHash\",\"type\":\"bytes32\"}],\"name\":\"AllowedCodeHashAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"codeHash\",\"type\":\"bytes32\"}],\"name\":\"AllowedCodeHashRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"AllowedContractAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"AllowedContractAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"AllowlistDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"codeHash\",\"type\":\"bytes32\"}],\"name\":\"BlockedCodeHashAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"codeHash\",\"type\":\"bytes32\"}],\"name\":\"BlockedCodeHashRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"BlockedContractAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"BlockedContractAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"BlocklistDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"codeHash\",\"type\":\"bytes32\"}],\"name\":\"addAllowedCodeHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"addAllowedContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"codeHash\",\"type\":\"bytes32\"}],\"name\":\"addBlockedCodeHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"addBlockedContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"allowedCodeHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedContractAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"blockedCodeHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blockedContractAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"isAllowedCodeHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"isAllowedContractAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isAllowedOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAllowlistDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isBlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"isBlockedCodeHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isBlockedContractAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBlocklistDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loadPredefinedBlocklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"codeHash\",\"type\":\"bytes32\"}],\"name\":\"removeAllowedCodeHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"removeAllowedContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"codeHash\",\"type\":\"bytes32\"}],\"name\":\"removeBlockedCodeHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"removeBlockedContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"setIsAllowlistDisabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"setIsBlocklistDisabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Registry", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}