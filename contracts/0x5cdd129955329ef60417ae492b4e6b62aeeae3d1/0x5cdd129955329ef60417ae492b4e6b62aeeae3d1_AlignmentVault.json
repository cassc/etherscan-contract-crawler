{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/AlignmentVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.20;\\n\\nimport \\\"solady/src/auth/Ownable.sol\\\";\\nimport \\\"openzeppelin/interfaces/IERC20.sol\\\";\\nimport \\\"openzeppelin/interfaces/IERC721.sol\\\";\\nimport \\\"openzeppelin/proxy/utils/Initializable.sol\\\";\\nimport \\\"liquidity-helper/UniswapV2LiquidityHelper.sol\\\";\\n\\ninterface INFTXFactory {\\n    function vaultsForAsset(address asset) external view returns (address[] memory);\\n}\\n\\ninterface INFTXVault {\\n    function vaultId() external view returns (uint256);\\n}\\n\\ninterface INFTXLPStaking {\\n    function deposit(uint256 vaultId, uint256 amount) external;\\n    function claimRewards(uint256 vaultId) external;\\n}\\n\\ninterface INFTXStakingZap {\\n    function addLiquidity721(uint256 vaultId, uint256[] calldata ids, uint256 minWethIn, uint256 wethIn)\\n        external\\n        returns (uint256);\\n}\\n\\n/**\\n * @title AlignmentVault\\n * @notice This allows anything to send ETH to a vault for the purpose of permanently deepening the floor liquidity of a target NFT collection.\\n * While the liquidity is locked forever, the yield can be claimed indefinitely.\\n * @dev You must initialize this contract once deployed! There is a factory for this, use it!\\n * @author Zodomo.eth (X: @0xZodomo, Telegram: @zodomo, GitHub: Zodomo, Email: zodomo@proton.me)\\n */\\ncontract AlignmentVault is Ownable, Initializable {\\n    error InsufficientFunds();\\n    error InvalidVaultId();\\n    error AlignedAsset();\\n    error NoNFTXVault();\\n    error UnwantedNFT();\\n\\n    IWETH internal constant _WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n    address internal constant _SUSHI_V2_FACTORY = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;\\n    IUniswapV2Router02 internal constant _SUSHI_V2_ROUTER =\\n        IUniswapV2Router02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\\n\\n    INFTXFactory internal constant _NFTX_VAULT_FACTORY = INFTXFactory(0xBE86f647b167567525cCAAfcd6f881F1Ee558216);\\n    INFTXLPStaking internal constant _NFTX_LIQUIDITY_STAKING =\\n        INFTXLPStaking(0x688c3E4658B5367da06fd629E41879beaB538E37);\\n    INFTXStakingZap internal constant _NFTX_STAKING_ZAP = INFTXStakingZap(0xdC774D5260ec66e5DD4627E1DD800Eff3911345C);\\n\\n    UniswapV2LiquidityHelper internal _liqHelper; // Liquidity helper used to deepen NFTX SLP with any amount of tokens\\n    IERC721 public erc721; // ERC721 token\\n    IERC20 public nftxInventory; // NFTX NFT token\\n    IERC20 public nftxLiquidity; // NFTX NFTWETH token\\n    uint256 public vaultId; // NFTX vault Id\\n    uint256[] public nftsHeld; // Inventory of aligned erc721 NFTs stored in contract\\n\\n    constructor() payable {}\\n\\n    /**\\n    * @notice Initializes all contract variables and NFTX integration\\n    * @param _erc721 Address of the target ERC721 contract\\n    * @param _owner Address of the owner to be set for this contract\\n    * @param _vaultId Identifier for the NFTX vault. If set to 0, the default (initial) vault will be used.\\n    */\\n    function initialize(address _erc721, address _owner, uint256 _vaultId) external payable virtual initializer {\\n        // Initialize contract ownership\\n        _initializeOwner(_owner);\\n        // Set target NFT collection for alignment\\n        erc721 = IERC721(_erc721);\\n        // Approve sending any NFT tokenId to NFTX Staking Zap contract\\n        erc721.setApprovalForAll(address(_NFTX_STAKING_ZAP), true);\\n        // Max approve WETH to NFTX LP Staking contract\\n        IERC20(address(_WETH)).approve(address(_NFTX_STAKING_ZAP), type(uint256).max);\\n        // Derive vaultId if necessary\\n        // Loop index is set to max value in order to determine if a match was found\\n        uint256 index = type(uint256).max;\\n        // If no vaultId is specified, use default (initial) vault\\n        if (_vaultId == 0) {\\n            index = 0;\\n        } else {\\n            // Retrieve all vaults\\n            address[] memory vaults = _NFTX_VAULT_FACTORY.vaultsForAsset(_erc721);\\n            // Revert if no vaults are returned\\n            if (vaults.length == 0) revert NoNFTXVault();\\n            // Search for vaultId\\n            for (uint256 i; i < vaults.length;) {\\n                if (INFTXVault(vaults[i]).vaultId() == _vaultId) {\\n                    index = i;\\n                    vaultId = _vaultId;\\n                    break;\\n                }\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n            // If vaultId wasn't found, revert\\n            if (index == type(uint256).max) revert InvalidVaultId();\\n        }\\n        // Derive nftxInventory token contract and vaultId if necessary\\n        address _nftxInventory = _NFTX_VAULT_FACTORY.vaultsForAsset(_erc721)[index];\\n        if (_vaultId == 0) vaultId = uint64(INFTXVault(_nftxInventory).vaultId());\\n        nftxInventory = IERC20(_nftxInventory);\\n        // Derive nftxLiquidity LP contract\\n        nftxLiquidity = IERC20(UniswapV2Library.pairFor(_SUSHI_V2_FACTORY, address(_WETH), _nftxInventory));\\n        // Approve sending nftxLiquidity to NFTX LP Staking contract\\n        nftxLiquidity.approve(address(_NFTX_LIQUIDITY_STAKING), type(uint256).max);\\n        // Setup liquidity helper\\n        _liqHelper = new UniswapV2LiquidityHelper(_SUSHI_V2_FACTORY, address(_SUSHI_V2_ROUTER), address(_WETH));\\n        // Approve tokens to liquidity helper\\n        IERC20(address(_WETH)).approve(address(_liqHelper), type(uint256).max);\\n        nftxInventory.approve(address(_liqHelper), type(uint256).max);\\n    }\\n\\n    /**\\n    * @notice Disables the ability to call initialization functions again, recommended post-initialization\\n    */\\n    function disableInitializers() external payable virtual {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n    * @notice The ability to renounce is overridden as it would break the vault. A privileged caller is required.\\n    */\\n    function renounceOwnership() public payable virtual override {}\\n\\n    /**\\n    * @notice Estimate the floor price of the NFT in terms of WETH based on NFTX SLP reserves\\n    * @return spotPrice The estimated price of the NFT token in WETH\\n    */\\n    function _estimateFloor() internal view virtual returns (uint256 spotPrice) {\\n        // Retrieve SLP reserves to calculate price of NFT token in WETH\\n        (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(address(nftxLiquidity)).getReserves();\\n        // Calculate value of NFT spot in WETH using SLP reserves values\\n        // Reverse reserve values if token1 isn't WETH\\n        if (IUniswapV2Pair(address(nftxLiquidity)).token1() != address(_WETH)) {\\n            spotPrice = ((10 ** 18 * uint256(reserve0)) / uint256(reserve1));\\n        } else {\\n            spotPrice = ((10 ** 18 * uint256(reserve1)) / uint256(reserve0));\\n        }\\n        return (spotPrice);\\n    }\\n\\n    /**\\n    * @notice Wrap all ETH, if any, before function execution\\n    */\\n    function _wrapEth() internal virtual {\\n        // Wrap all ETH, if any\\n        uint256 balance = address(this).balance;\\n        if (balance > 0) _WETH.deposit{value: balance}();\\n    }\\n\\n    /**\\n    * @notice Stake all LP tokens, if any\\n    */\\n    function _stakeLiquidity() internal virtual {\\n        uint256 liquidity = nftxLiquidity.balanceOf(address(this));\\n        if (liquidity > 0) _NFTX_LIQUIDITY_STAKING.deposit(vaultId, liquidity);\\n    }\\n\\n    /**\\n    * @notice Add aligned NFTs to NFTX vault by pairing them with their floor price in ETH\\n    * @dev This will revert if the contract doesn't hold the NFT. This doesn't require checkInventory().\\n    * @param _tokenIds Array of specific NFTs to try and add to the vault\\n    */\\n    function alignNfts(uint256[] memory _tokenIds) external payable virtual onlyOwner {\\n        // Revert if empty _tokenIds array is passed\\n        if (_tokenIds.length == 0) revert();\\n        // Wrap all ETH, if any\\n        _wrapEth();\\n        // Retrieve total WETH balance\\n        uint256 balance = IERC20(address(_WETH)).balanceOf(address(this));\\n        // Retrieve NFTX LP price for one NFT\\n        uint256 floorPrice = _estimateFloor();\\n        // Add 1 to floorPrice in order to resolve liquidity rounding issue\\n        uint256 afford = balance / (floorPrice + 1);\\n        // Revert if we cannot afford this amount of NFTs\\n        if (afford < _tokenIds.length) revert InsufficientFunds();\\n        // Calculate exact ETH to add to LP with NFTs\\n        uint256 requiredEth = _tokenIds.length * (floorPrice + 1);\\n        // Stake NFTs and ETH, approvals were given in initializeVault()\\n        _NFTX_STAKING_ZAP.addLiquidity721(vaultId, _tokenIds, 1, requiredEth);\\n        // Stake any held liquidity tokens\\n        _stakeLiquidity();\\n        // Purge tokenIds if they exist in nftsHeld inventory\\n        for (uint256 i; i < _tokenIds.length;) {\\n            // Cache nftsHeld for each aligned tokenId as its length will change upon each pop\\n            uint256[] memory inventory = nftsHeld;\\n            for (uint256 j; j < inventory.length;) {\\n                if (inventory[j] == _tokenIds[i]) {\\n                    nftsHeld[j] = nftsHeld[inventory.length - 1];\\n                    nftsHeld.pop();\\n                }\\n                unchecked { ++j; }\\n            }\\n            unchecked { ++i; }\\n        }\\n    }\\n\\n    /**\\n    * @notice Add specific amount of ETH/WETH and all fractionalized NFT tokens to NFTX vault\\n    * @dev Any ETH (msg.value or address(this).balance) will be wrapped to WETH before processing\\n    * @param _amount is the total amount of WETH to add\\n    */\\n    function alignTokens(uint256 _amount) external payable virtual onlyOwner {\\n        // Wrap all ETH, if any\\n        _wrapEth();\\n        // Retrieve total WETH balance\\n        uint256 balance = IERC20(address(_WETH)).balanceOf(address(this));\\n        // Revert if _amount is over balance\\n        if (_amount > balance) revert InsufficientFunds();\\n        // Cache nftxInventory to prevent a double SLOAD\\n        uint256 nftxInvBal = nftxInventory.balanceOf(address(this));\\n        // Process rebalancing remaining ETH and inventory tokens (if any) to add to LP\\n        if (_amount > 0 || nftxInvBal > 0) {\\n            _liqHelper.swapAndAddLiquidityTokenAndToken(\\n                address(_WETH), address(nftxInventory), uint112(_amount), uint112(nftxInvBal), 1, address(this)\\n            );\\n        }\\n        // Stake any held liquidity tokens\\n        _stakeLiquidity();\\n    }\\n\\n    /**\\n    * @notice Aligns max liquidity by depositing NFTs and ETH into the NFTX vault and staking them\\n    * This will add as many NFTs as it can afford, before staking the ETH remainder\\n    * Confirm vault has enough ETH for NFTs held before aligning max liquidity\\n    */\\n    function alignMaxLiquidity() external payable virtual onlyOwner {\\n        // Cache vaultId to save gas\\n        uint256 _vaultId = vaultId;\\n        // Wrap all ETH, if any\\n        _wrapEth();\\n        // Retrieve total WETH balance\\n        uint256 balance = IERC20(address(_WETH)).balanceOf(address(this));\\n\\n        // Retrieve NFTs held\\n        uint256[] memory inventory = nftsHeld;\\n        uint256 length = inventory.length;\\n        // Process adding liquidity using as many NFTs as the ETH balance allows\\n        if (length > 0) {\\n            // Retrieve NFTX LP price for 1 full inventory token\\n            uint256 floorPrice = _estimateFloor();\\n            // Determine how many NFTs we can afford to add to LP\\n            // Add 1 to floorPrice in order to resolve liquidity rounding issue\\n            uint256 afford = balance / (floorPrice + 1);\\n            uint256 addQty;\\n            // If we can afford to add more than we have, add what we have, otherwise add what we can afford\\n            (afford >= length) ? addQty = length : addQty = afford;\\n            // Add NFTs to LP if we can afford to\\n            if (addQty > 0) {\\n                // Calculate exact ETH to add to LP with NFTs\\n                uint256 requiredEth = addQty * (floorPrice + 1);\\n                // Iterate through inventory for as many NFTs as we can afford to add\\n                uint256[] memory tokenIds = new uint256[](addQty);\\n                for (uint256 i; i < addQty;) {\\n                    tokenIds[i] = inventory[length - addQty + i];\\n                    nftsHeld.pop();\\n                    unchecked {\\n                        ++i;\\n                    }\\n                }\\n                // Stake NFTs and ETH, approvals were given in initializeVault()\\n                _NFTX_STAKING_ZAP.addLiquidity721(_vaultId, tokenIds, 1, requiredEth);\\n                // Update cached balance after adding NFTs to vault\\n                balance = IERC20(address(_WETH)).balanceOf(address(this));\\n            }\\n        }\\n\\n        // Cache nftxInventory to prevent a double SLOAD\\n        uint256 nftxInvBal = nftxInventory.balanceOf(address(this));\\n        // Process rebalancing remaining ETH and inventory tokens (if any) to add to LP\\n        if (balance > 0 || nftxInvBal > 0) {\\n            _liqHelper.swapAndAddLiquidityTokenAndToken(\\n                address(_WETH), address(nftxInventory), uint112(balance), uint112(nftxInvBal), 1, address(this)\\n            );\\n        }\\n\\n        // Stake any held liquidity tokens\\n        _stakeLiquidity();\\n    }\\n\\n    /**\\n    * @notice Claims yield generated by the staked NFTWETH SLP. Yield can be compounded or split with a recipient.\\n    * @param _recipient Address to receive 50% of the yield. If address(0), the yield will be compounded.\\n    */\\n    function claimYield(address _recipient) external payable virtual onlyOwner {\\n        // Cache vaultId to save gas\\n        uint256 _vaultId = vaultId;\\n        // Claim SLP rewards\\n        _NFTX_LIQUIDITY_STAKING.claimRewards(_vaultId);\\n        // Determine yield amount\\n        uint256 yield = nftxInventory.balanceOf(address(this));\\n        // If no yield, end execution to save gas\\n        if (yield == 0) return;\\n        // If recipient is provided, send them 50%\\n        if (_recipient != address(0)) {\\n            uint256 amount;\\n            unchecked {\\n                amount = yield / 2;\\n                yield -= amount;\\n            }\\n            nftxInventory.transfer(_recipient, amount);\\n        }\\n        // Send all remaining yield to LP\\n        _liqHelper.swapAndAddLiquidityTokenAndToken(\\n            address(_WETH), address(nftxInventory), 0, uint112(yield), 1, address(this)\\n        );\\n        // Stake all liquidity tokens\\n        _stakeLiquidity();\\n    }\\n\\n    /**\\n    * @notice Checks the contract's inventory to recognize any new NFTs that were transferred unsafely\\n    * @param _tokenIds Array of tokenIds to check against the contract's inventory\\n    */\\n    function checkInventory(uint256[] memory _tokenIds) external payable virtual {\\n        // Cache nftsHeld to reduce SLOADs\\n        uint256[] memory inventory = nftsHeld;\\n        // Iterate through passed array\\n        for (uint256 i; i < _tokenIds.length;) {\\n            // Try check for ownership used in case token has been burned\\n            try erc721.ownerOf(_tokenIds[i]) {\\n                // If this address is the owner, see if it is in nftsHeld cached array\\n                if (erc721.ownerOf(_tokenIds[i]) == address(this)) {\\n                    bool noticed;\\n                    for (uint256 j; j < inventory.length;) {\\n                        // If NFT is found, end loop and iterate to next tokenId\\n                        if (inventory[j] == _tokenIds[i]) {\\n                            noticed = true;\\n                            break;\\n                        }\\n                        unchecked {\\n                            ++j;\\n                        }\\n                    }\\n                    // If tokenId wasn't in stored array, add it\\n                    if (!noticed) nftsHeld.push(_tokenIds[i]);\\n                }\\n            } catch {}\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @notice Retrieve known NFT inventory to check if contract is aware of holdings\\n    */\\n    function getInventory() external view virtual returns (uint256[] memory) {\\n        return nftsHeld;\\n    }\\n\\n    /**\\n    * @notice Allows the owner to rescue ERC20 tokens or ETH from vault and/or liquidity helper.\\n    * For aligned assets (like ETH, WETH, nftxInventory, nftxLiquidity), the function will rescue \\n    * the assets to the vault itself and return 0. For any other tokens, it will rescue from both \\n    * the liquidity helper and the vault, and then send the total balance to a specified address.\\n    * \\n    * @param _token The address of the ERC20 token to rescue. Use address(0) for ETH.\\n    * @param _to The recipient address to send the rescued tokens to.\\n    * @return amount Returns the amount of tokens sent to the recipient. Returns 0 for aligned assets.\\n    */\\n    function rescueERC20(address _token, address _to) external payable virtual onlyOwner returns (uint256 amount) {\\n        // If address(0), rescue ETH from liq helper to vault\\n        if (_token == address(0)) {\\n            _liqHelper.emergencyWithdrawEther();\\n            uint256 balance = address(this).balance;\\n            if (balance > 0) _WETH.deposit{value: balance}();\\n            return (0);\\n        }\\n        // If WETH, nftxInventory, or nftxLiquidity, rescue from liq helper to vault\\n        else if (_token == address(_WETH) || _token == address(nftxInventory) || _token == address(nftxLiquidity)) {\\n            _liqHelper.emergencyWithdrawErc20(_token);\\n            return (0);\\n        }\\n        // If any other token, rescue from liq helper and/or vault and send to recipient\\n        else {\\n            // Retrieve tokens from liq helper, if any\\n            if (IERC20(_token).balanceOf(address(_liqHelper)) > 0) {\\n                _liqHelper.emergencyWithdrawErc20(_token);\\n            }\\n            // Check updated balance\\n            uint256 balance = IERC20(_token).balanceOf(address(this));\\n            // Send entire balance to recipient\\n            IERC20(_token).transfer(_to, balance);\\n            return (balance);\\n        }\\n    }\\n    \\n    /**\\n    * @notice Allows the owner to rescue non-aligned ERC721 tokens. If the ERC721 token is from the \\n    * aligned collection, the transaction is reverted.\\n    *\\n    * @param _token The address of the ERC721 token contract.\\n    * @param _to The recipient address to send the rescued NFT to.\\n    * @param _tokenId The ID of the NFT to be rescued.\\n    */\\n    function rescueERC721(address _token, address _to, uint256 _tokenId) external payable virtual onlyOwner {\\n        // If _address is for the aligned collection, revert\\n        if (address(erc721) == _token) revert AlignedAsset();\\n        // Otherwise, attempt to send to recipient\\n        else IERC721(_token).transferFrom(address(this), _to, _tokenId);\\n    }\\n\\n    /**\\n    * @notice Fallback function that converts any received ETH to WETH.\\n    */\\n    receive() external payable virtual {\\n        _WETH.deposit{value: msg.value}();\\n    }\\n    \\n    /**\\n    * @notice Handles the logic when an ERC721 NFT is sent to this contract. Logs only aligned NFTs, \\n    * and reverts if any other NFTs are sent.\\n    *\\n    * @param _tokenId The ID of the received NFT.\\n    * @return magicBytes Returns a bytes4 magic value if the NFT transfer is accepted.\\n    */\\n    function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external virtual returns (bytes4 magicBytes) {\\n        if (msg.sender == address(erc721)) nftsHeld.push(_tokenId);\\n        else revert UnwantedNFT();\\n        return AlignmentVault.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n            // Store the new value.\\n            sstore(ownerSlot, newOwner)\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(not(_OWNER_SLOT_NOT))\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC721} from \\\"../token/ERC721/IERC721.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/liquidity-helper/UniswapV2LiquidityHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: VPL\\npragma solidity ^0.8.20;\\n\\nimport \\\"solady/src/auth/Ownable.sol\\\";\\nimport \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport \\\"solidity-lib/libraries/TransferHelper.sol\\\";\\nimport \\\"v2-periphery/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"v2-periphery/interfaces/IWETH.sol\\\";\\nimport \\\"./UniswapV2Library.sol\\\";\\n\\n// Majority of code was taken from the following link\\n// https://github.com/Roger-Wu/uniswap-v2-liquidity-adder-contract/blob/master/contracts/UniswapV2AddLiquidityHelperV1_1.sol\\n// Quite a few changes were necessary for Solidity >0.8.0 but most of the logic is still @Roger-Wu's\\n\\ncontract UniswapV2LiquidityHelper is Ownable {\\n    address public immutable _uniswapV2FactoryAddress;\\n    address public immutable _uniswapV2Router02Address;\\n    address public immutable _wethAddress;\\n\\n    constructor(\\n        address uniswapV2FactoryAddress,\\n        address uniswapV2Router02Address,\\n        address wethAddress\\n    ) payable {\\n        _uniswapV2FactoryAddress = uniswapV2FactoryAddress;\\n        _uniswapV2Router02Address = uniswapV2Router02Address;\\n        _wethAddress = wethAddress;\\n        _initializeOwner(msg.sender);\\n    }\\n\\n    // fallback() external payable {}\\n    receive() external payable {}\\n\\n    // Add as more tokenA and tokenB as possible to a Uniswap pair.\\n    // The ratio between tokenA and tokenB can be any.\\n    // Approve enough amount of tokenA and tokenB to this contract before calling this function.\\n    // Uniswap pair tokenA-tokenB must exist.\\n    function swapAndAddLiquidityTokenAndToken(\\n        address tokenAddressA,\\n        address tokenAddressB,\\n        uint112 amountA,\\n        uint112 amountB,\\n        uint112 minLiquidityOut,\\n        address to\\n    ) external returns(uint liquidity) {\\n        require(amountA > 0 || amountB > 0, \\\"amounts can not be both 0\\\");\\n\\n        // transfer user's tokens to this contract\\n        if (amountA > 0) {\\n            TransferHelper.safeTransferFrom(tokenAddressA, msg.sender, address(this), uint(amountA));\\n        }\\n        if (amountB > 0) {\\n            TransferHelper.safeTransferFrom(tokenAddressB, msg.sender, address(this), uint(amountB));\\n        }\\n\\n        return _swapAndAddLiquidity(\\n            tokenAddressA,\\n            tokenAddressB,\\n            uint(amountA),\\n            uint(amountB),\\n            uint(minLiquidityOut),\\n            to\\n        );\\n    }\\n\\n    // Add as more ether and tokenB as possible to a Uniswap pair.\\n    // The ratio between ether and tokenB can be any.\\n    // Approve enough amount of tokenB to this contract before calling this function.\\n    // Uniswap pair WETH-tokenB must exist.\\n    /*function swapAndAddLiquidityEthAndToken(\\n        address tokenAddressB,\\n        uint112 amountB,\\n        uint112 minLiquidityOut,\\n        address to\\n    ) external payable returns(uint liquidity) {\\n        uint amountA = msg.value;\\n        address tokenAddressA = _wethAddress;\\n\\n        require(amountA > 0 || amountB > 0, \\\"amounts can not be both 0\\\");\\n\\n        // convert ETH to WETH\\n        IWETH(_wethAddress).deposit{value: amountA}();\\n        // transfer user's tokenB to this contract\\n        if (amountB > 0) {\\n            TransferHelper.safeTransferFrom(tokenAddressB, msg.sender, address(this), uint(amountB));\\n        }\\n\\n        return _swapAndAddLiquidity(\\n            tokenAddressA,\\n            tokenAddressB,\\n            amountA,\\n            uint(amountB),\\n            uint(minLiquidityOut),\\n            to\\n        );\\n    }*/\\n\\n    // add as more tokens as possible to a Uniswap pair\\n    function _swapAndAddLiquidity(\\n        address tokenAddressA,\\n        address tokenAddressB,\\n        uint amountA,\\n        uint amountB,\\n        uint minLiquidityOut,\\n        address to\\n    ) internal returns(uint liquidity) {\\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(_uniswapV2FactoryAddress, tokenAddressA, tokenAddressB);\\n\\n        // Swap tokenA and tokenB s.t. amountA / reserveA >= amountB / reserveB\\n        // (or amountA * reserveB >= reserveA * amountB)\\n        // which means we will swap part of tokenA to tokenB before adding liquidity.\\n        if (amountA * reserveB < reserveA * amountB) {\\n            (tokenAddressA, tokenAddressB) = (tokenAddressB, tokenAddressA);\\n            (reserveA, reserveB) = (reserveB, reserveA);\\n            (amountA, amountB) = (amountB, amountA);\\n        }\\n        uint amountAToAdd = amountA;\\n        uint amountBToAdd = amountB;\\n        if (IERC20(tokenAddressA).allowance(address(this), _uniswapV2Router02Address) < amountA) {\\n            TransferHelper.safeApprove(tokenAddressA, _uniswapV2Router02Address, 2**256 - 1);\\n        }\\n\\n        uint amountAToSwap = calcAmountAToSwap(reserveA, reserveB, amountA, amountB);\\n        require(amountAToSwap <= amountA, \\\"bugs in calcAmountAToSwap cause amountAToSwap > amountA\\\");\\n        if (amountAToSwap > 0) {\\n            address[] memory path = new address[](2);\\n            path[0] = tokenAddressA;\\n            path[1] = tokenAddressB;\\n\\n            uint[] memory swapOutAmounts = IUniswapV2Router02(_uniswapV2Router02Address).swapExactTokensForTokens(\\n                amountAToSwap, // uint amountIn,\\n                1, // uint amountOutMin,\\n                path, // address[] calldata path,\\n                address(this), // address to,\\n                2**256-1 // uint deadline\\n            );\\n\\n            amountAToAdd -= amountAToSwap;\\n            amountBToAdd += swapOutAmounts[swapOutAmounts.length - 1];\\n        }\\n\\n        // _approveTokenToRouterIfNecessary(tokenAddressB, amountBToAdd);\\n        if (IERC20(tokenAddressB).allowance(address(this), _uniswapV2Router02Address) < amountBToAdd) {\\n            TransferHelper.safeApprove(tokenAddressB, _uniswapV2Router02Address, 2**256 - 1);\\n        }\\n        (, , liquidity) = IUniswapV2Router02(_uniswapV2Router02Address).addLiquidity(\\n            tokenAddressA, // address tokenA,\\n            tokenAddressB, // address tokenB,\\n            amountAToAdd, // uint amountADesired,\\n            amountBToAdd, // uint amountBDesired,\\n            1, // uint amountAMin,\\n            1, // uint amountBMin,\\n            to, // address to,\\n            2**256-1 // uint deadline\\n        );\\n\\n        require(liquidity >= minLiquidityOut, \\\"minted liquidity not enough\\\");\\n\\n        // Due to the inaccuracy of integer division,\\n        // there may be a small amount of tokens left in this contract.\\n        // Usually it doesn't worth it to spend more gas to transfer them out.\\n        // These tokens will be considered as a donation to the owner.\\n        // All ether and tokens directly sent to this contract will be considered as a donation to the contract owner.\\n    }\\n\\n    function calcAmountAToSwap(\\n        uint reserveA,\\n        uint reserveB,\\n        uint amountA,\\n        uint amountB\\n    ) public pure returns(\\n        uint amountAToSwap\\n    ) {\\n        // separating requirements somehow saves gas.\\n        require(reserveA > 0, \\\"reserveA can't be empty\\\");\\n        require(reserveB > 0, \\\"reserveB can't be empty\\\");\\n        require(reserveA < 2**112, \\\"reserveA must be < 2**112\\\");\\n        require(reserveB < 2**112, \\\"reserveB must be < 2**112\\\");\\n        require(amountA < 2**112, \\\"amountA must be < 2**112\\\");\\n        require(amountB < 2**112, \\\"amountB must be < 2**112\\\");\\n        require(amountA * reserveB >= reserveA * amountB, \\\"require amountA / amountB >= reserveA / reserveB\\\");\\n\\n        uint l = 0; // minAmountAToSwap\\n        uint r = amountA; // maxAmountAToSwap\\n        // avoid binary search going too deep. saving gas\\n        uint tolerance = amountA / 10000;\\n        if (tolerance == 0) { tolerance = 1; }\\n        uint newReserveA;\\n        uint newReserveB;\\n        uint newAmountA;\\n        uint newAmountB;\\n\\n        // cache rA_times_1000 and rA_times_rB_times_1000 to save gas\\n        // Since reserveA, reserveB are both < 2**112,\\n        // rA_times_rB_times_1000 won't overflow.\\n        uint rA_times_1000 = reserveA * 1000;\\n        uint rA_times_rB_times_1000 = rA_times_1000 * reserveB;\\n\\n        // goal:\\n        //   after swap l tokenA,\\n        //     newAmountA / newAmountB >= newReserveA / newReserveB\\n        //   after swap r tokenA,\\n        //     newAmountA / newAmountB < newReserveA / newReserveB\\n        //   r <= l + tolerance\\n        while (l + tolerance < r) {\\n            amountAToSwap = (l + r) / 2;\\n\\n            newReserveA = reserveA + amountAToSwap;\\n            // (1000 * reserveA + 997 * amountAToSwap) * newReserveB = 1000 * reserveA * reserveB\\n            newReserveB = rA_times_rB_times_1000 / (rA_times_1000 + 997 * amountAToSwap);\\n            newAmountA = amountA - amountAToSwap; // amountAToSwap <= amountA\\n            newAmountB = amountB + (reserveB - newReserveB); // newReserveB <= reserveB\\n            if (newAmountA * newReserveB >= newReserveA * newAmountB) {\\n                l = amountAToSwap;\\n            } else {\\n                r = amountAToSwap;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    function emergencyWithdrawEther() external onlyOwner {\\n        (bool success, ) = payable(msg.sender).call{ value: address(this).balance }(\\\"\\\");\\n        require(success, \\\"withdraw failure\\\");\\n    }\\n\\n    function emergencyWithdrawErc20(address tokenAddress) external onlyOwner {\\n        IERC20 token = IERC20(tokenAddress);\\n        TransferHelper.safeTransfer(tokenAddress, msg.sender, token.balanceOf(address(this)));\\n    }\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/solidity-lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"lib/liquidity-helper/UniswapV2Library.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport 'v2-core/interfaces/IUniswapV2Pair.sol';\\n\\nlibrary UniswapV2Library {\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // SushiSwap init code hash\\n            )))));\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"lib/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/solady/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"liquidity-helper/=lib/liquidity-helper/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solidity-lib/=lib/solidity-lib/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"v2-core/=lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/v2-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlignedAsset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidVaultId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoNFTXVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnwantedNFT\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"alignMaxLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"alignNfts\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"alignTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"checkInventory\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"claimYield\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableInitializers\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc721\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInventory\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc721\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftsHeld\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftxInventory\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftxLiquidity\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicBytes\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rescueERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"rescueERC721\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AlignmentVault", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}