{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/AaveCLRobotOperator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {IAaveCLRobotOperator} from '../interfaces/IAaveCLRobotOperator.sol';\\nimport {LinkTokenInterface} from 'chainlink-brownie-contracts/interfaces/LinkTokenInterface.sol';\\nimport {IKeeperRegistrar} from '../interfaces/IKeeperRegistrar.sol';\\nimport {IKeeperRegistry} from '../interfaces/IKeeperRegistry.sol';\\nimport {OwnableWithGuardian} from 'solidity-utils/contracts/access-control/OwnableWithGuardian.sol';\\n\\n/**\\n * @title AaveCLRobotOperator\\n * @author BGD Labs\\n * @dev Operator contract to perform admin actions on the automation keepers.\\n *      The contract can register keepers, cancel it, withdraw excess link,\\n *      refill the keeper, configure the gasLimit.\\n */\\ncontract AaveCLRobotOperator is OwnableWithGuardian, IAaveCLRobotOperator {\\n  /// @inheritdoc IAaveCLRobotOperator\\n  address public immutable LINK_TOKEN;\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  address public immutable KEEPER_REGISTRY;\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  address public immutable KEEPER_REGISTRAR;\\n\\n  address internal _linkWithdrawAddress;\\n\\n  mapping(uint256 id => KeeperInfo) internal _keepers;\\n\\n  /**\\n   * @param linkTokenAddress address of the ERC-677 link token contract.\\n   * @param keeperRegistry address of the chainlink registry.\\n   * @param keeperRegistrar address of the chainlink registrar.\\n   * @param linkWithdrawAddress withdrawal address to send the exccess link after cancelling the keeper.\\n   * @param operatorOwner address to set as the owner of the operator contract.\\n   */\\n  constructor(\\n    address linkTokenAddress,\\n    address keeperRegistry,\\n    address keeperRegistrar,\\n    address linkWithdrawAddress,\\n    address operatorOwner\\n  ) {\\n    KEEPER_REGISTRY = keeperRegistry;\\n    KEEPER_REGISTRAR = keeperRegistrar;\\n    LINK_TOKEN = linkTokenAddress;\\n    _linkWithdrawAddress = linkWithdrawAddress;\\n    _transferOwnership(operatorOwner);\\n  }\\n\\n  /// @notice In order to fund the keeper we need to approve the Link token amount to this contract\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function register(\\n    string memory name,\\n    address upkeepContract,\\n    uint32 gasLimit,\\n    uint96 amountToFund\\n  ) external onlyOwner returns (uint256) {\\n    LinkTokenInterface(LINK_TOKEN).transferFrom(msg.sender, address(this), amountToFund);\\n    (IKeeperRegistry.State memory state, , ) = IKeeperRegistry(KEEPER_REGISTRY).getState();\\n    // nonce of the registry before the keeper has been registered\\n    uint256 oldNonce = state.nonce;\\n\\n    bytes memory payload = abi.encode(\\n      name, // name of the keeper to register\\n      0x0, // encryptedEmail to send alerts to, unused currently\\n      upkeepContract, // address of the upkeep contract\\n      gasLimit, // max gasLimit which can be used for an performUpkeep action\\n      address(this), // admin of the keeper is set to this address of AaveCLRobotOperator\\n      '', // checkData of the keeper which get passed to the checkUpkeep, unused currently\\n      amountToFund, // amount of link to fund the keeper with\\n      0, // source application sending this request\\n      address(this) // address of the sender making the request\\n    );\\n    LinkTokenInterface(LINK_TOKEN).transferAndCall(\\n      KEEPER_REGISTRAR,\\n      amountToFund,\\n      bytes.concat(IKeeperRegistrar.register.selector, payload)\\n    );\\n\\n    (state, , ) = IKeeperRegistry(KEEPER_REGISTRY).getState();\\n\\n    // checks if the keeper has been registered succesfully by checking that nonce has been incremented on the registry\\n    if (state.nonce == oldNonce + 1) {\\n      // calculates the id for the keeper registered\\n      uint256 id = uint256(\\n        keccak256(abi.encodePacked(blockhash(block.number - 1), KEEPER_REGISTRY, uint32(oldNonce)))\\n      );\\n      _keepers[id].upkeep = upkeepContract;\\n      _keepers[id].name = name;\\n      emit KeeperRegistered(id, upkeepContract, amountToFund);\\n\\n      return id;\\n    } else {\\n      revert('AUTO_APPROVE_DISABLED');\\n    }\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function cancel(uint256 id) external onlyOwner {\\n    IKeeperRegistry(KEEPER_REGISTRY).cancelUpkeep(id);\\n    emit KeeperCancelled(id, _keepers[id].upkeep);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function withdrawLink(uint256 id) external {\\n    IKeeperRegistry(KEEPER_REGISTRY).withdrawFunds(id, _linkWithdrawAddress);\\n    emit LinkWithdrawn(id, _keepers[id].upkeep, _linkWithdrawAddress);\\n  }\\n\\n  /// @notice In order to refill the keeper we need to approve the Link token amount to this contract\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function refillKeeper(uint256 id, uint96 amount) external {\\n    LinkTokenInterface(LINK_TOKEN).transferFrom(msg.sender, address(this), amount);\\n    LinkTokenInterface(LINK_TOKEN).approve(KEEPER_REGISTRY, amount);\\n    IKeeperRegistry(KEEPER_REGISTRY).addFunds(id, amount);\\n    emit KeeperRefilled(id, msg.sender, amount);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function setGasLimit(uint256 id, uint32 gasLimit) external onlyOwnerOrGuardian {\\n    IKeeperRegistry(KEEPER_REGISTRY).setUpkeepGasLimit(id, gasLimit);\\n    emit GasLimitSet(id, _keepers[id].upkeep, gasLimit);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function setWithdrawAddress(address withdrawAddress) external onlyOwner {\\n    _linkWithdrawAddress = withdrawAddress;\\n    emit WithdrawAddressSet(withdrawAddress);\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function getWithdrawAddress() external view returns (address) {\\n    return _linkWithdrawAddress;\\n  }\\n\\n  /// @inheritdoc IAaveCLRobotOperator\\n  function getKeeperInfo(uint256 id) external view returns (KeeperInfo memory) {\\n    return _keepers[id];\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAaveCLRobotOperator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IAaveCLRobotOperator\\n * @author BGD Labs\\n * @notice Defines the interface for the robot operator contract to perform admin actions on the automation keepers.\\n **/\\ninterface IAaveCLRobotOperator {\\n  /**\\n   * @dev Emitted when a keeper is registered using the operator contract.\\n   * @param id id of the keeper registered.\\n   * @param upkeep address of the keeper contract.\\n   * @param amount amount of link the keeper has been registered with.\\n   */\\n  event KeeperRegistered(uint256 indexed id, address indexed upkeep, uint96 indexed amount);\\n\\n  /**\\n   * @dev Emitted when a keeper is cancelled using the operator contract.\\n   * @param id id of the keeper cancelled.\\n   * @param upkeep address of the keeper contract.\\n   */\\n  event KeeperCancelled(uint256 indexed id, address indexed upkeep);\\n\\n  /**\\n   * @dev Emitted when a keeper is already cancelled, and link is being withdrawn using the operator contract.\\n   * @param id id of the keeper to withdraw link from.\\n   * @param upkeep address of the keeper contract.\\n   * @param to address where link needs to be withdrawn to.\\n   */\\n  event LinkWithdrawn(uint256 indexed id, address indexed upkeep, address indexed to);\\n\\n  /**\\n   * @dev Emitted when a keeper is refilled using the operator contract.\\n   * @param id id of the keeper which has been refilled.\\n   * @param from address which refilled the keeper.\\n   * @param amount amount of link which has been refilled for the keeper.\\n   */\\n  event KeeperRefilled(uint256 indexed id, address indexed from, uint96 indexed amount);\\n\\n  /**\\n   * @dev Emitted when the link withdraw address has been changed of the keeper.\\n   * @param newWithdrawAddress address of the new withdraw address where link will be withdrawn to.\\n   */\\n  event WithdrawAddressSet(address indexed newWithdrawAddress);\\n\\n  /**\\n   * @dev Emitted when gas limit is configured using the operator contract.\\n   * @param id id of the keeper which gas limit has been configured.\\n   * @param upkeep address of the keeper contract.\\n   * @param gasLimit max gas limit which has been configured for the keeper.\\n   */\\n  event GasLimitSet(uint256 indexed id, address indexed upkeep, uint32 indexed gasLimit);\\n\\n  /**\\n   * @notice holds the keeper info registered via the operator.\\n   * @param upkeep address of the keeper contract registered.\\n   * @param name name of the registered keeper.\\n   */\\n  struct KeeperInfo {\\n    address upkeep;\\n    string name;\\n  }\\n\\n  /**\\n   * @notice method called by owner to register the automation robot keeper.\\n   * @param name - name of keeper.\\n   * @param upkeepContract - upkeepContract of the keeper.\\n   * @param gasLimit - max gasLimit which the chainlink automation node can execute for the automation.\\n   * @param amountToFund - amount of link to fund the keeper with.\\n   * @return chainlink id for the registered keeper.\\n   **/\\n  function register(\\n    string memory name,\\n    address upkeepContract,\\n    uint32 gasLimit,\\n    uint96 amountToFund\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice method called to refill the keeper.\\n   * @param id - id of the chainlink registered keeper to refill.\\n   * @param amount - amount of LINK to refill the keeper with.\\n   **/\\n  function refillKeeper(uint256 id, uint96 amount) external;\\n\\n  /**\\n   * @notice method called by the owner to cancel the automation robot keeper.\\n   * @param id - id of the chainlink registered keeper to cancel.\\n   **/\\n  function cancel(uint256 id) external;\\n\\n  /**\\n   * @notice method called permissionlessly to withdraw link of automation robot keeper to the withdraw address.\\n   *         this method should only be called after the automation robot keeper is cancelled.\\n   * @param id - id of the chainlink registered keeper to withdraw funds of.\\n   **/\\n  function withdrawLink(uint256 id) external;\\n\\n  /**\\n   * @notice method called by owner / robot guardian to set the max gasLimit of upkeep robot keeper.\\n   * @param id - id of the chainlink registered keeper to set the gasLimit.\\n   * @param gasLimit max gasLimit which the chainlink automation node can execute.\\n   **/\\n  function setGasLimit(uint256 id, uint32 gasLimit) external;\\n\\n  /**\\n   * @notice method called by owner to set the withdraw address when withdrawing excess link from the automation robot keeeper.\\n   * @param withdrawAddress withdraw address to withdaw link to.\\n   **/\\n  function setWithdrawAddress(address withdrawAddress) external;\\n\\n  /**\\n   * @notice method to get the withdraw address for the robot operator contract.\\n   * @return withdraw address to send excess link to.\\n   **/\\n  function getWithdrawAddress() external view returns (address);\\n\\n  /**\\n   * @notice method to get the keeper information registered via the operator.\\n   * @param id - id of the chainlink registered keeper.\\n   * @return Struct containing the following information about the keeper:\\n   *         - uint256 chainlink id of the registered keeper.\\n   *         - string name of the registered keeper.\\n   *         - address chainlink registry of the registered keeper.\\n   **/\\n  function getKeeperInfo(uint256 id) external view returns (KeeperInfo memory);\\n\\n  /**\\n   * @notice method to get the address of ERC-677 link token.\\n   * @return link token address.\\n   */\\n  function LINK_TOKEN() external returns (address);\\n\\n  /**\\n   * @notice method to get the address of chainlink keeper registry contract.\\n   * @return keeper registry address.\\n   */\\n  function KEEPER_REGISTRY() external returns (address);\\n\\n  /**\\n   * @notice method to get the address of chainlink keeper registrar contract.\\n   * @return keeper registrar address.\\n   */\\n  function KEEPER_REGISTRAR() external returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/chainlink-brownie-contracts/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IKeeperRegistrar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IKeeperRegistrar {\\n  function register(\\n    string memory name,\\n    bytes calldata encryptedEmail,\\n    address upkeepContract,\\n    uint32 gasLimit,\\n    address adminAddress,\\n    bytes calldata checkData,\\n    uint96 amount,\\n    uint8 source,\\n    address sender\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IKeeperRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IKeeperRegistry {\\n  /**\\n   * @notice config of the registry\\n   * @dev only used in params and return values\\n   * @member paymentPremiumPPB payment premium rate oracles receive on top of\\n   * being reimbursed for gas, measured in parts per billion\\n   * @member flatFeeMicroLink flat fee paid to oracles for performing upkeeps,\\n   * priced in MicroLink; can be used in conjunction with or independently of\\n   * paymentPremiumPPB\\n   * @member blockCountPerTurn number of blocks each oracle has during their turn to\\n   * perform upkeep before it will be the next keeper's turn to submit\\n   * @member checkGasLimit gas limit when checking for upkeep\\n   * @member stalenessSeconds number of seconds that is allowed for feed data to\\n   * be stale before switching to the fallback pricing\\n   * @member gasCeilingMultiplier multiplier to apply to the fast gas feed price\\n   * when calculating the payment ceiling for keepers\\n   * @member minUpkeepSpend minimum LINK that an upkeep must spend before cancelling\\n   * @member maxPerformGas max executeGas allowed for an upkeep on this registry\\n   * @member fallbackGasPrice gas price used if the gas price feed is stale\\n   * @member fallbackLinkPrice LINK price used if the LINK price feed is stale\\n   * @member transcoder address of the transcoder contract\\n   * @member registrar address of the registrar contract\\n   */\\n  struct Config {\\n    uint32 paymentPremiumPPB;\\n    uint32 flatFeeMicroLink; // min 0.000001 LINK, max 4294 LINK\\n    uint24 blockCountPerTurn;\\n    uint32 checkGasLimit;\\n    uint24 stalenessSeconds;\\n    uint16 gasCeilingMultiplier;\\n    uint96 minUpkeepSpend;\\n    uint32 maxPerformGas;\\n    uint256 fallbackGasPrice;\\n    uint256 fallbackLinkPrice;\\n    address transcoder;\\n    address registrar;\\n  }\\n\\n  /**\\n   * @notice state of the registry\\n   * @dev only used in params and return values\\n   * @member nonce used for ID generation\\n   * @member ownerLinkBalance withdrawable balance of LINK by contract owner\\n   * @member expectedLinkBalance the expected balance of LINK of the registry\\n   * @member numUpkeeps total number of upkeeps on the registry\\n   */\\n  struct State {\\n    uint32 nonce;\\n    uint96 ownerLinkBalance;\\n    uint256 expectedLinkBalance;\\n    uint256 numUpkeeps;\\n  }\\n\\n  function cancelUpkeep(uint256 id) external;\\n\\n  function addFunds(uint256 id, uint96 amount) external;\\n\\n  function withdrawFunds(uint256 id, address to) external;\\n\\n  function setUpkeepGasLimit(uint256 id, uint32 gasLimit) external;\\n\\n  function getUpkeep(\\n    uint256 id\\n  )\\n    external\\n    view\\n    returns (\\n      address target,\\n      uint32 executeGas,\\n      bytes memory checkData,\\n      uint96 balance,\\n      address lastKeeper,\\n      address admin,\\n      uint64 maxValidBlocknumber,\\n      uint96 amountSpent\\n    );\\n\\n  function getState() external view returns (State memory, Config memory, address[] memory);\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/access-control/OwnableWithGuardian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\nimport {IWithGuardian} from './interfaces/IWithGuardian.sol';\\nimport {Ownable} from '../oz-common/Ownable.sol';\\n\\nabstract contract OwnableWithGuardian is Ownable, IWithGuardian {\\n  address private _guardian;\\n\\n  constructor() {\\n    _updateGuardian(_msgSender());\\n  }\\n\\n  modifier onlyGuardian() {\\n    _checkGuardian();\\n    _;\\n  }\\n\\n  modifier onlyOwnerOrGuardian() {\\n    _checkOwnerOrGuardian();\\n    _;\\n  }\\n\\n  function guardian() public view override returns (address) {\\n    return _guardian;\\n  }\\n\\n  /// @inheritdoc IWithGuardian\\n  function updateGuardian(address newGuardian) external override onlyGuardian {\\n    _updateGuardian(newGuardian);\\n  }\\n\\n  /**\\n   * @dev method to update the guardian\\n   * @param newGuardian the new guardian address\\n   */\\n  function _updateGuardian(address newGuardian) internal {\\n    address oldGuardian = _guardian;\\n    _guardian = newGuardian;\\n    emit GuardianUpdated(oldGuardian, newGuardian);\\n  }\\n\\n  function _checkGuardian() internal view {\\n    require(guardian() == _msgSender(), 'ONLY_BY_GUARDIAN');\\n  }\\n\\n  function _checkOwnerOrGuardian() internal view {\\n    require(_msgSender() == owner() || _msgSender() == guardian(), 'ONLY_BY_OWNER_OR_GUARDIAN');\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/access-control/interfaces/IWithGuardian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\ninterface IWithGuardian {\\n  /**\\n   * @dev Event emitted when guardian gets updated\\n   * @param oldGuardian address of previous guardian\\n   * @param newGuardian address of the new guardian\\n   */\\n  event GuardianUpdated(address oldGuardian, address newGuardian);\\n\\n  /**\\n   * @dev get guardian address;\\n   */\\n  function guardian() external view returns (address);\\n\\n  /**\\n   * @dev method to update the guardian\\n   * @param newGuardian the new guardian address\\n   */\\n  function updateGuardian(address newGuardian) external;\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/oz-common/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\\n\\npragma solidity ^0.8.0;\\n\\nimport './Context.sol';\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solidity-utils/src/contracts/oz-common/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@aave/core-v3/=lib/aave-address-book/lib/aave-v3-core/\",\r\n      \"@aave/periphery-v3/=lib/aave-address-book/lib/aave-v3-periphery/\",\r\n      \"aave-address-book/=lib/aave-address-book/src/\",\r\n      \"aave-helpers/=lib/aave-helpers/src/\",\r\n      \"aave-v3-core/=lib/aave-address-book/lib/aave-v3-core/\",\r\n      \"aave-v3-periphery/=lib/aave-address-book/lib/aave-v3-periphery/\",\r\n      \"chainlink-brownie-contracts/=lib/chainlink-brownie-contracts/contracts/src/v0.8/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"governance-crosschain-bridges/=lib/governance-crosschain-bridges/\",\r\n      \"solidity-utils/=lib/solidity-utils/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"linkTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeperRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeperRegistrar\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"linkWithdrawAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operatorOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upkeep\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"}],\"name\":\"GasLimitSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGuardian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"GuardianUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upkeep\",\"type\":\"address\"}],\"name\":\"KeeperCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"KeeperRefilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upkeep\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"KeeperRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upkeep\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"LinkWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWithdrawAddress\",\"type\":\"address\"}],\"name\":\"WithdrawAddressSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"KEEPER_REGISTRAR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"KEEPER_REGISTRY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LINK_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getKeeperInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"upkeep\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct IAaveCLRobotOperator.KeeperInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"refillKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"upkeepContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"amountToFund\",\"type\":\"uint96\"}],\"name\":\"register\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"}],\"name\":\"setGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"withdrawAddress\",\"type\":\"address\"}],\"name\":\"setWithdrawAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"updateGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"withdrawLink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AaveCLRobotOperator", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca00000000000000000000000002777053d6764996e594c3e88af1d58d5363a2e6000000000000000000000000db8e8e2ccb5c033938736aa89fe4fa1edfd15a1d000000000000000000000000f71fc92e2949ccf6a5fd369a0b402ba80bc61e02000000000000000000000000e3fd707583932a99513a5c65c8463de769f5dadf", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}