{"SourceCode": "library LibBytes {\r\n    function addressToBytes32(address addr) external pure returns (bytes32) {\r\n        return bytes32(uint256(uint160(addr)));\r\n    }\r\n\r\n    function bytes32ToAddress(bytes32 _buf) public pure returns (address) {\r\n        return address(uint160(uint256(_buf)));\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                tempBytes := mload(0x40)\r\n\r\n                let lengthmod := and(_length, 31)\r\n\r\n                let mc := add(\r\n                    add(tempBytes, lengthmod),\r\n                    mul(0x20, iszero(lengthmod))\r\n                )\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    let cc := add(\r\n                        add(\r\n                            add(_bytes, lengthmod),\r\n                            mul(0x20, iszero(lengthmod))\r\n                        ),\r\n                        _start\r\n                    )\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addressToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_buf\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "LibBytes", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4162eed2984943ac326bc7cd87c661ba23b821af60aff44d7c7705287c790c18"}