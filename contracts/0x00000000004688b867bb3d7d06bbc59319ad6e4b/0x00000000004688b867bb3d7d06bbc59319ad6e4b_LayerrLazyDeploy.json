{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LayerrLazyDeploy.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {ILayerrLazyDeploy} from \\\"./interfaces/ILayerrLazyDeploy.sol\\\";\\r\\nimport {LayerrProxy} from './LayerrProxy.sol';\\r\\nimport {ILayerrMinter} from \\\"./interfaces/ILayerrMinter.sol\\\";\\r\\nimport {MintOrder} from \\\"./lib/MinterStructs.sol\\\";\\r\\nimport {ReentrancyGuard} from \\\"./lib/ReentrancyGuard.sol\\\";\\r\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\r\\nimport {IAdditionalRefundCalculator} from \\\"./interfaces/IAdditionalRefundCalculator.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title LayerrLazyDeploy\\r\\n * @author 0xth0mas (Layerr)\\r\\n * @notice LayerrLazyDeploy allows for Layerr token contracts to be\\r\\n *         lazily deployed as late as in the same transaction that is \\r\\n *         minting tokens on the contract.\\r\\n * \\r\\n *         This allows for Layerr platform users to create collections\\r\\n *         and sign MintParameters without first deploying the token\\r\\n *         contract.\\r\\n *         \\r\\n *         Gas refunds for deployment and minting transactions are possible\\r\\n *         through gas sponsorships with a wide range of parameters for \\r\\n *         controlling the refund amount and which transactions are eligible\\r\\n *         for a refund.\\r\\n * \\r\\n *         Gas refund calculation logic is extensible with contracts that\\r\\n *         implement IAdditionalRefundCalculator to allow custom logic for\\r\\n *         refund amounts on L2s or for specific transactions.\\r\\n */\\r\\ncontract LayerrLazyDeploy is ILayerrLazyDeploy, ReentrancyGuard {\\r\\n\\r\\n    /// @dev LayerrMinter interface\\r\\n    ILayerrMinter public constant layerrMinter = ILayerrMinter(0x000000000000D58696577347F78259bD376F1BEC);\\r\\n\\r\\n    /// @dev The next gas sponsorship ID that will be assigned when sponsorGas is called\\r\\n    uint256 public nextGasSponsorshipId;\\r\\n    /// @dev mapping of gas sponsorship IDs to the gas sponsorship data\\r\\n    mapping(uint256 => GasSponsorship) public gasSponsorships; \\r\\n\\r\\n    /**\\r\\n     * @inheritdoc ILayerrLazyDeploy\\r\\n     */\\r\\n    function findDeploymentAddress(\\r\\n        bytes32 salt,\\r\\n        bytes calldata constructorArgs\\r\\n    ) external view returns(address deploymentAddress) {\\r\\n        bytes memory creationCode = _getCreationCode(constructorArgs);\\r\\n\\r\\n        deploymentAddress = address(\\r\\n            uint160(                    // downcast to match the address type.\\r\\n                uint256(                  // convert to uint to truncate upper digits.\\r\\n                    keccak256(              // compute the CREATE2 hash using 4 inputs.\\r\\n                        abi.encodePacked(     // pack all inputs to the hash together.\\r\\n                            hex\\\"ff\\\",            // start with 0xff to distinguish from RLP.\\r\\n                            address(this),      // this contract will be the caller.\\r\\n                            salt,               // pass in the supplied salt value.\\r\\n                            keccak256(          // pass in the hash of initialization code.\\r\\n                                abi.encodePacked(\\r\\n                                creationCode\\r\\n                                )\\r\\n                            )\\r\\n                        )\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc ILayerrLazyDeploy\\r\\n     */\\r\\n    function deployContractAndMint(\\r\\n        bytes32 salt,\\r\\n        address expectedDeploymentAddress,\\r\\n        bytes calldata constructorArgs,\\r\\n        MintOrder[] calldata mintOrders,\\r\\n        uint256 gasSponsorshipId\\r\\n    ) external payable NonReentrant {\\r\\n        uint256 startingBalance;\\r\\n        if(gasSponsorshipId > 0) {\\r\\n            startingBalance = _refundPrecheck(gasSponsorshipId);\\r\\n        }\\r\\n        uint256 gasUsedDeploy = _deployContract(salt, expectedDeploymentAddress, false, constructorArgs);\\r\\n        uint256 gasUsedMint = _mint(mintOrders);\\r\\n        if(gasSponsorshipId > 0) {\\r\\n            _processGasRefund(gasSponsorshipId, startingBalance, gasUsedDeploy, gasUsedMint);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc ILayerrLazyDeploy\\r\\n     */\\r\\n    function deployContractAndMintWithERC20(\\r\\n        bytes32 salt,\\r\\n        address expectedDeploymentAddress,\\r\\n        bytes calldata constructorArgs,\\r\\n        MintOrder[] calldata mintOrders,\\r\\n        LazyERC20Payment[] calldata erc20Payments,\\r\\n        uint256 gasSponsorshipId\\r\\n    ) external payable NonReentrant {\\r\\n        uint256 startingBalance;\\r\\n        if(gasSponsorshipId > 0) {\\r\\n            startingBalance = _refundPrecheck(gasSponsorshipId);\\r\\n        }\\r\\n        _collectERC20ForMint(erc20Payments);\\r\\n        uint256 gasUsedDeploy = _deployContract(salt, expectedDeploymentAddress, false, constructorArgs);\\r\\n        uint256 gasUsedMint = _mint(mintOrders);\\r\\n        _returnLeftoverERC20(erc20Payments);\\r\\n        if(gasSponsorshipId > 0) {\\r\\n            _processGasRefund(gasSponsorshipId, startingBalance, gasUsedDeploy, gasUsedMint);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc ILayerrLazyDeploy\\r\\n     */\\r\\n    function deployContract(\\r\\n        bytes32 salt,\\r\\n        address expectedDeploymentAddress,\\r\\n        bool revertIfAlreadyDeployed,\\r\\n        bytes calldata constructorArgs,\\r\\n        uint256 gasSponsorshipId\\r\\n    ) external NonReentrant {\\r\\n        uint256 startingBalance;\\r\\n        if(gasSponsorshipId > 0) {\\r\\n            startingBalance = _refundPrecheck(gasSponsorshipId);\\r\\n        }\\r\\n        uint256 gasUsedDeploy = _deployContract(salt, expectedDeploymentAddress, revertIfAlreadyDeployed, constructorArgs);\\r\\n        if(gasSponsorshipId > 0) {\\r\\n            _processGasRefund(gasSponsorshipId, startingBalance, gasUsedDeploy, 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc ILayerrLazyDeploy\\r\\n     */\\r\\n    function mint(\\r\\n        MintOrder[] calldata mintOrders,\\r\\n        uint256 gasSponsorshipId\\r\\n    ) external payable NonReentrant {\\r\\n        uint256 startingBalance;\\r\\n        if(gasSponsorshipId > 0) {\\r\\n            startingBalance = _refundPrecheck(gasSponsorshipId);\\r\\n        }\\r\\n        uint256 gasUsedMint = _mint(mintOrders);\\r\\n        if(gasSponsorshipId > 0) {\\r\\n            _processGasRefund(gasSponsorshipId, startingBalance, 0, gasUsedMint);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc ILayerrLazyDeploy\\r\\n     */\\r\\n    function mintWithERC20(\\r\\n        MintOrder[] calldata mintOrders,\\r\\n        LazyERC20Payment[] calldata erc20Payments,\\r\\n        uint256 gasSponsorshipId\\r\\n    ) external payable NonReentrant {\\r\\n        uint256 startingBalance;\\r\\n        if(gasSponsorshipId > 0) {\\r\\n            startingBalance = _refundPrecheck(gasSponsorshipId);\\r\\n        }\\r\\n        _collectERC20ForMint(erc20Payments);\\r\\n        uint256 gasUsedMint = _mint(mintOrders);\\r\\n        _returnLeftoverERC20(erc20Payments);\\r\\n        if(gasSponsorshipId > 0) {\\r\\n            _processGasRefund(gasSponsorshipId, startingBalance, 0, gasUsedMint);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc ILayerrLazyDeploy\\r\\n     */\\r\\n    function sponsorGas(\\r\\n        uint24 baseRefundUnits,\\r\\n        uint24 baseRefundUnitsDeploy,\\r\\n        uint24 baseRefundUnitsMint,\\r\\n        bool refundDeploy,\\r\\n        bool refundMint,\\r\\n        uint64 maxRefundUnitsDeploy,\\r\\n        uint64 maxRefundUnitsMint,\\r\\n        uint64 maxBaseFee,\\r\\n        uint64 maxPriorityFee,\\r\\n        address additionalRefundCalculator,\\r\\n        address balanceCheckAddress,\\r\\n        uint96 minimumBalanceIncrement\\r\\n    ) external payable NonReentrant {\\r\\n        GasSponsorship memory newSponsorship;\\r\\n        newSponsorship.sponsor = msg.sender;\\r\\n        newSponsorship.baseRefundUnits = baseRefundUnits;\\r\\n        newSponsorship.baseRefundUnitsDeploy = baseRefundUnitsDeploy;\\r\\n        newSponsorship.baseRefundUnitsMint = baseRefundUnitsMint;\\r\\n        newSponsorship.refundDeploy = refundDeploy;\\r\\n        newSponsorship.refundMint = refundMint;\\r\\n        newSponsorship.maxRefundUnitsDeploy = maxRefundUnitsDeploy;\\r\\n        newSponsorship.maxRefundUnitsMint = maxRefundUnitsMint;\\r\\n        newSponsorship.maxBaseFee = maxBaseFee;\\r\\n        newSponsorship.maxPriorityFee = maxPriorityFee;\\r\\n        newSponsorship.donationAmount = uint96(msg.value);\\r\\n        newSponsorship.additionalRefundCalculator = additionalRefundCalculator;\\r\\n        newSponsorship.balanceCheckAddress = balanceCheckAddress;\\r\\n        newSponsorship.minimumBalanceIncrement = minimumBalanceIncrement;\\r\\n\\r\\n        unchecked {\\r\\n            ++nextGasSponsorshipId;\\r\\n        }\\r\\n        gasSponsorships[nextGasSponsorshipId] = newSponsorship;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc ILayerrLazyDeploy\\r\\n     */\\r\\n    function addToSponsorship(uint256 gasSponsorshipId) external payable NonReentrant {\\r\\n        gasSponsorships[gasSponsorshipId].donationAmount += uint96(msg.value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc ILayerrLazyDeploy\\r\\n     */\\r\\n    function withdrawSponsorship(uint256 gasSponsorshipId) external NonReentrant {\\r\\n        GasSponsorship storage gasSponsorship = gasSponsorships[gasSponsorshipId];\\r\\n\\r\\n        if(msg.sender != gasSponsorship.sponsor) {\\r\\n            revert CallerNotSponsor();\\r\\n        }\\r\\n\\r\\n        uint256 amountRemaining = gasSponsorship.donationAmount - gasSponsorship.amountUsed;\\r\\n        gasSponsorship.donationAmount = gasSponsorship.amountUsed;\\r\\n\\r\\n        (bool success, ) = payable(msg.sender).call{value: amountRemaining}(\\\"\\\");\\r\\n        if(!success) { revert SponsorshipWithdrawFailed(); }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deploys a LayerrProxy contract with the provided `constructorArgs`\\r\\n     */\\r\\n    function _deployContract(\\r\\n        bytes32 salt,\\r\\n        address expectedDeploymentAddress,\\r\\n        bool revertIfAlreadyDeployed,\\r\\n        bytes calldata constructorArgs\\r\\n    ) internal returns(uint256 gasUsed) {\\r\\n        gasUsed = gasleft();\\r\\n\\r\\n        uint256 existingCodeSize;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            existingCodeSize := extcodesize(expectedDeploymentAddress)\\r\\n        }\\r\\n        if(existingCodeSize > 0) {\\r\\n            if(revertIfAlreadyDeployed) {\\r\\n                revert ContractAlreadyDeployed();\\r\\n            } else {\\r\\n                return 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        address deploymentAddress;\\r\\n        bytes memory creationCode = _getCreationCode(constructorArgs);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            deploymentAddress := create2(\\r\\n                0,\\r\\n                add(creationCode, 0x20),\\r\\n                mload(creationCode),\\r\\n                salt\\r\\n            )\\r\\n        }\\r\\n        \\r\\n        if(deploymentAddress != expectedDeploymentAddress) {\\r\\n            revert DeploymentFailed();\\r\\n        }\\r\\n        unchecked {\\r\\n            gasUsed -= gasleft();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the creation code for the LayerrProxy contract with `constructorArgs`\\r\\n     */\\r\\n    function _getCreationCode(bytes calldata constructorArgs) internal pure returns(bytes memory creationCode) {\\r\\n        creationCode = type(LayerrProxy).creationCode;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            calldatacopy(\\r\\n                add(add(creationCode, 0x20), mload(creationCode)), \\r\\n                constructorArgs.offset, \\r\\n                constructorArgs.length\\r\\n            )\\r\\n            mstore(creationCode, add(mload(creationCode), constructorArgs.length))\\r\\n            mstore(0x40, add(creationCode, mload(creationCode)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calls LayerrMinter, calculates gas used and refunds overpayments\\r\\n     */\\r\\n    function _mint(\\r\\n        MintOrder[] calldata mintOrders\\r\\n    ) internal returns(uint256 gasUsed) {\\r\\n        gasUsed = gasleft();\\r\\n        uint256 startBalance = address(this).balance - msg.value;\\r\\n\\r\\n        layerrMinter.mintBatchTo{value: msg.value}(msg.sender, mintOrders, 0);\\r\\n        \\r\\n        uint256 endBalance = address(this).balance;\\r\\n        if(endBalance > startBalance) {\\r\\n            unchecked {\\r\\n                (bool success, ) = payable(msg.sender).call{value: endBalance - startBalance}(\\\"\\\");\\r\\n                if(!success) revert RefundFailed();   \\r\\n            }\\r\\n        }\\r\\n        unchecked {\\r\\n            gasUsed -= gasleft();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Collects ERC20 tokens from the caller, approves payment to LayerrMinter\\r\\n     */\\r\\n    function _collectERC20ForMint(LazyERC20Payment[] calldata erc20Payments) internal {\\r\\n        for(uint256 paymentIndex;paymentIndex < erc20Payments.length;) {\\r\\n            LazyERC20Payment calldata erc20Payment = erc20Payments[paymentIndex];\\r\\n            address tokenAddress = erc20Payment.tokenAddress;\\r\\n            uint256 totalSpend = erc20Payment.totalSpend;\\r\\n            IERC20(tokenAddress).transferFrom(msg.sender, address(this), totalSpend);\\r\\n            IERC20(tokenAddress).approve(address(layerrMinter), totalSpend);\\r\\n            \\r\\n            unchecked {\\r\\n                ++paymentIndex;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns leftover ERC20 tokens to the caller, clears approvals\\r\\n     */\\r\\n    function _returnLeftoverERC20(LazyERC20Payment[] calldata erc20Payments) internal {\\r\\n        for(uint256 paymentIndex;paymentIndex < erc20Payments.length;) {\\r\\n            LazyERC20Payment calldata erc20Payment = erc20Payments[paymentIndex];\\r\\n            address tokenAddress = erc20Payment.tokenAddress;\\r\\n            uint256 remainingBalance = IERC20(tokenAddress).balanceOf(address(this));\\r\\n            if(remainingBalance > 0) {\\r\\n                IERC20(tokenAddress).transfer(msg.sender, remainingBalance);\\r\\n                IERC20(tokenAddress).approve(address(layerrMinter), 0);\\r\\n            }\\r\\n\\r\\n            unchecked {\\r\\n                ++paymentIndex;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates and sends a gas refund to the caller\\r\\n     */\\r\\n    function _processGasRefund(uint256 gasSponsorshipId, uint256 startingBalance, uint256 gasUsedDeploy, uint256 gasUsedMint) internal {\\r\\n        GasSponsorship memory gasSponsorship = gasSponsorships[gasSponsorshipId];\\r\\n\\r\\n        if(gasSponsorship.balanceCheckAddress != address(0)) {\\r\\n            if(gasSponsorship.balanceCheckAddress.balance < (startingBalance + gasSponsorship.minimumBalanceIncrement)) {\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 refundUnits = gasSponsorship.baseRefundUnits;\\r\\n        if(gasUsedDeploy > 0 && gasSponsorship.refundDeploy) {\\r\\n            if(gasSponsorship.maxRefundUnitsDeploy < gasUsedDeploy) {\\r\\n                gasUsedDeploy = gasSponsorship.maxRefundUnitsDeploy;\\r\\n            }\\r\\n            unchecked {\\r\\n                refundUnits = (gasUsedDeploy + gasSponsorship.baseRefundUnitsDeploy);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        if(gasUsedMint > 0 && gasSponsorship.refundMint) {\\r\\n            if(gasSponsorship.maxRefundUnitsMint < gasUsedMint) {\\r\\n                gasUsedMint = gasSponsorship.maxRefundUnitsMint;\\r\\n            }\\r\\n            unchecked {\\r\\n                refundUnits += (gasUsedMint + gasSponsorship.baseRefundUnitsMint);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 totalFee = block.basefee;\\r\\n        if(totalFee > gasSponsorship.maxBaseFee) {\\r\\n            totalFee = gasSponsorship.maxBaseFee;\\r\\n        }\\r\\n        uint256 priorityFee = tx.gasprice - block.basefee;\\r\\n        if(priorityFee > gasSponsorship.maxPriorityFee) {\\r\\n            priorityFee = gasSponsorship.maxPriorityFee;\\r\\n        }\\r\\n        unchecked {\\r\\n            totalFee += priorityFee;\\r\\n        }\\r\\n        uint256 refundAmount = refundUnits * totalFee;\\r\\n\\r\\n        if(gasSponsorship.additionalRefundCalculator != address(0)) {\\r\\n            unchecked {\\r\\n                uint256 calldataLength;\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    calldataLength := calldatasize()\\r\\n                }\\r\\n                refundAmount += IAdditionalRefundCalculator(gasSponsorship.additionalRefundCalculator)\\r\\n                    .calculateAdditionalRefundAmount(msg.sender, calldataLength, gasUsedDeploy, gasUsedMint);   \\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 donationRemaining;\\r\\n        unchecked {\\r\\n            donationRemaining = gasSponsorship.donationAmount - gasSponsorship.amountUsed;\\r\\n        }\\r\\n        if(refundAmount > donationRemaining) {\\r\\n            refundAmount = donationRemaining;\\r\\n        }\\r\\n\\r\\n        gasSponsorships[gasSponsorshipId].amountUsed += uint96(refundAmount);\\r\\n        (bool success, ) = payable(msg.sender).call{value: refundAmount}(\\\"\\\");\\r\\n        if(!success) revert RefundFailed();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Initiates pre-checks for gas refunds\\r\\n     */\\r\\n    function _refundPrecheck(uint256 gasSponsorshipId) internal returns (uint256 startingBalance) {\\r\\n        address additionalRefundCalculator = gasSponsorships[gasSponsorshipId].additionalRefundCalculator;\\r\\n        if(additionalRefundCalculator != address(0)) {\\r\\n            IAdditionalRefundCalculator(additionalRefundCalculator).additionalRefundPrecheck();\\r\\n        }\\r\\n        address balanceCheckAddress = gasSponsorships[gasSponsorshipId].balanceCheckAddress;\\r\\n        if(balanceCheckAddress != address(0)) {\\r\\n            startingBalance = balanceCheckAddress.balance;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev allow LayerrMinter to return excess funds so they can be returned to the caller\\r\\n     */\\r\\n    receive() external payable {\\r\\n        if(msg.sender != address(layerrMinter)) revert DefaultReceiveForMinterOnly();\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev allow LayerrMinter to return excess funds so they can be returned to the caller\\r\\n     */\\r\\n    fallback() external payable {\\r\\n        if(msg.sender != address(layerrMinter)) revert DefaultReceiveForMinterOnly();\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/ILayerrLazyDeploy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {MintOrder} from \\\"../lib/MinterStructs.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ILayerrLazyDeploy\\r\\n * @author 0xth0mas (Layerr)\\r\\n * @notice ILayerrLazyDeploy interface defines functions required for\\r\\n *         lazy deployment/minting and gas refunds.\\r\\n */\\r\\ninterface ILayerrLazyDeploy {\\r\\n\\r\\n    /// @dev Thrown when the deployment address does not match the expected deployment address\\r\\n    error DeploymentFailed();\\r\\n    /// @dev Thrown when a deployment fails and revertIfAlreadyDeployed is true\\r\\n    error ContractAlreadyDeployed();\\r\\n    /// @dev Thrown when a refund fails\\r\\n    error RefundFailed();\\r\\n    /// @dev Thrown when attempting to withdraw sponsored funds sent by another account\\r\\n    error CallerNotSponsor();\\r\\n    /// @dev Thrown when sponsor withdraw fails\\r\\n    error SponsorshipWithdrawFailed();\\r\\n    /// @dev Thrown when a user is attempting to send funds to contract with default receive/fallback\\r\\n    error DefaultReceiveForMinterOnly();\\r\\n\\r\\n    /// @dev Data used to calculate the refund amount for a gas sponsored transaction\\r\\n    struct GasSponsorship {\\r\\n        address sponsor;\\r\\n        uint24 baseRefundUnits;\\r\\n        uint24 baseRefundUnitsDeploy;\\r\\n        uint24 baseRefundUnitsMint;\\r\\n        bool refundDeploy;\\r\\n        bool refundMint;\\r\\n        uint64 maxRefundUnitsDeploy;\\r\\n        uint64 maxRefundUnitsMint;\\r\\n        uint64 maxBaseFee;\\r\\n        uint64 maxPriorityFee;\\r\\n        uint96 donationAmount;\\r\\n        uint96 amountUsed;\\r\\n        address additionalRefundCalculator;\\r\\n        address balanceCheckAddress;\\r\\n        uint96 minimumBalanceIncrement;\\r\\n    }\\r\\n\\r\\n    /// @dev Used for minting lazy deployed contracts with ERC20 tokens\\r\\n    struct LazyERC20Payment {\\r\\n        address tokenAddress;\\r\\n        uint256 totalSpend;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the deployment address for a proxy contract with the provided\\r\\n     *         `salt` and `constructorArgs`. Allows UX to determine what contract address\\r\\n     *          should be used for signing mint parameters.\\r\\n     * @param salt Random value used to generate unique deployment addresses for\\r\\n     *             contracts with the same constructor arguments.\\r\\n     * @param constructorArgs ABI encoded arguments to be passed to the contract constructor.\\r\\n     * @return deploymentAddress The address the contract will be deployed to.\\r\\n     */\\r\\n    function findDeploymentAddress(\\r\\n        bytes32 salt,\\r\\n        bytes calldata constructorArgs\\r\\n    ) external view returns(address deploymentAddress);\\r\\n\\r\\n    /**\\r\\n     * @notice Deploys a token contract and mints in the same transaction.\\r\\n     * @param salt Random value used to generate unique deployment addresses for\\r\\n     *             contracts with the same constructor arguments.\\r\\n     * @param expectedDeploymentAddress The address the contract is expected to deploy at.\\r\\n     *             The transaction will revert if this does not match the actual deployment\\r\\n                   address.\\r\\n     * @param constructorArgs ABI encoded arguments to be passed to the contract constructor.\\r\\n     * @param mintOrders MintOrder array to be passed to the LayerrMinter contract after deployment\\r\\n     * @param gasSponsorshipId If non-zero, gasSponsorshipId will be used to determine the parameters\\r\\n     *                         for a gas refund.\\r\\n     */\\r\\n    function deployContractAndMint(\\r\\n        bytes32 salt,\\r\\n        address expectedDeploymentAddress,\\r\\n        bytes calldata constructorArgs,\\r\\n        MintOrder[] calldata mintOrders,\\r\\n        uint256 gasSponsorshipId\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Deploys a token contract and mints in the same transaction with ERC20 tokens.\\r\\n     * @param salt Random value used to generate unique deployment addresses for\\r\\n     *             contracts with the same constructor arguments.\\r\\n     * @param expectedDeploymentAddress The address the contract is expected to deploy at.\\r\\n     *             The transaction will revert if this does not match the actual deployment\\r\\n                   address.\\r\\n     * @param constructorArgs ABI encoded arguments to be passed to the contract constructor.\\r\\n     * @param mintOrders MintOrder array to be passed to the LayerrMinter contract after deployment\\r\\n     * @param erc20Payments Array of items containing the ERC20 tokens to be pulled from caller for minting.\\r\\n     * @param gasSponsorshipId If non-zero, gasSponsorshipId will be used to determine the parameters\\r\\n     *                   for a gas refund.\\r\\n     */\\r\\n    function deployContractAndMintWithERC20(\\r\\n        bytes32 salt,\\r\\n        address expectedDeploymentAddress,\\r\\n        bytes calldata constructorArgs,\\r\\n        MintOrder[] calldata mintOrders,\\r\\n        LazyERC20Payment[] calldata erc20Payments,\\r\\n        uint256 gasSponsorshipId\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Deploys a token contract.\\r\\n     * @param salt Random value used to generate unique deployment addresses for\\r\\n     *             contracts with the same constructor arguments.\\r\\n     * @param expectedDeploymentAddress The address the contract is expected to deploy at.\\r\\n     *             The transaction will revert if this does not match the actual deployment\\r\\n                   address.\\r\\n     * @param constructorArgs ABI encoded arguments to be passed to the contract constructor.\\r\\n     * @param gasSponsorshipId If non-zero, gasSponsorshipId will be used to determine the parameters\\r\\n     *                         for a gas refund.\\r\\n     */\\r\\n    function deployContract(\\r\\n        bytes32 salt,\\r\\n        address expectedDeploymentAddress,\\r\\n        bool revertIfAlreadyDeployed,\\r\\n        bytes calldata constructorArgs,\\r\\n        uint256 gasSponsorshipId\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Calls the LayerrMinter contract with `mintOrders` and processes a gas refund.\\r\\n     * @param mintOrders MintOrder array to be passed to the LayerrMinter contract after deployment\\r\\n     * @param gasSponsorshipId If non-zero, gasSponsorshipId will be used to determine the parameters\\r\\n     *                         for a gas refund.\\r\\n     */\\r\\n    function mint(\\r\\n        MintOrder[] calldata mintOrders,\\r\\n        uint256 gasSponsorshipId\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Calls the LayerrMinter contract with `mintOrders` and ERC20 tokens and processes a gas refund.\\r\\n     * @param mintOrders MintOrder array to be passed to the LayerrMinter contract after deployment\\r\\n     * @param erc20Payments Array of items containing the ERC20 tokens to be pulled from caller for minting.\\r\\n     * @param gasSponsorshipId If non-zero, gasSponsorshipId will be used to determine the parameters\\r\\n     *                         for a gas refund.\\r\\n     */\\r\\n    function mintWithERC20(\\r\\n        MintOrder[] calldata mintOrders,\\r\\n        LazyERC20Payment[] calldata erc20Payments,\\r\\n        uint256 gasSponsorshipId\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Provide a gas sponsorship for transactions deploying contracts or minting.\\r\\n     * @param baseRefundUnits Base amount of gas units to use in a refund calculation\\r\\n     * @param baseRefundUnitsDeploy Additional base amount of gas units to use for a deployment\\r\\n     * @param baseRefundUnitsMint Additional base amount of gas units to use for minting\\r\\n     * @param refundDeploy If true, deployment gas will be used to calculate a refund\\r\\n     * @param refundMint If true, minting gas will be used to calculate a refund\\r\\n     * @param maxRefundUnitsDeploy Maximum number of gas units that will be refunded for a deployment\\r\\n     * @param maxRefundUnitsMint  Maximum number of gas units that will be refunded for a mint\\r\\n     * @param maxBaseFee The max base fee to be used for gas refunds\\r\\n     * @param maxPriorityFee The max priority fee to be used for gas refunds\\r\\n     * @param additionalRefundCalculator If non-zero, an implementation of IAdditionalRefundCalculator\\r\\n     *                                   to call to calculate an additional refund amount.\\r\\n     * @param balanceCheckAddress If non-zero, an address to check for a native token balance increase \\r\\n     *                            from the mint transaction.\\r\\n     * @param minimumBalanceIncrement The minimum amount the balance check address's balance needs to \\r\\n     *                                increase to allow the gas refund.\\r\\n     */\\r\\n    function sponsorGas(\\r\\n        uint24 baseRefundUnits,\\r\\n        uint24 baseRefundUnitsDeploy,\\r\\n        uint24 baseRefundUnitsMint,\\r\\n        bool refundDeploy,\\r\\n        bool refundMint,\\r\\n        uint64 maxRefundUnitsDeploy,\\r\\n        uint64 maxRefundUnitsMint,\\r\\n        uint64 maxBaseFee,\\r\\n        uint64 maxPriorityFee,\\r\\n        address additionalRefundCalculator,\\r\\n        address balanceCheckAddress,\\r\\n        uint96 minimumBalanceIncrement\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Callable by any address to add funds to a gas sponsorship\\r\\n     * @param gasSponsorshipId The ID of the gas sponsorship to add funds to\\r\\n     */\\r\\n    function addToSponsorship(uint256 gasSponsorshipId) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Callable by the gas sponsor to withdraw their sponsorship funds\\r\\n     * @param gasSponsorshipId The ID of the gas sponsorship to withdraw\\r\\n     */\\r\\n    function withdrawSponsorship(uint256 gasSponsorshipId) external;\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IAdditionalRefundCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @title IAdditionalRefundCalculator\\r\\n * @author 0xth0mas (Layerr)\\r\\n * @notice IAdditionalRefundCalculator interface defines functions required for\\r\\n *         providing additional refund amounts in lazy deploys/mints.\\r\\n *         This can be implemented to provide refunds for rollup transaction fees\\r\\n *         or to pay refunds for any sort of transaction at the discretion of the \\r\\n *         gas sponsor.\\r\\n */\\r\\ninterface IAdditionalRefundCalculator {\\r\\n\\r\\n    /**\\r\\n     * @notice Allows an external gas refund calculator to perform additional\\r\\n     *         checks prior to deployment and minting transactions being processed\\r\\n     *         to validate the gas refund amount the sponsor is going to provide.\\r\\n     */\\r\\n    function additionalRefundPrecheck() external;\\r\\n\\r\\n    /**\\r\\n     * @notice Called from LayerrLazyDeploy to calculate an additional refund \\r\\n     *         for a deploy or mint transaction that is being gas sponsored.\\r\\n     *         The IAdditionalRefundCalculator implementation address is defined\\r\\n     *         by the gas sponsor and refunds out of the amount deposited to\\r\\n     *         LayerrLazyDeploy.\\r\\n     * @param caller Address of the account that is calling LayerrLazyDeploy\\r\\n     * @param calldataLength The length of calldata sent to LayerrLazyDeploy\\r\\n     * @param gasUsedDeploy The amount of gas used for deployment\\r\\n     * @param gasUsedMint The amount of gas used for minting\\r\\n     * @return additionalRefundAmount The amount of native token to add to a refund\\r\\n     */\\r\\n    function calculateAdditionalRefundAmount(\\r\\n        address caller,\\r\\n        uint256 calldataLength,\\r\\n        uint256 gasUsedDeploy,\\r\\n        uint256 gasUsedMint\\r\\n    ) external view returns(uint256 additionalRefundAmount);\\r\\n}\"\r\n    },\r\n    \"contracts/LayerrProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {StringValue} from \\\"./lib/StorageTypes.sol\\\";\\r\\nimport {AddressValue} from \\\"./lib/StorageTypes.sol\\\";\\r\\nimport {ILayerrMinter} from \\\"./interfaces/ILayerrMinter.sol\\\";\\r\\nimport {LAYERROWNABLE_OWNER_SLOT, LAYERRTOKEN_NAME_SLOT, LAYERRTOKEN_SYMBOL_SLOT, LAYERRTOKEN_RENDERER_SLOT} from \\\"./common/LayerrStorage.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title LayerrProxy\\r\\n * @author 0xth0mas (Layerr)\\r\\n * @notice A proxy contract that serves as an interface for interacting with \\r\\n *         Layerr tokens. At deployment it sets token properties and contract \\r\\n *         ownership, initializes signers and mint extensions, and configures \\r\\n *         royalties.\\r\\n */\\r\\ncontract LayerrProxy {\\r\\n\\r\\n    /// @dev the implementation address for the proxy contract\\r\\n    address immutable proxy;\\r\\n\\r\\n    /// @dev this is included as a hint for block explorers\\r\\n    bytes32 private constant PROXY_IMPLEMENTATION_REFERENCE = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n\\r\\n    /// @dev Thrown when a required initialization call fails\\r\\n    error DeploymentFailed();\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the proxy contract\\r\\n     * @param _owner initial owner of the token contract\\r\\n     * @param _proxy implementation address for the proxy contract\\r\\n     * @param _name token contract name\\r\\n     * @param _symbol token contract symbol\\r\\n     * @param royaltyPct default royalty percentage in BPS\\r\\n     * @param royaltyReceiver default royalty receiver\\r\\n     * @param operatorFilterRegistry address of the operator filter registry to subscribe to\\r\\n     * @param _extension minting extension to use with the token contract\\r\\n     * @param _renderer renderer to use with the token contract\\r\\n     * @param _signers array of allowed signers for the mint extension\\r\\n     */\\r\\n    constructor(\\r\\n        address _owner,\\r\\n        address _proxy, \\r\\n        string memory _name, \\r\\n        string memory _symbol, \\r\\n        uint96 royaltyPct, \\r\\n        address royaltyReceiver, \\r\\n        address operatorFilterRegistry, \\r\\n        address _extension, \\r\\n        address _renderer, \\r\\n        address[] memory _signers\\r\\n    ) {\\r\\n        proxy = _proxy; \\r\\n\\r\\n        StringValue storage name;\\r\\n        StringValue storage symbol;\\r\\n        AddressValue storage renderer;\\r\\n        AddressValue storage owner;\\r\\n        AddressValue storage explorerProxy;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            name.slot := LAYERRTOKEN_NAME_SLOT\\r\\n            symbol.slot := LAYERRTOKEN_SYMBOL_SLOT\\r\\n            renderer.slot := LAYERRTOKEN_RENDERER_SLOT\\r\\n            owner.slot := LAYERROWNABLE_OWNER_SLOT\\r\\n            explorerProxy.slot := PROXY_IMPLEMENTATION_REFERENCE\\r\\n        } \\r\\n        name.value = _name;\\r\\n        symbol.value = _symbol;\\r\\n        renderer.value = _renderer;\\r\\n        owner.value = msg.sender;\\r\\n        explorerProxy.value = _proxy;\\r\\n\\r\\n        uint256 signersLength = _signers.length;\\r\\n        for(uint256 signerIndex;signerIndex < signersLength;) {\\r\\n            ILayerrMinter(_extension).setContractAllowedSigner(_signers[signerIndex], true);\\r\\n            unchecked {\\r\\n                ++signerIndex;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        (bool success, ) = _proxy.delegatecall(abi.encodeWithSignature(\\\"setRoyalty(uint96,address)\\\", royaltyPct, royaltyReceiver));\\r\\n        if(!success) revert DeploymentFailed();\\r\\n\\r\\n        (success, ) = _proxy.delegatecall(abi.encodeWithSignature(\\\"setOperatorFilter(address)\\\", operatorFilterRegistry));\\r\\n        //this item may fail if deploying a contract that does not use an operator filter\\r\\n\\r\\n        (success, ) = _proxy.delegatecall(abi.encodeWithSignature(\\\"setMintExtension(address,bool)\\\", _extension, true));\\r\\n        if(!success) revert DeploymentFailed();\\r\\n\\r\\n        (success, ) = _proxy.delegatecall(abi.encodeWithSignature(\\\"initialize()\\\"));\\r\\n        if(!success) revert DeploymentFailed();\\r\\n\\r\\n        owner.value = _owner;\\r\\n    }\\r\\n\\r\\n    fallback() external payable {\\r\\n        address _proxy = proxy;\\r\\n        assembly {\\r\\n            calldatacopy(0x0, 0x0, calldatasize())\\r\\n            let result := delegatecall(gas(), _proxy, 0x0, calldatasize(), 0x0, 0)\\r\\n            returndatacopy(0x0, 0x0, returndatasize())\\r\\n            switch result case 0 {revert(0, returndatasize())} default {return (0, returndatasize())}\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/ILayerrMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {MintOrder, MintParameters, MintToken, BurnToken, PaymentToken} from \\\"../lib/MinterStructs.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ILayerrMinter\\r\\n * @author 0xth0mas (Layerr)\\r\\n * @notice ILayerrMinter interface defines functions required in the LayerrMinter to be callable by token contracts\\r\\n */\\r\\ninterface ILayerrMinter {\\r\\n\\r\\n    /// @dev Event emitted when a mint order is fulfilled\\r\\n    event MintOrderFulfilled(\\r\\n        bytes32 indexed mintParametersDigest,\\r\\n        address indexed minter,\\r\\n        uint256 indexed quantity\\r\\n    );\\r\\n\\r\\n    /// @dev Event emitted when a token contract updates an allowed signer for EIP712 signatures\\r\\n    event ContractAllowedSignerUpdate(\\r\\n        address indexed _contract,\\r\\n        address indexed _signer,\\r\\n        bool indexed _allowed\\r\\n    );\\r\\n\\r\\n    /// @dev Event emitted when a token contract updates an allowed oracle signer for offchain authorization of a wallet to use a signature\\r\\n    event ContractOracleUpdated(\\r\\n        address indexed _contract,\\r\\n        address indexed _oracle,\\r\\n        bool indexed _allowed\\r\\n    );\\r\\n\\r\\n    /// @dev Event emitted when a signer updates their nonce with LayerrMinter. Updating a nonce invalidates all previously signed EIP712 signatures.\\r\\n    event SignerNonceIncremented(\\r\\n        address indexed _signer,\\r\\n        uint256 indexed _nonce\\r\\n    );\\r\\n\\r\\n    /// @dev Event emitted when a specific signature's validity is updated with the LayerrMinter contract.\\r\\n    event SignatureValidityUpdated(\\r\\n        address indexed _contract,\\r\\n        bool indexed invalid,\\r\\n        bytes32 mintParametersDigests\\r\\n    );\\r\\n\\r\\n    /// @dev Thrown when the amount of native tokens supplied in msg.value is insufficient for the mint order\\r\\n    error InsufficientPayment();\\r\\n\\r\\n    /// @dev Thrown when a payment fails to be forwarded to the intended recipient\\r\\n    error PaymentFailed();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters payment token uses a token type value other than native or ERC20\\r\\n    error InvalidPaymentTokenType();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters burn token uses a token type value other than ERC20, ERC721 or ERC1155\\r\\n    error InvalidBurnTokenType();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters mint token uses a token type value other than ERC20, ERC721 or ERC1155\\r\\n    error InvalidMintTokenType();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters burn token uses a burn type value other than contract burn or send to dead\\r\\n    error InvalidBurnType();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters burn token requires a specific burn token id and the tokenId supplied does not match\\r\\n    error InvalidBurnTokenId();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters burn token requires a specific ERC721 token and the burn amount is greater than 1\\r\\n    error CannotBurnMultipleERC721WithSameId();\\r\\n\\r\\n    /// @dev Thrown when attempting to mint with MintParameters that have a start time greater than the current block time\\r\\n    error MintHasNotStarted();\\r\\n\\r\\n    /// @dev Thrown when attempting to mint with MintParameters that have an end time less than the current block time\\r\\n    error MintHasEnded();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters has a merkleroot set but the supplied merkle proof is invalid\\r\\n    error InvalidMerkleProof();\\r\\n\\r\\n    /// @dev Thrown when a MintOrder will cause a token's minted supply to exceed the defined maximum supply in MintParameters\\r\\n    error MintExceedsMaxSupply();\\r\\n\\r\\n    /// @dev Thrown when a MintOrder will cause a minter's minted amount to exceed the defined max per wallet in MintParameters\\r\\n    error MintExceedsMaxPerWallet();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters mint token has a specific ERC721 token and the mint amount is greater than 1\\r\\n    error CannotMintMultipleERC721WithSameId();\\r\\n\\r\\n    /// @dev Thrown when the recovered signer for the MintParameters is not an allowed signer for the mint token\\r\\n    error NotAllowedSigner();\\r\\n\\r\\n    /// @dev Thrown when the recovered signer's nonce does not match the current nonce in LayerrMinter\\r\\n    error SignerNonceInvalid();\\r\\n\\r\\n    /// @dev Thrown when a signature has been marked as invalid for a mint token contract\\r\\n    error SignatureInvalid();\\r\\n\\r\\n    /// @dev Thrown when MintParameters requires an oracle signature and the recovered signer is not an allowed oracle for the contract\\r\\n    error InvalidOracleSignature();\\r\\n\\r\\n    /// @dev Thrown when MintParameters has a max signature use set and the MintOrder will exceed the maximum uses\\r\\n    error ExceedsMaxSignatureUsage();\\r\\n\\r\\n    /// @dev Thrown when attempting to increment nonce on behalf of another account and the signature is invalid\\r\\n    error InvalidSignatureToIncrementNonce();\\r\\n\\r\\n    /**\\r\\n     * @notice This function is called by token contracts to update allowed signers for minting\\r\\n     * @param _signer address of the EIP712 signer\\r\\n     * @param _allowed if the `_signer` is allowed to sign for minting\\r\\n     */\\r\\n    function setContractAllowedSigner(address _signer, bool _allowed) external;\\r\\n\\r\\n    /**\\r\\n     * @notice This function is called by token contracts to update allowed oracles for offchain authorizations\\r\\n     * @param _oracle address of the oracle\\r\\n     * @param _allowed if the `_oracle` is allowed to sign offchain authorizations\\r\\n     */\\r\\n    function setContractAllowedOracle(address _oracle, bool _allowed) external;\\r\\n\\r\\n    /**\\r\\n     * @notice This function is called by token contracts to update validity of signatures for the LayerrMinter contract\\r\\n     * @dev `invalid` should be true to invalidate signatures, the default state of `invalid` being false means \\r\\n     *      a signature is valid for a contract assuming all other conditions are met\\r\\n     * @param mintParametersDigests an array of message digests for MintParameters to update validity of\\r\\n     * @param invalid if the supplied digests will be marked as valid or invalid\\r\\n     */\\r\\n    function setSignatureValidity(\\r\\n        bytes32[] calldata mintParametersDigests,\\r\\n        bool invalid\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Increments the nonce for a signer to invalidate all previous signed MintParameters\\r\\n     */\\r\\n    function incrementSignerNonce() external;\\r\\n\\r\\n    /**\\r\\n     * @notice Increments the nonce on behalf of another account by validating a signature from that account\\r\\n     * @dev The signature is an eth personal sign message of the current signer nonce plus the chain id\\r\\n     *      ex. current nonce 0 on chain 5 would be a signature of \\\\x19Ethereum Signed Message:\\\\n15\\r\\n     *          current nonce 50 on chain 1 would be a signature of \\\\x19Ethereum Signed Message:\\\\n251\\r\\n     * @param signer account to increment nonce for\\r\\n     * @param signature signature proof that the request is coming from the account\\r\\n     */\\r\\n    function incrementNonceFor(address signer, bytes calldata signature) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Validates and processes a single MintOrder, tokens are minted to msg.sender\\r\\n     * @param mintOrder struct containing the details of the mint order\\r\\n     */\\r\\n    function mint(\\r\\n        MintOrder calldata mintOrder\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Validates and processes an array of MintOrders, tokens are minted to msg.sender\\r\\n     * @param mintOrders array of structs containing the details of the mint orders\\r\\n     */\\r\\n    function mintBatch(\\r\\n        MintOrder[] calldata mintOrders\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Validates and processes a single MintOrder, tokens are minted to `mintToWallet`\\r\\n     * @param mintToWallet the address tokens will be minted to\\r\\n     * @param mintOrder struct containing the details of the mint order\\r\\n     * @param paymentContext Contextual information related to the payment process\\r\\n     *                     (Note: This parameter is required for integration with \\r\\n     *                     the payment processor and does not impact the behavior \\r\\n     *                     of the function)\\r\\n     */\\r\\n    function mintTo(\\r\\n        address mintToWallet,\\r\\n        MintOrder calldata mintOrder,\\r\\n        uint256 paymentContext\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Validates and processes an array of MintOrders, tokens are minted to `mintToWallet`\\r\\n     * @param mintToWallet the address tokens will be minted to\\r\\n     * @param mintOrders array of structs containing the details of the mint orders\\r\\n     * @param paymentContext Contextual information related to the payment process\\r\\n     *                     (Note: This parameter is required for integration with \\r\\n     *                     the payment processor and does not impact the behavior \\r\\n     *                     of the function)\\r\\n     */\\r\\n    function mintBatchTo(\\r\\n        address mintToWallet,\\r\\n        MintOrder[] calldata mintOrders,\\r\\n        uint256 paymentContext\\r\\n    ) external payable;\\r\\n}\"\r\n    },\r\n    \"contracts/common/LayerrStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/// @dev Storage slot for current owner calculated from keccak256('Layerr.LayerrOwnable.owner')\\r\\nbytes32 constant LAYERROWNABLE_OWNER_SLOT = 0xedc628ad38a73ae7d50600532f1bf21da1bfb1390b4f8174f361aca54d4c6b66;\\r\\n\\r\\n/// @dev Storage slot for pending ownership transfer calculated from keccak256('Layerr.LayerrOwnable.newOwner')\\r\\nbytes32 constant LAYERROWNABLE_NEW_OWNER_SLOT = 0x15c115ab76de082272ae65126522082d4aad634b6478097549f84086af3b84bc;\\r\\n\\r\\n/// @dev Storage slot for token name calculated from keccak256('Layerr.LayerrToken.name')\\r\\nbytes32 constant LAYERRTOKEN_NAME_SLOT = 0x7f84c61ed30727f282b62cab23f49ac7f4d263f04a4948416b7b9ba7f34a20dc;\\r\\n\\r\\n/// @dev Storage slot for token symbol calculated from keccak256('Layerr.LayerrToken.symbol')\\r\\nbytes32 constant LAYERRTOKEN_SYMBOL_SLOT = 0xdc0f2363b26c589c72caecd2357dae5fee235863060295a057e8d69d61a96d8a;\\r\\n\\r\\n/// @dev Storage slot for URI renderer calculated from keccak256('Layerr.LayerrToken.renderer')\\r\\nbytes32 constant LAYERRTOKEN_RENDERER_SLOT = 0x395b7021d979c3dbed0f5d530785632316942232113ba3dbe325dc167550e320;\"\r\n    },\r\n    \"contracts/lib/MinterStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev EIP712 Domain for signature verification\\r\\n */\\r\\nstruct EIP712Domain {\\r\\n    string name;\\r\\n    string version;\\r\\n    uint256 chainId;\\r\\n    address verifyingContract;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev MintOrders contain MintParameters as defined by a token creator\\r\\n *      along with proofs required to validate the MintParameters and \\r\\n *      parameters specific to the mint being performed.\\r\\n * \\r\\n *      `mintParameters` are the parameters signed by the token creator\\r\\n *      `quantity` is a multiplier for mintTokens, burnTokens and paymentTokens\\r\\n *          defined in mintParameters\\r\\n *      `mintParametersSignature` is the signature from the token creator\\r\\n *      `oracleSignature` is a signature of the hash of the mintParameters digest \\r\\n *          and msg.sender. The recovered signer must be an allowed oracle for \\r\\n *          the token contract if oracleSignatureRequired is true for mintParameters.\\r\\n *      `merkleProof` is the proof that is checked if merkleRoot is not bytes(0) in\\r\\n *          mintParameters\\r\\n *      `suppliedBurnTokenIds` is an array of tokenIds to be used when processing\\r\\n *          burnTokens. There must be one item in the array for each ERC1155 burnToken\\r\\n *          regardless of `quantity` and `quantity` items in the array for each ERC721\\r\\n *          burnToken.\\r\\n *      `referrer` is the address that will receive a portion of a paymentToken if\\r\\n *          not address(0) and paymentToken's referralBPS is greater than 0\\r\\n *      `vaultWallet` is used for allowlist mints if the msg.sender address it not on\\r\\n *          the allowlist but their delegate.cash vault wallet is.\\r\\n *      \\r\\n */\\r\\nstruct MintOrder {\\r\\n    MintParameters mintParameters;\\r\\n    uint256 quantity;\\r\\n    bytes mintParametersSignature;\\r\\n    bytes oracleSignature;\\r\\n    bytes32[] merkleProof;\\r\\n    uint256[] suppliedBurnTokenIds;\\r\\n    address referrer;\\r\\n    address vaultWallet;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev MintParameters define the tokens to be minted and conditions that must be met\\r\\n *      for the mint to be successfully processed.\\r\\n * \\r\\n *      `mintTokens` is an array of tokens that will be minted\\r\\n *      `burnTokens` is an array of tokens required to be burned\\r\\n *      `paymentTokens` is an array of tokens required as payment\\r\\n *      `startTime` is the UTC timestamp of when the mint will start\\r\\n *      `endTime` is the UTC timestamp of when the mint will end\\r\\n *      `signatureMaxUses` limits the number of mints that can be performed with the\\r\\n *          specific mintParameters/signature\\r\\n *      `merkleRoot` is the root of the merkletree for allowlist minting\\r\\n *      `nonce` is the signer nonce that can be incremented on the LayerrMinter \\r\\n *          contract to invalidate all previous signatures\\r\\n *      `oracleSignatureRequired` if true requires a secondary signature to process the mint\\r\\n */\\r\\nstruct MintParameters {\\r\\n    MintToken[] mintTokens;\\r\\n    BurnToken[] burnTokens;\\r\\n    PaymentToken[] paymentTokens;\\r\\n    uint256 startTime;\\r\\n    uint256 endTime;\\r\\n    uint256 signatureMaxUses;\\r\\n    bytes32 merkleRoot;\\r\\n    uint256 nonce;\\r\\n    bool oracleSignatureRequired;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Defines the token that will be minted\\r\\n *      \\r\\n *      `contractAddress` address of contract to mint tokens from\\r\\n *      `specificTokenId` used for ERC721 - \\r\\n *          if true, mint is non-sequential ERC721\\r\\n *          if false, mint is sequential ERC721A\\r\\n *      `tokenType` is the type of token being minted defined in TokenTypes.sol\\r\\n *      `tokenId` the tokenId to mint if specificTokenId is true\\r\\n *      `mintAmount` is the quantity to be minted\\r\\n *      `maxSupply` is checked against the total minted amount at time of mint\\r\\n *          minting reverts if `mintAmount` * `quantity` will cause total minted to \\r\\n *          exceed `maxSupply`\\r\\n *      `maxMintPerWallet` is checked against the number minted for the wallet\\r\\n *          minting reverts if `mintAmount` * `quantity` will cause wallet minted to \\r\\n *          exceed `maxMintPerWallet`\\r\\n */\\r\\nstruct MintToken {\\r\\n    address contractAddress;\\r\\n    bool specificTokenId;\\r\\n    uint256 tokenType;\\r\\n    uint256 tokenId;\\r\\n    uint256 mintAmount;\\r\\n    uint256 maxSupply;\\r\\n    uint256 maxMintPerWallet;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Defines the token that will be burned\\r\\n *      \\r\\n *      `contractAddress` address of contract to burn tokens from\\r\\n *      `specificTokenId` specifies if the user has the option of choosing any token\\r\\n *          from the contract or if they must burn a specific token\\r\\n *      `tokenType` is the type of token being burned, defined in TokenTypes.sol\\r\\n *      `burnType` is the type of burn to perform, burn function call or transfer to \\r\\n *          dead address, defined in BurnType.sol\\r\\n *      `tokenId` the tokenId to burn if specificTokenId is true\\r\\n *      `burnAmount` is the quantity to be burned\\r\\n */\\r\\nstruct BurnToken {\\r\\n    address contractAddress;\\r\\n    bool specificTokenId;\\r\\n    uint256 tokenType;\\r\\n    uint256 burnType;\\r\\n    uint256 tokenId;\\r\\n    uint256 burnAmount;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Defines the token that will be used for payment\\r\\n *      \\r\\n *      `contractAddress` address of contract to for payment if ERC20\\r\\n *          if tokenType is native token then this should be set to 0x000...000\\r\\n *          to save calldata gas units\\r\\n *      `tokenType` is the type of token being used for payment, defined in TokenTypes.sol\\r\\n *      `payTo` the address that will receive the payment\\r\\n *      `paymentAmount` the amount for the payment in base units for the token\\r\\n *          ex. a native payment on Ethereum for 1 ETH would be specified in wei\\r\\n *          which would be 1**18 wei\\r\\n *      `referralBPS` is the percentage of the payment in BPS that will be sent to the \\r\\n *          `referrer` on the MintOrder if `referralBPS` is greater than 0 and `referrer`\\r\\n *          is not address(0)\\r\\n */\\r\\nstruct PaymentToken {\\r\\n    address contractAddress;\\r\\n    uint256 tokenType;\\r\\n    address payTo;\\r\\n    uint256 paymentAmount;\\r\\n    uint256 referralBPS;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @title ReentrancyGuard\\r\\n * @author 0xth0mas (Layerr)\\r\\n * @notice Simple reentrancy guard to prevent callers from re-entering the LayerrMinter mint functions\\r\\n */\\r\\ncontract ReentrancyGuard {\\r\\n    uint256 private _reentrancyGuard = 1;\\r\\n    error ReentrancyProhibited();\\r\\n\\r\\n    modifier NonReentrant() {\\r\\n        if (_reentrancyGuard > 1) {\\r\\n            revert ReentrancyProhibited();\\r\\n        }\\r\\n        _reentrancyGuard = 2;\\r\\n        _;\\r\\n        _reentrancyGuard = 1;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/StorageTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/// @dev Simple struct to store a string value in a custom storage slot\\r\\nstruct StringValue {\\r\\n    string value;\\r\\n}\\r\\n\\r\\n/// @dev Simple struct to store an address value in a custom storage slot\\r\\nstruct AddressValue {\\r\\n    address value;\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 33333\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"CallerNotSponsor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractAlreadyDeployed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DefaultReceiveForMinterOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeploymentFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyProhibited\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RefundFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SponsorshipWithdrawFailed\",\"type\":\"error\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasSponsorshipId\",\"type\":\"uint256\"}],\"name\":\"addToSponsorship\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"expectedDeploymentAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"revertIfAlreadyDeployed\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"constructorArgs\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasSponsorshipId\",\"type\":\"uint256\"}],\"name\":\"deployContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"expectedDeploymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"constructorArgs\",\"type\":\"bytes\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"specificTokenId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxMintPerWallet\",\"type\":\"uint256\"}],\"internalType\":\"struct MintToken[]\",\"name\":\"mintTokens\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"specificTokenId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BurnToken[]\",\"name\":\"burnTokens\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"payTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralBPS\",\"type\":\"uint256\"}],\"internalType\":\"struct PaymentToken[]\",\"name\":\"paymentTokens\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"signatureMaxUses\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"oracleSignatureRequired\",\"type\":\"bool\"}],\"internalType\":\"struct MintParameters\",\"name\":\"mintParameters\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"mintParametersSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"oracleSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"suppliedBurnTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultWallet\",\"type\":\"address\"}],\"internalType\":\"struct MintOrder[]\",\"name\":\"mintOrders\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"gasSponsorshipId\",\"type\":\"uint256\"}],\"name\":\"deployContractAndMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"expectedDeploymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"constructorArgs\",\"type\":\"bytes\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"specificTokenId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxMintPerWallet\",\"type\":\"uint256\"}],\"internalType\":\"struct MintToken[]\",\"name\":\"mintTokens\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"specificTokenId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BurnToken[]\",\"name\":\"burnTokens\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"payTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralBPS\",\"type\":\"uint256\"}],\"internalType\":\"struct PaymentToken[]\",\"name\":\"paymentTokens\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"signatureMaxUses\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"oracleSignatureRequired\",\"type\":\"bool\"}],\"internalType\":\"struct MintParameters\",\"name\":\"mintParameters\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"mintParametersSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"oracleSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"suppliedBurnTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultWallet\",\"type\":\"address\"}],\"internalType\":\"struct MintOrder[]\",\"name\":\"mintOrders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSpend\",\"type\":\"uint256\"}],\"internalType\":\"struct ILayerrLazyDeploy.LazyERC20Payment[]\",\"name\":\"erc20Payments\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"gasSponsorshipId\",\"type\":\"uint256\"}],\"name\":\"deployContractAndMintWithERC20\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"constructorArgs\",\"type\":\"bytes\"}],\"name\":\"findDeploymentAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gasSponsorships\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"baseRefundUnits\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"baseRefundUnitsDeploy\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"baseRefundUnitsMint\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"refundDeploy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"refundMint\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"maxRefundUnitsDeploy\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxRefundUnitsMint\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxBaseFee\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxPriorityFee\",\"type\":\"uint64\"},{\"internalType\":\"uint96\",\"name\":\"donationAmount\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"amountUsed\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"additionalRefundCalculator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"balanceCheckAddress\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minimumBalanceIncrement\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"layerrMinter\",\"outputs\":[{\"internalType\":\"contract ILayerrMinter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"specificTokenId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxMintPerWallet\",\"type\":\"uint256\"}],\"internalType\":\"struct MintToken[]\",\"name\":\"mintTokens\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"specificTokenId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BurnToken[]\",\"name\":\"burnTokens\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"payTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralBPS\",\"type\":\"uint256\"}],\"internalType\":\"struct PaymentToken[]\",\"name\":\"paymentTokens\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"signatureMaxUses\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"oracleSignatureRequired\",\"type\":\"bool\"}],\"internalType\":\"struct MintParameters\",\"name\":\"mintParameters\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"mintParametersSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"oracleSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"suppliedBurnTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultWallet\",\"type\":\"address\"}],\"internalType\":\"struct MintOrder[]\",\"name\":\"mintOrders\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"gasSponsorshipId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"specificTokenId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxMintPerWallet\",\"type\":\"uint256\"}],\"internalType\":\"struct MintToken[]\",\"name\":\"mintTokens\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"specificTokenId\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BurnToken[]\",\"name\":\"burnTokens\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"payTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralBPS\",\"type\":\"uint256\"}],\"internalType\":\"struct PaymentToken[]\",\"name\":\"paymentTokens\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"signatureMaxUses\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"oracleSignatureRequired\",\"type\":\"bool\"}],\"internalType\":\"struct MintParameters\",\"name\":\"mintParameters\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"mintParametersSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"oracleSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"suppliedBurnTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultWallet\",\"type\":\"address\"}],\"internalType\":\"struct MintOrder[]\",\"name\":\"mintOrders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSpend\",\"type\":\"uint256\"}],\"internalType\":\"struct ILayerrLazyDeploy.LazyERC20Payment[]\",\"name\":\"erc20Payments\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"gasSponsorshipId\",\"type\":\"uint256\"}],\"name\":\"mintWithERC20\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextGasSponsorshipId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"baseRefundUnits\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"baseRefundUnitsDeploy\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"baseRefundUnitsMint\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"refundDeploy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"refundMint\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"maxRefundUnitsDeploy\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxRefundUnitsMint\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxBaseFee\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxPriorityFee\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"additionalRefundCalculator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"balanceCheckAddress\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minimumBalanceIncrement\",\"type\":\"uint96\"}],\"name\":\"sponsorGas\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasSponsorshipId\",\"type\":\"uint256\"}],\"name\":\"withdrawSponsorship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LayerrLazyDeploy", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "33333", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d5f7afad4664460200f3ecf36fd9e0ca4e6e082feb2fce94fe2f3ce29db4ffed"}