{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n// File: contracts/core/NiftyEntity.sol\r\n\r\n/**\r\n * @dev Authenticator of state mutating operations for Nifty Gateway contracts. \r\n *\r\n * addresses for stateful operations. \r\n *\r\n * Rinkeby: 0xCefBf44ff649B6E0Bc63785699c6F1690b8cF73b\r\n * Mainnet: 0x6e53130dDfF21E3BC963Ee902005223b9A202106\r\n */\r\ncontract NiftyEntity {\r\n   \r\n   // Address of {NiftyRegistry} contract. \r\n   address internal immutable niftyRegistryContract;\r\n   \r\n   /**\r\n    * @dev Determines whether accounts are allowed to invoke state mutating operations on child contracts.\r\n    */\r\n    modifier onlyValidSender() {\r\n        NiftyRegistry niftyRegistry = NiftyRegistry(niftyRegistryContract);\r\n        bool isValid = niftyRegistry.isValidNiftySender(msg.sender);\r\n        require(isValid, \"NiftyEntity: Invalid msg.sender\");\r\n        _;\r\n    }\r\n    \r\n   /**\r\n    * @param _niftyRegistryContract Points to the repository of authenticated\r\n    */\r\n    constructor(address _niftyRegistryContract) {\r\n        niftyRegistryContract = _niftyRegistryContract;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Defined to mediate interaction with externally deployed {NiftyRegistry} dependency. \r\n */\r\ninterface NiftyRegistry {\r\n   function isValidNiftySender(address sending_key) external view returns (bool);\r\n}\r\n\r\n// File: contracts/interface/IERC165.sol\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface IERC165 {\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n// File: contracts/interface/IERC721.sol\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n      * - `from` cannot be the zero address.\r\n      * - `to` cannot be the zero address.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/interface/IERC721Receiver.sol\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n// File: contracts/interface/IERC721Metadata.sol\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: contracts/util/Context.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/util/Strings.sol\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant alphabet = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/standard/ERC165.sol\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: contracts/core/ERC721.sol\r\n\r\n/**\r\n * @dev Nifty Gateway implementation of Non-Fungible Token Standard.\r\n */\r\ncontract ERC721 is NiftyEntity, Context, ERC165, IERC721, IERC721Metadata {\r\n\r\n    // Tracked individual instance spawned by {BuilderShop} contract. \r\n    uint immutable public _id;\r\n\r\n    // Number of distinct NFTs housed in this contract. \r\n    uint immutable public _typeCount;\r\n\r\n    // Intial receiver of all newly minted NFTs.\r\n    address immutable public _defaultOwner;\r\n\r\n    // Component(s) of 'tokenId' calculation. \r\n    uint immutable public topLevelMultiplier;\r\n    uint immutable public midLevelMultiplier;\r\n\r\n    // Token name.\r\n    string private _name;\r\n\r\n    // Token symbol.\r\n    string private _symbol;\r\n\r\n    // Token artifact location.\r\n    string private _baseURI;\r\n\r\n    // Mapping from Nifty type to name of token.\r\n    mapping(uint256 => string) private _niftyTypeName;\r\n\r\n    // Mapping from Nifty type to IPFS hash of canonical artifcat file.\r\n    mapping(uint256 => string) private _niftyTypeIPFSHashes;\r\n\r\n    // Mapping from token ID to owner address.\r\n    mapping (uint256 => address) internal _owners;\r\n\r\n    // Mapping owner address to token count, by aggregating all _typeCount NFTs in the contact.\r\n    mapping (address => uint256) internal _balances;\r\n\r\n    // Mapping from token ID to approved address.\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals.\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Initializes the token collection.\r\n     *\r\n     * @param name_ Of the collection being deployed.\r\n     * @param symbol_ Shorthand token identifier, for wallets, etc.\r\n     * @param id_ Number instance deployed by {BuilderShop} contract.\r\n     * @param baseURI_ The location where the artifact assets are stored.\r\n     * @param typeCount_ The number of different Nifty types (different \r\n     * individual NFTs) associated with the deployed collection.\r\n     * @param defaultOwner_ Intial receiver of all newly minted NFTs.\r\n     * @param niftyRegistryContract Points to the repository of authenticated\r\n     * addresses for stateful operations. \r\n     */\r\n    constructor(string memory name_, \r\n                string memory symbol_,\r\n                uint256 id_,\r\n                string memory baseURI_,\r\n                uint256 typeCount_,\r\n                address defaultOwner_, \r\n                address niftyRegistryContract) NiftyEntity(niftyRegistryContract) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _id = id_;\r\n        _baseURI = baseURI_;\r\n        _typeCount = typeCount_;\r\n        _defaultOwner = defaultOwner_;\r\n\r\n        midLevelMultiplier = 100000;\r\n        topLevelMultiplier = id_ * 1000000000;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC721).interfaceId\r\n            || interfaceId == type(IERC721Metadata).interfaceId\r\n            || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the link to artificat location for a given token by 'tokenId'.\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param tokenId uint256 ID of the token to query.\r\n     * @return The location where the artifact assets are stored.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n        string memory tokenIdStr = Strings.toString(tokenId);\r\n        return string(abi.encodePacked(_baseURI, tokenIdStr));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an IPFS hash for a given token ID.\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param tokenId uint256 ID of the token to query.\r\n     * @return IPFS hash for this (_typeCount) NFT. \r\n     */\r\n    function tokenIPFSHash(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: IPFS hash query for nonexistent token\");\r\n        uint256 niftyType = _getNiftyTypeId(tokenId);\r\n        return _niftyTypeIPFSHashes[niftyType];\r\n    }\r\n    \r\n    /**\r\n     * @dev Determine which NFT in the contract (_typeCount) is associated \r\n     * with this 'tokenId'.\r\n     */\r\n    function _getNiftyTypeId(uint256 tokenId) internal view returns (uint256) {\r\n        if(tokenId <= topLevelMultiplier) {\r\n            return 0;\r\n        } else {\r\n            return (tokenId - topLevelMultiplier) / midLevelMultiplier;\r\n        }        \r\n    }\r\n\r\n    /**\r\n     * @dev Returns the Name for a given token ID.\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenName(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: Name query for nonexistent token\");\r\n        uint256 niftyType = _getNiftyTypeId(tokenId);\r\n        return _niftyTypeName[niftyType];\r\n    }\r\n   \r\n    /**\r\n     * @dev Internal function to set the token IPFS hash for a nifty type.\r\n     * @param niftyType uint256 ID component of the token to set its IPFS hash\r\n     * @param ipfs_hash string IPFS link to assign\r\n     */\r\n    function _setTokenIPFSHashNiftyType(uint256 niftyType, string memory ipfs_hash) internal {\r\n        require(bytes(_niftyTypeIPFSHashes[niftyType]).length == 0, \"ERC721Metadata: IPFS hash already set\");\r\n        _niftyTypeIPFSHashes[niftyType] = ipfs_hash;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the name for a nifty type.\r\n     * @param niftyType uint256 of nifty type name to be set\r\n     * @param nifty_type_name name of nifty type\r\n     */\r\n    function _setNiftyTypeName(uint256 niftyType, string memory nifty_type_name) internal {\r\n        _niftyTypeName[niftyType] = nifty_type_name;\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}.\r\n     */\r\n    function _setBaseURI(string memory baseURI_) internal {\r\n        _baseURI = baseURI_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        private returns (bool)\r\n    {\r\n        if (isContract(to)) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver(to).onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    // solhint-disable-next-line no-inline-assembly\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/interface/IERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/util/Address.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/util/SafeERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interface/ICloneablePaymentSplitter.sol\r\n\r\ninterface ICloneablePaymentSplitter is IERC165 {\r\n    \r\n    event PayeeAdded(address account, uint256 shares);\r\n    event PaymentReleased(address to, uint256 amount);\r\n    event ERC20PaymentReleased(IERC20 indexed token, address to, uint256 amount);\r\n    event PaymentReceived(address from, uint256 amount);\r\n    \r\n    function initialize(address[] calldata payees, uint256[] calldata shares_) external;        \r\n    function totalShares() external view returns (uint256);    \r\n    function totalReleased() external view returns (uint256);\r\n    function totalReleased(IERC20 token) external view returns (uint256);\r\n    function shares(address account) external view returns (uint256);    \r\n    function released(address account) external view returns (uint256);\r\n    function released(IERC20 token, address account) external view returns (uint256);\r\n    function payee(uint256 index) external view returns (address);    \r\n    function release(address payable account) external;\r\n    function release(IERC20 token, address account) external;\r\n    function pendingPayment(address account) external view returns (uint256);\r\n    function pendingPayment(IERC20 token, address account) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/interface/IERC2981.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n///\r\n/// @dev Interface for the NFT Royalty Standard\r\n///\r\ninterface IERC2981 is IERC165 {\r\n    /// ERC165 bytes to add to interface array - set in parent contract\r\n    /// implementing this standard\r\n    ///\r\n    /// bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\r\n    /// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n    /// _registerInterface(_INTERFACE_ID_ERC2981);\r\n\r\n    /// @notice Called with the sale price to determine how much royalty\r\n    //          is owed and to whom.\r\n    /// @param _tokenId - the NFT asset queried for royalty information\r\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\r\n    /// @return receiver - address of who should be sent the royalty payment\r\n    /// @return royaltyAmount - the royalty payment amount for _salePrice\r\n    function royaltyInfo(\r\n        uint256 _tokenId,\r\n        uint256 _salePrice\r\n    ) external view returns (\r\n        address receiver,\r\n        uint256 royaltyAmount\r\n    );\r\n}\r\n\r\n// File: contracts/standard/ERC721Burnable.sol\r\n\r\n/**\r\n * @title ERC721 Burnable Token\r\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\r\n */\r\nabstract contract ERC721Burnable is Context, ERC721 {\r\n    /**\r\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own `tokenId` or be an approved operator.\r\n     */\r\n    function burn(uint256 tokenId) public virtual {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\r\n        _burn(tokenId);\r\n    }\r\n}\r\n\r\n// File: contracts/util/Clones.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\r\n// OpenZeppelin Contract Commit Hash: 6bd6b76d1156e20e45d1016f355d154141c7e5b9                                      \r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\r\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\r\n *\r\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\r\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\r\n * deterministic method.\r\n *\r\n * _Available since v3.4._\r\n */\r\nlibrary Clones {\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function clone(address implementation) internal returns (address instance) {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create(0, ptr, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\r\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\r\n     * the clones cannot be deployed twice at the same address.\r\n     */\r\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create2(0, ptr, 0x37, salt)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create2 failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(\r\n        address implementation,\r\n        bytes32 salt,\r\n        address deployer\r\n    ) internal pure returns (address predicted) {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\r\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\r\n            mstore(add(ptr, 0x4c), salt)\r\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\r\n            predicted := keccak256(add(ptr, 0x37), 0x55)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address implementation, bytes32 salt)\r\n        internal\r\n        view\r\n        returns (address predicted)\r\n    {\r\n        return predictDeterministicAddress(implementation, salt, address(this));\r\n    }\r\n}\r\n\r\n// File: contracts/core/NiftyBuilderInstance.sol\r\n\r\n/** \r\n * XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\r\n * XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  .***   XXXXXXXXXXXXXXXXXX\r\n * XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  ,*********  XXXXXXXXXXXXXXXX\r\n * XXXXXXXXXXXXXXXXXXXXXXXXXXXX  ***************  XXXXXXXXXXXXX\r\n * XXXXXXXXXXXXXXXXXXXXXXXXX  .*******************  XXXXXXXXXXX\r\n * XXXXXXXXXXXXXXXXXXXXXXX  ***********    **********  XXXXXXXX\r\n * XXXXXXXXXXXXXXXXXXXX   ***********       ***********  XXXXXX\r\n * XXXXXXXXXXXXXXXXXX  ***********         ***************  XXX\r\n * XXXXXXXXXXXXXXXX  ***********           ****    ********* XX\r\n * XXXXXXXXXXXXXXXX *********      ***    ***      *********  X\r\n * XXXXXXXXXXXXXXXX  **********  *****          *********** XXX\r\n * XXXXXXXXXXXX   /////.*************         ***********  XXXX\r\n * XXXXXXXXX  /////////...***********      ************  XXXXXX\r\n * XXXXXXX/ ///////////..... /////////   ///////////   XXXXXXXX\r\n * XXXXXX  /    //////.........///////////////////   XXXXXXXXXX\r\n * XXXXXXXXXX .///////...........//////////////   XXXXXXXXXXXXX\r\n * XXXXXXXXX .///////.....//..////  /////////  XXXXXXXXXXXXXXXX\r\n * XXXXXXX# /////////////////////  XXXXXXXXXXXXXXXXXXXXXXXXXXXX\r\n * XXXXX   ////////////////////   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX\r\n * XX   ////////////// //////   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\r\n * XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\r\n *\r\n * @dev Nifty Gateway extension of customized NFT contract, encapsulates\r\n * logic for minting new tokens, and concluding the minting process. \r\n */\r\ncontract NiftyBuilderInstance is ERC721, ERC721Burnable, IERC2981 {\r\n\r\n    event RoyaltyReceiverUpdated(uint256 indexed niftyType, address previousReceiver, address newReceiver);\r\n    event PaymentReleased(address to, uint256 amount);\r\n    event ERC20PaymentReleased(IERC20 indexed token, address to, uint256 amount);\r\n\r\n    // The artist associated with the collection.\r\n    string private _creator;    \r\n\r\n    uint256 immutable public _percentageTotal;\r\n    mapping(uint256 => uint256) public _percentageRoyalty;\r\n\r\n    mapping (uint256 => address) _royaltySplitters;\r\n    mapping (uint256 => address) _royaltyReceivers;\r\n\r\n    // Number of NFTs minted for a given 'typeCount'. \r\n    mapping (uint256 => uint256) public _mintCount;\r\n\r\n    /**\r\n     * @dev Serves as a gas cost optimized boolean flag \r\n     * to indicate whether the minting process has been \r\n     * concluded for a given 'typeCount', correspinds \r\n     * to the {_getFinalized} and {setFinalized}.\r\n     */\r\n    mapping (uint256 => bytes32) private _finalized;    \r\n\r\n    /**\r\n     * @dev Emitted when tokens are created.\r\n     */\r\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\r\n\r\n    /**\r\n     * @dev Ultimate instantiation of a Nifty Gateway NFT collection. \r\n     * \r\n     * @param name Of the collection being deployed.\r\n     * @param symbol Shorthand token identifier, for wallets, etc.\r\n     * @param id Number instance deployed by {BuilderShop} contract.\r\n     * @param typeCount The number of different Nifty types (different \r\n     * individual NFTs) associated with the deployed collection.\r\n     * @param baseURI The location where the artifact assets are stored.\r\n     * @param creator_ The artist associated with the collection.\r\n     * @param niftyRegistryContract Points to the repository of authenticated\r\n     * addresses for stateful operations. \r\n     * @param defaultOwner Intial receiver of all newly minted NFTs.\r\n     */\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint256 id,\r\n        uint256 typeCount,\r\n        string memory baseURI,\r\n        string memory creator_,        \r\n        address niftyRegistryContract,\r\n        address defaultOwner) ERC721(name, symbol, id, baseURI, typeCount, defaultOwner, niftyRegistryContract) {\r\n        \r\n        _creator = creator_;\r\n        _percentageTotal = 10000;        \r\n    }\r\n\r\n    function setRoyaltyBips(uint256 niftyType, uint256 percentageRoyalty_) external onlyValidSender {\r\n        require(percentageRoyalty_ <= _percentageTotal, \"NiftyBuilderInstance: Illegal argument more than 100%\");\r\n        _percentageRoyalty[niftyType] = percentageRoyalty_;\r\n    }\r\n\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public override view returns (address, uint256) {        \r\n        require(_exists(tokenId), \"NiftyBuilderInstance: operator query for nonexistent token\");\r\n        uint256 niftyType = _getNiftyTypeId(tokenId);\r\n        uint256 royaltyAmount = (salePrice * _percentageRoyalty[niftyType]) / _percentageTotal;\r\n        address royaltyReceiver = _getRoyaltyReceiverByNiftyType(niftyType);\r\n        require(royaltyReceiver != address(0), \"NiftyBuilderInstance: No royalty receiver\");\r\n        return (royaltyReceiver, royaltyAmount);\r\n    }\r\n\r\n    // This function must be called after builder shop instance is created - it can be called again\r\n    // to change the split; call this once per nifty type to set up royalty payments properly\r\n    function initializeRoyalties(address splitterImplementation, uint256 niftyType, address[] calldata payees, uint256[] calldata shares_) external onlyValidSender {\r\n        address previousReceiver = _getRoyaltyReceiverByNiftyType(niftyType);\r\n        address newReceiver = address(0);\r\n        if(payees.length == 1) {\r\n            newReceiver = payees[0];\r\n            _royaltyReceivers[niftyType] = newReceiver;\r\n            delete _royaltySplitters[niftyType];\r\n        } else {            \r\n            delete _royaltyReceivers[niftyType];\r\n            require(IERC165(splitterImplementation).supportsInterface(type(ICloneablePaymentSplitter).interfaceId), \"Not a valid payment splitter\");\r\n            newReceiver = payable (Clones.clone(splitterImplementation));\r\n            ICloneablePaymentSplitter(newReceiver).initialize(payees, shares_);\r\n            _royaltySplitters[niftyType] = newReceiver;        \r\n        }\r\n\r\n        emit RoyaltyReceiverUpdated(niftyType, previousReceiver, newReceiver);        \r\n    }\r\n\r\n    function getRoyaltyReceiverByTokenId(uint256 tokenId) public view returns (address) {        \r\n        return _getRoyaltyReceiverByNiftyType(_getNiftyTypeId(tokenId));\r\n    }\r\n\r\n    function getRoyaltyReceiverByNiftyType(uint256 niftyType) public view returns (address) {\r\n        return _getRoyaltyReceiverByNiftyType(niftyType);\r\n    }\r\n\r\n    function releaseRoyalties(address payable account) external {\r\n        uint256 totalPaymentAmount = 0;\r\n        for(uint256 niftyType = 1; niftyType <= _typeCount; niftyType++) {\r\n            address paymentSplitterAddress = _royaltySplitters[niftyType];\r\n            if(paymentSplitterAddress != address(0)) {\r\n                ICloneablePaymentSplitter paymentSplitter = ICloneablePaymentSplitter(paymentSplitterAddress);    \r\n                uint256 pendingPaymentAmount = paymentSplitter.pendingPayment(account);\r\n                if(pendingPaymentAmount > 0) {\r\n                    totalPaymentAmount += pendingPaymentAmount;\r\n                    paymentSplitter.release(account);\r\n                }\r\n            }            \r\n        }\r\n\r\n        if(totalPaymentAmount > 0) {\r\n            emit PaymentReleased(account, totalPaymentAmount);\r\n        }    \r\n    }\r\n\r\n    function releaseRoyalties(IERC20 token, address account) external {\r\n        uint256 totalPaymentAmount = 0;\r\n        for(uint256 niftyType = 1; niftyType <= _typeCount; niftyType++) {\r\n            address paymentSplitterAddress = _royaltySplitters[niftyType];\r\n            if(paymentSplitterAddress != address(0)) {\r\n                ICloneablePaymentSplitter paymentSplitter = ICloneablePaymentSplitter(paymentSplitterAddress);    \r\n                uint256 pendingPaymentAmount = paymentSplitter.pendingPayment(token, account);\r\n                if(pendingPaymentAmount > 0) {\r\n                    totalPaymentAmount += pendingPaymentAmount;\r\n                    paymentSplitter.release(token, account);\r\n                }\r\n            }            \r\n        }\r\n\r\n        if(totalPaymentAmount > 0) {\r\n            emit ERC20PaymentReleased(token, account, totalPaymentAmount);\r\n        }    \r\n    }\r\n    \r\n    function pendingRoyaltyPayment(address account) external view returns (uint256) {\r\n        uint256 totalPaymentAmount = 0;\r\n        for(uint256 niftyType = 1; niftyType <= _typeCount; niftyType++) {\r\n            address paymentSplitterAddress = _royaltySplitters[niftyType];\r\n            if(paymentSplitterAddress != address(0)) {\r\n                ICloneablePaymentSplitter paymentSplitter = ICloneablePaymentSplitter(paymentSplitterAddress);    \r\n                totalPaymentAmount += paymentSplitter.pendingPayment(account);\r\n            }            \r\n        }\r\n        return totalPaymentAmount;\r\n    }\r\n\r\n    function pendingRoyaltyPayment(IERC20 token, address account) external view returns (uint256) {\r\n        uint256 totalPaymentAmount = 0;\r\n        for(uint256 niftyType = 1; niftyType <= _typeCount; niftyType++) {\r\n            address paymentSplitterAddress = _royaltySplitters[niftyType];\r\n            if(paymentSplitterAddress != address(0)) {\r\n                ICloneablePaymentSplitter paymentSplitter = ICloneablePaymentSplitter(paymentSplitterAddress);    \r\n                totalPaymentAmount += paymentSplitter.pendingPayment(token, account);\r\n            }            \r\n        }\r\n        return totalPaymentAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Generate canonical Nifty Gateway token representation. \r\n     * Nifty contracts have a data model called a 'niftyType' (typeCount) \r\n     * The 'niftyType' refers to a specific nifty in our contract, note \r\n     * that it gives no information about the edition size. In a given \r\n     * contract, 'niftyType' 1 could be an edition of 10, while 'niftyType' \r\n     * 2 is a 1/1, etc.\r\n     * The token IDs are encoded as follows: {id}{niftyType}{edition #}\r\n     * 'niftyType' has 4 digits, and edition number has 5 digits, to allow \r\n     * for 99999 possible 'niftyType' and 99999 of each edition in each contract.\r\n     * Example token id: [5000100270]\r\n     * This is from contract #5, it is 'niftyType' 1 in the contract, and it is \r\n     * edition #270 of 'niftyType' 1.\r\n     * Example token id: [5000110000]\r\n     * This is from contract #5, it is 'niftyType' 1 in the contract, and it is \r\n     * edition #10000 of 'niftyType' 1.\r\n     */\r\n    function _encodeTokenId(uint256 niftyType, uint256 tokenNumber) private view returns (uint256) {\r\n        return (topLevelMultiplier + (niftyType * midLevelMultiplier) + tokenNumber);\r\n    }\r\n\r\n    /**\r\n     * @dev Determine whether it is possible to mint additional NFTs for this 'niftyType'.\r\n     */\r\n    function _getFinalized(uint256 niftyType) public view returns (bool) {\r\n        bytes32 chunk = _finalized[niftyType / 256];\r\n        return (chunk & bytes32(1 << (niftyType % 256))) != 0x0;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevent the minting of additional NFTs of this 'niftyType'.\r\n     */\r\n    function setFinalized(uint256 niftyType) public onlyValidSender {\r\n        uint256 quotient = niftyType / 256;\r\n        bytes32 chunk = _finalized[quotient];\r\n        _finalized[quotient] = chunk | bytes32(1 << (niftyType % 256));\r\n    }\r\n\r\n    /**\r\n     * @dev The artist of this collection.\r\n     */\r\n    function creator() public view virtual returns (string memory) {\r\n        return _creator;\r\n    }\r\n\r\n    /**\r\n     * @dev Assign the root location where the artifact assets are stored.\r\n     */\r\n    function setBaseURI(string memory baseURI) public onlyValidSender {\r\n        _setBaseURI(baseURI);\r\n    }\r\n\r\n    /**\r\n     * @dev Allow owner to change nifty name, by 'niftyType'.\r\n     */\r\n    function setNiftyName(uint256 niftyType, string memory niftyName) public onlyValidSender {\r\n        _setNiftyTypeName(niftyType, niftyName);\r\n    }\r\n\r\n    /**\r\n     * @dev Assign the IPFS hash of canonical artifcat file, by 'niftyType'.\r\n     */   \r\n    function setNiftyIPFSHash(uint256 niftyType, string memory hashIPFS) public onlyValidSender {\r\n        _setTokenIPFSHashNiftyType(niftyType, hashIPFS);\r\n    }\r\n\r\n    /**\r\n     * @dev Create specified number of nifties en masse.\r\n     * Once an NFT collection is spawned by the factory contract, we make calls to set the IPFS\r\n     * hash (above) for each Nifty type in the collection. \r\n     * Subsequently calls are issued to this function to mint the appropriate number of tokens \r\n     * for the project.\r\n     */\r\n    function mintNifty(uint256 niftyType, uint256 count) public onlyValidSender {\r\n        require(!_getFinalized(niftyType), \"NiftyBuilderInstance: minting concluded for nifty type\");\r\n            \r\n        uint256 tokenNumber = _mintCount[niftyType] + 1;\r\n        uint256 tokenId00 = _encodeTokenId(niftyType, tokenNumber);\r\n        uint256 tokenId01 = tokenId00 + count - 1;\r\n        \r\n        for (uint256 tokenId = tokenId00; tokenId <= tokenId01; tokenId++) {\r\n            _owners[tokenId] = _defaultOwner;\r\n        }\r\n        _mintCount[niftyType] += count;\r\n        _balances[_defaultOwner] += count;\r\n\r\n        emit ConsecutiveTransfer(tokenId00, tokenId01, address(0), _defaultOwner);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\r\n    }    \r\n\r\n    function _getRoyaltyReceiverByNiftyType(uint256 niftyType) private view returns (address) {\r\n        if(_royaltyReceivers[niftyType] != address(0)) {            \r\n            return _royaltyReceivers[niftyType];\r\n        } else if(_royaltySplitters[niftyType] != address(0)) {            \r\n            return _royaltySplitters[niftyType];\r\n        }\r\n\r\n        return address(0);   \r\n    }\r\n}\r\n\r\n// File: contracts/core/BuilderShop.sol\r\n\r\npragma solidity ^0.8.6;\r\n\r\n\r\n\r\n/**\r\n *   ::::::::::::::::::::::::::::::::::::::::::::\r\n * ::::::::::::::::::::::::::::::::::::::::::::::::\r\n * ::::::::::::::::::::::::::::::::::::::::::::::::\r\n * ::::::::::::NNNNNNNNN:::::::NNNNNNNN::::::::::::\r\n * ::::::::::::NNNNNNNNNN::::::NNNNNNNN::::::::::::\r\n * ::::::::::::NNNNNNNNNNN:::::NNNNNNNN::::::::::::\r\n * ::::::::::::NNNNNNNNNNNN::::NNNNNNNN::::::::::::\r\n * ::::::::::::NNNNNNNNNNNNN:::NNNNNNNN::::::::::::\r\n * ::::::::::::NNNNNNNNNNNNNN::NNNNNNNN::::::::::::\r\n * ::::::::::::NNNNNNNN:NNNNNN:NNNNNNNN::::::::::::\r\n * ::::::::::::NNNNNNNN::NNNNNNNNNNNNNN::::::::::::\r\n * ::::::::::::NNNNNNNN:::NNNNNNNNNNNNN::::::::::::\r\n * ::::::::::::NNNNNNNN::::NNNNNNNNNNNN::::::::::::\r\n * ::::::::::::NNNNNNNN:::::NNNNNNNNNNN::::::::::::\r\n * ::::::::::::NNNNNNNN::::::NNNNNNNNNN::::::::::::\r\n * ::::::::::::NNNNNNNN:::::::NNNNNNNNN::::::::::::\r\n * ::::::::::::::::::::::::::::::::::::::::::::::::\r\n * ::::::::::::::::::::::::::::::::::::::::::::::::\r\n *   ::::::::::::::::::::::::::::::::::::::::::::\r\n *  \r\n * @dev Nexus of the Nifty Gateway smartcontract constellation.\r\n * {BuilderShop} is a factory contract, when a new collection\r\n * is slated for deployment, a call is made to this factory \r\n * contract to create it. \r\n */\r\ncontract BuilderShop is NiftyEntity {\r\n\r\n    /**\r\n     * @dev Tracks the latest {NiftyBuilderInstance} deployment, supplied as constructor \r\n     * argument. Every time a new contract is deployed from this \"master\" factory contract, \r\n     * it is given a contract id that is one higher than the previous contract deployed.\r\n     */\r\n    uint public _id;\r\n\r\n    // Provided as a argument to {NiftyBuilderInstance} deployment.\r\n    address public _defaultOwner;\r\n\r\n    // Reference for validation of posible {NiftyBuilderInstance} by address.\r\n    mapping (address => bool) public validBuilderInstance;\r\n\r\n    // Log the creation of each {NiftyBuilderInstance} deployment. \r\n    event BuilderInstanceCreated(address instanceAddress, uint id);\r\n\r\n    /**\r\n     * @param niftyRegistryContract Points to the mainnet repository of addresses\r\n     * allowed to invoke state mutating operations via the modifier 'onlyValidSender'.\r\n     * @param defaultOwner_ The address to which all tokens are initially minted.\r\n     */\r\n    constructor(address niftyRegistryContract,\r\n                address defaultOwner_) NiftyEntity(niftyRegistryContract) {\r\n        _defaultOwner = defaultOwner_;\r\n    }\r\n\r\n    /**\r\n     * @dev Configurable address for defaultOwner.\r\n     * @param defaultOwner account to which newly minted tokens are allocated.\r\n     */ \r\n    function setDefaultOwner(address defaultOwner) onlyValidSender external {\r\n        _defaultOwner = defaultOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow anyone to check if a contract address is a valid nifty gateway contract.\r\n     * @param instanceAddress address of potential spawned {NiftyBuilderInstance}.\r\n     * @return bool whether or not the contract was initialized by this {BuilderShop}.\r\n     */\r\n    function isValidBuilderInstance(address instanceAddress) external view returns (bool) {\r\n        return (validBuilderInstance[instanceAddress]);\r\n    }\r\n\r\n    /**\r\n     * @dev Collections on the platform are associated with a call to this \r\n     * function which will generate a {NiftyBuilderInstance} to house the \r\n     * NFTs for that particular artist release. \r\n     * \r\n     * @param name Of the collection being deployed.\r\n     * @param symbol Shorthand token identifier, for wallets, etc.\r\n     * @param typeCount The number of different Nifty types (different \r\n     * individual NFTs) associated with the deployed collection.\r\n     * @param baseURI The location where the artifact assets are stored.\r\n     * @param creator The artist associated with the collection.\r\n     */\r\n    function createNewBuilderInstance(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint256 typeCount,\r\n        string memory baseURI,\r\n        string memory creator) external onlyValidSender { \r\n        \r\n        _id += 1;\r\n\r\n        NiftyBuilderInstance instance = new NiftyBuilderInstance(\r\n            name,\r\n            symbol,\r\n            _id,\r\n            typeCount,\r\n            baseURI,\r\n            creator,\r\n            niftyRegistryContract,\r\n            _defaultOwner\r\n        );\r\n        address instanceAddress = address(instance);\r\n        validBuilderInstance[instanceAddress] = true;\r\n\r\n        emit BuilderInstanceCreated(instanceAddress, _id);\r\n    }\r\n   \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"typeCount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"creator_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"niftyRegistryContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"defaultOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20PaymentReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"}],\"name\":\"RoyaltyReceiverUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_defaultOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"}],\"name\":\"_getFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_mintCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_percentageRoyalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_percentageTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_typeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"}],\"name\":\"getRoyaltyReceiverByNiftyType\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyaltyReceiverByTokenId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"splitterImplementation\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"payees\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shares_\",\"type\":\"uint256[]\"}],\"name\":\"initializeRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"midLevelMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"mintNifty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingRoyaltyPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingRoyaltyPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"releaseRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"releaseRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"}],\"name\":\"setFinalized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"hashIPFS\",\"type\":\"string\"}],\"name\":\"setNiftyIPFSHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"niftyName\",\"type\":\"string\"}],\"name\":\"setNiftyName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentageRoyalty_\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyBips\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenIPFSHash\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topLevelMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NiftyBuilderInstance", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "1500", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000006e53130ddff21e3bc963ee902005223b9a202106000000000000000000000000e052113bd7d7700d623414a0a4585bcae754e9d50000000000000000000000000000000000000000000000000000000000000018322032322032303232206279204c796c65204f7765726b6f0000000000000000000000000000000000000000000000000000000000000000000000000000000c42594c594c454f5745524b4f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003268747470733a2f2f6170692e6e69667479676174657761792e636f6d2f6c796c656f7765726b6f2d322d32322d323032322f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b4c796c65204f7765726b6f000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}