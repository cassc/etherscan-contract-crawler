{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.23;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function getOwner() external view returns (address);\r\n\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address spender\r\n    ) external view returns (uint);\r\n\r\n    function approve(address spender, uint amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping(address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!NOT OWNER\");\r\n        _;\r\n    }\r\n\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender), \"!NOT AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    function authorize(address adr) public onlyOwner {\r\n        authorizations[adr] = true;\r\n    }\r\n\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n    }\r\n\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function WETH() external pure returns (address);\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IDividendDistributor {\r\n    function setDistributionCriteria(\r\n        uint _minPeriod,\r\n        uint _minDistribution\r\n    ) external;\r\n\r\n    function setShare(address shareholder, uint amount) external;\r\n\r\n    function updateDivs(uint _amount) external;\r\n\r\n    function process(uint gas) external;\r\n}\r\n\r\ncontract DividendDistributor is IDividendDistributor {\r\n    address Token;\r\n\r\n    struct Share {\r\n        uint amount;\r\n        uint totalExcluded;\r\n        uint totalRealised;\r\n    }\r\n\r\n    address public RewardToken = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; //USDC address\r\n\r\n    IUniswapV2Router public router;\r\n    IERC20 private rewardToken = IERC20(RewardToken);\r\n    IERC20 private token = IERC20(Token);\r\n\r\n    address[] shareholders;\r\n\r\n    mapping(address => uint) shareholderIndexes;\r\n    mapping(address => uint) shareholderClaims;\r\n    mapping(address => Share) public shares;\r\n\r\n    uint public totalShares;\r\n    uint public totalDividends;\r\n    uint public totalDistributed;\r\n    uint public dividendsPerShare;\r\n    uint public dividendsPerShareAccuracyFactor = 10 ** 36;\r\n    uint public minPeriod = 1 hours;\r\n    uint public minDistribution = 1 * 1e6; //Shareholder must have at least $1 USDC in unpaid earnings\r\n    uint currentIndex;\r\n\r\n    event DividendClaimed(address indexed shareholder, uint amount);\r\n    event RewardTokenUpdated(address newToken);\r\n    event DistributionCriteriaUpdated(uint minPeriod, uint minDistribution);\r\n\r\n    bool initialized;\r\n\r\n    modifier initialization() {\r\n        require(!initialized);\r\n        _;\r\n        initialized = true;\r\n    }\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == Token);\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D != address(0)\r\n            ? IUniswapV2Router(router)\r\n            : IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        Token = msg.sender;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function updateRouterAddress(address newRouter) external onlyToken {\r\n        require(\r\n            newRouter != address(0),\r\n            \"Router address cannot be zero address\"\r\n        );\r\n        router = IUniswapV2Router(newRouter);\r\n    }\r\n\r\n    function setDistributionCriteria(\r\n        uint _minPeriod,\r\n        uint _minDistribution\r\n    ) external override onlyToken {\r\n        minPeriod = _minPeriod;\r\n        minDistribution = _minDistribution;\r\n\r\n        emit DistributionCriteriaUpdated(_minPeriod, _minDistribution);\r\n    }\r\n\r\n    function setShare(\r\n        address shareholder,\r\n        uint amount\r\n    ) external override onlyToken {\r\n        if (shares[shareholder].amount > 0) {\r\n            distributeDividend(shareholder);\r\n        }\r\n\r\n        if (amount > 0 && shares[shareholder].amount == 0) {\r\n            addShareholder(shareholder);\r\n        } else if (amount == 0 && shares[shareholder].amount > 0) {\r\n            removeShareholder(shareholder);\r\n        }\r\n\r\n        totalShares = totalShares - shares[shareholder].amount + amount;\r\n        shares[shareholder].amount = amount;\r\n        shares[shareholder].totalExcluded = getCumulativeDividends(\r\n            shares[shareholder].amount\r\n        );\r\n    }\r\n\r\n    function updateDivs(uint _amount) external override onlyToken {\r\n        totalDividends = totalDividends + _amount;\r\n        dividendsPerShare =\r\n            dividendsPerShare +\r\n            ((dividendsPerShareAccuracyFactor * _amount) / totalShares);\r\n    }\r\n\r\n    function process(uint gas) external override onlyToken {\r\n        uint shareholderCount = shareholders.length;\r\n\r\n        if (shareholderCount == 0) {\r\n            return;\r\n        }\r\n\r\n        uint gasUsed = 0;\r\n        uint gasLeft = gasleft();\r\n\r\n        uint iterations = 0;\r\n\r\n        while (gasUsed < gas && iterations < shareholderCount) {\r\n            if (currentIndex >= shareholderCount) {\r\n                currentIndex = 0;\r\n            }\r\n\r\n            if (shouldDistribute(shareholders[currentIndex])) {\r\n                distributeDividend(shareholders[currentIndex]);\r\n            }\r\n\r\n            gasUsed = gasUsed + (gasLeft - (gasleft()));\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++;\r\n        }\r\n    }\r\n\r\n    function shouldDistribute(\r\n        address shareholder\r\n    ) internal view returns (bool) {\r\n        return\r\n            shareholderClaims[shareholder] + minPeriod < block.timestamp &&\r\n            getUnpaidEarnings(shareholder) > minDistribution;\r\n    }\r\n\r\n    function distributeDividend(address shareholder) internal {\r\n        if (shares[shareholder].amount == 0) {\r\n            return;\r\n        }\r\n\r\n        uint amount = getUnpaidEarnings(shareholder);\r\n        if (amount > 0) {\r\n            totalDistributed = totalDistributed + amount;\r\n            rewardToken.transfer(shareholder, amount);\r\n            shareholderClaims[shareholder] = block.timestamp;\r\n            shares[shareholder].totalRealised =\r\n                shares[shareholder].totalRealised +\r\n                amount;\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(\r\n                shares[shareholder].amount\r\n            );\r\n\r\n            emit DividendClaimed(shareholder, amount);\r\n        }\r\n    }\r\n\r\n    function getDividendPercentage(\r\n        address shareholder\r\n    ) external view returns (uint) {\r\n        require(totalDistributed > 0, \"No dividends distributed yet\");\r\n\r\n        uint shareholderTotalReceived = shares[shareholder].totalRealised;\r\n        return (shareholderTotalReceived * 100) / totalDistributed;\r\n    }\r\n\r\n    function claimDividend() external {\r\n        distributeDividend(msg.sender);\r\n    }\r\n\r\n    function getTotalDividendsForAddress(\r\n        address shareholder\r\n    ) public view returns (uint) {\r\n        return shares[shareholder].totalRealised;\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder) public view returns (uint) {\r\n        if (shares[shareholder].amount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint shareholderTotalDividends = getCumulativeDividends(\r\n            shares[shareholder].amount\r\n        );\r\n        uint shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n\r\n        if (shareholderTotalDividends <= shareholderTotalExcluded) {\r\n            return 0;\r\n        }\r\n\r\n        return shareholderTotalDividends - shareholderTotalExcluded;\r\n    }\r\n\r\n    function getCumulativeDividends(uint share) internal view returns (uint) {\r\n        return (share * dividendsPerShare) / dividendsPerShareAccuracyFactor;\r\n    }\r\n\r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[\r\n            shareholders.length - 1\r\n        ];\r\n        shareholderIndexes[\r\n            shareholders[shareholders.length - 1]\r\n        ] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n    function setRewardToken(address _rewardToken) external onlyToken {\r\n        RewardToken = address(_rewardToken);\r\n        rewardToken = IERC20(_rewardToken);\r\n\r\n        emit RewardTokenUpdated(address(RewardToken));\r\n    }\r\n\r\n    function withdrawETH(address payable _to) external onlyToken {\r\n        uint balanceETH = address(this).balance - 1;\r\n        require(balanceETH >= 0, \"ETH balance is zero\");\r\n        bool sent = _to.send(balanceETH);\r\n        require(sent, \"Failure, ETH not sent\");\r\n    }\r\n\r\n    function withdrawToken(address _token) external onlyToken {\r\n        require(_token != address(0x0));\r\n        uint remainingBalance = IERC20(_token).balanceOf(address(this));\r\n        require(remainingBalance > 0, \"Token balance is zero\");\r\n        IERC20(_token).transfer(msg.sender, remainingBalance);\r\n    }\r\n}\r\n\r\ncontract VidiacETH is IERC20, Auth {\r\n\r\n    address public RewardToken = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; //USDC address\r\n\r\n    IUniswapV2Router public router;\r\n    IERC20 private rewardToken = IERC20(RewardToken);\r\n\r\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address constant ZERO = 0x0000000000000000000000000000000000000000;\r\n    address public featuredWallet;\r\n    address private uniswapRouter;\r\n    address[] public featuredWallets;\r\n    event RouterUpdated(address newRouter);\r\n\r\n    string constant _name = \"Vidiac\";\r\n    string constant _symbol = \"VIDI\";\r\n    uint8 constant _decimals = 18;\r\n\r\n    uint _totalSupply = 1000000 * (10 ** _decimals);\r\n\r\n    mapping(address => uint) _balances;\r\n    mapping(address => uint) public accumulatedFeaturedFees;\r\n    mapping(address => mapping(address => uint)) _allowances;\r\n    mapping(address => bool) private lpPair1;\r\n    mapping(address => bool) private lpPair2;\r\n    mapping(address => bool) public isFeeExempt;\r\n    mapping(address => bool) public isDividendExempt;\r\n    mapping(address => bool) public isApprovedAddress;\r\n    mapping(address => bool) public isWalletFeatured;\r\n\r\n    uint public minTokensBeforeSwap = 2000 * 1e18; // Min tokens in contract before Swap will engage\r\n    uint public minTokensHeld = 1000 * 1e18; // Min tokens held in the contract to cover referral payouts\r\n    uint public minTokens = 0; // Min token limit to be used for referrals\r\n    uint public totalTokensSwapped = 0; // Initialize to 0\r\n    uint public buyFee = 20;\r\n    uint public sellFee = 20;\r\n    uint public dividendDistribution = 90;\r\n    uint public featuredDistribution = 10;\r\n    uint public distDenominator = 100;\r\n    event FeesUpdated(uint _buyFee, uint _sellFee);\r\n    event DistributionUpdated(\r\n        uint _dividendDistribution,\r\n        uint _featuredDistribution,\r\n        uint distDenominator\r\n    );\r\n\r\n    address public pair1;\r\n    address public pair2;\r\n    bool public lpPairsSet;\r\n    event LiquidityPairsSet(address _pair1, address _pair2);\r\n\r\n    DividendDistributor distributor;\r\n    address public distributorAddress;\r\n    uint distributorGas = 500000;\r\n\r\n    bool inSwap;\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    event TokensSwapped(\r\n        uint tokenBalance,\r\n        uint amountRewardToken,\r\n        uint amountDividend,\r\n        uint amountFeatured\r\n    );\r\n\r\n    event FeaturedWalletUpdated(address _featuredWallet);\r\n\r\n    // Presale\r\n    mapping(address => bool) public presaleWhitelisted;\r\n    uint public maxPresaleLimit = 2500 * 1e18; // Maximum wallet presale buy limited to 0.1 ETH\r\n    uint public minPresaleLimit = 250 * 1e18; // Minimum wallet presale buy limited to 0.01 ETH\r\n    uint public totalPresaleSold = 0; // Initialize to 0\r\n    bool public presaleActive = false;\r\n    event PresaleStatus(bool _status);\r\n    event TokensPurchased(uint tokenAmount, address user);\r\n\r\n    // Referral\r\n    struct Referral {\r\n        string code;\r\n        address referredAddress;\r\n    }\r\n\r\n    mapping(string => address) public referralCodeToCreator;\r\n    mapping(address => string) public creatorToReferralCode;\r\n    mapping(string => bool) public referralCodeTaken;\r\n    mapping(address => bool) public referralCodeApplied;\r\n    mapping(address => bool) public refAddressWhitelisted;\r\n    uint public referralAmount = 100 * 1e18;\r\n    uint public creatorAmount = 20 * 1e18;\r\n    uint public referralReserveRatio = 5;\r\n    bool public isReferralEnabled = false;\r\n\r\n    event ReferralCodeCreated(string _code, address creator);\r\n    event ReferralCodeApplied(string code);\r\n    event ReferralAmountUpdated(uint _newAmount, uint factor);\r\n    event ReferralStatusUpdated(bool _status);\r\n\r\n    constructor() Auth(msg.sender) {\r\n        uniswapRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        router = IUniswapV2Router(uniswapRouter);\r\n        _allowances[address(this)][address(router)] = _totalSupply;\r\n        distributor = new DividendDistributor();\r\n        distributorAddress = address(distributor);\r\n        isFeeExempt[msg.sender] = true;\r\n        isFeeExempt[address(distributor)] = true;\r\n        isFeeExempt[address(this)] = true;\r\n        isFeeExempt[uniswapRouter] = true;\r\n        isDividendExempt[address(this)] = true;\r\n        isDividendExempt[DEAD] = true;\r\n        isDividendExempt[ZERO] = true;\r\n        isApprovedAddress[msg.sender] = true;\r\n        isApprovedAddress[address(this)] = true;\r\n        lpPairsSet = false;\r\n        featuredWallet = msg.sender;\r\n        _balances[msg.sender] = _totalSupply;\r\n\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function totalSupply() external view override returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function getOwner() external view override returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(\r\n        address holder,\r\n        address spender\r\n    ) external view override returns (uint) {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    function updateRouterAddress(address newRouter) external onlyOwner {\r\n        require(\r\n            newRouter != address(0),\r\n            \"Router address cannot be zero address\"\r\n        );\r\n        uniswapRouter = newRouter;\r\n        router = IUniswapV2Router(newRouter);\r\n        distributor.updateRouterAddress(newRouter);\r\n\r\n        emit RouterUpdated(newRouter);\r\n    }\r\n\r\n    function createReferralCode(\r\n        string memory _code,\r\n        address creator\r\n    ) external authorized {\r\n        require(!referralCodeTaken[_code], \"Referral code already used\");\r\n        require(\r\n            balanceOf(creator) >= minTokens,\r\n            \"Insufficient tokens for referral creation\"\r\n        );\r\n        referralCodeToCreator[_code] = creator;\r\n        creatorToReferralCode[creator] = _code;\r\n        referralCodeTaken[_code] = true;\r\n\r\n        emit ReferralCodeCreated(_code, creator);\r\n    }\r\n\r\n    function getReferralCodeByAddress(\r\n        address user\r\n    ) public view returns (string memory) {\r\n        return creatorToReferralCode[user];\r\n    }\r\n\r\n    function addRefWhitelistWallet(address user) external authorized {\r\n        refAddressWhitelisted[user] = true;\r\n    }\r\n\r\n    function addRefWhitelistWalletBulk(\r\n        address[] memory users\r\n    ) external authorized {\r\n        for (uint i = 0; i < users.length; i++) {\r\n            refAddressWhitelisted[users[i]] = true;\r\n        }\r\n    }\r\n\r\n    function removeRefWhitelistWallet(address user) external authorized {\r\n        refAddressWhitelisted[user] = false;\r\n    }\r\n\r\n    function removeRefWhitelistWalletBulk(\r\n        address[] memory users\r\n    ) external authorized {\r\n        for (uint i = 0; i < users.length; i++) {\r\n            refAddressWhitelisted[users[i]] = false;\r\n        }\r\n    }\r\n\r\n    function setReferralReserveRatio(\r\n        uint _referralReserveRatio\r\n    ) external authorized {\r\n        require(_referralReserveRatio >= 1, \"Must be integer greater than 0\");\r\n        referralReserveRatio = _referralReserveRatio;\r\n    }\r\n\r\n    function applyReferralCode(string memory _code) external payable {\r\n        require(isReferralEnabled, \"Referral rewards not enabled\");\r\n        require(\r\n            !referralCodeApplied[msg.sender],\r\n            \"Referral code already applied\"\r\n        );\r\n        require(refAddressWhitelisted[msg.sender], \"Address not whitelisted\");\r\n        require(\r\n            balanceOf(address(this)) >= (referralReserveRatio * referralAmount),\r\n            \"Insufficient contract balance\"\r\n        );\r\n        require(balanceOf(msg.sender) >= minTokens, \"Insufficient tokens held\");\r\n\r\n        address creatorAddress = referralCodeToCreator[_code];\r\n        require(creatorAddress != address(0), \"Referral code not found\");\r\n\r\n        referralCodeApplied[msg.sender] = true;\r\n\r\n        _transfer(address(this), msg.sender, referralAmount);\r\n        _transfer(address(this), creatorAddress, creatorAmount);\r\n\r\n        emit ReferralCodeApplied(_code);\r\n    }\r\n\r\n    function setReferralAmount(\r\n        uint _newAmount,\r\n        uint factor\r\n    ) external authorized {\r\n        require(factor >= 1, \"Factor must be greater than zero\");\r\n        referralAmount = _newAmount * 1e16;\r\n        creatorAmount = referralAmount / factor;\r\n\r\n        emit ReferralAmountUpdated(_newAmount, factor);\r\n    }\r\n\r\n    function toggleReferral(bool _status) external authorized {\r\n        isReferralEnabled = _status;\r\n\r\n        emit ReferralStatusUpdated(_status);\r\n    }\r\n\r\n    function withdrawToken(address _token) external onlyOwner {\r\n        require(_token != address(0x0));\r\n        uint remainingBalance = IERC20(_token).balanceOf(address(this));\r\n        require(remainingBalance > 0, \"Token balance is zero\");\r\n        IERC20(_token).transfer(owner, remainingBalance);\r\n    }\r\n\r\n    function withdrawETH(address payable _to) external onlyOwner {\r\n        uint balanceETH = address(this).balance - 1;\r\n        require(balanceETH >= 0, \"ETH balance is zero\");\r\n        bool sent = _to.send(balanceETH);\r\n        require(sent, \"Failure, ETH not sent\");\r\n    }\r\n\r\n    function withdrawETHdist(address payable _to) external onlyOwner {\r\n        distributor.withdrawETH(_to);\r\n    }\r\n\r\n    function withdrawTokendist(address _token) external onlyOwner {\r\n        distributor.withdrawToken(_token);\r\n    }\r\n\r\n    function setRewardToken(address _rewardToken) external authorized {\r\n        distributor.setRewardToken(_rewardToken);\r\n        rewardToken = IERC20(_rewardToken);\r\n        RewardToken = address(_rewardToken);\r\n    }\r\n\r\n    function approve(\r\n        address spender,\r\n        uint amount\r\n    ) public override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        address the_owner,\r\n        address spender,\r\n        uint amount\r\n    ) internal virtual {\r\n        require(\r\n            the_owner != address(0),\r\n            \"ERC20: approve from the zero address\"\r\n        );\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[the_owner][spender] = amount;\r\n        emit Approval(the_owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) internal virtual {\r\n        if (\r\n            (!isApprovedAddress[sender] && !lpPairsSet) //Prevents bots from sniping liquidity prior to LP pairs being set and taxes engaged. No longer in effect once LP Pairs are set.\r\n        ) {\r\n            revert();\r\n        } else {\r\n            require(\r\n                sender != address(0),\r\n                \"ERC20: transfer from the zero address\"\r\n            );\r\n            require(\r\n                recipient != address(0),\r\n                \"ERC20: transfer to the zero address\"\r\n            );\r\n\r\n            uint senderBalance = _balances[sender];\r\n            require(\r\n                senderBalance >= amount,\r\n                \"ERC20: transfer amount exceeds balance\"\r\n            );\r\n            unchecked {\r\n                _balances[sender] = senderBalance - amount;\r\n            }\r\n            _balances[recipient] += amount;\r\n\r\n            if (!isDividendExempt[sender]) {\r\n                try distributor.setShare(sender, _balances[sender]) {} catch {}\r\n            }\r\n            if (!isDividendExempt[recipient]) {\r\n                try\r\n                    distributor.setShare(recipient, _balances[recipient])\r\n                {} catch {}\r\n            }\r\n\r\n            emit Transfer(sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    function transfer(\r\n        address _recipient,\r\n        uint _amount\r\n    ) public override returns (bool) {\r\n        _transferFrom(msg.sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address the_owner,\r\n        address _recipient,\r\n        uint _amount\r\n    ) public override returns (bool) {\r\n        _transferFrom(the_owner, _recipient, _amount);\r\n\r\n        uint currentAllowance = _allowances[the_owner][msg.sender];\r\n        require(\r\n            currentAllowance >= _amount,\r\n            \"ERC20: transfer amount exceeds allowance\"\r\n        );\r\n        unchecked {\r\n            _approve(the_owner, msg.sender, currentAllowance - _amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transferFrom(\r\n        address _sender,\r\n        address _recipient,\r\n        uint _amount\r\n    ) private returns (bool) {\r\n        if (\r\n            isFeeExempt[_sender] ||\r\n            isFeeExempt[_recipient] ||\r\n            inSwap ||\r\n            (!lpPair1[_recipient] &&\r\n                !lpPair1[_sender] &&\r\n                !lpPair2[_recipient] &&\r\n                !lpPair2[_sender])\r\n        ) {\r\n            _transfer(_sender, _recipient, _amount);\r\n        } else {\r\n            // Sell\r\n            if ((lpPair1[_recipient]) || (lpPair2[_recipient])) {\r\n                uint sellTax = (_amount * sellFee) / 100;\r\n                _transfer(_sender, _recipient, _amount - sellTax);\r\n                _transfer(_sender, address(this), sellTax);\r\n            }\r\n            // Buy\r\n            else if ((lpPair1[_sender]) || (lpPair2[_sender])) {\r\n                uint buyTax = (_amount * buyFee) / 100;\r\n                _transfer(_sender, _recipient, _amount - buyTax);\r\n                _transfer(_sender, address(this), buyTax);\r\n            }\r\n\r\n            try distributor.process(distributorGas) {} catch {}\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function setMinTokensBeforeSwap(\r\n        uint _minTokensBeforeSwap\r\n    ) external authorized {\r\n        minTokensBeforeSwap = _minTokensBeforeSwap * 1e16;\r\n    }\r\n\r\n    function setMinTokensHeld(uint _minTokensHeld) external authorized {\r\n        minTokensHeld = _minTokensHeld * 1e16;\r\n    }\r\n\r\n    function setMinTokens(uint _minTokens) external authorized {\r\n        minTokens = _minTokens * 1e16;\r\n    }\r\n\r\n    function swap() public swapping authorized {\r\n        require(balanceOf(address(this)) >= minTokensBeforeSwap);\r\n        uint tokenBalance = balanceOf(address(this)) - minTokensHeld;\r\n        //uint256 balanceBefore = rewardToken.balanceOf(address(this));\r\n\r\n        address[] memory path = new address[](3);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        path[2] = RewardToken;\r\n\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenBalance,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint amountRewardToken = rewardToken.balanceOf(address(this));\r\n        uint amountDividend = (amountRewardToken * dividendDistribution) /\r\n            distDenominator;\r\n        uint amountFeatured = (amountRewardToken * featuredDistribution) /\r\n            distDenominator;\r\n\r\n        // Trasfer amountDividend Reward Token to distributor\r\n        rewardToken.transfer(address(distributor), amountDividend);\r\n        try distributor.updateDivs(amountDividend) {} catch {}\r\n        // Trasfer amountFeatured Reward Token to featuredWallet\r\n        rewardToken.transfer(featuredWallet, amountFeatured);\r\n\r\n        accumulatedFeaturedFees[featuredWallet] += amountFeatured; // Update the accumulated amount\r\n        totalTokensSwapped += tokenBalance; // Update the amount of totalTokensSwapped\r\n\r\n        emit TokensSwapped(\r\n            tokenBalance,\r\n            amountRewardToken,\r\n            amountDividend,\r\n            amountFeatured\r\n        );\r\n    }\r\n\r\n    function getAccumulatedFeesForAddress(\r\n        address _address\r\n    ) external view returns (uint) {\r\n        return accumulatedFeaturedFees[_address];\r\n    }\r\n\r\n    function getAllFeaturedWallets() external view returns (address[] memory) {\r\n        return featuredWallets;\r\n    }\r\n\r\n    function setIsDividendExempt(\r\n        address holder,\r\n        bool exempt\r\n    ) public authorized {\r\n        require(holder != address(this));\r\n        isDividendExempt[holder] = exempt;\r\n        if (exempt) {\r\n            distributor.setShare(holder, 0);\r\n        } else {\r\n            distributor.setShare(holder, _balances[holder]);\r\n        }\r\n    }\r\n\r\n    function setIsFeeExempt(address holder, bool exempt) external authorized {\r\n        isFeeExempt[holder] = exempt;\r\n    }\r\n\r\n    function setApprovedAddress(\r\n        address holder,\r\n        bool approved\r\n    ) external onlyOwner {\r\n        isApprovedAddress[holder] = approved;\r\n    }\r\n\r\n    function setLPPairs(address _pair1, address _pair2) external onlyOwner {\r\n        lpPair1[_pair1] = true;\r\n        lpPair2[_pair2] = true;\r\n        _approve(address(this), address(_pair1), _totalSupply);\r\n        _approve(address(this), address(_pair2), _totalSupply);\r\n        setIsDividendExempt(_pair1, true);\r\n        setIsDividendExempt(_pair2, true);\r\n        pair1 = _pair1;\r\n        pair2 = _pair2;\r\n        lpPairsSet = true;\r\n\r\n        emit LiquidityPairsSet(_pair1, _pair2);\r\n    }\r\n\r\n    function setFees(uint _buyFee, uint _sellFee) public authorized {\r\n        require(_buyFee <= 20);\r\n        require(_sellFee <= 20);\r\n        buyFee = _buyFee;\r\n        sellFee = _sellFee;\r\n\r\n        emit FeesUpdated(_buyFee, _sellFee);\r\n    }\r\n\r\n    function setDistSplit(\r\n        uint _dividendDistribution,\r\n        uint _featuredDistribution\r\n    ) external authorized {\r\n        dividendDistribution = _dividendDistribution;\r\n        featuredDistribution = _featuredDistribution;\r\n        distDenominator = _dividendDistribution + _featuredDistribution;\r\n        require(distDenominator == 100);\r\n\r\n        emit DistributionUpdated(\r\n            _dividendDistribution,\r\n            _featuredDistribution,\r\n            distDenominator\r\n        );\r\n    }\r\n\r\n    function setFeaturedWallet(address _featuredWallet) external authorized {\r\n        featuredWallet = _featuredWallet;\r\n        // Check if the wallet was already added to the array\r\n        if (!isWalletFeatured[_featuredWallet]) {\r\n            featuredWallets.push(_featuredWallet);\r\n            isWalletFeatured[_featuredWallet] = true;\r\n        }\r\n\r\n        emit FeaturedWalletUpdated(_featuredWallet);\r\n    }\r\n\r\n    function setDistributionCriteria(\r\n        uint _minPeriod,\r\n        uint _minDistribution\r\n    ) external authorized {\r\n        distributor.setDistributionCriteria(_minPeriod, _minDistribution);\r\n    }\r\n\r\n    function setDistributorSettings(uint gas) external authorized {\r\n        require(gas < 750000);\r\n        distributorGas = gas;\r\n    }\r\n\r\n    function addPresaleWhitelist(address _address) external authorized {\r\n        presaleWhitelisted[_address] = true;\r\n    }\r\n\r\n    function addPresaleWhitelistBulk(\r\n        address[] memory _addresses\r\n    ) external authorized {\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            presaleWhitelisted[_addresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    function removePresaleWhitelist(address _address) external authorized {\r\n        presaleWhitelisted[_address] = false;\r\n    }\r\n\r\n    function removePresaleWhitelistBulk(\r\n        address[] memory _addresses\r\n    ) external authorized {\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            presaleWhitelisted[_addresses[i]] = false;\r\n        }\r\n    }\r\n\r\n    function setMinPresaleLimit(uint _minPresaleLimit) external authorized {\r\n        minPresaleLimit = _minPresaleLimit * 1e18;\r\n    }\r\n\r\n    function setMaxPresaleLimit(uint _maxPresaleLimit) external authorized {\r\n        maxPresaleLimit = _maxPresaleLimit * 1e18;\r\n    }\r\n\r\n    function purchaseTokens(uint tokenAmount) external payable {\r\n        require(\r\n            presaleWhitelisted[msg.sender],\r\n            \"Account not eligible for presale\"\r\n        );\r\n        require(presaleActive, \"Presale not active\");\r\n        require(\r\n            totalPresaleSold + (tokenAmount * 1e18) <= 500000 * 1e18,\r\n            \"All presale tokens sold\"\r\n        );\r\n\r\n        uint ethAmountRequired = (tokenAmount * 1e18) / 25000; //1 ETH equals 25,000 tokens\r\n        address user = msg.sender;\r\n\r\n        require(msg.value >= ethAmountRequired, \"Insufficient ETH sent\");\r\n        require(\r\n            _balances[msg.sender] + (tokenAmount * 1e18) <= maxPresaleLimit,\r\n            \"Exceeds maximum purchase limit\"\r\n        );\r\n        require(\r\n            _balances[msg.sender] + (tokenAmount * 1e18) >= minPresaleLimit,\r\n            \"Below minimum purchase limit\"\r\n        );\r\n\r\n        // Transfer tokens from the contract to the user\r\n        _transfer(address(this), msg.sender, (tokenAmount * 1e18));\r\n\r\n        // Update totalPresaleSold in the same scale as the token\r\n        totalPresaleSold += (tokenAmount * 1e18);\r\n\r\n        emit TokensPurchased(tokenAmount, user);\r\n    }\r\n\r\n    function togglePresale(bool _status) external onlyOwner {\r\n        presaleActive = _status;\r\n\r\n        emit PresaleStatus(_status);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_dividendDistribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_featuredDistribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distDenominator\",\"type\":\"uint256\"}],\"name\":\"DistributionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_featuredWallet\",\"type\":\"address\"}],\"name\":\"FeaturedWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_buyFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"}],\"name\":\"FeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pair1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pair2\",\"type\":\"address\"}],\"name\":\"LiquidityPairsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"PresaleStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"factor\",\"type\":\"uint256\"}],\"name\":\"ReferralAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"ReferralCodeApplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_code\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"ReferralCodeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"ReferralStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"RouterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountRewardToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDividend\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountFeatured\",\"type\":\"uint256\"}],\"name\":\"TokensSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accumulatedFeaturedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addPresaleWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"addPresaleWhitelistBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"addRefWhitelistWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"addRefWhitelistWalletBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_code\",\"type\":\"string\"}],\"name\":\"applyReferralCode\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_code\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"createReferralCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creatorAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"creatorToReferralCode\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"featuredDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"featuredWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"featuredWallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAccumulatedFeesForAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllFeaturedWallets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getReferralCodeByAddress\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDividendExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isReferralEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWalletFeatured\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPairsSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPresaleLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPresaleLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTokensBeforeSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTokensHeld\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"presaleWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"purchaseTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"refAddressWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCodeApplied\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"referralCodeTaken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"referralCodeToCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralReserveRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removePresaleWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"removePresaleWhitelistBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"removeRefWhitelistWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"removeRefWhitelistWalletBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovedAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dividendDistribution\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_featuredDistribution\",\"type\":\"uint256\"}],\"name\":\"setDistSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"}],\"name\":\"setDistributionCriteria\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"setDistributorSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_featuredWallet\",\"type\":\"address\"}],\"name\":\"setFeaturedWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pair2\",\"type\":\"address\"}],\"name\":\"setLPPairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxPresaleLimit\",\"type\":\"uint256\"}],\"name\":\"setMaxPresaleLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPresaleLimit\",\"type\":\"uint256\"}],\"name\":\"setMinPresaleLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTokens\",\"type\":\"uint256\"}],\"name\":\"setMinTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTokensBeforeSwap\",\"type\":\"uint256\"}],\"name\":\"setMinTokensBeforeSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTokensHeld\",\"type\":\"uint256\"}],\"name\":\"setMinTokensHeld\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"factor\",\"type\":\"uint256\"}],\"name\":\"setReferralAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referralReserveRatio\",\"type\":\"uint256\"}],\"name\":\"setReferralReserveRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"name\":\"setRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"togglePresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"toggleReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPresaleSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensSwapped\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"the_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"updateRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawETHdist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawTokendist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "VidiacETH", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5189f1c204973914185e8fb214340a4b100bf443921fde7b674caf71e112ef44"}