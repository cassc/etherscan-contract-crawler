{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/UniswapUniversalRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// @credits : Salman Haider\\r\\n\\r\\npragma solidity 0.8.17;\\r\\nimport \\\"https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Commands.sol\\\";\\r\\nimport \\\"https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Constants.sol\\\";\\r\\n\\r\\ninterface IUniversalRouter  {\\r\\n    /// @notice Executes encoded commands along with provided inputs. Reverts if deadline has expired.\\r\\n    /// @param commands A set of concatenated commands, each 1 byte in length\\r\\n    /// @param inputs An array of byte strings containing abi encoded inputs for each command\\r\\n    /// @param deadline The deadline by which the transaction must be executed\\r\\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable;\\r\\n}\\r\\ninterface IPermit2 {\\r\\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external ;\\r\\n}\\r\\ninterface IERC20 {\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n}\\r\\n\\r\\ncontract UniswapUniversalRouter{\\r\\n    IUniversalRouter router;\\r\\n    IPermit2 constant PERMIT2 = IPermit2(0x000000000022D473030F116dDEE9F6B43aC78BA3);\\r\\n    constructor(address _routerAddress) {\\r\\n        router=IUniversalRouter(_routerAddress); //0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD\\r\\n    }\\r\\n    function swap(address token0,address token1,uint amount_in)public {\\r\\n        IERC20(token0).transferFrom(msg.sender,address(this),amount_in);\\r\\n        IERC20(token0).approve(address(PERMIT2), amount_in);\\r\\n        PERMIT2.approve(token0, address(router), type(uint160).max, type(uint48).max);\\r\\n        bytes memory commands = abi.encodePacked(bytes1(uint8(Commands.V2_SWAP_EXACT_IN)));\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = token0;\\r\\n        path[1] = token1;\\r\\n        bytes[] memory inputs = new bytes[](1);\\r\\n        inputs[0] = abi.encode(Constants.MSG_SENDER, amount_in, 0, path, true);\\r\\n\\r\\n        router.execute(commands, inputs,type(uint48).max);\\r\\n    }\\r\\n    function withdraw(address destToken)public payable {\\r\\n        IERC20(destToken).transfer(msg.sender, IERC20(destToken).balanceOf(address(this)) );\\r\\n        require(IERC20(destToken).balanceOf(address(this))==0,\\\"Withdraw Failed !\\\" );\\r\\n\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.17;\\n\\nimport {IWETH9} from '../interfaces/external/IWETH9.sol';\\n\\n/// @title Constant state\\n/// @notice Constant state used by the Universal Router\\nlibrary Constants {\\n    /// @dev Used for identifying cases when this contract's balance of a token is to be used as an input\\n    /// This value is equivalent to 1<<255, i.e. a singular 1 in the most significant bit.\\n    uint256 internal constant CONTRACT_BALANCE = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n    /// @dev Used for identifying cases when a v2 pair has already received input tokens\\n    uint256 internal constant ALREADY_PAID = 0;\\n\\n    /// @dev Used as a flag for identifying the transfer of ETH instead of a token\\n    address internal constant ETH = address(0);\\n\\n    /// @dev Used as a flag for identifying that msg.sender should be used, saves gas by sending more 0 bytes\\n    address internal constant MSG_SENDER = address(1);\\n\\n    /// @dev Used as a flag for identifying address(this) should be used, saves gas by sending more 0 bytes\\n    address internal constant ADDRESS_THIS = address(2);\\n\\n    /// @dev The length of the bytes encoded address\\n    uint256 internal constant ADDR_SIZE = 20;\\n\\n    /// @dev The length of the bytes encoded fee\\n    uint256 internal constant V3_FEE_SIZE = 3;\\n\\n    /// @dev The offset of a single token address (20) and pool fee (3)\\n    uint256 internal constant NEXT_V3_POOL_OFFSET = ADDR_SIZE + V3_FEE_SIZE;\\n\\n    /// @dev The offset of an encoded pool key\\n    /// Token (20) + Fee (3) + Token (20) = 43\\n    uint256 internal constant V3_POP_OFFSET = NEXT_V3_POOL_OFFSET + ADDR_SIZE;\\n\\n    /// @dev The minimum length of an encoding that contains 2 or more pools\\n    uint256 internal constant MULTIPLE_V3_POOLS_MIN_LENGTH = V3_POP_OFFSET + NEXT_V3_POOL_OFFSET;\\n}\\n\"\r\n    },\r\n    \"https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Commands.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.17;\\n\\n/// @title Commands\\n/// @notice Command Flags used to decode commands\\nlibrary Commands {\\n    // Masks to extract certain bits of commands\\n    bytes1 internal constant FLAG_ALLOW_REVERT = 0x80;\\n    bytes1 internal constant COMMAND_TYPE_MASK = 0x3f;\\n\\n    // Command Types. Maximum supported command at this moment is 0x3f.\\n\\n    // Command Types where value<0x08, executed in the first nested-if block\\n    uint256 constant V3_SWAP_EXACT_IN = 0x00;\\n    uint256 constant V3_SWAP_EXACT_OUT = 0x01;\\n    uint256 constant PERMIT2_TRANSFER_FROM = 0x02;\\n    uint256 constant PERMIT2_PERMIT_BATCH = 0x03;\\n    uint256 constant SWEEP = 0x04;\\n    uint256 constant TRANSFER = 0x05;\\n    uint256 constant PAY_PORTION = 0x06;\\n    // COMMAND_PLACEHOLDER = 0x07;\\n\\n    // The commands are executed in nested if blocks to minimise gas consumption\\n    // The following constant defines one of the boundaries where the if blocks split commands\\n    uint256 constant FIRST_IF_BOUNDARY = 0x08;\\n\\n    // Command Types where 0x08<=value<=0x0f, executed in the second nested-if block\\n    uint256 constant V2_SWAP_EXACT_IN = 0x08;\\n    uint256 constant V2_SWAP_EXACT_OUT = 0x09;\\n    uint256 constant PERMIT2_PERMIT = 0x0a;\\n    uint256 constant WRAP_ETH = 0x0b;\\n    uint256 constant UNWRAP_WETH = 0x0c;\\n    uint256 constant PERMIT2_TRANSFER_FROM_BATCH = 0x0d;\\n    uint256 constant BALANCE_CHECK_ERC20 = 0x0e;\\n    // COMMAND_PLACEHOLDER = 0x0f;\\n\\n    // The commands are executed in nested if blocks to minimise gas consumption\\n    // The following constant defines one of the boundaries where the if blocks split commands\\n    uint256 constant SECOND_IF_BOUNDARY = 0x10;\\n\\n    // Command Types where 0x10<=value<0x18, executed in the third nested-if block\\n    uint256 constant SEAPORT_V1_5 = 0x10;\\n    uint256 constant LOOKS_RARE_V2 = 0x11;\\n    uint256 constant NFTX = 0x12;\\n    uint256 constant CRYPTOPUNKS = 0x13;\\n    // 0x14;\\n    uint256 constant OWNER_CHECK_721 = 0x15;\\n    uint256 constant OWNER_CHECK_1155 = 0x16;\\n    uint256 constant SWEEP_ERC721 = 0x17;\\n\\n    // The commands are executed in nested if blocks to minimise gas consumption\\n    // The following constant defines one of the boundaries where the if blocks split commands\\n    uint256 constant THIRD_IF_BOUNDARY = 0x18;\\n\\n    // Command Types where 0x18<=value<=0x1f, executed in the final nested-if block\\n    uint256 constant X2Y2_721 = 0x18;\\n    uint256 constant SUDOSWAP = 0x19;\\n    uint256 constant NFT20 = 0x1a;\\n    uint256 constant X2Y2_1155 = 0x1b;\\n    uint256 constant FOUNDATION = 0x1c;\\n    uint256 constant SWEEP_ERC1155 = 0x1d;\\n    uint256 constant ELEMENT_MARKET = 0x1e;\\n    // COMMAND_PLACEHOLDER = 0x1f;\\n\\n    // The commands are executed in nested if blocks to minimise gas consumption\\n    // The following constant defines one of the boundaries where the if blocks split commands\\n    uint256 constant FOURTH_IF_BOUNDARY = 0x20;\\n\\n    // Command Types where 0x20<=value\\n    uint256 constant SEAPORT_V1_4 = 0x20;\\n    uint256 constant EXECUTE_SUB_PLAN = 0x21;\\n    uint256 constant APPROVE_ERC20 = 0x22;\\n    uint256 constant WRAP_STETH = 0x23;\\n    uint256 constant UNWRAP_STETH = 0x24;\\n\\n    // COMMAND_PLACEHOLDER for 0x25 to 0x3f (all unused)\\n}\\n\"\r\n    },\r\n    \"https://github.com/Uniswap/universal-router/blob/main/contracts/interfaces/external/IWETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/// @title Interface for WETH9\\ninterface IWETH9 is IERC20 {\\n    /// @notice Deposit ether to get wrapped ether\\n    function deposit() external payable;\\n\\n    /// @notice Withdraw wrapped ether to get ether\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_routerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_in\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "UniswapUniversalRouter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000003fc91a3afd70395cd496c647d5a6cc9d4b2b7fad", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}