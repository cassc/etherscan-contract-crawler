{"SourceCode": "# pragma version 0.3.10\r\n# pragma optimize gas\r\n# pragma evm-version shanghai\r\n\"\"\"\r\n@title CurveStableSwapNGMath\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n@notice Math for StableSwapMetaNG implementation\r\n\"\"\"\r\n\r\nMAX_COINS: constant(uint256) = 8\r\nMAX_COINS_128: constant(int128) = 8\r\nA_PRECISION: constant(uint256) = 100\r\n\r\n\r\n@external\r\n@pure\r\ndef get_y(\r\n    i: int128,\r\n    j: int128,\r\n    x: uint256,\r\n    xp: DynArray[uint256, MAX_COINS],\r\n    _amp: uint256,\r\n    _D: uint256,\r\n    _n_coins: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    Calculate x[j] if one makes x[i] = x\r\n\r\n    Done by solving quadratic equation iteratively.\r\n    x_1**2 + x_1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n    x_1**2 + b*x_1 = c\r\n\r\n    x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n    \"\"\"\r\n    # x in the input is converted to the same price/precision\r\n\r\n    n_coins_128: int128 = convert(_n_coins, int128)\r\n\r\n    assert i != j       # dev: same coin\r\n    assert j >= 0       # dev: j below zero\r\n    assert j < n_coins_128  # dev: j above N_COINS\r\n\r\n    # should be unreachable, but good for safety\r\n    assert i >= 0\r\n    assert i < n_coins_128\r\n\r\n    amp: uint256 = _amp\r\n    D: uint256 = _D\r\n    S_: uint256 = 0\r\n    _x: uint256 = 0\r\n    y_prev: uint256 = 0\r\n    c: uint256 = D\r\n    Ann: uint256 = amp * _n_coins\r\n\r\n    for _i in range(MAX_COINS_128):\r\n\r\n        if _i == n_coins_128:\r\n            break\r\n\r\n        if _i == i:\r\n            _x = x\r\n        elif _i != j:\r\n            _x = xp[_i]\r\n        else:\r\n            continue\r\n\r\n        S_ += _x\r\n        c = c * D / (_x * _n_coins)\r\n\r\n    c = c * D * A_PRECISION / (Ann * _n_coins)\r\n    b: uint256 = S_ + D * A_PRECISION / Ann  # - D\r\n    y: uint256 = D\r\n\r\n    for _i in range(255):\r\n        y_prev = y\r\n        y = (y*y + c) / (2 * y + b - D)\r\n        # Equality with the precision of 1\r\n        if y > y_prev:\r\n            if y - y_prev <= 1:\r\n                return y\r\n        else:\r\n            if y_prev - y <= 1:\r\n                return y\r\n    raise\r\n\r\n\r\n@external\r\n@pure\r\ndef get_D(\r\n    _xp: DynArray[uint256, MAX_COINS],\r\n    _amp: uint256,\r\n    _n_coins: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    D invariant calculation in non-overflowing integer operations\r\n    iteratively\r\n\r\n    A * sum(x_i) * n**n + D = A * D * n**n + D**(n+1) / (n**n * prod(x_i))\r\n\r\n    Converging solution:\r\n    D[j+1] = (A * n**n * sum(x_i) - D[j]**(n+1) / (n**n prod(x_i))) / (A * n**n - 1)\r\n    \"\"\"\r\n    S: uint256 = 0\r\n    for x in _xp:\r\n        S += x\r\n    if S == 0:\r\n        return 0\r\n\r\n    D: uint256 = S\r\n    Ann: uint256 = _amp * _n_coins\r\n    D_P: uint256 = 0\r\n    Dprev: uint256 = 0\r\n\r\n    for i in range(255):\r\n\r\n        D_P = D\r\n        for x in _xp:\r\n            D_P = D_P * D / (x * _n_coins)  # If division by 0, this will be borked: only withdrawal will work. And that is good\r\n        Dprev = D\r\n\r\n        # (Ann * S / A_PRECISION + D_P * _n_coins) * D / ((Ann - A_PRECISION) * D / A_PRECISION + (_n_coins + 1) * D_P)\r\n        D = (\r\n            (unsafe_div(Ann * S, A_PRECISION) + D_P * _n_coins) *\r\n            D / (\r\n                unsafe_div((Ann - A_PRECISION) * D, A_PRECISION) +\r\n                unsafe_add(_n_coins, 1) * D_P\r\n            )\r\n        )\r\n        # Equality with the precision of 1\r\n        if D > Dprev:\r\n            if D - Dprev <= 1:\r\n                return D\r\n        else:\r\n            if Dprev - D <= 1:\r\n                return D\r\n    # convergence typically occurs in 4 rounds or less, this should be unreachable!\r\n    # if it does happen the pool is borked and LPs can withdraw via `remove_liquidity`\r\n    raise\r\n\r\n\r\n@external\r\n@pure\r\ndef get_y_D(\r\n    A: uint256,\r\n    i: int128,\r\n    xp: DynArray[uint256, MAX_COINS],\r\n    D: uint256,\r\n    _n_coins: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    Calculate x[i] if one reduces D from being calculated for xp to D\r\n\r\n    Done by solving quadratic equation iteratively.\r\n    x_1**2 + x_1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n    x_1**2 + b*x_1 = c\r\n\r\n    x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n    \"\"\"\r\n    # x in the input is converted to the same price/precision\r\n\r\n    n_coins_128: int128 = convert(_n_coins, int128)\r\n\r\n    assert i >= 0  # dev: i below zero\r\n    assert i < n_coins_128  # dev: i above N_COINS\r\n\r\n    S_: uint256 = 0\r\n    _x: uint256 = 0\r\n    y_prev: uint256 = 0\r\n    c: uint256 = D\r\n    Ann: uint256 = A * _n_coins\r\n\r\n    for _i in range(MAX_COINS_128):\r\n\r\n        if _i == n_coins_128:\r\n            break\r\n\r\n        if _i != i:\r\n            _x = xp[_i]\r\n        else:\r\n            continue\r\n        S_ += _x\r\n        c = c * D / (_x * _n_coins)\r\n\r\n    c = c * D * A_PRECISION / (Ann * _n_coins)\r\n    b: uint256 = S_ + D * A_PRECISION / Ann\r\n    y: uint256 = D\r\n\r\n    for _i in range(255):\r\n        y_prev = y\r\n        y = (y*y + c) / (2 * y + b - D)\r\n        # Equality with the precision of 1\r\n        if y > y_prev:\r\n            if y - y_prev <= 1:\r\n                return y\r\n        else:\r\n            if y_prev - y <= 1:\r\n                return y\r\n    raise\r\n\r\n\r\n@external\r\n@pure\r\ndef exp(x: int256) -> uint256:\r\n\r\n    \"\"\"\r\n    @dev Calculates the natural exponential function of a signed integer with\r\n         a precision of 1e18.\r\n    @notice Note that this function consumes about 810 gas units. The implementation\r\n            is inspired by Remco Bloemen's implementation under the MIT license here:\r\n            https://xn--2-umb.com/22/exp-ln.\r\n    @dev This implementation is derived from Snekmate, which is authored\r\n         by pcaversaccio (Snekmate), distributed under the AGPL-3.0 license.\r\n         https://github.com/pcaversaccio/snekmate\r\n    @param x The 32-byte variable.\r\n    @return int256 The 32-byte calculation result.\r\n    \"\"\"\r\n    value: int256 = x\r\n\r\n    # If the result is `< 0.5`, we return zero. This happens when we have the following:\r\n    # \"x <= floor(log(0.5e18) * 1e18) ~ -42e18\".\r\n    if (x <= -42139678854452767551):\r\n        return empty(uint256)\r\n\r\n    # When the result is \"> (2 ** 255 - 1) / 1e18\" we cannot represent it as a signed integer.\r\n    # This happens when \"x >= floor(log((2 ** 255 - 1) / 1e18) * 1e18) ~ 135\".\r\n    assert x < 135305999368893231589, \"wad_exp overflow\"\r\n\r\n    # `x` is now in the range \"(-42, 136) * 1e18\". Convert to \"(-42, 136) * 2 ** 96\" for higher\r\n    # intermediate precision and a binary base. This base conversion is a multiplication with\r\n    # \"1e18 / 2 ** 96 = 5 ** 18 / 2 ** 78\".\r\n    value = unsafe_div(x << 78, 5 ** 18)\r\n\r\n    # Reduce the range of `x` to \"(-\u00bd ln 2, \u00bd ln 2) * 2 ** 96\" by factoring out powers of two\r\n    # so that \"exp(x) = exp(x') * 2 ** k\", where `k` is a signer integer. Solving this gives\r\n    # \"k = round(x / log(2))\" and \"x' = x - k * log(2)\". Thus, `k` is in the range \"[-61, 195]\".\r\n    k: int256 = unsafe_add(unsafe_div(value << 96, 54916777467707473351141471128), 2 ** 95) >> 96\r\n    value = unsafe_sub(value, unsafe_mul(k, 54916777467707473351141471128))\r\n\r\n    # Evaluate using a \"(6, 7)\"-term rational approximation. Since `p` is monic,\r\n    # we will multiply by a scaling factor later.\r\n    y: int256 = unsafe_add(unsafe_mul(unsafe_add(value, 1346386616545796478920950773328), value) >> 96, 57155421227552351082224309758442)\r\n    p: int256 = unsafe_add(unsafe_mul(unsafe_add(unsafe_mul(unsafe_sub(unsafe_add(y, value), 94201549194550492254356042504812), y) >> 96,\\\r\n                           28719021644029726153956944680412240), value), 4385272521454847904659076985693276 << 96)\r\n\r\n    # We leave `p` in the \"2 ** 192\" base so that we do not have to scale it up\r\n    # again for the division.\r\n    q: int256 = unsafe_add(unsafe_mul(unsafe_sub(value, 2855989394907223263936484059900), value) >> 96, 50020603652535783019961831881945)\r\n    q = unsafe_sub(unsafe_mul(q, value) >> 96, 533845033583426703283633433725380)\r\n    q = unsafe_add(unsafe_mul(q, value) >> 96, 3604857256930695427073651918091429)\r\n    q = unsafe_sub(unsafe_mul(q, value) >> 96, 14423608567350463180887372962807573)\r\n    q = unsafe_add(unsafe_mul(q, value) >> 96, 26449188498355588339934803723976023)\r\n\r\n    # The polynomial `q` has no zeros in the range because all its roots are complex.\r\n    # No scaling is required, as `p` is already \"2 ** 96\" too large. Also,\r\n    # `r` is in the range \"(0.09, 0.25) * 2**96\" after the division.\r\n    r: int256 = unsafe_div(p, q)\r\n\r\n    # To finalise the calculation, we have to multiply `r` by:\r\n    #   - the scale factor \"s = ~6.031367120\",\r\n    #   - the factor \"2 ** k\" from the range reduction, and\r\n    #   - the factor \"1e18 / 2 ** 96\" for the base conversion.\r\n    # We do this all at once, with an intermediate result in \"2**213\" base,\r\n    # so that the final right shift always gives a positive value.\r\n\r\n    # Note that to circumvent Vyper's safecast feature for the potentially\r\n    # negative parameter value `r`, we first convert `r` to `bytes32` and\r\n    # subsequently to `uint256`. Remember that the EVM default behaviour is\r\n    # to use two's complement representation to handle signed integers.\r\n    return unsafe_mul(convert(convert(r, bytes32), uint256), 3822833074963236453042738258902158003155416615667) >> convert(unsafe_sub(195, k), uint256)", "ABI": "[{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"get_y\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"xp\",\"type\":\"uint256[]\"},{\"name\":\"_amp\",\"type\":\"uint256\"},{\"name\":\"_D\",\"type\":\"uint256\"},{\"name\":\"_n_coins\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"get_D\",\"inputs\":[{\"name\":\"_xp\",\"type\":\"uint256[]\"},{\"name\":\"_amp\",\"type\":\"uint256\"},{\"name\":\"_n_coins\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"get_y_D\",\"inputs\":[{\"name\":\"A\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"xp\",\"type\":\"uint256[]\"},{\"name\":\"D\",\"type\":\"uint256\"},{\"name\":\"_n_coins\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"exp\",\"inputs\":[{\"name\":\"x\",\"type\":\"int256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "CurveStableSwapNGMath", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}