{"SourceCode": "{\"AFiStorage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity =0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./IAFiStorage.sol\\\";\\nimport \\\"./IAFi.sol\\\";\\nimport \\\"./IUniswapV3.sol\\\";\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport {ReentrancyGuard} from \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ArrayUtils.sol\\\";\\nimport {AggregatorV3Interface} from \\\"./AggregatorV3Interface.sol\\\";\\n\\n/**\\n * @title AFiStorage.\\n * @notice Storage conntract for storing investors and teamwallets details and performig the storage changes.\\n * @dev Error codes: AFS01: Cannot be address zero. AFS02: Unauthorized caller.\\n */\\n\\ninterface Compound {\\n  function exchangeRateStored() external view returns (uint);\\n}\\n\\nenum AssetDenomination {\\n  Wei // the amount is denominated in wei\\n}\\n\\nenum AssetReference {\\n  Delta // the amount is given as a delta from the current value\\n}\\n\\nstruct Wei {\\n  bool sign; // true if positive\\n  uint value;\\n}\\n\\nstruct Info {\\n  address owner; // The address that owns the account\\n  uint number; // A nonce that allows a single address to control many accounts\\n}\\n\\nenum ActionType {\\n  Deposit, // supply tokens\\n  Withdraw // borrow tokens\\n}\\n\\nstruct AssetAmount {\\n  bool sign; // true if positive\\n  AssetDenomination denomination;\\n  AssetReference ref;\\n  uint value;\\n}\\n\\nstruct ActionArgs {\\n  ActionType actionType;\\n  uint accountId;\\n  AssetAmount amount;\\n  uint primaryMarketId;\\n  uint secondaryMarketId;\\n  address otherAddress;\\n  uint otherAccountId;\\n  bytes data;\\n}\\n\\nabstract contract DyDx {\\n  function getAccountWei(\\n    Info memory account,\\n    uint marketId\\n  ) public view virtual returns (Wei memory);\\n\\n  function operate(Info[] memory, ActionArgs[] memory) public virtual;\\n}\\n\\ncontract AFiStorage is Ownable, IAFiStorage, ReentrancyGuard {\\n  using SafeMath for uint;\\n  using ArrayUtils for uint[];\\n  using ArrayUtils for address[];\\n\\n  address private aFiManager;\\n  mapping(address =\\u003e address) public apr; // fetch apr for different u tokens on different protocols\\n\\n  // List of TeamWallets, helpful when fetching team wallets report\\n  mapping(address =\\u003e address[]) internal teamWalletsOfAFi;\\n  // aFiContract =\\u003e investor =\\u003e Investor Struct\\n  mapping(address =\\u003e mapping(address =\\u003e Investor)) internal investorInAFi;\\n  // aFiContract =\\u003e teamWallet =\\u003e TeamWallet Struct\\n  mapping(address =\\u003e mapping(address =\\u003e TeamWallet)) internal teamWalletInAFi;\\n  mapping(address =\\u003e uint) internal numConfirmationsRequired;\\n  mapping(address =\\u003e uint) internal totalActiveTeamWallets;\\n  mapping(address =\\u003e bool) internal initilizeStatus;\\n  mapping(address =\\u003e bool) internal initializeTokenStatus;\\n  mapping(address =\\u003e bool) internal initializePlatformDataStatus;\\n  mapping(address =\\u003e bool) internal onlyOnce;\\n  mapping(address =\\u003e bool) public isAFiActive;\\n  mapping(address =\\u003e RebalanceDetails[]) internal _rebalanceDetails;\\n\\n  uint256 internal amountDeducted;\\n  uint256 internal redFromContract;\\n\\n  //synData\\n  mapping(address =\\u003e mapping(address =\\u003e address)) public compoundCopy; // compound address for various u tokens\\n  mapping(address =\\u003e mapping(address =\\u003e address)) public aaveTokenCopy; // aaveToken address for various u tokens\\n  mapping(address =\\u003e mapping(address =\\u003e uint)) public dTokenCopy;\\n  mapping(address =\\u003e mapping(address =\\u003eIAFiStorage.Lender)) public provider; // Protocol where each u token is invested\\n  mapping(address =\\u003e mapping(address =\\u003e bool)) internal _isStaked;\\n  mapping(address =\\u003e mapping(address =\\u003euint)) internal stalePriceDelay;\\n\\n  address public constant dydx = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\\n  address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n  address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n  address private constant USDC_ORACLE = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;\\n  address public immutable uniswapOracleV3;\\n\\n  /*\\n    Is underlying token staked\\n    isUTokenStaked: AFi =\\u003e UToken `isUTokenStaked[AFi][UToken]`\\n    isRebalanced: AFi `isRebalanced[AFi]`\\n  */\\n  mapping(address =\\u003e bool) internal isActiveRebalanced;\\n\\n  event UpdateRebalanceDetails(\\n    address indexed aFiContract,\\n    address rbToken,\\n    uint8 scenario\\n  );\\n  event SetActiveRebalancedStatus(address indexed aFiContract, bool status);\\n  event SetAFiActive(address indexed aFiContract, bool status);\\n  event ReActivateTeamWallet(address aFiContract, address wallet);\\n  event DeactivateTeamWallet(address aFiContract, address wallet);\\n  event SetAPR(address aFiContract, address _apr);\\n\\n  constructor(address _aFiManager, address oracleV3) {\\n    require(_aFiManager != address(0), \\\"AFS01\\\");\\n    aFiManager = _aFiManager;\\n    uniswapOracleV3 = oracleV3;\\n  }\\n\\n  /**\\n   * @notice To update rebalance details in the storage.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param rbUToken Address of the underlying token that is rebalanced.\\n   * @param rbtoUTokens Array of addresses of underlying tokens to which the uToken has been rebalanced.\\n   * @param _scenario Scenario can be either of 0, 1 or 2.\\n   */\\n  function updateRebalanceDetails(\\n    address aFiContract,\\n    address rbUToken,\\n    address[] memory rbtoUTokens,\\n    uint8 _scenario\\n  ) external override nonReentrant {\\n    // solhint-disable-next-line reason-string\\n    require(\\n      ( isAFiActive[aFiContract]) \\u0026\\u0026 (msg.sender == aFiManager),\\n      \\\"AFS02\\\"\\n    );\\n    RebalanceDetails memory rbDetails;\\n    rbDetails.rebalancedToUTokens = new address[](rbtoUTokens.length);\\n\\n    unchecked {\\n      for (uint i = 0; i \\u003c rbtoUTokens.length; i++) {\\n        rbDetails.rebalancedToUTokens[i] = rbtoUTokens[i];\\n      }\\n    }\\n\\n    rbDetails.scenario = _scenario;\\n    rbDetails.rebalancedUToken = rbUToken;\\n    _rebalanceDetails[aFiContract].push(rbDetails);\\n\\n    emit UpdateRebalanceDetails(aFiContract, rbUToken, _scenario);\\n  }\\n\\n  function getRebalanceDetails(\\n    address aFiContract,\\n    uint256 index\\n  ) external view returns (address[] memory, uint8, address) {\\n    require(index \\u003c _rebalanceDetails[aFiContract].length, \\\"AFS03\\\");\\n    return (\\n      _rebalanceDetails[aFiContract][index].rebalancedToUTokens,\\n      _rebalanceDetails[aFiContract][index].scenario,\\n      _rebalanceDetails[aFiContract][index].rebalancedUToken\\n    );\\n  }\\n\\n  /**\\n   * @notice To add a new team wallet.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param wallet Wallet address that has to be added in the `teamWallets` array.\\n   * @param isActive Boolean indicating whether to set the wallet to either active/inactive.\\n   * @param isPresent Boolean indicating the present status of the wallet.\\n   */\\n  function addTeamWallet(\\n    address aFiContract,\\n    address wallet,\\n    bool isActive,\\n    bool isPresent\\n  ) external override nonReentrant {\\n    // solhint-disable-next-line reason-string\\n    require(\\n      (isAFiActive[aFiContract]) \\u0026\\u0026\\n        (msg.sender == aFiManager),\\n      \\\"AFS04\\\"\\n    );\\n\\n    // Ensure setTeamWallets() has been called for the given AFi contract\\n    require(totalActiveTeamWallets[aFiContract] \\u003e 0, \\\"AFS05\\\");\\n    if(!teamWalletInAFi[aFiContract][wallet].isPresent \\u0026\\u0026 isPresent){\\n      teamWalletsOfAFi[aFiContract].push(wallet);\\n      teamWalletInAFi[aFiContract][wallet].isPresent = isPresent;\\n    \\n      // Write to contract storage\\n      if(!teamWalletInAFi[aFiContract][wallet].isActive \\u0026\\u0026 isActive){\\n        teamWalletInAFi[aFiContract][wallet].isActive = isActive;\\n        totalActiveTeamWallets[aFiContract]++;\\n      }\\n      teamWalletInAFi[aFiContract][wallet].walletAddress = wallet;\\n\\n    }\\n    emit TeamWalletAdd(wallet, true);\\n  }\\n\\n  /**\\n  * @notice To deactivate a team wallet.\\n  * @param aFiContract Address of the AFi contract.\\n  * @param wallet Wallet address that has to be deactivated.\\n  */\\n  function deactivateTeamWallet(\\n    address aFiContract,\\n    address wallet\\n  ) external onlyOwner nonReentrant {\\n    // solhint-disable-next-line reason-string\\n    require(\\n      (isAFiActive[aFiContract]),\\n      \\\"AFS06\\\"\\n    );\\n    require(teamWalletInAFi[aFiContract][wallet].isActive, \\\"AFS07\\\");\\n    totalActiveTeamWallets[aFiContract]--;\\n\\n    // Write to contract storage\\n    teamWalletInAFi[aFiContract][wallet].isActive = false;\\n    emit DeactivateTeamWallet(aFiContract, wallet);\\n  }\\n\\n  /**\\n  * @notice To reactivated a team wallet.\\n  * @param aFiContract Address of the AFi contract.\\n  * @param wallet address that has to be reactivated.\\n  */\\n  function reActivateTeamWallet(\\n    address aFiContract,\\n    address wallet\\n  ) external onlyOwner nonReentrant {\\n    // solhint-disable-next-line reason-string\\n    require(\\n      (isAFiActive[aFiContract]),\\n      \\\"AFS08\\\"\\n    );\\n    require(teamWalletInAFi[aFiContract][wallet].isPresent, \\\"AFS09\\\");\\n    require(!teamWalletInAFi[aFiContract][wallet].isActive, \\\"AFS10\\\");\\n    totalActiveTeamWallets[aFiContract]++;\\n\\n    // Write to contract storage\\n    teamWalletInAFi[aFiContract][wallet].isActive = true;\\n    emit ReActivateTeamWallet(aFiContract, wallet);\\n  }\\n\\n  function getTotalActiveWallets(\\n    address aFiContract\\n  ) external view override returns (uint) {\\n    return totalActiveTeamWallets[aFiContract];\\n  }\\n\\n  /**\\n   * @notice To add given wallet address to the contract storage.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _teamWallets An array of wallet addresses.\\n   */\\n  function setTeamWallets(\\n    address aFiContract,\\n    address[] memory _teamWallets\\n  ) external override nonReentrant {\\n    require(!onlyOnce[aFiContract] \\u0026\\u0026 msg.sender == aFiContract, \\\"AFS11\\\"); // solhint-disable-line reason-string\\n    uint tWalletLength = _teamWallets.length;\\n\\n    // Check if the team wallets have already been set\\n    require(\\n      totalActiveTeamWallets[aFiContract] == 0,\\n      \\\"AFS12\\\"\\n    );\\n\\n    numConfirmationsRequired[aFiContract] = tWalletLength;\\n    totalActiveTeamWallets[aFiContract] = tWalletLength;\\n\\n    for (uint i = 0; i \\u003c tWalletLength; i++) {\\n      address wallet = _teamWallets[i];\\n\\n      TeamWallet memory tWallet = teamWalletInAFi[aFiContract][wallet];\\n\\n      if (!tWallet.isPresent) {\\n        teamWalletsOfAFi[aFiContract].push(wallet);\\n        tWallet.isPresent = true;\\n        tWallet.isActive = true;\\n        tWallet.walletAddress = wallet;\\n\\n        // Write to contract storage\\n        teamWalletInAFi[aFiContract][wallet] = tWallet;\\n\\n        emit TeamWalletActive(wallet, true);\\n      }else{\\n        //only for duplicacy\\n        numConfirmationsRequired[aFiContract]--;\\n        totalActiveTeamWallets[aFiContract]--;\\n      }\\n    }\\n    onlyOnce[aFiContract] = true;\\n  }\\n\\n  function setActiveRebalancedStatus(\\n    address aFiContract,\\n    bool status\\n  ) external override {\\n    require(msg.sender == aFiContract || msg.sender == aFiManager, \\\"AFS13\\\");\\n    isActiveRebalanced[aFiContract] = status;\\n    emit SetActiveRebalancedStatus(aFiContract, status);\\n  }\\n\\n  /**\\n   * @notice Returns the team wallet details.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _wallet Team wallet address.\\n   * @return isActive Boolean indicating whether to set the wallet to either active/inactive.\\n   * @return isPresent Boolean indicating the present status of the wallet.\\n   */\\n  function getTeamWalletDetails(\\n    address aFiContract,\\n    address _wallet\\n  ) external view override returns (bool isActive, bool isPresent) {\\n    return (\\n      teamWalletInAFi[aFiContract][_wallet].isActive,\\n      teamWalletInAFi[aFiContract][_wallet].isPresent\\n    );\\n  }\\n\\n  /**\\n   * @notice Returns the array of team wallet addresses.\\n   * @param aFiContract Address of the AFi contract.\\n   * @return _teamWallets Array of teamWallets.\\n   */\\n  function getTeamWalletsOfAFi(\\n    address aFiContract\\n  ) external view override returns (address[] memory _teamWallets) {\\n    _teamWallets = teamWalletsOfAFi[aFiContract];\\n  }\\n\\n  function isAFiActiveRebalanced(\\n    address aFiContract\\n  ) external view override returns (bool _isActiveRebalanced) {\\n    _isActiveRebalanced = isActiveRebalanced[aFiContract];\\n  }\\n\\n  /**\\n   * @notice To set the AFi contract status.\\n   * @dev Requirements: It can be invoked only by the contract owner.\\n   * @param aFiContract Address of the AFiContract.\\n   * @param active status for afiContracts.\\n   */\\n  function setAFiActive(address aFiContract, bool active) external override {\\n    require(msg.sender == owner() || msg.sender == aFiContract, \\\"AFS15\\\");\\n    // Check if the contract is already active and trying to activate it again\\n    require(active != isAFiActive[aFiContract], \\\"AFS14\\\");\\n    isAFiActive[aFiContract] = active;\\n    emit SetAFiActive(aFiContract, isAFiActive[aFiContract]);\\n  }\\n\\n  /**\\n  * @notice To set the APR contract address.\\n  * @dev Requirements: It can be invoked only by the contract owner or the aficontract itself at the time of product creation.\\n  * @param aFiContract Address of the AFiContract.\\n  * @param _apr Address of the APRRecommendation contract.\\n  */\\n  function setAPR(address aFiContract, address _apr) external override {\\n    require(\\n      ((msg.sender == owner())) || (msg.sender == aFiContract),\\n      \\\"AFS16\\\"\\n    );\\n    apr[aFiContract] = _apr;\\n    emit SetAPR(aFiContract, _apr);\\n  }\\n\\n  /**\\n  * @notice Returns a recommended Lending pool for a Utoken.\\n  * @param tok Address of the underlying token.\\n  * @param aFiContract Address of the AFi contract.\\n  * @return Lender, returns recommended Lending Pool.\\n  */\\n  function recommend(\\n    address tok,\\n    address aFiContract\\n  ) internal view returns (Lender, uint) {\\n    (, uint capr, uint aapr, uint dapr) = IIEarnManager(apr[aFiContract]).recommend(\\n      tok,\\n      aFiContract,\\n      address(this)\\n    );\\n    uint max = 0;\\n    Lender newProvider = Lender.NONE;\\n    if (capr \\u003e max) {\\n      max = capr;\\n      newProvider = Lender.COMPOUND;\\n    }\\n    if (aapr \\u003e max) {\\n      max = aapr;\\n      newProvider = Lender.AAVE;\\n    }\\n    if (dapr \\u003e max) {\\n      max = dapr;\\n      newProvider = Lender.DYDX;\\n    }\\n    return (newProvider, max);\\n  }\\n\\n  /**\\n  * @notice Returns amount of equivalent USDC token.\\n  * @param tokenIn address of the token to get equivalent USDC.\\n  */\\n  function getPriceOracle(\\n    address tokenIn\\n  ) public view override returns (uint256 priceOracle) {\\n    uint256 uTokensDecimal = IERC20(tokenIn).decimals();\\n    uint256 amountIn = 10 ** uTokensDecimal;\\n    priceOracle = IUniswapOracleV3(uniswapOracleV3).estimateAmountOut(\\n      tokenIn,\\n      uint128(amountIn),\\n      USDC\\n    );\\n  }\\n\\n  /**\\n  * @notice Returns amount of equivalent _tokenOut token to _amountIn.\\n  * @param _tokenIn address of the token to get equivalent _tokenOut.\\n  * @param _amountIn amount of _tokenIn.\\n  * @param _tokenOut address of the token out.\\n  */\\n  function getMinimumAmountOut(address afiContract, address _tokenIn, uint256 _amountIn, address _tokenOut, address midTok, address _uniPool) public view override returns(uint256 amountOut){\\n    if (_tokenIn == (WETH) || _tokenOut == (WETH)) { \\n      amountOut = IUniswapOracleV3(uniswapOracleV3).estimateAmountOut(\\n        _tokenIn,\\n        uint128(_amountIn),\\n        _tokenOut\\n      ); \\n    }\\n    else if(_tokenIn == (midTok) || _tokenOut == (midTok)){\\n      address pool = IAFi(afiContract).getPool(_tokenIn, midTok);\\n      if(_uniPool != address(0)){\\n        pool = _uniPool;\\n      }\\n      require(pool != address(0), \\\"AFS17\\\");\\n      amountOut = estimateAmounts(_tokenIn, _amountIn, midTok, pool);\\n    }else {\\n      address pool = getUniPool(afiContract, midTok, _tokenIn);\\n      amountOut = estimateAmounts(_tokenIn, _amountIn, midTok, pool);\\n      pool = getUniPool(afiContract, midTok, _tokenOut);\\n      amountOut = estimateAmounts(midTok, amountOut, _tokenOut, pool);\\n    }\\n  }\\n\\n  function estimateAmounts(address intok, uint256 amt, address outTok, address pool) internal view returns(uint256){\\n    uint256 _amountOut = IUniswapOracleV3(uniswapOracleV3).estimateAmountOutMin(\\n      intok,\\n      uint128(amt),\\n      outTok,\\n      pool\\n    );\\n    return _amountOut;\\n  }\\n\\n  function getUniPool(address afiContract, address midTok, address tok) internal view returns(address){\\n    address pool = IAFi(afiContract).getPool(tok, midTok);\\n    require(pool != address(0), \\\"AFS18\\\");\\n    return pool;\\n  }\\n\\n   /**\\n  * @notice syncs the pool data of a token to the pool data of aficontract.\\n  * @param afiContract address of the afi contract.\\n  * @param tok address of the token to sync the pool data.\\n  * @param aaveTok address of the aave pool.\\n  * @param dtoken dydx market id of tok.\\n  * @param compTok address of the compound pool.\\n  */\\n  function afiSync(\\n    address afiContract,\\n    address tok,\\n    address aaveTok,\\n    uint dtoken,\\n    address compTok\\n  ) external override {\\n    require(msg.sender == afiContract, \\\"AFS19\\\");\\n    aaveTokenCopy[afiContract][tok] = aaveTok;\\n    dTokenCopy[afiContract][tok] = dtoken;\\n    compoundCopy[afiContract][tok] = compTok;\\n  }\\n\\n  function balanceCompound(\\n    address tok,\\n    address afiContract\\n  ) public view override returns (uint) {\\n    return IERC20(compoundCopy[afiContract][tok]).balanceOf(afiContract);\\n  }\\n\\n  function balanceCompoundInToken(\\n    address tok,\\n    address afiContract\\n  ) public view override returns (uint) {\\n    // Mantisa 1e18 to decimals\\n    uint b = balanceCompound(tok, afiContract);\\n    if (b \\u003e= 1) {\\n      b = b.mul(Compound(compoundCopy[afiContract][tok]).exchangeRateStored()).div(\\n        1e18\\n      );\\n    }\\n    return b;\\n  }\\n\\n  function balanceAave(address tok, address afiContract) public view override returns (uint) {\\n    return IERC20(aaveTokenCopy[afiContract][tok]).balanceOf(afiContract);\\n  }\\n\\n  function balance(address tok, address afiContract) public view returns (uint) {\\n    return IERC20(tok).balanceOf(afiContract);\\n  }\\n\\n  function balanceDydx(address tok, address afiContract) public view override returns (uint) {\\n    Wei memory bal;\\n    if (dTokenCopy[afiContract][tok] \\u003c= 3) {\\n      bal = DyDx(dydx).getAccountWei(\\n        Info(afiContract, 0),\\n        dTokenCopy[afiContract][tok]\\n      );\\n    }\\n\\n    return bal.value;\\n  }\\n\\n  function balanceDydxAvailable(address tok) public view override returns (uint) {\\n    return IERC20(tok).balanceOf(dydx);\\n  }\\n\\n  /**\\n  * @notice Returns total token locked by the afiContract in USD.\\n  * @param tok indicates the address of the token.\\n  * @param afiContract indicates the address of the afiContract.\\n  */\\n   function calcPoolValue(\\n    address tok,\\n    address afiContract,\\n    address midTok\\n  ) public view override returns (uint) {\\n    uint bal = 0;\\n    (uint256 price, uint256 multiplier) = checkIfUSDC(afiContract, tok, midTok);\\n\\n    uint uTokensDecimal = IERC20(tok).decimals();\\n    require(uTokensDecimal \\u003c=18, \\\"AFS20\\\");\\n    uTokensDecimal = 18 - uTokensDecimal;\\n    bal = balanceOfUnderlyingInPoolsAndContract(tok, afiContract);\\n    if (price != 0) {\\n      bal = (bal).mul(\\n        uint(price)\\n      );\\n      bal = ((bal.mul(10 ** uTokensDecimal)).div(multiplier));\\n    }\\n    return bal;\\n  }\\n\\n  /**\\n * @notice Returns total token locked by the aficontract in number of ERC20 token.\\n * @param tok indicates the address of the token.\\n * @param afiContract indicates the address of the afiContract to calculate underlying balance.\\n */\\n  function calculateBalanceOfUnderlying(\\n    address tok,\\n    address afiContract\\n  ) public view override returns (uint) {\\n    return balanceOfUnderlyingInPoolsAndContract(tok, afiContract);\\n  }\\n\\n  function balanceOfUnderlyingInPoolsAndContract(\\n    address tok,\\n    address afiContract\\n  ) internal view returns (uint) {\\n    uint bal = 0;\\n    if (compoundCopy[afiContract][tok] != address(0)) {\\n      bal += balanceCompoundInToken(tok, afiContract);\\n    }\\n    if (aaveTokenCopy[afiContract][tok] != address(0)) {\\n      bal += balanceAave(tok, afiContract);\\n    }\\n    if(IAFi(afiContract).getTypeOfProduct() == 2){\\n        bal = (bal.add(balance(tok, afiContract)).add(balanceDydx(tok, afiContract)));\\n      }else{\\n        bal = (bal.add(balance(tok, afiContract)));\\n    }\\n    return bal;\\n  }\\n\\n  /**\\n  * @notice Returns token locked by the aficontract in number of ERC20 token. \\n  */\\n  function calcPoolValueSome(\\n    address tok, \\n    address afiContract,\\n    address midTok\\n  ) public view override returns (uint) {\\n    (uint256 price, uint256 multiplier) = checkIfUSDC(afiContract, tok, midTok);\\n    uint bal = 0;\\n    uint uTokensDecimal = IERC20(tok).decimals();\\n    require(uTokensDecimal \\u003c=18, \\\"AFS21\\\");\\n    uTokensDecimal = 18 - uTokensDecimal;\\n    bal = balanceOfUnderlyingInPoolsAndContract(tok, afiContract);\\n    if (price != 0) {\\n      bal = (bal.sub(balance(tok, afiContract))).mul(uint(price));\\n      bal = ((bal.mul(10 ** uTokensDecimal)).div(multiplier));\\n    }\\n    return bal;\\n  }\\n\\n  function calculatePoolInUsd(address afiContract) public view override returns (uint) {\\n    uint bal = 0;\\n    address[] memory uTokens = new address[](IAFi(afiContract).getUTokens().length);\\n    uTokens = IAFi(afiContract).getUTokens();\\n    uint uLen = uTokens.length;\\n    address midTok;\\n    for (uint i = 0; i \\u003c uLen; i++) {\\n      midTok = IAFi(afiContract).getMidToken(uTokens[i]);\\n      bal = bal.add(calcPoolValue(uTokens[i], afiContract, midTok));\\n    }\\n    return bal;\\n  }\\n \\n  // the purpose of this function is to call initialize functions of AFiContract only once\\n  function afiContractInitUpdate(address aFiContract, uint order) external override{\\n    require(\\n      (msg.sender == aFiContract),\\n      \\\"AFS22\\\"\\n    );\\n    if(order == 1){\\n      require(!initilizeStatus[aFiContract], \\\"AFS23\\\");\\n      initilizeStatus[aFiContract] = true;\\n    }else if(order == 2){\\n      require(!initializeTokenStatus[aFiContract], \\\"AFS24\\\");\\n      initializeTokenStatus[aFiContract] = true;\\n    }else if(order == 3){\\n      require(!initializePlatformDataStatus[aFiContract], \\\"AFS25\\\");\\n      initializePlatformDataStatus[aFiContract] = true;\\n    }\\n  }\\n  \\n  // the function returns the initialize status of an afi contract for all three initialize functions\\n  function getAFiInitStatus(address aFiContract) external view override returns(bool, bool, bool){\\n    return (initilizeStatus[aFiContract], initializeTokenStatus[aFiContract], initializePlatformDataStatus[aFiContract]);\\n  }\\n\\n  function validateAndGetDecimals(address tok) public override view returns(uint256){\\n    uint uTokensDecimal = IERC20(tok).decimals();\\n    require(uTokensDecimal \\u003c= 18, \\\"AFS26\\\");\\n    return (18 - uTokensDecimal);\\n  }\\n\\n  //90% uTokens will be staked on pool and 10% remain on contract\\n  function rearrange(address aFiContract) external override {\\n    require(msg.sender == aFiContract,\\\"AFS27\\\");\\n    IAFiStorage.Lender newProvider = IAFiStorage.Lender.NONE;\\n    address[] memory uTokens = new address[](IAFi(aFiContract).getUTokens().length);\\n    uTokens = IAFi(aFiContract).getUTokens();\\n\\n    uint256 uTokenLen = uTokens.length;\\n    unchecked {\\n      for (uint i = 0; i \\u003c uTokenLen; i++) {\\n        // For all inactive tokens uTokenProportions[i] == 0\\n        (newProvider, ) = recommend(uTokens[i], aFiContract);\\n        if (newProvider != provider[aFiContract][uTokens[i]]) {\\n          _isStaked[aFiContract][uTokens[i]] = false;\\n          _withdrawAll(aFiContract, uTokens[i]);\\n        }\\n\\n        if (balance(uTokens[i], aFiContract) \\u003e 0) {\\n          if (newProvider == IAFiStorage.Lender.DYDX) {\\n            if (dTokenCopy[aFiContract][uTokens[i]] \\u003c 4) {\\n              _isStaked[aFiContract][uTokens[i]] = true;\\n              IAFi(aFiContract)._supplyDydx(uTokens[i], (balance(uTokens[i], aFiContract).mul(90)).div(100));\\n            }\\n          } else if (newProvider == IAFiStorage.Lender.COMPOUND) {\\n            if (compoundCopy[aFiContract][uTokens[i]] != address(0)) {\\n              _isStaked[aFiContract][uTokens[i]] = true;\\n              IAFi(aFiContract)._supplyCompound(uTokens[i], (balance(uTokens[i], aFiContract).mul(90).div(100)));\\n            }\\n          } else if (newProvider == IAFiStorage.Lender.AAVE) {\\n            if (aaveTokenCopy[aFiContract][uTokens[i]] != address(0)) {\\n              _isStaked[aFiContract][uTokens[i]] = true;\\n              IAFi(aFiContract)._supplyAave(uTokens[i], (balance(uTokens[i], aFiContract).mul(90)).div(100));\\n            }\\n          }\\n        }\\n        provider[aFiContract][uTokens[i]] = newProvider;\\n      }\\n    }\\n  }\\n\\n  function getStakedStatus(address aFiContract,address uToken) public view override returns(bool){\\n      return _isStaked[aFiContract][uToken];\\n  }\\n\\n  function swapForOtherProduct(address afiContract, uint r, address oToken, uint deadline, uint[] memory slippageFactor) external override returns(uint256){\\n    require(msg.sender == afiContract, \\\"AFS28\\\");\\n    redFromContract = 0;\\n    address[] memory uTokens = new address[](IAFi(afiContract).getUTokens().length);\\n    uTokens = IAFi(afiContract).getUTokens();\\n    \\n    checkIfTokenPresent(uTokens, r, oToken, deadline, afiContract, slippageFactor);\\n    return redFromContract;\\n  }\\n\\n  function calculatRedemptionFromContract(address afiContract, address tok, uint256 r) internal view returns(uint256, bool, uint256){\\n    uint256 redemptionFromContract;\\n    address midTok = IAFi(afiContract).getMidToken(tok);\\n    \\n    (uint256 price, uint256 multiplier) = checkIfUSDC(afiContract, tok, midTok);\\n    if (price != 0) {\\n      redemptionFromContract = calcPoolValue(tok, afiContract, midTok);\\n      redemptionFromContract = (r).mul(redemptionFromContract).mul(\\n            multiplier\\n          );\\n      redemptionFromContract = (\\n          redemptionFromContract\\n        ).div(((IAFi(afiContract).getTVL()).mul(uint(price)).mul(10 ** (validateAndGetDecimals(tok)))));\\n    }\\n    return (price, getStakedStatus(afiContract,tok), redemptionFromContract);\\n  }\\n\\n  function withdrawFromPools(address afiContract, address tok, uint r, address oToken, uint redemptionFromContract, uint256[] memory slippageFactor, uint deadline) internal {\\n\\n    address midTok = IAFi(afiContract).getMidToken(tok);\\n    { \\n      (uint256 price, uint256 multiplier) = checkIfUSDC(afiContract, tok, midTok);\\n      uint256 redemptionFromPool = calcPoolValueSome(tok, afiContract, midTok);\\n      redemptionFromPool = redemptionFromPool.mul(r).mul(multiplier);\\n      redemptionFromPool = (\\n        redemptionFromPool\\n      ).div((IAFi(afiContract).getTVL()).mul(uint(price)).mul(10 ** validateAndGetDecimals(tok)));\\n\\n      _withdrawSome(afiContract, tok, redemptionFromPool);\\n    }\\n    internalSwap( afiContract,  tok, oToken, midTok, deadline, redemptionFromContract, slippageFactor);\\n  }\\n\\n  function internalSwap(address afiContract, address tok, address oToken, address midTok, uint deadline, uint redeem, uint256[] memory slippageFactor) internal{\\n    if(tok!= oToken){\\n      if (IERC20(tok).balanceOf(afiContract) \\u003e 0) {\\n        if (amountDeducted \\u003e 0) {\\n          redFromContract += IAFi(afiContract).swapViAFiStorage(\\n            tok,\\n            oToken,\\n            redeem.sub(amountDeducted),\\n            deadline,\\n            midTok,\\n            slippageFactor,\\n            2\\n          );\\n          amountDeducted = 0;\\n        } else {\\n          redFromContract += IAFi(afiContract).swapViAFiStorage(\\n            tok,\\n            oToken,\\n            redeem,\\n            deadline,\\n            midTok,\\n            slippageFactor,\\n            2\\n          );\\n        }\\n      }\\n    }else{\\n      redFromContract = redFromContract + redeem - amountDeducted;\\n    }\\n  }\\n\\n  /**\\n  * @notice Returns pool to invest in, amount to invest and \\n  * deducted amount if there is a fluctuation or insufficient balance(rare case).\\n  */\\n  function _withdrawSome(address afiContract, address tok, uint _amount) internal{\\n    uint origAmount = _amount; \\n    if (compoundCopy[afiContract][tok]!= address(0)) {\\n      if (balanceCompound(tok, afiContract) \\u003e= 1) {\\n        if (_amount \\u003e= balanceCompoundInToken(tok, afiContract)) {\\n          amountDeducted = origAmount.sub(balanceCompoundInToken(tok, afiContract).sub(1));\\n          IAFi(afiContract)._withdrawCompound(tok, balanceCompoundInToken(tok, afiContract).sub(1));\\n        } else {\\n          IAFi(afiContract)._withdrawCompound(tok, _amount);\\n        }\\n      }\\n    }\\n    if (aaveTokenCopy[afiContract][tok] != address(0)) {\\n      if (balanceAave(tok, afiContract) \\u003e= 1) {\\n        if (_amount \\u003e= balanceAave(tok, afiContract)) {\\n          amountDeducted = origAmount.sub(balanceAave(tok, afiContract));\\n          IAFi(afiContract)._withdrawAave(tok, balanceAave(tok, afiContract));\\n        } else {\\n          IAFi(afiContract)._withdrawAave(tok, _amount);\\n        }\\n      }\\n    }\\n    if (dydx != address(0)) {\\n      if (balanceDydx(tok, afiContract) \\u003e= 1) {\\n        if (_amount \\u003e= balanceDydxAvailable(tok)) {\\n          amountDeducted = origAmount.sub(balanceDydxAvailable(tok));\\n          IAFi(afiContract)._withdrawDydx(tok, balanceDydxAvailable(tok));\\n        } else {\\n          IAFi(afiContract)._withdrawDydx(tok, _amount);\\n        }\\n      }\\n    }\\n  }\\n\\n  function caculateMinOutForUniswap(address afiContract, address _tokenIn, address _tokenOut, uint256 amt, address middleToken, address unipool) external view override returns(uint256){\\n    uint256 minimumAmountOut;\\n    address inTokOracle = IAFi(afiContract).getPriceOracle(_tokenIn);\\n    address outTokOracle = IAFi(afiContract).getPriceOracle(_tokenOut);\\n    if(inTokOracle != address(0) \\u0026\\u0026 outTokOracle != address(0)){\\n        (int256 inputTokenPrice, uint8 inputTokenDecimal) = getPriceAndDecimals(afiContract, _tokenIn, inTokOracle);\\n        uint256 slippageInDollars = ((uint256(inputTokenPrice) *\\n        (amt) *\\n        (10 ** (validateAndGetDecimals(_tokenIn))))/\\n        (10**inputTokenDecimal));\\n        (int256 outputTokenPrice,) = getPriceAndDecimals(afiContract, _tokenOut, outTokOracle);\\n      minimumAmountOut = ((((slippageInDollars)) * ( 10**inputTokenDecimal)) / (uint256(outputTokenPrice) * (10 ** (validateAndGetDecimals(_tokenOut)))));\\n    }else{\\n      minimumAmountOut = getMinimumAmountOut(afiContract, _tokenIn, amt, _tokenOut, middleToken, unipool);\\n    }\\n    return minimumAmountOut;\\n  }\\n\\n  function getPriceAndDecimals(address aFiContract, address uToken, address feed) internal view returns(int256 , uint8 ){\\n    (, int256 inPrice, ,uint256 updatedAt, ) = AggregatorV3Interface(feed).latestRoundData();\\n    uint8 decimals = AggregatorV3Interface(feed).decimals();\\n    require(block.timestamp \\u003c= updatedAt + stalePriceDelay[aFiContract][uToken], \\\"AFS29\\\");\\n    require(inPrice \\u003e= 0, \\\"AFS02\\\");\\n    return (inPrice, decimals);\\n  }\\n\\n  function intializeStalePriceDelay(address aFiContract, address[] memory underlyingTokens, uint256[] memory _stalePriceDelay) external onlyOwner{\\n    for(uint i=0; i \\u003c underlyingTokens.length; i++){\\n      stalePriceDelay[aFiContract][underlyingTokens[i]] = _stalePriceDelay[i];\\n    }\\n  }\\n\\n  function setStalePriceDelay(address aFiContract, address uToken, uint256 _stalePriceDelay) external onlyOwner {\\n    require(stalePriceDelay[aFiContract][uToken] \\u003e= 1 hours, \\\"AFS30\\\");\\n    stalePriceDelay[aFiContract][uToken] = _stalePriceDelay;\\n  }\\n\\n  function getStalePriceDelay(address aFiContract, address uToken) external view returns(uint256) {\\n    return stalePriceDelay[aFiContract][uToken];\\n  }\\n\\n  function checkIfUSDC(address afiContract, address tok, address midTok) public view override returns (uint256, uint256) {\\n    bool res;\\n    if (tok == USDC) {\\n      res = true;\\n    }\\n    uint256 multiplier = 1e6;\\n    uint256 price;\\n    // Transfer Aarna Token to investor\\n    if (!res) {\\n      if(IAFi(afiContract).getPriceOracle(tok) != address(0)){\\n        (int256 tokPrice, ) = getPriceAndDecimals(afiContract, tok, IAFi(afiContract).getPriceOracle(tok));\\n        (int256 usdcPrice,) = getPriceAndDecimals(afiContract, USDC, USDC_ORACLE);\\n        price = ((uint256(tokPrice) * (10**6)) / uint256((usdcPrice)));\\n      }else{\\n          if(IUniswapOracleV3(uniswapOracleV3).checkUnderlyingPool(tok)){\\n          price = getPriceOracle(tok);\\n        }else{\\n          uint256 uTokensDecimal = IERC20(tok).decimals();\\n          uint256 amountIn = 10 ** uTokensDecimal;\\n          price = getMinimumAmountOut(afiContract, tok, amountIn, USDC, midTok, address(0));\\n        }\\n      }\\n    } else {\\n      price = 1;\\n      multiplier = 1;\\n    }\\n    return (price, multiplier);\\n  }\\n\\n  function checkIfTokenPresent(address[] memory uTokens, uint r, address oToken, uint deadline, address afiContract, uint256[] memory slippageFactor) internal {\\n    uint256 redemptionFromContract;\\n    bool stakedStatus;\\n    uint256 price;\\n    {\\n      (uint index, bool present) = ArrayUtils.indexOf(uTokens, oToken);\\n      if(present){\\n        (price, stakedStatus, redemptionFromContract) = calculatRedemptionFromContract(afiContract, uTokens[index], r);\\n        if (!stakedStatus) {\\n          redFromContract += redemptionFromContract;\\n        }\\n        if (stakedStatus) {\\n          if (price != 0) {\\n            withdrawFromPools(afiContract, uTokens[index], r, oToken, redemptionFromContract, slippageFactor, deadline);\\n          }\\n        }\\n      }\\n    } \\n    address midTok;\\n    unchecked{\\n      for (uint n = 0; n \\u003c uTokens.length; n++) {\\n        (price, stakedStatus, redemptionFromContract) = calculatRedemptionFromContract(afiContract, uTokens[n], r);\\n        if (!stakedStatus  \\u0026\\u0026 uTokens[n] != oToken) {\\n          if (IERC20(uTokens[n]).balanceOf(afiContract) \\u003e 0) {\\n            midTok = IAFi(afiContract).getMidToken(uTokens[n]);\\n            if(redemptionFromContract \\u003c= IERC20(uTokens[n]).balanceOf(afiContract)){\\n              redFromContract += IAFi(afiContract).swapViAFiStorage(uTokens[n], oToken, redemptionFromContract, deadline, midTok, slippageFactor, 2 );\\n            }else{\\n              redFromContract += IAFi(afiContract).swapViAFiStorage(uTokens[n], oToken, IERC20(uTokens[n]).balanceOf(afiContract), deadline, midTok, slippageFactor, 2);\\n            }\\n          }\\n        }\\n        if (stakedStatus \\u0026\\u0026 uTokens[n] != oToken) {\\n          if (price != 0) {\\n            withdrawFromPools(afiContract, uTokens[n], r, oToken, redemptionFromContract, slippageFactor, deadline);\\n          }\\n        }\\n      }\\n    }\\n  }\\n  \\n  /**\\n   * @notice _withdrawAll Function withdraws whole diposited balance from the pools(protocols).\\n   * @dev It should only be called by the AFiManager, AFiStorage contracts.\\n   * @param tok address of the token to withdraw from protocols.\\n   */\\n  function _withdrawAll(address afiContract, address tok) public override {\\n    require(msg.sender == afiContract || msg.sender == aFiManager,\\\"AFS31\\\");\\n    uint poolBal;\\n    if (compoundCopy[afiContract][tok] != address(0)) {\\n      if (balanceCompound(tok, afiContract) \\u003e= 1) {\\n        IAFi(afiContract)._withdrawCompound(\\n          tok,\\n          balanceCompoundInToken(tok, afiContract).sub(1)\\n        );\\n      }\\n    }\\n    if (aaveTokenCopy[afiContract][tok] != address(0)) {\\n      poolBal = balanceAave(tok, afiContract);\\n      if (poolBal \\u003e= 1) {\\n        IAFi(afiContract)._withdrawAave(tok, poolBal);\\n      }\\n    }\\n    if (dydx != address(0)) {\\n      poolBal = balanceDydx(tok, afiContract);\\n      if (poolBal \\u003e= 1) {\\n        if (poolBal \\u003c= balanceDydxAvailable(tok)) {\\n          IAFi(afiContract)._withdrawDydx(tok, poolBal);\\n        }\\n      }\\n    }\\n  }\\n}\"},\"AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"},\"ArrayUtils.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity =0.8.0;\\n\\n// Reference: https://github.com/cryptofinlabs/cryptofin-solidity/blob/master/contracts/array-utils/AddressArrayUtils.sol\\nlibrary ArrayUtils {\\n  /**\\n   * Deletes address at index and fills the spot with the last address.\\n   * Order is preserved.\\n   */\\n  // solhint-disable-next-line var-name-mixedcase\\n  function sPopAddress(address[] storage A, uint index) internal {\\n    uint length = A.length;\\n    if (index \\u003e= length) {\\n      revert(\\\"Error: index out of bounds\\\");\\n    }\\n\\n    for (uint i = index; i \\u003c length - 1; i++) {\\n      A[i] = A[i + 1];\\n    }\\n    A.pop();\\n  }\\n\\n  // solhint-disable-next-line var-name-mixedcase\\n  function sPopUint256(uint[] storage A, uint index) internal {\\n    uint length = A.length;\\n    if (index \\u003e= length) {\\n      revert(\\\"Error: index out of bounds\\\");\\n    }\\n\\n    for (uint i = index; i \\u003c length - 1; i++) {\\n      A[i] = A[i + 1];\\n    }\\n    A.pop();\\n  }\\n\\n  // solhint-disable-next-line var-name-mixedcase\\n  function sumOfMArrays(\\n    uint[] memory A,\\n    uint[] memory B\\n  ) internal pure returns (uint[] memory sum) {\\n    sum = new uint[](A.length);\\n    for (uint i = 0; i \\u003c A.length; i++) {\\n      sum[i] = A[i] + B[i];\\n    }\\n    return sum;\\n  }\\n\\n  /**\\n   * Finds the index of the first occurrence of the given element.\\n   * @param A The input array to search\\n   * @param a The value to find\\n   * @return Returns (index and isIn) for the first occurrence starting from index 0\\n   */\\n  function indexOf(address[] memory A, address a) internal pure returns (uint, bool) {\\n    uint length = A.length;\\n    for (uint i = 0; i \\u003c length; i++) {\\n      if (A[i] == a) {\\n        return (i, true);\\n      }\\n    }\\n    return (type(uint).max, false);\\n  }\\n\\n  /**\\n   * Returns true if the value is present in the list. Uses indexOf internally.\\n   * @param A The input array to search\\n   * @param a The value to find\\n   * @return Returns isIn for the first occurrence starting from index 0\\n   */\\n  function contains(address[] memory A, address a) internal pure returns (bool) {\\n    (, bool isIn) = indexOf(A, a);\\n    return isIn;\\n  }\\n\\n  /**\\n   * Returns true if there are 2 elements that are the same in an array\\n   * @param A The input array to search\\n   * @return Returns boolean for the first occurrence of a duplicate\\n   */\\n  function hasDuplicate(address[] memory A) internal pure returns (bool) {\\n    require(A.length \\u003e 0, \\\"A is empty\\\");\\n\\n    for (uint i = 0; i \\u003c A.length - 1; i++) {\\n      address current = A[i];\\n      for (uint j = i + 1; j \\u003c A.length; j++) {\\n        if (current == A[j]) {\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * @param A The input array to search\\n   * @param a The address to remove\\n   * @return Returns the array with the object removed.\\n   */\\n  function remove(\\n    address[] memory A,\\n    address a\\n  ) internal pure returns (address[] memory) {\\n    (uint index, bool isIn) = indexOf(A, a);\\n    if (!isIn) {\\n      revert(\\\"Address not in array.\\\");\\n    } else {\\n      (address[] memory _A, ) = pop(A, index);\\n      return _A;\\n    }\\n  }\\n\\n  /**\\n   * @param A The input array to search\\n   * @param a The address to remove\\n   */\\n  function removeStorage(address[] storage A, address a) internal {\\n    (uint index, bool isIn) = indexOf(A, a);\\n    if (!isIn) {\\n      revert(\\\"Address not in array.\\\");\\n    } else {\\n      uint lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\\n      if (index != lastIndex) {\\n        A[index] = A[lastIndex];\\n      }\\n      A.pop();\\n    }\\n  }\\n\\n  /**\\n   * Removes specified index from array\\n   * @param A The input array to search\\n   * @param index The index to remove\\n   * @return Returns the new array and the removed entry\\n   */\\n  function pop(\\n    address[] memory A,\\n    uint index\\n  ) internal pure returns (address[] memory, address) {\\n    uint length = A.length;\\n    require(index \\u003c A.length, \\\"Index must be \\u003c A length\\\");\\n    address[] memory newAddresses = new address[](length - 1);\\n    for (uint i = 0; i \\u003c index; i++) {\\n      newAddresses[i] = A[i];\\n    }\\n    for (uint j = index + 1; j \\u003c length; j++) {\\n      newAddresses[j - 1] = A[j];\\n    }\\n    return (newAddresses, A[index]);\\n  }\\n\\n  /**\\n   * Returns the combination of the two arrays\\n   * @param A The first array\\n   * @param B The second array\\n   * @return Returns A extended by B\\n   */\\n  function extend(\\n    address[] memory A,\\n    address[] memory B\\n  ) internal pure returns (address[] memory) {\\n    uint aLength = A.length;\\n    uint bLength = B.length;\\n    address[] memory newAddresses = new address[](aLength + bLength);\\n    for (uint i = 0; i \\u003c aLength; i++) {\\n      newAddresses[i] = A[i];\\n    }\\n    for (uint j = 0; j \\u003c bLength; j++) {\\n      newAddresses[aLength + j] = B[j];\\n    }\\n    return newAddresses;\\n  }\\n\\n  /**\\n   * Validate that address and uint array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of uint\\n   */\\n  function validatePairsWithArray(address[] memory A, uint[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address and bool array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of bool\\n   */\\n  function validatePairsWithArray(address[] memory A, bool[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address and string array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of strings\\n   */\\n  function validatePairsWithArray(address[] memory A, string[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address array lengths match, and calling address array are not empty\\n   * and contain no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of addresses\\n   */\\n  function validatePairsWithArray(\\n    address[] memory A,\\n    address[] memory B\\n  ) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate that address and bytes array lengths match. Validate address array is not empty\\n   * and contains no duplicate elements.\\n   *\\n   * @param A         Array of addresses\\n   * @param B         Array of bytes\\n   */\\n  function validatePairsWithArray(address[] memory A, bytes[] memory B) internal pure {\\n    require(A.length == B.length, \\\"Array length mismatch\\\");\\n    _validateLengthAndUniqueness(A);\\n  }\\n\\n  /**\\n   * Validate address array is not empty and contains no duplicate elements.\\n   *\\n   * @param A          Array of addresses\\n   */\\n  function _validateLengthAndUniqueness(address[] memory A) internal pure {\\n    require(A.length \\u003e 0, \\\"Array length must be \\u003e 0\\\");\\n    require(!hasDuplicate(A), \\\"Cannot duplicate addresses\\\");\\n  }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"},\"IAFi.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity =0.8.0;\\n\\nimport {IERC20Extended as IERC20} from \\\"./IERC20Extended.sol\\\";\\nimport \\\"./IAFiStorage.sol\\\";\\nimport \\\"./IPassiveRebal.sol\\\";\\n\\n/**\\n * @title PassiveRebal.\\n * @notice Interface of the Passive Rebalance contract.\\n */\\ninterface PassiveRebal {\\n\\n  function applyRebalForProportions(\\n    address _aFiContract,\\n    address _aFiManager,\\n    uint _strategyNumber,\\n    address[] memory _tokens\\n  ) external returns (uint[] memory proportions);\\n\\n  function getPauseStatus() external returns (bool);\\n\\n  function getRebalPeriod(address aFiContract) external returns (uint);\\n\\n  function updateRebalPeriod(address aFiContract, uint _newRebalPeiod) external;\\n\\n  function setPassiveRebalancedStatus(address aFiContract, bool status) external;\\n\\n  function isAFiPassiveRebalanced(\\n    address aFiContract\\n  ) external returns (bool _isPassiveRebalanced);\\n\\n  function getRebalStrategyNumber(address aFiContract) external returns (uint);\\n\\n  function updateRebalStrategyNumber(\\n    address aFiContract,\\n    uint updatedStrategy\\n  ) external;\\n}\\n\\ninterface IAFiManager {\\n  function _distributeProfitShare(\\n    address aFiStorage,\\n    address aFiContract,\\n    uint profit,\\n    address oToken,\\n    uint256 depositNAV,\\n    uint256 redemptionNAV\\n  ) external returns (uint totalProfitShare);\\n\\n  function updateUTokenProportion(address aFiContract,address aFiStorage) external returns(uint256[] memory);\\n\\n  function intializeData(address aFiContract,address[] memory underlyingTokens,uint[] memory underlyingProportion) external;\\n\\n  function uTokenslippage(address aFiContract, address uToken) external view returns(uint uTokenSlippage);\\n\\n}\\n\\n/**\\n * @title IAFi.\\n * @notice Interface of the AToken.\\n */\\ninterface IAFi {\\n\\n  struct StablePools{\\n    address[] _pools;\\n  }\\n\\n  struct UnderlyingData{\\n    address[] _underlyingTokens;\\n    address[] _underlyingUniPoolToken;\\n    address[] _underlyingUniPool;\\n    address[] _underlyingPoolWithWETH;\\n    StablePools[] stablePools;\\n    address[] stableWethPool;\\n  }\\n\\n  struct PoolsData {\\n    address[] _depositStableCoin;\\n    address[] _depositCoinOracle;\\n    bytes underlyingData;                                                                             \\n    address _apr;\\n    address[] _compound;\\n    address[] _aaveToken;\\n    address[] _priceOracles;\\n    uint[] _underlyingTokensProportion;\\n    uint[] _dToken;\\n    uint _typeOfProduct;\\n  }\\n\\n  /**\\n   * @param account Address of the account that paused the contract.\\n   * @param isDeposit True if we want to pause deposit otherwise false if want to pause withdraw.\\n   */\\n  event Paused(address account,bool isDeposit);\\n  /**\\n   * @param account Address of the account that unpaused the contract.\\n   * @param isDeposit True if we want to unpause deposit otherwise false if want to unpause withdraw.\\n   */\\n  event Unpaused(address account,bool isDeposit);\\n\\n  /**\\n   * @notice Function to initialize the data, owner and afi token related data.\\n   * @dev the function should be called once only by factory\\n   * @param newOwner indicates the owner of the created afi product.\\n   * @param _name indicates the name of the afi Token\\n   * @param _symbol indicates symbol of the the afi Token.\\n   * @param data indicates the encoded data that follows the PoolsData struct format.\\n   * @param _isActiveRebalanced indicates the active rebalance status of the afi contract.\\n   * @param _aFiStorage indicates the afi storage contract address.\\n   */\\n  function initialize(\\n    address newOwner,\\n    string memory _name,\\n    string memory _symbol,\\n    bytes memory data,\\n    bool _isActiveRebalanced,\\n    IAFiStorage _aFiStorage\\n  ) external;\\n\\n  /**\\n   * @notice Function to initialize the platform related data.\\n   * @dev  the function should be called once only by factory\\n   * @param _teamWallets indicates the array of the wallets to share the profit and confirm active rebalance txn.\\n   * @param _rebalContract indicates passive rebal strategy contract address.\\n   * @param _isPassiveRebalanced indicates the passive rebalance status of the afi contract.\\n   * @param _aFiManager indicates the afi manager contract address.\\n   * @param _aarnaEngine indicates the engine contract.\\n   */\\n  function initializePlatformData(\\n    address[] memory _teamWallets,\\n    IPassiveRebal _rebalContract,\\n    bool _isPassiveRebalanced,\\n    address _aFiManager,\\n    address _aarnaEngine\\n  ) external;\\n\\n  /**\\n   * @notice Function to initialize accepted tokens in deposit and withdraw functions.\\n   * @dev  the function should be called once only by factory\\n   * @param iToken indicates the array of the accepted token addressess.\\n   */\\n  function initializeToken(\\n    address[] memory iToken,\\n    address[] memory iTokenOracel,\\n    bytes memory poolData\\n  ) external;\\n\\n  /**\\n   * @notice Returns the array of underlying tokens.\\n   * @return uTokensArray Array of underlying tokens.\\n   */\\n  function getUTokens() external view returns (address[] memory uTokensArray);\\n  function swapViAFiStorage(\\n    address from,\\n    address to,\\n    uint amount,\\n    uint deadline,\\n    address midTok,\\n    uint[] memory slippageFactor,\\n    uint8 counter\\n  ) external returns(uint256);\\n  \\n  /**\\n   * @notice Returns the paused status of the contract.\\n   */\\n  function isPaused() external view returns (bool,bool);\\n  function getProportionsAndRebalTime() external view returns (uint[] memory, uint[] memory, uint256);\\n  /**\\n   * @notice Updates the pool data during Active Rebalance.\\n   * @param data that follows PoolsData format indicates the data of the token being rebalanced in Active Rebalance.\\n   */\\n  function updatePoolData(bytes memory data) external;\\n  function sendProfitOrFeeToManager(address wallet, uint profitShare, address oToken) external;\\n  function totalSupply() external view returns (uint);\\n  function updateUnderlyingData(address[] memory _uTokens,uint256[] memory _uTokenProportion,uint256[] memory _defaultProportion)external;\\n  function _supplyDydx(address tok, uint amount) external;\\n  function _supplyAave(address tok, uint amount) external;\\n  function _supplyCompound(address tok, uint amount) external;\\n  function getRebalContract() external view returns(address);\\n  function getPriceOracle(address tok) external view returns(address);\\n  function updateOracleData(address _uTokens, address _oracleAddress, address _underlyingMidToken, address uniPool)external;\\n  function _withdrawAave(address tok, uint amount) external;\\n  function _withdrawDydx(address tok, uint amount) external;\\n  function _withdrawCompound(address tok, uint amount) external;\\n  function getTVL() external view returns(uint256);\\n  function upDateInputTokPool(bytes memory uniData) external;\\n  function getTypeOfProduct() external view returns(uint256);\\n  function updateuniPool(address tok, address midTok) external;\\n  function getMidToken(address tok) external view returns (address);\\n  function getPool(\\n    address tok,\\n    address midTok\\n  ) external view returns (address);\\n}\"},\"IAFiStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity =0.8.0;\\n\\n/**\\n * @title IAFiStorage.\\n * @notice Interface of the AFiStorage.\\n */\\n\\ninterface IIEarnManager {\\n  function recommend(\\n    address _token,\\n    address afiBase,\\n    address afiStorage\\n  ) external view returns (string memory choice, uint capr, uint aapr, uint dapr);\\n}\\n\\ninterface IAFiStorage {\\n  /**\\n   * @notice Struct representing investor details.\\n   * @param isPresent Boolean indicating whether an investor exists.\\n   * @param uTokenBalance Investor underlying token balance.\\n   * @param investedAmount Amount of StableCoin invested in the underlying token\\n   */\\n  struct Investor {\\n    bool isPresent;\\n    uint depositNAV;\\n    uint redemptionNAV;\\n  }\\n\\n  /**\\n   * @notice Struct representing TeamWallet details.\\n   * @param isPresent Boolean indicating whether a wallet exists.\\n   * @param isActive Boolean indicating whether a wallet is active.\\n   * @param walletAddress Wallet address.\\n   */\\n  struct TeamWallet {\\n    bool isPresent;\\n    bool isActive;\\n    address walletAddress;\\n  }\\n\\n  /**\\n   * @notice enum representing Lending Protocols.\\n   * @param NONE represents NO protocol.\\n   * @param DYDX represents DYDX protocol.\\n   * @param COMPOUND represents COMPOUND protocol.\\n   * @param AAVE represents AAVE protocol.\\n   */\\n  enum Lender {\\n    NONE,\\n    DYDX,\\n    COMPOUND,\\n    AAVE\\n  }\\n\\n  /**\\n   * @notice Struct representing Rebalance details.\\n   * @param scenario Scenario can be either of 0, 1 or 2.\\n   * @param rebalancedUToken Address of the underlying token that is rebalanced.\\n   * @param rebalancedToUTokens Array of addresses of underlying tokens to which the uToken has been rebalanced.\\n   */\\n  struct RebalanceDetails {\\n    uint8 scenario;\\n    address rebalancedUToken;\\n    address[] rebalancedToUTokens;\\n  }\\n\\n  /**\\n   * @param walletAddress Address of the wallet.\\n   * @param isActive Boolean indicating wallet active status.\\n   */\\n  event TeamWalletActive(address indexed walletAddress, bool isActive);\\n\\n  /**\\n   * @param walletAddress Address of the wallet.\\n   * @param isActive Boolean indicating wallet active status.\\n   */\\n  event TeamWalletAdd(address indexed walletAddress, bool isActive);\\n\\n  /**\\n   * @notice Returns the team wallet details.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _wallet Wallet address\\n   * @return isPresent Boolean indicating the present status of the wallet.\\n   * @return isActive Boolean indicating whether to set the wallet to either active/inactive.\\n   */\\n  function getTeamWalletDetails(\\n    address aFiContract,\\n    address _wallet\\n  ) external view returns (bool isPresent, bool isActive);\\n\\n  /**\\n   * @notice To add a new team wallet.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _wallet Wallet address that has to be added in the `teamWallets` array.\\n   * @param isActive Boolean indicating whether to set the wallet to either active/inactive.\\n   * @param isPresent Boolean indicating the present status of the wallet.\\n   */\\n  function addTeamWallet(\\n    address aFiContract,\\n    address _wallet,\\n    bool isActive,\\n    bool isPresent\\n  ) external;\\n\\n  /**\\n   * @notice Returns the team wallets for an AFi.\\n   * @param aFiContract Address of the AFi contract.\\n   * @return _teamWallets Array of teamWallets.\\n   */\\n  function getTeamWalletsOfAFi(\\n    address aFiContract\\n  ) external view returns (address[] memory _teamWallets);\\n\\n  /**\\n   * @notice Sets the address for team wallets.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param _teamWallets Array of addresses for the team wallets.\\n   */\\n  function setTeamWallets(address aFiContract, address[] memory _teamWallets) external;\\n\\n  /**\\n   * @notice Sets the status for the AFi in the storage contract.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param active status for afiContracts.\\n   */\\n  function setAFiActive(address aFiContract, bool active) external;\\n\\n  /**\\n   * @notice To update rebalance details in the storage\\n   * @param aFiContract Address of the AFi contract.\\n   * @param rbUToken Address of the underlying token that is rebalanced.\\n   * @param rbtoUTokens Array of addresses of underlying tokens to which the uToken has been rebalanced.\\n   * @param _scenario Scenario can be either of 0, 1 or 2.\\n   */\\n  function updateRebalanceDetails(\\n    address aFiContract,\\n    address rbUToken,\\n    address[] memory rbtoUTokens,\\n    uint8 _scenario\\n  ) external;\\n\\n  /**\\n   * @notice Sets Active Rebalance status of an AFi.\\n   * @param aFiContract Address of the AFi contract.\\n   * @param status indicating active rebalance status of the AFi contract.\\n   */\\n  function setActiveRebalancedStatus(address aFiContract, bool status) external;\\n\\n  /**\\n   * @notice gets Active Rebalance status of an AFi.\\n   * @param aFiContract Address of the AFi contract.\\n   * @return _isActiveRebalanced bool indicating active rebalance status of the AFi contract.\\n   */\\n  function isAFiActiveRebalanced(\\n    address aFiContract\\n  ) external view returns (bool _isActiveRebalanced);\\n\\n  function getTotalActiveWallets(address aFiContract) external view returns (uint);\\n\\n  function setAPR(address aFiContract, address _apr) external;\\n\\n  function calcPoolValue(address tok, address afiContract, address midTok) external view returns (uint);\\n\\n  function calculateBalanceOfUnderlying(\\n    address tok,\\n    address afiContract\\n  ) external view returns (uint);\\n\\n  function calculatePoolInUsd(address afiContract) external view returns (uint);\\n\\n  function calcPoolValueSome(\\n    address tok,\\n    address afiContract,\\n    address midTok\\n  ) external view returns (uint);\\n\\n  function afiSync(\\n    address afiContract,\\n    address tok,\\n    address aaveTok,\\n    uint dtoken,\\n    address compTok\\n  ) external;\\n\\n  function getPriceOracle(address tokenIn) external view returns (uint256 priceOracle);\\n  function getAFiInitStatus(address afiContract) external view returns(bool, bool, bool);\\n  function afiContractInitUpdate(address afiContract, uint order) external;\\n  function getMinimumAmountOut(address afiContract, address _tokenIn, uint256 _amountIn, address _tokenOut, address midTok, address uniPool) external view  returns(uint256 priceOracle);\\n  function checkIfUSDC(address afiContract, address tok, address midTok) external view returns (uint256, uint256);\\n  function validateAndGetDecimals(address tok) external  view returns(uint256);\\n  function getStakedStatus(address aFiContract,address uToken) external view  returns(bool);\\n  function rearrange(address aFiContract) external;\\n  function balanceDydx(address tok, address afiContract) external view returns (uint);\\n  function balanceDydxAvailable(address tok) external view returns (uint);\\n  function balanceCompoundInToken(address tok, address afiContract) external view returns (uint);\\n  function balanceCompound(address tok, address afiContract) external view returns (uint);\\n  function balanceAave(address tok, address afiContract) external view returns (uint);\\n  function swapForOtherProduct(address afiContract, uint r, address oToken, uint deadline, uint[] memory slippageFactor) external returns(uint256);\\n  function caculateMinOutForUniswap(address afiContract, address _tokenIn, address _tokenOut, uint256 amt, address middleToken, address uniPool) external view returns(uint256);\\n  function _withdrawAll(address afiContract, address tok) external;\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"},\"IERC20Extended.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity =0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Extended is IERC20 {\\n  function decimals() external view returns (uint8);\\n}\\n\"},\"IPassiveRebal.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity =0.8.0;\\n\\ninterface IPassiveRebal {\\n  function applyRebalForProportions(\\n    address _aFiContract,\\n    address _aFiManager,\\n    address _aFiStorage,\\n    uint _strategyNumber,\\n    address[] memory _tokens\\n  ) external returns (uint[] memory proportions);\\n\\n  function getPauseStatus() external returns (bool);\\n\\n  function getRebalPeriod(address aFiContract) external returns (uint);\\n\\n  function updateRebalPeriod(address aFiContract, uint _newRebalPeiod) external;\\n\\n  function setPassiveRebalancedStatus(address aFiContract, bool status) external;\\n\\n  function isAFiPassiveRebalanced(\\n    address aFiContract\\n  ) external returns (bool _isPassiveRebalanced);\\n\\n  function getRebalStrategyNumber(address aFiContract) external returns (uint);\\n\\n  function updateRebalStrategyNumber(\\n    address aFiContract,\\n    uint updatedStrategy\\n  ) external;\\n}\\n\"},\"IUniswapV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.0;\\n\\ninterface IUniswapOracleV3 {\\n  function PERIOD() external returns (uint256);\\n  function factory() external returns (address);\\n  function update(address _tokenIn, address _tokenOut) external;\\n\\n  function consult(\\n    address _tokenIn,\\n    uint256 _amountIn,\\n    address _tokenOut\\n  ) external view returns (uint256 _amountOut);\\n\\n  function estimateAmountOut(\\n    address tokenIn,\\n    uint128 amountIn,\\n    address tokenOut\\n  ) external view returns (uint amountOut);\\n\\n  function estimateAmountOutMin(\\n    address tokenIn,\\n    uint128 amountIn,\\n    address tokenOut,\\n    address pool\\n  ) external view returns (uint amountOut);\\n\\n  function updateAndConsult(\\n    address _tokenIn,\\n    uint256 _amountIn,\\n    address _tokenOut\\n  ) external returns (uint256 _amountOut);\\n\\n  function checkUnderlyingPool(address token) external view returns (bool hasPool);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler\\u0027s built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c \\u003c a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b \\u003e a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003c= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aFiManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracleV3\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"DeactivateTeamWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"ReActivateTeamWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetAFiActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_apr\",\"type\":\"address\"}],\"name\":\"SetAPR\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetActiveRebalancedStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"TeamWalletActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"TeamWalletAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rbToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"scenario\",\"type\":\"uint8\"}],\"name\":\"UpdateRebalanceDetails\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"}],\"name\":\"_withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"aaveTokenCopy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPresent\",\"type\":\"bool\"}],\"name\":\"addTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"order\",\"type\":\"uint256\"}],\"name\":\"afiContractInitUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aaveTok\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dtoken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"compTok\",\"type\":\"address\"}],\"name\":\"afiSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"apr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"balanceAave\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"balanceCompound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"balanceCompoundInToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"balanceDydx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"}],\"name\":\"balanceDydxAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"middleToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unipool\",\"type\":\"address\"}],\"name\":\"caculateMinOutForUniswap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"midTok\",\"type\":\"address\"}],\"name\":\"calcPoolValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"midTok\",\"type\":\"address\"}],\"name\":\"calcPoolValueSome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"calculateBalanceOfUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"}],\"name\":\"calculatePoolInUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"midTok\",\"type\":\"address\"}],\"name\":\"checkIfUSDC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"compoundCopy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dTokenCopy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"deactivateTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dydx\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"}],\"name\":\"getAFiInitStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"midTok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniPool\",\"type\":\"address\"}],\"name\":\"getMinimumAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"}],\"name\":\"getPriceOracle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceOracle\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRebalanceDetails\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uToken\",\"type\":\"address\"}],\"name\":\"getStakedStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uToken\",\"type\":\"address\"}],\"name\":\"getStalePriceDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getTeamWalletDetails\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPresent\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"}],\"name\":\"getTeamWalletsOfAFi\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_teamWallets\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"}],\"name\":\"getTotalActiveWallets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"underlyingTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_stalePriceDelay\",\"type\":\"uint256[]\"}],\"name\":\"intializeStalePriceDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAFiActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"}],\"name\":\"isAFiActiveRebalanced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isActiveRebalanced\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"provider\",\"outputs\":[{\"internalType\":\"enum IAFiStorage.Lender\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"reActivateTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"}],\"name\":\"rearrange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setAFiActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_apr\",\"type\":\"address\"}],\"name\":\"setAPR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setActiveRebalancedStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stalePriceDelay\",\"type\":\"uint256\"}],\"name\":\"setStalePriceDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_teamWallets\",\"type\":\"address[]\"}],\"name\":\"setTeamWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"afiContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"oToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"slippageFactor\",\"type\":\"uint256[]\"}],\"name\":\"swapForOtherProduct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapOracleV3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aFiContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rbUToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"rbtoUTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"_scenario\",\"type\":\"uint8\"}],\"name\":\"updateRebalanceDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tok\",\"type\":\"address\"}],\"name\":\"validateAndGetDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AFiStorage", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005ebad784813bddfe8f2374103e7b9d9c955959d7000000000000000000000000f4d1ee82a413e46d76faeae3403f498cd0612669", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://74a918f5de8b96b363bfb5dab643b0ad168ab884e6163b353d4cbf8d68e7e670"}