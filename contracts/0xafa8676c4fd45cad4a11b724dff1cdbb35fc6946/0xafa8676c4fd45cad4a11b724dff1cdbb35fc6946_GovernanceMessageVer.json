{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/governance/GovernanceMessageVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {RLPReader} from \\\"solidity-rlp/contracts/RLPReader.sol\\\";\\nimport {IGovernanceMessageVerifier} from \\\"../interfaces/IGovernanceMessageVerifier.sol\\\";\\nimport {IRootChain} from \\\"../interfaces/external/IRootChain.sol\\\";\\nimport {ITelepathyRouter} from \\\"../interfaces/external/ITelepathyRouter.sol\\\";\\nimport {Merkle} from \\\"../libraries/Merkle.sol\\\";\\nimport {MerklePatriciaProof} from \\\"../libraries/MerklePatriciaProof.sol\\\";\\n\\nerror InvalidGovernanceMessageEmitter(address governanceMessageEmitter, address expecteGovernanceMessageEmitter);\\nerror InvalidTopic(bytes32 topic, bytes32 expectedTopic);\\nerror InvalidReceiptsRootMerkleProof();\\nerror InvalidRootHashMerkleProof();\\nerror InvalidHeaderBlock();\\nerror MessageAlreadyProcessed(IGovernanceMessageVerifier.GovernanceMessageProof proof);\\nerror InvalidNonce(uint256 nonce, uint256 expectedNonce);\\n\\ncontract GovernanceMessageVerifier is IGovernanceMessageVerifier {\\n    address public constant TELEPATHY_ROUTER = 0x41EA857C32c8Cb42EEFa00AF67862eCFf4eB795a;\\n    address public constant ROOT_CHAIN_ADDRESS = 0x86E4Dc95c7FBdBf52e33D563BbDB00823894C287;\\n    bytes32 public constant EVENT_SIGNATURE_TOPIC = 0x85aab78efe4e39fd3b313a465f645990e6a1b923f5f5b979957c176e632c5a07; //keccak256(GovernanceMessage(bytes));\\n\\n    address public immutable governanceMessageEmitter;\\n\\n    uint256 public totalNumberOfProcessedMessages;\\n    mapping(bytes32 => bool) _messagesProcessed;\\n\\n    constructor(address governanceMessageEmitter_) {\\n        governanceMessageEmitter = governanceMessageEmitter_;\\n    }\\n\\n    /// @inheritdoc IGovernanceMessageVerifier\\n    function isProcessed(GovernanceMessageProof calldata proof) external view returns (bool) {\\n        return _messagesProcessed[proofIdOf(proof)];\\n    }\\n\\n    /// @inheritdoc IGovernanceMessageVerifier\\n    function proofIdOf(GovernanceMessageProof calldata proof) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    proof.rootHashProof,\\n                    proof.rootHashProofIndex,\\n                    proof.receiptsRoot,\\n                    proof.blockNumber,\\n                    proof.blockTimestamp,\\n                    proof.transactionsRoot,\\n                    proof.receiptsRootProofPath,\\n                    proof.receiptsRootProofParentNodes,\\n                    proof.receipt,\\n                    proof.logIndex,\\n                    proof.transactionType,\\n                    proof.headerBlock\\n                )\\n            );\\n    }\\n\\n    /// @inheritdoc IGovernanceMessageVerifier\\n    function verifyAndPropagateMessage(GovernanceMessageProof calldata proof) external {\\n        bytes32 id = proofIdOf(proof);\\n        if (_messagesProcessed[id]) {\\n            revert MessageAlreadyProcessed(proof);\\n        }\\n        _messagesProcessed[id] = true;\\n\\n        // NOTE: handle legacy and eip2718\\n        RLPReader.RLPItem[] memory receiptData = RLPReader.toList(\\n            RLPReader.toRlpItem(proof.transactionType == 2 ? proof.receipt[1:] : proof.receipt)\\n        );\\n        RLPReader.RLPItem[] memory logs = RLPReader.toList(receiptData[3]);\\n        RLPReader.RLPItem[] memory log = RLPReader.toList(logs[proof.logIndex]);\\n\\n        // NOTE: only events emitted from the GovernanceMessageEmitter will be propagated\\n        address proofGovernanceMessageEmitter = RLPReader.toAddress(log[0]);\\n        if (governanceMessageEmitter != proofGovernanceMessageEmitter) {\\n            revert InvalidGovernanceMessageEmitter(proofGovernanceMessageEmitter, governanceMessageEmitter);\\n        }\\n\\n        RLPReader.RLPItem[] memory topics = RLPReader.toList(log[1]);\\n        bytes32 proofTopic = bytes32(RLPReader.toBytes(topics[0]));\\n        if (EVENT_SIGNATURE_TOPIC != proofTopic) {\\n            revert InvalidTopic(proofTopic, EVENT_SIGNATURE_TOPIC);\\n        }\\n\\n        if (\\n            !MerklePatriciaProof.verify(\\n                proof.receipt,\\n                proof.receiptsRootProofPath,\\n                proof.receiptsRootProofParentNodes,\\n                proof.receiptsRoot\\n            )\\n        ) {\\n            revert InvalidReceiptsRootMerkleProof();\\n        }\\n\\n        bytes32 blockHash = keccak256(\\n            abi.encodePacked(proof.blockNumber, proof.blockTimestamp, proof.transactionsRoot, proof.receiptsRoot)\\n        );\\n\\n        (bytes32 rootHash, , , , ) = IRootChain(ROOT_CHAIN_ADDRESS).headerBlocks(proof.headerBlock);\\n        if (rootHash == bytes32(0)) {\\n            revert InvalidHeaderBlock();\\n        }\\n\\n        if (!Merkle.checkMembership(blockHash, proof.rootHashProofIndex, rootHash, proof.rootHashProof)) {\\n            revert InvalidRootHashMerkleProof();\\n        }\\n\\n        bytes memory message = RLPReader.toBytes(log[2]);\\n        (uint256 nonce, uint32[] memory chainIds, address[] memory hubs, bytes memory data) = abi.decode(\\n            message,\\n            (uint256, uint32[], address[], bytes)\\n        );\\n        if (nonce != totalNumberOfProcessedMessages) {\\n            revert InvalidNonce(nonce, totalNumberOfProcessedMessages);\\n        }\\n        unchecked {\\n            ++totalNumberOfProcessedMessages;\\n        }\\n\\n        for (uint256 index = 0; index < chainIds.length; ) {\\n            ITelepathyRouter(TELEPATHY_ROUTER).send(chainIds[index], hubs[index], data);\\n\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n\\n        emit GovernanceMessagePropagated(data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/IRootChain.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.19;\\n\\ninterface IRootChain {\\n    function headerBlocks(uint256 headerBlock) external view returns (bytes32, uint256, uint256, uint256, address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/ITelepathyRouter.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.19;\\n\\ninterface ITelepathyRouter {\\n    function send(\\n        uint32 destinationChainId,\\n        address destinationAddress,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernanceMessageVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @title IGovernanceMessageVerifier\\n * @author pNetwork\\n *\\n * @notice\\n */\\n\\ninterface IGovernanceMessageVerifier {\\n    struct GovernanceMessageProof {\\n        bytes rootHashProof;\\n        uint256 rootHashProofIndex;\\n        bytes32 receiptsRoot;\\n        uint256 blockNumber;\\n        uint256 blockTimestamp;\\n        bytes32 transactionsRoot;\\n        bytes receiptsRootProofPath;\\n        bytes receiptsRootProofParentNodes;\\n        bytes receipt;\\n        uint256 logIndex;\\n        uint8 transactionType;\\n        uint256 headerBlock;\\n    }\\n\\n    /**\\n     * @dev Emitted when a governance message is propagated.\\n     *\\n     * @param data The governance message\\n     */\\n    event GovernanceMessagePropagated(bytes data);\\n\\n    /*\\n     * @notice Returns if a message has been processed by providing the proof.\\n     *\\n     * @param proof\\n     *\\n     * @return bool indicating if the message has been processed or not.\\n     */\\n    function isProcessed(GovernanceMessageProof calldata proof) external view returns (bool);\\n\\n    /*\\n     * @notice Returns the id of a message proof.\\n     *\\n     * @param proof\\n     *\\n     * @return bytes32 representing the id of a message proof.\\n     */\\n    function proofIdOf(GovernanceMessageProof calldata proof) external pure returns (bytes32);\\n\\n    /*\\n     * @notice Verify that a certain event has been emitted on Polygon by the GovernanceMessageEmitter and propagate the message\\n     *\\n     * @param proof\\n     * @param destinationAddresses\\n     *\\n     */\\n    function verifyAndPropagateMessage(GovernanceMessageProof calldata proof) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Merkle.sol\": {\r\n      \"content\": \"// taken here: https://github.com/maticnetwork/contracts/blob/main/contracts/common/lib/Merkle.sol\\npragma solidity ^0.8.19;\\n\\nlibrary Merkle {\\n    function checkMembership(\\n        bytes32 leaf,\\n        uint256 index,\\n        bytes32 rootHash,\\n        bytes memory proof\\n    ) internal pure returns (bool) {\\n        require(proof.length % 32 == 0, \\\"Invalid proof length\\\");\\n        uint256 proofHeight = proof.length / 32;\\n        // Proof of size n means, height of the tree is n+1.\\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\\n        require(index < 2 ** proofHeight, \\\"Leaf index is too big\\\");\\n\\n        bytes32 proofElement;\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 32; i <= proof.length; i += 32) {\\n            assembly {\\n                proofElement := mload(add(proof, i))\\n            }\\n\\n            if (index % 2 == 0) {\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n\\n            index = index / 2;\\n        }\\n        return computedHash == rootHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MerklePatriciaProof.sol\": {\r\n      \"content\": \"// taken here: https://github.com/maticnetwork/contracts/blob/main/contracts/common/lib/MerklePatriciaProof.sol\\n\\n/*\\n * @title MerklePatriciaVerifier\\n * @author Sam Mayo (sammayo888@gmail.com)\\n *\\n * @dev Library for verifing merkle patricia proofs.\\n */\\npragma solidity ^0.8.19;\\n\\nimport {RLPReader} from \\\"solidity-rlp/contracts/RLPReader.sol\\\";\\n\\nlibrary MerklePatriciaProof {\\n    /*\\n     * @dev Verifies a merkle patricia proof.\\n     * @param value The terminating value in the trie.\\n     * @param encodedPath The path in the trie leading to value.\\n     * @param rlpParentNodes The rlp encoded stack of nodes.\\n     * @param root The root hash of the trie.\\n     * @return The boolean validity of the proof.\\n     */\\n    function verify(\\n        bytes memory value,\\n        bytes memory encodedPath,\\n        bytes memory rlpParentNodes,\\n        bytes32 root\\n    ) internal pure returns (bool) {\\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\\n        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\\n\\n        bytes memory currentNode;\\n        RLPReader.RLPItem[] memory currentNodeList;\\n\\n        bytes32 nodeKey = root;\\n        uint256 pathPtr = 0;\\n\\n        bytes memory path = _getNibbleArray(encodedPath);\\n        if (path.length == 0) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < parentNodes.length; i++) {\\n            if (pathPtr > path.length) {\\n                return false;\\n            }\\n\\n            currentNode = RLPReader.toRlpBytes(parentNodes[i]);\\n            if (nodeKey != keccak256(currentNode)) {\\n                return false;\\n            }\\n            currentNodeList = RLPReader.toList(parentNodes[i]);\\n\\n            if (currentNodeList.length == 17) {\\n                if (pathPtr == path.length) {\\n                    if (keccak256(RLPReader.toBytes(currentNodeList[16])) == keccak256(value)) {\\n                        return true;\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n\\n                uint8 nextPathNibble = uint8(path[pathPtr]);\\n                if (nextPathNibble > 16) {\\n                    return false;\\n                }\\n\\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[nextPathNibble]));\\n                pathPtr += 1;\\n            } else if (currentNodeList.length == 2) {\\n                uint256 traversed = _nibblesToTraverse(RLPReader.toBytes(currentNodeList[0]), path, pathPtr);\\n                if (pathPtr + traversed == path.length) {\\n                    //leaf node\\n                    if (keccak256(RLPReader.toBytes(currentNodeList[1])) == keccak256(value)) {\\n                        return true;\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n\\n                //extension node\\n                if (traversed == 0) {\\n                    return false;\\n                }\\n\\n                pathPtr += traversed;\\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    function _nibblesToTraverse(\\n        bytes memory encodedPartialPath,\\n        bytes memory path,\\n        uint256 pathPtr\\n    ) private pure returns (uint256) {\\n        uint256 len;\\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\\n        // and slicedPath have elements that are each one hex character (1 nibble)\\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\\n        bytes memory slicedPath = new bytes(partialPath.length);\\n\\n        // pathPtr counts nibbles in path\\n        // partialPath.length is a number of nibbles\\n        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\\n            bytes1 pathNibble = path[i];\\n            slicedPath[i - pathPtr] = pathNibble;\\n        }\\n\\n        if (keccak256(partialPath) == keccak256(slicedPath)) {\\n            len = partialPath.length;\\n        } else {\\n            len = 0;\\n        }\\n        return len;\\n    }\\n\\n    // bytes b must be hp encoded\\n    function _getNibbleArray(bytes memory b) private pure returns (bytes memory) {\\n        bytes memory nibbles;\\n        if (b.length > 0) {\\n            uint8 offset;\\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\\n            if (hpNibble == 1 || hpNibble == 3) {\\n                nibbles = new bytes(b.length * 2 - 1);\\n                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\\n                nibbles[0] = oddNibble;\\n                offset = 1;\\n            } else {\\n                nibbles = new bytes(b.length * 2 - 2);\\n                offset = 0;\\n            }\\n\\n            for (uint256 i = offset; i < nibbles.length; i++) {\\n                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\\n            }\\n        }\\n        return nibbles;\\n    }\\n\\n    function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {\\n        return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity-rlp/contracts/RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity >=0.5.10 <0.9.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governanceMessageEmitter_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governanceMessageEmitter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expecteGovernanceMessageEmitter\",\"type\":\"address\"}],\"name\":\"InvalidGovernanceMessageEmitter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidHeaderBlock\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedNonce\",\"type\":\"uint256\"}],\"name\":\"InvalidNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReceiptsRootMerkleProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRootHashMerkleProof\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"topic\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"expectedTopic\",\"type\":\"bytes32\"}],\"name\":\"InvalidTopic\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"rootHashProof\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"rootHashProofIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"receiptsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"transactionsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"receiptsRootProofPath\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receiptsRootProofParentNodes\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receipt\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"logIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"transactionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"headerBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct IGovernanceMessageVerifier.GovernanceMessageProof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"name\":\"MessageAlreadyProcessed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"GovernanceMessagePropagated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EVENT_SIGNATURE_TOPIC\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT_CHAIN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TELEPATHY_ROUTER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceMessageEmitter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"rootHashProof\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"rootHashProofIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"receiptsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"transactionsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"receiptsRootProofPath\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receiptsRootProofParentNodes\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receipt\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"logIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"transactionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"headerBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct IGovernanceMessageVerifier.GovernanceMessageProof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"name\":\"isProcessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"rootHashProof\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"rootHashProofIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"receiptsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"transactionsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"receiptsRootProofPath\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receiptsRootProofParentNodes\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receipt\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"logIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"transactionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"headerBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct IGovernanceMessageVerifier.GovernanceMessageProof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"name\":\"proofIdOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNumberOfProcessedMessages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"rootHashProof\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"rootHashProofIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"receiptsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"transactionsRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"receiptsRootProofPath\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receiptsRootProofParentNodes\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"receipt\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"logIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"transactionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"headerBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct IGovernanceMessageVerifier.GovernanceMessageProof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"name\":\"verifyAndPropagateMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GovernanceMessageVerifier", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000594e3ee2f0d3704d0de8551516b1f4963e8dec17", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}