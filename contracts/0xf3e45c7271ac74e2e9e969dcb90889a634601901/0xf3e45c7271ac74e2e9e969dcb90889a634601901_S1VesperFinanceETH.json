{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/S1VesperFinanceETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"./interfaces/IUniswapConnector.sol\\\";\\nimport \\\"./interfaces/IS1Proxy.sol\\\";\\nimport \\\"./proxies/S1VesperFinanceETHProxy.sol\\\";\\n\\n\\ninterface IFees {\\n    function feeCollector(uint256 _index) external view returns (address);\\n    function depositStatus(uint256 _index) external view returns (bool);\\n    function calcFee(\\n        uint256 _strategyId,\\n        address _user,\\n        address _feeToken\\n    ) external view returns (uint256);\\n    function whitelistedDepositCurrencies(uint256 _index, address _token) external view returns(bool);\\n}\\n\\n\\ncontract S1VesperFinanceETH {\\n    uint8 constant public strategyIndex = 4;\\n    address public feesAddress;\\n    address public uniswapConnector;\\n    address private wethAddress;\\n\\n    // protocols\\n    address public vPoolETH;\\n    address public vPoolRewardsETH;\\n    address public vspToken;\\n\\n    mapping(address => address) public depositors;\\n\\n    constructor(\\n        address _feesAddress,\\n        address _uniswapConnector,\\n        address _wethAddress,\\n        address _vPoolETH,\\n        address _vPoolRewardsETH,\\n        address _vspToken\\n    ) {\\n        feesAddress = _feesAddress;\\n        uniswapConnector = _uniswapConnector;\\n        wethAddress = _wethAddress;\\n        vPoolETH = _vPoolETH;\\n        vPoolRewardsETH = _vPoolRewardsETH;\\n        vspToken = _vspToken;\\n    }\\n\\n    event Deposit(address indexed _depositor, address indexed _token, uint256 _amountIn, uint256 _amountOut);\\n\\n    event Withdraw(address indexed _depositor, address indexed _token, uint256 _amount, uint256 _fee);\\n\\n    event ClaimAdditionalTokens(address indexed _depositor, uint256 _amount0, uint256 _amount1, address indexed _swappedTo);\\n\\n    // Get current unclaimed additional tokens amount\\n    function getPendingAdditionalTokenClaims(address _address) external view returns(address[] memory _rewardTokens, uint256[] memory _claimableAmounts) {\\n        return IVPoolRewards(vPoolRewardsETH).claimable(depositors[_address]);\\n    }\\n\\n    // Get current stake\\n    function getCurrentDeposit(address _address) external view returns(uint256, uint256) {\\n        uint256 vaETHShare = IERC20(vPoolETH).balanceOf(depositors[_address]);\\n        uint256 ethEquivalent;\\n        if (vaETHShare > 0) {\\n            uint256 pricePerShare = IVPoolETH(vPoolETH).pricePerShare();\\n            ethEquivalent = (pricePerShare * vaETHShare) / 10 ** 18;\\n        }\\n        return (vaETHShare, ethEquivalent);\\n    }\\n\\n    function depositETH() public payable {\\n        require(IFees(feesAddress).depositStatus(strategyIndex), \\\"ERR: DEPOSITS_STOPPED\\\");\\n\\n        _yieldDeposit(msg.value);\\n        emit Deposit(msg.sender, wethAddress, msg.value, 0);\\n    }\\n\\n    function depositToken(address _token, uint256 _amount, uint256 _amountOutMin) external {\\n        require(IFees(feesAddress).depositStatus(strategyIndex), \\\"ERR: DEPOSITS_STOPPED\\\");\\n        require(IFees(feesAddress).whitelistedDepositCurrencies(strategyIndex, _token), \\\"ERR: INVALID_DEPOSIT_TOKEN\\\");\\n        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\\n\\n        if (IERC20(_token).allowance(address(this), uniswapConnector) == 0) {\\n            IERC20(_token).approve(uniswapConnector, 2**256 - 1);\\n        }\\n\\n        uint256 depositAmount = IUniswapConnector(uniswapConnector).swapTokenForToken(\\n            _token,\\n            wethAddress, \\n            _amount, \\n            _amountOutMin, \\n            address(this)\\n        );\\n        IWETH(wethAddress).withdraw(depositAmount);\\n        _yieldDeposit(depositAmount);\\n \\n        emit Deposit(msg.sender, _token, _amount, depositAmount);\\n    }\\n\\n    function _yieldDeposit(uint256 _amount) private {\\n        if (depositors[msg.sender] == address(0)) {\\n            // deploy new proxy contract\\n            S1VesperFinanceETHProxy s1proxy = new S1VesperFinanceETHProxy(\\n                address(this),\\n                vPoolETH,\\n                vPoolRewardsETH,\\n                vspToken\\n            );\\n            depositors[msg.sender] = address(s1proxy);\\n            s1proxy.depositETH{value: _amount}();\\n        } else {\\n            // send the deposit to the existing proxy contract\\n            IS1Proxy(depositors[msg.sender]).depositETH{value: _amount}();\\n        }\\n    }\\n\\n    // claim VSP tokens and withdraw them\\n    function claimRaw() external {\\n        require(depositors[msg.sender] != address(0), \\\"ERR: INVALID_DEPOSITOR\\\");\\n        uint256 vspTokens = IS1Proxy(depositors[msg.sender]).claimToDepositor(msg.sender);\\n\\n        emit ClaimAdditionalTokens(msg.sender, vspTokens, 0, address(0));\\n    }\\n\\n    // claim VSP tokens, swap them for ETH and withdraw\\n    function claimInETH(uint256 _amountOutMin) external {\\n        claimInToken(wethAddress, _amountOutMin);        \\n    }\\n\\n    // claim VSP tokens, swap them for _token and withdraw\\n    function claimInToken(address _token, uint256 _amountOutMin) public {\\n        require(depositors[msg.sender] != address(0), \\\"ERR: INVALID_DEPOSITOR\\\");\\n        uint256 vspTokens = IS1Proxy(depositors[msg.sender]).claimToDeployer();\\n\\n        address receiver;\\n        if (_token == wethAddress) {\\n            receiver = address(this);\\n        } else {\\n            receiver = msg.sender;\\n        }\\n        \\n        uint256 tokenAmount;\\n        if (vspTokens > 0) {\\n            if (IERC20(vspToken).allowance(address(this), uniswapConnector) == 0) {\\n                IERC20(vspToken).approve(uniswapConnector, 2**256 - 1);\\n            }\\n\\n            tokenAmount = IUniswapConnector(uniswapConnector).swapTokenForToken(\\n                vspToken,\\n                _token,\\n                vspTokens,\\n                _amountOutMin,\\n                receiver\\n            );\\n\\n            if (_token == wethAddress) {\\n                IWETH(wethAddress).withdraw(tokenAmount);\\n                (bool success, ) = payable(msg.sender).call{value: tokenAmount}(\\\"\\\");\\n                require(success, \\\"ERR: FAIL_SENDING_ETH\\\");\\n            }\\n        }\\n\\n        emit ClaimAdditionalTokens(msg.sender, vspTokens, tokenAmount, _token);\\n    }\\n\\n    function withdrawETH(uint256 _vaETHAmount, address _feeToken) external {\\n        require(depositors[msg.sender] != address(0), \\\"ERR: INVALID_DEPOSITOR\\\");\\n        (uint256 yieldDeposit, uint256 fee) = _withdrawYieldDeposit(_vaETHAmount, _feeToken);\\n\\n        // withdraw ETH\\n        (bool success, ) = payable(msg.sender).call{value: yieldDeposit - fee}(\\\"\\\");\\n        require(success, \\\"ERR: FAIL_SENDING_ETH\\\");\\n        emit Withdraw(msg.sender, wethAddress, yieldDeposit - fee, fee);\\n    }\\n\\n    function withdrawToken(address _token, uint256 _vaETHAmount, uint256 _amountOutMin, address _feeToken) external {\\n        require(depositors[msg.sender] != address(0), \\\"ERR: INVALID_DEPOSITOR\\\");\\n        (uint256 yieldDeposit, uint256 fee) = _withdrawYieldDeposit(_vaETHAmount, _feeToken);\\n\\n        uint256 tokenAmount = IUniswapConnector(uniswapConnector).swapETHForToken{value: yieldDeposit - fee}(\\n            _token, \\n            0, \\n            _amountOutMin, \\n            msg.sender\\n        );\\n\\n        emit Withdraw(msg.sender, _token, tokenAmount, fee);\\n    }\\n\\n    function _withdrawYieldDeposit(uint256 _vaETHAmount, address _feeToken) private returns(uint256, uint256) {\\n        uint256 ethAmountToBeWithdrawn = IS1Proxy(depositors[msg.sender]).withdraw(_vaETHAmount);\\n\\n        // if fee then send it to the feeCollector\\n        uint256 fee = (ethAmountToBeWithdrawn * IFees(feesAddress).calcFee(strategyIndex, msg.sender, _feeToken)) / 1000;\\n        if (fee > 0) {\\n            (bool success, ) = payable(IFees(feesAddress).feeCollector(strategyIndex)).call{value: fee}(\\\"\\\");\\n            require(success, \\\"ERR: FAIL_SENDING_ETH\\\");\\n        }\\n        return (ethAmountToBeWithdrawn, fee);  \\n    }\\n\\n    receive() external payable {}\\n}\\n\\n// MN bby \u00af\\\\_(\u30c4)_/\u00af\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IERC20 {\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external;\\n\\n    function transfer(address recipient, uint256 amount) external;\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function decimals() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IWETH {\\n    function withdraw(uint wad) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IS1Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IS1Proxy {\\n    function deposit(uint256 _deposit) external;\\n    function depositETH() external payable;\\n    function withdraw(uint256 _amount) external returns(uint256);\\n    function claimToDepositor(address _depositor) external returns(uint256);\\n    function claimToDeployer() external returns(uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUniswapConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IUniswapConnector {\\n    function swapTokenForToken(address _tokenIn, address _tokenOut, uint256 _amount, uint256 _amountOutMin, address _to) external returns(uint256);\\n\\n    function swapTokenForETH(address _tokenIn, uint256 _amount, uint256 _amountOutMin, address _to) external returns(uint256);\\n\\n    function swapETHForToken(address _tokenOut, uint256 _amount, uint256 _amountOutMin, address _to) external payable returns(uint256);\\n}\"\r\n    },\r\n    \"contracts/proxies/S1VesperFinanceETHProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IVesperFinance.sol\\\";\\n\\n\\ncontract S1VesperFinanceETHProxy {\\n    address public deployer;\\n    address public vPoolETH;\\n    address public vPoolRewardsETH;\\n    address public vspToken;\\n\\n    constructor(\\n        address _deployer,\\n        address _vPoolETH,\\n        address _vPoolRewardsETH,\\n        address _vspToken\\n    ) {\\n        deployer = _deployer;\\n        vPoolETH = _vPoolETH;\\n        vPoolRewardsETH = _vPoolRewardsETH;\\n        vspToken = _vspToken;\\n    }\\n\\n    modifier onlyDeployer() {\\n        require(msg.sender == deployer, \\\"ERR: WRONG_DEPLOYER\\\");\\n        _;\\n    } \\n\\n    function depositETH() external payable onlyDeployer {\\n        IVPoolETH(vPoolETH).deposit{value: msg.value}();\\n    }\\n\\n    function withdraw(uint256 _amount) external onlyDeployer returns(uint256) {\\n        IVPoolETH(vPoolETH).withdrawETH(_amount);\\n        uint256 ethBalance = address(this).balance;\\n        (bool success, ) = payable(deployer).call{value: ethBalance}(\\\"\\\");\\n        require(success, \\\"ERR: FAIL_SENDING_ETH\\\");\\n\\n        return ethBalance;\\n    }\\n\\n    function claimToDepositor(address _depositor) external onlyDeployer returns(uint256) {\\n        return _claim(_depositor);\\n    }\\n\\n    function claimToDeployer() external onlyDeployer returns(uint256) {\\n        return _claim(deployer);\\n    }\\n\\n    function _claim(address _address) private returns(uint256) {\\n        // VSP tokens\\n        IVPoolRewards(vPoolRewardsETH).claimReward(address(this));\\n\\n        uint256 vspBalance = IERC20(vspToken).balanceOf(address(this));\\n        IERC20(vspToken).transfer(\\n            _address,\\n            vspBalance\\n        );\\n\\n        return vspBalance;\\n    }\\n\\n    receive() external payable {}\\n}\\n\\n// MN bby \u00af\\\\_(\u30c4)_/\u00af\"\r\n    },\r\n    \"contracts/interfaces/IVesperFinance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IVPoolDAI {\\n    function deposit(uint256 _amount) external;\\n\\n    function withdraw(uint256 _shares) external;\\n\\n    function pricePerShare() external view returns (uint256);\\n}\\n\\n\\ninterface IVPoolETH {\\n    function deposit() external payable;\\n\\n    function withdrawETH(uint256 _shares) external;\\n\\n    function pricePerShare() external view returns (uint256);\\n}\\n\\n\\ninterface IVPoolRewards {\\n    function claimable(address _account) external view returns (\\n        address[] memory _rewardTokens,\\n        uint256[] memory _claimableAmounts\\n    );\\n\\n    function claimReward(address _account) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapConnector\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wethAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vPoolETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vPoolRewardsETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vspToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount1\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_swappedTo\",\"type\":\"address\"}],\"name\":\"ClaimAdditionalTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"}],\"name\":\"claimInETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"}],\"name\":\"claimInToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRaw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getCurrentDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPendingAdditionalTokenClaims\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_claimableAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapConnector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vPoolETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vPoolRewardsETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vspToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaETHAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeToken\",\"type\":\"address\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vaETHAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeToken\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "S1VesperFinanceETH", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000006bfe813169eeb685935952ec461792b57e5ecc7000000000000000000000000f46a58c9cf612bb9d37512e9495688b40d41a8e7000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d1c117319b3595fbc39b471ab1fd485629eb05f200000000000000000000000051eef73abf5d4ac5f41de131591ed82c27a7be3d0000000000000000000000001b40183efb4dd766f11bda7a7c3ad8982e998421", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}