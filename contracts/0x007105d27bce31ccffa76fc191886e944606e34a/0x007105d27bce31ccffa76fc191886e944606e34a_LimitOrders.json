{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/periphery/services/LimitOrders.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {Auth, Authority} from \\\"solmate/auth/Auth.sol\\\";\\nimport {TransferHelper} from \\\"src/lib/TransferHelper.sol\\\";\\nimport {FullMath} from \\\"src/lib/FullMath.sol\\\";\\nimport {IBondAggregator} from \\\"src/interfaces/IBondAggregator.sol\\\";\\nimport {IBondAuctioneer} from \\\"src/interfaces/IBondAuctioneer.sol\\\";\\nimport {IBondTeller} from \\\"src/interfaces/IBondTeller.sol\\\";\\n\\ncontract LimitOrders is Auth {\\n    using TransferHelper for ERC20;\\n    using FullMath for uint256;\\n\\n    /* ========== EVENTS ========== */\\n    event OrderExecuted(bytes32 digest);\\n    event OrderCancelled(bytes32 digest);\\n    event OrderReinstated(bytes32 digest);\\n\\n    /* ========== ERRORS ========== */\\n    error LimitOrders_NotAuthorized();\\n    error LimitOrders_OrderExpired(uint256 deadline);\\n    error LimitOrders_MarketClosed(uint256 marketId);\\n    error LimitOrders_AlreadyExecuted(bytes32 digest);\\n    error LimitOrders_OrderCancelled(bytes32 digest);\\n    error LimitOrders_InvalidUpdate();\\n    error LimitOrders_InvalidFee(uint256 fee, uint256 maxFee);\\n    error LimitOrders_InvalidSignature(bytes signature);\\n    error LimitOrders_InvalidParams();\\n    error LimitOrders_InvalidUser();\\n\\n    /* ========== STATE ========== */\\n\\n    struct Order {\\n        uint256 marketId;\\n        address recipient;\\n        address referrer;\\n        uint256 amount;\\n        uint256 minAmountOut;\\n        uint256 maxFee;\\n        uint256 submitted;\\n        uint256 deadline;\\n        address user;\\n    }\\n\\n    enum Status {\\n        Open,\\n        Executed,\\n        Cancelled\\n    }\\n\\n    IBondAggregator public immutable aggregator;\\n\\n    uint256 public chainId;\\n    bytes32 internal domainSeparator;\\n\\n    bytes32 internal constant ORDER_TYPEHASH =\\n        keccak256(\\n            \\\"Order(uint256 marketId,address recipient,address referrer,uint256 amount,uint256 minAmountOut,uint256 maxFee,uint256 submitted,uint256 deadline,address user)\\\"\\n        );\\n\\n    mapping(bytes32 => Status) public orderStatus;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(IBondAggregator aggregator_, Authority authority_) Auth(address(0), authority_) {\\n        aggregator = aggregator_;\\n        chainId = block.chainid;\\n        domainSeparator = computeDomainSeparator();\\n    }\\n\\n    /* ========== ORDER EXECUTION ========== */\\n\\n    function executeOrders(\\n        Order[] calldata orders_,\\n        bytes[] calldata signatures_,\\n        uint256[] calldata fees_\\n    ) external requiresAuth {\\n        uint256 len = orders_.length;\\n        if (len != fees_.length || len != signatures_.length) revert LimitOrders_InvalidParams();\\n\\n        for (uint256 i; i < len; ) {\\n            _executeOrder(orders_[i], signatures_[i], fees_[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function executeOrder(\\n        Order calldata order_,\\n        bytes calldata signature_,\\n        uint256 fee_\\n    ) external requiresAuth {\\n        _executeOrder(order_, signature_, fee_);\\n    }\\n\\n    function _executeOrder(\\n        Order calldata order_,\\n        bytes calldata signature_,\\n        uint256 fee_\\n    ) internal {\\n        // Validate order\\n        bytes32 digest = _validateOrder(order_, signature_);\\n\\n        // Validate that the order has not expired\\n        if (order_.deadline < block.timestamp) revert LimitOrders_OrderExpired(order_.deadline);\\n\\n        // Validate that the market is still active\\n        if (!aggregator.isLive(order_.marketId)) revert LimitOrders_MarketClosed(order_.marketId);\\n\\n        // Validate that the order has not already been executed\\n        // and that the user has not cancelled the order\\n        Status status = orderStatus[digest];\\n        if (status == Status.Executed) revert LimitOrders_AlreadyExecuted(digest);\\n        if (status == Status.Cancelled) revert LimitOrders_OrderCancelled(digest);\\n\\n        // Confirm that executor fee is within bounds and calculate amount minus fee\\n        if (fee_ > order_.maxFee) revert LimitOrders_InvalidFee(fee_, order_.maxFee);\\n        uint256 amount = order_.amount - fee_;\\n\\n        // Mark the order as executed\\n        orderStatus[digest] = Status.Executed;\\n\\n        // Get max amount accepted for market\\n        uint256 maxAccepted = aggregator.maxAmountAccepted(order_.marketId, order_.referrer);\\n\\n        // Set the amount for the purchase as the lesser of the order amount and the max accepted\\n        uint256 minAmountOut = order_.minAmountOut;\\n        if (amount > maxAccepted) {\\n            // If amount is too large, set to max accepted\\n            amount = maxAccepted;\\n\\n            // We need to convert the new amount to an equivalent payout amount\\n            // The minAmountOut represents the price the user is willing to pay per token\\n            // after the max fee is taken out.\\n            if (minAmountOut != 0) {\\n                uint256 scale = aggregator.marketScale(order_.marketId);\\n                uint256 maxPrice = (order_.amount - order_.maxFee).mulDiv(\\n                    scale,\\n                    order_.minAmountOut\\n                );\\n                minAmountOut = amount.mulDiv(scale, maxPrice);\\n            }\\n        }\\n\\n        // Transfer tokens from user to this contract for the purchase\\n        IBondAuctioneer auctioneer = aggregator.getAuctioneer(order_.marketId);\\n        (, , , ERC20 quoteToken, , ) = auctioneer.getMarketInfoForPurchase(order_.marketId);\\n        quoteToken.safeTransferFrom(order_.user, address(this), amount + fee_);\\n\\n        // Approve teller to spend token\\n        IBondTeller teller = auctioneer.getTeller();\\n        quoteToken.safeApprove(address(teller), amount);\\n\\n        // Execute purchase\\n        teller.purchase(order_.recipient, order_.referrer, order_.marketId, amount, minAmountOut);\\n\\n        // Transfer fee to executor\\n        quoteToken.safeTransfer(msg.sender, fee_);\\n\\n        // Emit event for off-chain service to pick up\\n        emit OrderExecuted(digest);\\n    }\\n\\n    function _validateOrder(\\n        Order calldata order_,\\n        bytes calldata signature_\\n    ) internal view returns (bytes32) {\\n        // Validate the user is not the zero address (must do this to avoid bypassing the signer check)\\n        // Although, transfers from the zero address would later fail in _executeOrder, so it may not be necessary\\n        if (order_.user == address(0)) revert LimitOrders_InvalidUser();\\n        if (signature_.length != 65) revert LimitOrders_InvalidSignature(signature_);\\n\\n        // Get order digest\\n        bytes32 digest = getDigest(order_);\\n\\n        // Validate signature\\n        bytes32 r = bytes32(signature_[0:32]);\\n        bytes32 s = bytes32(signature_[32:64]);\\n        uint8 v = uint8(signature_[64]);\\n        address signer = ecrecover(digest, v, r, s);\\n\\n        if (signer != order_.user) revert LimitOrders_InvalidSignature(signature_);\\n\\n        return digest;\\n    }\\n\\n    function getDigest(Order calldata order_) public view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    hex\\\"1901\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(\\n                        abi.encode(\\n                            ORDER_TYPEHASH,\\n                            order_.marketId,\\n                            order_.recipient,\\n                            order_.referrer,\\n                            order_.amount,\\n                            order_.minAmountOut,\\n                            order_.maxFee,\\n                            order_.submitted,\\n                            order_.deadline,\\n                            order_.user\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    /* ========== USER FUNCTIONS ========== */\\n\\n    function cancelOrder(Order calldata order_) external {\\n        // Validate that the sender is the order \\\"user\\\"\\n        if (msg.sender != order_.user) revert LimitOrders_NotAuthorized();\\n\\n        // Validate that the order has not expired (no need to cancel if so)\\n        if (order_.deadline < block.timestamp) revert LimitOrders_OrderExpired(order_.deadline);\\n\\n        // Get order digest\\n        bytes32 digest = getDigest(order_);\\n\\n        // Validate that the order has not already been executed\\n        // and that the user has not cancelled the order\\n        if (orderStatus[digest] != Status.Open) revert LimitOrders_InvalidUpdate();\\n\\n        // Set order status to cancelled\\n        orderStatus[digest] = Status.Cancelled;\\n\\n        // Emit event to pick up with off-chain service\\n        emit OrderCancelled(digest);\\n    }\\n\\n    function reinstateOrder(Order calldata order_) external {\\n        // Validate that the sender is the order \\\"user\\\"\\n        if (msg.sender != order_.user) revert LimitOrders_NotAuthorized();\\n\\n        // Validate that the order has not expired\\n        if (order_.deadline < block.timestamp) revert LimitOrders_OrderExpired(order_.deadline);\\n\\n        // Get order digest\\n        bytes32 digest = getDigest(order_);\\n\\n        // Validate that the order is currently cancelled\\n        if (orderStatus[digest] != Status.Cancelled) revert LimitOrders_InvalidUpdate();\\n\\n        // Set the order status as open\\n        orderStatus[digest] = Status.Open;\\n    }\\n\\n    /* ========== DOMAIN SEPARATOR ========== */\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == chainId ? domainSeparator : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\n                        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                    ),\\n                    keccak256(\\\"Bond Protocol Limit Orders\\\"),\\n                    keccak256(\\\"v1.0.0\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    function updateDomainSeparator() external {\\n        require(block.chainid != chainId, \\\"DOMAIN_SEPARATOR_ALREADY_UPDATED\\\");\\n\\n        chainId = block.chainid;\\n\\n        domainSeparator = computeDomainSeparator();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/lib/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ERC20 and ETH transfer library that safely handles missing return values.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\n/// @author Taken from Solmate.\\nlibrary TransferHelper {\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(ERC20.transferFrom.selector, from, to, amount)\\n        );\\n\\n        require(\\n            success &&\\n                (data.length == 0 || abi.decode(data, (bool))) &&\\n                address(token).code.length > 0,\\n            \\\"TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(ERC20.transfer.selector, to, amount)\\n        );\\n\\n        require(\\n            success &&\\n                (data.length == 0 || abi.decode(data, (bool))) &&\\n                address(token).code.length > 0,\\n            \\\"TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(ERC20.approve.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    // function safeTransferETH(address to, uint256 amount) internal {\\n    //     (bool success, ) = to.call{value: amount}(new bytes(0));\\n\\n    //     require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    // }\\n}\\n\"\r\n    },\r\n    \"src/lib/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        unchecked {\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {IBondAuctioneer} from \\\"../interfaces/IBondAuctioneer.sol\\\";\\nimport {IBondTeller} from \\\"../interfaces/IBondTeller.sol\\\";\\n\\ninterface IBondAggregator {\\n    /// @notice             Register a auctioneer with the aggregator\\n    /// @notice             Only Guardian\\n    /// @param auctioneer_  Address of the Auctioneer to register\\n    /// @dev                A auctioneer must be registered with an aggregator to create markets\\n    function registerAuctioneer(IBondAuctioneer auctioneer_) external;\\n\\n    /// @notice             Register a new market with the aggregator\\n    /// @notice             Only registered depositories\\n    /// @param payoutToken_ Token to be paid out by the market\\n    /// @param quoteToken_  Token to be accepted by the market\\n    /// @param marketId     ID of the market being created\\n    function registerMarket(ERC20 payoutToken_, ERC20 quoteToken_)\\n        external\\n        returns (uint256 marketId);\\n\\n    /// @notice     Get the auctioneer for the provided market ID\\n    /// @param id_  ID of Market\\n    function getAuctioneer(uint256 id_) external view returns (IBondAuctioneer);\\n\\n    /// @notice             Calculate current market price of payout token in quote tokens\\n    /// @dev                Accounts for debt and control variable decay since last deposit (vs _marketPrice())\\n    /// @param id_          ID of market\\n    /// @return             Price for market (see the specific auctioneer for units)\\n    //\\n    // if price is below minimum price, minimum price is returned\\n    // this is enforced on deposits by manipulating total debt (see _decay())\\n    function marketPrice(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Scale value to use when converting between quote token and payout token amounts with marketPrice()\\n    /// @param id_          ID of market\\n    /// @return             Scaling factor for market in configured decimals\\n    function marketScale(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Payout due for amount of quote tokens\\n    /// @dev                Accounts for debt and control variable decay so it is up to date\\n    /// @param amount_      Amount of quote tokens to spend\\n    /// @param id_          ID of market\\n    /// @param referrer_    Address of referrer, used to get fees to calculate accurate payout amount.\\n    ///                     Inputting the zero address will take into account just the protocol fee.\\n    /// @return             amount of payout tokens to be paid\\n    function payoutFor(\\n        uint256 amount_,\\n        uint256 id_,\\n        address referrer_\\n    ) external view returns (uint256);\\n\\n    /// @notice             Returns maximum amount of quote token accepted by the market\\n    /// @param id_          ID of market\\n    /// @param referrer_    Address of referrer, used to get fees to calculate accurate payout amount.\\n    ///                     Inputting the zero address will take into account just the protocol fee.\\n    function maxAmountAccepted(uint256 id_, address referrer_) external view returns (uint256);\\n\\n    /// @notice             Does market send payout immediately\\n    /// @param id_          Market ID to search for\\n    function isInstantSwap(uint256 id_) external view returns (bool);\\n\\n    /// @notice             Is a given market accepting deposits\\n    /// @param id_          ID of market\\n    function isLive(uint256 id_) external view returns (bool);\\n\\n    /// @notice             Returns array of active market IDs within a range\\n    /// @dev                Should be used if length exceeds max to query entire array\\n    function liveMarketsBetween(uint256 firstIndex_, uint256 lastIndex_)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /// @notice             Returns an array of all active market IDs for a given quote token\\n    /// @param token_       Address of token to query by\\n    /// @param isPayout_    If true, search by payout token, else search for quote token\\n    function liveMarketsFor(address token_, bool isPayout_)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /// @notice             Returns an array of all active market IDs for a given owner\\n    /// @param owner_       Address of owner to query by\\n    /// @param firstIndex_  Market ID to start at\\n    /// @param lastIndex_   Market ID to end at (non-inclusive)\\n    function liveMarketsBy(\\n        address owner_,\\n        uint256 firstIndex_,\\n        uint256 lastIndex_\\n    ) external view returns (uint256[] memory);\\n\\n    /// @notice             Returns an array of all active market IDs for a given payout and quote token\\n    /// @param payout_      Address of payout token\\n    /// @param quote_       Address of quote token\\n    function marketsFor(address payout_, address quote_) external view returns (uint256[] memory);\\n\\n    /// @notice                 Returns the market ID with the highest current payoutToken payout for depositing quoteToken\\n    /// @param payout_          Address of payout token\\n    /// @param quote_           Address of quote token\\n    /// @param amountIn_        Amount of quote tokens to deposit\\n    /// @param minAmountOut_    Minimum amount of payout tokens to receive as payout\\n    /// @param maxExpiry_       Latest acceptable vesting timestamp for bond\\n    ///                         Inputting the zero address will take into account just the protocol fee.\\n    function findMarketFor(\\n        address payout_,\\n        address quote_,\\n        uint256 amountIn_,\\n        uint256 minAmountOut_,\\n        uint256 maxExpiry_\\n    ) external view returns (uint256 id);\\n\\n    /// @notice             Returns the Teller that services the market ID\\n    function getTeller(uint256 id_) external view returns (IBondTeller);\\n\\n    /// @notice             Returns current capacity of a market\\n    function currentCapacity(uint256 id_) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondAuctioneer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {IBondTeller} from \\\"../interfaces/IBondTeller.sol\\\";\\nimport {IBondAggregator} from \\\"../interfaces/IBondAggregator.sol\\\";\\n\\ninterface IBondAuctioneer {\\n    /// @notice                 Creates a new bond market\\n    /// @param params_          Configuration data needed for market creation, encoded in a bytes array\\n    /// @dev                    See specific auctioneer implementations for details on encoding the parameters.\\n    /// @return id              ID of new bond market\\n    function createMarket(bytes memory params_) external returns (uint256);\\n\\n    /// @notice                 Disable existing bond market\\n    /// @notice                 Must be market owner\\n    /// @param id_              ID of market to close\\n    function closeMarket(uint256 id_) external;\\n\\n    /// @notice                 Exchange quote tokens for a bond in a specified market\\n    /// @notice                 Must be teller\\n    /// @param id_              ID of the Market the bond is being purchased from\\n    /// @param amount_          Amount to deposit in exchange for bond (after fee has been deducted)\\n    /// @param minAmountOut_    Minimum acceptable amount of bond to receive. Prevents frontrunning\\n    /// @return payout          Amount of payout token to be received from the bond\\n    function purchaseBond(\\n        uint256 id_,\\n        uint256 amount_,\\n        uint256 minAmountOut_\\n    ) external returns (uint256 payout);\\n\\n    /// @notice                         Set market intervals to different values than the defaults\\n    /// @notice                         Must be market owner\\n    /// @dev                            Changing the intervals could cause markets to behave in unexpected way\\n    ///                                 tuneInterval should be greater than tuneAdjustmentDelay\\n    /// @param id_                      Market ID\\n    /// @param intervals_               Array of intervals (3)\\n    ///                                 1. Tune interval - Frequency of tuning\\n    ///                                 2. Tune adjustment delay - Time to implement downward tuning adjustments\\n    ///                                 3. Debt decay interval - Interval over which debt should decay completely\\n    function setIntervals(uint256 id_, uint32[3] calldata intervals_) external;\\n\\n    /// @notice                      Designate a new owner of a market\\n    /// @notice                      Must be market owner\\n    /// @dev                         Doesn't change permissions until newOwner calls pullOwnership\\n    /// @param id_                   Market ID\\n    /// @param newOwner_             New address to give ownership to\\n    function pushOwnership(uint256 id_, address newOwner_) external;\\n\\n    /// @notice                      Accept ownership of a market\\n    /// @notice                      Must be market newOwner\\n    /// @dev                         The existing owner must call pushOwnership prior to the newOwner calling this function\\n    /// @param id_                   Market ID\\n    function pullOwnership(uint256 id_) external;\\n\\n    /// @notice             Set the auctioneer defaults\\n    /// @notice             Must be policy\\n    /// @param defaults_    Array of default values\\n    ///                     1. Tune interval - amount of time between tuning adjustments\\n    ///                     2. Tune adjustment delay - amount of time to apply downward tuning adjustments\\n    ///                     3. Minimum debt decay interval - minimum amount of time to let debt decay to zero\\n    ///                     4. Minimum deposit interval - minimum amount of time to wait between deposits\\n    ///                     5. Minimum market duration - minimum amount of time a market can be created for\\n    ///                     6. Minimum debt buffer - the minimum amount of debt over the initial debt to trigger a market shutdown\\n    /// @dev                The defaults set here are important to avoid edge cases in market behavior, e.g. a very short market reacts doesn't tune well\\n    /// @dev                Only applies to new markets that are created after the change\\n    function setDefaults(uint32[6] memory defaults_) external;\\n\\n    /// @notice             Change the status of the auctioneer to allow creation of new markets\\n    /// @dev                Setting to false and allowing active markets to end will sunset the auctioneer\\n    /// @param status_      Allow market creation (true) : Disallow market creation (false)\\n    function setAllowNewMarkets(bool status_) external;\\n\\n    /// @notice             Change whether a market creator is allowed to use a callback address in their markets or not\\n    /// @notice             Must be guardian\\n    /// @dev                Callback is believed to be safe, but a whitelist is implemented to prevent abuse\\n    /// @param creator_     Address of market creator\\n    /// @param status_      Allow callback (true) : Disallow callback (false)\\n    function setCallbackAuthStatus(address creator_, bool status_) external;\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    /// @notice                 Provides information for the Teller to execute purchases on a Market\\n    /// @param id_              Market ID\\n    /// @return owner           Address of the market owner (tokens transferred from this address if no callback)\\n    /// @return callbackAddr    Address of the callback contract to get tokens for payouts\\n    /// @return payoutToken     Payout Token (token paid out) for the Market\\n    /// @return quoteToken      Quote Token (token received) for the Market\\n    /// @return vesting         Timestamp or duration for vesting, implementation-dependent\\n    /// @return maxPayout       Maximum amount of payout tokens you can purchase in one transaction\\n    function getMarketInfoForPurchase(uint256 id_)\\n        external\\n        view\\n        returns (\\n            address owner,\\n            address callbackAddr,\\n            ERC20 payoutToken,\\n            ERC20 quoteToken,\\n            uint48 vesting,\\n            uint256 maxPayout\\n        );\\n\\n    /// @notice             Calculate current market price of payout token in quote tokens\\n    /// @param id_          ID of market\\n    /// @return             Price for market in configured decimals\\n    //\\n    // if price is below minimum price, minimum price is returned\\n    function marketPrice(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Scale value to use when converting between quote token and payout token amounts with marketPrice()\\n    /// @param id_          ID of market\\n    /// @return             Scaling factor for market in configured decimals\\n    function marketScale(uint256 id_) external view returns (uint256);\\n\\n    /// @notice             Payout due for amount of quote tokens\\n    /// @dev                Accounts for debt and control variable decay so it is up to date\\n    /// @param amount_      Amount of quote tokens to spend\\n    /// @param id_          ID of market\\n    /// @param referrer_    Address of referrer, used to get fees to calculate accurate payout amount.\\n    ///                     Inputting the zero address will take into account just the protocol fee.\\n    /// @return             amount of payout tokens to be paid\\n    function payoutFor(\\n        uint256 amount_,\\n        uint256 id_,\\n        address referrer_\\n    ) external view returns (uint256);\\n\\n    /// @notice             Returns maximum amount of quote token accepted by the market\\n    /// @param id_          ID of market\\n    /// @param referrer_    Address of referrer, used to get fees to calculate accurate payout amount.\\n    ///                     Inputting the zero address will take into account just the protocol fee.\\n    function maxAmountAccepted(uint256 id_, address referrer_) external view returns (uint256);\\n\\n    /// @notice             Does market send payout immediately\\n    /// @param id_          Market ID to search for\\n    function isInstantSwap(uint256 id_) external view returns (bool);\\n\\n    /// @notice             Is a given market accepting deposits\\n    /// @param id_          ID of market\\n    function isLive(uint256 id_) external view returns (bool);\\n\\n    /// @notice             Returns the address of the market owner\\n    /// @param id_          ID of market\\n    function ownerOf(uint256 id_) external view returns (address);\\n\\n    /// @notice             Returns the Teller that services the Auctioneer\\n    function getTeller() external view returns (IBondTeller);\\n\\n    /// @notice             Returns the Aggregator that services the Auctioneer\\n    function getAggregator() external view returns (IBondAggregator);\\n\\n    /// @notice             Returns current capacity of a market\\n    function currentCapacity(uint256 id_) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBondTeller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\ninterface IBondTeller {\\n    /// @notice                 Exchange quote tokens for a bond in a specified market\\n    /// @param recipient_       Address of recipient of bond. Allows deposits for other addresses\\n    /// @param referrer_        Address of referrer who will receive referral fee. For frontends to fill.\\n    ///                         Direct calls can use the zero address for no referrer fee.\\n    /// @param id_              ID of the Market the bond is being purchased from\\n    /// @param amount_          Amount to deposit in exchange for bond\\n    /// @param minAmountOut_    Minimum acceptable amount of bond to receive. Prevents frontrunning\\n    /// @return                 Amount of payout token to be received from the bond\\n    /// @return                 Timestamp at which the bond token can be redeemed for the underlying token\\n    function purchase(\\n        address recipient_,\\n        address referrer_,\\n        uint256 id_,\\n        uint256 amount_,\\n        uint256 minAmountOut_\\n    ) external returns (uint256, uint48);\\n\\n    /// @notice          Get current fee charged by the teller based on the combined protocol and referrer fee\\n    /// @param referrer_ Address of the referrer\\n    /// @return          Fee in basis points (3 decimal places)\\n    function getFee(address referrer_) external view returns (uint48);\\n\\n    /// @notice         Set protocol fee\\n    /// @notice         Must be guardian\\n    /// @param fee_     Protocol fee in basis points (3 decimal places)\\n    function setProtocolFee(uint48 fee_) external;\\n\\n    /// @notice          Set the discount for creating bond tokens from the base protocol fee\\n    /// @dev             The discount is subtracted from the protocol fee to determine the fee\\n    ///                  when using create() to mint bond tokens without using an Auctioneer\\n    /// @param discount_ Create Fee Discount in basis points (3 decimal places)\\n    function setCreateFeeDiscount(uint48 discount_) external;\\n\\n    /// @notice         Set your fee as a referrer to the protocol\\n    /// @notice         Fee is set for sending address\\n    /// @param fee_     Referrer fee in basis points (3 decimal places)\\n    function setReferrerFee(uint48 fee_) external;\\n\\n    /// @notice         Claim fees accrued by sender in the input tokens and sends them to the provided address\\n    /// @param tokens_  Array of tokens to claim fees for\\n    /// @param to_      Address to send fees to\\n    function claimFees(ERC20[] memory tokens_, address to_) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"clones/=lib/clones-with-immutable-args/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solidity-code-metrics/=node_modules/solidity-code-metrics/\",\r\n      \"clones-with-immutable-args/=lib/clones-with-immutable-args/src/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"weird-erc20/=lib/solmate/lib/weird-erc20/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBondAggregator\",\"name\":\"aggregator_\",\"type\":\"address\"},{\"internalType\":\"contract Authority\",\"name\":\"authority_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"}],\"name\":\"LimitOrders_AlreadyExecuted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"}],\"name\":\"LimitOrders_InvalidFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrders_InvalidParams\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"LimitOrders_InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrders_InvalidUpdate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrders_InvalidUser\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"LimitOrders_MarketClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LimitOrders_NotAuthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"}],\"name\":\"LimitOrders_OrderCancelled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"LimitOrders_OrderExpired\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"}],\"name\":\"OrderExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"}],\"name\":\"OrderReinstated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aggregator\",\"outputs\":[{\"internalType\":\"contract IBondAggregator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submitted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"internalType\":\"struct LimitOrders.Order\",\"name\":\"order_\",\"type\":\"tuple\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submitted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"internalType\":\"struct LimitOrders.Order\",\"name\":\"order_\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"}],\"name\":\"executeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submitted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"internalType\":\"struct LimitOrders.Order[]\",\"name\":\"orders_\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures_\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"fees_\",\"type\":\"uint256[]\"}],\"name\":\"executeOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submitted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"internalType\":\"struct LimitOrders.Order\",\"name\":\"order_\",\"type\":\"tuple\"}],\"name\":\"getDigest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderStatus\",\"outputs\":[{\"internalType\":\"enum LimitOrders.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submitted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"internalType\":\"struct LimitOrders.Order\",\"name\":\"order_\",\"type\":\"tuple\"}],\"name\":\"reinstateOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateDomainSeparator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LimitOrders", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "000000000000000000000000007a66a2a13415db3613c1a4dd1c942a285902d1000000000000000000000000007a2f0a16bd0874ca2e1fffafc2d6b0b876aa8e", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}