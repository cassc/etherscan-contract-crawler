{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"VaultSafetyMode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"SafeERC20.sol\\\";\\nimport \\\"ERC20.sol\\\";\\nimport \\\"EnumerableSet.sol\\\";\\n\\nimport \\\"Governable.sol\\\";\\nimport \\\"DataTypes.sol\\\";\\nimport \\\"IGyroConfig.sol\\\";\\nimport \\\"IAssetRegistry.sol\\\";\\nimport \\\"IGyroVault.sol\\\";\\nimport \\\"IVault.sol\\\";\\nimport \\\"Errors.sol\\\";\\nimport \\\"ISafetyCheck.sol\\\";\\nimport \\\"IVaultRegistry.sol\\\";\\nimport \\\"FixedPoint.sol\\\";\\nimport \\\"Flow.sol\\\";\\nimport \\\"Errors.sol\\\";\\nimport \\\"StringExtensions.sol\\\";\\nimport \\\"ConfigHelpers.sol\\\";\\n\\ncontract VaultSafetyMode is ISafetyCheck, Governable {\\n    using FixedPoint for uint256;\\n    using StringExtensions for string;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using ConfigHelpers for IGyroConfig;\\n\\n    EnumerableSet.AddressSet internal whitelist;\\n\\n    /// @notice Emitted when entering safety mode\\n    event SafetyStatus(string err);\\n\\n    /// @notice Emitted when a whitelisted address protects a vault\\n    event OracleGuardianActivated(\\n        address vaultAddress,\\n        uint256 durationOfProtectionInBlocks,\\n        bool inFlows\\n    );\\n\\n    event AddedToWhitelist(address indexed account);\\n    event RemovedFromWhitelist(address indexed account);\\n\\n    struct FlowResult {\\n        uint256 newFlow;\\n        bool safetyModeActivated;\\n    }\\n\\n    mapping(address => DataTypes.FlowData) public persistedFlowData;\\n\\n    IGyroConfig public immutable gyroConfig;\\n\\n    uint256 public constant THRESHOLD_BUFFER = 8e17;\\n\\n    constructor(address governor, address _gyroConfig) Governable(governor) {\\n        gyroConfig = IGyroConfig(_gyroConfig);\\n    }\\n\\n    modifier rootSafetyCheckOnly() {\\n        require(msg.sender == address(gyroConfig.getRootSafetyCheck()), Errors.NOT_AUTHORIZED);\\n        _;\\n    }\\n\\n    /// @notice Checks whether a mint operation is safe\\n    /// @return err empty string if it is safe, otherwise the reason why it is not safe\\n    function isMintSafe(DataTypes.Order memory order) external view returns (string memory err) {\\n        if (order.mint) {\\n            (err, ) = _checkFlows(order);\\n            if (err.equals(Errors.OPERATION_SUCCEEDS_BUT_SAFETY_MODE_ACTIVATED)) {\\n                err = \\\"\\\";\\n            }\\n        } else {\\n            err = Errors.INVALID_ARGUMENT;\\n        }\\n    }\\n\\n    /// @inheritdoc ISafetyCheck\\n    function checkAndPersistMint(DataTypes.Order memory order) external rootSafetyCheckOnly {\\n        require(order.mint, Errors.INVALID_ARGUMENT);\\n        (string memory err, FlowResult[] memory result) = _checkFlows(order);\\n\\n        if (bytes(err).length > 0) {\\n            if (err.equals(Errors.OPERATION_SUCCEEDS_BUT_SAFETY_MODE_ACTIVATED)) {\\n                emit SafetyStatus(err);\\n            } else {\\n                revert(err);\\n            }\\n        }\\n\\n        _updateFlows(order, result);\\n    }\\n\\n    /// @notice Checks whether a redeem operation is safe\\n    /// @return err empty string if it is safe, otherwise the reason why it is not safe\\n    function isRedeemSafe(DataTypes.Order memory order) external view returns (string memory err) {\\n        if (!order.mint) {\\n            (err, ) = _checkFlows(order);\\n            if (err.equals(Errors.OPERATION_SUCCEEDS_BUT_SAFETY_MODE_ACTIVATED)) {\\n                err = \\\"\\\";\\n            }\\n        } else {\\n            err = Errors.INVALID_ARGUMENT;\\n        }\\n    }\\n\\n    /// @notice Checks whether a redeem operation is safe\\n    /// This is only called when an actual redeem is performed\\n    /// The implementation should store any relevant information for the redeem\\n    function checkAndPersistRedeem(DataTypes.Order memory order) external rootSafetyCheckOnly {\\n        require(!order.mint, Errors.INVALID_ARGUMENT);\\n        (string memory err, FlowResult[] memory result) = _checkFlows(order);\\n\\n        if (bytes(err).length > 0) {\\n            if (err.equals(Errors.OPERATION_SUCCEEDS_BUT_SAFETY_MODE_ACTIVATED)) {\\n                emit SafetyStatus(err);\\n            } else {\\n                revert(err);\\n            }\\n        }\\n\\n        _updateFlows(order, result);\\n    }\\n\\n    function getWhitelist() external view returns (address[] memory) {\\n        return whitelist.values();\\n    }\\n\\n    function addAddressToWhitelist(address _addressToAdd) external governanceOnly {\\n        whitelist.add(_addressToAdd);\\n        emit AddedToWhitelist(_addressToAdd);\\n    }\\n\\n    function removeAddressFromWhitelist(address _addressToRemove) external governanceOnly {\\n        whitelist.remove(_addressToRemove);\\n        emit RemovedFromWhitelist(_addressToRemove);\\n    }\\n\\n    modifier isWhitelisted(address _address) {\\n        require(whitelist.contains(_address), Errors.NOT_AUTHORIZED);\\n        _;\\n    }\\n\\n    function activateOracleGuardian(DataTypes.GuardedVaults memory vaultToProtect, uint256 blocks)\\n        external\\n        isWhitelisted(msg.sender)\\n    {\\n        _activateOracleGuardian(vaultToProtect, blocks);\\n    }\\n\\n    function pauseProtocol(bool depositsOnly) external isWhitelisted(msg.sender) {\\n        IVaultRegistry vaultRegistry = gyroConfig.getVaultRegistry();\\n        address[] memory vaults = vaultRegistry.listVaults();\\n        DataTypes.Direction direction = depositsOnly\\n            ? DataTypes.Direction.In\\n            : DataTypes.Direction.Both;\\n        uint256 blocksToActivate = gyroConfig.getUint(ConfigKeys.SAFETY_BLOCKS_GUARDIAN);\\n        for (uint256 i = 0; i < vaults.length; i++) {\\n            DataTypes.GuardedVaults memory vaultToProtect = DataTypes.GuardedVaults(\\n                vaults[i],\\n                direction\\n            );\\n            _activateOracleGuardian(vaultToProtect, blocksToActivate);\\n        }\\n    }\\n\\n    function getAllPersistedFlowData() external view returns (DataTypes.FlowData[] memory) {\\n        IVaultRegistry vaultRegistry = gyroConfig.getVaultRegistry();\\n        address[] memory vaults = vaultRegistry.listVaults();\\n        DataTypes.FlowData[] memory allFlowData = new DataTypes.FlowData[](vaults.length);\\n        for (uint256 i = 0; i < vaults.length; i++) {\\n            allFlowData[i] = persistedFlowData[vaults[i]];\\n        }\\n        return allFlowData;\\n    }\\n\\n    function _checkFlows(DataTypes.Order memory order)\\n        internal\\n        view\\n        returns (string memory err, FlowResult[] memory result)\\n    {\\n        result = new FlowResult[](order.vaultsWithAmount.length);\\n\\n        for (uint256 i; i < order.vaultsWithAmount.length; i++) {\\n            uint256 amount = order.vaultsWithAmount[i].amount;\\n            DataTypes.VaultInfo memory vault = order.vaultsWithAmount[i].vaultInfo;\\n            DataTypes.FlowData storage flowData = persistedFlowData[vault.vault];\\n            DataTypes.DirectionalFlowData memory directionalData;\\n            directionalData = order.mint ? flowData.inFlow : flowData.outFlow;\\n\\n            if (amount > 0 && block.number <= directionalData.lastSafetyBlock) {\\n                err = Errors.SAFETY_MODE_ACTIVATED;\\n                break;\\n            }\\n\\n            uint256 shortFlowThreshold = vault.persistedMetadata.shortFlowThreshold;\\n            uint256 newFlow = amount +\\n                Flow.updateFlow(\\n                    directionalData.shortFlow,\\n                    block.number,\\n                    directionalData.lastSeenBlock,\\n                    vault.persistedMetadata.shortFlowMemory\\n                );\\n\\n            if (amount > 0 && newFlow > shortFlowThreshold) {\\n                err = Errors.VAULT_FLOW_TOO_HIGH;\\n                break;\\n            }\\n\\n            bool activateSafetyMode = newFlow > THRESHOLD_BUFFER.mulDown(shortFlowThreshold);\\n            if (activateSafetyMode) {\\n                err = Errors.OPERATION_SUCCEEDS_BUT_SAFETY_MODE_ACTIVATED;\\n            }\\n\\n            result[i] = FlowResult(newFlow, activateSafetyMode);\\n        }\\n    }\\n\\n    function _updateFlows(DataTypes.Order memory order, FlowResult[] memory result) internal {\\n        for (uint256 i; i < order.vaultsWithAmount.length; i++) {\\n            DataTypes.VaultInfo memory vault = order.vaultsWithAmount[i].vaultInfo;\\n            DataTypes.FlowData storage flowData = persistedFlowData[vault.vault];\\n            DataTypes.DirectionalFlowData storage directionalData;\\n            if (order.mint) {\\n                directionalData = flowData.inFlow;\\n            } else {\\n                directionalData = flowData.outFlow;\\n            }\\n            directionalData.lastSeenBlock = uint64(block.number);\\n            directionalData.shortFlow = uint128(result[i].newFlow);\\n            if (result[i].safetyModeActivated) {\\n                directionalData.lastSafetyBlock = uint64(\\n                    block.number + gyroConfig.getUint(ConfigKeys.SAFETY_BLOCKS_AUTOMATIC)\\n                );\\n            }\\n        }\\n    }\\n\\n    function _activateOracleGuardian(DataTypes.GuardedVaults memory vaultToProtect, uint256 blocks)\\n        internal\\n    {\\n        require(\\n            blocks <= gyroConfig.getUint(ConfigKeys.SAFETY_BLOCKS_GUARDIAN),\\n            Errors.ORACLE_GUARDIAN_TIME_LIMIT\\n        );\\n\\n        uint64 targetBlock = uint64(block.number + blocks);\\n        if (\\n            vaultToProtect.direction == DataTypes.Direction.In ||\\n            vaultToProtect.direction == DataTypes.Direction.Both\\n        ) {\\n            persistedFlowData[vaultToProtect.vaultAddress].inFlow.lastSafetyBlock = targetBlock;\\n            emit OracleGuardianActivated(vaultToProtect.vaultAddress, blocks, true);\\n        }\\n        if (\\n            vaultToProtect.direction == DataTypes.Direction.Out ||\\n            vaultToProtect.direction == DataTypes.Direction.Both\\n        ) {\\n            persistedFlowData[vaultToProtect.vaultAddress].outFlow.lastSafetyBlock = targetBlock;\\n            emit OracleGuardianActivated(vaultToProtect.vaultAddress, blocks, false);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"draft-IERC20Permit.sol\\\";\\nimport \\\"Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"IERC20Metadata.sol\\\";\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"GovernableBase.sol\\\";\\n\\ncontract Governable is GovernableBase {\\n    constructor(address _governor) {\\n        governor = _governor;\\n        emit GovernorChanged(address(0), _governor);\\n    }\\n}\\n\"\r\n    },\r\n    \"GovernableBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"Errors.sol\\\";\\nimport \\\"IGovernable.sol\\\";\\n\\ncontract GovernableBase is IGovernable {\\n    address public override governor;\\n    address public override pendingGovernor;\\n\\n    modifier governanceOnly() {\\n        require(msg.sender == governor, Errors.NOT_AUTHORIZED);\\n        _;\\n    }\\n\\n    /// @inheritdoc IGovernable\\n    function changeGovernor(address newGovernor) external override governanceOnly {\\n        require(address(newGovernor) != address(0), Errors.INVALID_ARGUMENT);\\n        pendingGovernor = newGovernor;\\n        emit GovernorChangeRequested(newGovernor);\\n    }\\n\\n    /// @inheritdoc IGovernable\\n    function acceptGovernance() external override {\\n        require(msg.sender == pendingGovernor, Errors.NOT_AUTHORIZED);\\n        address currentGovernor = governor;\\n        governor = pendingGovernor;\\n        pendingGovernor = address(0);\\n        emit GovernorChanged(currentGovernor, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\n/// @notice Defines different errors emitted by Gyroscope contracts\\nlibrary Errors {\\n    string public constant TOKEN_AND_AMOUNTS_LENGTH_DIFFER = \\\"1\\\";\\n    string public constant TOO_MUCH_SLIPPAGE = \\\"2\\\";\\n    string public constant EXCHANGER_NOT_FOUND = \\\"3\\\";\\n    string public constant POOL_IDS_NOT_FOUND = \\\"4\\\";\\n    string public constant WOULD_UNBALANCE_GYROSCOPE = \\\"5\\\";\\n    string public constant VAULT_ALREADY_EXISTS = \\\"6\\\";\\n    string public constant VAULT_NOT_FOUND = \\\"7\\\";\\n\\n    string public constant X_OUT_OF_BOUNDS = \\\"20\\\";\\n    string public constant Y_OUT_OF_BOUNDS = \\\"21\\\";\\n    string public constant PRODUCT_OUT_OF_BOUNDS = \\\"22\\\";\\n    string public constant INVALID_EXPONENT = \\\"23\\\";\\n    string public constant OUT_OF_BOUNDS = \\\"24\\\";\\n    string public constant ZERO_DIVISION = \\\"25\\\";\\n    string public constant ADD_OVERFLOW = \\\"26\\\";\\n    string public constant SUB_OVERFLOW = \\\"27\\\";\\n    string public constant MUL_OVERFLOW = \\\"28\\\";\\n    string public constant DIV_INTERNAL = \\\"29\\\";\\n\\n    // User errors\\n    string public constant NOT_AUTHORIZED = \\\"30\\\";\\n    string public constant INVALID_ARGUMENT = \\\"31\\\";\\n    string public constant KEY_NOT_FOUND = \\\"32\\\";\\n    string public constant KEY_FROZEN = \\\"33\\\";\\n    string public constant INSUFFICIENT_BALANCE = \\\"34\\\";\\n    string public constant INVALID_ASSET = \\\"35\\\";\\n    string public constant FORBIDDEN_EXTERNAL_ACTION = \\\"35\\\";\\n\\n    // Oracle related errors\\n    string public constant ASSET_NOT_SUPPORTED = \\\"40\\\";\\n    string public constant STALE_PRICE = \\\"41\\\";\\n    string public constant NEGATIVE_PRICE = \\\"42\\\";\\n    string public constant INVALID_MESSAGE = \\\"43\\\";\\n    string public constant TOO_MUCH_VOLATILITY = \\\"44\\\";\\n    string public constant WETH_ADDRESS_NOT_FIRST = \\\"44\\\";\\n    string public constant ROOT_PRICE_NOT_GROUNDED = \\\"45\\\";\\n    string public constant NOT_ENOUGH_TWAPS = \\\"46\\\";\\n    string public constant ZERO_PRICE_TWAP = \\\"47\\\";\\n    string public constant INVALID_NUMBER_WEIGHTS = \\\"48\\\";\\n    string public constant NO_WETH_PRICE = \\\"49\\\";\\n\\n    //Vault safety check related errors\\n    string public constant A_VAULT_HAS_ALL_STABLECOINS_OFF_PEG = \\\"51\\\";\\n    string public constant NOT_SAFE_TO_MINT = \\\"52\\\";\\n    string public constant NOT_SAFE_TO_REDEEM = \\\"53\\\";\\n    string public constant AMOUNT_AND_PRICE_LENGTH_DIFFER = \\\"54\\\";\\n    string public constant TOKEN_PRICES_TOO_SMALL = \\\"55\\\";\\n    string public constant TRYING_TO_REDEEM_MORE_THAN_VAULT_CONTAINS = \\\"56\\\";\\n    string public constant CALLER_NOT_MOTHERBOARD = \\\"57\\\";\\n    string public constant CALLER_NOT_RESERVE_MANAGER = \\\"58\\\";\\n    string public constant VAULT_CANNOT_BE_REMOVED = \\\"59\\\";\\n\\n    string public constant VAULT_FLOW_TOO_HIGH = \\\"60\\\";\\n    string public constant OPERATION_SUCCEEDS_BUT_SAFETY_MODE_ACTIVATED = \\\"61\\\";\\n    string public constant ORACLE_GUARDIAN_TIME_LIMIT = \\\"62\\\";\\n    string public constant NOT_ENOUGH_FLOW_DATA = \\\"63\\\";\\n    string public constant SUPPLY_CAP_EXCEEDED = \\\"64\\\";\\n    string public constant SAFETY_MODE_ACTIVATED = \\\"65\\\";\\n\\n    // misc errors\\n    string public constant REDEEM_AMOUNT_BUG = \\\"100\\\";\\n    string public constant EXTERNAL_ACTION_FAILED = \\\"101\\\";\\n    string public constant TOKENS_NOT_SORTED = \\\"102\\\";\\n    string public constant NO_SHARES_MINTED = \\\"103\\\";\\n    string public constant TRYING_TO_REDEEM_MORE_THAN_SUPPLY = \\\"104\\\";\\n}\\n\"\r\n    },\r\n    \"IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\ninterface IGovernable {\\n    /// @notice Emmited when the governor is changed\\n    event GovernorChanged(address oldGovernor, address newGovernor);\\n\\n    /// @notice Emmited when the governor is change is requested\\n    event GovernorChangeRequested(address newGovernor);\\n\\n    /// @notice Returns the current governor\\n    function governor() external view returns (address);\\n\\n    /// @notice Returns the pending governor\\n    function pendingGovernor() external view returns (address);\\n\\n    /// @notice Changes the governor\\n    /// can only be called by the current governor\\n    function changeGovernor(address newGovernor) external;\\n\\n    /// @notice Called by the pending governor to approve the change\\n    function acceptGovernance() external;\\n}\\n\"\r\n    },\r\n    \"DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\n/// @notice Contains the data structures to express token routing\\nlibrary DataTypes {\\n    /// @notice Contains a token and the amount associated with it\\n    struct MonetaryAmount {\\n        address tokenAddress;\\n        uint256 amount;\\n    }\\n\\n    /// @notice Contains a token and the price associated with it\\n    /// @dev The price range is only relevant for stablecoins\\n    struct PricedToken {\\n        address tokenAddress;\\n        bool isStable;\\n        uint256 price;\\n        Range priceRange;\\n    }\\n\\n    /// @notice A route from/to a token to a vault\\n    /// This is used to determine in which vault the token should be deposited\\n    /// or from which vault it should be withdrawn\\n    struct TokenToVaultMapping {\\n        address inputToken;\\n        address vault;\\n    }\\n\\n    /// @notice Asset used to mint\\n    struct MintAsset {\\n        address inputToken;\\n        uint256 inputAmount;\\n        address destinationVault;\\n    }\\n\\n    /// @notice Asset to redeem\\n    struct RedeemAsset {\\n        address outputToken;\\n        uint256 minOutputAmount;\\n        uint256 valueRatio;\\n        address originVault;\\n    }\\n\\n    /// @notice Persisted metadata about the vault\\n    struct PersistedVaultMetadata {\\n        uint256 priceAtCalibration;\\n        uint256 weightAtCalibration;\\n        uint256 shortFlowMemory;\\n        uint256 shortFlowThreshold;\\n        uint64 weightTransitionDuration;\\n        uint64 weightAtPreviousCalibration;\\n        uint64 timeOfCalibration;\\n    }\\n\\n    /// @notice Directional (in or out) flow data for the vaults\\n    struct DirectionalFlowData {\\n        uint128 shortFlow;\\n        uint64 lastSafetyBlock;\\n        uint64 lastSeenBlock;\\n    }\\n\\n    /// @notice Bidirectional vault flow data\\n    struct FlowData {\\n        DirectionalFlowData inFlow;\\n        DirectionalFlowData outFlow;\\n    }\\n\\n    /// @notice Vault flow direction\\n    enum Direction {\\n        In,\\n        Out,\\n        Both\\n    }\\n\\n    /// @notice Vault address and direction for Oracle Guardian\\n    struct GuardedVaults {\\n        address vaultAddress;\\n        Direction direction;\\n    }\\n\\n    /// @notice Vault with metadata\\n    struct VaultInfo {\\n        address vault;\\n        uint8 decimals;\\n        address underlying;\\n        uint256 price;\\n        PersistedVaultMetadata persistedMetadata;\\n        uint256 reserveBalance;\\n        uint256 currentWeight;\\n        uint256 targetWeight;\\n        PricedToken[] pricedTokens;\\n    }\\n\\n    /// @notice Vault metadata\\n    struct VaultMetadata {\\n        address vault;\\n        uint256 targetWeight;\\n        uint256 currentWeight;\\n        uint256 resultingWeight;\\n        uint256 price;\\n        bool allStablecoinsOnPeg;\\n        bool atLeastOnePriceLargeEnough;\\n        bool vaultWithinEpsilon;\\n        PricedToken[] pricedTokens;\\n    }\\n\\n    /// @notice Metadata to contain vaults metadata\\n    struct Metadata {\\n        VaultMetadata[] vaultMetadata;\\n        bool allVaultsWithinEpsilon;\\n        bool allStablecoinsAllVaultsOnPeg;\\n        bool allVaultsUsingLargeEnoughPrices;\\n        bool mint;\\n    }\\n\\n    /// @notice Mint or redeem order struct\\n    struct Order {\\n        VaultWithAmount[] vaultsWithAmount;\\n        bool mint;\\n    }\\n\\n    /// @notice Vault info with associated amount for order operation\\n    struct VaultWithAmount {\\n        VaultInfo vaultInfo;\\n        uint256 amount;\\n    }\\n\\n    /// @notice state of the reserve (i.e., all the vaults)\\n    struct ReserveState {\\n        uint256 totalUSDValue;\\n        VaultInfo[] vaults;\\n    }\\n\\n    struct VaultConfiguration {\\n        address vaultAddress;\\n        DataTypes.PersistedVaultMetadata metadata;\\n    }\\n\\n    struct Range {\\n        uint256 floor;\\n        uint256 ceiling;\\n    }\\n\\n    /// @notice Action executed by calling `target` passing in `data`\\n    struct ExternalAction {\\n        address target;\\n        bytes data;\\n    }\\n}\\n\"\r\n    },\r\n    \"IGyroConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"IGovernable.sol\\\";\\n\\n/// @notice IGyroConfig stores the global configuration of the Gyroscope protocol\\ninterface IGyroConfig is IGovernable {\\n    /// @notice Event emitted every time a configuration is changed\\n    event ConfigChanged(bytes32 key, uint256 previousValue, uint256 newValue);\\n    event ConfigChanged(bytes32 key, address previousValue, address newValue);\\n\\n    /// @notice Event emitted when a configuration is unset\\n    event ConfigUnset(bytes32 key);\\n\\n    /// @notice Event emitted when a configuration is frozen\\n    event ConfigFrozen(bytes32 key);\\n\\n    /// @notice Returns a set of known configuration keys\\n    function listKeys() external view returns (bytes32[] memory);\\n\\n    /// @notice Returns true if the configuration has the given key\\n    function hasKey(bytes32 key) external view returns (bool);\\n\\n    /// @notice Returns the metadata associated with a particular config key\\n    function getConfigMeta(bytes32 key) external view returns (uint8, bool);\\n\\n    /// @notice Returns a uint256 value from the config\\n    function getUint(bytes32 key) external view returns (uint256);\\n\\n    /// @notice Returns a uint256 value from the config or `defaultValue` if it does not exist\\n    function getUint(bytes32 key, uint256 defaultValue) external view returns (uint256);\\n\\n    /// @notice Returns an address value from the config\\n    function getAddress(bytes32 key) external view returns (address);\\n\\n    /// @notice Returns an address value from the config or `defaultValue` if it does not exist\\n    function getAddress(bytes32 key, address defaultValue) external view returns (address);\\n\\n    /// @notice Set a uint256 config\\n    /// NOTE: We avoid overloading to avoid complications with some clients\\n    function setUint(bytes32 key, uint256 newValue) external;\\n\\n    /// @notice Set an address config\\n    function setAddress(bytes32 key, address newValue) external;\\n\\n    /// @notice Unset a key in the config\\n    function unset(bytes32 key) external;\\n\\n    /// @notice Freezes a key, making it impossible to update or unset\\n    function freeze(bytes32 key) external;\\n}\\n\"\r\n    },\r\n    \"IAssetRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"DataTypes.sol\\\";\\n\\ninterface IAssetRegistry {\\n    /// @notice Emitted when an asset address is updated\\n    /// If `previousAddress` was 0, it means that the asset was added to the registry\\n    event AssetAddressUpdated(\\n        string indexed assetName,\\n        address indexed previousAddress,\\n        address indexed newAddress\\n    );\\n\\n    /// @notice Emitted when an asset is set as being stable\\n    event StableAssetAdded(address indexed asset);\\n\\n    /// @notice Emitted when an asset is unset as being stable\\n    event StableAssetRemoved(address indexed asset);\\n\\n    /// @notice Emitted when an asset range is updated\\n    event AssetRangeUpdated(address indexed assetAddress, DataTypes.Range range);\\n\\n    /// @notice Returns the address associated with the given asset name\\n    /// e.g. \\\"DAI\\\" -> 0x6B175474E89094C44Da98b954EedeAC495271d0F\\n    function getAssetAddress(string calldata assetName) external view returns (address);\\n\\n    /// @notice Returns a list of names for the registered assets\\n    /// The asset are encoded as bytes32 (big endian) rather than string\\n    function getRegisteredAssetNames() external view returns (bytes32[] memory);\\n\\n    /// @notice Returns a list of addresses for the registered assets\\n    function getRegisteredAssetAddresses() external view returns (address[] memory);\\n\\n    /// @notice Returns a list of addresses contaning the stable assets\\n    function getStableAssets() external view returns (address[] memory);\\n\\n    /// @return true if the asset name is registered\\n    function isAssetNameRegistered(string calldata assetName) external view returns (bool);\\n\\n    /// @return true if the asset address is registered\\n    function isAssetAddressRegistered(address assetAddress) external view returns (bool);\\n\\n    /// @return the price range of the asset\\n    function getAssetRange(address asset) external view returns (DataTypes.Range memory);\\n\\n    /// @return true if the asset name is stable\\n    function isAssetStable(address assetAddress) external view returns (bool);\\n\\n    /// @notice Adds a stable asset to the registry\\n    /// The asset must already be registered in the registry\\n    function addStableAsset(address assetAddress) external;\\n\\n    /// @notice Sets the price range (floor and ceiling) for the given asset\\n    function setAssetRange(address asset, DataTypes.Range memory range) external;\\n\\n    /// @notice Removes a stable asset to the registry\\n    /// The asset must already be a stable asset\\n    function removeStableAsset(address asset) external;\\n\\n    /// @notice Set the `assetName` to the given `assetAddress`\\n    function setAssetAddress(string memory assetName, address assetAddress) external;\\n\\n    /// @notice Removes `assetName` from the registry\\n    function removeAsset(string memory assetName) external;\\n}\\n\"\r\n    },\r\n    \"IGyroVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"Vaults.sol\\\";\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"draft-IERC20PermitUpgradeable.sol\\\";\\n\\nimport \\\"IRateProvider.sol\\\";\\n\\n/// @notice A vault is one of the component of the reserve and has a one-to-one\\n/// mapping to an underlying pool (e.g. Balancer pool, Curve pool, Uniswap pool...)\\n/// It is itself an ERC-20 token that is used to track the ownership of the LP tokens\\n/// deposited in the vault\\n/// A vault can be associated with a strategy to generate yield on the deposited funds\\ninterface IGyroVault is IERC20MetadataUpgradeable, IERC20PermitUpgradeable, IRateProvider {\\n    /// @return The type of the vault\\n    function vaultType() external view returns (Vaults.Type);\\n\\n    /// @return The token associated with this vault\\n    /// This can be any type of token but will likely be an LP token in practice\\n    function underlying() external view returns (address);\\n\\n    /// @return The token associated with this vault\\n    /// In the case of an LP token, this will be the underlying tokens\\n    /// associated to it (e.g. [ETH, DAI] for a ETH/DAI pool LP token or [USDC] for aUSDC)\\n    /// In most cases, the tokens returned will not be LP tokens\\n    function getTokens() external view returns (IERC20[] memory);\\n\\n    /// @return The total amount of underlying tokens in the vault\\n    function totalUnderlying() external view returns (uint256);\\n\\n    /// @notice The same as getRate() from IRateProvider.\\n    /// @return The exchange rate between an underlying tokens and the token of this vault\\n    function exchangeRate() external view returns (uint256);\\n\\n    /// @notice Deposits `underlyingAmount` of underlying (usually LP) token supported\\n    /// and sends back the received vault tokens\\n    /// @param underlyingAmount the amount of underlying to deposit\\n    /// @return vaultTokenAmount the amount of vault token sent back\\n    function deposit(uint256 underlyingAmount, uint256 minVaultTokensOut)\\n        external\\n        returns (uint256 vaultTokenAmount);\\n\\n    /// @notice Simlar to `deposit(uint256 underlyingAmount)` but credits the tokens\\n    /// to `beneficiary` instead of `msg.sender`\\n    function depositFor(\\n        address beneficiary,\\n        uint256 underlyingAmount,\\n        uint256 minVaultTokensOut\\n    ) external returns (uint256 vaultTokenAmount);\\n\\n    /// @notice Dry-run version of deposit\\n    function dryDeposit(uint256 underlyingAmount, uint256 minVaultTokensOut)\\n        external\\n        view\\n        returns (uint256 vaultTokenAmount, string memory error);\\n\\n    /// @notice Withdraws `vaultTokenAmount` of LP token supported\\n    /// and burns the vault tokens\\n    /// @param vaultTokenAmount the amount of vault token to withdraw\\n    /// @return underlyingAmount the amount of LP token sent back\\n    function withdraw(uint256 vaultTokenAmount, uint256 minUnderlyingOut)\\n        external\\n        returns (uint256 underlyingAmount);\\n\\n    /// @notice Dry-run version of `withdraw`\\n    function dryWithdraw(uint256 vaultTokenAmount, uint256 minUnderlyingOut)\\n        external\\n        view\\n        returns (uint256 underlyingAmount, string memory error);\\n\\n    /// @return The address of the current strategy used by the vault\\n    function strategy() external view returns (address);\\n\\n    /// @notice Sets the address of the strategy to use for this vault\\n    /// This will be used through governance\\n    /// @param strategyAddress the address of the strategy contract that should follow the `IStrategy` interface\\n    function setStrategy(address strategyAddress) external;\\n\\n    /// @return the block at which the vault has been deployed\\n    function deployedAt() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"Vaults.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nlibrary Vaults {\\n    enum Type {\\n        GENERIC,\\n        BALANCER_CPMM,\\n        BALANCER_2CLP,\\n        BALANCER_3CLP,\\n        BALANCER_ECLP\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"draft-IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"IRateProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\ninterface IRateProvider {\\n    function getRate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\nimport \\\"IERC20.sol\\\";\\n\\nimport \\\"IWETH.sol\\\";\\nimport \\\"IAsset.sol\\\";\\nimport \\\"IAuthorizer.sol\\\";\\nimport \\\"IFlashLoanRecipient.sol\\\";\\nimport \\\"ISignaturesValidator.sol\\\";\\nimport \\\"ITemporarilyPausable.sol\\\";\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\\n * don't override one of these declarations.\\n */\\ninterface IVault is ISignaturesValidator, ITemporarilyPausable {\\n    // Generalities about the Vault:\\n    //\\n    // - Whenever documentation refers to 'tokens', it strictly refers to ERC20-compliant token contracts. Tokens are\\n    // transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\\n    // `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\\n    // calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\\n    // a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\\n    //\\n    // - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\\n    // while execution control is transferred to a token contract during a swap) will result in a revert. View\\n    // functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\\n    // Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\\n    //\\n    // - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\\n\\n    // Authorizer\\n    //\\n    // Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\\n    // outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\\n    // can perform a given action.\\n\\n    /**\\n     * @dev Returns the Vault's Authorizer.\\n     */\\n    function getAuthorizer() external view returns (IAuthorizer);\\n\\n    /**\\n     * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\\n     *\\n     * Emits an `AuthorizerChanged` event.\\n     */\\n    function setAuthorizer(IAuthorizer newAuthorizer) external;\\n\\n    /**\\n     * @dev Emitted when a new authorizer is set by `setAuthorizer`.\\n     */\\n    event AuthorizerChanged(IAuthorizer indexed newAuthorizer);\\n\\n    // Relayers\\n    //\\n    // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\\n    // Vault ERC20 allowance and Internal Balance. These accounts are said to be 'relayers' for these Vault functions,\\n    // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\\n    // this power, two things must occur:\\n    //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\\n    //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\\n    //    functions.\\n    //  - Each user must approve the relayer to act on their behalf.\\n    // This double protection means users cannot be tricked into approving malicious relayers (because they will not\\n    // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\\n    // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\\n\\n    /**\\n     * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\\n     */\\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\\n\\n    /**\\n     * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\\n     *\\n     * Emits a `RelayerApprovalChanged` event.\\n     */\\n    function setRelayerApproval(\\n        address sender,\\n        address relayer,\\n        bool approved\\n    ) external;\\n\\n    /**\\n     * @dev Emitted every time a relayer is approved or disapproved by `setRelayerApproval`.\\n     */\\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\\n\\n    // Internal Balance\\n    //\\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\\n    //\\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\\n    // operations of different kinds, with different senders and recipients, at once.\\n\\n    /**\\n     * @dev Returns `user`'s Internal Balance for a set of tokens.\\n     */\\n    function getInternalBalance(address user, IERC20[] memory tokens)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\\n     * it lets integrators reuse a user's Vault allowance.\\n     *\\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\\n     */\\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\\n\\n    /**\\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\\n     without manual WETH wrapping or unwrapping.\\n     */\\n    struct UserBalanceOp {\\n        UserBalanceOpKind kind;\\n        IAsset asset;\\n        uint256 amount;\\n        address sender;\\n        address payable recipient;\\n    }\\n\\n    // There are four possible operations in `manageUserBalance`:\\n    //\\n    // - DEPOSIT_INTERNAL\\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\\n    //\\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\\n    // relevant for relayers).\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - WITHDRAW_INTERNAL\\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\\n    //\\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\\n    // it to the recipient as ETH.\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - TRANSFER_INTERNAL\\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\\n    //\\n    // Reverts if the ETH sentinel value is passed.\\n    //\\n    // Emits an `InternalBalanceChanged` event.\\n    //\\n    //\\n    // - TRANSFER_EXTERNAL\\n    // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\\n    // relayers, as it lets them reuse a user's Vault allowance.\\n    //\\n    // Reverts if the ETH sentinel value is passed.\\n    //\\n    // Emits an `ExternalBalanceTransfer` event.\\n\\n    enum UserBalanceOpKind {\\n        DEPOSIT_INTERNAL,\\n        WITHDRAW_INTERNAL,\\n        TRANSFER_INTERNAL,\\n        TRANSFER_EXTERNAL\\n    }\\n\\n    /**\\n     * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\\n     * interacting with Pools using Internal Balance.\\n     *\\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\\n     * address.\\n     */\\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\\n\\n    /**\\n     * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\\n     */\\n    event ExternalBalanceTransfer(\\n        IERC20 indexed token,\\n        address indexed sender,\\n        address recipient,\\n        uint256 amount\\n    );\\n\\n    // Pools\\n    //\\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\\n    // functionality:\\n    //\\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\\n    // which increase with the number of registered tokens.\\n    //\\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\\n    // independent of the number of registered tokens.\\n    //\\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\\n\\n    enum PoolSpecialization {\\n        GENERAL,\\n        MINIMAL_SWAP_INFO,\\n        TWO_TOKEN\\n    }\\n\\n    /**\\n     * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\\n     * changed.\\n     *\\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\\n     *\\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\\n     * multiple Pools may share the same contract.\\n     *\\n     * Emits a `PoolRegistered` event.\\n     */\\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\\n\\n    /**\\n     * @dev Emitted when a Pool is registered by calling `registerPool`.\\n     */\\n    event PoolRegistered(\\n        bytes32 indexed poolId,\\n        address indexed poolAddress,\\n        PoolSpecialization specialization\\n    );\\n\\n    /**\\n     * @dev Returns a Pool's contract address and specialization setting.\\n     */\\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\\n\\n    /**\\n     * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\\n     * exit by receiving registered tokens, and can only swap registered tokens.\\n     *\\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\\n     * ascending order.\\n     *\\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\\n     * Asset Manager should not be made lightly.\\n     *\\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\\n     * different Asset Manager.\\n     *\\n     * Emits a `TokensRegistered` event.\\n     */\\n    function registerTokens(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        address[] memory assetManagers\\n    ) external;\\n\\n    /**\\n     * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\\n     */\\n    event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\\n\\n    /**\\n     * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\\n     * must be deregistered in the same `deregisterTokens` call.\\n     *\\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\\n     *\\n     * Emits a `TokensDeregistered` event.\\n     */\\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\\n\\n    /**\\n     * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\\n     */\\n    event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\\n\\n    /**\\n     * @dev Returns detailed information for a Pool's registered token.\\n     *\\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\\n     * equals the sum of `cash` and `managed`.\\n     *\\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\\n     * `managed` or `total` balance to be greater than 2^112 - 1.\\n     *\\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\\n     * change for this purpose, and will update `lastChangeBlock`.\\n     *\\n     * `assetManager` is the Pool's token Asset Manager.\\n     */\\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\\n        external\\n        view\\n        returns (\\n            uint256 cash,\\n            uint256 managed,\\n            uint256 lastChangeBlock,\\n            address assetManager\\n        );\\n\\n    /**\\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\\n     * the tokens' `balances` changed.\\n     *\\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\\n     *\\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\\n     * order as passed to `registerTokens`.\\n     *\\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\\n     * instead.\\n     */\\n    function getPoolTokens(bytes32 poolId)\\n        external\\n        view\\n        returns (\\n            IERC20[] memory tokens,\\n            uint256[] memory balances,\\n            uint256 lastChangeBlock\\n        );\\n\\n    /**\\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\\n     * Pool shares.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\\n     * these maximums.\\n     *\\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\\n     * back to the caller (not the sender, which is important for relayers).\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\\n     *\\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\\n     *\\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\\n     * directly to the Pool's contract, as is `recipient`.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n    function joinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        JoinPoolRequest memory request\\n    ) external payable;\\n\\n    struct JoinPoolRequest {\\n        IAsset[] assets;\\n        uint256[] maxAmountsIn;\\n        bytes userData;\\n        bool fromInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\\n     * `getPoolTokenInfo`).\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\\n     * it just enforces these minimums.\\n     *\\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\\n     *\\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\\n     * do so will trigger a revert.\\n     *\\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\\n     * `tokens` array. This array must match the Pool's registered tokens.\\n     *\\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\\n     * passed directly to the Pool's contract.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n    function exitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address payable recipient,\\n        ExitPoolRequest memory request\\n    ) external;\\n\\n    struct ExitPoolRequest {\\n        IAsset[] assets;\\n        uint256[] minAmountsOut;\\n        bytes userData;\\n        bool toInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\\n     */\\n    event PoolBalanceChanged(\\n        bytes32 indexed poolId,\\n        address indexed liquidityProvider,\\n        IERC20[] tokens,\\n        int256[] deltas,\\n        uint256[] protocolFeeAmounts\\n    );\\n\\n    enum PoolBalanceChangeKind {\\n        JOIN,\\n        EXIT\\n    }\\n\\n    // Swaps\\n    //\\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\\n    //\\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\\n    // individual swaps.\\n    //\\n    // There are two swap kinds:\\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\\n    //\\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\\n    // the final intended token.\\n    //\\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\\n    // much less gas than they would otherwise.\\n    //\\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\\n    // updating the Pool's internal accounting).\\n    //\\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\\n    //\\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\\n    //\\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\\n    //\\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\\n\\n    enum SwapKind {\\n        GIVEN_IN,\\n        GIVEN_OUT\\n    }\\n\\n    /**\\n     * @dev Performs a swap with a single Pool.\\n     *\\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\\n     * taken from the Pool, which must be greater than or equal to `limit`.\\n     *\\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\\n     * sent to the Pool, which must be less than or equal to `limit`.\\n     *\\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\\n     *\\n     * Emits a `Swap` event.\\n     */\\n    function swap(\\n        SingleSwap memory singleSwap,\\n        FundManagement memory funds,\\n        uint256 limit,\\n        uint256 deadline\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\\n     * the `kind` value.\\n     *\\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        SwapKind kind;\\n        IAsset assetIn;\\n        IAsset assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\\n     *\\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\\n     * the same index in the `assets` array.\\n     *\\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\\n     * `amountOut` depending on the swap kind.\\n     *\\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\\n     *\\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\\n     * or unwrapped from WETH by the Vault.\\n     *\\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\\n     *\\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\\n     * equivalent `swap` call.\\n     *\\n     * Emits `Swap` events.\\n     */\\n    function batchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds,\\n        int256[] memory limits,\\n        uint256 deadline\\n    ) external payable returns (int256[] memory);\\n\\n    /**\\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\\n     *\\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\\n     * from the previous swap, depending on the swap kind.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct BatchSwapStep {\\n        bytes32 poolId;\\n        uint256 assetInIndex;\\n        uint256 assetOutIndex;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\\n     */\\n    event Swap(\\n        bytes32 indexed poolId,\\n        IERC20 indexed tokenIn,\\n        IERC20 indexed tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    );\\n\\n    /**\\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\\n     * `recipient` account.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n     * `joinPool`.\\n     *\\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n     * transferred. This matches the behavior of `exitPool`.\\n     *\\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\\n     * revert.\\n     */\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address payable recipient;\\n        bool toInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\\n     *\\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\\n     * receives are the same that an equivalent `batchSwap` call would receive.\\n     *\\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\\n     * approve them for the Vault, or even know a user's address.\\n     *\\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\\n     * eth_call instead of eth_sendTransaction.\\n     */\\n    function queryBatchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds\\n    ) external returns (int256[] memory assetDeltas);\\n\\n    // Flash Loans\\n\\n    /**\\n     * @dev Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\\n     * and then reverting unless the tokens plus a proportional protocol fee have been returned.\\n     *\\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\\n     * for each token contract. `tokens` must be sorted in ascending order.\\n     *\\n     * The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\\n     * `receiveFlashLoan` call.\\n     *\\n     * Emits `FlashLoan` events.\\n     */\\n    function flashLoan(\\n        IFlashLoanRecipient recipient,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        bytes memory userData\\n    ) external;\\n\\n    /**\\n     * @dev Emitted for each individual flash loan performed by `flashLoan`.\\n     */\\n    event FlashLoan(\\n        IFlashLoanRecipient indexed recipient,\\n        IERC20 indexed token,\\n        uint256 amount,\\n        uint256 feeAmount\\n    );\\n\\n    // Asset Management\\n    //\\n    // Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool's\\n    // tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\\n    // `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\\n    // controls one of the tokens in a Pool, a malicious manager could set that token's balance to manipulate the\\n    // prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\\n    // not constrained to the tokens they are managing, but extends to the entire Pool's holdings.\\n    //\\n    // However, a properly designed Asset Manager smart contract can be safely used for the Pool's benefit,\\n    // for example by lending unused tokens out for interest, or using them to participate in voting protocols.\\n    //\\n    // This concept is unrelated to the IAsset interface.\\n\\n    /**\\n     * @dev Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates.\\n     *\\n     * Pool Balance management features batching, which means a single contract call can be used to perform multiple\\n     * operations of different kinds, with different Pools and tokens, at once.\\n     *\\n     * For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\\n     */\\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\\n\\n    struct PoolBalanceOp {\\n        PoolBalanceOpKind kind;\\n        bytes32 poolId;\\n        IERC20 token;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * Withdrawals decrease the Pool's cash, but increase its managed balance, leaving the total balance unchanged.\\n     *\\n     * Deposits increase the Pool's cash, but decrease its managed balance, leaving the total balance unchanged.\\n     *\\n     * Updates don't affect the Pool's cash balance, but because the managed balance changes, it does alter the total.\\n     * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\\n     */\\n    enum PoolBalanceOpKind {\\n        WITHDRAW,\\n        DEPOSIT,\\n        UPDATE\\n    }\\n\\n    /**\\n     * @dev Emitted when a Pool's token Asset Manager alters its balance via `managePoolBalance`.\\n     */\\n    event PoolBalanceManaged(\\n        bytes32 indexed poolId,\\n        address indexed assetManager,\\n        IERC20 indexed token,\\n        int256 cashDelta,\\n        int256 managedDelta\\n    );\\n\\n    // Protocol Fees\\n    //\\n    // Some operations cause the Vault to collect tokens in the form of protocol fees, which can then be withdrawn by\\n    // permissioned accounts.\\n    //\\n    // There are two kinds of protocol fees:\\n    //\\n    //  - flash loan fees: charged on all flash loans, as a percentage of the amounts lent.\\n    //\\n    //  - swap fees: a percentage of the fees charged by Pools when performing swaps. For a number of reasons, including\\n    // swap gas costs and interface simplicity, protocol swap fees are not charged on each individual swap. Rather,\\n    // Pools are expected to keep track of how much they have charged in swap fees, and pay any outstanding debts to the\\n    // Vault when they are joined or exited. This prevents users from joining a Pool with unpaid debt, as well as\\n    // exiting a Pool in debt without first paying their share.\\n\\n    /**\\n     * @dev Returns the current protocol fee module.\\n     */\\n    // function getProtocolFeesCollector() external view returns (ProtocolFeesCollector);\\n\\n    /**\\n     * @dev Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an\\n     * error in some part of the system.\\n     *\\n     * The Vault can only be paused during an initial time period, after which pausing is forever disabled.\\n     *\\n     * While the contract is paused, the following features are disabled:\\n     * - depositing and transferring internal balance\\n     * - transferring external balance (using the Vault's allowance)\\n     * - swaps\\n     * - joining Pools\\n     * - Asset Manager interactions\\n     *\\n     * Internal Balance can still be withdrawn, and Pools exited.\\n     */\\n    function setPaused(bool paused) external;\\n\\n    /**\\n     * @dev Returns the Vault's WETH instance.\\n     */\\n    function WETH() external view returns (IWETH);\\n    // solhint-disable-previous-line func-name-mixedcase\\n}\\n\"\r\n    },\r\n    \"IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the WETH token contract used internally for wrapping and unwrapping, to support\\n * sending and receiving ETH in joins, swaps, and internal balance deposits and withdrawals.\\n */\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"IAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\\n * types.\\n *\\n * This concept is unrelated to a Pool's Asset Managers.\\n */\\ninterface IAsset {\\n    // solhint-disable-previous-line no-empty-blocks\\n}\\n\"\r\n    },\r\n    \"IAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\n\\npragma solidity ^0.8.4;\\n\\ninterface IAuthorizer {\\n    /**\\n     * @dev Returns true if `account` can perform the action described by `actionId` in the contract `where`.\\n     */\\n    function canPerform(\\n        bytes32 actionId,\\n        address account,\\n        address where\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IFlashLoanRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\n\\npragma solidity ^0.8.4;\\n\\n// Inspired by Aave Protocol's IFlashLoanReceiver.\\n\\nimport \\\"IERC20.sol\\\";\\n\\ninterface IFlashLoanRecipient {\\n    /**\\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\\n     *\\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\\n     * Vault, or else the entire flash loan will revert.\\n     *\\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\\n     */\\n    function receiveFlashLoan(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        uint256[] memory feeAmounts,\\n        bytes memory userData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"ISignaturesValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface for the SignatureValidator helper, used to support meta-transactions.\\n */\\ninterface ISignaturesValidator {\\n    /**\\n     * @dev Returns the EIP712 domain separator.\\n     */\\n    function getDomainSeparator() external view returns (bytes32);\\n\\n    /**\\n     * @dev Returns the next nonce used by an address to sign messages.\\n     */\\n    function getNextNonce(address user) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"ITemporarilyPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface for the TemporarilyPausable helper.\\n */\\ninterface ITemporarilyPausable {\\n    /**\\n     * @dev Emitted every time the pause state changes by `_setPaused`.\\n     */\\n    event PausedStateChanged(bool paused);\\n\\n    /**\\n     * @dev Returns the current paused state.\\n     */\\n    function getPausedState()\\n        external\\n        view\\n        returns (\\n            bool paused,\\n            uint256 pauseWindowEndTime,\\n            uint256 bufferPeriodEndTime\\n        );\\n}\\n\"\r\n    },\r\n    \"ISafetyCheck.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"DataTypes.sol\\\";\\n\\ninterface ISafetyCheck {\\n    /// @notice Checks whether a mint operation is safe\\n    /// @return empty string if it is safe, otherwise the reason why it is not safe\\n    function isMintSafe(DataTypes.Order memory order) external view returns (string memory);\\n\\n    /// @notice Checks whether a redeem operation is safe\\n    /// @return empty string if it is safe, otherwise the reason why it is not safe\\n    function isRedeemSafe(DataTypes.Order memory order) external view returns (string memory);\\n\\n    /// @notice Checks whether a redeem operation is safe and reverts otherwise\\n    /// This is only called when an actual redeem is performed\\n    /// The implementation should store any relevant information for the redeem\\n    function checkAndPersistRedeem(DataTypes.Order memory order) external;\\n\\n    /// @notice Checks whether a mint operation is safe and reverts otherwise\\n    /// This is only called when an actual mint is performed\\n    /// The implementation should store any relevant information for the mint\\n    function checkAndPersistMint(DataTypes.Order memory order) external;\\n}\\n\"\r\n    },\r\n    \"IVaultRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"DataTypes.sol\\\";\\n\\ninterface IVaultRegistry {\\n    event VaultsSet(DataTypes.VaultConfiguration[] vaults);\\n\\n    /// @notice Returns the metadata for the given vault\\n    function getVaultMetadata(address vault)\\n        external\\n        view\\n        returns (DataTypes.PersistedVaultMetadata memory);\\n\\n    /// @notice Returns the weight of the vault given its schedule\\n    function getScheduleVaultWeight(address vault) external view returns (uint256);\\n\\n    /// @notice Get the list of all vaults\\n    function listVaults() external view returns (address[] memory);\\n\\n    /// @notice Registers a new vault\\n    function setVaults(DataTypes.VaultConfiguration[] memory vaults) external;\\n\\n    /// @notice updates the vaults' flow params\\n    function updatePersistedVaultFlowParams(\\n        address[] memory vaultsToUpdate,\\n        uint256[] memory newShortFlowMemory,\\n        uint256[] memory newShortFlowThreshold\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"LogExpMath.sol\\\";\\nimport \\\"Errors.sol\\\";\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\nlibrary FixedPoint {\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\\n\\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\\n\\n    function absSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a - b : b - a;\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n\\n        return product / ONE;\\n    }\\n\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n\\n        if (product == 0) {\\n            return 0;\\n        } else {\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((product - 1) / ONE) + 1;\\n        }\\n    }\\n\\n    function squareUp(uint256 a) internal pure returns (uint256) {\\n        return mulUp(a, a);\\n    }\\n\\n    function squareDown(uint256 a) internal pure returns (uint256) {\\n        return mulDown(a, a);\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            unchecked {\\n                return ((aInflated - 1) / b) + 1;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\\n     * the true value (that is, the error function expected - actual is always positive).\\n     */\\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR) + 1;\\n\\n        if (raw < maxError) {\\n            return 0;\\n        } else {\\n            return raw - maxError;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\\n     * the true value (that is, the error function expected - actual is always negative).\\n     */\\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR) + 1;\\n\\n        return raw + maxError;\\n    }\\n\\n    /**\\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\\n     *\\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\\n     * prevents intermediate negative values.\\n     */\\n    function complement(uint256 x) internal pure returns (uint256) {\\n        return (x < ONE) ? (ONE - x) : 0;\\n    }\\n\\n    /**\\n     * @dev returns the minimum between x and y\\n     */\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x < y ? x : y;\\n    }\\n\\n    /**\\n     * @dev returns the maximum between x and y\\n     */\\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? x : y;\\n    }\\n\\n    /**\\n     * @notice This is taken from the Balancer V1 code base.\\n     * Computes a**b where a is a scaled fixed-point number and b is an integer\\n     * The computation is performed in O(log n)\\n     */\\n    function intPowDown(uint256 base, uint256 exp) internal pure returns (uint256) {\\n        uint256 result = FixedPoint.ONE;\\n        while (exp > 0) {\\n            if (exp % 2 == 1) {\\n                result = mulDown(result, base);\\n            }\\n            exp /= 2;\\n            base = mulDown(base, base);\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"LogExpMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"Errors.sol\\\";\\n\\n/* solhint-disable */\\n\\n/**\\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\\n *\\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\\n * exponentiation and logarithm (where the base is Euler's number).\\n *\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\\n    // two numbers, and multiply by ONE when dividing them.\\n\\n    // All arguments and return values are 18 decimal fixed point numbers.\\n    int256 constant ONE_18 = 1e18;\\n\\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\\n    // case of ln36, 36 decimals.\\n    int256 constant ONE_20 = 1e20;\\n    int256 constant ONE_36 = 1e36;\\n\\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\\n    //\\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\\n    // The smallest possible result is 10^(-18), which makes largest negative argument\\n    // ln(10^(-18)) = -41.446531673892822312.\\n    // We use 130.0 and -41.0 to have some safety margin.\\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\\n\\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\\n    // 256 bit integer.\\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\\n\\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\\n\\n    // 18 decimal constants\\n    int256 constant x0 = 128000000000000000000; // 2\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\u02c6(x0) (no decimals)\\n    int256 constant x1 = 64000000000000000000; // 2\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; // e\u02c6(x1) (no decimals)\\n\\n    // 20 decimal constants\\n    int256 constant x2 = 3200000000000000000000; // 2\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; // e\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; // 2\u02c64\\n    int256 constant a3 = 888611052050787263676000000; // e\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; // 2\u02c63\\n    int256 constant a4 = 298095798704172827474000; // e\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; // 2\u02c62\\n    int256 constant a5 = 5459815003314423907810; // e\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; // 2\u02c61\\n    int256 constant a6 = 738905609893065022723; // e\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; // 2\u02c60\\n    int256 constant a7 = 271828182845904523536; // e\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; // 2\u02c6-1\\n    int256 constant a8 = 164872127070012814685; // e\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; // 2\u02c6-2\\n    int256 constant a9 = 128402541668774148407; // e\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; // 2\u02c6-3\\n    int256 constant a10 = 113314845306682631683; // e\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; // 2\u02c6-4\\n    int256 constant a11 = 106449445891785942956; // e\u02c6(x11)\\n\\n    /**\\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\\n     *\\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        unchecked {\\n            if (y == 0) {\\n                // We solve the 0^0 indetermination by making it equal one.\\n                return uint256(ONE_18);\\n            }\\n\\n            if (x == 0) {\\n                return 0;\\n            }\\n\\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\\n            // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\\n            // x^y = exp(y * ln(x)).\\n\\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\\n            require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\\n            int256 x_int256 = int256(x);\\n\\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\\n\\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\\n            require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\\n            int256 y_int256 = int256(y);\\n\\n            int256 logx_times_y;\\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\\n                int256 ln_36_x = _ln_36(x_int256);\\n\\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\\n                // (downscaled) last 18 decimals.\\n                logx_times_y = ((ln_36_x / ONE_18) *\\n                    y_int256 +\\n                    ((ln_36_x % ONE_18) * y_int256) /\\n                    ONE_18);\\n            } else {\\n                logx_times_y = _ln(x_int256) * y_int256;\\n            }\\n            logx_times_y /= ONE_18;\\n\\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\\n            require(\\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\\n                Errors.PRODUCT_OUT_OF_BOUNDS\\n            );\\n\\n            return uint256(exp(logx_times_y));\\n        }\\n    }\\n\\n    /**\\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\\n     *\\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function exp(int256 x) internal pure returns (int256) {\\n        require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\\n        unchecked {\\n            if (x < 0) {\\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\\n                // Fixed point division requires multiplying by ONE_18.\\n                return ((ONE_18 * ONE_18) / exp(-x));\\n            }\\n\\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\\n            // decomposition.\\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\\n            // decomposition, which will be lower than the smallest x_n.\\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\\n\\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\\n            // decomposition.\\n\\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\\n            // it and compute the accumulated product.\\n\\n            int256 firstAN;\\n            if (x >= x0) {\\n                x -= x0;\\n                firstAN = a0;\\n            } else if (x >= x1) {\\n                x -= x1;\\n                firstAN = a1;\\n            } else {\\n                firstAN = 1; // One with no decimal places\\n            }\\n\\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\\n            // smaller terms.\\n            x *= 100;\\n\\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\\n            int256 product = ONE_20;\\n\\n            if (x >= x2) {\\n                x -= x2;\\n                product = (product * a2) / ONE_20;\\n            }\\n            if (x >= x3) {\\n                x -= x3;\\n                product = (product * a3) / ONE_20;\\n            }\\n            if (x >= x4) {\\n                x -= x4;\\n                product = (product * a4) / ONE_20;\\n            }\\n            if (x >= x5) {\\n                x -= x5;\\n                product = (product * a5) / ONE_20;\\n            }\\n            if (x >= x6) {\\n                x -= x6;\\n                product = (product * a6) / ONE_20;\\n            }\\n            if (x >= x7) {\\n                x -= x7;\\n                product = (product * a7) / ONE_20;\\n            }\\n            if (x >= x8) {\\n                x -= x8;\\n                product = (product * a8) / ONE_20;\\n            }\\n            if (x >= x9) {\\n                x -= x9;\\n                product = (product * a9) / ONE_20;\\n            }\\n\\n            // x10 and x11 are unnecessary here since we have high enough precision already.\\n\\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\\n\\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\\n\\n            // The first term is simply x.\\n            term = x;\\n            seriesSum += term;\\n\\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\\n\\n            term = ((term * x) / ONE_20) / 2;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 3;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 4;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 5;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 6;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 7;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 8;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 9;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 10;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 11;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 12;\\n            seriesSum += term;\\n\\n            // 12 Taylor terms are sufficient for 18 decimal precision.\\n\\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\\n            // and then drop two digits to return an 18 decimal value.\\n\\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\\n        }\\n    }\\n\\n    /**\\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\\n     */\\n    function log(int256 arg, int256 base) internal pure returns (int256) {\\n        unchecked {\\n            // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\\n\\n            // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\\n            // upscaling.\\n\\n            int256 logBase;\\n            if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\\n                logBase = _ln_36(base);\\n            } else {\\n                logBase = _ln(base) * ONE_18;\\n            }\\n\\n            int256 logArg;\\n            if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\\n                logArg = _ln_36(arg);\\n            } else {\\n                logArg = _ln(arg) * ONE_18;\\n            }\\n\\n            // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\\n            return (logArg * ONE_18) / logBase;\\n        }\\n    }\\n\\n    /**\\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function ln(int256 a) internal pure returns (int256) {\\n        unchecked {\\n            // The real natural logarithm is not defined for negative numbers or zero.\\n            require(a > 0, Errors.OUT_OF_BOUNDS);\\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\\n                return _ln_36(a) / ONE_18;\\n            } else {\\n                return _ln(a);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function _ln(int256 a) private pure returns (int256) {\\n        unchecked {\\n            if (a < ONE_18) {\\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\\n                // Fixed point division requires multiplying by ONE_18.\\n                return (-_ln((ONE_18 * ONE_18) / a));\\n            }\\n\\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\\n            // decomposition, which will be lower than the smallest a_n.\\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\\n\\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\\n            // ONE_18 to convert them to fixed point.\\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\\n            // by it and compute the accumulated sum.\\n\\n            int256 sum = 0;\\n            if (a >= a0 * ONE_18) {\\n                a /= a0; // Integer, not fixed point division\\n                sum += x0;\\n            }\\n\\n            if (a >= a1 * ONE_18) {\\n                a /= a1; // Integer, not fixed point division\\n                sum += x1;\\n            }\\n\\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\\n            sum *= 100;\\n            a *= 100;\\n\\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\\n\\n            if (a >= a2) {\\n                a = (a * ONE_20) / a2;\\n                sum += x2;\\n            }\\n\\n            if (a >= a3) {\\n                a = (a * ONE_20) / a3;\\n                sum += x3;\\n            }\\n\\n            if (a >= a4) {\\n                a = (a * ONE_20) / a4;\\n                sum += x4;\\n            }\\n\\n            if (a >= a5) {\\n                a = (a * ONE_20) / a5;\\n                sum += x5;\\n            }\\n\\n            if (a >= a6) {\\n                a = (a * ONE_20) / a6;\\n                sum += x6;\\n            }\\n\\n            if (a >= a7) {\\n                a = (a * ONE_20) / a7;\\n                sum += x7;\\n            }\\n\\n            if (a >= a8) {\\n                a = (a * ONE_20) / a8;\\n                sum += x8;\\n            }\\n\\n            if (a >= a9) {\\n                a = (a * ONE_20) / a9;\\n                sum += x9;\\n            }\\n\\n            if (a >= a10) {\\n                a = (a * ONE_20) / a10;\\n                sum += x10;\\n            }\\n\\n            if (a >= a11) {\\n                a = (a * ONE_20) / a11;\\n                sum += x11;\\n            }\\n\\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\\n            // Let z = (a - 1) / (a + 1).\\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\\n            // division by ONE_20.\\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\\n            int256 z_squared = (z * z) / ONE_20;\\n\\n            // num is the numerator of the series: the z^(2 * n + 1) term\\n            int256 num = z;\\n\\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n            int256 seriesSum = num;\\n\\n            // In each step, the numerator is multiplied by z^2\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 3;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 5;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 7;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 9;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 11;\\n\\n            // 6 Taylor terms are sufficient for 36 decimal precision.\\n\\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\\n            seriesSum *= 2;\\n\\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\\n            // value.\\n\\n            return (sum + seriesSum) / 100;\\n        }\\n    }\\n\\n    /**\\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\\n     * for x close to one.\\n     *\\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\\n     */\\n    function _ln_36(int256 x) private pure returns (int256) {\\n        unchecked {\\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\\n            // worthwhile.\\n\\n            // First, we transform x to a 36 digit fixed point value.\\n            x *= ONE_18;\\n\\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\\n            // division by ONE_36.\\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\\n            int256 z_squared = (z * z) / ONE_36;\\n\\n            // num is the numerator of the series: the z^(2 * n + 1) term\\n            int256 num = z;\\n\\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n            int256 seriesSum = num;\\n\\n            // In each step, the numerator is multiplied by z^2\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 3;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 5;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 7;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 9;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 11;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 13;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 15;\\n\\n            // 8 Taylor terms are sufficient for 36 decimal precision.\\n\\n            // All that remains is multiplying by 2 (non fixed point).\\n            return seriesSum * 2;\\n        }\\n    }\\n\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n        return pow(x, uint256(ONE_18) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"Flow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"FixedPoint.sol\\\";\\n\\nlibrary Flow {\\n    using FixedPoint for uint256;\\n\\n    // This function calculates an exponential moving sum based on memoryParam\\n    function updateFlow(\\n        uint256 flowHistory,\\n        uint256 currentBlock,\\n        uint256 lastSeenBlock,\\n        uint256 memoryParam\\n    ) internal pure returns (uint256) {\\n        if (lastSeenBlock == currentBlock || flowHistory == 0) {\\n            return flowHistory;\\n        } else if (lastSeenBlock < currentBlock) {\\n            uint256 blockDifference = currentBlock - lastSeenBlock;\\n            uint256 memoryParamRaised = memoryParam.intPowDown(blockDifference);\\n            return flowHistory.mulDown(memoryParamRaised);\\n        }\\n        revert(Errors.INVALID_ARGUMENT);\\n    }\\n}\\n\"\r\n    },\r\n    \"StringExtensions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.10;\\n\\nlibrary StringExtensions {\\n    function equals(string memory a, string memory b) internal pure returns (bool) {\\n        if (bytes(a).length != bytes(b).length) {\\n            return false;\\n        }\\n        return (keccak256(bytes(a)) == keccak256(bytes(b)));\\n    }\\n}\\n\"\r\n    },\r\n    \"ConfigHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"IERC721.sol\\\";\\n\\nimport \\\"ConfigKeys.sol\\\";\\n\\nimport \\\"IBatchVaultPriceOracle.sol\\\";\\nimport \\\"IRateManager.sol\\\";\\nimport \\\"IMotherboard.sol\\\";\\nimport \\\"ISafetyCheck.sol\\\";\\nimport \\\"IGyroConfig.sol\\\";\\nimport \\\"IVaultRegistry.sol\\\";\\nimport \\\"IAssetRegistry.sol\\\";\\nimport \\\"IReserveManager.sol\\\";\\nimport \\\"IReserve.sol\\\";\\nimport \\\"IGYDToken.sol\\\";\\nimport \\\"IFeeHandler.sol\\\";\\nimport \\\"IGydRecovery.sol\\\";\\nimport \\\"IPAMM.sol\\\";\\nimport \\\"IReserveStewardshipIncentives.sol\\\";\\nimport \\\"IVault.sol\\\";\\n\\n/// @notice Defines helpers to allow easy access to common parts of the configuration\\nlibrary ConfigHelpers {\\n    function getRootPriceOracle(IGyroConfig gyroConfig)\\n        internal\\n        view\\n        returns (IBatchVaultPriceOracle)\\n    {\\n        return IBatchVaultPriceOracle(gyroConfig.getAddress(ConfigKeys.ROOT_PRICE_ORACLE_ADDRESS));\\n    }\\n\\n    function getPAMM(IGyroConfig gyroConfig) internal view returns (IPAMM) {\\n        return IPAMM(gyroConfig.getAddress(ConfigKeys.PAMM_ADDRESS));\\n    }\\n\\n    function getRootSafetyCheck(IGyroConfig gyroConfig) internal view returns (ISafetyCheck) {\\n        return ISafetyCheck(gyroConfig.getAddress(ConfigKeys.ROOT_SAFETY_CHECK_ADDRESS));\\n    }\\n\\n    function getVaultRegistry(IGyroConfig gyroConfig) internal view returns (IVaultRegistry) {\\n        return IVaultRegistry(gyroConfig.getAddress(ConfigKeys.VAULT_REGISTRY_ADDRESS));\\n    }\\n\\n    function getAssetRegistry(IGyroConfig gyroConfig) internal view returns (IAssetRegistry) {\\n        return IAssetRegistry(gyroConfig.getAddress(ConfigKeys.ASSET_REGISTRY_ADDRESS));\\n    }\\n\\n    function getReserveManager(IGyroConfig gyroConfig) internal view returns (IReserveManager) {\\n        return IReserveManager(gyroConfig.getAddress(ConfigKeys.RESERVE_MANAGER_ADDRESS));\\n    }\\n\\n    function getReserve(IGyroConfig gyroConfig) internal view returns (IReserve) {\\n        return IReserve(gyroConfig.getAddress(ConfigKeys.RESERVE_ADDRESS));\\n    }\\n\\n    function getGYDToken(IGyroConfig gyroConfig) internal view returns (IGYDToken) {\\n        return IGYDToken(gyroConfig.getAddress(ConfigKeys.GYD_TOKEN_ADDRESS));\\n    }\\n\\n    function getFeeHandler(IGyroConfig gyroConfig) internal view returns (IFeeHandler) {\\n        return IFeeHandler(gyroConfig.getAddress(ConfigKeys.FEE_HANDLER_ADDRESS));\\n    }\\n\\n    function getMotherboard(IGyroConfig gyroConfig) internal view returns (IMotherboard) {\\n        return IMotherboard(gyroConfig.getAddress(ConfigKeys.MOTHERBOARD_ADDRESS));\\n    }\\n\\n    function getGydRecovery(IGyroConfig gyroConfig) internal view returns (IGydRecovery) {\\n        return IGydRecovery(gyroConfig.getAddress(ConfigKeys.GYD_RECOVERY_ADDRESS));\\n    }\\n\\n    function getReserveStewardshipIncentives(IGyroConfig gyroConfig)\\n        internal\\n        view\\n        returns (IReserveStewardshipIncentives)\\n    {\\n        return\\n            IReserveStewardshipIncentives(\\n                gyroConfig.getAddress(ConfigKeys.STEWARDSHIP_INC_ADDRESS)\\n            );\\n    }\\n\\n    function getBalancerVault(IGyroConfig gyroConfig) internal view returns (IVault) {\\n        return IVault(gyroConfig.getAddress(ConfigKeys.BALANCER_VAULT_ADDRESS));\\n    }\\n\\n    function getGlobalSupplyCap(IGyroConfig gyroConfig) internal view returns (uint256) {\\n        return gyroConfig.getUint(ConfigKeys.GYD_GLOBAL_SUPPLY_CAP, type(uint256).max);\\n    }\\n\\n    function getStewardshipIncMinCollateralRatio(IGyroConfig gyroConfig)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return gyroConfig.getUint(ConfigKeys.STEWARDSHIP_INC_MIN_CR);\\n    }\\n\\n    function getStewardshipIncMaxHealthViolations(IGyroConfig gyroConfig)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return gyroConfig.getUint(ConfigKeys.STEWARDSHIP_INC_MAX_VIOLATIONS);\\n    }\\n\\n    function getStewardshipIncDuration(IGyroConfig gyroConfig) internal view returns (uint256) {\\n        return gyroConfig.getUint(ConfigKeys.STEWARDSHIP_INC_DURATION);\\n    }\\n\\n    function getGovTreasuryAddress(IGyroConfig gyroConfig) internal view returns (address) {\\n        return gyroConfig.getAddress(ConfigKeys.GOV_TREASURY_ADDRESS);\\n    }\\n\\n    function getRateManager(IGyroConfig gyroConfig) internal view returns (IRateManager) {\\n        return IRateManager(gyroConfig.getAddress(ConfigKeys.RATE_MANAGER_ADDRESS));\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"ConfigKeys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\n/// @notice Defines different configuration keys used in the Gyroscope system\\nlibrary ConfigKeys {\\n    // Addresses\\n    bytes32 internal constant GYD_TOKEN_ADDRESS = \\\"GYD_TOKEN_ADDRESS\\\";\\n    bytes32 internal constant PAMM_ADDRESS = \\\"PAMM_ADDRESS\\\";\\n    bytes32 internal constant RESERVE_ADDRESS = \\\"RESERVE_ADDRESS\\\";\\n    bytes32 internal constant ROOT_PRICE_ORACLE_ADDRESS = \\\"ROOT_PRICE_ORACLE_ADDRESS\\\";\\n    bytes32 internal constant ROOT_SAFETY_CHECK_ADDRESS = \\\"ROOT_SAFETY_CHECK_ADDRESS\\\";\\n    bytes32 internal constant VAULT_REGISTRY_ADDRESS = \\\"VAULT_REGISTRY_ADDRESS\\\";\\n    bytes32 internal constant ASSET_REGISTRY_ADDRESS = \\\"ASSET_REGISTRY_ADDRESS\\\";\\n    bytes32 internal constant RESERVE_MANAGER_ADDRESS = \\\"RESERVE_MANAGER_ADDRESS\\\";\\n    bytes32 internal constant FEE_HANDLER_ADDRESS = \\\"FEE_HANDLER_ADDRESS\\\";\\n    bytes32 internal constant MOTHERBOARD_ADDRESS = \\\"MOTHERBOARD_ADDRESS\\\";\\n    bytes32 internal constant CAP_AUTHENTICATION_ADDRESS = \\\"CAP_AUTHENTICATION_ADDRESS\\\";\\n    bytes32 internal constant GYD_RECOVERY_ADDRESS = \\\"GYD_RECOVERY_ADDRESS\\\";\\n    bytes32 internal constant BALANCER_VAULT_ADDRESS = \\\"BALANCER_VAULT_ADDRESS\\\";\\n    bytes32 internal constant RATE_MANAGER_ADDRESS = \\\"RATE_MANAGER_ADDRESS\\\";\\n\\n    bytes32 internal constant STEWARDSHIP_INC_ADDRESS = \\\"STEWARDSHIP_INC_ADDRESS\\\";\\n    bytes32 internal constant STEWARDSHIP_INC_MIN_CR = \\\"STEWARDSHIP_INC_MIN_CR\\\";\\n    bytes32 internal constant STEWARDSHIP_INC_DURATION = \\\"STEWARDSHIP_INC_DURATION\\\";\\n    bytes32 internal constant STEWARDSHIP_INC_MAX_VIOLATIONS = \\\"STEWARDSHIP_INC_MAX_VIOLATIONS\\\";\\n\\n    bytes32 internal constant GOV_TREASURY_ADDRESS = \\\"GOV_TREASURY_ADDRESS\\\";\\n\\n    // Uints\\n    bytes32 internal constant GYD_GLOBAL_SUPPLY_CAP = \\\"GYD_GLOBAL_SUPPLY_CAP\\\";\\n    bytes32 internal constant GYD_AUTHENTICATED_USER_CAP = \\\"GYD_AUTHENTICATED_USER_CAP\\\";\\n    bytes32 internal constant GYD_USER_CAP = \\\"GYD_USER_CAP\\\";\\n\\n    bytes32 internal constant GYD_RECOVERY_TRIGGER_CR = \\\"GYD_RECOVERY_TRIGGER_CR\\\";\\n    bytes32 internal constant GYD_RECOVERY_TARGET_CR = \\\"GYD_RECOVERY_TARGET_CR\\\";\\n\\n    bytes32 internal constant SAFETY_BLOCKS_AUTOMATIC = \\\"SAFETY_BLOCKS_AUTOMATIC\\\";\\n    bytes32 internal constant SAFETY_BLOCKS_GUARDIAN = \\\"SAFETY_BLOCKS_GUARDIAN\\\";\\n\\n    bytes32 internal constant REDEEM_DISCOUNT_RATIO = \\\"REDEEM_DISCOUNT_RATIO\\\";\\n    bytes32 internal constant VAULT_DUST_THRESHOLD = \\\"VAULT_DUST_THRESHOLD\\\";\\n    bytes32 internal constant STABLECOIN_MAX_DEVIATION = \\\"STABLECOIN_MAX_DEVIATION\\\";\\n}\\n\"\r\n    },\r\n    \"IBatchVaultPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"DataTypes.sol\\\";\\n\\nimport \\\"IGyroVault.sol\\\";\\n\\ninterface IBatchVaultPriceOracle {\\n    event BatchPriceOracleChanged(address indexed priceOracle);\\n    event VaultPriceOracleChanged(Vaults.Type indexed vaultType, address indexed priceOracle);\\n\\n    /// @notice Fetches the price of the vault token as well as the underlying tokens\\n    /// @return the same vaults info with the price data populated\\n    function fetchPricesUSD(\\n        DataTypes.VaultInfo[] memory vaultsInfo\\n    ) external view returns (DataTypes.VaultInfo[] memory);\\n\\n    /// @notice Returns the price of the vault token give the prices included in `pricedTokens`\\n    function getVaultPrice(\\n        IGyroVault vault,\\n        DataTypes.PricedToken[] memory pricedTokens\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"IRateManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"IRateProvider.sol\\\";\\n\\ninterface IRateManager {\\n    event RateProviderChanged(address indexed token, RateProviderInfo providerInfo);\\n\\n    struct RateProviderInfo {\\n        address underlying;\\n        IRateProvider provider;\\n    }\\n\\n    /// @notice input token may have a rate such as sDAI or aUSDC, or be a \\\"normal\\\" token such as DAI or USDC\\n    /// @return underlyingToken the \\\"underlying\\\" token, e.g. DAI instead of sDAI\\n    /// @return rate the rate of the token\\n    /// @dev if the token does not have a rate, its address will be returned as-is and its rate will be 1e18\\n    function getUnderlyingAndRate(address token)\\n        external\\n        view\\n        returns (address underlyingToken, uint256 rate);\\n\\n    /// @return the info about the rate provider for the given token\\n    function getProviderInfo(address token) external view returns (RateProviderInfo memory);\\n}\\n\"\r\n    },\r\n    \"IMotherboard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"IGyroConfig.sol\\\";\\nimport \\\"IGYDToken.sol\\\";\\nimport \\\"IReserve.sol\\\";\\nimport \\\"IPAMM.sol\\\";\\n\\n/// @title IMotherboard is the central contract connecting the different pieces\\n/// of the Gyro protocol\\ninterface IMotherboard {\\n    /// @dev The GYD token is not upgradable so this will always return the same value\\n    /// @return the address of the GYD token\\n    function gydToken() external view returns (IGYDToken);\\n\\n    /// @notice Returns the address for the PAMM\\n    /// @return the PAMM address\\n    function pamm() external view returns (IPAMM);\\n\\n    /// @notice Returns the address for the reserve\\n    /// @return the address of the reserve\\n    function reserve() external view returns (IReserve);\\n\\n    /// @notice Returns the address of the global configuration\\n    /// @return the global configuration address\\n    function gyroConfig() external view returns (IGyroConfig);\\n\\n    /// @notice Main minting function to be called by a depositor\\n    /// This mints using the exact input amount and mints at least `minMintedAmount`\\n    /// All the `inputTokens` should be approved for the motherboard to spend at least\\n    /// `inputAmounts` on behalf of the sender\\n    /// @param assets the assets and associated amounts used to mint GYD\\n    /// @param minReceivedAmount the minimum amount of GYD to be minted\\n    /// @return mintedGYDAmount GYD token minted amount\\n    function mint(DataTypes.MintAsset[] calldata assets, uint256 minReceivedAmount)\\n        external\\n        returns (uint256 mintedGYDAmount);\\n\\n    /// @notice Main redemption function to be called by a withdrawer\\n    /// This redeems using at most `maxRedeemedAmount` of GYD and returns the\\n    /// exact outputs as specified by `tokens` and `amounts`\\n    /// @param gydToRedeem the maximum amount of GYD to redeem\\n    /// @param assets the output tokens and associated amounts to return against GYD\\n    /// @return outputAmounts the amounts receivd against the redeemed GYD\\n    function redeem(uint256 gydToRedeem, DataTypes.RedeemAsset[] calldata assets)\\n        external\\n        returns (uint256[] memory outputAmounts);\\n\\n    /// @notice Simulates a mint to know whether it would succeed and how much would be minted\\n    /// The parameters are the same as the `mint` function\\n    ///\\n    /// Note: This does *not* include the action of the recovery module, if any!\\n    ///\\n    /// @param assets the assets and associated amounts used to mint GYD\\n    /// @param minReceivedAmount the minimum amount of GYD to be minted\\n    /// @return mintedGYDAmount the amount that would be minted, or 0 if it an error would occur\\n    /// @return err a non-empty error message in case an error would happen when minting\\n    function dryMint(DataTypes.MintAsset[] calldata assets, uint256 minReceivedAmount)\\n        external\\n        view\\n        returns (uint256 mintedGYDAmount, string memory err);\\n\\n    /// @notice Dry version of the `redeem` function\\n    /// exact outputs as specified by `tokens` and `amounts`\\n    ///\\n    /// Note: This does *not* include the action of the recovery module, if any!\\n    ///\\n    /// @param gydToRedeem the maximum amount of GYD to redeem\\n    /// @param assets the output tokens and associated amounts to return against GYD\\n    /// @return outputAmounts the amounts receivd against the redeemed GYD\\n    /// @return err a non-empty error message in case an error would happen when redeeming\\n    function dryRedeem(uint256 gydToRedeem, DataTypes.RedeemAsset[] memory assets)\\n        external\\n        view\\n        returns (uint256[] memory outputAmounts, string memory err);\\n\\n    /// @notice Only callable from the reserve stewardship incentives module. Mints new GYD to the governance treasury.\\n    function mintStewardshipIncRewards(uint256 amount) external;\\n\\n    /// @notice Supply preminted for bootstrapping.\\n    function bootstrappingSupply() external view returns (uint256);\\n\\n    /// @notice Total supply created through minting via the reserve (`Motherboard.mint()`).\\n    /// Excludes supply created for bootstrapping.\\n    /// @dev Reverts if bootstrappingSupply() > totalSupply(), but this never happens, assuming\\n    /// that governance consistently calls setBootstrappingSupply() with minting/burning\\n    /// bootstrapping supply.\\n    function mintedSupply() external view returns (uint256);\\n\\n    /// @notice Set bootstrappingSupply. Only to be used by governance when setting up / unwinding\\n    /// bootstrapping pools.\\n    function setBootstrappingSupply(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"IGYDToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"IERC20Upgradeable.sol\\\";\\n\\n/// @notice IGYDToken is the GYD token contract\\ninterface IGYDToken is IERC20Upgradeable {\\n    event MinterAdded(address indexed minter);\\n    event MinterRemoved(address indexed minter);\\n\\n    /// @notice Adds an address allowed to mint new GYD tokens\\n    /// @param _minter the address of the authorized minter\\n    function addMinter(address _minter) external;\\n\\n    /// @notice Removes an address allowed to mint new GYD tokens\\n    /// @param _minter the address of the authorized minter\\n    function removeMinter(address _minter) external;\\n\\n    /// @return the addresses of the authorized minters\\n    function listMinters() external returns (address[] memory);\\n\\n    /// @notice Mints `amount` of GYD token for `account`\\n    function mint(address account, uint256 amount) external;\\n\\n    /// @notice Burns `amount` of GYD token\\n    function burn(uint256 amount) external;\\n\\n    /// @notice Burns `amount` of GYD token from `account`\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"IReserve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\n/// @notice IReserve allows an authorized contract to deposit and withdraw tokens\\ninterface IReserve {\\n    event Deposit(address indexed from, address indexed token, uint256 amount);\\n    event Withdraw(address indexed from, address indexed token, uint256 amount);\\n\\n    event ManagerAdded(address indexed manager);\\n    event ManagerRemoved(address indexed manager);\\n\\n    /// @notice the address of the reserve managers, the only entities allowed to withdraw\\n    /// from this reserve\\n    function managers() external view returns (address[] memory);\\n\\n    /// @notice Adds a manager, who will be allowed to withdraw from this reserve\\n    function addManager(address manager) external;\\n\\n    /// @notice Removes manager\\n    function removeManager(address manager) external;\\n\\n    /// @notice Deposits vault tokens in the reserve\\n    /// @param token address of the vault tokens\\n    /// @param amount amount of the vault tokens to deposit\\n    function depositToken(address token, uint256 amount) external;\\n\\n    /// @notice Withdraws vault tokens from the reserve\\n    /// @param token address of the vault tokens\\n    /// @param amount amount of the vault tokens to deposit\\n    function withdrawToken(address token, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"IPAMM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"DataTypes.sol\\\";\\nimport \\\"Governable.sol\\\";\\n\\n/// @title IPAMM is the pricing contract for the Primary Market\\ninterface IPAMM {\\n    /// @notice this event is emitted when the system parameters are updated\\n    event SystemParamsUpdated(uint64 alphaBar, uint64 xuBar, uint64 thetaBar, uint64 outflowMemory);\\n\\n    // NB gas optimization, don't need to use uint64\\n    struct Params {\\n        uint64 alphaBar; // \u1fb1 \u220a [0,1]\\n        uint64 xuBar; // x\u0304_U \u220a [0,1]\\n        uint64 thetaBar; // \u03b8\u0304 \u220a [0,1]\\n        uint64 outflowMemory; // this is [0,1]\\n    }\\n\\n    /// @notice Quotes the amount of GYD to mint for the given USD amount\\n    /// @param usdAmount the USD value to add to the reserve\\n    /// @param reserveUSDValue the current USD value of the reserve\\n    /// @return the amount of GYD to mint\\n    function computeMintAmount(\\n        uint256 usdAmount,\\n        uint256 reserveUSDValue\\n    ) external view returns (uint256);\\n\\n    /// @notice Quotes and records the amount of GYD to mint for the given USD amount.\\n    /// NB that reserveUSDValue is added here to future proof the implementation\\n    /// @param usdAmount the USD value to add to the reserve\\n    /// @return the amount of GYD to mint\\n    function mint(uint256 usdAmount, uint256 reserveUSDValue) external returns (uint256);\\n\\n    /// @notice Quotes the output USD value given an amount of GYD\\n    /// @param gydAmount the amount GYD to redeem\\n    /// @param reserveUSDValue total value of the reserve in USD. Can be pulled from\\n    /// ReserveManager.getReserveState()\\n    /// @return the USD value to redeem\\n    function computeRedeemAmount(\\n        uint256 gydAmount,\\n        uint256 reserveUSDValue\\n    ) external view returns (uint256);\\n\\n    /// @notice Current redemption level\\n    function getRedemptionLevel() external view returns (uint256);\\n\\n    /// @notice Quotes and records the output USD value given an amount of GYD\\n    /// @param gydAmount the amount GYD to redeem\\n    /// @param reserveUSDValue total value of the reserve in USD. Can be pulled from\\n    /// ReserveManager.getReserveState()\\n    /// @return the USD value to redeem\\n    function redeem(uint256 gydAmount, uint256 reserveUSDValue) external returns (uint256);\\n\\n    /// @notice Allows for the system parameters to be updated\\n    function setSystemParams(Params memory params) external;\\n\\n    /// @notice Retrieves the system parameters to be updated\\n    function systemParams() external view returns (Params memory);\\n\\n    /// @notice Internal value that may be useful to predict the state of the system under\\n    /// different scenarios. This value is the 'anchor reserve value', normalized to 'anchor GYD\\n    /// supply' = 1.\\n    /// @dev This function extends the meaning of the anchor reserve value to cases where it's not\\n    /// formally defined as follows. Let r be the current reserve value, discounted by the\\n    /// configured redeem discount ratio.\\n    /// - If r >= 1, this returns 1.\\n    /// - If thetaBar < r < 1, this returns the normalized anchor reserve value like in the PAMM\\n    ///   mathematics paper.\\n    /// - If r <= thetaBar, this returns r.\\n    /// Note that, in the two edge cases, the mapping is not 1:1 and the anchor reserve value is not\\n    /// actually used by the PAMM to compute redemption amounts.\\n    function getNormalizedAnchoredReserveValue(uint256 reserveUSDValue) external view returns (uint256);\\n\\n    /// @notice Like computeRedeemAmount(gydAmount, reserveUSDValue) but at a hypothetical different\\n    /// starting state. This can be used to simulate the impact of different changes to the system\\n    /// state, e.g., prior redemptions or time passing.\\n    /// @param reserveUSDValue hypothetical total value of the reserve in USD.\\n    /// @param redemptionLevel hypothetical redemption level.\\n    /// @param totalGyroSupply hypothetical value of gydToken.totalSupply().\\n    function getNormalizedAnchoredReserveValueAtState(\\n        uint256 reserveUSDValue,\\n        uint256 redemptionLevel,\\n        uint256 totalGyroSupply\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"IReserveManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"IVaultWeightManager.sol\\\";\\nimport \\\"IUSDPriceOracle.sol\\\";\\nimport \\\"DataTypes.sol\\\";\\n\\ninterface IReserveManager {\\n    event NewVaultWeightManager(address indexed oldManager, address indexed newManager);\\n    event NewPriceOracle(address indexed oldOracle, address indexed newOracle);\\n\\n    /// @notice Returns a list of vaults including metadata such as price and weights\\n    function getReserveState() external view returns (DataTypes.ReserveState memory);\\n}\\n\"\r\n    },\r\n    \"IVaultWeightManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\ninterface IVaultWeightManager {\\n    /// @notice Retrieves the weight of the given vault\\n    function getVaultWeight(address _vault) external view returns (uint256);\\n\\n    /// @notice Retrieves the weights of the given vaults\\n    function getVaultWeights(address[] calldata _vaults) external view returns (uint256[] memory);\\n\\n    /// @notice Sets the weight of the given vault\\n    function setVaultWeight(address _vault, uint256 _weight) external;\\n}\\n\"\r\n    },\r\n    \"IUSDPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\ninterface IUSDPriceOracle {\\n    /// @notice Quotes the USD price of `tokenAddress`\\n    /// The quoted price is always scaled with 18 decimals regardless of the\\n    /// source used for the oracle.\\n    /// @param tokenAddress the asset of which the price is to be quoted\\n    /// @return the USD price of the asset\\n    function getPriceUSD(address tokenAddress) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"IFeeHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"DataTypes.sol\\\";\\n\\ninterface IFeeHandler {\\n    /// @return an order with the fees applied\\n    function applyFees(DataTypes.Order memory order) external view returns (DataTypes.Order memory);\\n\\n    /// @return if the given vault is supported\\n    function isVaultSupported(address vaultAddress) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IGydRecovery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"DataTypes.sol\\\";\\n\\n/// @title IGydRecovery is a recovery module where providers lock GYD, which are burned in the event of a reserve shortfall. It supports a version of liquidity mining.\\ninterface IGydRecovery {\\n    // TODO make this interface more complete for easier access & documentation. Stub right now.\\n\\n    /// @notice Checks whether the reserve experiences a shortfall and the safety module should run and then runs it if so. This is called internally but can also be called by anyone.\\n    /// @return didRun Whether the safety module ran.\\n    function checkAndRun() external returns (bool didRun);\\n\\n    /// @notice Whether the reserve should run under current conditions, i.e., whether it would run if `checkAndRun()` was called.\\n    function shouldRun() external view returns (bool);\\n\\n    /// @notice Variant of checkAndRun() where the reserve state is passed in; only callable by Motherboard.\\n    function checkAndRun(DataTypes.ReserveState memory reserveState) external returns (bool didRun);\\n}\\n\"\r\n    },\r\n    \"IReserveStewardshipIncentives.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.0;\\n\\nimport \\\"DataTypes.sol\\\";\\n\\n/// @notice IReserveStewardshipIncentives lets governance set up *incentive initiatives* that reward the governance treasury, in GYD, for continued high reserve ratios and GYD supply.\\ninterface IReserveStewardshipIncentives {\\n    // TODO stub, to be expanded with view methods etc.\\n\\n    event InitiativeStarted(uint256 endTime, uint256 minCollateralRatio, uint256 rewardPercentage);\\n    event InitiativeCanceled();\\n    event InitiativeCompleted(uint256 startTime, uint256 rewardGYDAmount);\\n\\n    /// @notice Create new incentive initiative.\\n    /// @param rewardPercentage Share of the average GYD supply over time that should be paid as a reward. How much *will* actually be paid will also depend on the system state when the incentive is completed.\\n    function startInitiative(uint256 rewardPercentage) external;\\n\\n    /// @notice Cancel the active initiative without claming rewards\\n    function cancelInitiative() external;\\n\\n    /// @notice Complete the active initiative and claim rewards. Rewards are sent to the governance treasury address.\\n    /// The initiative period must have passed while the reserve health conditions have held, and they must currently\\n    /// still hold. Callable by anyone.\\n    function completeInitiative() external;\\n\\n    /// @notice Update the internally tracked variables. Called internally but can also be called by anyone.\\n    function checkpoint() external;\\n\\n    /// @notice Variant of `checkpoint()` where the reserve state is passed in; only callable by Motherboard.\\n    function checkpoint(DataTypes.ReserveState memory reserveState) external;\\n\\n    /// @notice Whether there is an active initiative.\\n    function hasActiveInitiative() external view returns (bool);\\n\\n    /// @notice Whether the initiative has already failed. This does *not* include any information based on the current\\n    /// state that would be included when `checkpoint()` is called. `false` if there is no active initiative.\\n    function hasFailed() external view returns (bool);\\n\\n    /// @notice Rewards (in GYD) that the governance treasury would receive if the initiative had ended and\\n    /// `completeInitiative()` was called now.\\n    function tentativeRewards() external view returns (uint256 gydAmount);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"VaultSafetyMode.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gyroConfig\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorChangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"durationOfProtectionInBlocks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"inFlows\",\"type\":\"bool\"}],\"name\":\"OracleGuardianActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"err\",\"type\":\"string\"}],\"name\":\"SafetyStatus\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"THRESHOLD_BUFFER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"enum DataTypes.Direction\",\"name\":\"direction\",\"type\":\"uint8\"}],\"internalType\":\"struct DataTypes.GuardedVaults\",\"name\":\"vaultToProtect\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"activateOracleGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressToAdd\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"priceAtCalibration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightAtCalibration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortFlowMemory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortFlowThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"weightTransitionDuration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"weightAtPreviousCalibration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timeOfCalibration\",\"type\":\"uint64\"}],\"internalType\":\"struct DataTypes.PersistedVaultMetadata\",\"name\":\"persistedMetadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetWeight\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isStable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"floor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceiling\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.Range\",\"name\":\"priceRange\",\"type\":\"tuple\"}],\"internalType\":\"struct DataTypes.PricedToken[]\",\"name\":\"pricedTokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct DataTypes.VaultInfo\",\"name\":\"vaultInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.VaultWithAmount[]\",\"name\":\"vaultsWithAmount\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"mint\",\"type\":\"bool\"}],\"internalType\":\"struct DataTypes.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"checkAndPersistMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"priceAtCalibration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightAtCalibration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortFlowMemory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortFlowThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"weightTransitionDuration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"weightAtPreviousCalibration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timeOfCalibration\",\"type\":\"uint64\"}],\"internalType\":\"struct DataTypes.PersistedVaultMetadata\",\"name\":\"persistedMetadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetWeight\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isStable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"floor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceiling\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.Range\",\"name\":\"priceRange\",\"type\":\"tuple\"}],\"internalType\":\"struct DataTypes.PricedToken[]\",\"name\":\"pricedTokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct DataTypes.VaultInfo\",\"name\":\"vaultInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.VaultWithAmount[]\",\"name\":\"vaultsWithAmount\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"mint\",\"type\":\"bool\"}],\"internalType\":\"struct DataTypes.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"checkAndPersistRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPersistedFlowData\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"shortFlow\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastSafetyBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastSeenBlock\",\"type\":\"uint64\"}],\"internalType\":\"struct DataTypes.DirectionalFlowData\",\"name\":\"inFlow\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"shortFlow\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastSafetyBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastSeenBlock\",\"type\":\"uint64\"}],\"internalType\":\"struct DataTypes.DirectionalFlowData\",\"name\":\"outFlow\",\"type\":\"tuple\"}],\"internalType\":\"struct DataTypes.FlowData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhitelist\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gyroConfig\",\"outputs\":[{\"internalType\":\"contract IGyroConfig\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"priceAtCalibration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightAtCalibration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortFlowMemory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortFlowThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"weightTransitionDuration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"weightAtPreviousCalibration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timeOfCalibration\",\"type\":\"uint64\"}],\"internalType\":\"struct DataTypes.PersistedVaultMetadata\",\"name\":\"persistedMetadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetWeight\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isStable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"floor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceiling\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.Range\",\"name\":\"priceRange\",\"type\":\"tuple\"}],\"internalType\":\"struct DataTypes.PricedToken[]\",\"name\":\"pricedTokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct DataTypes.VaultInfo\",\"name\":\"vaultInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.VaultWithAmount[]\",\"name\":\"vaultsWithAmount\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"mint\",\"type\":\"bool\"}],\"internalType\":\"struct DataTypes.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"isMintSafe\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"err\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"priceAtCalibration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightAtCalibration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortFlowMemory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortFlowThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"weightTransitionDuration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"weightAtPreviousCalibration\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timeOfCalibration\",\"type\":\"uint64\"}],\"internalType\":\"struct DataTypes.PersistedVaultMetadata\",\"name\":\"persistedMetadata\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetWeight\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isStable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"floor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceiling\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.Range\",\"name\":\"priceRange\",\"type\":\"tuple\"}],\"internalType\":\"struct DataTypes.PricedToken[]\",\"name\":\"pricedTokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct DataTypes.VaultInfo\",\"name\":\"vaultInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.VaultWithAmount[]\",\"name\":\"vaultsWithAmount\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"mint\",\"type\":\"bool\"}],\"internalType\":\"struct DataTypes.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"isRedeemSafe\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"err\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"depositsOnly\",\"type\":\"bool\"}],\"name\":\"pauseProtocol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"persistedFlowData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"shortFlow\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastSafetyBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastSeenBlock\",\"type\":\"uint64\"}],\"internalType\":\"struct DataTypes.DirectionalFlowData\",\"name\":\"inFlow\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"shortFlow\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastSafetyBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastSeenBlock\",\"type\":\"uint64\"}],\"internalType\":\"struct DataTypes.DirectionalFlowData\",\"name\":\"outFlow\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressToRemove\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VaultSafetyMode", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004f244fcaff67a2f98eaec20a44caf079a7f7a1d4000000000000000000000000ac89cc9d78bbad7eb3a02601b4d65daa1f908aa6", "EVMVersion": "london", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}