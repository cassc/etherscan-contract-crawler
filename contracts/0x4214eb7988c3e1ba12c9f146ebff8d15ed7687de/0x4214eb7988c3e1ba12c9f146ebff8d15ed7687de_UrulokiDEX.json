{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/UrulokiDex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n// Uruloki DEX is NOT LICENSED FOR COPYING.\\r\\n// Uruloki DEX (C) 2022. All Rights Reserved.\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\ninterface IUniswapV2Router {\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function getAmountsOut(\\r\\n        uint amountIn,\\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    function getPair(\\r\\n        address tokenA, \\r\\n        address tokenB\\r\\n    ) external view returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IOrderMgr {\\r\\n    //// Define enums\\r\\n    enum OrderType {\\r\\n        TargetPrice,\\r\\n        PriceRange\\r\\n    }\\r\\n    enum OrderStatus {\\r\\n        Active,\\r\\n        Cancelled,\\r\\n        OutOfFunds,\\r\\n        Completed\\r\\n    }\\r\\n\\r\\n    //// Define structs\\r\\n    // One time order, it's a base order struct\\r\\n    struct OrderBase {\\r\\n        address userAddress;\\r\\n        address pairedTokenAddress;\\r\\n        address tokenAddress;\\r\\n        OrderType orderType;\\r\\n        uint256 targetPrice;\\r\\n        bool isBuy;\\r\\n        uint256 maxPrice;\\r\\n        uint256 minPrice;\\r\\n        OrderStatus status;\\r\\n        uint256 amount;\\r\\n        uint256 slippage;\\r\\n        bool isContinuous;\\r\\n    }\\r\\n\\r\\n    // Continuous Order, it's an extended order struct, including the base order struct\\r\\n    struct Order {\\r\\n        OrderBase orderBase;\\r\\n        uint256 numExecutions;\\r\\n        uint256 resetPercentage;\\r\\n        bool hasPriceReset;\\r\\n    }\\r\\n\\r\\n    function createOneTimeOrder(\\r\\n        address userAddress,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 targetPrice,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 slippage\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function createContinuousOrder(\\r\\n        address userAddress,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 targetPrice,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 slippage,\\r\\n        uint256 resetPercentage\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function updateOrder(\\r\\n        uint256 orderId,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 targetPrice,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 slippage,\\r\\n        uint256 resetPercentage\\r\\n    ) external;\\r\\n\\r\\n    function cancelOrder(uint256 orderId) external returns (uint256);\\r\\n\\r\\n    function orderCounter() external view returns (uint256);\\r\\n\\r\\n    function getOrder(uint256 orderId) external view returns (Order memory);\\r\\n\\r\\n    function setOrderStatus(\\r\\n        uint256 orderId,\\r\\n        IOrderMgr.OrderStatus status\\r\\n    ) external;\\r\\n\\r\\n    function incNumExecutions(uint256 orderId) external;\\r\\n\\r\\n    function setHasPriceReset(uint256 orderId, bool flag) external;\\r\\n}\\r\\n\\r\\ninterface IERC20Ext is IERC20 {\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\ncontract UrulokiDEX is ReentrancyGuard {\\r\\n    //// Define events\\r\\n    // Event emitted when a one-time order is created\\r\\n    event OneTimeOrderCreated(uint256 orderId);\\r\\n\\r\\n    // Event emitted when a continuous order is created\\r\\n    event ContinuousOrderCreated(uint256 orderId);\\r\\n\\r\\n    // Event emitted when a one-time order is edited\\r\\n    event OneTimeOrderEdited(uint256 orderId);\\r\\n\\r\\n    // Event emitted when a continuous order is edited\\r\\n    event ContinuousOrderEdited(uint256 orderId);\\r\\n\\r\\n    // Event emitted when an order is canceled\\r\\n    event OrderCanceled(uint256 orderId);\\r\\n\\r\\n    // Event emitted when the price is outside of the specified price range\\r\\n    event ExecutedOutOfPrice(uint256 orderId, bool isBuy, uint256 price);\\r\\n\\r\\n    // Event emitted when a one-time order is successfully executed\\r\\n    event ExecutedOneTimeOrder(\\r\\n        uint256 orderId,\\r\\n        bool isBuy,\\r\\n        uint256 pairAmount,\\r\\n        uint256 tokenAmount,\\r\\n        uint256 price\\r\\n    );\\r\\n\\r\\n    // Event emitted when a continuous order is successfully executed\\r\\n    event ExecutedContinuousOrder(\\r\\n        uint256 orderId,\\r\\n        bool isBuy,\\r\\n        uint256 price\\r\\n    );\\r\\n\\r\\n    // Event emitted when funds are withdrawn from a user's address\\r\\n    event FundsWithdrawn(\\r\\n        address userAddress,\\r\\n        address tokenAddress,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    // Event emitted when the owner of the contract is changed\\r\\n    event BackendOwner(address newOwner);\\r\\n\\r\\n    // Event emitted when an order is out of funds\\r\\n    event OutOfFunds(uint256 orderId);\\r\\n\\r\\n    // Event emitted when a swap during order execution fails\\r\\n    event SwapFailed(uint256 orderId);\\r\\n\\r\\n    // This event is emitted when no valid pairs for USDC, USDT, TSUKA, or WETH are found for the specified order\\r\\n    event PairNotFound(uint256 orderId);\\r\\n\\r\\n    //// Define constants\\r\\n    address private constant UNISWAP_V2_ROUTER =\\r\\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n    address private constant UNISWAP_V2_FACTORY =\\r\\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\\r\\n    address private constant WETH =\\r\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n    address private constant USDT =\\r\\n        0xc28ab4E347dd26C5809540e7dB0CEa473D91439c;\\r\\n    address private constant USDC =\\r\\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\r\\n    address private constant TSUKA =\\r\\n        0xc5fB36dd2fb59d3B98dEfF88425a3F425Ee469eD;\\r\\n\\r\\n    //// Define variables\\r\\n    mapping(address => mapping(address => uint256)) public balances;\\r\\n\\r\\n    IUniswapV2Router private uniswapRouter =\\r\\n        IUniswapV2Router(UNISWAP_V2_ROUTER);\\r\\n    IUniswapV2Factory private uniswapFactory =\\r\\n        IUniswapV2Factory(UNISWAP_V2_FACTORY);\\r\\n\\r\\n    address public backend_owner;\\r\\n    address public orderMgrAddress;\\r\\n    IOrderMgr _orderMgr;\\r\\n\\r\\n    constructor() {\\r\\n        backend_owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier initOneTimeOrderBalance (\\r\\n        uint256 orderId\\r\\n    ) {\\r\\n        IOrderMgr.Order memory order = _orderMgr.getOrder(orderId);\\r\\n\\r\\n        // Validate order owner\\r\\n        require(\\r\\n            order.orderBase.userAddress == msg.sender,\\r\\n            \\\"msg.sender is not order owner\\\"\\r\\n        );\\r\\n\\r\\n        // Check if the order is a one-time order\\r\\n        require(order.orderBase.isContinuous == false, \\\"Incorrect order type\\\");\\r\\n\\r\\n        // Check if the order status is active\\r\\n        require(order.orderBase.status == IOrderMgr.OrderStatus.Active, \\\"Incorrect order status\\\");\\r\\n\\r\\n        // Update the balances based on the order type\\r\\n        if(!order.orderBase.isBuy) {\\r\\n            balances[msg.sender][order.orderBase.tokenAddress] += order.orderBase.amount;\\r\\n        } else {\\r\\n            balances[msg.sender][order.orderBase.pairedTokenAddress] += order.orderBase.amount;\\r\\n        }\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Validates a one-time order by checking the user's balance and updating it if necessary\\r\\n     * @param pairedTokenAddress The address of the paired token\\r\\n     * @param tokenAddress The address of the token\\r\\n     * @param isBuy Boolean indicating if it's a buy order\\r\\n     * @param amount The amount of tokens in the order\\r\\n     * @return bool Returns true if the order is valid, false otherwise\\r\\n     */\\r\\n    function validateOneTimeOrder(\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        // if buying token, pair token is spendable else if sell, the token is spendable\\r\\n        if (!isBuy) {\\r\\n            // Check if the user has enough balance\\r\\n            if(balances[msg.sender][tokenAddress] >= amount) {\\r\\n                // Update the user's balance\\r\\n                balances[msg.sender][tokenAddress] -= amount;\\r\\n            } else \\r\\n                return false;\\r\\n        } else {\\r\\n            // Check if the user has enough balance\\r\\n            if(balances[msg.sender][pairedTokenAddress] >= amount) {\\r\\n                // Update the user's balance\\r\\n                balances[msg.sender][pairedTokenAddress] -= amount;\\r\\n            } else \\r\\n                return false;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // set backend owner address\\r\\n    function setBackendOwner(address new_owner) public {\\r\\n        require(msg.sender == backend_owner, \\\"Not admin\\\");\\r\\n        backend_owner = new_owner;\\r\\n        emit BackendOwner(backend_owner);\\r\\n    }\\r\\n\\r\\n    function setOrderMgr(address _orderMgrAddress) public {\\r\\n        require(msg.sender == backend_owner, \\\"setOrderMgr: not allowed\\\");\\r\\n        require(\\r\\n            _orderMgrAddress != address(0),\\r\\n            \\\"setOrderMgr: invalid orderMgrAddress\\\"\\r\\n        );\\r\\n        orderMgrAddress = _orderMgrAddress;\\r\\n        _orderMgr = IOrderMgr(_orderMgrAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice allows users to make a deposit\\r\\n     * @dev token should be transferred from the user wallet to the contract\\r\\n     * @param tokenAddress token address\\r\\n     * @param amount deposit amount\\r\\n     */\\r\\n    function addFunds(\\r\\n        address tokenAddress,\\r\\n        uint256 amount\\r\\n    ) external nonReentrant {\\r\\n        require(amount > 0, \\\"Amount must be greater than zero\\\");\\r\\n\\r\\n        IERC20 token = IERC20(tokenAddress);\\r\\n        uint256 balanceBefore = token.balanceOf(address(this));\\r\\n\\r\\n        require(\\r\\n            token.transferFrom(msg.sender, address(this), amount),\\r\\n            \\\"Transfer failed\\\"\\r\\n        );\\r\\n\\r\\n        // Update the user's balance\\r\\n        balances[USDT][tokenAddress] += token.balanceOf(address(this)) - balanceBefore;\\r\\n        balances[msg.sender][tokenAddress] = balances[USDT][tokenAddress];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev funds withdrawal external call\\r\\n     * @param tokenAddress token address\\r\\n     * @param amount token amount\\r\\n     */\\r\\n    function withdrawFunds(\\r\\n        address tokenAddress,\\r\\n        uint256 amount\\r\\n    ) external nonReentrant {\\r\\n        require(amount > 0, \\\"Amount must be greater than zero\\\");\\r\\n\\r\\n        // Check if the user has enough balance to withdraw\\r\\n        require(\\r\\n            balances[msg.sender][tokenAddress] >= amount,\\r\\n            \\\"Insufficient balance\\\"\\r\\n        );\\r\\n\\r\\n        // Update the user's balance\\r\\n        balances[msg.sender][tokenAddress] -= amount;\\r\\n\\r\\n        // Transfer ERC20 token to the user\\r\\n        IERC20 token = IERC20(tokenAddress);\\r\\n        require(token.transfer(msg.sender, amount), \\\"Transfer failed\\\");\\r\\n        // Emit event\\r\\n        emit FundsWithdrawn(msg.sender, tokenAddress, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice create non-continuous price range order\\r\\n     * @dev The orders are only executed when the market price is less than or equal to the minPrice and greater than or equal to the maxPrice\\r\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\r\\n     * @param tokenAddress The address of the token being traded\\r\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\r\\n     * @param minPrice Minimum price for the order. The value's decimal is in USDC decimal 6 format\\r\\n     * @param maxPrice Maximum price for the order. The value's decimal is in USDC decimal 6 format\\r\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\r\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\r\\n     */\\r\\n    function createNonContinuousPriceRangeOrder(\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 slippage\\r\\n    )   external nonReentrant {\\r\\n        require(validateOneTimeOrder(pairedTokenAddress, tokenAddress, isBuy, amount), \\\"Validation failed\\\");\\r\\n\\r\\n        uint256 id = _orderMgr.createOneTimeOrder(\\r\\n            msg.sender,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            0,\\r\\n            minPrice,\\r\\n            maxPrice,\\r\\n            amount,\\r\\n            slippage\\r\\n        );\\r\\n        // Emit an event\\r\\n        emit OneTimeOrderCreated(id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice creates a non-continuous order with a target price\\r\\n     * @dev Target price orders are only executed when certain conditions are met:\\r\\n     * - For buy orders, the market price must be less than or equal to the target price\\r\\n     * - For sell orders, the market price must be greater than or equal to the target price\\r\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\r\\n     * @param tokenAddress The address of the token being traded\\r\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\r\\n     * @param targetPrice The target price for the order. The value's decimal is in USDC decimal 6 format\\r\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\r\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\r\\n     */\\r\\n    function createNonContinuousTargetPriceOrder(\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 targetPrice,\\r\\n        uint256 amount,\\r\\n        uint256 slippage\\r\\n    )   external nonReentrant {\\r\\n        require(validateOneTimeOrder(pairedTokenAddress, tokenAddress, isBuy, amount), \\\"Validation failed\\\");\\r\\n\\r\\n        // Create a new order\\r\\n        uint256 id = _orderMgr.createOneTimeOrder(\\r\\n            msg.sender,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            targetPrice,\\r\\n            0,\\r\\n            0,\\r\\n            amount,\\r\\n            slippage\\r\\n        );\\r\\n\\r\\n        // Emit event\\r\\n        emit OneTimeOrderCreated(id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice creates a continuous order with price range\\r\\n     * @dev The orders are only executed continuely when the market price is less than or equal to the minPrice and greater than or equal to the maxPrice\\r\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\r\\n     * @param tokenAddress The address of the token being traded\\r\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\r\\n     * @param minPrice Minimum price for the order. The value's decimal is in USDC decimal 6 format\\r\\n     * @param maxPrice Maximum price for the order. The value's decimal is in USDC decimal 6 format\\r\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\r\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\r\\n     * @param resetPercentage decimal represented as an int with 0 places of precision\\r\\n     */\\r\\n    function createContinuousPriceRangeOrder(\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 slippage,\\r\\n        uint256 resetPercentage\\r\\n    ) external nonReentrant {\\r\\n        uint256 id = _orderMgr.createContinuousOrder(\\r\\n            msg.sender,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            0,\\r\\n            minPrice,\\r\\n            maxPrice,\\r\\n            amount,\\r\\n            slippage,\\r\\n            resetPercentage\\r\\n        );\\r\\n\\r\\n        // Emit an event\\r\\n        emit ContinuousOrderCreated(id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice creates a continuous order with a target price\\r\\n     * @dev The orders are only executed continuely when certain conditions are met:\\r\\n     * - For buy orders, the market price must be less than or equal to the target price\\r\\n     * - For sell orders, the market price must be greater than or equal to the target price\\r\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\r\\n     * @param tokenAddress The address of the token being traded\\r\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\r\\n     * @param targetPrice The target price for the order. The value's decimal is in USDC decimal 6 format\\r\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\r\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\r\\n     * @param resetPercentage decimal represented as an int with 0 places of precision\\r\\n     */\\r\\n    function createContinuousTargetPriceOrder(\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 targetPrice,\\r\\n        uint256 amount,\\r\\n        uint256 slippage,\\r\\n        uint256 resetPercentage\\r\\n    ) external nonReentrant {\\r\\n        // Create the ContinuousOrder struct\\r\\n        uint256 id = _orderMgr.createContinuousOrder(\\r\\n            msg.sender,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            targetPrice,\\r\\n            0,\\r\\n            0,\\r\\n            amount,\\r\\n            slippage,\\r\\n            resetPercentage\\r\\n        );\\r\\n\\r\\n        // Emit an event\\r\\n        emit ContinuousOrderCreated(id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev cancel exist order\\r\\n     * @param orderId order id\\r\\n     */\\r\\n    function cancelOrder(uint256 orderId) external {\\r\\n        // Validate order owner\\r\\n        IOrderMgr.Order memory order = _orderMgr.getOrder(orderId);\\r\\n        require(\\r\\n            order.orderBase.userAddress == msg.sender,\\r\\n            \\\"msg.sender is not order owner\\\"\\r\\n        );\\r\\n\\r\\n        _orderMgr.cancelOrder(orderId);\\r\\n        if (!order.orderBase.isContinuous)\\r\\n            if (order.orderBase.isBuy) {\\r\\n                balances[msg.sender][order.orderBase.pairedTokenAddress] += order\\r\\n                    .orderBase\\r\\n                    .amount;\\r\\n            } else {\\r\\n                balances[msg.sender][order.orderBase.tokenAddress] += order\\r\\n                    .orderBase\\r\\n                    .amount;\\r\\n            }\\r\\n\\r\\n        // Emit event\\r\\n        emit OrderCanceled(orderId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice process a one-time order\\r\\n     * @dev internal function\\r\\n     * @param orderId id of the order\\r\\n     */\\r\\n    function _processOneTimeOrder(IOrderMgr.Order memory order, uint256 orderId) internal returns (bool) {\\r\\n        // Get the price in amount\\r\\n        uint256 price = _getPairPrice(\\r\\n            order.orderBase.tokenAddress,\\r\\n            10 ** IERC20Ext(order.orderBase.tokenAddress).decimals()\\r\\n        );\\r\\n        \\r\\n        if(price == 0) {\\r\\n            emit PairNotFound(orderId);\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        address fromToken;\\r\\n        address toToken;\\r\\n        uint256 toAmount;\\r\\n        bool swapStatus;\\r\\n\\r\\n        // Check if the order type is PriceRange\\r\\n        if (order.orderBase.orderType == IOrderMgr.OrderType.PriceRange) {\\r\\n            if (\\r\\n                order.orderBase.minPrice > price || price > order.orderBase.maxPrice\\r\\n            ) {\\r\\n                emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (order.orderBase.isBuy) {\\r\\n            // Check if the order type is TargetPrice\\r\\n            if (order.orderBase.orderType == IOrderMgr.OrderType.TargetPrice) {\\r\\n                if (\\r\\n                    price > order.orderBase.targetPrice\\r\\n                ) {\\r\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                    return false;\\r\\n                }\\r\\n            }\\r\\n            fromToken = order.orderBase.pairedTokenAddress;\\r\\n            toToken = order.orderBase.tokenAddress;\\r\\n        } else {\\r\\n            // Check if the order type is TargetPrice\\r\\n            if (order.orderBase.orderType == IOrderMgr.OrderType.TargetPrice) {\\r\\n                if (price < order.orderBase.targetPrice) {\\r\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                    return false;\\r\\n                }\\r\\n            }\\r\\n            fromToken = order.orderBase.tokenAddress;\\r\\n            toToken = order.orderBase.pairedTokenAddress;\\r\\n        }\\r\\n\\r\\n        (toAmount, swapStatus) = _swapTokens(\\r\\n            fromToken, \\r\\n            toToken, \\r\\n            order.orderBase.amount,\\r\\n            order.orderBase.slippage\\r\\n        );\\r\\n\\r\\n        if(swapStatus) {\\r\\n            balances[order.orderBase.userAddress][toToken] += toAmount;\\r\\n\\r\\n            _orderMgr.setOrderStatus(orderId, IOrderMgr.OrderStatus.Completed);\\r\\n            emit ExecutedOneTimeOrder(\\r\\n                orderId,\\r\\n                order.orderBase.isBuy,\\r\\n                order.orderBase.amount,\\r\\n                toAmount,\\r\\n                price\\r\\n            );\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            emit SwapFailed(orderId);\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice process a continuous order\\r\\n     * @dev internal function\\r\\n     * @param orderId id of the order\\r\\n     */\\r\\n    function _processContinuousOrder(IOrderMgr.Order memory order, uint256 orderId) internal returns (bool){\\r\\n        if (order.orderBase.targetPrice == 0) {\\r\\n            // Price range order\\r\\n            return _processContinuousPriceRangeOrder(order, orderId);\\r\\n        } else {\\r\\n            // Target price order\\r\\n            return _processContinuousTargetPriceOrder(order, orderId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to process a continuous price range order\\r\\n     * @param order The order memory instance\\r\\n     * @param orderId Order ID\\r\\n     * @return bool Returns true if the order is processed successfully, false otherwise\\r\\n     */\\r\\n    function _processContinuousPriceRangeOrder(\\r\\n        IOrderMgr.Order memory order,\\r\\n        uint256 orderId\\r\\n    ) internal returns(bool) {\\r\\n        // Get the price in amount\\r\\n        uint256 price = _getPairPrice(\\r\\n            order.orderBase.tokenAddress,\\r\\n            10 ** IERC20Ext(order.orderBase.tokenAddress).decimals()\\r\\n        );\\r\\n\\r\\n        // Check if the price is not found for the pair\\r\\n        if(price == 0) {\\r\\n            emit PairNotFound(orderId);\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        // Check if the order has price reset\\r\\n        if (order.hasPriceReset) {\\r\\n            // Check if the price is within the specified range\\r\\n            if (\\r\\n                !(\\r\\n                price > order.orderBase.minPrice \\r\\n                && price < order.orderBase.maxPrice\\r\\n                )\\r\\n            ) {\\r\\n                emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                return false;\\r\\n            }\\r\\n            address fromToken;\\r\\n            address toToken;\\r\\n            uint256 toAmount;\\r\\n            bool swapStatus;\\r\\n\\r\\n            // Determine the tokens for swapping based on the order type\\r\\n            if (order.orderBase.isBuy) {\\r\\n                fromToken = order.orderBase.pairedTokenAddress;\\r\\n                toToken = order.orderBase.tokenAddress;\\r\\n            } else {\\r\\n                fromToken = order.orderBase.tokenAddress;\\r\\n                toToken = order.orderBase.pairedTokenAddress;\\r\\n            }\\r\\n\\r\\n            // Check if the user has enough balance of the fromToken\\r\\n            if (\\r\\n                balances[order.orderBase.userAddress][fromToken] >=\\r\\n                order.orderBase.amount\\r\\n            ) {\\r\\n                // Swap tokens\\r\\n                (toAmount, swapStatus) = _swapTokens(\\r\\n                    fromToken,\\r\\n                    toToken,\\r\\n                    order.orderBase.amount,\\r\\n                    order.orderBase.slippage\\r\\n                );\\r\\n\\r\\n                if(swapStatus) {\\r\\n                    // Update user's balances\\r\\n                    balances[order.orderBase.userAddress][toToken] += toAmount;\\r\\n                    balances[order.orderBase.userAddress][fromToken] -= order\\r\\n                        .orderBase\\r\\n                        .amount;\\r\\n                    \\r\\n                    // Update order status and execution count\\r\\n                    _orderMgr.setOrderStatus(orderId, IOrderMgr.OrderStatus.Active);\\r\\n                    _orderMgr.incNumExecutions(orderId);\\r\\n                    _orderMgr.setHasPriceReset(orderId, false);\\r\\n\\r\\n                    emit ExecutedContinuousOrder(orderId, order.orderBase.isBuy, price);\\r\\n                } else {\\r\\n                    emit SwapFailed(orderId);\\r\\n                }\\r\\n            } else {\\r\\n                // Set order status as out of funds\\r\\n                _orderMgr.setOrderStatus(\\r\\n                    orderId,\\r\\n                    IOrderMgr.OrderStatus.OutOfFunds\\r\\n                );\\r\\n                emit OutOfFunds(orderId);\\r\\n            }\\r\\n        } else {\\r\\n            // Calculate the lower and upper price differences based on the reset percentage\\r\\n            uint256 lowerDiff = (order.orderBase.minPrice *\\r\\n                order.resetPercentage) / 100;\\r\\n            uint256 upperDiff = (order.orderBase.maxPrice *\\r\\n                order.resetPercentage) / 100;\\r\\n\\r\\n            // Check if the price is outside the adjusted range\\r\\n            if (\\r\\n                !(price < order.orderBase.minPrice - lowerDiff\\r\\n                || price > order.orderBase.maxPrice + upperDiff)\\r\\n            ) {\\r\\n                return false;\\r\\n            }\\r\\n\\r\\n            // Set hasPriceReset to true for the order\\r\\n            _orderMgr.setHasPriceReset(orderId, true);\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Processes a continuous order with a target price\\r\\n     * @param order The order to process\\r\\n     * @param orderId The ID of the order\\r\\n     * @return bool Returns true if the order is successfully processed, false otherwise\\r\\n     */\\r\\n    function _processContinuousTargetPriceOrder(\\r\\n        IOrderMgr.Order memory order,\\r\\n        uint256 orderId\\r\\n    ) internal returns (bool) {\\r\\n        // Get the price in amount\\r\\n        uint256 price = _getPairPrice(\\r\\n            order.orderBase.tokenAddress,\\r\\n            10 ** IERC20Ext(order.orderBase.tokenAddress).decimals()\\r\\n        );\\r\\n\\r\\n        // Check if the price is 0, indicating that the pair does not exist\\r\\n        if(price == 0) {\\r\\n            emit PairNotFound(orderId);\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        // Check if the order is a buy order\\r\\n        if (order.orderBase.isBuy) {\\r\\n            // Check if the order has price reset\\r\\n            if (order.hasPriceReset) {\\r\\n                // Check if the current price is greater than the target price\\r\\n                if (price > order.orderBase.targetPrice) {\\r\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                    return false;\\r\\n                }\\r\\n\\r\\n                // Swap tokens and update balances\\r\\n                address fromToken;\\r\\n                address toToken;\\r\\n                uint256 toAmount;\\r\\n                bool swapStatus;\\r\\n\\r\\n                fromToken = order.orderBase.pairedTokenAddress;\\r\\n                toToken = order.orderBase.tokenAddress;\\r\\n\\r\\n                // Check if the user has sufficient balance of fromToken\\r\\n                if (\\r\\n                    balances[order.orderBase.userAddress][fromToken] >=\\r\\n                    order.orderBase.amount\\r\\n                ) {\\r\\n                    (toAmount, swapStatus) = _swapTokens(\\r\\n                        fromToken,\\r\\n                        toToken,\\r\\n                        order.orderBase.amount,\\r\\n                        order.orderBase.slippage\\r\\n                    );\\r\\n\\r\\n                    if(swapStatus) {\\r\\n                        // Update user's balances\\r\\n                        balances[order.orderBase.userAddress][toToken] += toAmount;\\r\\n                        balances[order.orderBase.userAddress][fromToken] -= order\\r\\n                            .orderBase\\r\\n                            .amount;\\r\\n\\r\\n                        // Update order status and execution count\\r\\n                        _orderMgr.setOrderStatus(\\r\\n                            orderId,\\r\\n                            IOrderMgr.OrderStatus.Active\\r\\n                        );\\r\\n                        _orderMgr.incNumExecutions(orderId);\\r\\n                        _orderMgr.setHasPriceReset(orderId, false);\\r\\n\\r\\n                        emit ExecutedContinuousOrder(orderId, order.orderBase.isBuy, price);\\r\\n                    } else {\\r\\n                        emit SwapFailed(orderId);\\r\\n                    }\\r\\n                } else {\\r\\n                    // Set order status as out of funds\\r\\n                    _orderMgr.setOrderStatus(\\r\\n                        orderId,\\r\\n                        IOrderMgr.OrderStatus.OutOfFunds\\r\\n                    );\\r\\n                    emit OutOfFunds(orderId);\\r\\n                }\\r\\n            } else {\\r\\n                uint256 diff = (order.orderBase.targetPrice *\\r\\n                    order.resetPercentage) / 100;\\r\\n\\r\\n                // Check if the current price is less than the target price plus the difference\\r\\n                if (price < order.orderBase.targetPrice + diff) {\\r\\n                    return false;\\r\\n                }\\r\\n                _orderMgr.setHasPriceReset(orderId, true);\\r\\n            }\\r\\n        } else {\\r\\n            // Check if the order has price reset\\r\\n            if (order.hasPriceReset) {\\r\\n                // Check if the current price is less than the target price\\r\\n                if (price < order.orderBase.targetPrice) {\\r\\n                    emit ExecutedOutOfPrice(orderId, order.orderBase.isBuy, price);\\r\\n                    return false;\\r\\n                }\\r\\n\\r\\n                // Swap tokens and update balances\\r\\n                address fromToken;\\r\\n                address toToken;\\r\\n                uint256 toAmount;\\r\\n                bool swapStatus;\\r\\n\\r\\n                fromToken = order.orderBase.tokenAddress;\\r\\n                toToken = order.orderBase.pairedTokenAddress;\\r\\n\\r\\n                // Check if the user has sufficient balance of fromToken\\r\\n                if (\\r\\n                    balances[order.orderBase.userAddress][fromToken] >=\\r\\n                    order.orderBase.amount\\r\\n                ) {\\r\\n                    (toAmount, swapStatus) = _swapTokens(\\r\\n                        fromToken,\\r\\n                        toToken,\\r\\n                        order.orderBase.amount,\\r\\n                        order.orderBase.slippage\\r\\n                    );\\r\\n\\r\\n                    if(swapStatus) {\\r\\n                        balances[order.orderBase.userAddress][toToken] += toAmount;\\r\\n                        balances[order.orderBase.userAddress][fromToken] -= order\\r\\n                            .orderBase\\r\\n                            .amount;\\r\\n\\r\\n                        _orderMgr.setOrderStatus(\\r\\n                            orderId,\\r\\n                            IOrderMgr.OrderStatus.Active\\r\\n                        );\\r\\n                        _orderMgr.incNumExecutions(orderId);\\r\\n                        _orderMgr.setHasPriceReset(orderId, false);\\r\\n\\r\\n                        emit ExecutedContinuousOrder(orderId, order.orderBase.isBuy, price);\\r\\n                    } else {\\r\\n                        emit SwapFailed(orderId);\\r\\n                    }\\r\\n                } else {\\r\\n                    _orderMgr.setOrderStatus(\\r\\n                        orderId,\\r\\n                        IOrderMgr.OrderStatus.OutOfFunds\\r\\n                    );\\r\\n                    emit OutOfFunds(orderId);\\r\\n                }\\r\\n            } else {\\r\\n                uint256 diff = (order.orderBase.targetPrice *\\r\\n                    order.resetPercentage) / 100;\\r\\n\\r\\n                // Check if the current price is greater than the target price minus the difference\\r\\n                if (price > order.orderBase.targetPrice - diff) {\\r\\n                    return false;\\r\\n                }\\r\\n                _orderMgr.setHasPriceReset(orderId, true);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Processes multiple orders based on the provided order IDs\\r\\n     * @param orderIds An array of order IDs to process\\r\\n     */\\r\\n    function processOrders(\\r\\n        uint256[] memory orderIds\\r\\n    ) external {\\r\\n        IOrderMgr.Order memory order;\\r\\n\\r\\n        // Iterate through each order ID in the orderIds array\\r\\n        for (uint256 i = 0; i < orderIds.length; i++) {\\r\\n            order = _orderMgr.getOrder(orderIds[i]);\\r\\n            uint256 orderId = orderIds[i];\\r\\n            \\r\\n            // Check if the tokenAddress of the order is the zero address\\r\\n            // If it is, skip to the next iteration of the loop\\r\\n            if (order.orderBase.tokenAddress == address(0))\\r\\n                continue;\\r\\n\\r\\n            // Check if the order is a continuous order\\r\\n            if (order.orderBase.isContinuous == true) {\\r\\n                // If the order is cancelled, skip to the next iteration of the loop\\r\\n                if (order.orderBase.status == IOrderMgr.OrderStatus.Cancelled)\\r\\n                    continue;\\r\\n                _processContinuousOrder(order, orderId);\\r\\n            } else {\\r\\n                // If the order is not active, skip to the next iteration of the loop\\r\\n                if (order.orderBase.status != IOrderMgr.OrderStatus.Active)\\r\\n                    continue;\\r\\n                _processOneTimeOrder(order, orderId);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Swaps tokens from one token to another using the Uniswap router\\r\\n     * @param _fromTokenAddress The address of the token to swap from\\r\\n     * @param _toTokenAddress The address of the token to swap to\\r\\n     * @param _amount The amount of tokens to swap\\r\\n     * @param _slippage The maximum acceptable slippage for the swap\\r\\n     * @return uint256 The amount of tokens received after the swap\\r\\n     * @return bool The status of the swap (true if successful, false otherwise)\\r\\n     */\\r\\n    function _swapTokens(\\r\\n        address _fromTokenAddress,\\r\\n        address _toTokenAddress,\\r\\n        uint256 _amount,\\r\\n        uint256 _slippage\\r\\n    ) internal returns (uint256, bool) {\\r\\n        IERC20 fromToken = IERC20(_fromTokenAddress);\\r\\n        \\r\\n        fromToken.approve(address(uniswapRouter), _amount);\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = _fromTokenAddress;\\r\\n        path[1] = _toTokenAddress;\\r\\n\\r\\n        uint256 balanceBefore = IERC20(_toTokenAddress).balanceOf(address(this));\\r\\n        \\r\\n        try uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            _amount,\\r\\n            _slippage,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        ) {} catch (bytes memory) {\\r\\n            return (0, false);\\r\\n        }\\r\\n        uint256 toAmount = IERC20(_toTokenAddress).balanceOf(address(this)) - balanceBefore;\\r\\n\\r\\n        // Return the amount of tokens received and the status of the swap\\r\\n        return (toAmount, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Checks if a pair exists for the given tokens in the Uniswap exchange\\r\\n    * @param token1 The address of the first token\\r\\n    * @param token2 The address of the second token\\r\\n    * @return bool Returns true if a pair exists, false otherwise\\r\\n    */\\r\\n    function checkIfPairExists(\\r\\n        address token1,\\r\\n        address token2\\r\\n    ) public view returns(bool) {\\r\\n        // Get the pair address from the Uniswap factory contract\\r\\n        address pair = uniswapFactory.getPair(token1, token2);\\r\\n        \\r\\n        // If the pair address is equal to the zero address, it means the pair does not exist.\\r\\n        if(pair == address(0)) return false;\\r\\n        else return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Retrieves the price of a token pair based on the specified token address and amount\\r\\n    * @param _tokenAddress The address of the token\\r\\n    * @param _amount The amount of the token\\r\\n    * @return uint256 The price of the token pair\\r\\n    */\\r\\n    function _getPairPrice(\\r\\n        address _tokenAddress,\\r\\n        uint256 _amount\\r\\n    ) internal view returns (uint256) {\\r\\n        // Check if a pair exists for USDC and the specified token\\r\\n        if (checkIfPairExists(USDC, _tokenAddress)) {\\r\\n            address[] memory path = new address[](2);\\r\\n            path[0] = _tokenAddress;\\r\\n            path[1] = USDC;\\r\\n            return getAmountOut(path, _amount);\\r\\n        }\\r\\n        \\r\\n        // Check if a pair exists for USDT and the specified token\\r\\n        if (checkIfPairExists(USDT, _tokenAddress)) {\\r\\n            address[] memory path = new address[](2);\\r\\n            path[0] = _tokenAddress;\\r\\n            path[1] = USDT;\\r\\n            return getAmountOut(path, _amount);\\r\\n        }\\r\\n        \\r\\n        // Check if a pair exists for WETH and the specified token\\r\\n        if (checkIfPairExists(WETH, _tokenAddress)) {\\r\\n            address[] memory path = new address[](3);\\r\\n            path[0] = _tokenAddress;\\r\\n            path[1] = WETH;\\r\\n            path[2] = USDC;\\r\\n            return getAmountOut(path, _amount);\\r\\n        }\\r\\n        \\r\\n        // Check if a pair exists for TSUKA and the specified token\\r\\n        if (checkIfPairExists(TSUKA, _tokenAddress)) {\\r\\n            address[] memory path = new address[](3);\\r\\n            path[0] = _tokenAddress;\\r\\n            path[1] = TSUKA;\\r\\n            path[2] = USDC;\\r\\n            return getAmountOut(path, _amount);\\r\\n        }\\r\\n        \\r\\n        // If no pair exists, return 0\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Retrieves the amount out for a given input amount and path of token addresses\\r\\n     * @param path The array of token addresses representing the path\\r\\n     * @param amount The input amount\\r\\n     * @return uint256 The amount out\\r\\n     */\\r\\n    function getAmountOut(\\r\\n        address[] memory path,\\r\\n        uint256 amount\\r\\n    ) internal view returns (uint256) {\\r\\n        // Get the amounts out for the specified input amount and path\\r\\n        uint[] memory amountsOut = uniswapRouter.getAmountsOut(amount, path);\\r\\n        \\r\\n        // The getAmountsOut function from the Uniswap router contract is called with the specified input amount and path\\r\\n        // It returns an array of amounts representing the output amounts at each step of the path\\r\\n\\r\\n        // Return the amount out of the final token.\\r\\n        // The amount out is obtained by accessing the last element of the amountsOut array using path.length - 1\\r\\n        // This represents the output amount of the final token in the path after the swap\\r\\n        return amountsOut[path.length - 1];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Retrieves the price of a token based on the specified token address\\r\\n     * @param _tokenAddress The address of the token\\r\\n     * @return uint256 The price of the token\\r\\n     */\\r\\n    function getTokenPrice(\\r\\n        address _tokenAddress\\r\\n    ) external view returns (uint256) {\\r\\n        // Get the decimals of the token\\r\\n        uint256 tokenDecimals = 10 ** IERC20Ext(_tokenAddress).decimals();\\r\\n\\r\\n        // Get the pair price for the specified token\\r\\n        return _getPairPrice(_tokenAddress, tokenDecimals);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice edit a continuous order with target price\\r\\n     * @param orderId Order id\\r\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\r\\n     * @param tokenAddress The address of the token being traded\\r\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\r\\n     * @param targetPrice The target price for the order. The value's decimal is in USDC decimal 6 format\\r\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\r\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\r\\n     * @param resetPercentage decimal represented as an int with 0 places of precision\\r\\n     */\\r\\n    function editContinuousTargetPriceOrder(\\r\\n        uint256 orderId,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 targetPrice,\\r\\n        uint256 amount,\\r\\n        uint256 slippage,\\r\\n        uint256 resetPercentage\\r\\n    ) external {\\r\\n        IOrderMgr.Order memory order = _orderMgr.getOrder(orderId);\\r\\n        // Validate order owner\\r\\n        require(\\r\\n            order.orderBase.userAddress == msg.sender,\\r\\n            \\\"msg.sender is not order owner\\\"\\r\\n        );\\r\\n        // Is continous order\\r\\n        require(order.orderBase.isContinuous == true, \\\"Incorrect order type\\\");\\r\\n\\r\\n        _orderMgr.updateOrder(\\r\\n            orderId,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            targetPrice,\\r\\n            0,\\r\\n            0,\\r\\n            amount,\\r\\n            slippage,\\r\\n            resetPercentage\\r\\n        );\\r\\n\\r\\n        // Emit an event\\r\\n        emit ContinuousOrderEdited(orderId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice edit a continuous order with price range\\r\\n     * @param orderId order id\\r\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\r\\n     * @param tokenAddress The address of the token being traded\\r\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\r\\n     * @param minPrice Minimum price for the order. The value's decimal is in USDC decimal 6 format\\r\\n     * @param maxPrice Maximum price for the order. The value's decimal is in USDC decimal 6 format\\r\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\r\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\r\\n     * @param resetPercentage decimal represented as an int with 0 places of precision\\r\\n     */\\r\\n    function editContinuousPriceRangeOrder(\\r\\n        uint256 orderId,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 slippage,\\r\\n        uint256 resetPercentage\\r\\n    ) external {\\r\\n        IOrderMgr.Order memory order = _orderMgr.getOrder(orderId);\\r\\n        // Validate order owner\\r\\n        require(\\r\\n            order.orderBase.userAddress == msg.sender,\\r\\n            \\\"msg.sender is not order owner\\\"\\r\\n        );\\r\\n        // Is continous order\\r\\n        require(order.orderBase.isContinuous == true, \\\"Incorrect order type\\\");\\r\\n\\r\\n        _orderMgr.updateOrder(\\r\\n            orderId,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            0,\\r\\n            minPrice,\\r\\n            maxPrice,\\r\\n            amount,\\r\\n            slippage,\\r\\n            resetPercentage\\r\\n        );\\r\\n\\r\\n        // Emit an event\\r\\n        emit ContinuousOrderEdited(orderId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Edit non-continuous order with price range\\r\\n     * @param orderId Order id\\r\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\r\\n     * @param tokenAddress The address of the token being traded\\r\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\r\\n     * @param minPrice Minimum price for the order. The value's decimal is in USDC decimal 6 format\\r\\n     * @param maxPrice Maximum price for the order. The value's decimal is in USDC decimal 6 format\\r\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\r\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\r\\n     */\\r\\n    function editNonContinuousPriceRangeOrder(\\r\\n        uint256 orderId,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        bool isBuy,\\r\\n        uint256 minPrice,\\r\\n        uint256 maxPrice,\\r\\n        uint256 amount,\\r\\n        uint256 slippage\\r\\n    ) \\r\\n        external\\r\\n        nonReentrant\\r\\n        initOneTimeOrderBalance(orderId)\\r\\n    {\\r\\n        require(validateOneTimeOrder(pairedTokenAddress, tokenAddress, isBuy, amount), \\\"Validation failed\\\");\\r\\n\\r\\n        _orderMgr.updateOrder(\\r\\n            orderId,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            0,\\r\\n            minPrice,\\r\\n            maxPrice,\\r\\n            amount,\\r\\n            slippage,\\r\\n            0\\r\\n        );\\r\\n        // Emit an event\\r\\n        emit OneTimeOrderEdited(orderId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Edit a non-continuous order with a target price\\r\\n     * @dev Target price order is only executed when the market price is equal to the target price\\r\\n     * @param orderId Order id\\r\\n     * @param pairedTokenAddress The address of the paired token in the trading pair\\r\\n     * @param tokenAddress The address of the token being traded\\r\\n     * @param isBuy Indicates whether it is a buy or sell order (true for buy, false for sell)\\r\\n     * @param targetPrice The target price for the order. The value's decimal is in USDC decimal 6 format\\r\\n     * @param amount The amount of tokens for the order. The value's decimal is the traded token decimal format.\\r\\n     * @param slippage The slippage tolerance for the order. This is minAmountOut value and decimal is the traded token decimal format.\\r\\n     */\\r\\n    function editNonContinuousTargetPriceOrder(\\r\\n        uint256 orderId,\\r\\n        address pairedTokenAddress,\\r\\n        address tokenAddress,\\r\\n        uint256 targetPrice,\\r\\n        bool isBuy,\\r\\n        uint256 amount,\\r\\n        uint256 slippage\\r\\n    ) \\r\\n        external\\r\\n        nonReentrant\\r\\n        initOneTimeOrderBalance(orderId)\\r\\n    {\\r\\n        require(validateOneTimeOrder(pairedTokenAddress, tokenAddress, isBuy, amount), \\\"Validation failed\\\");\\r\\n\\r\\n        _orderMgr.updateOrder(\\r\\n            orderId,\\r\\n            pairedTokenAddress,\\r\\n            tokenAddress,\\r\\n            isBuy,\\r\\n            targetPrice,\\r\\n            0,\\r\\n            0,\\r\\n            amount,\\r\\n            slippage,\\r\\n            0\\r\\n        );\\r\\n\\r\\n        // Emit event\\r\\n        emit OneTimeOrderEdited(orderId);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"BackendOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"ContinuousOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"ContinuousOrderEdited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ExecutedContinuousOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pairAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ExecutedOneTimeOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ExecutedOutOfPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OneTimeOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OneTimeOrderEdited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OrderCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OutOfFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"PairNotFound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"SwapFailed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backend_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token2\",\"type\":\"address\"}],\"name\":\"checkIfPairExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"createContinuousPriceRangeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"createContinuousTargetPriceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"createNonContinuousPriceRangeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"createNonContinuousTargetPriceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"editContinuousPriceRangeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resetPercentage\",\"type\":\"uint256\"}],\"name\":\"editContinuousTargetPriceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"editNonContinuousPriceRangeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"editNonContinuousTargetPriceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderMgrAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"orderIds\",\"type\":\"uint256[]\"}],\"name\":\"processOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"setBackendOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_orderMgrAddress\",\"type\":\"address\"}],\"name\":\"setOrderMgr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "UrulokiDEX", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}