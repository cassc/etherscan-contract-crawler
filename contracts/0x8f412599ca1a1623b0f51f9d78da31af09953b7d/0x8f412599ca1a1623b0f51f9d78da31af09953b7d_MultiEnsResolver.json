{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ByteUtils.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ~0.8.17;\\n\\nlibrary BytesUtils {\\n    /*\\n     * @dev Returns the keccak-256 hash of a byte range.\\n     * @param self The byte string to hash.\\n     * @param offset The position to start hashing at.\\n     * @param len The number of bytes to hash.\\n     * @return The hash of the byte range.\\n     */\\n    function keccak(\\n        bytes memory self,\\n        uint256 offset,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        require(offset + len <= self.length);\\n        assembly {\\n            ret := keccak256(add(add(self, 32), offset), len)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the ENS namehash of a DNS-encoded name.\\n     * @param self The DNS-encoded name to hash.\\n     * @param offset The offset at which to start hashing.\\n     * @return The namehash of the name.\\n     */\\n    function namehash(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        (bytes32 labelhash, uint256 newOffset) = readLabel(self, offset);\\n        if (labelhash == bytes32(0)) {\\n            require(offset == self.length - 1, \\\"namehash: Junk at end of name\\\");\\n            return bytes32(0);\\n        }\\n        return\\n            keccak256(abi.encodePacked(namehash(self, newOffset), labelhash));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak-256 hash of a DNS-encoded label, and the offset to the start of the next label.\\n     * @param self The byte string to read a label from.\\n     * @param idx The index to read a label at.\\n     * @return labelhash The hash of the label at the specified index, or 0 if it is the last label.\\n     * @return newIdx The index of the start of the next label.\\n     */\\n    function readLabel(\\n        bytes memory self,\\n        uint256 idx\\n    ) internal pure returns (bytes32 labelhash, uint256 newIdx) {\\n        require(idx < self.length, \\\"readLabel: Index out of bounds\\\");\\n        uint256 len = uint256(uint8(self[idx]));\\n        if (len > 0) {\\n            labelhash = keccak(self, idx + 1, len);\\n        } else {\\n            labelhash = bytes32(0);\\n        }\\n        newIdx = idx + len + 1;\\n    }\\n}\\n\\nlibrary NameEncoder {\\n    using BytesUtils for bytes;\\n\\n    function dnsEncodeName(\\n        string memory name\\n    ) internal pure returns (bytes memory dnsName, bytes32 node) {\\n        uint8 labelLength = 0;\\n        bytes memory bytesName = bytes(name);\\n        uint256 length = bytesName.length;\\n        dnsName = new bytes(length + 2);\\n        node = 0;\\n        if (length == 0) {\\n            dnsName[0] = 0;\\n            return (dnsName, node);\\n        }\\n\\n        // use unchecked to save gas since we check for an underflow\\n        // and we check for the length before the loop\\n        unchecked {\\n            for (uint256 i = length - 1; i >= 0; i--) {\\n                if (bytesName[i] == \\\".\\\") {\\n                    dnsName[i + 1] = bytes1(labelLength);\\n                    node = keccak256(\\n                        abi.encodePacked(\\n                            node,\\n                            bytesName.keccak(i + 1, labelLength)\\n                        )\\n                    );\\n                    labelLength = 0;\\n                } else {\\n                    labelLength += 1;\\n                    dnsName[i + 1] = bytesName[i];\\n                }\\n                if (i == 0) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        node = keccak256(\\n            abi.encodePacked(node, bytesName.keccak(0, labelLength))\\n        );\\n\\n        dnsName[0] = bytes1(labelLength);\\n        return (dnsName, node);\\n    }\\n}\"\r\n    },\r\n    \"contracts/EnsBatchedResolver.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./ByteUtils.sol\\\";\\nimport \\\"./interfaces.sol\\\";\\n\\n/// @title Contract allows to resolve multiple addresses or names at once\\n/// @author asimaranov\\n/// @notice Can be used to convert addresses [names] to names [addresses] and text fields e.g. avatars\\ncontract MultiEnsResolver {\\n    using NameEncoder for string;\\n\\n    IUniversalResolver public defaultUniversalResolver;\\n    bytes constant _base = \\\"0123456789abcdef\\\";\\n\\n    constructor(address universalResolverAddress) {\\n        defaultUniversalResolver = IUniversalResolver(universalResolverAddress);\\n    }\\n\\n    /// @notice Converts addresses to names and text records\\n    /// @param addresses Addresses to convert to names\\n    /// @param textFields text fields to fetch e.g. [\\\"avatar\\\"]\\n    function resolveAddresses(\\n        address[] calldata addresses, \\n        string[] memory textFields\\n    ) \\n        public view \\n        returns (\\n            string[] memory names, \\n            string[][] memory textRecords\\n        ) \\n    {\\n        return resolveAddresses(address(0), addresses, textFields);\\n    }\\n\\n    /// @notice Converts addresses to names and text records\\n    /// @param universalResolver address of the universal resolver\\n    /// @param addresses Addresses to convert to names\\n    /// @param textFields text fields to fetch e.g. [\\\"avatar\\\"]\\n    function resolveAddresses(\\n        address universalResolver, \\n        address[] calldata addresses, \\n        string[] memory textFields\\n    ) \\n        public view \\n        returns (\\n            string[] memory names, \\n            string[][] memory textRecords\\n        ) \\n    {\\n        IUniversalResolver universalResolver_ = \\n            universalResolver == address(0) ? defaultUniversalResolver : IUniversalResolver(universalResolver);\\n\\n        names = new string[](addresses.length);\\n        textRecords = new string[][](addresses.length);\\n\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            textRecords[i] = new string[](textFields.length);\\n        }\\n\\n        bytes memory request = hex\\\"28000000000000000000000000000000000000000000000000000000000000000000000000000000000461646472077265766572736500\\\";\\n\\n        for (uint256 addressId = 0; addressId < names.length; addressId++) {\\n            uint160 addressToResolve = uint160(addresses[addressId]);\\n            \\n            for (uint256 i = 0; i < 20; i++) { \\n                request[(20*2 - 1) - i*2] = _base[uint8(addressToResolve >> (i * 8)) / 16];\\n                request[(20*2 - 1) - i*2 + 1] = _base[uint8(addressToResolve >> (i * 8)) % 16];\\n            }\\n            try universalResolver_.reverse(request) returns (string memory name, address, address, address res) {\\n                (, bytes32 namehash) = name.dnsEncodeName();\\n                \\n                for (uint256 i = 0; i < textFields.length; i++) {\\n                    textRecords[addressId][i] = ITextResolver(res).text(namehash, textFields[i]);\\n                }\\n\\n                names[addressId] = name;\\n            } catch {}\\n        }\\n    }\\n\\n    /// @notice Converts names to addresses and text records\\n    /// @param names Names to convert to addresses\\n    /// @param textFields text fields to fetch e.g. [\\\"avatar\\\"]\\n    function resolveNames(\\n        string[] calldata names, \\n        string[] memory textFields\\n    ) \\n        public view \\n        returns (\\n            address[] memory addresses, \\n            string[][] memory textRecords\\n    ) {\\n        return resolveNames(address(0), names, textFields);\\n    }\\n\\n    /// @notice Converts names to addresses and text records\\n    /// @param universalResolver address of the universal resolver\\n    /// @param names Names to convert to addresses\\n    /// @param textFields text fields to fetch e.g. [\\\"avatar\\\"]\\n    function resolveNames(\\n        address universalResolver, \\n        string[] calldata names, \\n        string[] memory textFields\\n    ) \\n        public view \\n        returns (\\n            address[] memory addresses, \\n            string[][] memory textRecords\\n        ) \\n    {\\n        IUniversalResolver universalResolver_ = \\n            universalResolver == address(0) ? defaultUniversalResolver : IUniversalResolver(universalResolver);\\n\\n        addresses = new address[](names.length);\\n        textRecords = new string[][](addresses.length);\\n\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            textRecords[i] = new string[](textFields.length);\\n        }\\n\\n        for (uint256 nameId = 0; nameId < names.length; nameId++) {\\n            string memory nameToResolve = names[nameId];\\n            \\n            (bytes memory encodedName, bytes32 namehash) = nameToResolve.dnsEncodeName();\\n\\n            bytes memory encodedCall = abi.encodeCall(\\n                IAddrResolver.addr,\\n                namehash\\n            );\\n\\n            try universalResolver_.resolve(encodedName, encodedCall) returns (\\n                bytes memory resolvedData, \\n                address resolverAddress\\n            ) {\\n                for (uint256 i = 0; i < textFields.length; i++) {\\n                    textRecords[nameId][i] = ITextResolver(resolverAddress).text(namehash, textFields[i]);\\n                }\\n\\n                address resolvedAddress = abi.decode(resolvedData, (address));\\n\\n                addresses[nameId] = resolvedAddress;\\n            } catch {}\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\ninterface IUniversalResolver {\\n    function reverse(\\n        bytes calldata reverseName\\n    ) external view returns (string memory, address, address, address);\\n\\n    /**\\n     * @dev Performs ENS name reverse resolution for the supplied reverse name.\\n     * @param reverseName The reverse name to resolve, in normalised and DNS-encoded form. e.g. b6E040C9ECAaE172a89bD561c5F73e1C48d28cd9.addr.reverse\\n     * @return The resolved name, the resolved address, the reverse resolver address, and the resolver address.\\n     */\\n    function reverse(\\n        bytes calldata reverseName,\\n        string[] memory gateways\\n    ) external view returns (string memory, address, address, address);\\n\\n    /**\\n     * @dev Performs ENS name resolution for the supplied name and resolution data.\\n     * @param name The name to resolve, in normalised and DNS-encoded form.\\n     * @param data The resolution data, as specified in ENSIP-10.\\n     * @return The result of resolving the name.\\n     */\\n    function resolve(\\n        bytes calldata name,\\n        bytes memory data\\n    ) external view returns (bytes memory, address);\\n\\n    function resolve(\\n        bytes calldata name,\\n        bytes[] memory data\\n    ) external view returns (bytes[] memory, address);\\n}\\n\\ninterface ITextResolver {\\n    function text(bytes32 node, string calldata key) external view returns (string memory);\\n}\\n\\ninterface IAddrResolver {\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    /**\\n     * Returns the address associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node) external view returns (address payable);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"universalResolverAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"defaultUniversalResolver\",\"outputs\":[{\"internalType\":\"contract IUniversalResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"textFields\",\"type\":\"string[]\"}],\"name\":\"resolveAddresses\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"textRecords\",\"type\":\"string[][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"universalResolver\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"textFields\",\"type\":\"string[]\"}],\"name\":\"resolveAddresses\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"textRecords\",\"type\":\"string[][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"universalResolver\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"textFields\",\"type\":\"string[]\"}],\"name\":\"resolveNames\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"string[][]\",\"name\":\"textRecords\",\"type\":\"string[][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"textFields\",\"type\":\"string[]\"}],\"name\":\"resolveNames\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"string[][]\",\"name\":\"textRecords\",\"type\":\"string[][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MultiEnsResolver", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c0497e381f536be9ce14b0dd3817cbcae57d2f62", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}