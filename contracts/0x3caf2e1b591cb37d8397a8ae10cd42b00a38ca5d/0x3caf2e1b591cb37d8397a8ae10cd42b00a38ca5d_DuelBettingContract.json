{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Duel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\ncontract DuelBettingContract is Ownable, ReentrancyGuard {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    enum MatchOutcome { NOT_FINISHED, A, B }\\r\\n\\r\\n    event NewMatchStarted();\\r\\n    event BetPlaced(address indexed bettor, MatchOutcome outcome, uint256 amount);\\r\\n    event OutcomeDeclared(MatchOutcome outcome);\\r\\n    event WinningsDistributed(MatchOutcome winningOutcome);\\r\\n    event AdminFeesWithdrawn(uint256 amount);\\r\\n\\r\\n    struct Match {\\r\\n        uint256 betA;\\r\\n        uint256 betB;\\r\\n        MatchOutcome outcome;\\r\\n        mapping(address => uint256) betsA;\\r\\n        mapping(address => uint256) betsB;\\r\\n        address[] bettorsA;\\r\\n        address[] bettorsB;\\r\\n    }\\r\\n\\r\\n    Match currentMatch;\\r\\n    bool public matchActive = false;\\r\\n    uint256 public minBetAmount = 10000000000000000; // 0.01e\\r\\n    uint256 public maxBetAmount = 100000000000000000; // 0.1e\\r\\n    uint256 public adminFeePercentage = 5;\\r\\n    uint256 public playerLimit = 25;\\r\\n    uint256 public accumulatedFees;\\r\\n    MatchOutcome previousOutcome;\\r\\n\\r\\n    mapping(address => uint256) lastParticipatedMatch;\\r\\n    uint256 public currentMatchNonce = 0;\\r\\n\\r\\n    function startNewMatch() external onlyOwner {\\r\\n        require(!matchActive, \\\"Finish the current match first\\\");\\r\\n        \\r\\n        // bad code but scalable on l2 if required\\r\\n        for (uint i = 0; i < currentMatch.bettorsA.length; i++) {\\r\\n            delete currentMatch.betsA[currentMatch.bettorsA[i]];\\r\\n            delete currentMatch.bettorsA[i];\\r\\n        }\\r\\n        for (uint i = 0; i < currentMatch.bettorsB.length; i++) {\\r\\n            delete currentMatch.betsB[currentMatch.bettorsB[i]];\\r\\n            delete currentMatch.bettorsB[i];\\r\\n        }\\r\\n\\r\\n        currentMatch.betA = 0;\\r\\n        currentMatch.betB = 0;\\r\\n        currentMatch.outcome = MatchOutcome.NOT_FINISHED;\\r\\n        currentMatch.bettorsA = new address[](0);\\r\\n        currentMatch.bettorsB = new address[](0);\\r\\n        \\r\\n        matchActive = true;\\r\\n        currentMatchNonce = currentMatchNonce.add(1);\\r\\n\\r\\n        emit NewMatchStarted();\\r\\n    }\\r\\n\\r\\n    function _recordBettor(address[] storage bettors, address bettor) private {\\r\\n        if (lastParticipatedMatch[bettor] < currentMatchNonce) {\\r\\n            bettors.push(bettor);\\r\\n            lastParticipatedMatch[bettor] = currentMatchNonce;\\r\\n        } else if (lastParticipatedMatch[bettor] == currentMatchNonce) {\\r\\n            revert(\\\"You can only bet once per match.\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _isContract(address addr) private view returns(bool) {\\r\\n        uint32 size;\\r\\n        assembly { size := extcodesize(addr) }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n    function _betOnOutcome(MatchOutcome outcome, uint256 amount) private {\\r\\n        require(!_isContract(msg.sender), \\\"Contracts are not allowed to bet\\\");\\r\\n        require(matchActive, \\\"No active match\\\");\\r\\n        require(amount >= minBetAmount && amount <= maxBetAmount, \\\"Invalid bet amount\\\");\\r\\n        require(msg.value == amount, \\\"Mismatched ether sent\\\");\\r\\n\\r\\n        if (outcome == MatchOutcome.A) {\\r\\n            require(currentMatch.bettorsA.length < playerLimit, \\\"Player limit reached for Outcome A\\\");\\r\\n            _recordBettor(currentMatch.bettorsA, msg.sender);\\r\\n            currentMatch.betA = currentMatch.betA.add(amount);\\r\\n            currentMatch.betsA[msg.sender] = currentMatch.betsA[msg.sender].add(amount);\\r\\n        } else if (outcome == MatchOutcome.B) {\\r\\n            require(currentMatch.bettorsB.length < playerLimit, \\\"Player limit reached for Outcome B\\\");\\r\\n            _recordBettor(currentMatch.bettorsB, msg.sender);\\r\\n            currentMatch.betB = currentMatch.betB.add(amount);\\r\\n            currentMatch.betsB[msg.sender] = currentMatch.betsB[msg.sender].add(amount);\\r\\n        }\\r\\n\\r\\n        emit BetPlaced(msg.sender, outcome, amount);\\r\\n    }\\r\\n\\r\\n    function betOnOutcomeA(uint256 amount) external payable {\\r\\n        _betOnOutcome(MatchOutcome.A, amount);\\r\\n    }\\r\\n\\r\\n    function betOnOutcomeB(uint256 amount) external payable {\\r\\n        _betOnOutcome(MatchOutcome.B, amount);\\r\\n    }\\r\\n\\r\\n    function declareOutcome(MatchOutcome outcome) external onlyOwner {\\r\\n        require(matchActive, \\\"No active match\\\");\\r\\n        require(outcome != MatchOutcome.NOT_FINISHED, \\\"Invalid outcome\\\");\\r\\n        require(currentMatch.bettorsA.length > 0, \\\"No bets on Outcome A.\\\");\\r\\n        require(currentMatch.bettorsB.length > 0, \\\"No bets on Outcome B.\\\");\\r\\n        \\r\\n        currentMatch.outcome = outcome;\\r\\n        previousOutcome = outcome;\\r\\n        \\r\\n        matchActive = false;\\r\\n\\r\\n        emit OutcomeDeclared(outcome);\\r\\n    }\\r\\n\\r\\n    function distributeWinnings() external onlyOwner nonReentrant {\\r\\n        require(!matchActive, \\\"Match is still active\\\");\\r\\n        require(currentMatch.outcome != MatchOutcome.NOT_FINISHED, \\\"Match hasn't finished yet\\\");\\r\\n\\r\\n        if (currentMatch.outcome == MatchOutcome.A) {\\r\\n            uint256 adminFee = currentMatch.betB.mul(adminFeePercentage).div(100);\\r\\n            accumulatedFees = accumulatedFees.add(adminFee);\\r\\n\\r\\n            uint256 payoutPool = currentMatch.betB.sub(adminFee);\\r\\n            for (uint i = 0; i < currentMatch.bettorsA.length; i++) {\\r\\n                address bettor = currentMatch.bettorsA[i];\\r\\n                uint256 initialBet = currentMatch.betsA[bettor];\\r\\n                uint256 reward = payoutPool.mul(initialBet).div(currentMatch.betA).add(initialBet); // Added initial bet\\r\\n                currentMatch.betsA[bettor] = 0; // Prevent re-entrancy\\r\\n                payable(bettor).transfer(reward);\\r\\n            }\\r\\n        } else if (currentMatch.outcome == MatchOutcome.B) {\\r\\n            uint256 adminFee = currentMatch.betA.mul(adminFeePercentage).div(100);\\r\\n            accumulatedFees = accumulatedFees.add(adminFee);\\r\\n\\r\\n            uint256 payoutPool = currentMatch.betA.sub(adminFee);\\r\\n            for (uint i = 0; i < currentMatch.bettorsB.length; i++) {\\r\\n                address bettor = currentMatch.bettorsB[i];\\r\\n                uint256 initialBet = currentMatch.betsB[bettor];\\r\\n                uint256 reward = payoutPool.mul(initialBet).div(currentMatch.betB).add(initialBet); // Added initial bet\\r\\n                currentMatch.betsB[bettor] = 0; // Prevent re-entrancy\\r\\n                payable(bettor).transfer(reward);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit WinningsDistributed(currentMatch.outcome);\\r\\n    }\\r\\n\\r\\n    function withdrawAccumulatedFees() external onlyOwner {\\r\\n        require(accumulatedFees > 0, \\\"No fees to withdraw\\\");\\r\\n\\r\\n        uint256 amount = accumulatedFees;\\r\\n        accumulatedFees = 0;\\r\\n        payable(owner()).transfer(amount);\\r\\n\\r\\n        emit AdminFeesWithdrawn(amount);\\r\\n    }\\r\\n\\r\\n    function setLimits(uint256 _minBetAmount, uint256 _maxBetAmount, uint256 _playerLimit) external onlyOwner {\\r\\n        require(_minBetAmount < _maxBetAmount, \\\"Invalid bet limits\\\");\\r\\n        require(!matchActive, \\\"Finish the current match first\\\");\\r\\n        minBetAmount = _minBetAmount;\\r\\n        maxBetAmount = _maxBetAmount;\\r\\n        playerLimit = _playerLimit;\\r\\n    }\\r\\n\\r\\n    function setAdminFeePercentage(uint256 _adminFeePercentage) external onlyOwner {\\r\\n        require(_adminFeePercentage < 100, \\\"Fee percentage too high\\\");\\r\\n        adminFeePercentage = _adminFeePercentage;\\r\\n    }\\r\\n\\r\\n    function getNumberOfBettors() external view returns (uint256 numBettorsA, uint256 numBettorsB) {\\r\\n        numBettorsA = currentMatch.bettorsA.length;\\r\\n        numBettorsB = currentMatch.bettorsB.length;\\r\\n    }\\r\\n\\r\\n    function getMatchBetAmount() external view returns (uint256 betAmountA, uint256 betAmountB) {\\r\\n        betAmountA = currentMatch.betA;\\r\\n        betAmountB = currentMatch.betB;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AdminFeesWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bettor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum DuelBettingContract.MatchOutcome\",\"name\":\"outcome\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NewMatchStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum DuelBettingContract.MatchOutcome\",\"name\":\"outcome\",\"type\":\"uint8\"}],\"name\":\"OutcomeDeclared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum DuelBettingContract.MatchOutcome\",\"name\":\"winningOutcome\",\"type\":\"uint8\"}],\"name\":\"WinningsDistributed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accumulatedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"betOnOutcomeA\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"betOnOutcomeB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMatchNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum DuelBettingContract.MatchOutcome\",\"name\":\"outcome\",\"type\":\"uint8\"}],\"name\":\"declareOutcome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMatchBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"betAmountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betAmountB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfBettors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numBettorsA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numBettorsB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"matchActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"playerLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_adminFeePercentage\",\"type\":\"uint256\"}],\"name\":\"setAdminFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minBetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_playerLimit\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startNewMatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAccumulatedFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DuelBettingContract", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}