{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.4;\r\n\r\ninterface IFlashToken {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function mint(address to, uint256 value) external returns (bool);\r\n\r\n    function burn(uint256 value) external returns (bool);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\ninterface IFlashReceiver {\r\n    function receiveFlash(\r\n        bytes32 id,\r\n        uint256 amountIn,\r\n        uint256 expireAfter,\r\n        uint256 mintedAmount,\r\n        address staker,\r\n        bytes calldata data\r\n    ) external returns (uint256);\r\n}\r\n\r\ninterface IFlashProtocol {\r\n    enum LockedFunctions { SET_MATCH_RATIO, SET_MATCH_RECEIVER }\r\n\r\n    function TIMELOCK() external view returns (uint256);\r\n\r\n    function FLASH_TOKEN() external view returns (address);\r\n\r\n    function matchRatio() external view returns (uint256);\r\n\r\n    function matchReceiver() external view returns (address);\r\n\r\n    function stakes(bytes32 _id)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 amountIn,\r\n            uint256 expiry,\r\n            uint256 expireAfter,\r\n            uint256 mintedAmount,\r\n            address staker,\r\n            address receiver\r\n        );\r\n\r\n    function stake(\r\n        uint256 _amountIn,\r\n        uint256 _days,\r\n        address _receiver,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        returns (\r\n            uint256 mintedAmount,\r\n            uint256 matchedAmount,\r\n            bytes32 id\r\n        );\r\n\r\n    function lockFunction(LockedFunctions _lockedFunction) external;\r\n\r\n    function unlockFunction(LockedFunctions _lockedFunction) external;\r\n\r\n    function timelock(LockedFunctions _lockedFunction) external view returns (uint256);\r\n\r\n    function balances(address _staker) external view returns (uint256);\r\n\r\n    function unstake(bytes32 _id) external returns (uint256 withdrawAmount);\r\n\r\n    function unstakeEarly(bytes32 _id) external returns (uint256 withdrawAmount);\r\n\r\n    function getFPY(uint256 _amountIn) external view returns (uint256);\r\n\r\n    function setMatchReceiver(address _newMatchReceiver) external;\r\n\r\n    function setMatchRatio(uint256 _newMatchRatio) external;\r\n\r\n    function getMatchedAmount(uint256 mintedAmount) external view returns (uint256);\r\n\r\n    function getMintAmount(uint256 _amountIn, uint256 _expiry) external view returns (uint256);\r\n\r\n    function getPercentageStaked(uint256 _amountIn) external view returns (uint256 percentage);\r\n\r\n    function calculateMaxStakePeriod(uint256 _amountIn) external view returns (uint256);\r\n\r\n    function stakeWithPermit(\r\n        address _receiver,\r\n        uint256 _amountIn,\r\n        uint256 _expiry,\r\n        uint256 _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        returns (\r\n            uint256 mintedAmount,\r\n            uint256 matchedAmount,\r\n            bytes32 id\r\n        );\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"MATH:: ADD_OVERFLOW\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"MATH:: SUB_UNDERFLOW\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MATH:: MUL_OVERFLOW\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"MATH:: DIVISION_BY_ZERO\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\ncontract FlashProtocol is IFlashProtocol {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    struct Stake {\r\n        uint256 amountIn;\r\n        uint256 expiry;\r\n        uint256 expireAfter;\r\n        uint256 mintedAmount;\r\n        address staker;\r\n        address receiver;\r\n    }\r\n\r\n    uint256 public constant override TIMELOCK = 3 days;\r\n    address public constant override FLASH_TOKEN = 0x20398aD62bb2D930646d45a6D4292baa0b860C1f;\r\n\r\n    uint256 internal constant PRECISION = 1e18;\r\n    uint256 internal constant MAX_FPY_FOR_1_YEAR = 5e17;\r\n    uint256 internal constant SECONDS_IN_1_YEAR = 365 * 86400;\r\n\r\n    uint256 public override matchRatio;\r\n    address public override matchReceiver;\r\n\r\n    mapping(bytes32 => Stake) public override stakes;\r\n    mapping(LockedFunctions => uint256) public override timelock;\r\n    mapping(address => uint256) public override balances;\r\n\r\n    event Staked(\r\n        bytes32 _id,\r\n        uint256 _amountIn,\r\n        uint256 _expiry,\r\n        uint256 _expireAfter,\r\n        uint256 _mintedAmount,\r\n        address indexed _staker,\r\n        address indexed _receiver\r\n    );\r\n\r\n    event Unstaked(bytes32 _id, uint256 _amountIn, address indexed _staker);\r\n\r\n    modifier onlyMatchReceiver {\r\n        require(msg.sender == matchReceiver, \"FlashProtocol:: NOT_MATCH_RECEIVER\");\r\n        _;\r\n    }\r\n\r\n    modifier notLocked(LockedFunctions _lockedFunction) {\r\n        require(\r\n            timelock[_lockedFunction] != 0 && timelock[_lockedFunction] <= block.timestamp,\r\n            \"FlashProtocol:: FUNCTION_TIMELOCKED\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _initialMatchReceiver, uint256 _initialMatchRatio) {\r\n        _setMatchRatio(_initialMatchRatio);\r\n        _setMatchReceiver(_initialMatchReceiver);\r\n    }\r\n\r\n    function lockFunction(LockedFunctions _lockedFunction) external override onlyMatchReceiver {\r\n        timelock[_lockedFunction] = type(uint256).max;\r\n    }\r\n\r\n    function unlockFunction(LockedFunctions _lockedFunction) external override onlyMatchReceiver {\r\n        timelock[_lockedFunction] = block.timestamp + TIMELOCK;\r\n    }\r\n\r\n    function setMatchReceiver(address _newMatchReceiver)\r\n        external\r\n        override\r\n        onlyMatchReceiver\r\n        notLocked(LockedFunctions.SET_MATCH_RECEIVER)\r\n    {\r\n        _setMatchReceiver(_newMatchReceiver);\r\n        timelock[LockedFunctions.SET_MATCH_RECEIVER] = 0;\r\n    }\r\n\r\n    function _setMatchReceiver(address _newMatchReceiver) internal {\r\n        matchReceiver = _newMatchReceiver;\r\n    }\r\n\r\n    function setMatchRatio(uint256 _newMatchRatio)\r\n        external\r\n        override\r\n        onlyMatchReceiver\r\n        notLocked(LockedFunctions.SET_MATCH_RATIO)\r\n    {\r\n        _setMatchRatio(_newMatchRatio);\r\n        timelock[LockedFunctions.SET_MATCH_RATIO] = 0;\r\n    }\r\n\r\n    function _setMatchRatio(uint256 _newMatchRatio) internal {\r\n        require(_newMatchRatio >= 0 && _newMatchRatio <= 2000, \"FlashProtocol:: INVALID_MATCH_RATIO\");\r\n        // can be 0 and cannot be above 20%\r\n        require(_newMatchRatio <= 2000, \"FlashProtocol:: INVALID_MATCH_RATIO\");\r\n        matchRatio = _newMatchRatio;\r\n    }\r\n\r\n    function stake(\r\n        uint256 _amountIn,\r\n        uint256 _expiry,\r\n        address _receiver,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        override\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            bytes32\r\n        )\r\n    {\r\n        return _stake(_amountIn, _expiry, _receiver, _data);\r\n    }\r\n\r\n    function stakeWithPermit(\r\n        address _receiver,\r\n        uint256 _amountIn,\r\n        uint256 _expiry,\r\n        uint256 _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        override\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            bytes32\r\n        )\r\n    {\r\n        IFlashToken(FLASH_TOKEN).permit(msg.sender, address(this), type(uint256).max, _deadline, _v, _r, _s);\r\n        return _stake(_amountIn, _expiry, _receiver, _data);\r\n    }\r\n\r\n    function _stake(\r\n        uint256 _amountIn,\r\n        uint256 _expiry,\r\n        address _receiver,\r\n        bytes calldata _data\r\n    )\r\n        internal\r\n        returns (\r\n            uint256 mintedAmount,\r\n            uint256 matchedAmount,\r\n            bytes32 id\r\n        )\r\n    {\r\n        require(_amountIn > 0, \"FlashProtocol:: INVALID_AMOUNT\");\r\n        require(_receiver != address(this), \"FlashProtocol:: INVALID_ADDRESS\");\r\n        require(_expiry <= calculateMaxStakePeriod(_amountIn), \"FlashProtocol:: MAX_STAKE_PERIOD_EXCEEDS\");\r\n\r\n        address staker = msg.sender;\r\n\r\n        uint256 expiration = block.timestamp.add(_expiry);\r\n        balances[staker] = balances[staker].add(_amountIn);\r\n\r\n        id = keccak256(abi.encodePacked(_amountIn, _expiry, _receiver, staker, block.timestamp));\r\n\r\n        require(stakes[id].staker == address(0), \"FlashProtocol:: STAKE_EXISTS\");\r\n\r\n        mintedAmount = getMintAmount(_amountIn, _expiry);\r\n        matchedAmount = getMatchedAmount(mintedAmount);\r\n\r\n        IFlashToken(FLASH_TOKEN).transferFrom(staker, address(this), _amountIn);\r\n\r\n        IFlashToken(FLASH_TOKEN).mint(_receiver, mintedAmount);\r\n        IFlashToken(FLASH_TOKEN).mint(matchReceiver, matchedAmount);\r\n\r\n        stakes[id] = Stake(_amountIn, _expiry, expiration, mintedAmount, staker, _receiver);\r\n\r\n        if (_receiver.isContract()) {\r\n            IFlashReceiver(_receiver).receiveFlash(id, _amountIn, expiration, mintedAmount, staker, _data);\r\n        }\r\n\r\n        emit Staked(id, _amountIn, _expiry, expiration, mintedAmount, staker, _receiver);\r\n    }\r\n\r\n    function unstake(bytes32 _id) external override returns (uint256 withdrawAmount) {\r\n        Stake memory s = stakes[_id];\r\n        require(block.timestamp >= s.expireAfter, \"FlashProtol:: STAKE_NOT_EXPIRED\");\r\n        balances[s.staker] = balances[s.staker].sub(s.amountIn);\r\n        withdrawAmount = s.amountIn;\r\n        delete stakes[_id];\r\n        IFlashToken(FLASH_TOKEN).transfer(s.staker, withdrawAmount);\r\n        emit Unstaked(_id, s.amountIn, s.staker);\r\n    }\r\n\r\n    function unstakeEarly(bytes32 _id) external override returns (uint256 withdrawAmount) {\r\n        Stake memory s = stakes[_id];\r\n        address staker = msg.sender;\r\n        require(s.staker == staker, \"FlashProtocol:: INVALID_STAKER\");\r\n        uint256 remainingTime = (s.expireAfter.sub(block.timestamp));\r\n        require(s.expiry > remainingTime, \"Flash Protocol:: INVALID_UNSTAKE_TIME\");\r\n        uint256 burnAmount = _calculateBurn(s.amountIn, remainingTime, s.expiry);\r\n        assert(burnAmount <= s.amountIn);\r\n        balances[staker] = balances[staker].sub(s.amountIn);\r\n        withdrawAmount = s.amountIn.sub(burnAmount);\r\n        delete stakes[_id];\r\n        IFlashToken(FLASH_TOKEN).burn(burnAmount);\r\n        IFlashToken(FLASH_TOKEN).transfer(staker, withdrawAmount);\r\n        emit Unstaked(_id, withdrawAmount, staker);\r\n    }\r\n\r\n    function getMatchedAmount(uint256 _mintedAmount) public view override returns (uint256) {\r\n        return _mintedAmount.mul(matchRatio).div(10000);\r\n    }\r\n\r\n    function getMintAmount(uint256 _amountIn, uint256 _expiry) public view override returns (uint256) {\r\n        return _amountIn.mul(_expiry).mul(getFPY(_amountIn)).div(PRECISION * SECONDS_IN_1_YEAR);\r\n    }\r\n\r\n    function getFPY(uint256 _amountIn) public view override returns (uint256) {\r\n        return (PRECISION.sub(getPercentageStaked(_amountIn))).div(2);\r\n    }\r\n\r\n    function getPercentageStaked(uint256 _amountIn) public view override returns (uint256) {\r\n        uint256 locked = IFlashToken(FLASH_TOKEN).balanceOf(address(this)).add(_amountIn);\r\n        return locked.mul(PRECISION).div(IFlashToken(FLASH_TOKEN).totalSupply());\r\n    }\r\n\r\n    function calculateMaxStakePeriod(uint256 _amountIn) public view override returns (uint256) {\r\n        return MAX_FPY_FOR_1_YEAR.mul(SECONDS_IN_1_YEAR).div(getFPY(_amountIn));\r\n    }\r\n\r\n    function _calculateBurn(\r\n        uint256 _amount,\r\n        uint256 _remainingTime,\r\n        uint256 _totalTime\r\n    ) private pure returns (uint256) {\r\n        return _amount.mul(_remainingTime).div(_totalTime);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initialMatchReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialMatchRatio\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_expireAfter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_mintedAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FLASH_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIMELOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"}],\"name\":\"calculateMaxStakePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"}],\"name\":\"getFPY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintedAmount\",\"type\":\"uint256\"}],\"name\":\"getMatchedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"getMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"}],\"name\":\"getPercentageStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IFlashProtocol.LockedFunctions\",\"name\":\"_lockedFunction\",\"type\":\"uint8\"}],\"name\":\"lockFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"matchRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"matchReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMatchRatio\",\"type\":\"uint256\"}],\"name\":\"setMatchRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMatchReceiver\",\"type\":\"address\"}],\"name\":\"setMatchReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"stakeWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IFlashProtocol.LockedFunctions\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"timelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IFlashProtocol.LockedFunctions\",\"name\":\"_lockedFunction\",\"type\":\"uint8\"}],\"name\":\"unlockFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"unstakeEarly\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FlashProtocol", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000842f8f6fb524996d0b660621da895166e1cea69100000000000000000000000000000000000000000000000000000000000005dc", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6dc5d6153199f30c9e7dfd6cff75014faddcff6959bde4c24a51e128a2010df5"}