{"SourceCode": "// ##############################################################\r\n// ##############################################################\r\n// ##############################################################\r\n// ######\"          \"\"### \"\" \"###################################\r\n// ####                        ##### ------------------------- ##\r\n// #### ........              ###### ACTUAL            GENESIS ##\r\n// ###########\"             ######## BY           NEU \u00d7 REGIME ##\r\n// ########\"        .      #########                           ##\r\n// ######       .###        ########    https://actual.gallery ##\r\n// #####        ####        \"#######            @actualgallery ##\r\n// ####       #####          \"######                           ##\r\n// ###         \"\"              #####        https://neuregi.me ##\r\n// ###               #          \"###               @neuxregime ##\r\n// ###.           .#####.       .### ------------------------- ##\r\n// #####........#########......##################################\r\n// ##############################################################\r\n// ##############################################################\r\n// ##     \"NEVER BEFORE HAS THERE BEEN SO MUCH LIGHT\" - M.     ##\r\n// ##############################################################\r\n// ##############################################################\r\n\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\n// Sources flattened with hardhat v2.8.0 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n  /**\r\n   * @dev Returns true if this contract implements the interface defined by\r\n   * `interfaceId`. See the corresponding\r\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n   * to learn more about how these ids are created.\r\n   *\r\n   * This function call must use less than 30 000 gas.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n  /**\r\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n   */\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 indexed tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n   */\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed approved,\r\n    uint256 indexed tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed owner,\r\n    address indexed operator,\r\n    bool approved\r\n  );\r\n\r\n  /**\r\n   * @dev Returns the number of tokens in ``owner``'s account.\r\n   */\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n  /**\r\n   * @dev Returns the owner of the `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n   * The approval is cleared when the token is transferred.\r\n   *\r\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The caller must own the token or be an approved operator.\r\n   * - `tokenId` must exist.\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address to, uint256 tokenId) external;\r\n\r\n  /**\r\n   * @dev Returns the account approved for `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function getApproved(uint256 tokenId)\r\n    external\r\n    view\r\n    returns (address operator);\r\n\r\n  /**\r\n   * @dev Approve or remove `operator` as an operator for the caller.\r\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The `operator` cannot be the caller.\r\n   *\r\n   * Emits an {ApprovalForAll} event.\r\n   */\r\n  function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n  /**\r\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n   *\r\n   * See {setApprovalForAll}\r\n   */\r\n  function isApprovedForAll(address owner, address operator)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes calldata data\r\n  ) external;\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n  /**\r\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n   * by `operator` from `from`, this function is called.\r\n   *\r\n   * It must return its Solidity selector to confirm the token transfer.\r\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n   *\r\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n   */\r\n  function onERC721Received(\r\n    address operator,\r\n    address from,\r\n    uint256 tokenId,\r\n    bytes calldata data\r\n  ) external returns (bytes4);\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n  /**\r\n   * @dev Returns the token collection name.\r\n   */\r\n  function name() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the token collection symbol.\r\n   */\r\n  function symbol() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n   */\r\n  function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * It is unsafe to assume that an address for which this function returns\r\n   * false is an externally-owned account (EOA) and not a contract.\r\n   *\r\n   * Among others, `isContract` will return false for the following\r\n   * types of addresses:\r\n   *\r\n   *  - an externally-owned account\r\n   *  - a contract in construction\r\n   *  - an address where a contract will be created\r\n   *  - an address where a contract lived, but was destroyed\r\n   * ====\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // This method relies on extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    uint256 size;\r\n    assembly {\r\n      size := extcodesize(account)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n   * `recipient`, forwarding all available gas and reverting on errors.\r\n   *\r\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n   * imposed by `transfer`, making them unable to receive funds via\r\n   * `transfer`. {sendValue} removes this limitation.\r\n   *\r\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n   *\r\n   * IMPORTANT: because control is transferred to `recipient`, care must be\r\n   * taken to not create reentrancy vulnerabilities. Consider using\r\n   * {ReentrancyGuard} or the\r\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n   */\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n    (bool success, ) = recipient.call{value: amount}('');\r\n    require(\r\n      success,\r\n      'Address: unable to send value, recipient may have reverted'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Performs a Solidity function call using a low level `call`. A\r\n   * plain `call` is an unsafe replacement for a function call: use this\r\n   * function instead.\r\n   *\r\n   * If `target` reverts with a revert reason, it is bubbled up by this\r\n   * function (like regular Solidity function calls).\r\n   *\r\n   * Returns the raw returned data. To convert to the expected return value,\r\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `target` must be a contract.\r\n   * - calling `target` with `data` must not revert.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n  {\r\n    return functionCall(target, data, 'Address: low-level call failed');\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n   * `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but also transferring `value` wei to `target`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the calling contract must have an ETH balance of at least `value`.\r\n   * - the called Solidity function must be `payable`.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value\r\n  ) internal returns (bytes memory) {\r\n    return\r\n      functionCallWithValue(\r\n        target,\r\n        data,\r\n        value,\r\n        'Address: low-level call with value failed'\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(\r\n      address(this).balance >= value,\r\n      'Address: insufficient balance for call'\r\n    );\r\n    require(isContract(target), 'Address: call to non-contract');\r\n\r\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(address target, bytes memory data)\r\n    internal\r\n    view\r\n    returns (bytes memory)\r\n  {\r\n    return\r\n      functionStaticCall(target, data, 'Address: low-level static call failed');\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    require(isContract(target), 'Address: static call to non-contract');\r\n\r\n    (bool success, bytes memory returndata) = target.staticcall(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but performing a delegate call.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function functionDelegateCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n  {\r\n    return\r\n      functionDelegateCall(\r\n        target,\r\n        data,\r\n        'Address: low-level delegate call failed'\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n   * but performing a delegate call.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function functionDelegateCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(isContract(target), 'Address: delegate call to non-contract');\r\n\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n   * revert reason using the provided one.\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) internal pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes calldata) {\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n  bytes16 private constant _HEX_SYMBOLS = '0123456789abcdef';\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n   */\r\n  function toString(uint256 value) internal pure returns (string memory) {\r\n    // Inspired by OraclizeAPI's implementation - MIT licence\r\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n    if (value == 0) {\r\n      return '0';\r\n    }\r\n    uint256 temp = value;\r\n    uint256 digits;\r\n    while (temp != 0) {\r\n      digits++;\r\n      temp /= 10;\r\n    }\r\n    bytes memory buffer = new bytes(digits);\r\n    while (value != 0) {\r\n      digits -= 1;\r\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n      value /= 10;\r\n    }\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n   */\r\n  function toHexString(uint256 value) internal pure returns (string memory) {\r\n    if (value == 0) {\r\n      return '0x00';\r\n    }\r\n    uint256 temp = value;\r\n    uint256 length = 0;\r\n    while (temp != 0) {\r\n      length++;\r\n      temp >>= 8;\r\n    }\r\n    return toHexString(value, length);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n   */\r\n  function toHexString(uint256 value, uint256 length)\r\n    internal\r\n    pure\r\n    returns (string memory)\r\n  {\r\n    bytes memory buffer = new bytes(2 * length + 2);\r\n    buffer[0] = '0';\r\n    buffer[1] = 'x';\r\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n      value >>= 4;\r\n    }\r\n    require(value == 0, 'Strings: hex length insufficient');\r\n    return string(buffer);\r\n  }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return interfaceId == type(IERC165).interfaceId;\r\n  }\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC721/ERC721.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n  using Address for address;\r\n  using Strings for uint256;\r\n\r\n  // Token name\r\n  string private _name;\r\n\r\n  // Token symbol\r\n  string private _symbol;\r\n\r\n  // Mapping from token ID to owner address\r\n  mapping(uint256 => address) private _owners;\r\n\r\n  // Mapping owner address to token count\r\n  mapping(address => uint256) private _balances;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping(uint256 => address) private _tokenApprovals;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n  /**\r\n   * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n   */\r\n  constructor(string memory name_, string memory symbol_) {\r\n    _name = name_;\r\n    _symbol = symbol_;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override(ERC165, IERC165)\r\n    returns (bool)\r\n  {\r\n    return\r\n      interfaceId == type(IERC721).interfaceId ||\r\n      interfaceId == type(IERC721Metadata).interfaceId ||\r\n      super.supportsInterface(interfaceId);\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-balanceOf}.\r\n   */\r\n  function balanceOf(address owner)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    require(owner != address(0), 'ERC721: balance query for the zero address');\r\n    return _balances[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-ownerOf}.\r\n   */\r\n  function ownerOf(uint256 tokenId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (address)\r\n  {\r\n    address owner = _owners[tokenId];\r\n    require(owner != address(0), 'ERC721: owner query for nonexistent token');\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721Metadata-name}.\r\n   */\r\n  function name() public view virtual override returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721Metadata-symbol}.\r\n   */\r\n  function symbol() public view virtual override returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721Metadata-tokenURI}.\r\n   */\r\n  function tokenURI(uint256 tokenId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (string memory)\r\n  {\r\n    require(\r\n      _exists(tokenId),\r\n      'ERC721Metadata: URI query for nonexistent token'\r\n    );\r\n\r\n    string memory baseURI = _baseURI();\r\n    return\r\n      bytes(baseURI).length > 0\r\n        ? string(abi.encodePacked(baseURI, tokenId.toString()))\r\n        : '';\r\n  }\r\n\r\n  /**\r\n   * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n   * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n   * by default, can be overriden in child contracts.\r\n   */\r\n  function _baseURI() internal view virtual returns (string memory) {\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-approve}.\r\n   */\r\n  function approve(address to, uint256 tokenId) public virtual override {\r\n    address owner = ERC721.ownerOf(tokenId);\r\n    require(to != owner, 'ERC721: approval to current owner');\r\n\r\n    require(\r\n      _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n      'ERC721: approve caller is not owner nor approved for all'\r\n    );\r\n\r\n    _approve(to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-getApproved}.\r\n   */\r\n  function getApproved(uint256 tokenId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (address)\r\n  {\r\n    require(_exists(tokenId), 'ERC721: approved query for nonexistent token');\r\n\r\n    return _tokenApprovals[tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-setApprovalForAll}.\r\n   */\r\n  function setApprovalForAll(address operator, bool approved)\r\n    public\r\n    virtual\r\n    override\r\n  {\r\n    _setApprovalForAll(_msgSender(), operator, approved);\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-isApprovedForAll}.\r\n   */\r\n  function isApprovedForAll(address owner, address operator)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return _operatorApprovals[owner][operator];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-transferFrom}.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) public virtual override {\r\n    //solhint-disable-next-line max-line-length\r\n    require(\r\n      _isApprovedOrOwner(_msgSender(), tokenId),\r\n      'ERC721: transfer caller is not owner nor approved'\r\n    );\r\n\r\n    _transfer(from, to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-safeTransferFrom}.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) public virtual override {\r\n    safeTransferFrom(from, to, tokenId, '');\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC721-safeTransferFrom}.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes memory _data\r\n  ) public virtual override {\r\n    require(\r\n      _isApprovedOrOwner(_msgSender(), tokenId),\r\n      'ERC721: transfer caller is not owner nor approved'\r\n    );\r\n    _safeTransfer(from, to, tokenId, _data);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n   *\r\n   * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n   *\r\n   * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n   * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _safeTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes memory _data\r\n  ) internal virtual {\r\n    _transfer(from, to, tokenId);\r\n    require(\r\n      _checkOnERC721Received(from, to, tokenId, _data),\r\n      'ERC721: transfer to non ERC721Receiver implementer'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether `tokenId` exists.\r\n   *\r\n   * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n   *\r\n   * Tokens start existing when they are minted (`_mint`),\r\n   * and stop existing when they are burned (`_burn`).\r\n   */\r\n  function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n    return _owners[tokenId] != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function _isApprovedOrOwner(address spender, uint256 tokenId)\r\n    internal\r\n    view\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    require(_exists(tokenId), 'ERC721: operator query for nonexistent token');\r\n    address owner = ERC721.ownerOf(tokenId);\r\n    return (spender == owner ||\r\n      getApproved(tokenId) == spender ||\r\n      isApprovedForAll(owner, spender));\r\n  }\r\n\r\n  /**\r\n   * @dev Safely mints `tokenId` and transfers it to `to`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must not exist.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _safeMint(address to, uint256 tokenId) internal virtual {\r\n    _safeMint(to, tokenId, '');\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n   * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n   */\r\n  function _safeMint(\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes memory _data\r\n  ) internal virtual {\r\n    _mint(to, tokenId);\r\n    require(\r\n      _checkOnERC721Received(address(0), to, tokenId, _data),\r\n      'ERC721: transfer to non ERC721Receiver implementer'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Mints `tokenId` and transfers it to `to`.\r\n   *\r\n   * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must not exist.\r\n   * - `to` cannot be the zero address.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _mint(address to, uint256 tokenId) internal virtual {\r\n    require(to != address(0), 'ERC721: mint to the zero address');\r\n    require(!_exists(tokenId), 'ERC721: token already minted');\r\n\r\n    _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n    _balances[to] += 1;\r\n    _owners[tokenId] = to;\r\n\r\n    emit Transfer(address(0), to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `tokenId`.\r\n   * The approval is cleared when the token is burned.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _burn(uint256 tokenId) internal virtual {\r\n    address owner = ERC721.ownerOf(tokenId);\r\n\r\n    _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n    // Clear approvals\r\n    _approve(address(0), tokenId);\r\n\r\n    _balances[owner] -= 1;\r\n    delete _owners[tokenId];\r\n\r\n    emit Transfer(owner, address(0), tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers `tokenId` from `from` to `to`.\r\n   *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must be owned by `from`.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _transfer(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) internal virtual {\r\n    require(\r\n      ERC721.ownerOf(tokenId) == from,\r\n      'ERC721: transfer of token that is not own'\r\n    );\r\n    require(to != address(0), 'ERC721: transfer to the zero address');\r\n\r\n    _beforeTokenTransfer(from, to, tokenId);\r\n\r\n    // Clear approvals from the previous owner\r\n    _approve(address(0), tokenId);\r\n\r\n    _balances[from] -= 1;\r\n    _balances[to] += 1;\r\n    _owners[tokenId] = to;\r\n\r\n    emit Transfer(from, to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve `to` to operate on `tokenId`\r\n   *\r\n   * Emits a {Approval} event.\r\n   */\r\n  function _approve(address to, uint256 tokenId) internal virtual {\r\n    _tokenApprovals[tokenId] = to;\r\n    emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve `operator` to operate on all of `owner` tokens\r\n   *\r\n   * Emits a {ApprovalForAll} event.\r\n   */\r\n  function _setApprovalForAll(\r\n    address owner,\r\n    address operator,\r\n    bool approved\r\n  ) internal virtual {\r\n    require(owner != operator, 'ERC721: approve to caller');\r\n    _operatorApprovals[owner][operator] = approved;\r\n    emit ApprovalForAll(owner, operator, approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n   * The call is not executed if the target address is not a contract.\r\n   *\r\n   * @param from address representing the previous owner of the given token ID\r\n   * @param to target address that will receive the tokens\r\n   * @param tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes optional data to send along with the call\r\n   * @return bool whether the call correctly returned the expected magic value\r\n   */\r\n  function _checkOnERC721Received(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes memory _data\r\n  ) private returns (bool) {\r\n    if (to.isContract()) {\r\n      try\r\n        IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data)\r\n      returns (bytes4 retval) {\r\n        return retval == IERC721Receiver.onERC721Received.selector;\r\n      } catch (bytes memory reason) {\r\n        if (reason.length == 0) {\r\n          revert('ERC721: transfer to non ERC721Receiver implementer');\r\n        } else {\r\n          assembly {\r\n            revert(add(32, reason), mload(reason))\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Hook that is called before any token transfer. This includes minting\r\n   * and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n   * transferred to `to`.\r\n   * - When `from` is zero, `tokenId` will be minted for `to`.\r\n   * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n   * - `from` and `to` are never both zero.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) internal virtual {}\r\n}\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    _transferOwnership(_msgSender());\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view virtual returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    _transferOwnership(address(0));\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Internal function without access restriction.\r\n   */\r\n  function _transferOwnership(address newOwner) internal virtual {\r\n    address oldOwner = _owner;\r\n    _owner = newOwner;\r\n    emit OwnershipTransferred(oldOwner, newOwner);\r\n  }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/cryptography/ECDSA.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n  enum RecoverError {\r\n    NoError,\r\n    InvalidSignature,\r\n    InvalidSignatureLength,\r\n    InvalidSignatureS,\r\n    InvalidSignatureV\r\n  }\r\n\r\n  function _throwError(RecoverError error) private pure {\r\n    if (error == RecoverError.NoError) {\r\n      return; // no error: do nothing\r\n    } else if (error == RecoverError.InvalidSignature) {\r\n      revert('ECDSA: invalid signature');\r\n    } else if (error == RecoverError.InvalidSignatureLength) {\r\n      revert('ECDSA: invalid signature length');\r\n    } else if (error == RecoverError.InvalidSignatureS) {\r\n      revert(\"ECDSA: invalid signature 's' value\");\r\n    } else if (error == RecoverError.InvalidSignatureV) {\r\n      revert(\"ECDSA: invalid signature 'v' value\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address that signed a hashed message (`hash`) with\r\n   * `signature` or error string. This address can then be used for verification purposes.\r\n   *\r\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n   * this function rejects them by requiring the `s` value to be in the lower\r\n   * half order, and the `v` value to be either 27 or 28.\r\n   *\r\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n   * verification to be secure: it is possible to craft signatures that\r\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n   * this is by receiving a hash of the original message (which may otherwise\r\n   * be too long), and then calling {toEthSignedMessageHash} on it.\r\n   *\r\n   * Documentation for signature generation:\r\n   * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n   * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function tryRecover(bytes32 hash, bytes memory signature)\r\n    internal\r\n    pure\r\n    returns (address, RecoverError)\r\n  {\r\n    // Check the signature length\r\n    // - case 65: r,s,v signature (standard)\r\n    // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n    if (signature.length == 65) {\r\n      bytes32 r;\r\n      bytes32 s;\r\n      uint8 v;\r\n      // ecrecover takes the signature parameters, and the only way to get them\r\n      // currently is to use assembly.\r\n      assembly {\r\n        r := mload(add(signature, 0x20))\r\n        s := mload(add(signature, 0x40))\r\n        v := byte(0, mload(add(signature, 0x60)))\r\n      }\r\n      return tryRecover(hash, v, r, s);\r\n    } else if (signature.length == 64) {\r\n      bytes32 r;\r\n      bytes32 vs;\r\n      // ecrecover takes the signature parameters, and the only way to get them\r\n      // currently is to use assembly.\r\n      assembly {\r\n        r := mload(add(signature, 0x20))\r\n        vs := mload(add(signature, 0x40))\r\n      }\r\n      return tryRecover(hash, r, vs);\r\n    } else {\r\n      return (address(0), RecoverError.InvalidSignatureLength);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address that signed a hashed message (`hash`) with\r\n   * `signature`. This address can then be used for verification purposes.\r\n   *\r\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n   * this function rejects them by requiring the `s` value to be in the lower\r\n   * half order, and the `v` value to be either 27 or 28.\r\n   *\r\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n   * verification to be secure: it is possible to craft signatures that\r\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n   * this is by receiving a hash of the original message (which may otherwise\r\n   * be too long), and then calling {toEthSignedMessageHash} on it.\r\n   */\r\n  function recover(bytes32 hash, bytes memory signature)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n    _throwError(error);\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\r\n   *\r\n   * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function tryRecover(\r\n    bytes32 hash,\r\n    bytes32 r,\r\n    bytes32 vs\r\n  ) internal pure returns (address, RecoverError) {\r\n    bytes32 s;\r\n    uint8 v;\r\n    assembly {\r\n      s := and(\r\n        vs,\r\n        0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n      )\r\n      v := add(shr(255, vs), 27)\r\n    }\r\n    return tryRecover(hash, v, r, s);\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\r\n   *\r\n   * _Available since v4.2._\r\n   */\r\n  function recover(\r\n    bytes32 hash,\r\n    bytes32 r,\r\n    bytes32 vs\r\n  ) internal pure returns (address) {\r\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n    _throwError(error);\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\r\n   * `r` and `s` signature fields separately.\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function tryRecover(\r\n    bytes32 hash,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal pure returns (address, RecoverError) {\r\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n    // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\r\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n    //\r\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n    // these malleable signatures as well.\r\n    if (\r\n      uint256(s) >\r\n      0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\r\n    ) {\r\n      return (address(0), RecoverError.InvalidSignatureS);\r\n    }\r\n    if (v != 27 && v != 28) {\r\n      return (address(0), RecoverError.InvalidSignatureV);\r\n    }\r\n\r\n    // If the signature is valid (and not malleable), return the signer address\r\n    address signer = ecrecover(hash, v, r, s);\r\n    if (signer == address(0)) {\r\n      return (address(0), RecoverError.InvalidSignature);\r\n    }\r\n\r\n    return (signer, RecoverError.NoError);\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n   * `r` and `s` signature fields separately.\r\n   */\r\n  function recover(\r\n    bytes32 hash,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal pure returns (address) {\r\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n    _throwError(error);\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n   * produces hash corresponding to the one signed with the\r\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n   * JSON-RPC method as part of EIP-191.\r\n   *\r\n   * See {recover}.\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return\r\n      keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\r\n   * produces hash corresponding to the one signed with the\r\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n   * JSON-RPC method as part of EIP-191.\r\n   *\r\n   * See {recover}.\r\n   */\r\n  function toEthSignedMessageHash(bytes memory s)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    return\r\n      keccak256(\r\n        abi.encodePacked(\r\n          '\\x19Ethereum Signed Message:\\n',\r\n          Strings.toString(s.length),\r\n          s\r\n        )\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an Ethereum Signed Typed Data, created from a\r\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n   * to the one signed with the\r\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n   * JSON-RPC method as part of EIP-712.\r\n   *\r\n   * See {recover}.\r\n   */\r\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    return keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\r\n  }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/cryptography/draft-EIP712.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\r\n *\r\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\r\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\r\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\r\n *\r\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\r\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\r\n * ({_hashTypedDataV4}).\r\n *\r\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\r\n * the chain id to protect against replay attacks on an eventual fork of the chain.\r\n *\r\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\r\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\r\n *\r\n * _Available since v3.4._\r\n */\r\nabstract contract EIP712 {\r\n  /* solhint-disable var-name-mixedcase */\r\n  // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\r\n  // invalidate the cached domain separator if the chain id changes.\r\n  bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\r\n  uint256 private immutable _CACHED_CHAIN_ID;\r\n  address private immutable _CACHED_THIS;\r\n\r\n  bytes32 private immutable _HASHED_NAME;\r\n  bytes32 private immutable _HASHED_VERSION;\r\n  bytes32 private immutable _TYPE_HASH;\r\n\r\n  /* solhint-enable var-name-mixedcase */\r\n\r\n  /**\r\n   * @dev Initializes the domain separator and parameter caches.\r\n   *\r\n   * The meaning of `name` and `version` is specified in\r\n   * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\r\n   *\r\n   * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\r\n   * - `version`: the current major version of the signing domain.\r\n   *\r\n   * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\r\n   * contract upgrade].\r\n   */\r\n  constructor(string memory name, string memory version) {\r\n    bytes32 hashedName = keccak256(bytes(name));\r\n    bytes32 hashedVersion = keccak256(bytes(version));\r\n    bytes32 typeHash = keccak256(\r\n      'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\r\n    );\r\n    _HASHED_NAME = hashedName;\r\n    _HASHED_VERSION = hashedVersion;\r\n    _CACHED_CHAIN_ID = block.chainid;\r\n    _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(\r\n      typeHash,\r\n      hashedName,\r\n      hashedVersion\r\n    );\r\n    _CACHED_THIS = address(this);\r\n    _TYPE_HASH = typeHash;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the domain separator for the current chain.\r\n   */\r\n  function _domainSeparatorV4() internal view returns (bytes32) {\r\n    if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\r\n      return _CACHED_DOMAIN_SEPARATOR;\r\n    } else {\r\n      return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\r\n    }\r\n  }\r\n\r\n  function _buildDomainSeparator(\r\n    bytes32 typeHash,\r\n    bytes32 nameHash,\r\n    bytes32 versionHash\r\n  ) private view returns (bytes32) {\r\n    return\r\n      keccak256(\r\n        abi.encode(\r\n          typeHash,\r\n          nameHash,\r\n          versionHash,\r\n          block.chainid,\r\n          address(this)\r\n        )\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\r\n   * function returns the hash of the fully encoded EIP712 message for this domain.\r\n   *\r\n   * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\r\n   *\r\n   * ```solidity\r\n   * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\r\n   *     keccak256(\"Mail(address to,string contents)\"),\r\n   *     mailTo,\r\n   *     keccak256(bytes(mailContents))\r\n   * )));\r\n   * address signer = ECDSA.recover(digest, signature);\r\n   * ```\r\n   */\r\n  function _hashTypedDataV4(bytes32 structHash)\r\n    internal\r\n    view\r\n    virtual\r\n    returns (bytes32)\r\n  {\r\n    return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\r\n  }\r\n}\r\n\r\n// File contracts/ActualGenesis.sol\r\n\r\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588\u2588\u2588\u2588\u2580\u255d\u2559`    ``\u2559\u2580\u2580\u2588\u2588\u2588\u2593\u2580\u2580\u255d\u2580\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588\u2588                       \u2551\u2588\u2588\u2588\u2588\r\n// \u2588\u2588\u2588\u2593\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584,           \u2553\u2593\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`           \u2553\u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580^     \u2553\u2593\u2584      \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588\u2588\u2588\u2588\u258c      \u2584\u2588\u2588\u2588\u258c      \u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588\u2588\u2588\u2568     ,\u2593\u2588\u2588\u2588\u2588M       \u2580\u2588\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588\u2588       \u2588\u2588\u2588\u2588\u2588\u255b         \u2580\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588M       \u2568\u2580\u2580'            \u255a\u2588\u2588\u2588\u2588\r\n// \u2588\u2588              \u2553\u2588\u2593         \u2580\u2588\u2588\r\n// \u2588\u2588           ,\u2584\u2588\u2588\u2588\u2588\u2588,        \u2588\u2588\r\n// \u2588\u2588\u2593\u2584     ,\u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2584,   \u2584\u2593\u2588\u2588\r\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2588\u2588\r\n// \u2588\u2588 \u2588\u2580\u2580\u2580\u2580\u2580\u2588 \u2588  \u2584\u2584\u2584\u2580\u2580\u2588 \u2588\u2580\u2580\u2580\u2580\u2580\u2588 \u2588\u2588\r\n// \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588\u2584 \u2588\u2584\u2584\u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588\r\n// \u2588\u2588 \u2588 \u2580\u2580\u2580 \u2588 \u2584\u2588\u2588 \u2580\u2584\u2580\u2580\u2588 \u2588 \u2580\u2580\u2580 \u2588 \u2588\u2588\r\n// \u2588\u2588 \u2580\u2580\u2580\u2580\u2580\u2580\u2580 \u2580 \u2588\u2584\u2580 \u2580 \u2580 \u2580\u2580\u2580\u2580\u2580\u2580\u2580 \u2588\u2588\r\n// \u2588\u2588 \u2580\u2588\u2584\u2584\u2580\u2580\u2580 \u2584 \u2580 \u2580\u2584\u2584\u2584\u2584  \u2580\u2584\u2588\u2580\u2588\u2580 \u2588\u2588\r\n// \u2588\u2588 \u2580\u2588\u2584\u2588\u2588 \u2580\u2588 \u2588\u2580 \u2584 \u2588\u2580\u2580\u2580\u2584\u2580 \u2580\u2588\u2584  \u2588\u2588\r\n// \u2588\u2588 \u2588 \u2584\u2580 \u2584\u2580\u2588\u2584 \u2584\u2580\u2584\u2584 \u2588 \u2588\u2580\u2580\u2584\u2580\u2580\u2588\u2580 \u2588\u2588\r\n// \u2588\u2588   \u2584\u2580\u2588\u2584\u2580\u2584\u2584 \u2588\u2588\u2580\u2580 \u2588\u2580\u2584 \u2588\u2588\u2580\u2588\u2584  \u2588\u2588\r\n// \u2588\u2588 \u2580\u2580 \u2580\u2580 \u2580\u2580\u2588   \u2580  \u2580\u2588\u2580\u2580\u2580\u2588\u2580\u2580   \u2588\u2588\r\n// \u2588\u2588 \u2588\u2580\u2580\u2580\u2580\u2580\u2588 \u2584\u2580  \u2584 \u2584 \u2588 \u2580 \u2588\u2584\u2584\u2584\u2584 \u2588\u2588\r\n// \u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588 \u2580\u2584\u2580\u2580\u2584\u2580\u2588\u2584\u2580\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588 \u2588\u2588\r\n// \u2588\u2588 \u2588 \u2580\u2580\u2580 \u2588 \u2584\u2588 \u2588\u2580\u2588\u2580\u2588\u2580 \u2580\u2584\u2584\u2588\u2584\u2588  \u2588\u2588\r\n// \u2588\u2588 \u2580\u2580\u2580\u2580\u2580\u2580\u2580 \u2580   \u2580\u2580 \u2580 \u2580\u2580   \u2580\u2580\u2580 \u2588\u2588\r\n// \u2588\u2588 ------------------------- \u2588\u2588\r\n// \u2588\u2588 ACTUAL            GENESIS \u2588\u2588\r\n// \u2588\u2588 BY           NEU \u00d7 REGIME \u2588\u2588\r\n// \u2588\u2588                           \u2588\u2588\r\n// \u2588\u2588    https://actual.gallery \u2588\u2588\r\n// \u2588\u2588            @actualgallery \u2588\u2588\r\n// \u2588\u2588                           \u2588\u2588\r\n// \u2588\u2588        https://neuregi.me \u2588\u2588\r\n// \u2588\u2588               @neuxregime \u2588\u2588\r\n// \u2588\u2588 ------------------------- \u2588\u2588\r\n// \u2588\u2588\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2588\u2588\r\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588 \"NEVER BEFORE, HAS THERE  \u2588\u2588\r\n// \u2588\u2588 BEEN SO MUCH LIGHT\" \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588 -M. \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 ENCODING REQUIRES \u2588\u2588\r\n// \u2588\u2588 POWERLINE SUPPORTING FONT \u2588\u2588\r\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 JAN. 6, 2022 \u2588\u2588\r\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\r\n\r\npragma solidity ^0.8.4;\r\n\r\nerror TokenURILocked();\r\nerror ArweaveIDLocked();\r\nerror SaleIsLocked();\r\nerror AllArtworksSold();\r\nerror ArtworkAlreadyMinted();\r\nerror ArtworkDoesNotExist();\r\nerror NewMaxNumberLowerThanCurrentNumberOfMintedArtworks();\r\nerror NewMaxNumberGreaterThanTotalSupply();\r\nerror AmountMoreThanSetPrice();\r\nerror AmountLessThanSetPrice();\r\nerror MoreThanOneArtworkExistsAlready();\r\nerror SenderIsDifferentFromOwner();\r\nerror ArtworkWithProvidedTokenIdDoesNotExist();\r\nerror DirectMintDisallowedSignatureMismatch();\r\nerror WithdrawalFailed();\r\n\r\ncontract ActualGenesis is ERC721, EIP712, Ownable {\r\n  string public tokenBaseURI;\r\n  bool public tokenURILocked;\r\n\r\n  string public arweaveID;\r\n  bool public arweaveIDLocked;\r\n\r\n  string public tokenURISuffix = '';\r\n\r\n  bool public saleLocked;\r\n  uint256 public totalSupply;\r\n  uint256 public maxNumberOfArtworks;\r\n  uint256 public numberOfMintedArtworks;\r\n  uint256 public pricePerArtwork;\r\n  uint256 public artistProofs = 10;\r\n\r\n  mapping(uint256 => bool) private tokenIdToIsArtworkPrivate;\r\n  mapping(uint256 => address) private tokenIdToAddressArtworkIsLentTo;\r\n\r\n  event Purchase(address indexed buyer, uint256 price, uint256 indexed tokenId);\r\n  event Gift(address indexed receiver, uint256 indexed tokenId);\r\n  event Lend(\r\n    address indexed from,\r\n    address indexed receiver,\r\n    uint256 indexed tokenId\r\n  );\r\n  event ArweaveIdUpdated(string newArweaveId);\r\n\r\n  constructor(\r\n    string memory _tokenBaseURI,\r\n    bool _saleLocked,\r\n    uint256 _totalSupply,\r\n    uint256 _maxNumberOfArtworks,\r\n    uint256 _pricePerArtwork\r\n  ) ERC721('Actual Genesis', 'ACTUAL') EIP712('Actual Genesis', '1.0.0') {\r\n    tokenBaseURI = _tokenBaseURI;\r\n    saleLocked = _saleLocked;\r\n    totalSupply = _totalSupply;\r\n    maxNumberOfArtworks = _maxNumberOfArtworks;\r\n    pricePerArtwork = _pricePerArtwork;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether th eprovided `tokenId` exists.\r\n   *\r\n   * @param tokenId artwork token id\r\n   *\r\n   * @return true if artwork exists (has been minted\r\n   * already), false otherwise\r\n   */\r\n  function exists(uint256 tokenId) public view returns (bool) {\r\n    return _exists(tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Base URI for computing {tokenURI}. The resulting\r\n   * tokenURI for each token will be the concatenation of\r\n   * the `baseURI` and the `tokenId`.\r\n   */\r\n  function _baseURI() internal view override returns (string memory) {\r\n    return tokenBaseURI;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes `baseURI`, useful when freezing the\r\n   * contract.\r\n   *\r\n   * @notice that value cannot be changed if `tokenURILocked`\r\n   * is locked.\r\n   *\r\n   * @param newBaseURI new URI replacing the old one\r\n   */\r\n  function setTokenBaseURI(string memory newBaseURI) public onlyOwner {\r\n    if (tokenURILocked == true) revert TokenURILocked();\r\n    tokenBaseURI = newBaseURI;\r\n  }\r\n\r\n  /**\r\n   * @dev Overriden `tokenURI` with the ability to add a\r\n   * suffix to URI. This is particularly helpful if\r\n   * if metadata is \"baked\" as static .json files.\r\n   *\r\n   * @notice calls ERC721 `tokenURI` first and concatenates\r\n   * the returned value with `tokenURISuffix`\r\n   *\r\n   * @param tokenId id of token to retrive URI for\r\n   */\r\n  function tokenURI(uint256 tokenId)\r\n    public\r\n    view\r\n    override\r\n    returns (string memory)\r\n  {\r\n    string memory tokenURIBasename = super.tokenURI(tokenId);\r\n\r\n    return\r\n      bytes(tokenURIBasename).length > 0\r\n        ? string(abi.encodePacked(tokenURIBasename, tokenURISuffix))\r\n        : '';\r\n  }\r\n\r\n  /**\r\n   * @dev Lock the `baseURI` preventing any changes to\r\n   * be committed to it. Useful when freezing the contract.\r\n   */\r\n  function lockTokenURI() public onlyOwner {\r\n    tokenURILocked = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes `tokenURISuffix`, useful when freezing the\r\n   * contract after all assets have been decentralized.\r\n   *\r\n   * @param newTokenURISuffix new suffix replacing the old one\r\n   */\r\n  function setTokenURISuffix(string memory newTokenURISuffix) public onlyOwner {\r\n    tokenURISuffix = newTokenURISuffix;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes `arweaveID`, useful when freezing the\r\n   * contract after all assets have been decentralized.\r\n   *\r\n   * @notice that value cannot be changed if `arweaveIDLocked`\r\n   * is locked.\r\n   *\r\n   * @param newArweaveID new ID replacing the old one\r\n   */\r\n  function setArweaveID(string memory newArweaveID) public onlyOwner {\r\n    if (arweaveIDLocked == true) revert ArweaveIDLocked();\r\n    arweaveID = newArweaveID;\r\n  }\r\n\r\n  /**\r\n   * @dev Lock the `arweaveID` preventing any changes to be\r\n   * committed to it. Useful when freezing the contract.\r\n   */\r\n  function lockArweaveID() public onlyOwner {\r\n    arweaveIDLocked = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Collects balance sum and transfers to sender.\r\n   */\r\n  function collectSum() public onlyOwner {\r\n    (bool success, ) = payable(msg.sender).call{value: address(this).balance}(\r\n      ''\r\n    );\r\n    if (success == false) revert WithdrawalFailed();\r\n  }\r\n\r\n  /**\r\n   * @dev Permits lending of an artwork to an arbitrary\r\n   * address 'addressToLendTo'. This functionality is to be\r\n   * used in conjuction with setArtworkPublic/Private\r\n   *\r\n   * Requirements:\r\n   * - `tokenID` must be owned by msg.sender\r\n   * - `tokenID` must be already minted\r\n   *\r\n   * @param tokenID id of token that will be lent\r\n   * @param addressToLendTo address of the borrower\r\n   *\r\n   * Emits a {Lend} event.\r\n   */\r\n  function lend(uint256 tokenID, address addressToLendTo) public {\r\n    if (!_exists(tokenID)) revert ArtworkDoesNotExist();\r\n    if (ownerOf(tokenID) != msg.sender) revert SenderIsDifferentFromOwner();\r\n\r\n    emit Lend(ownerOf(tokenID), addressToLendTo, tokenID);\r\n    tokenIdToAddressArtworkIsLentTo[tokenID] = addressToLendTo;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks the address to which `tokenID` is lent to.\r\n   *\r\n   * Requirements:\r\n   * - `tokenID` must be already minted\r\n   *\r\n   * @param tokenID id of token that is lent\r\n   * @return address of the borrower of `tokenID`\r\n   */\r\n  function getLentToAddress(uint256 tokenID) public view returns (address) {\r\n    if (!_exists(tokenID)) revert ArtworkDoesNotExist();\r\n    return tokenIdToAddressArtworkIsLentTo[tokenID];\r\n  }\r\n\r\n  /**\r\n   * @dev Makes an artwork with `tokenID` public\r\n   *\r\n   * Requirements:\r\n   * - `tokenID` must be owned by msg.sender\r\n   * - `tokenID` must be already minted\r\n   *\r\n   * @param tokenID id of token that will be made public\r\n   */\r\n  function setArtworkPublic(uint256 tokenID) public {\r\n    setArtworkPrivateState(tokenID, false);\r\n  }\r\n\r\n  /**\r\n   * @dev Makes an artwork with `tokenID` private\r\n   *\r\n   * Requirements:\r\n   * - `tokenID` must be owned by msg.sender\r\n   * - `tokenID` must be already minted\r\n   *\r\n   * @param tokenID id of token that will be made private\r\n   */\r\n  function setArtworkPrivate(uint256 tokenID) public {\r\n    setArtworkPrivateState(tokenID, true);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if an artwork with `tokenID` is public or\r\n   * private.\r\n   *\r\n   * Requirements:\r\n   * - `tokenID` must be already minted\r\n   *\r\n   * @param tokenID id of artwork to check\r\n   * @return true if private, false if public\r\n   */\r\n  function isArtworkPrivate(uint256 tokenID) public view returns (bool) {\r\n    if (!_exists(tokenID)) revert ArtworkDoesNotExist();\r\n    return tokenIdToIsArtworkPrivate[tokenID];\r\n  }\r\n\r\n  /**\r\n   * @dev Helper function to modify the private/public state\r\n   * of `tokenID`.\r\n   *\r\n   * Requirements:\r\n   * - `tokenID` must be owned by msg.sender\r\n   * - `tokenID` must be already minted\r\n   *\r\n   * @param tokenID id of token to be made private/public\r\n   * @param flag true to make private, false to make public\r\n   */\r\n  function setArtworkPrivateState(uint256 tokenID, bool flag) private {\r\n    if (!_exists(tokenID)) revert ArtworkDoesNotExist();\r\n    if (ownerOf(tokenID) != msg.sender) revert SenderIsDifferentFromOwner();\r\n\r\n    tokenIdToIsArtworkPrivate[tokenID] = flag;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks the number of artworks available for minting.\r\n   *\r\n   * @return the number of artworks available for minting\r\n   */\r\n  function artworksLeft() public view returns (uint256) {\r\n    return maxNumberOfArtworks - numberOfMintedArtworks;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the maximum number of artworks available for\r\n   * minting.\r\n   *\r\n   * Requirements:\r\n   * - new maximum must be < than total number of artworks\r\n   * - new maximum must be > than  artworks minted so far\r\n   *\r\n   * @param newMaxNumberOfArtworks new maximum\r\n   */\r\n  function setMaxNumberOfArtworks(uint256 newMaxNumberOfArtworks)\r\n    public\r\n    onlyOwner\r\n  {\r\n    if (newMaxNumberOfArtworks < numberOfMintedArtworks)\r\n      revert NewMaxNumberLowerThanCurrentNumberOfMintedArtworks();\r\n    if (newMaxNumberOfArtworks >= totalSupply)\r\n      revert NewMaxNumberGreaterThanTotalSupply();\r\n\r\n    maxNumberOfArtworks = newMaxNumberOfArtworks;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier ensuring that the minting tx is valid.\r\n   *\r\n   * Requirements:\r\n   * - sale is not locked\r\n   * - there are artworks left to be minted\r\n   * - artwork is not already minted\r\n   * - artwork `tokenId` is valid and <= total supply\r\n   * - transaction value is exactly same as the base price\r\n   *\r\n   * @param newTokenId new token ID that will be minted\r\n   */\r\n  modifier isSaleValid(uint256 newTokenId) {\r\n    if (msg.sender != owner() && saleLocked == true) revert SaleIsLocked();\r\n\r\n    if (artworksLeft() == 0) revert AllArtworksSold();\r\n\r\n    if (_exists(newTokenId)) revert ArtworkAlreadyMinted();\r\n\r\n    if (newTokenId > totalSupply)\r\n      revert ArtworkWithProvidedTokenIdDoesNotExist();\r\n\r\n    if (msg.value < pricePerArtwork && msg.sender != owner())\r\n      revert AmountLessThanSetPrice();\r\n\r\n    if (msg.value > pricePerArtwork && msg.sender != owner())\r\n      revert AmountMoreThanSetPrice();\r\n\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Mints `artistProofs` number of artworks with\r\n   * `tokenID` starting at 1 (inclusive) and increasing\r\n   * to `artistProofs` (inclusive).\r\n   *\r\n   * Requirements:\r\n   * - No artworks have been sold/minted already\r\n   */\r\n  function mintArtistProofs() public onlyOwner {\r\n    if (numberOfMintedArtworks > 0) revert MoreThanOneArtworkExistsAlready();\r\n    for (uint256 i = 1; i <= artistProofs; i++) {\r\n      mintArtistProof(i);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Helper function to mint artist proofs\r\n   */\r\n  function mintArtistProof(uint256 newTokenId) private isSaleValid(newTokenId) {\r\n    emit Purchase(msg.sender, msg.value, newTokenId);\r\n    _mintPiece(newTokenId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Computes EIP 712 hash of typed structure of\r\n   * `account` and `tokenID`\r\n   *\r\n   * @param account msg.sender of minting transaction\r\n   * @param newTokenId artwork to be minted\r\n   *\r\n   * @return the hash of the fully encoded EIP712 message\r\n   * for this domain.\r\n   */\r\n  function _hash(address account, uint256 newTokenId)\r\n    internal\r\n    view\r\n    returns (bytes32)\r\n  {\r\n    return\r\n      _hashTypedDataV4(\r\n        keccak256(\r\n          abi.encode(\r\n            keccak256('NFT(uint256 Artwork,address Buyer)'),\r\n            newTokenId,\r\n            account\r\n          )\r\n        )\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Compares an EIP 712 signed message of\r\n   * `account`and `newTokenId` with one provided by the `buy`\r\n   * function (incoming from client/wallet app).\r\n   *\r\n   * @param account msg.sender of minting transaction\r\n   * @param newTokenId artwork to be minted\r\n   * @param signature provided by the client/wallet\r\n   *\r\n   * @return true if contract-computed signature matches the\r\n   * client/wallet signature, otherwise false, meaning that\r\n   * the msg.sender is different from the wallet account that\r\n   * signed the message.\r\n   */\r\n  function matchAddressSigner(\r\n    address account,\r\n    uint256 newTokenId,\r\n    bytes memory signature\r\n  ) private view returns (bool) {\r\n    return account == ECDSA.recover(_hash(account, newTokenId), signature);\r\n    // return _hash(account, newTokenId) == signature;\r\n  }\r\n\r\n  /**\r\n   * @dev Mints an artwork with `newTokenId`\r\n   *\r\n   * Requirements:\r\n   * - see isSaleValid(uint256 newTokenId)\r\n   * - see matchAddressSigner(...)\r\n   *\r\n   * @param signature client-provided wallet-signed keccak256\r\n   * hash of msg.sender and `newTokenId`\r\n   * @param newTokenId artwork to be minted\r\n   *\r\n   * Emits a {Transfer} and {Purchase} event.\r\n   */\r\n  function buy(bytes memory signature, uint256 newTokenId)\r\n    public\r\n    payable\r\n    isSaleValid(newTokenId)\r\n  {\r\n    if (matchAddressSigner(msg.sender, newTokenId, signature) == false)\r\n      revert DirectMintDisallowedSignatureMismatch();\r\n\r\n    emit Purchase(msg.sender, msg.value, newTokenId);\r\n    _mintPiece(newTokenId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Gifting/airdrop functionality for owner\r\n   *\r\n   * Requirements:\r\n   * - see isSaleValid(uint256 newTokenId)\r\n   * - see onlyOwner(...)\r\n   *\r\n   * @param receiver address that will receive the artwork\r\n   * @param newTokenId artwork to be minted\r\n   *\r\n   * Emits a {Transfer} and {Gift} event.\r\n   */\r\n  function gift(uint256 newTokenId, address receiver)\r\n    public\r\n    payable\r\n    onlyOwner\r\n    isSaleValid(newTokenId)\r\n  {\r\n    emit Gift(receiver, newTokenId);\r\n    _mintPiece(newTokenId, receiver);\r\n  }\r\n\r\n  /**\r\n   * @dev Helper function to mint artworks. Used in gift, buy,\r\n   *and mintArtistProof.\r\n   *\r\n   * By defaults sets:\r\n   * - the artwork to be public\r\n   * - lent to the address of the owner (msg.sender)\r\n   * - increments `numberOfMintedArtworks`, the number of\r\n   *   artworks minted so far\r\n   *\r\n   * @param toAddress address that will own the artwork\r\n   * @param newTokenId artwork to be minted\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function _mintPiece(uint256 newTokenId, address toAddress) private {\r\n    tokenIdToIsArtworkPrivate[newTokenId] = false;\r\n    tokenIdToAddressArtworkIsLentTo[newTokenId] = msg.sender;\r\n    numberOfMintedArtworks += 1;\r\n\r\n    _safeMint(toAddress, newTokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Locks public sale\r\n   *\r\n   * Requirements:\r\n   * - see onlyOwner(...)\r\n   */\r\n  function lockSale() public onlyOwner {\r\n    saleLocked = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Unlocks public sale\r\n   *\r\n   * Requirements:\r\n   * - see onlyOwner(...)\r\n   */\r\n  function unlockSale() public onlyOwner {\r\n    saleLocked = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter function to determine if public sale is\r\n   * locked or not.\r\n   *\r\n   * @return true if sale is locked, false otherwise\r\n   */\r\n  function getSaleLocked() public view returns (bool) {\r\n    return saleLocked;\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenBaseURI\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_saleLocked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxNumberOfArtworks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pricePerArtwork\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AllArtworksSold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AmountLessThanSetPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AmountMoreThanSetPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArtworkAlreadyMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArtworkDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArtworkWithProvidedTokenIdDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArweaveIDLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DirectMintDisallowedSignatureMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MoreThanOneArtworkExistsAlready\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewMaxNumberGreaterThanTotalSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewMaxNumberLowerThanCurrentNumberOfMintedArtworks\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SaleIsLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderIsDifferentFromOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenURILocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawalFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newArweaveId\",\"type\":\"string\"}],\"name\":\"ArweaveIdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Gift\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Lend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artistProofs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artworksLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arweaveID\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arweaveIDLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectSum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getLentToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSaleLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"gift\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"isArtworkPrivate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addressToLendTo\",\"type\":\"address\"}],\"name\":\"lend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockArweaveID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxNumberOfArtworks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintArtistProofs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfMintedArtworks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pricePerArtwork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"setArtworkPrivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"setArtworkPublic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newArweaveID\",\"type\":\"string\"}],\"name\":\"setArweaveID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxNumberOfArtworks\",\"type\":\"uint256\"}],\"name\":\"setMaxNumberOfArtworks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setTokenBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newTokenURISuffix\",\"type\":\"string\"}],\"name\":\"setTokenURISuffix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenBaseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenURILocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenURISuffix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ActualGenesis", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000138800000000000000000000000000000000000000000000000000000000000007d000000000000000000000000000000000000000000000000001bc16d674ec8000000000000000000000000000000000000000000000000000000000000000002068747470733a2f2f646170702e61637475616c2e67616c6c6572792f6170692f", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://800119f736278e36e67325cdfc629e6a4d2071dea7eb8fc0466406af58b12d75"}