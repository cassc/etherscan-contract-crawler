{"SourceCode": "pragma experimental ABIEncoderV2;\r\n// File: contracts/modules/common/Utils.sol\r\n// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n// SPDX-License-Identifier: GPL-3.0-only\r\n/**\r\n * @title Utils\r\n * @notice Common utility methods used by modules.\r\n */\r\nlibrary Utils {\r\n    /**\r\n    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\r\n    * @param _signedHash The signed hash\r\n    * @param _signatures The concatenated signatures.\r\n    * @param _index The index of the signature to recover.\r\n    */\r\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        // we jump 32 (0x20) as the first slot of bytes contains the length\r\n        // we jump 65 (0x41) per signature\r\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\r\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\r\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\r\n        }\r\n        require(v == 27 || v == 28);\r\n        address recoveredAddress = ecrecover(_signedHash, v, r, s);\r\n        require(recoveredAddress != address(0), \"Utils: ecrecover returned 0\");\r\n        return recoveredAddress;\r\n    }\r\n    /**\r\n    * @notice Helper method to parse data and extract the method signature.\r\n    */\r\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\r\n        require(_data.length >= 4, \"RM: Invalid functionPrefix\");\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            prefix := mload(add(_data, 0x20))\r\n        }\r\n    }\r\n    /**\r\n    * @notice Returns ceil(a / b).\r\n    */\r\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        if (a % b == 0) {\r\n            return c;\r\n        } else {\r\n            return c + 1;\r\n        }\r\n    }\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a < b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n}\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n// File: contracts/wallet/IWallet.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IWallet\r\n * @notice Interface for the BaseWallet\r\n */\r\ninterface IWallet {\r\n    /**\r\n     * @notice Returns the wallet owner.\r\n     * @return The wallet owner address.\r\n     */\r\n    function owner() external view returns (address);\r\n    /**\r\n     * @notice Returns the number of authorised modules.\r\n     * @return The number of authorised modules.\r\n     */\r\n    function modules() external view returns (uint);\r\n    /**\r\n     * @notice Sets a new owner for the wallet.\r\n     * @param _newOwner The new owner.\r\n     */\r\n    function setOwner(address _newOwner) external;\r\n    /**\r\n     * @notice Checks if a module is authorised on the wallet.\r\n     * @param _module The module address to check.\r\n     * @return `true` if the module is authorised, otherwise `false`.\r\n     */\r\n    function authorised(address _module) external view returns (bool);\r\n    /**\r\n     * @notice Returns the module responsible for a static call redirection.\r\n     * @param _sig The signature of the static call.\r\n     * @return the module doing the redirection\r\n     */\r\n    function enabled(bytes4 _sig) external view returns (address);\r\n    /**\r\n     * @notice Enables/Disables a module.\r\n     * @param _module The target module.\r\n     * @param _value Set to `true` to authorise the module.\r\n     */\r\n    function authoriseModule(address _module, bool _value) external;\r\n    /**\r\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\r\n    * @param _module The target module.\r\n    * @param _method The static method signature.\r\n    */\r\n    function enableStaticCall(address _module, bytes4 _method) external;\r\n}\r\n// File: contracts/infrastructure/IModuleRegistry.sol\r\n// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IModuleRegistry\r\n * @notice Interface for the registry of authorised modules.\r\n */\r\ninterface IModuleRegistry {\r\n    function registerModule(address _module, bytes32 _name) external;\r\n    function deregisterModule(address _module) external;\r\n    function registerUpgrader(address _upgrader, bytes32 _name) external;\r\n    function deregisterUpgrader(address _upgrader) external;\r\n    function recoverToken(address _token) external;\r\n    function moduleInfo(address _module) external view returns (bytes32);\r\n    function upgraderInfo(address _upgrader) external view returns (bytes32);\r\n    function isRegisteredModule(address _module) external view returns (bool);\r\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\r\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool);\r\n}\r\n// File: contracts/infrastructure/storage/ILockStorage.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\npragma solidity >=0.5.4 <0.7.0;\r\ninterface ILockStorage {\r\n    function isLocked(address _wallet) external view returns (bool);\r\n    function getLock(address _wallet) external view returns (uint256);\r\n    function getLocker(address _wallet) external view returns (address);\r\n    function setLock(address _wallet, address _locker, uint256 _releaseAfter) external;\r\n}\r\n// File: contracts/modules/common/IFeature.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IFeature\r\n * @notice Interface for a Feature.\r\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\r\n */\r\ninterface IFeature {\r\n    enum OwnerSignature {\r\n        Anyone,             // Anyone\r\n        Required,           // Owner required\r\n        Optional,           // Owner and/or guardians\r\n        Disallowed          // guardians only\r\n    }\r\n    /**\r\n    * @notice Utility method to recover any ERC20 token that was sent to the Feature by mistake.\r\n    * @param _token The token to recover.\r\n    */\r\n    function recoverToken(address _token) external;\r\n    /**\r\n     * @notice Inits a Feature for a wallet by e.g. setting some wallet specific parameters in storage.\r\n     * @param _wallet The wallet.\r\n     */\r\n    function init(address _wallet) external;\r\n    /**\r\n     * @notice Helper method to check if an address is an authorised feature of a target wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _feature The address.\r\n     */\r\n    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) external view returns (bool);\r\n    /**\r\n    * @notice Gets the number of valid signatures that must be provided to execute a\r\n    * specific relayed transaction.\r\n    * @param _wallet The target wallet.\r\n    * @param _data The data of the relayed transaction.\r\n    * @return The number of required signatures and the wallet owner signature requirement.\r\n    */\r\n    function getRequiredSignatures(address _wallet, bytes calldata _data) external view returns (uint256, OwnerSignature);\r\n    /**\r\n    * @notice Gets the list of static call signatures that this feature responds to on behalf of wallets\r\n    */\r\n    function getStaticCallSignatures() external view returns (bytes4[] memory);\r\n}\r\n// File: lib/other/ERC20.sol\r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * ERC20 contract interface.\r\n */\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function decimals() external view returns (uint);\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n}\r\n// File: contracts/infrastructure/storage/ILimitStorage.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n/**\r\n * @title ILimitStorage\r\n * @notice LimitStorage interface\r\n */\r\ninterface ILimitStorage {\r\n    struct Limit {\r\n        // the current limit\r\n        uint128 current;\r\n        // the pending limit if any\r\n        uint128 pending;\r\n        // when the pending limit becomes the current limit\r\n        uint64 changeAfter;\r\n    }\r\n    struct DailySpent {\r\n        // The amount already spent during the current period\r\n        uint128 alreadySpent;\r\n        // The end of the current period\r\n        uint64 periodEnd;\r\n    }\r\n    function setLimit(address _wallet, Limit memory _limit) external;\r\n    function getLimit(address _wallet) external view returns (Limit memory _limit);\r\n    function setDailySpent(address _wallet, DailySpent memory _dailySpent) external;\r\n    function getDailySpent(address _wallet) external view returns (DailySpent memory _dailySpent);\r\n    function setLimitAndDailySpent(address _wallet, Limit memory _limit, DailySpent memory _dailySpent) external;\r\n    function getLimitAndDailySpent(address _wallet) external view returns (Limit memory _limit, DailySpent memory _dailySpent);\r\n}\r\n// File: contracts/modules/common/IVersionManager.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IVersionManager\r\n * @notice Interface for the VersionManager module.\r\n * @author Olivier VDB - <olivier@argent.xyz>\r\n */\r\ninterface IVersionManager {\r\n    /**\r\n     * @notice Returns true if the feature is authorised for the wallet\r\n     * @param _wallet The target wallet.\r\n     * @param _feature The feature.\r\n     */\r\n    function isFeatureAuthorised(address _wallet, address _feature) external view returns (bool);\r\n    /**\r\n     * @notice Lets a feature (caller) invoke a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _to The target address for the transaction.\r\n     * @param _value The value of the transaction.\r\n     * @param _data The data of the transaction.\r\n     */\r\n    function checkAuthorisedFeatureAndInvokeWallet(\r\n        address _wallet,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external returns (bytes memory _res);\r\n    /* ******* Backward Compatibility with old Storages and BaseWallet *************** */\r\n    /**\r\n     * @notice Sets a new owner for the wallet.\r\n     * @param _newOwner The new owner.\r\n     */\r\n    function setOwner(address _wallet, address _newOwner) external;\r\n    /**\r\n     * @notice Lets a feature write data to a storage contract.\r\n     * @param _wallet The target wallet.\r\n     * @param _storage The storage contract.\r\n     * @param _data The data of the call\r\n     */\r\n    function invokeStorage(address _wallet, address _storage, bytes calldata _data) external;\r\n    /**\r\n     * @notice Upgrade a wallet to a new version.\r\n     * @param _wallet the wallet to upgrade\r\n     * @param _toVersion the new version\r\n     */\r\n    function upgradeWallet(address _wallet, uint256 _toVersion) external;\r\n}\r\n// File: contracts/modules/common/BaseFeature.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.s\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n/**\r\n * @title BaseFeature\r\n * @notice Base Feature contract that contains methods common to all Feature contracts.\r\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\r\n */\r\ncontract BaseFeature is IFeature {\r\n    // Empty calldata\r\n    bytes constant internal EMPTY_BYTES = \"\";\r\n    // Mock token address for ETH\r\n    address constant internal ETH_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    // The address of the Lock storage\r\n    ILockStorage internal lockStorage;\r\n    // The address of the Version Manager\r\n    IVersionManager internal versionManager;\r\n    event FeatureCreated(bytes32 name);\r\n    /**\r\n     * @notice Throws if the wallet is locked.\r\n     */\r\n    modifier onlyWhenUnlocked(address _wallet) {\r\n        require(!lockStorage.isLocked(_wallet), \"BF: wallet locked\");\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Throws if the sender is not the VersionManager.\r\n     */\r\n    modifier onlyVersionManager() {\r\n        require(msg.sender == address(versionManager), \"BF: caller must be VersionManager\");\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Throws if the sender is not the owner of the target wallet.\r\n     */\r\n    modifier onlyWalletOwner(address _wallet) {\r\n        require(isOwner(_wallet, msg.sender), \"BF: must be wallet owner\");\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Throws if the sender is not an authorised feature of the target wallet.\r\n     */\r\n    modifier onlyWalletFeature(address _wallet) {\r\n        require(versionManager.isFeatureAuthorised(_wallet, msg.sender), \"BF: must be a wallet feature\");\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Throws if the sender is not the owner of the target wallet or the feature itself.\r\n     */\r\n    modifier onlyWalletOwnerOrFeature(address _wallet) {\r\n        // Wrapping in an internal method reduces deployment cost by avoiding duplication of inlined code\r\n        verifyOwnerOrAuthorisedFeature(_wallet, msg.sender);\r\n        _;\r\n    }\r\n    constructor(\r\n        ILockStorage _lockStorage,\r\n        IVersionManager _versionManager,\r\n        bytes32 _name\r\n    ) public {\r\n        lockStorage = _lockStorage;\r\n        versionManager = _versionManager;\r\n        emit FeatureCreated(_name);\r\n    }\r\n    /**\r\n    * @inheritdoc IFeature\r\n    */\r\n    function recoverToken(address _token) external virtual override {\r\n        uint total = ERC20(_token).balanceOf(address(this));\r\n        _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector, address(versionManager), total));\r\n    }\r\n    /**\r\n     * @notice Inits the feature for a wallet by doing nothing.\r\n     * @dev !! Overriding methods need make sure `init()` can only be called by the VersionManager !!\r\n     * @param _wallet The wallet.\r\n     */\r\n    function init(address _wallet) external virtual override  {}\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function getRequiredSignatures(address, bytes calldata) external virtual view override returns (uint256, OwnerSignature) {\r\n        revert(\"BF: disabled method\");\r\n    }\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function getStaticCallSignatures() external virtual override view returns (bytes4[] memory _sigs) {}\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) public override view returns (bool) {\r\n        return versionManager.isFeatureAuthorised(_wallet, _feature);\r\n    }\r\n    /**\r\n    * @notice Checks that the wallet address provided as the first parameter of _data matches _wallet\r\n    * @return false if the addresses are different.\r\n    */\r\n    function verifyData(address _wallet, bytes calldata _data) internal pure returns (bool) {\r\n        require(_data.length >= 36, \"RM: Invalid dataWallet\");\r\n        address dataWallet = abi.decode(_data[4:], (address));\r\n        return dataWallet == _wallet;\r\n    }\r\n     /**\r\n     * @notice Helper method to check if an address is the owner of a target wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _addr The address.\r\n     */\r\n    function isOwner(address _wallet, address _addr) internal view returns (bool) {\r\n        return IWallet(_wallet).owner() == _addr;\r\n    }\r\n    /**\r\n     * @notice Verify that the caller is an authorised feature or the wallet owner.\r\n     * @param _wallet The target wallet.\r\n     * @param _sender The caller.\r\n     */\r\n    function verifyOwnerOrAuthorisedFeature(address _wallet, address _sender) internal view {\r\n        require(isFeatureAuthorisedInVersionManager(_wallet, _sender) || isOwner(_wallet, _sender), \"BF: must be owner or feature\");\r\n    }\r\n    /**\r\n     * @notice Helper method to invoke a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _to The target address for the transaction.\r\n     * @param _value The value of the transaction.\r\n     * @param _data The data of the transaction.\r\n     */\r\n    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data)\r\n        internal\r\n        returns (bytes memory _res) \r\n    {\r\n        _res = versionManager.checkAuthorisedFeatureAndInvokeWallet(_wallet, _to, _value, _data);\r\n    }\r\n}\r\n// File: contracts/modules/common/GuardianUtils.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n/**\r\n * @title GuardianUtils\r\n * @notice Bundles guardian read logic.\r\n */\r\nlibrary GuardianUtils {\r\n    /**\r\n    * @notice Checks if an address is a guardian or an account authorised to sign on behalf of a smart-contract guardian\r\n    * given a list of guardians.\r\n    * @param _guardians the list of guardians\r\n    * @param _guardian the address to test\r\n    * @return true and the list of guardians minus the found guardian upon success, false and the original list of guardians if not found.\r\n    */\r\n    function isGuardianOrGuardianSigner(address[] memory _guardians, address _guardian) internal view returns (bool, address[] memory) {\r\n        if (_guardians.length == 0 || _guardian == address(0)) {\r\n            return (false, _guardians);\r\n        }\r\n        bool isFound = false;\r\n        address[] memory updatedGuardians = new address[](_guardians.length - 1);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < _guardians.length; i++) {\r\n            if (!isFound) {\r\n                // check if _guardian is an account guardian\r\n                if (_guardian == _guardians[i]) {\r\n                    isFound = true;\r\n                    continue;\r\n                }\r\n                // check if _guardian is the owner of a smart contract guardian\r\n                if (isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {\r\n                    isFound = true;\r\n                    continue;\r\n                }\r\n            }\r\n            if (index < updatedGuardians.length) {\r\n                updatedGuardians[index] = _guardians[i];\r\n                index++;\r\n            }\r\n        }\r\n        return isFound ? (true, updatedGuardians) : (false, _guardians);\r\n    }\r\n   /**\r\n    * @notice Checks if an address is a contract.\r\n    * @param _addr The address.\r\n    */\r\n    function isContract(address _addr) internal view returns (bool) {\r\n        uint32 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n    /**\r\n    * @notice Checks if an address is the owner of a guardian contract.\r\n    * The method does not revert if the call to the owner() method consumes more then 5000 gas.\r\n    * @param _guardian The guardian contract\r\n    * @param _owner The owner to verify.\r\n    */\r\n    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {\r\n        address owner = address(0);\r\n        bytes4 sig = bytes4(keccak256(\"owner()\"));\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr,sig)\r\n            let result := staticcall(5000, _guardian, ptr, 0x20, ptr, 0x20)\r\n            if eq(result, 1) {\r\n                owner := mload(ptr)\r\n            }\r\n        }\r\n        return owner == _owner;\r\n    }\r\n}\r\n// File: contracts/infrastructure/ITokenPriceRegistry.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n/**\r\n * @title ITokenPriceRegistry\r\n * @notice TokenPriceRegistry interface\r\n */\r\ninterface ITokenPriceRegistry {\r\n    function getTokenPrice(address _token) external view returns (uint184 _price);\r\n    function isTokenTradable(address _token) external view returns (bool _isTradable);\r\n}\r\n// File: contracts/modules/common/LimitUtils.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n/**\r\n * @title LimitUtils\r\n * @notice Helper library to manage the daily limit and interact with a contract implementing the ILimitStorage interface.\r\n * @author Julien Niset - <julien@argent.xyz>\r\n */\r\nlibrary LimitUtils {\r\n    // large limit when the limit can be considered disabled\r\n    uint128 constant internal LIMIT_DISABLED = uint128(-1);\r\n    using SafeMath for uint256;\r\n    // *************** Internal Functions ********************* //\r\n    /**\r\n     * @notice Changes the daily limit (expressed in ETH).\r\n     * Decreasing the limit is immediate while increasing the limit is pending for the security period.\r\n     * @param _lStorage The storage contract.\r\n     * @param _versionManager The version manager.\r\n     * @param _wallet The target wallet.\r\n     * @param _targetLimit The target limit.\r\n     * @param _securityPeriod The security period.\r\n     */\r\n    function changeLimit(\r\n        ILimitStorage _lStorage,\r\n        IVersionManager _versionManager,\r\n        address _wallet,\r\n        uint256 _targetLimit,\r\n        uint256 _securityPeriod\r\n    )\r\n        internal\r\n        returns (ILimitStorage.Limit memory)\r\n    {\r\n        ILimitStorage.Limit memory limit = _lStorage.getLimit(_wallet);\r\n        uint256 currentLimit = currentLimit(limit);\r\n        ILimitStorage.Limit memory newLimit;\r\n        if (_targetLimit <= currentLimit) {\r\n            uint128 targetLimit = safe128(_targetLimit);\r\n            newLimit = ILimitStorage.Limit(targetLimit, targetLimit, safe64(block.timestamp));\r\n        } else {\r\n            newLimit = ILimitStorage.Limit(safe128(currentLimit), safe128(_targetLimit), safe64(block.timestamp.add(_securityPeriod)));\r\n        }\r\n        setLimit(_versionManager, _lStorage, _wallet, newLimit);\r\n        return newLimit;\r\n    }\r\n     /**\r\n     * @notice Disable the daily limit.\r\n     * The change is pending for the security period.\r\n     * @param _lStorage The storage contract.\r\n     * @param _versionManager The version manager.\r\n     * @param _wallet The target wallet.\r\n     * @param _securityPeriod The security period.\r\n     */\r\n    function disableLimit(\r\n        ILimitStorage _lStorage,\r\n        IVersionManager _versionManager,\r\n        address _wallet,\r\n        uint256 _securityPeriod\r\n    )\r\n        internal\r\n    {\r\n        changeLimit(_lStorage, _versionManager, _wallet, LIMIT_DISABLED, _securityPeriod);\r\n    }\r\n    /**\r\n    * @notice Returns whether the daily limit is disabled for a wallet.\r\n    * @param _wallet The target wallet.\r\n    * @return _limitDisabled true if the daily limit is disabled, false otherwise.\r\n    */\r\n    function isLimitDisabled(ILimitStorage _lStorage, address _wallet) internal view returns (bool) {\r\n        ILimitStorage.Limit memory limit = _lStorage.getLimit(_wallet);\r\n        uint256 currentLimit = currentLimit(limit);\r\n        return (currentLimit == LIMIT_DISABLED);\r\n    }\r\n    /**\r\n    * @notice Checks if a transfer is within the limit. If yes the daily spent is updated.\r\n    * @param _lStorage The storage contract.\r\n    * @param _versionManager The Version Manager.\r\n    * @param _wallet The target wallet.\r\n    * @param _amount The amount for the transfer\r\n    * @return true if the transfer is withing the daily limit.\r\n    */\r\n    function checkAndUpdateDailySpent(\r\n        ILimitStorage _lStorage,\r\n        IVersionManager _versionManager,\r\n        address _wallet,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        (ILimitStorage.Limit memory limit, ILimitStorage.DailySpent memory dailySpent) = _lStorage.getLimitAndDailySpent(_wallet);\r\n        uint256 currentLimit = currentLimit(limit);\r\n        if (_amount == 0 || currentLimit == LIMIT_DISABLED) {\r\n            return true;\r\n        }\r\n        ILimitStorage.DailySpent memory newDailySpent;\r\n        if (dailySpent.periodEnd <= block.timestamp && _amount <= currentLimit) {\r\n            newDailySpent = ILimitStorage.DailySpent(safe128(_amount), safe64(block.timestamp + 24 hours));\r\n            setDailySpent(_versionManager, _lStorage, _wallet, newDailySpent);\r\n            return true;\r\n        } else if (dailySpent.periodEnd > block.timestamp && _amount.add(dailySpent.alreadySpent) <= currentLimit) {\r\n            newDailySpent = ILimitStorage.DailySpent(safe128(_amount.add(dailySpent.alreadySpent)), safe64(dailySpent.periodEnd));\r\n            setDailySpent(_versionManager, _lStorage, _wallet, newDailySpent);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n    * @notice Helper method to Reset the daily consumption.\r\n    * @param _versionManager The Version Manager.\r\n    * @param _wallet The target wallet.\r\n    */\r\n    function resetDailySpent(IVersionManager _versionManager, ILimitStorage limitStorage, address _wallet) internal {\r\n        setDailySpent(_versionManager, limitStorage, _wallet, ILimitStorage.DailySpent(uint128(0), uint64(0)));\r\n    }\r\n    /**\r\n    * @notice Helper method to get the ether value equivalent of a token amount.\r\n    * @notice For low value amounts of tokens we accept this to return zero as these are small enough to disregard.\r\n    * Note that the price stored for tokens = price for 1 token (in ETH wei) * 10^(18-token decimals).\r\n    * @param _amount The token amount.\r\n    * @param _token The address of the token.\r\n    * @return The ether value for _amount of _token.\r\n    */\r\n    function getEtherValue(ITokenPriceRegistry _priceRegistry, uint256 _amount, address _token) internal view returns (uint256) {\r\n        uint256 price = _priceRegistry.getTokenPrice(_token);\r\n        uint256 etherValue = price.mul(_amount).div(10**18);\r\n        return etherValue;\r\n    }\r\n    /**\r\n    * @notice Helper method to get the current limit from a Limit struct.\r\n    * @param _limit The limit struct\r\n    */\r\n    function currentLimit(ILimitStorage.Limit memory _limit) internal view returns (uint256) {\r\n        if (_limit.changeAfter > 0 && _limit.changeAfter < block.timestamp) {\r\n            return _limit.pending;\r\n        }\r\n        return _limit.current;\r\n    }\r\n    function safe128(uint256 _num) internal pure returns (uint128) {\r\n        require(_num < 2**128, \"LU: more then 128 bits\");\r\n        return uint128(_num);\r\n    }\r\n    function safe64(uint256 _num) internal pure returns (uint64) {\r\n        require(_num < 2**64, \"LU: more then 64 bits\");\r\n        return uint64(_num);\r\n    }\r\n    // *************** Storage invocations in VersionManager ********************* //\r\n    function setLimit(\r\n        IVersionManager _versionManager,\r\n        ILimitStorage _lStorage,\r\n        address _wallet, \r\n        ILimitStorage.Limit memory _limit\r\n    ) internal {\r\n        _versionManager.invokeStorage(\r\n            _wallet,\r\n            address(_lStorage),\r\n            abi.encodeWithSelector(_lStorage.setLimit.selector, _wallet, _limit)\r\n        );\r\n    }\r\n    function setDailySpent(\r\n        IVersionManager _versionManager,\r\n        ILimitStorage _lStorage,\r\n        address _wallet, \r\n        ILimitStorage.DailySpent memory _dailySpent\r\n    ) private {\r\n        _versionManager.invokeStorage(\r\n            _wallet,\r\n            address(_lStorage),\r\n            abi.encodeWithSelector(_lStorage.setDailySpent.selector, _wallet, _dailySpent)\r\n        );\r\n    }\r\n}\r\n// File: contracts/infrastructure/storage/IGuardianStorage.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\npragma solidity >=0.5.4 <0.7.0;\r\ninterface IGuardianStorage {\r\n    /**\r\n     * @notice Lets an authorised module add a guardian to a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The guardian to add.\r\n     */\r\n    function addGuardian(address _wallet, address _guardian) external;\r\n    /**\r\n     * @notice Lets an authorised module revoke a guardian from a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The guardian to revoke.\r\n     */\r\n    function revokeGuardian(address _wallet, address _guardian) external;\r\n    /**\r\n     * @notice Checks if an account is a guardian for a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The account.\r\n     * @return true if the account is a guardian for a wallet.\r\n     */\r\n    function isGuardian(address _wallet, address _guardian) external view returns (bool);\r\n    function isLocked(address _wallet) external view returns (bool);\r\n    function getLock(address _wallet) external view returns (uint256);\r\n    function getLocker(address _wallet) external view returns (address);\r\n    function setLock(address _wallet, uint256 _releaseAfter) external;\r\n    function getGuardians(address _wallet) external view returns (address[] memory);\r\n    function guardianCount(address _wallet) external view returns (uint256);\r\n}\r\n// File: modules/RelayerManager.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n/**\r\n * @title RelayerManager\r\n * @notice Feature to execute transactions signed by ETH-less accounts and sent by a relayer.\r\n * @author Julien Niset <julien@argent.xyz>, Olivier VDB <olivier@argent.xyz>\r\n */\r\ncontract RelayerManager is BaseFeature {\r\n    bytes32 constant NAME = \"RelayerManager\";\r\n    uint256 constant internal BLOCKBOUND = 10000;\r\n    using SafeMath for uint256;\r\n    mapping (address => RelayerConfig) public relayer;\r\n    // The storage of the limit\r\n    ILimitStorage public limitStorage;\r\n    // The Token price storage\r\n    ITokenPriceRegistry public tokenPriceRegistry;\r\n    // The Guardian storage\r\n    IGuardianStorage public guardianStorage;\r\n    struct RelayerConfig {\r\n        uint256 nonce;\r\n        mapping (bytes32 => bool) executedTx;\r\n    }\r\n    // Used to avoid stack too deep error\r\n    struct StackExtension {\r\n        uint256 requiredSignatures;\r\n        OwnerSignature ownerSignatureRequirement;\r\n        bytes32 signHash;\r\n        bool success;\r\n        bytes returnData;\r\n    }\r\n    event TransactionExecuted(address indexed wallet, bool indexed success, bytes returnData, bytes32 signedHash);\r\n    event Refund(address indexed wallet, address indexed refundAddress, address refundToken, uint256 refundAmount);\r\n    /* ***************** External methods ************************* */\r\n    constructor(\r\n        ILockStorage _lockStorage,\r\n        IGuardianStorage _guardianStorage,\r\n        ILimitStorage _limitStorage,\r\n        ITokenPriceRegistry _tokenPriceRegistry,\r\n        IVersionManager _versionManager\r\n    )\r\n        BaseFeature(_lockStorage, _versionManager, NAME)\r\n        public\r\n    {\r\n        limitStorage = _limitStorage;\r\n        tokenPriceRegistry = _tokenPriceRegistry;\r\n        guardianStorage = _guardianStorage;\r\n    }\r\n    /**\r\n    * @notice Executes a relayed transaction.\r\n    * @param _wallet The target wallet.\r\n    * @param _feature The target feature.\r\n    * @param _data The data for the relayed transaction\r\n    * @param _nonce The nonce used to prevent replay attacks.\r\n    * @param _signatures The signatures as a concatenated byte array.\r\n    * @param _gasPrice The gas price to use for the gas refund.\r\n    * @param _gasLimit The gas limit to use for the gas refund.\r\n    * @param _refundToken The token to use for the gas refund.\r\n    * @param _refundAddress The address refunded to prevent front-running.\r\n    */\r\n    function execute(\r\n        address _wallet,\r\n        address _feature,\r\n        bytes calldata _data,\r\n        uint256 _nonce,\r\n        bytes calldata _signatures,\r\n        uint256 _gasPrice,\r\n        uint256 _gasLimit,\r\n        address _refundToken,\r\n        address _refundAddress\r\n    )\r\n        external\r\n        returns (bool)\r\n    {\r\n        uint startGas = gasleft();\r\n        require(startGas >= _gasLimit, \"RM: not enough gas provided\");\r\n        require(verifyData(_wallet, _data), \"RM: Target of _data != _wallet\");\r\n        require(isFeatureAuthorisedInVersionManager(_wallet, _feature), \"RM: feature not authorised\");\r\n        StackExtension memory stack;\r\n        (stack.requiredSignatures, stack.ownerSignatureRequirement) = IFeature(_feature).getRequiredSignatures(_wallet, _data);\r\n        require(stack.requiredSignatures > 0 || stack.ownerSignatureRequirement == OwnerSignature.Anyone, \"RM: Wrong signature requirement\");\r\n        require(stack.requiredSignatures * 65 == _signatures.length, \"RM: Wrong number of signatures\");\r\n        stack.signHash = getSignHash(\r\n            address(this),\r\n            _feature,\r\n            0,\r\n            _data,\r\n            _nonce,\r\n            _gasPrice,\r\n            _gasLimit,\r\n            _refundToken,\r\n            _refundAddress);\r\n        require(checkAndUpdateUniqueness(\r\n            _wallet,\r\n            _nonce,\r\n            stack.signHash,\r\n            stack.requiredSignatures,\r\n            stack.ownerSignatureRequirement), \"RM: Duplicate request\");\r\n        require(validateSignatures(_wallet, stack.signHash, _signatures, stack.ownerSignatureRequirement), \"RM: Invalid signatures\");\r\n        (stack.success, stack.returnData) = _feature.call(_data);\r\n        // only refund when approved by owner and positive gas price\r\n        if (_gasPrice > 0 && stack.ownerSignatureRequirement == OwnerSignature.Required) {\r\n            refund(\r\n                _wallet,\r\n                startGas,\r\n                _gasPrice,\r\n                _gasLimit,\r\n                _refundToken,\r\n                _refundAddress,\r\n                stack.requiredSignatures);\r\n        }\r\n        emit TransactionExecuted(_wallet, stack.success, stack.returnData, stack.signHash);\r\n        return stack.success;\r\n    }\r\n    /**\r\n    * @notice Gets the current nonce for a wallet.\r\n    * @param _wallet The target wallet.\r\n    */\r\n    function getNonce(address _wallet) external view returns (uint256 nonce) {\r\n        return relayer[_wallet].nonce;\r\n    }\r\n    /**\r\n    * @notice Checks if a transaction identified by its sign hash has already been executed.\r\n    * @param _wallet The target wallet.\r\n    * @param _signHash The sign hash of the transaction.\r\n    */\r\n    function isExecutedTx(address _wallet, bytes32 _signHash) external view returns (bool executed) {\r\n        return relayer[_wallet].executedTx[_signHash];\r\n    }\r\n    /* ***************** Internal & Private methods ************************* */\r\n    /**\r\n    * @notice Generates the signed hash of a relayed transaction according to ERC 1077.\r\n    * @param _from The starting address for the relayed transaction (should be the relayer module)\r\n    * @param _to The destination address for the relayed transaction (should be the target module)\r\n    * @param _value The value for the relayed transaction.\r\n    * @param _data The data for the relayed transaction which includes the wallet address.\r\n    * @param _nonce The nonce used to prevent replay attacks.\r\n    * @param _gasPrice The gas price to use for the gas refund.\r\n    * @param _gasLimit The gas limit to use for the gas refund.\r\n    * @param _refundToken The token to use for the gas refund.\r\n    * @param _refundAddress The address refunded to prevent front-running.\r\n    */\r\n    function getSignHash(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes memory _data,\r\n        uint256 _nonce,\r\n        uint256 _gasPrice,\r\n        uint256 _gasLimit,\r\n        address _refundToken,\r\n        address _refundAddress\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19Ethereum Signed Message:\\n32\",\r\n                keccak256(abi.encodePacked(\r\n                    byte(0x19),\r\n                    byte(0),\r\n                    _from,\r\n                    _to,\r\n                    _value,\r\n                    _data,\r\n                    getChainId(),\r\n                    _nonce,\r\n                    _gasPrice,\r\n                    _gasLimit,\r\n                    _refundToken,\r\n                    _refundAddress))\r\n        ));\r\n    }\r\n    /**\r\n    * @notice Checks if the relayed transaction is unique. If yes the state is updated.\r\n    * For actions requiring 1 signature by the owner we use the incremental nonce.\r\n    * For all other actions we check/store the signHash in a mapping.\r\n    * @param _wallet The target wallet.\r\n    * @param _nonce The nonce.\r\n    * @param _signHash The signed hash of the transaction.\r\n    * @param requiredSignatures The number of signatures required.\r\n    * @param ownerSignatureRequirement The wallet owner signature requirement.\r\n    * @return true if the transaction is unique.\r\n    */\r\n    function checkAndUpdateUniqueness(\r\n        address _wallet,\r\n        uint256 _nonce,\r\n        bytes32 _signHash,\r\n        uint256 requiredSignatures,\r\n        OwnerSignature ownerSignatureRequirement\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (requiredSignatures == 1 && ownerSignatureRequirement == OwnerSignature.Required) {\r\n            // use the incremental nonce\r\n            if (_nonce <= relayer[_wallet].nonce) {\r\n                return false;\r\n            }\r\n            uint256 nonceBlock = (_nonce & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;\r\n            if (nonceBlock > block.number + BLOCKBOUND) {\r\n                return false;\r\n            }\r\n            relayer[_wallet].nonce = _nonce;\r\n            return true;\r\n        } else {\r\n            // use the txHash map\r\n            if (relayer[_wallet].executedTx[_signHash] == true) {\r\n                return false;\r\n            }\r\n            relayer[_wallet].executedTx[_signHash] = true;\r\n            return true;\r\n        }\r\n    }\r\n    /**\r\n    * @notice Validates the signatures provided with a relayed transaction.\r\n    * The method MUST throw if one or more signatures are not valid.\r\n    * @param _wallet The target wallet.\r\n    * @param _signHash The signed hash representing the relayed transaction.\r\n    * @param _signatures The signatures as a concatenated byte array.\r\n    * @param _option An enum indicating whether the owner is required, optional or disallowed.\r\n    * @return A boolean indicating whether the signatures are valid.\r\n    */\r\n    function validateSignatures(\r\n        address _wallet,\r\n        bytes32 _signHash,\r\n        bytes memory _signatures,\r\n        OwnerSignature _option\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (_signatures.length == 0) {\r\n            return true;\r\n        }\r\n        address lastSigner = address(0);\r\n        address[] memory guardians;\r\n        if (_option != OwnerSignature.Required || _signatures.length > 65) {\r\n            guardians = guardianStorage.getGuardians(_wallet); // guardians are only read if they may be needed\r\n        }\r\n        bool isGuardian;\r\n        for (uint256 i = 0; i < _signatures.length / 65; i++) {\r\n            address signer = Utils.recoverSigner(_signHash, _signatures, i);\r\n            if (i == 0) {\r\n                if (_option == OwnerSignature.Required) {\r\n                    // First signer must be owner\r\n                    if (isOwner(_wallet, signer)) {\r\n                        continue;\r\n                    }\r\n                    return false;\r\n                } else if (_option == OwnerSignature.Optional) {\r\n                    // First signer can be owner\r\n                    if (isOwner(_wallet, signer)) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            if (signer <= lastSigner) {\r\n                return false; // Signers must be different\r\n            }\r\n            lastSigner = signer;\r\n            (isGuardian, guardians) = GuardianUtils.isGuardianOrGuardianSigner(guardians, signer);\r\n            if (!isGuardian) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n    * @notice Refunds the gas used to the Relayer.\r\n    * @param _wallet The target wallet.\r\n    * @param _startGas The gas provided at the start of the execution.\r\n    * @param _gasPrice The gas price for the refund.\r\n    * @param _gasLimit The gas limit for the refund.\r\n    * @param _refundToken The token to use for the gas refund.\r\n    * @param _refundAddress The address refunded to prevent front-running.\r\n    * @param _requiredSignatures The number of signatures required.\r\n    */\r\n    function refund(\r\n        address _wallet,\r\n        uint _startGas,\r\n        uint _gasPrice,\r\n        uint _gasLimit,\r\n        address _refundToken,\r\n        address _refundAddress,\r\n        uint256 _requiredSignatures\r\n    )\r\n        internal\r\n    {\r\n        address refundAddress = _refundAddress == address(0) ? msg.sender : _refundAddress;\r\n        uint256 refundAmount;\r\n        // skip daily limit when approved by guardians (and signed by owner)\r\n        if (_requiredSignatures > 1) {\r\n            uint256 gasConsumed = _startGas.sub(gasleft()).add(30000);\r\n            refundAmount = Utils.min(gasConsumed, _gasLimit).mul(_gasPrice);\r\n        } else {\r\n            uint256 gasConsumed = _startGas.sub(gasleft()).add(40000);\r\n            refundAmount = Utils.min(gasConsumed, _gasLimit).mul(_gasPrice);\r\n            uint256 ethAmount = (_refundToken == ETH_TOKEN) ? refundAmount : LimitUtils.getEtherValue(tokenPriceRegistry, refundAmount, _refundToken);\r\n            require(LimitUtils.checkAndUpdateDailySpent(limitStorage, versionManager, _wallet, ethAmount), \"RM: refund is above daily limit\");\r\n        }\r\n        // refund in ETH or ERC20\r\n        if (_refundToken == ETH_TOKEN) {\r\n            invokeWallet(_wallet, refundAddress, refundAmount, EMPTY_BYTES);\r\n        } else {\r\n            bytes memory methodData = abi.encodeWithSignature(\"transfer(address,uint256)\", refundAddress, refundAmount);\r\n\t\t    bytes memory transferSuccessBytes = invokeWallet(_wallet, _refundToken, 0, methodData);\r\n            // Check token refund is successful, when `transfer` returns a success bool result\r\n            if (transferSuccessBytes.length > 0) {\r\n                require(abi.decode(transferSuccessBytes, (bool)), \"RM: Refund transfer failed\");\r\n            }\r\n        }\r\n        emit Refund(_wallet, refundAddress, _refundToken, refundAmount);\r\n    }\r\n   /**\r\n    * @notice Returns the current chainId\r\n    * @return chainId the chainId\r\n    */\r\n    function getChainId() private pure returns (uint256 chainId) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { chainId := chainid() }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ILockStorage\",\"name\":\"_lockStorage\",\"type\":\"address\"},{\"internalType\":\"contract IGuardianStorage\",\"name\":\"_guardianStorage\",\"type\":\"address\"},{\"internalType\":\"contract ILimitStorage\",\"name\":\"_limitStorage\",\"type\":\"address\"},{\"internalType\":\"contract ITokenPriceRegistry\",\"name\":\"_tokenPriceRegistry\",\"type\":\"address\"},{\"internalType\":\"contract IVersionManager\",\"name\":\"_versionManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"FeatureCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"signedHash\",\"type\":\"bytes32\"}],\"name\":\"TransactionExecuted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feature\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_refundToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_refundAddress\",\"type\":\"address\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"getRequiredSignatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"enum IFeature.OwnerSignature\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStaticCallSignatures\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"_sigs\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardianStorage\",\"outputs\":[{\"internalType\":\"contract IGuardianStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_signHash\",\"type\":\"bytes32\"}],\"name\":\"isExecutedTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feature\",\"type\":\"address\"}],\"name\":\"isFeatureAuthorisedInVersionManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitStorage\",\"outputs\":[{\"internalType\":\"contract ILimitStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"relayer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPriceRegistry\",\"outputs\":[{\"internalType\":\"contract ITokenPriceRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RelayerManager", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "999", "ConstructorArguments": "000000000000000000000000af5ef23e884fd696c8dfafd1836e0164f13873a00000000000000000000000004cac0996ede3125a72be96942d299b1b26e5381b00000000000000000000000081efe143a10bd20dc850e2ed234242fe6314036c000000000000000000000000f6f211121b07947fba3faae159422af2f93a636c000000000000000000000000dec1c7a7b5930871ddff751a0e07247a67f4a707", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://49c9013192ef272eca90edb38188c4c5c8e88cca2b8992227345105c5bbfaa33"}