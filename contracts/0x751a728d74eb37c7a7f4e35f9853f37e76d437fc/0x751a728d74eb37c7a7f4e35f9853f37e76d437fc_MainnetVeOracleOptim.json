{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MainnetVeOracleOptimism.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts@4.9.3/access/Ownable2Step.sol\\\";\\n\\ninterface IVeCrv {\\n    struct LockedBalance {\\n        int128 amount;\\n        uint256 end;\\n    }\\n\\n    struct Point {\\n        int128 bias;\\n        int128 slope;\\n        uint256 ts;\\n        uint256 blk;\\n    }\\n\\n    function epoch() external view returns (uint256);\\n\\n    function point_history(uint256) external view returns (Point memory);\\n\\n    function slope_changes(uint256) external view returns (int128);\\n\\n    function locked(address _user) external view returns (LockedBalance memory);\\n\\n    function user_point_epoch(address _user) external view returns (uint256);\\n\\n    function user_point_history(address _user, uint256 _epoch)\\n        external\\n        view\\n        returns (Point memory);\\n}\\n\\ninterface IOracle is IVeCrv {\\n    function submit_state(\\n        uint256 _epoch,\\n        Point memory _globalPointStruct,\\n        int128[8] memory _slopeChangeArray,\\n        address _user,\\n        LockedBalance memory _userLockedStruct,\\n        uint256 _userEpoch,\\n        Point memory _userPointStruct\\n    ) external;\\n}\\n\\ninterface IOptimismMessenger {\\n    function sendMessage(\\n        address _target,\\n        bytes memory _message,\\n        uint32 _gasLimit\\n    ) external;\\n}\\n\\n/**\\n * @title Mainnet veOracle Optimism\\n * @notice This contract reads data from Curve's veCRV contract for a given user, and pushes that data to Optimism to be\\n *  read and used for determining boost for Curve gauges on Optimism. Additionally, overwrites can be set for users such\\n *  that an L1 veCRV balance will be written to a different address on the L2.\\n */\\ncontract MainnetVeOracleOptimism is Ownable2Step {\\n    /// @notice Ethereum veCRV contract; pull all of our info from here\\n    IVeCrv public constant veCRV =\\n        IVeCrv(0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2);\\n\\n    /// @notice The address of Optimism's messenger contract on L1\\n    IOptimismMessenger public constant ovmL1CrossDomainMessenger =\\n        IOptimismMessenger(0x25ace71c97B33Cc4729CF772ae268934F7ab5fA1);\\n\\n    /// @notice The address of our veOracle on Optimism\\n    address public optimismVeOracle;\\n\\n    /// Week in seconds\\n    uint256 constant WEEK = 1 weeks;\\n\\n    /// @notice Mapping of overwrites; mainnet address => L2 address\\n    mapping(address => address) public overwrites;\\n\\n    /**\\n     * @notice Update the Optimism veOracle for a given user.\\n     * @param _user The user whose data to push to Optimism's veOracle.\\n     */\\n    function updateOptimismVeOracle(address _user) public {\\n        if (optimismVeOracle == address(0)) {\\n            revert(\\\"Set optimismVeOracle address first\\\");\\n        }\\n\\n        // here we should pull all of the relevant params we need from veCRV to send to the L2\\n        (\\n            IVeCrv.LockedBalance memory userLockedStruct,\\n            IVeCrv.Point memory userPointStruct,\\n            uint256 userEpoch\\n        ) = _getUpdatedUserInfo(_user);\\n\\n        // pull our global point history struct\\n        uint256 currentEpoch = veCRV.epoch();\\n        IVeCrv.Point memory globalPointStruct = veCRV.point_history(\\n            currentEpoch\\n        );\\n\\n        // generate slope changes\\n        int128[8] memory slopeChanges;\\n        uint256 startTime = (globalPointStruct.ts / WEEK) * WEEK + WEEK;\\n        for (uint256 i = 0; i < 8; i++) {\\n            slopeChanges[i] = veCRV.slope_changes(startTime + WEEK * i);\\n        }\\n\\n        // check if we have an overwrite for the L2\\n        _user = _checkOverwrite(_user);\\n\\n        // this call will change based on the L2 we are pushing the message to\\n        ovmL1CrossDomainMessenger.sendMessage(\\n            optimismVeOracle,\\n            abi.encodeWithSignature(\\n                \\\"submit_state(uint256,(int128,int128,uint256,uint256),int128[8],address,(int128,uint256),uint256,(int128,int128,uint256,uint256))\\\",\\n                currentEpoch,\\n                globalPointStruct,\\n                slopeChanges,\\n                _user,\\n                userLockedStruct,\\n                userEpoch,\\n                userPointStruct\\n            ),\\n            1000000\\n        );\\n    }\\n\\n    /**\\n     * @notice Pull info from the veCRV contract for a given user address.\\n     * @param _user The user whose data to push to Optimism's veOracle.\\n     * @return userLockedStruct Struct containing the user's lock info.\\n     * @return userPointStruct Struct containing the user's point info (bias, slope, etc.).\\n     * @return userEpoch Current epoch for a given user.\\n     */\\n    function _getUpdatedUserInfo(address _user)\\n        internal\\n        view\\n        returns (\\n            IVeCrv.LockedBalance memory userLockedStruct,\\n            IVeCrv.Point memory userPointStruct,\\n            uint256 userEpoch\\n        )\\n    {\\n        // get our lock and point struct, as well as our latest user epoch, from veCRV\\n        userLockedStruct = veCRV.locked(_user);\\n        userEpoch = veCRV.user_point_epoch(_user);\\n        userPointStruct = veCRV.user_point_history(_user, userEpoch);\\n    }\\n\\n    /**\\n     * @notice Check if an overwrite has been set for a given address on mainnet.\\n     * @param _user The user to check if an overwrite has been set.\\n     * @return userOverwrite Overwrite address if it exists, else input user address.\\n     */\\n    function _checkOverwrite(address _user)\\n        internal\\n        view\\n        returns (address userOverwrite)\\n    {\\n        userOverwrite = _user;\\n        if (overwrites[_user] != address(0)) {\\n            userOverwrite = overwrites[_user];\\n        }\\n    }\\n\\n    /**\\n     * @notice Update the Optimism veOracle contract address.\\n     * @dev May only be called by owner.\\n     * @param _oracleAddress The address for our new veOracle on Optimism.\\n     */\\n    function setOptimismVeOracle(address _oracleAddress) external onlyOwner {\\n        optimismVeOracle = _oracleAddress;\\n    }\\n\\n    /**\\n     * @notice Maps the value of a mainnet veCRV lock to a different L2 address.\\n     * @dev May only be set for others by owner.\\n     * @param _mainnetLocker The address to read veCRV holdings from.\\n     * @param _optimismLocker The address to map these veCRV holdings to on Optimism.\\n     */\\n    function setOverwrite(address _mainnetLocker, address _optimismLocker)\\n        external\\n    {\\n        if (msg.sender != _mainnetLocker && msg.sender != owner()) {\\n            revert(\\\"Only owner can update addresses for others\\\");\\n        }\\n\\n        // pull our current optimismLocker address if we have one\\n        address oldOptimismLocker = overwrites[_mainnetLocker];\\n        overwrites[_mainnetLocker] = _optimismLocker;\\n\\n        // clear out any stored overwrite state for the old address\\n        if (oldOptimismLocker != address(0)) {\\n            updateOptimismVeOracle(oldOptimismLocker);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.9.3/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.9.3/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.9.3/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimismVeOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"overwrites\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ovmL1CrossDomainMessenger\",\"outputs\":[{\"internalType\":\"contract IOptimismMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"}],\"name\":\"setOptimismVeOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mainnetLocker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_optimismLocker\",\"type\":\"address\"}],\"name\":\"setOverwrite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"updateOptimismVeOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"veCRV\",\"outputs\":[{\"internalType\":\"contract IVeCrv\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MainnetVeOracleOptimism", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0a5f3666832dc5d694cb7fab59d0618d6964f1fad0c4e87b8743ff91c5042cfb"}