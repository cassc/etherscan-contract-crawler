{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lib/CondsRepo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\nlibrary CondsRepo {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    enum LogOps {\\n        ZeroPoint,  // 0\\n        And,           \\n        Or,         \\n        Equal,\\n        NotEqual,   // 4\\n        AndAnd,  \\n        OrOr,\\n        AndOr,\\n        OrAnd,\\n        EqEq,\\n        NeNe,\\n        EqNe,\\n        NeEq,\\n        AndEq,\\n        EqAnd,\\n        OrEq,\\n        EqOr,\\n        AndNe,\\n        NeAnd,\\n        OrNe,\\n        NeOr        \\n    }\\n\\n    enum ComOps {\\n        ZeroPoint,\\n        Equal,\\n        NotEqual,\\n        Bigger,\\n        Smaller,\\n        BiggerOrEqual,\\n        SmallerOrEqual\\n    }\\n\\n    struct Cond {\\n        uint32 seqOfCond;\\n        uint8 logicOpr;    \\n        uint8 compOpr1;    \\n        uint64 para1;           \\n        uint8 compOpr2;    \\n        uint64 para2;           \\n        uint8 compOpr3;    \\n        uint64 para3;                               \\n    }\\n\\n    struct Repo {\\n        mapping(uint256 => Cond) conds;\\n        EnumerableSet.Bytes32Set seqList;\\n    }\\n\\n    // ###############\\n    // ## Write I/O ##\\n    // ###############\\n\\n    // ==== codify / parser ====\\n\\n    function snParser(bytes32 sn) public pure returns(Cond memory cond)\\n    {\\n        uint _sn = uint(sn);\\n\\n        cond = Cond({\\n            seqOfCond: uint32(_sn >> 224),\\n            logicOpr: uint8(_sn >> 216),\\n            compOpr1: uint8(_sn >> 208),    \\n            para1: uint64(_sn >> 144),          \\n            compOpr2: uint8(_sn >> 136),    \\n            para2: uint64(_sn >> 72),           \\n            compOpr3: uint8(_sn >> 64),    \\n            para3: uint64(_sn)                               \\n        });\\n    }\\n\\n    function codifyCond(Cond memory cond) public pure returns(bytes32 sn)\\n    {\\n        bytes memory _sn = abi.encodePacked(\\n                            cond.seqOfCond,\\n                            cond.logicOpr,\\n                            cond.compOpr1,\\n                            cond.para1,\\n                            cond.compOpr2,\\n                            cond.para2,\\n                            cond.compOpr3,\\n                            cond.para3);\\n\\n        assembly {\\n            sn := mload(add(_sn, 0x20))\\n        }                \\n    }\\n\\n    // ==== create / reg ====\\n    function createCond(Repo storage repo, bytes32 sn) public returns(uint32 seqOfCond)\\n    {\\n        seqOfCond = regCond(repo, snParser(sn));\\n    }\\n\\n    function regCond(Repo storage repo, Cond memory cond) public returns(uint32 seqOfCond)\\n    {\\n        cond.seqOfCond = _increaseCounterOfConds(repo);\\n        repo.conds[cond.seqOfCond] = cond;\\n        repo.seqList.add(codifyCond(cond));\\n        seqOfCond = cond.seqOfCond;\\n    }\\n\\n    function _increaseCounterOfConds(Repo storage repo) private returns(uint32)\\n    {\\n        repo.conds[0].seqOfCond++;\\n        return repo.conds[0].seqOfCond;\\n    }\\n\\n    function removeCond(Repo storage repo, uint256 seqOfCond) public returns(bool flag)\\n    {\\n        if (repo.seqList.remove(codifyCond(repo.conds[seqOfCond])))\\n        {\\n            delete repo.conds[seqOfCond];\\n            flag = true;\\n        }\\n    }\\n    \\n    // ##################\\n    // ## Write I/O ##\\n    // ##################\\n\\n    function counterOfConds(Repo storage repo) public view returns(uint32 seqOfCond) {\\n        seqOfCond = repo.conds[0].seqOfCond;\\n    }\\n\\n    function getConds(Repo storage repo) public view returns(Cond[] memory)\\n    {\\n        uint256 len = repo.seqList.length();\\n        Cond[] memory output = new Cond[](len);\\n\\n        while (len > 0) {\\n            output[len -1] = repo.conds[len];\\n            len--;\\n        }\\n\\n        return output;\\n    }\\n\\n    function checkCond(\\n        uint compOpr,\\n        uint para,\\n        uint data\\n    ) public pure returns (bool flag) {\\n        if (compOpr == uint8(ComOps.Equal)) flag = data == para;\\n        else if (compOpr == uint8(ComOps.NotEqual)) flag = data != para;\\n        else if (compOpr == uint8(ComOps.Bigger)) flag = data > para;\\n        else if (compOpr == uint8(ComOps.Smaller)) flag = data < para;\\n        else if (compOpr == uint8(ComOps.BiggerOrEqual)) flag = data >= para;\\n        else if (compOpr == uint8(ComOps.SmallerOrEqual)) flag = data <= para;\\n        else revert (\\\"CR.CSC: compOpr overflow\\\");\\n    }\\n\\n    function checkSoleCond(\\n        Cond memory cond,\\n        uint data\\n    ) public pure returns (bool flag) {\\n        flag = checkCond(cond.compOpr1, cond.para1, data);\\n    }\\n\\n    function checkCondsOfTwo(\\n        Cond memory cond,\\n        uint data1,\\n        uint data2\\n    ) public pure returns (bool flag) {\\n        bool flag1;\\n        bool flag2;\\n\\n        flag1 = checkCond(cond.compOpr1, cond.para1, data1);\\n        flag2 = checkCond(cond.compOpr2, cond.para2, data2);\\n\\n        if (cond.logicOpr == uint8(LogOps.And)) flag = flag1 && flag2;\\n        else if (cond.logicOpr == uint8(LogOps.Or)) flag = flag1 || flag2;\\n        else if (cond.logicOpr == uint8(LogOps.Equal)) flag = flag1 == flag2;\\n        else if (cond.logicOpr == uint8(LogOps.NotEqual)) flag = flag1 != flag2;\\n        else revert(\\\"CR.CCO2: logicOpr overflow\\\");\\n    }\\n\\n    function checkCondsOfThree(\\n        Cond memory cond,\\n        uint data1,\\n        uint data2,\\n        uint data3\\n    ) public pure returns (bool flag) {\\n        bool flag1;\\n        bool flag2;\\n        bool flag3;\\n\\n        flag1 = checkCond(cond.compOpr1, cond.para1, data1);\\n        flag2 = checkCond(cond.compOpr2, cond.para2, data2);\\n        flag3 = checkCond(cond.compOpr3, cond.para3, data3);\\n\\n        if (cond.logicOpr == uint8(LogOps.AndAnd)) flag = flag1 && flag2 && flag3;\\n        else if (cond.logicOpr == uint8(LogOps.OrOr)) flag = flag1 || flag2 || flag3;\\n        else if (cond.logicOpr == uint8(LogOps.AndOr)) flag = flag1 && flag2 || flag3;\\n        else if (cond.logicOpr == uint8(LogOps.OrAnd)) flag = flag1 || flag2 && flag3;\\n        else if (cond.logicOpr == uint8(LogOps.EqEq)) flag = flag1 == flag2 == flag3;\\n        else if (cond.logicOpr == uint8(LogOps.NeNe)) flag = flag1 != flag2 != flag3;\\n        else if (cond.logicOpr == uint8(LogOps.EqNe)) flag = flag1 == flag2 != flag3;\\n        else if (cond.logicOpr == uint8(LogOps.NeEq)) flag = flag1 != flag2 == flag3;\\n        else if (cond.logicOpr == uint8(LogOps.AndEq)) flag = flag1 && flag2 == flag3;\\n        else if (cond.logicOpr == uint8(LogOps.EqAnd)) flag = flag1 == flag2 && flag3;\\n        else if (cond.logicOpr == uint8(LogOps.OrEq)) flag = flag1 || flag2 == flag3;\\n        else if (cond.logicOpr == uint8(LogOps.EqOr)) flag = flag1 == flag2 || flag3;\\n        else if (cond.logicOpr == uint8(LogOps.AndNe)) flag = flag1 && flag2 != flag3;\\n        else if (cond.logicOpr == uint8(LogOps.NeAnd)) flag = flag1 != flag2 && flag3;\\n        else if (cond.logicOpr == uint8(LogOps.OrNe)) flag = flag1 || flag2 != flag3;\\n        else if (cond.logicOpr == uint8(LogOps.NeOr)) flag = flag1 != flag2 || flag3;\\n        else revert(\\\"CR.CCO3: logicOpr overflow\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.8;\\n\\nlibrary EnumerableSet {\\n    struct Set {\\n        bytes32[] _values;\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                set._values[toDeleteIndex] = lastValue;\\n                set._indexes[lastValue] = valueIndex;\\n            }\\n\\n            delete set._values[lastIndex];\\n            set._values.pop();\\n\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _contains(Set storage set, bytes32 value)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _at(Set storage set, uint256 index)\\n        private\\n        view\\n        returns (bytes32)\\n    {\\n        return set._values[index];\\n    }\\n\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    //======== Bytes32Set ========\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    function add(Bytes32Set storage set, bytes32 value)\\n        public\\n        returns (bool)\\n    {\\n        return _add(set._inner, value);\\n    }\\n\\n    function remove(Bytes32Set storage set, bytes32 value)\\n        public\\n        returns (bool)\\n    {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function contains(Bytes32Set storage set, bytes32 value)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function length(Bytes32Set storage set) public view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(Bytes32Set storage set, uint256 index)\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        return _at(set._inner, index);\\n    }\\n\\n    function values(Bytes32Set storage set)\\n        public\\n        view\\n        returns (bytes32[] memory)\\n    {\\n        return _values(set._inner);\\n    }\\n\\n    //======== AddressSet ========\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    function add(AddressSet storage set, address value)\\n        public\\n        returns (bool)\\n    {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(AddressSet storage set, address value)\\n        public\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(AddressSet storage set, address value)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function length(AddressSet storage set) public view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(AddressSet storage set, uint256 index)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function values(AddressSet storage set)\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    //======== UintSet ========\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function add(UintSet storage set, uint256 value) public returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(UintSet storage set, uint256 value)\\n        public\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) public view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(UintSet storage set, uint256 index)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function values(UintSet storage set)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/lib/EnumerableSet.sol\": {\r\n        \"EnumerableSet\": \"0xc4f24b69792ff96f0316fab2d7df198af8033930\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"compOpr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"para\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"checkCond\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"seqOfCond\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"logicOpr\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"compOpr1\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para1\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"compOpr2\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para2\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"compOpr3\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para3\",\"type\":\"uint64\"}],\"internalType\":\"struct CondsRepo.Cond\",\"name\":\"cond\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"data1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data3\",\"type\":\"uint256\"}],\"name\":\"checkCondsOfThree\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"seqOfCond\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"logicOpr\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"compOpr1\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para1\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"compOpr2\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para2\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"compOpr3\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para3\",\"type\":\"uint64\"}],\"internalType\":\"struct CondsRepo.Cond\",\"name\":\"cond\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"data1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data2\",\"type\":\"uint256\"}],\"name\":\"checkCondsOfTwo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"seqOfCond\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"logicOpr\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"compOpr1\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para1\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"compOpr2\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para2\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"compOpr3\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para3\",\"type\":\"uint64\"}],\"internalType\":\"struct CondsRepo.Cond\",\"name\":\"cond\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"checkSoleCond\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"seqOfCond\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"logicOpr\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"compOpr1\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para1\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"compOpr2\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para2\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"compOpr3\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para3\",\"type\":\"uint64\"}],\"internalType\":\"struct CondsRepo.Cond\",\"name\":\"cond\",\"type\":\"tuple\"}],\"name\":\"codifyCond\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"sn\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sn\",\"type\":\"bytes32\"}],\"name\":\"snParser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"seqOfCond\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"logicOpr\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"compOpr1\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para1\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"compOpr2\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para2\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"compOpr3\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"para3\",\"type\":\"uint64\"}],\"internalType\":\"struct CondsRepo.Cond\",\"name\":\"cond\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "CondsRepo", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}