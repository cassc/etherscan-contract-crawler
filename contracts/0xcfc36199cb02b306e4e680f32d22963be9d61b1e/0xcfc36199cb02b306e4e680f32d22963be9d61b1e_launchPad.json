{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Launchpad.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.17;\\n\\n// File: PresaleStaking/IWETH.sol\\n\\n// @title Safo-Bills LP farm Smart Contract\\n//\\n//   /$$$$$$   /$$$$$$  /$$$$$$$$ /$$$$$$\\n// /$$__  $$ /$$__  $$| $$_____//$$__  $$\\n// | $$  \\\\__/| $$  \\\\ $$| $$     | $$  \\\\ $$\\n// |  $$$$$$ | $$$$$$$$| $$$$$  | $$  | $$\\n//  \\\\____  $$| $$__  $$| $$__/  | $$  | $$\\n//  /$$  \\\\ $$| $$  | $$| $$     | $$  | $$\\n// |  $$$$$$/| $$  | $$| $$     |  $$$$$$/\\n//  \\\\______/ |__/  |__/|__/      \\\\______/\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n\\n    function approve(address guy, uint256 wad) external returns (bool);\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) external returns (bool);\\n\\n    function balanceOf(address guy) external view returns (uint256);\\n}\\n\\n// File: PresaleStaking/IPancakeRouter01.sol\\n\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(\\n        uint256 amountIn,\\n        address[] calldata path\\n    ) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(\\n        uint256 amountOut,\\n        address[] calldata path\\n    ) external view returns (uint256[] memory amounts);\\n}\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\n// File: PresaleStaking/presaleStaking.sol\\n\\n/* ========== CUSTOM ERRORS ========== */\\n\\nerror InvalidAmount();\\nerror InvalidAddress();\\nerror TokensLocked();\\n\\ninterface IERC20A {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setFeeToSetter(address) external;\\n}\\n\\n//\\n\\ninterface IUniswapV2Pair {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(\\n        address to\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\\n// pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(\\n        uint256 amountIn,\\n        address[] calldata path\\n    ) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(\\n        uint256 amountOut,\\n        address[] calldata path\\n    ) external view returns (uint256[] memory amounts);\\n}\\n\\n// pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ncontract SafoBillsFarm is ReentrancyGuard {\\n    address public owner;\\n    mapping(address => uint256) public userPresaleTBalance;\\n    mapping(address => uint256) public userPresaleMBalance;\\n    mapping(address => uint256) public userPresaleLBalance;\\n    uint256 public beansFromSoldSafo;\\n    mapping(address => bool) userStakeAgain;\\n    mapping(address => bool) public userStakeIsRefferred;\\n    mapping(address => address) public userRefferred;\\n    mapping(address => uint256) refferralRewardCount;\\n    uint256 public rewardPerTokenStored;\\n    uint256 public _totalStaked;\\n    uint256 public rewardRate;\\n    uint256 public poolEndTime;\\n    uint256 public updatedAt;\\n    mapping(address => uint256) public userRewards;\\n    mapping(address => uint256) public ReferralIncome;\\n    mapping(address => uint256) public userStakedBalance;\\n    mapping(address => uint256) public userRewardPerTokenPaid;\\n    uint256 public emergencyFee = 2000;\\n    mapping(address => uint256) public userPaidRewards;\\n    uint256 public refferralLimit = 5;\\n    uint256 public refferralPercentage = 20;\\n    uint256 public poolDuration;\\n    uint256 public poolStartTime;\\n    uint256 public TokensForReward;\\n    address public teamWallet = 0x58490A6eD97F8820D8c120dC102F50c638B3C81E;\\n    bool public poolCancelled;\\n    bool public poolFinalized;\\n    bool public poolShifted;\\n\\n    IERC20A Token;\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == owner, \\\"you are not authorized\\\");\\n        _;\\n    }\\n\\n    struct presale {\\n        uint256 softCap; //0\\n        uint256 presaleAmount; //1\\n        uint256 price; //2\\n        address token; //3\\n        uint256 tokensSold; //4\\n        uint256 bnbSold; //5\\n        uint256 endTime; //6\\n        uint256 startTime; //7\\n        uint256 min; //8\\n        uint256 max; //9\\n        bool[] badges; //10\\n        uint256 liquidity; //11\\n        string logo; //12\\n        string name; //13\\n        uint256 duration; //14\\n        string symbol; //15\\n        string youtube; //16\\n        string description; //17\\n        address router; //18\\n        uint256 LPTokens; //19\\n        string socials; //20\\n    }\\n\\n    presale selfInfo;\\n\\n    modifier updateReward(address _account) {\\n        rewardPerTokenStored = rewardPerToken();\\n        updatedAt = lastTimeRewardApplicable();\\n        if (_account != address(0)) {\\n            userRewards[_account] = earned(_account);\\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\\n        }\\n        _;\\n    }\\n\\n    function setPoolRewards(\\n        uint256 _amount\\n    ) public onlyAdmin updateReward(address(0)) {\\n        if (_amount <= 0) revert InvalidAmount();\\n        if (block.timestamp >= poolEndTime) {\\n            rewardRate = _amount / poolDuration;\\n        } else {\\n            uint256 remainingRewards = (poolEndTime - block.timestamp) *\\n                rewardRate;\\n            rewardRate = (_amount + remainingRewards) / poolDuration;\\n        }\\n        if (rewardRate <= 0) revert InvalidAmount();\\n        poolStartTime = block.timestamp;\\n        poolEndTime = block.timestamp + poolDuration;\\n        updatedAt = block.timestamp;\\n    }\\n\\n    function setPoolRewardsi(\\n        uint256 _amount\\n    ) internal updateReward(address(0)) {\\n        if (_amount <= 0) revert InvalidAmount();\\n        if (block.timestamp >= poolEndTime) {\\n            rewardRate = _amount / poolDuration;\\n        } else {\\n            uint256 remainingRewards = (poolEndTime - block.timestamp) *\\n                rewardRate;\\n            rewardRate = (_amount + remainingRewards) / poolDuration;\\n        }\\n        if (rewardRate <= 0) revert InvalidAmount();\\n        poolStartTime = block.timestamp;\\n        poolEndTime = block.timestamp + poolDuration;\\n        updatedAt = block.timestamp;\\n    }\\n\\n    function updateTeamWallet(address payable _teamWallet) external onlyAdmin {\\n        teamWallet = _teamWallet;\\n    }\\n\\n    function transferOwnership(address _newOwner) external onlyAdmin {\\n        owner = payable(_newOwner);\\n    }\\n\\n    function rewardPerToken() public view returns (uint256) {\\n        if (_totalStaked == 0) {\\n            return rewardPerTokenStored;\\n        }\\n\\n        return\\n            rewardPerTokenStored +\\n            (rewardRate * (lastTimeRewardApplicable() - updatedAt) * 1e18) /\\n            _totalStaked;\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        return _min(block.timestamp, poolEndTime);\\n    }\\n\\n    function _min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function changeEmergencyFee(uint256 x) public onlyAdmin {\\n        emergencyFee = x;\\n    }\\n\\n    function earned(address _account) public view returns (uint256) {\\n        return\\n            (userStakedBalance[_account] *\\n                (rewardPerToken() - userRewardPerTokenPaid[_account])) /\\n            1e18 +\\n            userRewards[_account];\\n    }\\n\\n    constructor(\\n        address _owner,\\n        address[] memory _addresses,\\n        uint256[] memory _integers,\\n        string[] memory _strings\\n    ) {\\n        owner = _owner;\\n        selfInfo.softCap = _integers[0];\\n        selfInfo.price = _integers[1];\\n        selfInfo.token = _addresses[0];\\n        Token = IERC20A(_addresses[0]);\\n        selfInfo.endTime = _integers[2];\\n        selfInfo.startTime = _integers[3];\\n        selfInfo.min = _integers[4];\\n        selfInfo.max = _integers[5];\\n        selfInfo.liquidity = _integers[6];\\n        selfInfo.name = _strings[0];\\n        selfInfo.logo = _strings[1];\\n        selfInfo.duration = _integers[7];\\n        poolDuration = _integers[7] * 60 * 60 * 24;\\n        selfInfo.symbol = _strings[2];\\n        selfInfo.youtube = _strings[3];\\n        selfInfo.description = _strings[4];\\n        selfInfo.router = _addresses[1];\\n        selfInfo.socials = _strings[5];\\n        uint256 apr = (_integers[0] * 5 * _integers[7] * 100000) / (100 * 365);\\n        setPoolRewardsi(apr);\\n    }\\n\\n    function purchaseSafoBill(\\n        address _refferralUserAddress\\n    ) external payable nonReentrant {\\n        if (userStakeAgain[msg.sender] == false) {\\n            userStakeAgain[msg.sender] = true;\\n            if (\\n                _refferralUserAddress != address(0) &&\\n                _refferralUserAddress != msg.sender\\n            ) {\\n                userRefferred[msg.sender] = _refferralUserAddress;\\n                userStakeIsRefferred[msg.sender] = true;\\n            }\\n        }\\n\\n        //   require(selfInfo.bnbSold<selfInfo.softCap,\\\"soft cap breached\\\");\\n        require(!poolCancelled, \\\"Pool has been cancelled\\\");\\n        // require(block.timestamp<=selfInfo.endTime ,\\\"presale ended\\\");\\n        // require(block.timestamp>=selfInfo.startTime,\\\"presale not started\\\");\\n        uint256 totalBeans = msg.value;\\n        require(\\n            totalBeans >= selfInfo.min,\\n            \\\"Amount is less than minimum user buy limit\\\"\\n        );\\n        require(totalBeans >= 0, \\\"insufficient amount\\\");\\n        require(\\n            userPresaleMBalance[msg.sender] + totalBeans <= selfInfo.max,\\n            \\\"Amount is more than max user buy limit\\\"\\n        );\\n\\n        uint256 beanForLiqudity = (totalBeans * selfInfo.liquidity) / 100;\\n        uint256 beanForToken = totalBeans - beanForLiqudity;\\n\\n        uint256 tokensForLiquidity;\\n        uint256 tokensForUser;\\n        if (poolFinalized) {\\n            tokensForLiquidity = _beanToToken(beanForLiqudity);\\n            tokensForUser = _beanToToken(beanForToken);\\n        } else {\\n            tokensForLiquidity =\\n                (beanForLiqudity * selfInfo.price) /\\n                10 ** Token.decimals();\\n            tokensForUser =\\n                (beanForToken * selfInfo.price) /\\n                10 ** Token.decimals();\\n        }\\n\\n        uint256 LPTokens = addLiquidity(\\n            tokensForLiquidity,\\n            beanForLiqudity,\\n            selfInfo.token\\n        );\\n\\n        selfInfo.tokensSold += tokensForUser;\\n        selfInfo.bnbSold += totalBeans;\\n        selfInfo.LPTokens += LPTokens;\\n        userPresaleTBalance[msg.sender] += tokensForUser;\\n        userPresaleMBalance[msg.sender] += beanForToken;\\n        userPresaleLBalance[msg.sender] += LPTokens;\\n\\n        _stake(LPTokens);\\n\\n        if (!poolFinalized) {\\n            if (selfInfo.bnbSold >= selfInfo.softCap) {\\n                selfInfo.startTime = block.timestamp;\\n                poolFinalized = true;\\n            }\\n        }\\n    }\\n\\n    function _beanToToken(uint256 _amount) private view returns (uint256) {\\n        uint256 tokenJuice;\\n\\n        IUniswapV2Router02 Router = IUniswapV2Router02(selfInfo.router);\\n        address _WETH = Router.WETH();\\n        address _uniswapV2Pair = IUniswapV2Factory(Router.factory()).getPair(\\n            selfInfo.token,\\n            _WETH\\n        );\\n\\n        uint256 bnbReserves = IERC20A(_WETH).balanceOf(_uniswapV2Pair);\\n        uint256 tokenReserves = Token.balanceOf(_uniswapV2Pair);\\n\\n        uint256 tokenPerBnb = (tokenReserves * 10 ** 18) / bnbReserves;\\n\\n        tokenJuice = (_amount * tokenPerBnb) / 10 ** 18;\\n\\n        return tokenJuice;\\n    }\\n\\n    function _stake(uint256 _amount) internal updateReward(msg.sender) {\\n        if (_amount <= 0) revert InvalidAmount();\\n        userStakedBalance[msg.sender] += _amount;\\n        _totalStaked += _amount;\\n    }\\n\\n    function addLiquidity(\\n        uint256 tokenAmount,\\n        uint256 ethAmount,\\n        address token\\n    ) public returns (uint256) {\\n        Token.approve(selfInfo.router, tokenAmount);\\n        IUniswapV2Router02 Router = IUniswapV2Router02(selfInfo.router);\\n        // add the liquidity\\n        (, , uint256 liquidity) = Router.addLiquidityETH{value: ethAmount}(\\n            token,\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            address(this),\\n            block.timestamp + 500\\n        );\\n\\n        return liquidity;\\n    }\\n\\n    receive() external payable {}\\n\\n    function redeemSafoBill(uint256 percentage) external nonReentrant {\\n        require(block.timestamp <= poolEndTime, \\\"Please duration not ended\\\");\\n        require(percentage <= 10000, \\\"Invalid percentage\\\");\\n\\n        uint256 amount = (userStakedBalance[msg.sender] * percentage) / 10000;\\n        require(amount > 0, \\\"No Tokens to unstake\\\");\\n\\n        uint256 bnbOwed = (userPresaleMBalance[msg.sender] * percentage) /\\n            10000;\\n        uint256 tokenOwed = (userPresaleTBalance[msg.sender] * percentage) /\\n            10000;\\n        uint256 tokenBonds = (userPresaleLBalance[msg.sender] * percentage) /\\n            10000;\\n        require(tokenBonds > 0, \\\"No Tokens to unstake\\\");\\n         (\\n            address _WETH,\\n            uint amountToken,\\n            uint amountETH\\n        ) = removeTokenLiquidity(amount);\\n\\n        userPresaleTBalance[msg.sender] -= tokenOwed;\\n        userPresaleMBalance[msg.sender] -= bnbOwed;\\n        userPresaleLBalance[msg.sender] -= tokenBonds;\\n\\n        selfInfo.tokensSold -= tokenOwed;\\n        selfInfo.bnbSold -= (bnbOwed + amountETH);\\n        selfInfo.LPTokens -= amount;\\n\\n        IERC20A(_WETH).transfer(msg.sender, amountETH);\\n        Token.transfer(msg.sender, tokenOwed);\\n    }\\n\\n    function cancel() external onlyAdmin {\\n        poolCancelled = true;\\n    }\\n\\n    function finalizePool() external onlyAdmin {\\n        require(!poolFinalized, \\\"Pool already finalized\\\");\\n        poolFinalized = true;\\n        selfInfo.startTime = block.timestamp;\\n        poolShifted = true;\\n    }\\n\\n    function refund(uint256 percentage) external nonReentrant {\\n        require(poolCancelled, \\\"Pool is not cancelled yet\\\");\\n        require(percentage <= 10000, \\\"Invalid percentage\\\");\\n\\n        uint256 amount = (userStakedBalance[msg.sender] * percentage) / 10000;\\n        require(amount > 0, \\\"No LP Tokens to unstake\\\");\\n\\n        uint256 bnbOwed = (userPresaleMBalance[msg.sender] * percentage) /\\n            10000;\\n        uint256 tokenOwed = (userPresaleTBalance[msg.sender] * percentage) /\\n            10000;\\n        uint256 tokenBonds = (userPresaleLBalance[msg.sender] * percentage) /\\n            10000;\\n        require(tokenBonds > 0, \\\"No Tokens to unstake\\\");\\n\\n        (\\n            address _WETH,\\n            uint amountToken,\\n            uint amountETH\\n        ) = removeTokenLiquidity(amount);\\n\\n        userPresaleTBalance[msg.sender] -= tokenOwed;\\n        userPresaleMBalance[msg.sender] -= bnbOwed;\\n        userPresaleLBalance[msg.sender] -= tokenBonds;\\n\\n        selfInfo.tokensSold -= tokenOwed;\\n        selfInfo.bnbSold -= (bnbOwed + amountETH);\\n        selfInfo.LPTokens -= amount;\\n\\n        IERC20A(_WETH).transfer(msg.sender, amountETH);\\n        payable(msg.sender).transfer(bnbOwed);\\n        // Token.transfer(msg.sender, tokenOwed);\\n    }\\n\\n    function cancelInvestment() external nonReentrant {\\n        require(!poolFinalized, \\\"Pool is Finalized\\\");\\n\\n        uint256 amount = userStakedBalance[msg.sender];\\n        require(amount > 0, \\\"No LP Tokens to unstake\\\");\\n\\n        uint256 bnbOwed = userPresaleMBalance[msg.sender];\\n        uint256 tokenOwed = userPresaleTBalance[msg.sender];\\n        uint256 tokenBonds = userPresaleLBalance[msg.sender];\\n\\n        (\\n            address _WETH,\\n            uint amountToken,\\n            uint amountETH\\n        ) = removeTokenLiquidity(amount);\\n\\n        userPresaleTBalance[msg.sender] -= tokenOwed;\\n        userPresaleMBalance[msg.sender] -= bnbOwed;\\n        userPresaleLBalance[msg.sender] -= tokenBonds;\\n\\n        selfInfo.tokensSold -= tokenOwed;\\n        selfInfo.bnbSold -= (bnbOwed + amountETH);\\n        selfInfo.LPTokens -= amount;\\n\\n        uint256 wbnbFee = (amountETH * emergencyFee) / 10000;\\n        uint256 wbnbAfterFee = amountETH - wbnbFee;\\n        uint256 bnbFee = (bnbOwed * emergencyFee) / 10000;\\n        uint256 bnbAfterFee = bnbOwed - bnbFee;\\n\\n        IERC20A(_WETH).transfer(msg.sender, wbnbAfterFee);\\n        payable(msg.sender).transfer(bnbAfterFee);\\n        IERC20A(_WETH).transfer(teamWallet, wbnbFee);\\n        payable(teamWallet).transfer(bnbFee);\\n    }\\n\\n    function emergencySale(uint256 percentage) external nonReentrant {\\n        require(block.timestamp <= poolEndTime, \\\"Pool Ended\\\");\\n        require(percentage <= 10000, \\\"Invalid percentage\\\");\\n\\n        uint256 amount = (userStakedBalance[msg.sender] * percentage) / 10000;\\n        require(amount > 0, \\\"No LP Tokens to unstake\\\");\\n\\n        uint256 bnbOwed = (userPresaleMBalance[msg.sender] * percentage) /\\n            10000;\\n        uint256 tokenOwed = (userPresaleTBalance[msg.sender] * percentage) /\\n            10000;\\n        uint256 tokenBonds = (userPresaleLBalance[msg.sender] * percentage) /\\n            10000;\\n        require(tokenBonds > 0, \\\"No Tokens to unstake\\\");\\n\\n        (\\n            address _WETH,\\n            uint amountToken,\\n            uint amountETH\\n        ) = removeTokenLiquidity(amount);\\n\\n        userPresaleTBalance[msg.sender] -= tokenOwed;\\n        userPresaleMBalance[msg.sender] -= bnbOwed;\\n        userPresaleLBalance[msg.sender] -= tokenBonds;\\n\\n        selfInfo.tokensSold -= tokenOwed;\\n        selfInfo.bnbSold -= (bnbOwed + amountETH);\\n        selfInfo.LPTokens -= amount;\\n\\n        uint256 wbnbFee = (amountETH * emergencyFee) / 10000;\\n        uint256 bnbOwedAfterFee = amountETH - wbnbFee;\\n        uint256 tokenFee = (tokenOwed * emergencyFee) / 10000;\\n        uint256 tokenOwedAfterFee = tokenOwed - tokenFee;\\n\\n        IERC20A(_WETH).transfer(msg.sender, bnbOwedAfterFee);\\n        IERC20A(selfInfo.token).transfer(msg.sender, tokenOwedAfterFee);\\n        IERC20A(_WETH).transfer(teamWallet, wbnbFee);\\n        IERC20A(selfInfo.token).transfer(teamWallet, tokenFee);\\n    }\\n\\n    function removeTokenLiquidity(\\n        uint amount\\n    ) private returns (address, uint, uint) {\\n        IUniswapV2Router02 Router = IUniswapV2Router02(selfInfo.router);\\n        address _WETH = Router.WETH();\\n        address _uniswapV2Pair = IUniswapV2Factory(Router.factory()).getPair(\\n            selfInfo.token,\\n            _WETH\\n        );\\n        IUniswapV2Pair(_uniswapV2Pair).approve(selfInfo.router, amount);\\n\\n        (uint256 amountToken, uint256 amountETH) = IUniswapV2Router01(\\n            selfInfo.router\\n        ).removeLiquidity(\\n                selfInfo.token,\\n                _WETH,\\n                amount,\\n                0,\\n                0,\\n                address(this),\\n                block.timestamp + 500\\n            );\\n        _unstake(amount);\\n        return (_WETH, amountToken, amountETH);\\n    }\\n\\n    function claimRewards() public updateReward(msg.sender) {\\n        uint256 rewards = userRewards[msg.sender];\\n        require(rewards > 0, \\\"No Claim Rewards Yet!\\\");\\n\\n        require(\\n            rewards <= TokensForReward,\\n            \\\"insufficient tokens for reward, please contact admin\\\"\\n        );\\n        TokensForReward -= rewards;\\n\\n        userRewards[msg.sender] = 0;\\n        userPaidRewards[msg.sender] += rewards;\\n\\n        if (userStakeIsRefferred[msg.sender] == true) {\\n            if (refferralRewardCount[msg.sender] < refferralLimit) {\\n                uint256 refferalReward = (rewards * refferralPercentage) / 100;\\n                refferralRewardCount[msg.sender] =\\n                    refferralRewardCount[msg.sender] +\\n                    1;\\n                ReferralIncome[userRefferred[msg.sender]] += refferalReward;\\n                Token.transfer(userRefferred[msg.sender], refferalReward);\\n                Token.transfer(msg.sender, rewards - refferalReward);\\n            } else {\\n                Token.transfer(msg.sender, rewards);\\n            }\\n        } else {\\n            Token.transfer(msg.sender, rewards);\\n        }\\n    }\\n\\n    function withdrawFund() external payable onlyAdmin {\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n\\n    function withdrawTokens() external payable onlyAdmin {\\n        Token.transfer(msg.sender, Token.balanceOf(address(this)));\\n    }\\n\\n    function withdrawCustomTokens(\\n        address _tokenAddress\\n    ) external payable onlyAdmin {\\n        IERC20A(_tokenAddress).transfer(\\n            msg.sender,\\n            IERC20A(_tokenAddress).balanceOf(address(this))\\n        );\\n    }\\n\\n    function withdrawLPTokens() external payable onlyAdmin {\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\\n            selfInfo.router\\n        ); // pancake test old 0xD99D1c33F9fC3444f8101754aBC46c52416550D1 // pancake  test 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3  // uniswap 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D  // pancake original 0x10ED43C718714eb63d5aA57B78B54704E256024E\\n\\n        // Create a uniswap pair for this new token\\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .getPair(selfInfo.token, _uniswapV2Router.WETH());\\n        IUniswapV2Pair pair = IUniswapV2Pair(_uniswapV2Pair);\\n        pair.transfer(msg.sender, pair.balanceOf(address(this)));\\n    }\\n\\n    function _unstake(uint256 _amount) internal updateReward(msg.sender) {\\n        // if (block.timestamp < poolEndTime) revert TokensLocked();\\n        if (_amount <= 0) revert InvalidAmount();\\n        if (_amount > userStakedBalance[msg.sender]) revert InvalidAmount();\\n        userStakedBalance[msg.sender] -= _amount;\\n        _totalStaked -= _amount;\\n    }\\n\\n    function topUpPoolRewards(\\n        uint256 _amount\\n    ) external onlyAdmin updateReward(address(0)) {\\n        uint256 remainingRewards = (poolEndTime - block.timestamp) * rewardRate;\\n        rewardRate = (_amount + remainingRewards) / poolDuration;\\n        require(rewardRate > 0, \\\"reward rate = 0\\\");\\n        updatedAt = block.timestamp;\\n    }\\n\\n    function getSelfInfo() public view returns (presale memory) {\\n        return selfInfo;\\n    }\\n\\n    function setBadges(bool[] memory _badges) public {\\n        require(msg.sender == owner, \\\"you are not authorised\\\");\\n        selfInfo.badges = _badges;\\n    }\\n\\n    function setRefferralPercentage(\\n        uint256 _newRefferralPercentage\\n    ) external onlyAdmin {\\n        require(_newRefferralPercentage >= 0, \\\"Invalid Refferral Percentage\\\");\\n        refferralPercentage = _newRefferralPercentage;\\n    }\\n\\n    function setRefferralLimit(uint256 _newRefferralLimit) external onlyAdmin {\\n        require(_newRefferralLimit >= 0, \\\"Invalid Refferral Limit\\\");\\n        refferralLimit = _newRefferralLimit;\\n    }\\n\\n    function depositToken(uint256 _amount) public {\\n        require(\\n            Token.allowance(msg.sender, address(this)) >= _amount,\\n            \\\"insufficient allowance\\\"\\n        );\\n        Token.transferFrom(msg.sender, address(this), _amount);\\n        TokensForReward += _amount;\\n    }\\n\\n    function depositTokenForSale(uint256 _amount) public {\\n        require(\\n            Token.allowance(msg.sender, address(this)) >= _amount,\\n            \\\"insufficient allowance\\\"\\n        );\\n        Token.transferFrom(msg.sender, address(this), _amount);\\n    }\\n}\\n\\ncontract launchPad {\\n    address public admin;\\n    address[] public farmArray;\\n\\n    constructor() {\\n        admin = 0x58490A6eD97F8820D8c120dC102F50c638B3C81E;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"you are not allowed\\\");\\n        _;\\n    }\\n\\n    function changeAdmin(address _add) public onlyAdmin {\\n        admin = _add;\\n    }\\n\\n    function launch(\\n        address[] memory _addresses,\\n        uint256[] memory _integers,\\n        string[] memory _strings\\n    ) public onlyAdmin {\\n        IERC20A Token = IERC20A(_addresses[0]);\\n        uint256 tokenAmount = (_integers[0] * _integers[1]) /\\n            10 ** Token.decimals();\\n        require(\\n            Token.allowance(msg.sender, address(this)) >= tokenAmount,\\n            \\\"insufficient allowance\\\"\\n        );\\n        SafoBillsFarm tx1 = new SafoBillsFarm(\\n            msg.sender,\\n            _addresses,\\n            _integers,\\n            _strings\\n        );\\n        Token.transferFrom(msg.sender, address(tx1), tokenAmount);\\n        farmArray.push(address(tx1));\\n    }\\n\\n    function getFarmArray() public view returns (address[] memory) {\\n        return farmArray;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"farmArray\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFarmArray\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_integers\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"_strings\",\"type\":\"string[]\"}],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "launchPad", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}