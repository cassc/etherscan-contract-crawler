{"SourceCode": "// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/SignedMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n    /**\r\n     * @dev Returns the largest of two signed numbers.\r\n     */\r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two signed numbers.\r\n     */\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two signed numbers without overflow.\r\n     * The result is rounded towards zero.\r\n     */\r\n    function average(int256 a, int256 b) internal pure returns (int256) {\r\n        // Formula from the book \"Hacker's Delight\"\r\n        int256 x = (a & b) + ((a ^ b) >> 1);\r\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the absolute unsigned value of a signed value.\r\n     */\r\n    function abs(int256 n) internal pure returns (uint256) {\r\n        unchecked {\r\n            // must be unchecked in order to support `n = type(int256).min`\r\n            return uint256(n >= 0 ? n : -n);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/Math.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Muldiv operation overflow.\r\n     */\r\n    error MathOverflowedMulDiv();\r\n\r\n    enum Rounding {\r\n        Floor, // Toward negative infinity\r\n        Ceil, // Toward positive infinity\r\n        Trunc, // Toward zero\r\n        Expand // Away from zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds towards infinity instead\r\n     * of rounding towards zero.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b == 0) {\r\n            // Guarantee the same behavior as in a regular Solidity division.\r\n            return a / b;\r\n        }\r\n\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\r\n     * denominator == 0.\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\r\n     * Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            if (denominator <= prod1) {\r\n                revert MathOverflowedMulDiv();\r\n            }\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\r\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            uint256 twos = denominator & (0 - denominator);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\r\n            // works in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\r\n     * towards zero.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\r\n     */\r\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\r\n        return uint8(rounding) % 2 == 1;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\r\n    uint8 private constant ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev The `value` string doesn't fit in the specified `length`.\r\n     */\r\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toStringSigned(int256 value) internal pure returns (string memory) {\r\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        uint256 localValue = value;\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\r\n            localValue >>= 4;\r\n        }\r\n        if (localValue != 0) {\r\n            revert StringsInsufficientHexLength(value, length);\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\r\n     * representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two strings are equal.\r\n     */\r\n    function equal(string memory a, string memory b) internal pure returns (bool) {\r\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: /DN404Mirror.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @title DN404Mirror\r\n/// @notice DN404Mirror provides an interface for interacting with the\r\n/// NFT tokens in a DN404 implementation.\r\n///\r\n/// @author vectorized.eth (@optimizoor)\r\n/// @author Quit (@0xQuit)\r\n/// @author Michael Amadi (@AmadiMichaels)\r\n/// @author cygaar (@0xCygaar)\r\n/// @author Thomas (@0xjustadev)\r\n/// @author Harrison (@PopPunkOnChain)\r\n///\r\n/// @dev Note:\r\n/// - The ERC721 data is stored in the base DN404 contract.\r\ncontract DN404Mirror {\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                           EVENTS                           */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\r\n\r\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\r\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\r\n\r\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\r\n\r\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\r\n    /// This is for marketplace signaling purposes. This contract has a `pullOwner()`\r\n    /// function that will sync the owner from the base contract.\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\r\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\r\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\r\n\r\n    /// @dev `keccak256(bytes(\"ApprovalForAll(address,address,bool)\"))`.\r\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\r\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                        CUSTOM ERRORS                       */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Thrown when a call for an NFT function did not originate\r\n    /// from the base DN404 contract.\r\n    error SenderNotBase();\r\n\r\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\r\n    error SenderNotDeployer();\r\n\r\n    /// @dev Thrown when transferring an NFT to a contract address that\r\n    /// does not implement ERC721Receiver.\r\n    error TransferToNonERC721ReceiverImplementer();\r\n\r\n    /// @dev Thrown when linking to the DN404 base contract and the\r\n    /// DN404 supportsInterface check fails or the call reverts.\r\n    error CannotLink();\r\n\r\n    /// @dev Thrown when a linkMirrorContract call is received and the\r\n    /// NFT mirror contract has already been linked to a DN404 base contract.\r\n    error AlreadyLinked();\r\n\r\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\r\n    /// been established.\r\n    error NotLinked();\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                          STORAGE                           */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Struct contain the NFT mirror contract storage.\r\n    struct DN404NFTStorage {\r\n        address baseERC20;\r\n        address deployer;\r\n        address owner;\r\n    }\r\n\r\n    /// @dev Returns a storage pointer for DN404NFTStorage.\r\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // `uint72(bytes9(keccak256(\"DN404_MIRROR_STORAGE\")))`.\r\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                        CONSTRUCTOR                         */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    constructor(address deployer) {\r\n        // For non-proxies, we will store the deployer so that only the deployer can\r\n        // link the base contract.\r\n        _getDN404NFTStorage().deployer = deployer;\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                     ERC721 OPERATIONS                      */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the token collection name from the base DN404 contract.\r\n    function name() public view virtual returns (string memory result) {\r\n        return _readString(0x06fdde03, 0); // `symbol()`.\r\n    }\r\n\r\n    /// @dev Returns the token collection symbol from the base DN404 contract.\r\n    function symbol() public view virtual returns (string memory result) {\r\n        return _readString(0x95d89b41, 0); // `symbol()`.\r\n    }\r\n\r\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\r\n    /// the base DN404 contract.\r\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\r\n        return _readString(0xc87b56dd, id); // `tokenURI()`.\r\n    }\r\n\r\n    /// @dev Returns the total NFT supply from the base DN404 contract.\r\n    function totalSupply() public view virtual returns (uint256 result) {\r\n        return _readWord(0xe2c79281, 0, 0); // `totalNFTSupply()`.\r\n    }\r\n\r\n    /// @dev Returns the number of NFT tokens owned by `nftOwner` from the base DN404 contract.\r\n    ///\r\n    /// Requirements:\r\n    /// - `nftOwner` must not be the zero address.\r\n    function balanceOf(address nftOwner) public view virtual returns (uint256 result) {\r\n        return _readWord(0xf5b100ea, uint160(nftOwner), 0); // `balanceOfNFT(address)`.\r\n    }\r\n\r\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    function ownerOf(uint256 id) public view virtual returns (address result) {\r\n        return address(uint160(_readWord(0x6352211e, id, 0))); // `ownerOf(uint256)`.\r\n    }\r\n\r\n    /// @dev Sets `spender` as the approved account to manage token `id` in\r\n    /// the base DN404 contract.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    /// - The caller must be the owner of the token,\r\n    ///   or an approved operator for the token owner.\r\n    ///\r\n    /// Emits an {Approval} event.\r\n    function approve(address spender, uint256 id) public virtual {\r\n        address base = baseERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            spender := shr(96, shl(96, spender))\r\n            let m := mload(0x40)\r\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\r\n            mstore(0x20, spender)\r\n            mstore(0x40, id)\r\n            mstore(0x60, caller())\r\n            if iszero(\r\n                and(\r\n                    gt(returndatasize(), 0x1f),\r\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                returndatacopy(m, 0x00, returndatasize())\r\n                revert(m, returndatasize())\r\n            }\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            mstore(0x60, 0) // Restore the zero pointer.\r\n            // Emit the {Approval} event.\r\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the account approved to manage token `id` from\r\n    /// the base DN404 contract.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    function getApproved(uint256 id) public view virtual returns (address) {\r\n        return address(uint160(_readWord(0x081812fc, id, 0))); // `getApproved(uint256)`.\r\n    }\r\n\r\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\r\n    /// the base DN404 contract.\r\n    ///\r\n    /// Emits an {ApprovalForAll} event.\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        address base = baseERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            operator := shr(96, shl(96, operator))\r\n            let m := mload(0x40)\r\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\r\n            mstore(0x20, operator)\r\n            mstore(0x40, iszero(iszero(approved)))\r\n            mstore(0x60, caller())\r\n            if iszero(\r\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\r\n            ) {\r\n                returndatacopy(m, 0x00, returndatasize())\r\n                revert(m, returndatasize())\r\n            }\r\n            // Emit the {ApprovalForAll} event.\r\n            // The `approved` value is already at 0x40.\r\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            mstore(0x60, 0) // Restore the zero pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether `operator` is approved to manage the tokens of `nftOwner` from\r\n    /// the base DN404 contract.\r\n    function isApprovedForAll(address nftOwner, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bool result)\r\n    {\r\n        // `isApprovedForAll(address,address)`.\r\n        return _readWord(0xe985e9c5, uint160(nftOwner), uint160(operator)) != 0;\r\n    }\r\n\r\n    /// @dev Transfers token `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Token `id` must exist.\r\n    /// - `from` must be the owner of the token.\r\n    /// - `to` cannot be the zero address.\r\n    /// - The caller must be the owner of the token, or be approved to manage the token.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transferFrom(address from, address to, uint256 id) public virtual {\r\n        address base = baseERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            from := shr(96, shl(96, from))\r\n            to := shr(96, shl(96, to))\r\n            let m := mload(0x40)\r\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\r\n            mstore(add(m, 0x20), from)\r\n            mstore(add(m, 0x40), to)\r\n            mstore(add(m, 0x60), id)\r\n            mstore(add(m, 0x80), caller())\r\n            if iszero(\r\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\r\n            ) {\r\n                returndatacopy(m, 0x00, returndatasize())\r\n                revert(m, returndatasize())\r\n            }\r\n            // Emit the {Transfer} event.\r\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\r\n        }\r\n    }\r\n\r\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \"\")`.\r\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \"\");\r\n    }\r\n\r\n    /// @dev Transfers token `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Token `id` must exist.\r\n    /// - `from` must be the owner of the token.\r\n    /// - `to` cannot be the zero address.\r\n    /// - The caller must be the owner of the token, or be approved to manage the token.\r\n    /// - If `to` refers to a smart contract, it must implement\r\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\r\n        public\r\n        virtual\r\n    {\r\n        transferFrom(from, to, id);\r\n\r\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\r\n    }\r\n\r\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\r\n    /// See: https://eips.ethereum.org/EIPS/eip-165\r\n    /// This function call must use less than 30000 gas.\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let s := shr(224, interfaceId)\r\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\r\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                  OWNER SYNCING OPERATIONS                  */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the `owner` of the contract, for marketplace signaling purposes.\r\n    function owner() public view virtual returns (address) {\r\n        return _getDN404NFTStorage().owner;\r\n    }\r\n\r\n    /// @dev Permissionless function to pull the owner from the base DN404 contract\r\n    /// if it implements ownable, for marketplace signaling purposes.\r\n    function pullOwner() public virtual {\r\n        address newOwner;\r\n        address base = baseERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, 0x8da5cb5b) // `owner()`.\r\n            if and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20)) {\r\n                newOwner := shr(96, mload(0x0c))\r\n            }\r\n        }\r\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\r\n        address oldOwner = $.owner;\r\n        if (oldOwner != newOwner) {\r\n            $.owner = newOwner;\r\n            emit OwnershipTransferred(oldOwner, newOwner);\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                     MIRROR OPERATIONS                      */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the address of the base DN404 contract.\r\n    function baseERC20() public view virtual returns (address base) {\r\n        base = _getDN404NFTStorage().baseERC20;\r\n        if (base == address(0)) revert NotLinked();\r\n    }\r\n\r\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\r\n    modifier dn404NFTFallback() virtual {\r\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\r\n\r\n        uint256 fnSelector = _calldataload(0x00) >> 224;\r\n\r\n        // `logTransfer(uint256[])`.\r\n        if (fnSelector == 0x263c69d6) {\r\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\r\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\r\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\r\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\r\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\r\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\r\n\r\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\r\n                    let d := calldataload(o) // Entry in the packed logs.\r\n                    let a := shr(96, d) // The address.\r\n                    let b := and(1, d) // Whether it is a burn.\r\n                    log4(\r\n                        codesize(),\r\n                        0x00,\r\n                        _TRANSFER_EVENT_SIGNATURE,\r\n                        mul(a, b),\r\n                        mul(a, iszero(b)),\r\n                        shr(168, shl(160, d))\r\n                    )\r\n                }\r\n                mstore(0x00, 0x01)\r\n                return(0x00, 0x20)\r\n            }\r\n        }\r\n        // `linkMirrorContract(address)`.\r\n        if (fnSelector == 0x0f4599e5) {\r\n            if ($.deployer != address(0)) {\r\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\r\n                    revert SenderNotDeployer();\r\n                }\r\n            }\r\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\r\n            $.baseERC20 = msg.sender;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                mstore(0x00, 0x01)\r\n                return(0x00, 0x20)\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function for calls from base DN404 contract.\r\n    fallback() external payable virtual dn404NFTFallback {}\r\n\r\n    receive() external payable virtual {}\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                      PRIVATE HELPERS                       */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Helper to read a string from the base DN404 contract.\r\n    function _readString(uint256 fnSelector, uint256 arg0)\r\n        private\r\n        view\r\n        returns (string memory result)\r\n    {\r\n        address base = baseERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := mload(0x40)\r\n            mstore(0x00, fnSelector)\r\n            mstore(0x20, arg0)\r\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\r\n                returndatacopy(result, 0x00, returndatasize())\r\n                revert(result, returndatasize())\r\n            }\r\n            returndatacopy(0x00, 0x00, 0x20) // Copy the offset of the string in returndata.\r\n            returndatacopy(result, mload(0x00), 0x20) // Copy the length of the string.\r\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result)) // Copy the string.\r\n            mstore(0x40, add(add(result, 0x20), mload(result))) // Allocate memory.\r\n        }\r\n    }\r\n\r\n    /// @dev Helper to read a word from the base DN404 contract.\r\n    function _readWord(uint256 fnSelector, uint256 arg0, uint256 arg1)\r\n        private\r\n        view\r\n        returns (uint256 result)\r\n    {\r\n        address base = baseERC20();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(0x00, fnSelector)\r\n            mstore(0x20, arg0)\r\n            mstore(0x40, arg1)\r\n            if iszero(\r\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\r\n            ) {\r\n                returndatacopy(m, 0x00, returndatasize())\r\n                revert(m, returndatasize())\r\n            }\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            result := mload(0x00)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the calldata value at `offset`.\r\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            value := calldataload(offset)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns if `a` has bytecode of non-zero length.\r\n    function _hasCode(address a) private view returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := extcodesize(a) // Can handle dirty upper bits.\r\n        }\r\n    }\r\n\r\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\r\n    /// Reverts if the target does not support the function correctly.\r\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\r\n        private\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Prepare the calldata.\r\n            let m := mload(0x40)\r\n            let onERC721ReceivedSelector := 0x150b7a02\r\n            mstore(m, onERC721ReceivedSelector)\r\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\r\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\r\n            mstore(add(m, 0x60), id)\r\n            mstore(add(m, 0x80), 0x80)\r\n            let n := mload(data)\r\n            mstore(add(m, 0xa0), n)\r\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\r\n            // Revert if the call reverts.\r\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\r\n                if returndatasize() {\r\n                    // Bubble up the revert if the call reverts.\r\n                    returndatacopy(m, 0x00, returndatasize())\r\n                    revert(m, returndatasize())\r\n                }\r\n            }\r\n            // Load the returndata and compare it.\r\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\r\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n}\r\n// File: /DN404.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @title DN404\r\n/// @notice DN404 is a hybrid ERC20 and ERC721 implementation that mints\r\n/// and burns NFTs based on an account's ERC20 token balance.\r\n///\r\n/// @author vectorized.eth (@optimizoor)\r\n/// @author Quit (@0xQuit)\r\n/// @author Michael Amadi (@AmadiMichaels)\r\n/// @author cygaar (@0xCygaar)\r\n/// @author Thomas (@0xjustadev)\r\n/// @author Harrison (@PopPunkOnChain)\r\n///\r\n/// @dev Note:\r\n/// - The ERC721 data is stored in this base DN404 contract, however a\r\n///   DN404Mirror contract ***MUST*** be deployed and linked during\r\n///   initialization.\r\nabstract contract DN404 {\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                           EVENTS                           */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /// @dev Emitted when `target` sets their skipNFT flag to `status`.\r\n    event SkipNFTSet(address indexed target, bool status);\r\n\r\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\r\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\r\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                        CUSTOM ERRORS                       */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Thrown when attempting to double-initialize the contract.\r\n    error DNAlreadyInitialized();\r\n\r\n    /// @dev Thrown when attempting to transfer or burn more tokens than sender's balance.\r\n    error InsufficientBalance();\r\n\r\n    /// @dev Thrown when a spender attempts to transfer tokens with an insufficient allowance.\r\n    error InsufficientAllowance();\r\n\r\n    /// @dev Thrown when minting an amount of tokens that would overflow the max tokens.\r\n    error TotalSupplyOverflow();\r\n\r\n    /// @dev Thrown when the caller for a fallback NFT function is not the mirror contract.\r\n    error SenderNotMirror();\r\n\r\n    /// @dev Thrown when attempting to transfer tokens to the zero address.\r\n    error TransferToZeroAddress();\r\n\r\n    /// @dev Thrown when the mirror address provided for initialization is the zero address.\r\n    error MirrorAddressIsZero();\r\n\r\n    /// @dev Thrown when the link call to the mirror contract reverts.\r\n    error LinkMirrorContractFailed();\r\n\r\n    /// @dev Thrown when setting an NFT token approval\r\n    /// and the caller is not the owner or an approved operator.\r\n    error ApprovalCallerNotOwnerNorApproved();\r\n\r\n    /// @dev Thrown when transferring an NFT\r\n    /// and the caller is not the owner or an approved operator.\r\n    error TransferCallerNotOwnerNorApproved();\r\n\r\n    /// @dev Thrown when transferring an NFT and the from address is not the current owner.\r\n    error TransferFromIncorrectOwner();\r\n\r\n    /// @dev Thrown when checking the owner or approved address for an non-existent NFT.\r\n    error TokenDoesNotExist();\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                         CONSTANTS                          */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Amount of token balance that is equal to one NFT.\r\n    uint256 internal constant _WAD = 10 ** 18;\r\n\r\n    /// @dev The maximum token ID allowed for an NFT.\r\n    uint256 internal constant _MAX_TOKEN_ID = 0xffffffff;\r\n\r\n    /// @dev The maximum possible token supply.\r\n    uint256 internal constant _MAX_SUPPLY = 10 ** 18 * 0xffffffff - 1;\r\n\r\n    /// @dev The flag to denote that the address data is initialized.\r\n    uint8 internal constant _ADDRESS_DATA_INITIALIZED_FLAG = 1 << 0;\r\n\r\n    /// @dev The flag to denote that the address should skip NFTs.\r\n    uint8 internal constant _ADDRESS_DATA_SKIP_NFT_FLAG = 1 << 1;\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                          STORAGE                           */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Struct containing an address's token data and settings.\r\n    struct AddressData {\r\n        // Auxiliary data.\r\n        uint88 aux;\r\n        // Flags for `initialized` and `skipNFT`.\r\n        uint8 flags;\r\n        // The alias for the address. Zero means absence of an alias.\r\n        uint32 addressAlias;\r\n        // The number of NFT tokens.\r\n        uint32 ownedLength;\r\n        // The token balance in wei.\r\n        uint96 balance;\r\n    }\r\n\r\n    /// @dev A uint32 map in storage.\r\n    struct Uint32Map {\r\n        mapping(uint256 => uint256) map;\r\n    }\r\n\r\n    /// @dev A struct to wrap a uint256 in storage.\r\n    struct Uint256Ref {\r\n        uint256 value;\r\n    }\r\n\r\n    /// @dev Struct containing the base token contract storage.\r\n    struct DN404Storage {\r\n        // Current number of address aliases assigned.\r\n        uint32 numAliases;\r\n        // Next token ID to assign for an NFT mint.\r\n        uint32 nextTokenId;\r\n        // Total supply of minted NFTs.\r\n        uint32 totalNFTSupply;\r\n        // Total supply of tokens.\r\n        uint96 totalSupply;\r\n        // Address of the NFT mirror contract.\r\n        address mirrorERC721;\r\n        // Mapping of a user alias number to their address.\r\n        mapping(uint32 => address) aliasToAddress;\r\n        // Mapping of user operator approvals for NFTs.\r\n        mapping(address => mapping(address => bool)) operatorApprovals;\r\n        // Mapping of NFT token approvals to approved operators.\r\n        mapping(uint256 => address) tokenApprovals;\r\n        // Mapping of user allowances for token spenders.\r\n        mapping(address => mapping(address => Uint256Ref)) allowance;\r\n        // Mapping of NFT token IDs owned by an address.\r\n        mapping(address => Uint32Map) owned;\r\n        // Even indices: owner aliases. Odd indices: owned indices.\r\n        Uint32Map oo;\r\n        // Mapping of user account AddressData\r\n        mapping(address => AddressData) addressData;\r\n    }\r\n\r\n    /// @dev Returns a storage pointer for DN404Storage.\r\n    function _getDN404Storage() internal pure virtual returns (DN404Storage storage $) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // `uint72(bytes9(keccak256(\"DN404_STORAGE\")))`.\r\n            $.slot := 0xa20d6e21d0e5255308 // Truncate to 9 bytes to reduce bytecode size.\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                         INITIALIZER                        */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Initializes the DN404 contract with an\r\n    /// `initialTokenSupply`, `initialTokenOwner` and `mirror` NFT contract address.\r\n    function _initializeDN404(\r\n        uint256 initialTokenSupply,\r\n        address initialSupplyOwner,\r\n        address mirror\r\n    ) internal virtual {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        if ($.nextTokenId != 0) revert DNAlreadyInitialized();\r\n\r\n        if (mirror == address(0)) revert MirrorAddressIsZero();\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Make the call to link the mirror contract.\r\n            mstore(0x00, 0x0f4599e5) // `linkMirrorContract(address)`.\r\n            mstore(0x20, caller())\r\n            if iszero(and(eq(mload(0x00), 1), call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20))) {\r\n                mstore(0x00, 0xd125259c) // `LinkMirrorContractFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n\r\n        $.nextTokenId = 1;\r\n        $.mirrorERC721 = mirror;\r\n\r\n        if (initialTokenSupply != 0) {\r\n            if (initialSupplyOwner == address(0)) revert TransferToZeroAddress();\r\n            if (initialTokenSupply > _MAX_SUPPLY) revert TotalSupplyOverflow();\r\n\r\n            $.totalSupply = uint96(initialTokenSupply);\r\n            AddressData storage initialOwnerAddressData = _addressData(initialSupplyOwner);\r\n            initialOwnerAddressData.balance = uint96(initialTokenSupply);\r\n\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                // Emit the {Transfer} event.\r\n                mstore(0x00, initialTokenSupply)\r\n                log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, shl(96, initialSupplyOwner)))\r\n            }\r\n\r\n            _setSkipNFT(initialSupplyOwner, true);\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*               METADATA FUNCTIONS TO OVERRIDE               */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the name of the token.\r\n    function name() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the symbol of the token.\r\n    function symbol() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\r\n    function tokenURI(uint256 id) public view virtual returns (string memory);\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                      ERC20 OPERATIONS                      */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the decimals places of the token. Always 18.\r\n    function decimals() public pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens in existence.\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return uint256(_getDN404Storage().totalSupply);\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens owned by `owner`.\r\n    function balanceOf(address owner) public view virtual returns (uint256) {\r\n        return _getDN404Storage().addressData[owner].balance;\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _getDN404Storage().allowance[owner][spender].value;\r\n    }\r\n\r\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer `amount` tokens from the caller to `to`.\r\n    ///\r\n    /// Will burn sender NFTs if balance after transfer is less than\r\n    /// the amount required to support the current NFT balance.\r\n    ///\r\n    /// Will mint NFTs to `to` if the recipient's new balance supports\r\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\r\n    /// set to false.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must at least have `amount`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        _transfer(msg.sender, to, amount);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers `amount` tokens from `from` to `to`.\r\n    ///\r\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\r\n    ///\r\n    /// Will burn sender NFTs if balance after transfer is less than\r\n    /// the amount required to support the current NFT balance.\r\n    ///\r\n    /// Will mint NFTs to `to` if the recipient's new balance supports\r\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\r\n    /// set to false.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must at least have `amount`.\r\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\r\n        Uint256Ref storage a = _getDN404Storage().allowance[from][msg.sender];\r\n        uint256 allowed = a.value;\r\n\r\n        if (allowed != type(uint256).max) {\r\n            if (amount > allowed) revert InsufficientAllowance();\r\n            unchecked {\r\n                a.value = allowed - amount;\r\n            }\r\n        }\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                  INTERNAL MINT FUNCTIONS                   */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\r\n    ///\r\n    /// Will mint NFTs to `to` if the recipient's new balance supports\r\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\r\n    /// set to false.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        if (to == address(0)) revert TransferToZeroAddress();\r\n\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        AddressData storage toAddressData = _addressData(to);\r\n\r\n        unchecked {\r\n            uint256 currentTokenSupply = uint256($.totalSupply) + amount;\r\n            if (_toUint(amount > _MAX_SUPPLY) | _toUint(currentTokenSupply > _MAX_SUPPLY) != 0) {\r\n                revert TotalSupplyOverflow();\r\n            }\r\n            $.totalSupply = uint96(currentTokenSupply);\r\n\r\n            uint256 toBalance = toAddressData.balance + amount;\r\n            toAddressData.balance = uint96(toBalance);\r\n\r\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\r\n                Uint32Map storage toOwned = $.owned[to];\r\n                uint256 toIndex = toAddressData.ownedLength;\r\n                uint256 toEnd = toBalance / _WAD;\r\n                _PackedLogs memory packedLogs = _packedLogsMalloc(_zeroFloorSub(toEnd, toIndex));\r\n                Uint32Map storage oo = $.oo;\r\n\r\n                if (packedLogs.logs.length != 0) {\r\n                    uint256 maxNFTId = currentTokenSupply / _WAD;\r\n                    uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\r\n                    uint256 id = $.nextTokenId;\r\n                    $.totalNFTSupply += uint32(packedLogs.logs.length);\r\n                    toAddressData.ownedLength = uint32(toEnd);\r\n                    // Mint loop.\r\n                    do {\r\n                        while (_get(oo, _ownershipIndex(id)) != 0) {\r\n                            if (++id > maxNFTId) id = 1;\r\n                        }\r\n                        _set(toOwned, toIndex, uint32(id));\r\n                        _setOwnerAliasAndOwnedIndex(oo, id, toAlias, uint32(toIndex++));\r\n                        _packedLogsAppend(packedLogs, to, id, 0);\r\n                        if (++id > maxNFTId) id = 1;\r\n                    } while (toIndex != toEnd);\r\n                    $.nextTokenId = uint32(id);\r\n                    _packedLogsSend(packedLogs, $.mirrorERC721);\r\n                }\r\n            }\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Emit the {Transfer} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, shl(96, to)))\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                  INTERNAL BURN FUNCTIONS                   */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\r\n    ///\r\n    /// Will burn sender NFTs if balance after transfer is less than\r\n    /// the amount required to support the current NFT balance.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        AddressData storage fromAddressData = _addressData(from);\r\n\r\n        uint256 fromBalance = fromAddressData.balance;\r\n        if (amount > fromBalance) revert InsufficientBalance();\r\n\r\n        uint256 currentTokenSupply = $.totalSupply;\r\n\r\n        unchecked {\r\n            fromBalance -= amount;\r\n            fromAddressData.balance = uint96(fromBalance);\r\n            currentTokenSupply -= amount;\r\n            $.totalSupply = uint96(currentTokenSupply);\r\n\r\n            Uint32Map storage fromOwned = $.owned[from];\r\n            uint256 fromIndex = fromAddressData.ownedLength;\r\n            uint256 nftAmountToBurn = _zeroFloorSub(fromIndex, fromBalance / _WAD);\r\n\r\n            if (nftAmountToBurn != 0) {\r\n                $.totalNFTSupply -= uint32(nftAmountToBurn);\r\n\r\n                _PackedLogs memory packedLogs = _packedLogsMalloc(nftAmountToBurn);\r\n                Uint32Map storage oo = $.oo;\r\n                uint256 fromEnd = fromIndex - nftAmountToBurn;\r\n                // Burn loop.\r\n                do {\r\n                    uint256 id = _get(fromOwned, --fromIndex);\r\n                    _setOwnerAliasAndOwnedIndex(oo, id, 0, 0);\r\n                    delete $.tokenApprovals[id];\r\n                    _packedLogsAppend(packedLogs, from, id, 1);\r\n                } while (fromIndex != fromEnd);\r\n\r\n                fromAddressData.ownedLength = uint32(fromIndex);\r\n                _packedLogsSend(packedLogs, $.mirrorERC721);\r\n            }\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Emit the {Transfer} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Moves `amount` of tokens from `from` to `to`.\r\n    ///\r\n    /// Will burn sender NFTs if balance after transfer is less than\r\n    /// the amount required to support the current NFT balance.\r\n    ///\r\n    /// Will mint NFTs to `to` if the recipient's new balance supports\r\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\r\n    /// set to false.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        if (to == address(0)) revert TransferToZeroAddress();\r\n\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        AddressData storage fromAddressData = _addressData(from);\r\n        AddressData storage toAddressData = _addressData(to);\r\n\r\n        _TransferTemps memory t;\r\n        t.fromOwnedLength = fromAddressData.ownedLength;\r\n        t.toOwnedLength = toAddressData.ownedLength;\r\n        t.fromBalance = fromAddressData.balance;\r\n\r\n        if (amount > t.fromBalance) revert InsufficientBalance();\r\n\r\n        unchecked {\r\n            t.fromBalance -= amount;\r\n            fromAddressData.balance = uint96(t.fromBalance);\r\n            toAddressData.balance = uint96(t.toBalance = toAddressData.balance + amount);\r\n\r\n            t.nftAmountToBurn = _zeroFloorSub(t.fromOwnedLength, t.fromBalance / _WAD);\r\n\r\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\r\n                if (from == to) t.toOwnedLength = t.fromOwnedLength - t.nftAmountToBurn;\r\n                t.nftAmountToMint = _zeroFloorSub(t.toBalance / _WAD, t.toOwnedLength);\r\n            }\r\n\r\n            _PackedLogs memory packedLogs = _packedLogsMalloc(t.nftAmountToBurn + t.nftAmountToMint);\r\n            Uint32Map storage oo = $.oo;\r\n\r\n            if (t.nftAmountToBurn != 0) {\r\n                Uint32Map storage fromOwned = $.owned[from];\r\n                uint256 fromIndex = t.fromOwnedLength;\r\n                uint256 fromEnd = fromIndex - t.nftAmountToBurn;\r\n                $.totalNFTSupply -= uint32(t.nftAmountToBurn);\r\n                fromAddressData.ownedLength = uint32(fromEnd);\r\n                // Burn loop.\r\n                do {\r\n                    uint256 id = _get(fromOwned, --fromIndex);\r\n                    _setOwnerAliasAndOwnedIndex(oo, id, 0, 0);\r\n                    delete $.tokenApprovals[id];\r\n                    _packedLogsAppend(packedLogs, from, id, 1);\r\n                } while (fromIndex != fromEnd);\r\n            }\r\n\r\n            if (t.nftAmountToMint != 0) {\r\n                Uint32Map storage toOwned = $.owned[to];\r\n                uint256 toIndex = t.toOwnedLength;\r\n                uint256 toEnd = toIndex + t.nftAmountToMint;\r\n                uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\r\n                uint256 maxNFTId = $.totalSupply / _WAD;\r\n                uint256 id = $.nextTokenId;\r\n                $.totalNFTSupply += uint32(t.nftAmountToMint);\r\n                toAddressData.ownedLength = uint32(toEnd);\r\n                // Mint loop.\r\n                do {\r\n                    while (_get(oo, _ownershipIndex(id)) != 0) {\r\n                        if (++id > maxNFTId) id = 1;\r\n                    }\r\n                    _set(toOwned, toIndex, uint32(id));\r\n                    _setOwnerAliasAndOwnedIndex(oo, id, toAlias, uint32(toIndex++));\r\n                    _packedLogsAppend(packedLogs, to, id, 0);\r\n                    if (++id > maxNFTId) id = 1;\r\n                } while (toIndex != toEnd);\r\n                $.nextTokenId = uint32(id);\r\n            }\r\n\r\n            if (packedLogs.logs.length != 0) {\r\n                _packedLogsSend(packedLogs, $.mirrorERC721);\r\n            }\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Emit the {Transfer} event.\r\n            mstore(0x00, amount)\r\n            // forgefmt: disable-next-item\r\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), shr(96, shl(96, to)))\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers token `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Call must originate from the mirror contract.\r\n    /// - Token `id` must exist.\r\n    /// - `from` must be the owner of the token.\r\n    /// - `to` cannot be the zero address.\r\n    ///   `msgSender` must be the owner of the token, or be approved to manage the token.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _transferFromNFT(address from, address to, uint256 id, address msgSender)\r\n        internal\r\n        virtual\r\n    {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        if (to == address(0)) revert TransferToZeroAddress();\r\n\r\n        Uint32Map storage oo = $.oo;\r\n\r\n        if (from != $.aliasToAddress[_get(oo, _ownershipIndex(id))]) {\r\n            revert TransferFromIncorrectOwner();\r\n        }\r\n\r\n        if (msgSender != from) {\r\n            if (!$.operatorApprovals[from][msgSender]) {\r\n                if (msgSender != $.tokenApprovals[id]) {\r\n                    revert TransferCallerNotOwnerNorApproved();\r\n                }\r\n            }\r\n        }\r\n\r\n        AddressData storage fromAddressData = _addressData(from);\r\n        AddressData storage toAddressData = _addressData(to);\r\n\r\n        fromAddressData.balance -= uint96(_WAD);\r\n\r\n        unchecked {\r\n            toAddressData.balance += uint96(_WAD);\r\n\r\n            mapping(address => Uint32Map) storage owned = $.owned;\r\n            Uint32Map storage fromOwned = owned[from];\r\n\r\n            _set(oo, _ownershipIndex(id), _registerAndResolveAlias(toAddressData, to));\r\n            delete $.tokenApprovals[id];\r\n\r\n            uint256 updatedId = _get(fromOwned, --fromAddressData.ownedLength);\r\n            _set(fromOwned, _get(oo, _ownedIndex(id)), uint32(updatedId));\r\n\r\n            _set(oo, _ownedIndex(updatedId), _get(oo, _ownedIndex(id)));\r\n            uint256 n = toAddressData.ownedLength++;\r\n            _set(owned[to], n, uint32(id));\r\n            _set(oo, _ownedIndex(id), uint32(n));\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Emit the {Transfer} event.\r\n            mstore(0x00, _WAD)\r\n            // forgefmt: disable-next-item\r\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), shr(96, shl(96, to)))\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                 INTERNAL APPROVE FUNCTIONS                 */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        _getDN404Storage().allowance[owner][spender].value = amount;\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, amount)\r\n            // forgefmt: disable-next-item\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, shl(96, owner)), shr(96, shl(96, spender)))\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                 DATA HITCHHIKING FUNCTIONS                 */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the auxiliary data for `owner`.\r\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\r\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\r\n    function _getAux(address owner) internal view virtual returns (uint88) {\r\n        return _getDN404Storage().addressData[owner].aux;\r\n    }\r\n\r\n    /// @dev Set the auxiliary data for `owner` to `value`.\r\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\r\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\r\n    function _setAux(address owner, uint88 value) internal virtual {\r\n        _getDN404Storage().addressData[owner].aux = value;\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                     SKIP NFT FUNCTIONS                     */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns true if account `owner` will skip NFT minting on token mints and transfers.\r\n    /// Returns false if account `owner` will mint NFTs on token mints and transfers.\r\n    function getSkipNFT(address owner) public view virtual returns (bool) {\r\n        AddressData storage d = _getDN404Storage().addressData[owner];\r\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) return _hasCode(owner);\r\n        return d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0;\r\n    }\r\n\r\n    /// @dev Sets the caller's skipNFT flag to `skipNFT`\r\n    ///\r\n    /// Emits a {SkipNFTSet} event.\r\n    function setSkipNFT(bool skipNFT) public virtual {\r\n        _setSkipNFT(msg.sender, skipNFT);\r\n    }\r\n\r\n    /// @dev Internal function to set account `owner` skipNFT flag to `state`\r\n    ///\r\n    /// Initializes account `owner` AddressData if it is not currently initialized.\r\n    ///\r\n    /// Emits a {SkipNFTSet} event.\r\n    function _setSkipNFT(address owner, bool state) internal virtual {\r\n        AddressData storage d = _addressData(owner);\r\n        if ((d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0) != state) {\r\n            d.flags ^= _ADDRESS_DATA_SKIP_NFT_FLAG;\r\n        }\r\n        emit SkipNFTSet(owner, state);\r\n    }\r\n\r\n    /// @dev Returns a storage data pointer for account `owner` AddressData\r\n    ///\r\n    /// Initializes account `owner` AddressData if it is not currently initialized.\r\n    function _addressData(address owner) internal virtual returns (AddressData storage d) {\r\n        d = _getDN404Storage().addressData[owner];\r\n\r\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) {\r\n            uint8 flags = _ADDRESS_DATA_INITIALIZED_FLAG;\r\n            if (_hasCode(owner)) flags |= _ADDRESS_DATA_SKIP_NFT_FLAG;\r\n            d.flags = flags;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the `addressAlias` of account `to`.\r\n    ///\r\n    /// Assigns and registers the next alias if `to` alias was not previously registered.\r\n    function _registerAndResolveAlias(AddressData storage toAddressData, address to)\r\n        internal\r\n        virtual\r\n        returns (uint32 addressAlias)\r\n    {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n        addressAlias = toAddressData.addressAlias;\r\n        if (addressAlias == 0) {\r\n            addressAlias = ++$.numAliases;\r\n            toAddressData.addressAlias = addressAlias;\r\n            $.aliasToAddress[addressAlias] = to;\r\n        }\r\n    }\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                     MIRROR OPERATIONS                      */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Returns the address of the mirror NFT contract.\r\n    function mirrorERC721() public view virtual returns (address) {\r\n        return _getDN404Storage().mirrorERC721;\r\n    }\r\n\r\n    /// @dev Returns the total NFT supply.\r\n    function _totalNFTSupply() internal view virtual returns (uint256) {\r\n        return _getDN404Storage().totalNFTSupply;\r\n    }\r\n\r\n    /// @dev Returns `owner` NFT balance.\r\n    function _balanceOfNFT(address owner) internal view virtual returns (uint256) {\r\n        return _getDN404Storage().addressData[owner].ownedLength;\r\n    }\r\n\r\n    /// @dev Returns the owner of token `id`.\r\n    /// Returns the zero address instead of reverting if the token does not exist.\r\n    function _ownerAt(uint256 id) internal view virtual returns (address) {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n        return $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\r\n    }\r\n\r\n    /// @dev Returns the owner of token `id`.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\r\n        if (!_exists(id)) revert TokenDoesNotExist();\r\n        return _ownerAt(id);\r\n    }\r\n\r\n    /// @dev Returns if token `id` exists.\r\n    function _exists(uint256 id) internal view virtual returns (bool) {\r\n        return _ownerAt(id) != address(0);\r\n    }\r\n\r\n    /// @dev Returns the account approved to manage token `id`.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    function _getApproved(uint256 id) internal view virtual returns (address) {\r\n        if (!_exists(id)) revert TokenDoesNotExist();\r\n        return _getDN404Storage().tokenApprovals[id];\r\n    }\r\n\r\n    /// @dev Sets `spender` as the approved account to manage token `id`, using `msgSender`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `msgSender` must be the owner or an approved operator for the token owner.\r\n    function _approveNFT(address spender, uint256 id, address msgSender)\r\n        internal\r\n        virtual\r\n        returns (address owner)\r\n    {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\r\n\r\n        if (msgSender != owner) {\r\n            if (!$.operatorApprovals[owner][msgSender]) {\r\n                revert ApprovalCallerNotOwnerNorApproved();\r\n            }\r\n        }\r\n\r\n        $.tokenApprovals[id] = spender;\r\n    }\r\n\r\n    /// @dev Approve or remove the `operator` as an operator for `msgSender`,\r\n    /// without authorization checks.\r\n    function _setApprovalForAll(address operator, bool approved, address msgSender)\r\n        internal\r\n        virtual\r\n    {\r\n        _getDN404Storage().operatorApprovals[msgSender][operator] = approved;\r\n    }\r\n\r\n    /// @dev Fallback modifier to dispatch calls from the mirror NFT contract\r\n    /// to internal functions in this contract.\r\n    modifier dn404Fallback() virtual {\r\n        DN404Storage storage $ = _getDN404Storage();\r\n\r\n        uint256 fnSelector = _calldataload(0x00) >> 224;\r\n\r\n        // `transferFromNFT(address,address,uint256,address)`.\r\n        if (fnSelector == 0xe5eb36c8) {\r\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\r\n            if (msg.data.length < 0x84) revert();\r\n\r\n            address from = address(uint160(_calldataload(0x04)));\r\n            address to = address(uint160(_calldataload(0x24)));\r\n            uint256 id = _calldataload(0x44);\r\n            address msgSender = address(uint160(_calldataload(0x64)));\r\n\r\n            _transferFromNFT(from, to, id, msgSender);\r\n            _return(1);\r\n        }\r\n        // `setApprovalForAll(address,bool,address)`.\r\n        if (fnSelector == 0x813500fc) {\r\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\r\n            if (msg.data.length < 0x64) revert();\r\n\r\n            address spender = address(uint160(_calldataload(0x04)));\r\n            bool status = _calldataload(0x24) != 0;\r\n            address msgSender = address(uint160(_calldataload(0x44)));\r\n\r\n            _setApprovalForAll(spender, status, msgSender);\r\n            _return(1);\r\n        }\r\n        // `isApprovedForAll(address,address)`.\r\n        if (fnSelector == 0xe985e9c5) {\r\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\r\n            if (msg.data.length < 0x44) revert();\r\n\r\n            address owner = address(uint160(_calldataload(0x04)));\r\n            address operator = address(uint160(_calldataload(0x24)));\r\n\r\n            _return(_toUint($.operatorApprovals[owner][operator]));\r\n        }\r\n        // `ownerOf(uint256)`.\r\n        if (fnSelector == 0x6352211e) {\r\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\r\n            if (msg.data.length < 0x24) revert();\r\n\r\n            uint256 id = _calldataload(0x04);\r\n\r\n            _return(uint160(_ownerOf(id)));\r\n        }\r\n        // `approveNFT(address,uint256,address)`.\r\n        if (fnSelector == 0xd10b6e0c) {\r\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\r\n            if (msg.data.length < 0x64) revert();\r\n\r\n            address spender = address(uint160(_calldataload(0x04)));\r\n            uint256 id = _calldataload(0x24);\r\n            address msgSender = address(uint160(_calldataload(0x44)));\r\n\r\n            _return(uint160(_approveNFT(spender, id, msgSender)));\r\n        }\r\n        // `getApproved(uint256)`.\r\n        if (fnSelector == 0x081812fc) {\r\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\r\n            if (msg.data.length < 0x24) revert();\r\n\r\n            uint256 id = _calldataload(0x04);\r\n\r\n            _return(uint160(_getApproved(id)));\r\n        }\r\n        // `balanceOfNFT(address)`.\r\n        if (fnSelector == 0xf5b100ea) {\r\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\r\n            if (msg.data.length < 0x24) revert();\r\n\r\n            address owner = address(uint160(_calldataload(0x04)));\r\n\r\n            _return(_balanceOfNFT(owner));\r\n        }\r\n        // `totalNFTSupply()`.\r\n        if (fnSelector == 0xe2c79281) {\r\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\r\n            if (msg.data.length < 0x04) revert();\r\n\r\n            _return(_totalNFTSupply());\r\n        }\r\n        // `implementsDN404()`.\r\n        if (fnSelector == 0xb7a94eb8) {\r\n            _return(1);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function for calls from mirror NFT contract.\r\n    fallback() external payable virtual dn404Fallback {}\r\n\r\n    receive() external payable virtual {}\r\n\r\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\r\n    /*                      PRIVATE HELPERS                       */\r\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\r\n\r\n    /// @dev Struct containing packed log data for {Transfer} events to be\r\n    /// emitted by the mirror NFT contract.\r\n    struct _PackedLogs {\r\n        uint256 offset;\r\n        uint256[] logs;\r\n    }\r\n\r\n    /// @dev Initiates memory allocation for packed logs with `n` log items.\r\n    function _packedLogsMalloc(uint256 n) private pure returns (_PackedLogs memory p) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Note that `p` implicitly allocates and advances the free memory pointer by\r\n            // 2 words, which we can safely mutate in `_packedLogsSend`.\r\n            let logs := mload(0x40)\r\n            mstore(logs, n) // Store the length.\r\n            let offset := add(0x20, logs)\r\n            mstore(0x40, add(offset, shl(5, n))) // Allocate memory.\r\n            mstore(add(0x20, p), logs) // Set `p.logs`.\r\n            mstore(p, offset) // Set `p.offset`.\r\n        }\r\n    }\r\n\r\n    /// @dev Adds a packed log item to `p` with address `a`, token `id` and burn flag `burnBit`.\r\n    function _packedLogsAppend(_PackedLogs memory p, address a, uint256 id, uint256 burnBit)\r\n        private\r\n        pure\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let offset := mload(p)\r\n            mstore(offset, or(or(shl(96, a), shl(8, id)), burnBit))\r\n            mstore(p, add(offset, 0x20))\r\n        }\r\n    }\r\n\r\n    /// @dev Calls the `mirror` NFT contract to emit {Transfer} events for packed logs `p`.\r\n    function _packedLogsSend(_PackedLogs memory p, address mirror) private {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let logs := mload(add(p, 0x20))\r\n            let o := sub(logs, 0x40) // Start of calldata to send.\r\n            mstore(o, 0x263c69d6) // `logTransfer(uint256[])`.\r\n            mstore(add(o, 0x20), 0x20) // Offset of `logs` in the calldata to send.\r\n            let n := add(0x44, shl(5, mload(logs))) // Length of calldata to send.\r\n            if iszero(and(eq(mload(o), 1), call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20))) {\r\n                revert(o, 0x00)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Struct of temporary variables for transfers.\r\n    struct _TransferTemps {\r\n        uint256 nftAmountToBurn;\r\n        uint256 nftAmountToMint;\r\n        uint256 fromBalance;\r\n        uint256 toBalance;\r\n        uint256 fromOwnedLength;\r\n        uint256 toOwnedLength;\r\n    }\r\n\r\n    /// @dev Returns if `a` has bytecode of non-zero length.\r\n    function _hasCode(address a) private view returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := extcodesize(a) // Can handle dirty upper bits.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the calldata value at `offset`.\r\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            value := calldataload(offset)\r\n        }\r\n    }\r\n\r\n    /// @dev Executes a return opcode to return `x` and end the current call frame.\r\n    function _return(uint256 x) private pure {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, x)\r\n            return(0x00, 0x20)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `max(0, x - y)`.\r\n    function _zeroFloorSub(uint256 x, uint256 y) private pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := mul(gt(x, y), sub(x, y))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `i << 1`.\r\n    function _ownershipIndex(uint256 i) private pure returns (uint256) {\r\n        return i << 1;\r\n    }\r\n\r\n    /// @dev Returns `(i << 1) + 1`.\r\n    function _ownedIndex(uint256 i) private pure returns (uint256) {\r\n        unchecked {\r\n            return (i << 1) + 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `b ? 1 : 0`.\r\n    function _toUint(bool b) private pure returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := iszero(iszero(b))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the uint32 value at `index` in `map`.\r\n    function _get(Uint32Map storage map, uint256 index) private view returns (uint32 result) {\r\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\r\n    }\r\n\r\n    /// @dev Updates the uint32 value at `index` in `map`.\r\n    function _set(Uint32Map storage map, uint256 index, uint32 value) private {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x20, map.slot)\r\n            mstore(0x00, shr(3, index))\r\n            let s := keccak256(0x00, 0x40) // Storage slot.\r\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\r\n            let v := sload(s) // Storage slot value.\r\n            let m := 0xffffffff // Value mask.\r\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets the owner alias and the owned index together.\r\n    function _setOwnerAliasAndOwnedIndex(\r\n        Uint32Map storage map,\r\n        uint256 id,\r\n        uint32 ownership,\r\n        uint32 ownedIndex\r\n    ) private {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let value := or(shl(32, ownedIndex), and(0xffffffff, ownership))\r\n            mstore(0x20, map.slot)\r\n            mstore(0x00, shr(2, id))\r\n            let s := keccak256(0x00, 0x40) // Storage slot.\r\n            let o := shl(6, and(id, 3)) // Storage slot offset (bits).\r\n            let v := sload(s) // Storage slot value.\r\n            let m := 0xffffffffffffffff // Value mask.\r\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\r\n        }\r\n    }\r\n}\r\n// File: simpledn404.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Lucky\r\n * @notice Sample DN404 contract that demonstrates the owner selling fungible tokens.\r\n * When a user has at least one base unit (10^18) amount of tokens, they will automatically receive an NFT.\r\n * NFTs are minted as an address accumulates each base unit amount of tokens.\r\n */\r\ncontract Lucky is DN404, Ownable(msg.sender) {\r\n    string private _name;\r\n    string private _symbol;\r\n    string private _baseURI;\r\n\r\n    address public taxWallet;\r\n\r\n    uint256 public taxRate; // Tax rate as a percentage (1% = 100, 10% = 1000 to allow for decimal points)\r\n    mapping(address => bool) public whitelist;\r\n\r\n    constructor(\r\n  \r\n    ) {\r\n        _name = \"LUCKY\";\r\n        _symbol = \"LUCKY\";\r\n        taxWallet = 0x5C71C6A9D6233CF6bEC9772F0a62f8EF2F1d1Dc1;\r\n        address mirror = address(new DN404Mirror(msg.sender));\r\n        _initializeDN404(1000e18, msg.sender, mirror);\r\n    }\r\n\r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory result) {\r\n        if (bytes(_baseURI).length != 0) {\r\n            result = string(abi.encodePacked(_baseURI, Strings.toString(tokenId)));\r\n        }\r\n    }\r\n\r\n    // This allows the owner of the contract to mint more tokens.\r\n    function mint(address to, uint256 amount) public onlyOwner {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function setBaseURI(string calldata baseURI_) public onlyOwner {\r\n        _baseURI = baseURI_;\r\n    }\r\n\r\n    function SetTaxWallet(address tax) public onlyOwner {\r\n        taxWallet= tax;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the contract owner to withdraw Ether from the contract.\r\n     */\r\n    function withdrawEther() public onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No ether left to withdraw\");\r\n\r\n        (bool success, ) = msg.sender.call{value: balance}(\"\");\r\n        require(success, \"Ether withdrawal failed\");\r\n    }\r\n\r\n    /**\r\n    * @notice Allows the contract owner to withdraw ERC20 tokens from the contract.\r\n    * @param tokenAddress The address of the ERC20 token to withdraw.\r\n    * @param amount The amount of the ERC20 token to withdraw.\r\n    */\r\n    function withdrawERC20(address tokenAddress, uint256 amount) public onlyOwner {\r\n        require(tokenAddress != address(0), \"Invalid token address\");\r\n        IERC20 token = IERC20(tokenAddress);\r\n        uint256 contractBalance = token.balanceOf(address(this));\r\n        require(amount <= contractBalance, \"Insufficient balance\");\r\n\r\n        bool sent = token.transfer(msg.sender, amount);\r\n        require(sent, \"Token transfer failed\");\r\n    }\r\n\r\n        /**\r\n     * @dev Adds an address to the whitelist.\r\n     * @param _address Address to be added to the whitelist.\r\n     */\r\n    function addToWhitelist(address _address) public onlyOwner {\r\n        whitelist[_address] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an address from the whitelist.\r\n     * @param _address Address to be removed from the whitelist.\r\n     */\r\n    function removeFromWhitelist(address _address) public onlyOwner {\r\n        whitelist[_address] = false;\r\n    }\r\n\r\n        /**\r\n     * @dev Sets the tax rate.\r\n     * @param _taxRate The new tax rate to be set.\r\n     */\r\n    function setTaxRate(uint256 _taxRate) public onlyOwner {\r\n        require(_taxRate <= 1000, \"Tax rate cannot exceed 10%\");\r\n        taxRate = _taxRate;\r\n    }\r\n\r\n        /**\r\n     * @dev Override the _transfer function to include tax logic.\r\n     */\r\n    function transfer(address to, uint256 amount) public override returns (bool) {\r\n        uint256 senderBalance = balanceOf(msg.sender);\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n\r\n        // Check if sender or recipient is whitelisted\r\n        if (!whitelist[msg.sender] && !whitelist[to] && taxRate > 0) {\r\n            uint256 taxAmount = (amount * taxRate) / 10000;\r\n            require(amount > taxAmount, \"Transfer amount must be greater than the tax amount\");\r\n            uint256 amountAfterTax = amount - taxAmount;\r\n\r\n            // Assuming the tax is simply removed from the transfer and not redirected\r\n            // Adjust this logic to handle the tax as needed (e.g., send to a treasury or burn)\r\n            _transfer(msg.sender, taxWallet, taxAmount);\r\n            _transfer(msg.sender, to, amountAfterTax);\r\n            // Optionally handle the taxAmount here, e.g., transfer to a treasury or burn it\r\n        } else {\r\n            _transfer(msg.sender, to, amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n        function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount <= balanceOf(from), \"ERC20: transfer amount exceeds balance\");\r\n\r\n        // Calculate the tax if neither party is whitelisted and a tax rate is set\r\n        uint256 taxAmount = 0;\r\n        if (!whitelist[from] && !whitelist[to] && taxRate > 0) {\r\n            taxAmount = (amount * taxRate) / 10000; // Assuming taxRate is in basis points (1% = 100)\r\n            require(amount > taxAmount, \"Transfer amount must be greater than the tax amount\");\r\n        }\r\n        uint256 amountAfterTax = amount - taxAmount;\r\n\r\n        // Update the spender's allowance before transferring\r\n        uint256 currentAllowance = allowance(from, _msgSender());\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(from, _msgSender(), currentAllowance - amount);\r\n\r\n        // Perform the transfer with the post-tax amount\r\n        _transfer(from, taxWallet, taxAmount);\r\n        _transfer(from, to, amountAfterTax);\r\n\r\n        // Optionally handle the taxAmount here, e.g., transfer to a treasury or burn it\r\n        // This example simply burns the tax by not transferring it anywhere\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DNAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkMirrorContractFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MirrorAddressIsZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotMirror\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SkipNFTSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tax\",\"type\":\"address\"}],\"name\":\"SetTaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getSkipNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mirrorERC721\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"skipNFT\",\"type\":\"bool\"}],\"name\":\"setSkipNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxRate\",\"type\":\"uint256\"}],\"name\":\"setTaxRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Lucky", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f464dfebfe8d90684d93c0c054886f27f3f5e7c7db67ea178d6c4b9326922208"}