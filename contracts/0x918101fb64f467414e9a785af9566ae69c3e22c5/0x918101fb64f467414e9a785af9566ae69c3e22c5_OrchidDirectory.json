{"SourceCode": "/* Orchid - WebRTC P2P VPN Market (on Ethereum)\r\n * Copyright (C) 2017-2019  The Orchid Authors\r\n*/\r\n\r\n/* GNU Affero General Public License, Version 3 {{{ */\r\n/*\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Affero General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Affero General Public License for more details.\r\n\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n**/\r\n/* }}} */\r\n\r\n\r\npragma solidity 0.5.13;\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract OrchidDirectory {\r\n\r\n    IERC20 internal token_;\r\n\r\n    constructor(IERC20 token) public {\r\n        token_ = token;\r\n    }\r\n\r\n    function what() external view returns (IERC20) {\r\n        return token_;\r\n    }\r\n\r\n\r\n    struct Stakee {\r\n        uint256 amount_;\r\n    }\r\n\r\n    mapping(address => Stakee) internal stakees_;\r\n\r\n    function heft(address stakee) external view returns (uint256) {\r\n        return stakees_[stakee].amount_;\r\n    }\r\n\r\n\r\n    struct Primary {\r\n        bytes32 value_;\r\n    }\r\n\r\n    function name(address staker, address stakee) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(staker, stakee));\r\n    }\r\n\r\n    function name(Primary storage primary) private view returns (bytes32) {\r\n        return primary.value_;\r\n    }\r\n\r\n    function copy(Primary storage primary, address staker, address stakee) private {\r\n        primary.value_ = name(staker, stakee);\r\n    }\r\n\r\n    function copy(Primary storage primary, Primary storage other) private {\r\n        primary.value_ = other.value_;\r\n    }\r\n\r\n    function kill(Primary storage primary) private {\r\n        primary.value_ = bytes32(0);\r\n    }\r\n\r\n    function nope(Primary storage primary) private view returns (bool) {\r\n        return primary.value_ == bytes32(0);\r\n    }\r\n\r\n\r\n    struct Stake {\r\n        uint256 before_;\r\n        uint256 after_;\r\n\r\n        uint256 amount_;\r\n        uint128 delay_;\r\n\r\n        address stakee_;\r\n\r\n        bytes32 parent_;\r\n        Primary left_;\r\n        Primary right_;\r\n    }\r\n\r\n    mapping(bytes32 => Stake) internal stakes_;\r\n\r\n    Primary private root_;\r\n\r\n\r\n    function have() public view returns (uint256) {\r\n        if (nope(root_))\r\n            return 0;\r\n        Stake storage stake = stakes_[name(root_)];\r\n        return stake.before_ + stake.after_ + stake.amount_;\r\n    }\r\n\r\n    function seek(uint256 point) public view returns (address, uint128) {\r\n        require(!nope(root_));\r\n\r\n        Primary storage primary = root_;\r\n        for (;;) {\r\n            bytes32 key = name(primary);\r\n            Stake storage stake = stakes_[key];\r\n\r\n            if (point < stake.before_) {\r\n                primary = stake.left_;\r\n                continue;\r\n            }\r\n\r\n            point -= stake.before_;\r\n\r\n            if (point < stake.amount_)\r\n                return (stake.stakee_, stake.delay_);\r\n\r\n            point -= stake.amount_;\r\n\r\n            primary = stake.right_;\r\n        }\r\n    }\r\n\r\n    function pick(uint128 percent) external view returns (address, uint128) {\r\n        // for OXT, have() will be less than a uint128, so this math cannot overflow\r\n        return seek(have() * percent >> 128);\r\n    }\r\n\r\n\r\n    function turn(bytes32 key, Stake storage stake) private view returns (Primary storage) {\r\n        if (stake.parent_ == bytes32(0))\r\n            return root_;\r\n        Stake storage parent = stakes_[stake.parent_];\r\n        return name(parent.left_) == key ? parent.left_ : parent.right_;\r\n    }\r\n\r\n\r\n    function step(bytes32 key, Stake storage stake, uint256 amount, bytes32 root) private {\r\n        while (stake.parent_ != root) {\r\n            bytes32 parent = stake.parent_;\r\n            stake = stakes_[parent];\r\n            if (name(stake.left_) == key)\r\n                stake.before_ += amount;\r\n            else\r\n                stake.after_ += amount;\r\n            key = parent;\r\n        }\r\n    }\r\n\r\n    event Update(address indexed stakee, address indexed staker, uint256 local, uint256 global);\r\n\r\n    function lift(bytes32 key, Stake storage stake, uint256 amount, address staker, address stakee) private {\r\n        uint256 local = stake.amount_;\r\n        local += amount;\r\n        stake.amount_ = local;\r\n\r\n        uint256 global = stakees_[stakee].amount_;\r\n        global += amount;\r\n        stakees_[stakee].amount_ = global;\r\n\r\n        emit Update(stakee, staker, local, global);\r\n        step(key, stake, amount, bytes32(0));\r\n    }\r\n\r\n\r\n    event Delay(address indexed stakee, address indexed staker, uint128 delay);\r\n\r\n    function wait(Stake storage stake, uint128 delay, address staker, address stakee) private {\r\n        if (stake.delay_ != delay) {\r\n            require(stake.delay_ < delay);\r\n            stake.delay_ = delay;\r\n            emit Delay(stakee, staker, delay);\r\n        }\r\n    }\r\n\r\n    function more(address stakee, uint256 amount, uint128 delay) private {\r\n        address staker = msg.sender;\r\n        bytes32 key = name(staker, stakee);\r\n        Stake storage stake = stakes_[key];\r\n\r\n        if (stake.amount_ == 0) {\r\n            require(amount != 0);\r\n\r\n            bytes32 parent = bytes32(0);\r\n            Primary storage primary = root_;\r\n\r\n            while (!nope(primary)) {\r\n                parent = name(primary);\r\n                Stake storage current = stakes_[parent];\r\n                primary = current.before_ < current.after_ ? current.left_ : current.right_;\r\n            }\r\n\r\n            stake.parent_ = parent;\r\n            copy(primary, staker, stakee);\r\n\r\n            stake.stakee_ = stakee;\r\n        }\r\n\r\n        wait(stake, delay, staker, stakee);\r\n        lift(key, stake, amount, staker, stakee);\r\n    }\r\n\r\n    function push(address stakee, uint256 amount, uint128 delay) external {\r\n        more(stakee, amount, delay);\r\n        require(token_.transferFrom(msg.sender, address(this), amount));\r\n    }\r\n\r\n    function wait(address stakee, uint128 delay) external {\r\n        address staker = msg.sender;\r\n        bytes32 key = name(staker, stakee);\r\n        Stake storage stake = stakes_[key];\r\n        require(stake.amount_ != 0);\r\n        wait(stake, delay, staker, stakee);\r\n    }\r\n\r\n\r\n    struct Pending {\r\n        uint256 expire_;\r\n        address stakee_;\r\n        uint256 amount_;\r\n    }\r\n\r\n    mapping(address => mapping(uint256 => Pending)) private pendings_;\r\n\r\n    function pend(uint256 index, uint256 amount, uint128 delay) private returns (address) {\r\n        Pending storage pending = pendings_[msg.sender][index];\r\n        require(pending.expire_ <= block.timestamp + delay);\r\n        address stakee = pending.stakee_;\r\n\r\n        if (pending.amount_ == amount)\r\n            delete pendings_[msg.sender][index];\r\n        else {\r\n            require(pending.amount_ > amount);\r\n            pending.amount_ -= amount;\r\n        }\r\n\r\n        return stakee;\r\n    }\r\n\r\n    function take(uint256 index, uint256 amount, address payable target) external {\r\n        pend(index, amount, 0);\r\n        require(token_.transfer(target, amount));\r\n    }\r\n\r\n    function stop(uint256 index, uint256 amount, uint128 delay) external {\r\n        more(pend(index, amount, delay), amount, delay);\r\n    }\r\n\r\n\r\n    function fixr(Stake storage stake, bytes32 location, Stake storage current) private {\r\n        if (nope(stake.right_))\r\n            return;\r\n        stakes_[name(stake.right_)].parent_ = location;\r\n        copy(current.right_, stake.right_);\r\n        current.after_ = stake.after_;\r\n    }\r\n\r\n    function fixl(Stake storage stake, bytes32 location, Stake storage current) private {\r\n        if (nope(stake.left_))\r\n            return;\r\n        stakes_[name(stake.left_)].parent_ = location;\r\n        copy(current.left_, stake.left_);\r\n        current.before_ = stake.before_;\r\n    }\r\n\r\n    function pull(address stakee, uint256 amount, uint256 index) external {\r\n        address staker = msg.sender;\r\n        bytes32 key = name(staker, stakee);\r\n        Stake storage stake = stakes_[key];\r\n        uint128 delay = stake.delay_;\r\n\r\n        require(stake.amount_ != 0);\r\n        require(stake.amount_ >= amount);\r\n\r\n        lift(key, stake, -amount, staker, stakee);\r\n\r\n        if (stake.amount_ == 0) {\r\n            Primary storage pivot = turn(key, stake);\r\n            Primary storage child = stake.before_ > stake.after_ ? stake.left_ : stake.right_;\r\n\r\n            if (nope(child))\r\n                kill(pivot);\r\n            else {\r\n                Primary storage last = child;\r\n                bytes32 location = name(last);\r\n                Stake storage current = stakes_[location];\r\n                for (;;) {\r\n                    Primary storage next = current.before_ > current.after_ ? current.left_ : current.right_;\r\n                    if (nope(next))\r\n                        break;\r\n                    last = next;\r\n                    location = name(last);\r\n                    current = stakes_[location];\r\n                }\r\n\r\n                bytes32 direct = current.parent_;\r\n                copy(pivot, last);\r\n                current.parent_ = stake.parent_;\r\n\r\n                if (direct != key) {\r\n                    fixr(stake, location, current);\r\n                    fixl(stake, location, current);\r\n\r\n                    stake.parent_ = direct;\r\n                    copy(last, staker, stakee);\r\n                    step(key, stake, -current.amount_, current.parent_);\r\n                    kill(last);\r\n                } else if (name(stake.left_) == location) {\r\n                    fixr(stake, location, current);\r\n                } else {\r\n                    fixl(stake, location, current);\r\n                }\r\n            }\r\n\r\n            emit Delay(stakee, staker, 0);\r\n            delete stakes_[key];\r\n        }\r\n\r\n        Pending storage pending = pendings_[msg.sender][index];\r\n\r\n        uint256 expire = block.timestamp + delay;\r\n        if (pending.expire_ < expire)\r\n            pending.expire_ = expire;\r\n\r\n        if (pending.stakee_ == address(0))\r\n            pending.stakee_ = stakee;\r\n        else\r\n            require(pending.stakee_ == stakee);\r\n\r\n        pending.amount_ += amount;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakee\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"delay\",\"type\":\"uint128\"}],\"name\":\"Delay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakee\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"local\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"global\",\"type\":\"uint256\"}],\"name\":\"Update\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"have\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakee\",\"type\":\"address\"}],\"name\":\"heft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakee\",\"type\":\"address\"}],\"name\":\"name\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"percent\",\"type\":\"uint128\"}],\"name\":\"pick\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"pull\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"delay\",\"type\":\"uint128\"}],\"name\":\"push\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"point\",\"type\":\"uint256\"}],\"name\":\"seek\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"delay\",\"type\":\"uint128\"}],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"take\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakee\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"delay\",\"type\":\"uint128\"}],\"name\":\"wait\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"what\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OrchidDirectory", "CompilerVersion": "v0.5.13+commit.5b0b510c", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000004575f41308ec1483f3d399aa9a2826d74da13deb", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://f85a87801f9df089d4cd9fe0c36c44be616242965847021b990f74203975cc26"}