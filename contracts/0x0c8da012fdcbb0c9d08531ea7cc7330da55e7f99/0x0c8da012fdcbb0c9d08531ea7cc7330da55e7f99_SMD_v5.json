{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LockedFarming.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.9;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see `ERC20Detailed`.\\r\\n */\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(\\r\\n            newOwner != address(0),\\r\\n            \\\"Ownable: new owner is the zero address\\\"\\r\\n        );\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        require(token.transfer(to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        require(token.transferFrom(from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        require(token.approve(spender, value));\\r\\n    }\\r\\n}\\r\\n\\r\\npragma solidity 0.8.9;\\r\\n\\r\\ncontract SMD_v5 is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    uint256 public constant SECONDS_PER_HOUR = 3600; // 60 * 60\\r\\n\\r\\n    /// @notice LP token address to deposit to earn rewards.\\r\\n    address public tokenAddress;\\r\\n    /// @notice token address to in which rewards will be paid in.\\r\\n    address public rewardTokenAddress;\\r\\n    uint256 public stakedTotal;\\r\\n    uint256 public stakedBalance;\\r\\n    uint256 public rewardBalance;\\r\\n    uint256 public totalReward;\\r\\n\\r\\n    /// @dev expressed in UNIX timestamp. Will be compareed to block.timestamp.\\r\\n    uint256 public startingDate;\\r\\n    /// @dev expressed in UNIX timestamp. Will be compareed to block.timestamp.\\r\\n    uint256 public endingDate;\\r\\n    /**\\r\\n      * @notice periodCounter is used to keep track of the farming periods, which allow participants to\\r\\n      *         earn a certain amount of rewards by staking their LP for a certain period of time. Then, \\r\\n      *         a new period can be opened with a different or equal amount to earn.\\r\\n      * @dev counts the amount of farming periods.\\r\\n      */\\r\\n    uint256 public periodCounter;\\r\\n    /// @notice should be the last amount of rewards per wei of deposited LP token {tokenAddress}.\\r\\n    uint256 public accShare;\\r\\n    /// @notice timestamp of the last period start date, expressed in UNIX timestamp.\\r\\n    uint256 public lastPeriodStartedAt;\\r\\n    /**\\r\\n    * @notice amount of participant in current period.\\r\\n    * @dev {resetAndsetStartEndBlock} will reset this value to 0.\\r\\n    */\\r\\n    uint256 public totalParticipants;\\r\\n    /// @dev expressed in hours, e.g. 7 days = 24 * 7 = 168.\\r\\n    uint256 public lockDuration;\\r\\n    bool public isPaused;\\r\\n\\r\\n    IERC20 public ERC20Interface;\\r\\n\\r\\n    struct Deposits {\\r\\n        uint256 amount;\\r\\n        uint256 initialStake;\\r\\n        uint256 latestClaim;\\r\\n        uint256 userAccShare;\\r\\n        uint256 currentPeriod;\\r\\n    }\\r\\n\\r\\n    struct PeriodDetails {\\r\\n        uint256 periodCounter;\\r\\n        uint256 accShare;\\r\\n        uint256 rewPerSecond;\\r\\n        uint256 startingDate;\\r\\n        uint256 endingDate;\\r\\n        uint256 rewards;\\r\\n    }\\r\\n\\r\\n    mapping(address => Deposits) private deposits;\\r\\n\\r\\n    mapping(address => bool) public isPaid;\\r\\n    mapping(address => bool) public hasStaked;\\r\\n    mapping(uint256 => PeriodDetails) public endAccShare;\\r\\n\\r\\n    event NewPeriodSet(\\r\\n        uint256 periodCounter,\\r\\n        uint256 startDate,\\r\\n        uint256 endDate,\\r\\n        uint256 lockDuration,\\r\\n        uint256 rewardAmount\\r\\n    );\\r\\n    event PeriodExtended(uint256 periodCounter, uint256 endDate, uint256 rewards);\\r\\n    event Staked(\\r\\n        address indexed token,\\r\\n        address indexed staker_,\\r\\n        uint256 stakedAmount_\\r\\n    );\\r\\n    event PaidOut(\\r\\n        address indexed token,\\r\\n        address indexed rewardToken,\\r\\n        address indexed staker_,\\r\\n        uint256 amount_,\\r\\n        uint256 reward_\\r\\n    );\\r\\n\\r\\n    constructor(address _tokenAddress, address _rewardTokenAddress) Ownable() {\\r\\n        require(_tokenAddress != address(0), \\\"Zero token address\\\");\\r\\n        tokenAddress = _tokenAddress;\\r\\n        require(_rewardTokenAddress != address(0), \\\"Zero reward token address\\\");\\r\\n        rewardTokenAddress = _rewardTokenAddress;\\r\\n        isPaused = true;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        -   To set the start and end blocks for each periodCounter\\r\\n    */\\r\\n\\r\\n    function setStartEnd(uint256 _start, uint256 _end) private {\\r\\n        require(totalReward > 0, \\\"Add rewards for this periodCounter\\\");\\r\\n        startingDate = _start;\\r\\n        endingDate = _end;\\r\\n        periodCounter++;\\r\\n        isPaused = false;\\r\\n        lastPeriodStartedAt = _start;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add rewards to the contract, without transfering them to the contract. They stay in \\r\\n     *         `msg.sender` wallet, so be sure `msg.sender` has approved the this contract to transfer\\r\\n     *         the `_rewardAmount` of `rewardTokenAddress`.\\r\\n     */\\r\\n    function addReward(uint256 _rewardAmount)\\r\\n        private\\r\\n        _hasAllowance(msg.sender, _rewardAmount, rewardTokenAddress)\\r\\n        returns (bool)\\r\\n    {\\r\\n        totalReward = totalReward.add(_rewardAmount);\\r\\n        rewardBalance = rewardBalance.add(_rewardAmount);\\r\\n        if (!_payMe(msg.sender, _rewardAmount, rewardTokenAddress)) {\\r\\n            return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        -   To reset the contract at the end of each periodCounter.\\r\\n    */\\r\\n\\r\\n    function reset() private {\\r\\n        require(block.timestamp > endingDate, \\\"Wait till end of this period\\\");\\r\\n        updateShare();\\r\\n        endAccShare[periodCounter] = PeriodDetails(\\r\\n            periodCounter,\\r\\n            accShare,\\r\\n            rewPerSecond(),\\r\\n            startingDate,\\r\\n            endingDate,\\r\\n            rewardBalance\\r\\n        );\\r\\n        totalReward = 0;\\r\\n        stakedBalance = 0;\\r\\n        isPaused = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Function to set the start and end blocks for each new period and add rewards to be \\r\\n     *         earned within this period. Previous period must have ended, otherwise use \\r\\n     *         {extendCurrentPeriod} to update current period.\\r\\n     * @dev Easier to pass seconds to wait until start and end of period, instead of passing the start and\\r\\n     *      end timestamp. \\r\\n     *\\r\\n     * @param _rewardAmount Amount of rewards to be earned within this period.\\r\\n     * @param _start Seconds at which the period starts - in UNIX timestamp.\\r\\n     * @param _end Seconds at which the period ends - in UNIX timestamp.\\r\\n     * @param _lockDuration Duration in hours to wait before being able to withdraw.\\r\\n     */\\r\\n    function resetAndsetStartEndBlock(\\r\\n        uint256 _rewardAmount,\\r\\n        uint256 _start,\\r\\n        uint256 _end,\\r\\n        uint256 _lockDuration\\r\\n    ) external onlyOwner returns (bool) {\\r\\n        require(\\r\\n            _start > block.timestamp,\\r\\n            \\\"Start should be more than block.timestamp\\\"\\r\\n        );\\r\\n        require(_end > _start, \\\"End block should be greater than start\\\");\\r\\n        require(_rewardAmount > 0, \\\"Reward must be positive\\\");\\r\\n        reset();\\r\\n        bool rewardAdded = addReward(_rewardAmount);\\r\\n        require(rewardAdded, \\\"Rewards error\\\");\\r\\n        setStartEnd(_start, _end);\\r\\n        lockDuration = _lockDuration;\\r\\n        totalParticipants = 0;\\r\\n        emit NewPeriodSet(periodCounter, _start, _end, _lockDuration, _rewardAmount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        -   Function to update rewards and state parameters\\r\\n    */\\r\\n\\r\\n    function updateShare() private {\\r\\n        if (block.timestamp <= lastPeriodStartedAt) {\\r\\n            return;\\r\\n        }\\r\\n        if (stakedBalance == 0) {\\r\\n            lastPeriodStartedAt = block.timestamp;\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 secSinceLastPeriod;\\r\\n\\r\\n        if (block.timestamp >= endingDate) {\\r\\n            secSinceLastPeriod = endingDate.sub(lastPeriodStartedAt);\\r\\n        } else {\\r\\n            secSinceLastPeriod = block.timestamp.sub(lastPeriodStartedAt);\\r\\n        }\\r\\n\\r\\n        uint256 rewards = secSinceLastPeriod.mul(rewPerSecond());\\r\\n\\r\\n        accShare = accShare.add((rewards.mul(1e6).div(stakedBalance)));\\r\\n        if (block.timestamp >= endingDate) {\\r\\n            lastPeriodStartedAt = endingDate;\\r\\n        } else {\\r\\n            lastPeriodStartedAt = block.timestamp;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function rewPerSecond() public view returns (uint256) {\\r\\n        if (totalReward == 0 || rewardBalance == 0) return 0;\\r\\n        uint256 rewardPerSecond = totalReward.div(\\r\\n            (endingDate.sub(startingDate))\\r\\n        );\\r\\n        return (rewardPerSecond);\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount)\\r\\n        external\\r\\n        _hasAllowance(msg.sender, amount, tokenAddress)\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(!isPaused, \\\"Contract is paused\\\");\\r\\n        require(\\r\\n            block.timestamp >= startingDate && block.timestamp < endingDate,\\r\\n            \\\"No active pool (time)\\\"\\r\\n        );\\r\\n        require(amount > 0, \\\"Can't stake 0 amount\\\");\\r\\n        return (_stake(msg.sender, amount));\\r\\n    }\\r\\n\\r\\n    function _stake(address from, uint256 amount) private returns (bool) {\\r\\n        updateShare();\\r\\n\\r\\n        if (!hasStaked[from]) {\\r\\n            deposits[from] = Deposits(\\r\\n                amount,\\r\\n                block.timestamp,\\r\\n                block.timestamp,\\r\\n                accShare,\\r\\n                periodCounter\\r\\n            );\\r\\n            totalParticipants = totalParticipants.add(1);\\r\\n            hasStaked[from] = true;\\r\\n        } else {\\r\\n            if (deposits[from].currentPeriod != periodCounter) {\\r\\n                bool renew_ = _renew(from);\\r\\n                require(renew_, \\\"Error renewing\\\");\\r\\n            } else {\\r\\n                bool claim = _claimRewards(from);\\r\\n                require(claim, \\\"Error paying rewards\\\");\\r\\n            }\\r\\n\\r\\n            uint256 userAmount = deposits[from].amount;\\r\\n\\r\\n            deposits[from] = Deposits(\\r\\n                userAmount.add(amount),\\r\\n                block.timestamp,\\r\\n                block.timestamp,\\r\\n                accShare,\\r\\n                periodCounter\\r\\n            );\\r\\n        }\\r\\n        stakedBalance = stakedBalance.add(amount);\\r\\n        stakedTotal = stakedTotal.add(amount);\\r\\n        if (!_payMe(from, amount, tokenAddress)) {\\r\\n            return false;\\r\\n        }\\r\\n        emit Staked(tokenAddress, from, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function userDeposits(address from)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        if (hasStaked[from]) {\\r\\n            return (\\r\\n                deposits[from].amount,\\r\\n                deposits[from].initialStake,\\r\\n                deposits[from].latestClaim,\\r\\n                deposits[from].currentPeriod\\r\\n            );\\r\\n        } else {\\r\\n            return (0, 0, 0, 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function fetchUserShare(address from) public view returns (uint256) {\\r\\n        require(hasStaked[from], \\\"No stakes found for user\\\");\\r\\n        if (stakedBalance == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        require(\\r\\n            deposits[from].currentPeriod == periodCounter,\\r\\n            \\\"Please renew in the active valid periodCounter\\\"\\r\\n        );\\r\\n        uint256 userAmount = deposits[from].amount;\\r\\n        require(userAmount > 0, \\\"No stakes available for user\\\"); //extra check\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    function claimRewards() public returns (bool) {\\r\\n        require(fetchUserShare(msg.sender) > 0, \\\"No stakes found for user\\\");\\r\\n        return (_claimRewards(msg.sender));\\r\\n    }\\r\\n\\r\\n    function _claimRewards(address from) private returns (bool) {\\r\\n        uint256 userAccShare = deposits[from].userAccShare;\\r\\n        updateShare();\\r\\n        uint256 amount = deposits[from].amount;\\r\\n        uint256 rewDebt = amount.mul(userAccShare).div(1e6);\\r\\n        uint256 rew = (amount.mul(accShare).div(1e6)).sub(rewDebt);\\r\\n        require(rew > 0, \\\"No rewards generated\\\");\\r\\n        require(rew <= rewardBalance, \\\"Not enough rewards in the contract\\\");\\r\\n        deposits[from].userAccShare = accShare;\\r\\n        deposits[from].latestClaim = block.timestamp;\\r\\n        rewardBalance = rewardBalance.sub(rew);\\r\\n        bool payRewards = _payDirect(from, rew, rewardTokenAddress);\\r\\n        require(payRewards, \\\"Rewards transfer failed\\\");\\r\\n        emit PaidOut(tokenAddress, rewardTokenAddress, from, amount, rew);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Should take into account staking rewards from previous periods into the current new period.\\r\\n    function renew() public returns (bool) {\\r\\n        require(!isPaused, \\\"Contract paused\\\");\\r\\n        require(hasStaked[msg.sender], \\\"No stakings found, please stake\\\");\\r\\n        require(\\r\\n            deposits[msg.sender].currentPeriod != periodCounter,\\r\\n            \\\"Already renewed\\\"\\r\\n        );\\r\\n        require(\\r\\n            block.timestamp > startingDate && block.timestamp < endingDate,\\r\\n            \\\"Wrong time\\\"\\r\\n        );\\r\\n        return (_renew(msg.sender));\\r\\n    }\\r\\n\\r\\n    function _renew(address from) private returns (bool) {\\r\\n        updateShare();\\r\\n        if (viewOldRewards(from) > 0) {\\r\\n            bool claimed = claimOldRewards();\\r\\n            require(claimed, \\\"Error paying old rewards\\\");\\r\\n        }\\r\\n        deposits[from].currentPeriod = periodCounter;\\r\\n        deposits[from].initialStake = block.timestamp;\\r\\n        deposits[from].latestClaim = block.timestamp;\\r\\n        deposits[from].userAccShare = accShare;\\r\\n        stakedBalance = stakedBalance.add(deposits[from].amount);\\r\\n        totalParticipants = totalParticipants.add(1);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function viewOldRewards(address from) public view returns (uint256) {\\r\\n        require(!isPaused, \\\"Contract paused\\\");\\r\\n        require(hasStaked[from], \\\"No stakings found, please stake\\\");\\r\\n\\r\\n        if (deposits[from].currentPeriod == periodCounter) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 userPeriod = deposits[from].currentPeriod;\\r\\n\\r\\n        uint256 accShare1 = endAccShare[userPeriod].accShare;\\r\\n        uint256 userAccShare = deposits[from].userAccShare;\\r\\n\\r\\n        if (deposits[from].latestClaim >= endAccShare[userPeriod].endingDate)\\r\\n            return 0;\\r\\n        uint256 amount = deposits[from].amount;\\r\\n        uint256 rewDebt = amount.mul(userAccShare).div(1e6);\\r\\n        uint256 rew = (amount.mul(accShare1).div(1e6)).sub(rewDebt);\\r\\n\\r\\n        require(rew <= rewardBalance, \\\"Not enough rewards\\\");\\r\\n\\r\\n        return (rew);\\r\\n    }\\r\\n\\r\\n    /// @notice Should claim rewards from previous periods.\\r\\n    function claimOldRewards() public returns (bool) {\\r\\n        require(!isPaused, \\\"Contract paused\\\");\\r\\n        require(hasStaked[msg.sender], \\\"No stakings found, please stake\\\");\\r\\n        require(\\r\\n            deposits[msg.sender].currentPeriod != periodCounter,\\r\\n            \\\"Already renewed\\\"\\r\\n        );\\r\\n\\r\\n        uint256 userPeriod = deposits[msg.sender].currentPeriod;\\r\\n\\r\\n        uint256 accShare1 = endAccShare[userPeriod].accShare;\\r\\n        uint256 userAccShare = deposits[msg.sender].userAccShare;\\r\\n\\r\\n        require(\\r\\n            deposits[msg.sender].latestClaim <\\r\\n                endAccShare[userPeriod].endingDate,\\r\\n            \\\"Already claimed old rewards\\\"\\r\\n        );\\r\\n        uint256 amount = deposits[msg.sender].amount;\\r\\n        uint256 rewDebt = amount.mul(userAccShare).div(1e6);\\r\\n        uint256 rew = (amount.mul(accShare1).div(1e6)).sub(rewDebt);\\r\\n\\r\\n        require(rew <= rewardBalance, \\\"Not enough rewards\\\");\\r\\n        deposits[msg.sender].latestClaim = endAccShare[userPeriod].endingDate;\\r\\n        rewardBalance = rewardBalance.sub(rew);\\r\\n        bool paidOldRewards = _payDirect(msg.sender, rew, rewardTokenAddress);\\r\\n        require(paidOldRewards, \\\"Error paying\\\");\\r\\n        emit PaidOut(tokenAddress, rewardTokenAddress, msg.sender, amount, rew);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function calculate(address from) public view returns (uint256) {\\r\\n        if (fetchUserShare(from) == 0) return 0;\\r\\n        return (_calculate(from));\\r\\n    }\\r\\n\\r\\n    function _calculate(address from) private view returns (uint256) {\\r\\n        uint256 userAccShare = deposits[from].userAccShare;\\r\\n        uint256 currentAccShare = accShare;\\r\\n        //Simulating updateShare() to calculate rewards\\r\\n        if (block.timestamp <= lastPeriodStartedAt) {\\r\\n            return 0;\\r\\n        }\\r\\n        if (stakedBalance == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 secSinceLastPeriod;\\r\\n\\r\\n        if (block.timestamp >= endingDate) {\\r\\n            secSinceLastPeriod = endingDate.sub(lastPeriodStartedAt);\\r\\n        } else {\\r\\n            secSinceLastPeriod = block.timestamp.sub(lastPeriodStartedAt);\\r\\n        }\\r\\n\\r\\n        uint256 rewards = secSinceLastPeriod.mul(rewPerSecond());\\r\\n\\r\\n        uint256 newAccShare = currentAccShare.add(\\r\\n            (rewards.mul(1e6).div(stakedBalance))\\r\\n        );\\r\\n        uint256 amount = deposits[from].amount;\\r\\n        uint256 rewDebt = amount.mul(userAccShare).div(1e6);\\r\\n        uint256 rew = (amount.mul(newAccShare).div(1e6)).sub(rewDebt);\\r\\n        return (rew);\\r\\n    }\\r\\n\\r\\n    function emergencyWithdraw() external returns (bool) {\\r\\n        require(\\r\\n            block.timestamp >\\r\\n                deposits[msg.sender].initialStake.add(\\r\\n                    lockDuration.mul(SECONDS_PER_HOUR)\\r\\n                ),\\r\\n            \\\"Can't withdraw before lock duration\\\"\\r\\n        );\\r\\n        require(hasStaked[msg.sender], \\\"No stakes available for user\\\");\\r\\n        require(!isPaid[msg.sender], \\\"Already Paid\\\");\\r\\n        return (_withdraw(msg.sender, deposits[msg.sender].amount));\\r\\n    }\\r\\n\\r\\n    function _withdraw(address from, uint256 amount) private returns (bool) {\\r\\n        updateShare();\\r\\n        deposits[from].amount = deposits[from].amount.sub(amount);\\r\\n        if (!isPaused && deposits[from].currentPeriod == periodCounter) {\\r\\n            stakedBalance = stakedBalance.sub(amount);\\r\\n        }\\r\\n        bool paid = _payDirect(from, amount, tokenAddress);\\r\\n        require(paid, \\\"Error during withdraw\\\");\\r\\n        if (deposits[from].amount == 0) {\\r\\n            isPaid[from] = true;\\r\\n            hasStaked[from] = false;\\r\\n            if (deposits[from].currentPeriod == periodCounter) {\\r\\n                totalParticipants = totalParticipants.sub(1);\\r\\n            }\\r\\n            delete deposits[from];\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) external returns (bool) {\\r\\n        require(\\r\\n            block.timestamp >\\r\\n                deposits[msg.sender].initialStake.add(\\r\\n                    lockDuration.mul(SECONDS_PER_HOUR)\\r\\n                ),\\r\\n            \\\"Can't withdraw before lock duration\\\"\\r\\n        );\\r\\n        require(amount <= deposits[msg.sender].amount, \\\"Wrong value\\\");\\r\\n        if (deposits[msg.sender].currentPeriod == periodCounter) {\\r\\n            if (calculate(msg.sender) > 0) {\\r\\n                bool rewardsPaid = claimRewards();\\r\\n                require(rewardsPaid, \\\"Error paying rewards\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (viewOldRewards(msg.sender) > 0) {\\r\\n            bool oldRewardsPaid = claimOldRewards();\\r\\n            require(oldRewardsPaid, \\\"Error paying old rewards\\\");\\r\\n        }\\r\\n        return (_withdraw(msg.sender, amount));\\r\\n    }\\r\\n\\r\\n    function extendCurrentPeriod(uint256 rewardsToBeAdded)\\r\\n        external\\r\\n        onlyOwner\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(\\r\\n            block.timestamp > startingDate && block.timestamp < endingDate,\\r\\n            \\\"No active pool (time)\\\"\\r\\n        );\\r\\n        require(rewardsToBeAdded > 0, \\\"Zero rewards\\\");\\r\\n        bool addedRewards = _payMe(\\r\\n            msg.sender,\\r\\n            rewardsToBeAdded,\\r\\n            rewardTokenAddress\\r\\n        );\\r\\n        require(addedRewards, \\\"Error adding rewards\\\");\\r\\n        endingDate = endingDate.add(rewardsToBeAdded.div(rewPerSecond()));\\r\\n        totalReward = totalReward.add(rewardsToBeAdded);\\r\\n        rewardBalance = rewardBalance.add(rewardsToBeAdded);\\r\\n        emit PeriodExtended(periodCounter, endingDate, rewardsToBeAdded);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _payMe(\\r\\n        address payer,\\r\\n        uint256 amount,\\r\\n        address token\\r\\n    ) private returns (bool) {\\r\\n        return _payTo(payer, address(this), amount, token);\\r\\n    }\\r\\n\\r\\n    function _payTo(\\r\\n        address allower,\\r\\n        address receiver,\\r\\n        uint256 amount,\\r\\n        address token\\r\\n    ) private returns (bool) {\\r\\n        // Request to transfer amount from the contract to receiver.\\r\\n        // contract does not own the funds, so the allower must have added allowance to the contract\\r\\n        // Allower is the original owner.\\r\\n        ERC20Interface = IERC20(token);\\r\\n        ERC20Interface.safeTransferFrom(allower, receiver, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _payDirect(\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        address token\\r\\n    ) private returns (bool) {\\r\\n        require(\\r\\n            token == tokenAddress || token == rewardTokenAddress,\\r\\n            \\\"Invalid token address\\\"\\r\\n        );\\r\\n        ERC20Interface = IERC20(token);\\r\\n        ERC20Interface.safeTransfer(to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    modifier _hasAllowance(\\r\\n        address allower,\\r\\n        uint256 amount,\\r\\n        address token\\r\\n    ) {\\r\\n        // Make sure the allower has provided the right allowance.\\r\\n        require(\\r\\n            token == tokenAddress || token == rewardTokenAddress,\\r\\n            \\\"Invalid token address\\\"\\r\\n        );\\r\\n        ERC20Interface = IERC20(token);\\r\\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\\r\\n        require(amount <= ourAllowance, \\\"Make sure to add enough allowance\\\");\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardTokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periodCounter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"NewPeriodSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward_\",\"type\":\"uint256\"}],\"name\":\"PaidOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"periodCounter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"name\":\"PeriodExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount_\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ERC20Interface\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_HOUR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"calculate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOldRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"endAccShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"periodCounter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endingDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsToBeAdded\",\"type\":\"uint256\"}],\"name\":\"extendCurrentPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"fetchUserShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPaid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPeriodStartedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renew\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDuration\",\"type\":\"uint256\"}],\"name\":\"resetAndsetStartEndBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalParticipants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"userDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"viewOldRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SMD_v5", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "000000000000000000000000619391ba76b316fc56bc50388b90d9c8f24fcfe7000000000000000000000000126e4dcd47c00054f367345202de31db570fe2a7", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}