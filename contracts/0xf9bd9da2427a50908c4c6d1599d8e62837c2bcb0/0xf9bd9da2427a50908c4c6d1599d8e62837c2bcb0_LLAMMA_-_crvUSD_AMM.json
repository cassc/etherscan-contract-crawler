{"SourceCode": "# @version 0.3.9\r\n\"\"\"\r\n@title LLAMMA - crvUSD AMM\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n\"\"\"\r\n\r\n# Glossary of variables and terms\r\n# =======================\r\n# * ticks, bands - price ranges where liquidity is deposited\r\n# * x - coin which is being borrowed, typically stablecoin\r\n# * y - collateral coin (for example, wETH)\r\n# * A - amplification, the measure of how concentrated the tick is\r\n# * rate - interest rate\r\n# * rate_mul - rate multiplier, 1 + integral(rate * dt)\r\n# * active_band - current band. Other bands are either in one or other coin, but not both\r\n# * min_band - bands below this are definitely empty\r\n# * max_band - bands above this are definitely empty\r\n# * bands_x[n], bands_y[n] - amounts of coin x or y deposited in band n\r\n# * user_shares[user,n] / total_shares[n] - fraction of n'th band owned by a user\r\n# * p_oracle - external oracle price (can be from another AMM)\r\n# * p (as in get_p) - current price of AMM. It depends not only on the balances (x,y) in the band and active_band, but\r\n# also on p_oracle\r\n# * p_current_up, p_current_down - the value of p at constant p_oracle when y=0 or x=0 respectively for the band n\r\n# * p_oracle_up, p_oracle_down - edges of the band when p=p_oracle (steady state), happen when x=0 or y=0 respectively,\r\n# for band n.\r\n# * Grid of bands is set for p_oracle values such as:\r\n#   * p_oracle_up(n) = base_price * ((A - 1) / A)**n\r\n#   * p_oracle_down(n) = p_oracle_up(n) * (A - 1) / A = p_oracle_up(n+1)\r\n# * p_current_up and p_oracle_up change in opposite directions with n\r\n# * When intereste is accrued - all the grid moves by change of base_price\r\n#\r\n# Bonding curve reads as:\r\n# (f + x) * (g + y) = Inv = p_oracle * A**2 * y0**2\r\n# =======================\r\n\r\ninterface ERC20:\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n    def approve(_spender: address, _value: uint256) -> bool: nonpayable\r\n\r\ninterface PriceOracle:\r\n    def price() -> uint256: view\r\n    def price_w() -> uint256: nonpayable\r\n\r\ninterface LMGauge:\r\n    def callback_collateral_shares(n: int256, collateral_per_share: DynArray[uint256, MAX_TICKS_UINT]): nonpayable\r\n    def callback_user_shares(user: address, n: int256, user_shares: DynArray[uint256, MAX_TICKS_UINT]): nonpayable\r\n\r\n\r\nevent TokenExchange:\r\n    buyer: indexed(address)\r\n    sold_id: uint256\r\n    tokens_sold: uint256\r\n    bought_id: uint256\r\n    tokens_bought: uint256\r\n\r\nevent Deposit:\r\n    provider: indexed(address)\r\n    amount: uint256\r\n    n1: int256\r\n    n2: int256\r\n\r\nevent Withdraw:\r\n    provider: indexed(address)\r\n    amount_borrowed: uint256\r\n    amount_collateral: uint256\r\n\r\nevent SetRate:\r\n    rate: uint256\r\n    rate_mul: uint256\r\n    time: uint256\r\n\r\nevent SetFee:\r\n    fee: uint256\r\n\r\nevent SetAdminFee:\r\n    fee: uint256\r\n\r\n\r\nMAX_TICKS: constant(int256) = 50\r\nMAX_TICKS_UINT: constant(uint256) = 50\r\nMAX_SKIP_TICKS: constant(int256) = 1024\r\n\r\n\r\nstruct UserTicks:\r\n    ns: int256  # packs n1 and n2, each is int128\r\n    ticks: uint256[MAX_TICKS/2]  # Share fractions packed 2 per slot\r\n\r\nstruct DetailedTrade:\r\n    in_amount: uint256\r\n    out_amount: uint256\r\n    n1: int256\r\n    n2: int256\r\n    ticks_in: DynArray[uint256, MAX_TICKS_UINT]\r\n    last_tick_j: uint256\r\n    admin_fee: uint256\r\n\r\n\r\nBORROWED_TOKEN: immutable(ERC20)    # x\r\nBORROWED_PRECISION: immutable(uint256)\r\nCOLLATERAL_TOKEN: immutable(ERC20)  # y\r\nCOLLATERAL_PRECISION: immutable(uint256)\r\nBASE_PRICE: immutable(uint256)\r\nadmin: public(address)\r\n\r\nA: public(immutable(uint256))\r\nAminus1: immutable(uint256)\r\nA2: immutable(uint256)\r\nAminus12: immutable(uint256)\r\nSQRT_BAND_RATIO: immutable(uint256)  # sqrt(A / (A - 1))\r\nLOG_A_RATIO: immutable(int256)  # ln(A / (A - 1))\r\nMAX_ORACLE_DN_POW: immutable(uint256)  # (A / (A - 1)) ** 50\r\n\r\nfee: public(uint256)\r\nadmin_fee: public(uint256)\r\nrate: public(uint256)\r\nrate_time: uint256\r\nrate_mul: uint256\r\nactive_band: public(int256)\r\nmin_band: public(int256)\r\nmax_band: public(int256)\r\n\r\nadmin_fees_x: public(uint256)\r\nadmin_fees_y: public(uint256)\r\n\r\nprice_oracle_contract: public(immutable(PriceOracle))\r\nold_p_o: uint256\r\nold_dfee: uint256\r\nprev_p_o_time: uint256\r\nPREV_P_O_DELAY: constant(uint256) = 2 * 60  # s = 2 min\r\nMAX_P_O_CHG: constant(uint256) = 12500 * 10**14  # <= 2**(1/3) - max relative change to have fee < 50%\r\n\r\nbands_x: public(HashMap[int256, uint256])\r\nbands_y: public(HashMap[int256, uint256])\r\n\r\ntotal_shares: HashMap[int256, uint256]\r\nuser_shares: HashMap[address, UserTicks]\r\nDEAD_SHARES: constant(uint256) = 1000\r\n\r\nliquidity_mining_callback: public(LMGauge)\r\n\r\n\r\n@external\r\ndef __init__(\r\n        _borrowed_token: address,\r\n        _borrowed_precision: uint256,\r\n        _collateral_token: address,\r\n        _collateral_precision: uint256,\r\n        _A: uint256,\r\n        _sqrt_band_ratio: uint256,\r\n        _log_A_ratio: int256,\r\n        _base_price: uint256,\r\n        fee: uint256,\r\n        admin_fee: uint256,\r\n        _price_oracle_contract: address,\r\n    ):\r\n    \"\"\"\r\n    @notice LLAMMA constructor\r\n    @param _borrowed_token Token which is being borrowed\r\n    @param _collateral_token Token used as collateral\r\n    @param _collateral_precision Precision of collateral: we pass it because we want the blueprint to fit into bytecode\r\n    @param _A \"Amplification coefficient\" which also defines density of liquidity and band size. Relative band size is 1/_A\r\n    @param _sqrt_band_ratio Precomputed int(sqrt(A / (A - 1)) * 1e18)\r\n    @param _log_A_ratio Precomputed int(ln(A / (A - 1)) * 1e18)\r\n    @param _base_price Typically the initial crypto price at which AMM is deployed. Will correspond to band 0\r\n    @param fee Relative fee of the AMM: int(fee * 1e18)\r\n    @param admin_fee Admin fee: how much of fee goes to admin. 50% === int(0.5 * 1e18)\r\n    @param _price_oracle_contract External price oracle which has price() and price_w() methods\r\n           which both return current price of collateral multiplied by 1e18\r\n    \"\"\"\r\n    BORROWED_TOKEN = ERC20(_borrowed_token)\r\n    BORROWED_PRECISION = _borrowed_precision\r\n    COLLATERAL_TOKEN = ERC20(_collateral_token)\r\n    COLLATERAL_PRECISION = _collateral_precision\r\n    A = _A\r\n    BASE_PRICE = _base_price\r\n\r\n    Aminus1 = unsafe_sub(A, 1)\r\n    A2 = pow_mod256(A, 2)\r\n    Aminus12 = pow_mod256(unsafe_sub(A, 1), 2)\r\n\r\n    self.fee = fee\r\n    self.admin_fee = admin_fee\r\n    price_oracle_contract = PriceOracle(_price_oracle_contract)\r\n    self.prev_p_o_time = block.timestamp\r\n    self.old_p_o = price_oracle_contract.price()\r\n\r\n    self.rate_mul = 10**18\r\n\r\n    # sqrt(A / (A - 1)) - needs to be pre-calculated externally\r\n    SQRT_BAND_RATIO = _sqrt_band_ratio\r\n    # log(A / (A - 1)) - needs to be pre-calculated externally\r\n    LOG_A_RATIO = _log_A_ratio\r\n\r\n    # (A / (A - 1)) ** 50\r\n    MAX_ORACLE_DN_POW = unsafe_div(pow_mod256(unsafe_div(A**25 * 10**18, pow_mod256(Aminus1, 25)), 2), 10**18)\r\n\r\n\r\n@internal\r\ndef approve_max(token: ERC20, _admin: address):\r\n    \"\"\"\r\n    Approve max in a separate function because it uses less bytespace than\r\n    calling directly, and gas doesn't matter in set_admin\r\n    \"\"\"\r\n    assert token.approve(_admin, max_value(uint256), default_return_value=True)\r\n\r\n\r\n@external\r\ndef set_admin(_admin: address):\r\n    \"\"\"\r\n    @notice Set admin of the AMM. Typically it's a controller (unless it's tests)\r\n    @param _admin Admin address\r\n    \"\"\"\r\n    assert self.admin == empty(address)\r\n    self.admin = _admin\r\n    self.approve_max(BORROWED_TOKEN, _admin)\r\n    self.approve_max(COLLATERAL_TOKEN, _admin)\r\n\r\n\r\n@internal\r\n@pure\r\ndef sqrt_int(_x: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Wrapping isqrt builtin because otherwise it will be repeated every time instead of calling\r\n    @param _x Square root's input in \"normal\" units, e.g. sqrt_int(1) == 1\r\n    \"\"\"\r\n    return isqrt(_x)\r\n\r\n\r\n@external\r\n@pure\r\ndef coins(i: uint256) -> address:\r\n    return [BORROWED_TOKEN.address, COLLATERAL_TOKEN.address][i]\r\n\r\n\r\n@internal\r\n@view\r\ndef limit_p_o(p: uint256) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Limits oracle price to avoid losses at abrupt changes, as well as calculates a dynamic fee.\r\n        If we consider oracle_change such as:\r\n            ratio = p_new / p_old\r\n        (let's take for simplicity p_new < p_old, otherwise we compute p_old / p_new)\r\n        Then if the minimal AMM fee will be:\r\n            fee = (1 - ratio**3),\r\n        AMM will not have a loss associated with the price change.\r\n        However, over time fee should still go down (over PREV_P_O_DELAY), and also ratio should be limited\r\n        because we don't want the fee to become too large (say, 50%) which is achieved by limiting the instantaneous\r\n        change in oracle price.\r\n\r\n    @return (limited_price_oracle, dynamic_fee)\r\n    \"\"\"\r\n    p_new: uint256 = p\r\n    dt: uint256 = unsafe_sub(PREV_P_O_DELAY, min(PREV_P_O_DELAY, block.timestamp - self.prev_p_o_time))\r\n    ratio: uint256 = 0\r\n\r\n    # ratio = 1 - (p_o_min / p_o_max)**3\r\n\r\n    if dt > 0:\r\n        old_p_o: uint256 = self.old_p_o\r\n        old_ratio: uint256 = self.old_dfee\r\n        # ratio = p_o_min / p_o_max\r\n        if p > old_p_o:\r\n            ratio = unsafe_div(old_p_o * 10**18, p)\r\n            if ratio < 10**36 / MAX_P_O_CHG:\r\n                p_new = unsafe_div(old_p_o * MAX_P_O_CHG, 10**18)\r\n                ratio = 10**36 / MAX_P_O_CHG\r\n        else:\r\n            ratio = unsafe_div(p * 10**18, old_p_o)\r\n            if ratio < 10**36 / MAX_P_O_CHG:\r\n                p_new = unsafe_div(old_p_o * 10**18, MAX_P_O_CHG)\r\n                ratio = 10**36 / MAX_P_O_CHG\r\n\r\n        # ratio is guaranteed to be less than 1e18\r\n        # Also guaranteed to be limited, therefore can have all ops unsafe\r\n        ratio = unsafe_div(\r\n            unsafe_mul(\r\n                unsafe_sub(unsafe_add(10**18, old_ratio), unsafe_div(pow_mod256(ratio, 3), 10**36)),  # (f' + (1 - r**3))\r\n                dt),                                                                                  # * dt / T\r\n            PREV_P_O_DELAY)\r\n\r\n    return [p_new, ratio]\r\n\r\n\r\n@internal\r\n@view\r\ndef _price_oracle_ro() -> uint256[2]:\r\n    return self.limit_p_o(price_oracle_contract.price())\r\n\r\n\r\n@internal\r\ndef _price_oracle_w() -> uint256[2]:\r\n    p: uint256[2] = self.limit_p_o(price_oracle_contract.price_w())\r\n    self.prev_p_o_time = block.timestamp\r\n    self.old_p_o = p[0]\r\n    self.old_dfee = p[1]\r\n    return p\r\n\r\n\r\n@external\r\n@view\r\ndef price_oracle() -> uint256:\r\n    \"\"\"\r\n    @notice Value returned by the external price oracle contract\r\n    \"\"\"\r\n    return self._price_oracle_ro()[0]\r\n\r\n\r\n@external\r\n@view\r\ndef dynamic_fee() -> uint256:\r\n    \"\"\"\r\n    @notice Dynamic fee which accounts for price_oracle shifts\r\n    \"\"\"\r\n    return max(self.fee, self._price_oracle_ro()[1])\r\n\r\n\r\n@internal\r\n@view\r\ndef _rate_mul() -> uint256:\r\n    \"\"\"\r\n    @notice Rate multiplier which is 1.0 + integral(rate, dt)\r\n    @return Rate multiplier in units where 1.0 == 1e18\r\n    \"\"\"\r\n    return unsafe_div(self.rate_mul * (10**18 + self.rate * (block.timestamp - self.rate_time)), 10**18)\r\n\r\n\r\n@external\r\n@view\r\ndef get_rate_mul() -> uint256:\r\n    \"\"\"\r\n    @notice Rate multiplier which is 1.0 + integral(rate, dt)\r\n    @return Rate multiplier in units where 1.0 == 1e18\r\n    \"\"\"\r\n    return self._rate_mul()\r\n\r\n\r\n@internal\r\n@view\r\ndef _base_price() -> uint256:\r\n    \"\"\"\r\n    @notice Price which corresponds to band 0.\r\n            Base price grows with time to account for interest rate (which is 0 by default)\r\n    \"\"\"\r\n    return unsafe_div(BASE_PRICE * self._rate_mul(), 10**18)\r\n\r\n\r\n@external\r\n@view\r\ndef get_base_price() -> uint256:\r\n    \"\"\"\r\n    @notice Price which corresponds to band 0.\r\n            Base price grows with time to account for interest rate (which is 0 by default)\r\n    \"\"\"\r\n    return self._base_price()\r\n\r\n\r\n@internal\r\n@view\r\ndef _p_oracle_up(n: int256) -> uint256:\r\n    \"\"\"\r\n    @notice Upper oracle price for the band to have liquidity when p = p_oracle\r\n    @param n Band number (can be negative)\r\n    @return Price at 1e18 base\r\n    \"\"\"\r\n    # p_oracle_up(n) = p_base * ((A - 1) / A) ** n\r\n    # p_oracle_down(n) = p_base * ((A - 1) / A) ** (n + 1) = p_oracle_up(n+1)\r\n    # return unsafe_div(self._base_price() * self.exp_int(-n * LOG_A_RATIO), 10**18)\r\n\r\n    power: int256 = -n * LOG_A_RATIO\r\n\r\n    # ((A - 1) / A) ** n = exp(-n * A / (A - 1)) = exp(-n * LOG_A_RATIO)\r\n    ## Exp implementation based on solmate's\r\n    assert power > -42139678854452767551\r\n    assert power < 135305999368893231589\r\n\r\n    x: int256 = unsafe_div(unsafe_mul(power, 2**96), 10**18)\r\n\r\n    k: int256 = unsafe_div(\r\n        unsafe_add(\r\n            unsafe_div(unsafe_mul(x, 2**96), 54916777467707473351141471128),\r\n            2**95),\r\n        2**96)\r\n    x = unsafe_sub(x, unsafe_mul(k, 54916777467707473351141471128))\r\n\r\n    y: int256 = unsafe_add(x, 1346386616545796478920950773328)\r\n    y = unsafe_add(unsafe_div(unsafe_mul(y, x), 2**96), 57155421227552351082224309758442)\r\n    p: int256 = unsafe_sub(unsafe_add(y, x), 94201549194550492254356042504812)\r\n    p = unsafe_add(unsafe_div(unsafe_mul(p, y), 2**96), 28719021644029726153956944680412240)\r\n    p = unsafe_add(unsafe_mul(p, x), (4385272521454847904659076985693276 * 2**96))\r\n\r\n    q: int256 = x - 2855989394907223263936484059900\r\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 50020603652535783019961831881945)\r\n    q = unsafe_sub(unsafe_div(unsafe_mul(q, x), 2**96), 533845033583426703283633433725380)\r\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 3604857256930695427073651918091429)\r\n    q = unsafe_sub(unsafe_div(unsafe_mul(q, x), 2**96), 14423608567350463180887372962807573)\r\n    q = unsafe_add(unsafe_div(unsafe_mul(q, x), 2**96), 26449188498355588339934803723976023)\r\n\r\n    exp_result: uint256 = shift(\r\n        unsafe_mul(convert(unsafe_div(p, q), uint256), 3822833074963236453042738258902158003155416615667),\r\n        unsafe_sub(k, 195))\r\n    ## End exp\r\n    assert exp_result > 1000  # dev: limit precision of the multiplier\r\n    return unsafe_div(self._base_price() * exp_result, 10**18)\r\n\r\n\r\n@internal\r\n@view\r\ndef _p_current_band(n: int256) -> uint256:\r\n    \"\"\"\r\n    @notice Lowest possible price of the band at current oracle price\r\n    @param n Band number (can be negative)\r\n    @return Price at 1e18 base\r\n    \"\"\"\r\n    # k = (self.A - 1) / self.A  # equal to (p_down / p_up)\r\n    # p_base = self.p_base * k ** n = p_oracle_up(n)\r\n    p_base: uint256 = self._p_oracle_up(n)\r\n\r\n    # return self.p_oracle**3 / p_base**2\r\n    p_oracle: uint256 = self._price_oracle_ro()[0]\r\n    return unsafe_div(p_oracle**2 / p_base * p_oracle, p_base)\r\n\r\n\r\n@external\r\n@view\r\ndef p_current_up(n: int256) -> uint256:\r\n    \"\"\"\r\n    @notice Highest possible price of the band at current oracle price\r\n    @param n Band number (can be negative)\r\n    @return Price at 1e18 base\r\n    \"\"\"\r\n    return self._p_current_band(n + 1)\r\n\r\n\r\n@external\r\n@view\r\ndef p_current_down(n: int256) -> uint256:\r\n    \"\"\"\r\n    @notice Lowest possible price of the band at current oracle price\r\n    @param n Band number (can be negative)\r\n    @return Price at 1e18 base\r\n    \"\"\"\r\n    return self._p_current_band(n)\r\n\r\n\r\n@external\r\n@view\r\ndef p_oracle_up(n: int256) -> uint256:\r\n    \"\"\"\r\n    @notice Highest oracle price for the band to have liquidity when p = p_oracle\r\n    @param n Band number (can be negative)\r\n    @return Price at 1e18 base\r\n    \"\"\"\r\n    return self._p_oracle_up(n)\r\n\r\n\r\n@external\r\n@view\r\ndef p_oracle_down(n: int256) -> uint256:\r\n    \"\"\"\r\n    @notice Lowest oracle price for the band to have liquidity when p = p_oracle\r\n    @param n Band number (can be negative)\r\n    @return Price at 1e18 base\r\n    \"\"\"\r\n    return self._p_oracle_up(n + 1)\r\n\r\n\r\n@internal\r\n@view\r\ndef _get_y0(x: uint256, y: uint256, p_o: uint256, p_o_up: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate y0 for the invariant based on current liquidity in band.\r\n            The value of y0 has a meaning of amount of collateral when band has no stablecoin\r\n            but current price is equal to both oracle price and upper band price.\r\n    @param x Amount of stablecoin in band\r\n    @param y Amount of collateral in band\r\n    @param p_o External oracle price\r\n    @param p_o_up Upper boundary of the band\r\n    @return y0\r\n    \"\"\"\r\n    assert p_o != 0\r\n    # solve:\r\n    # p_o * A * y0**2 - y0 * (p_oracle_up/p_o * (A-1) * x + p_o**2/p_oracle_up * A * y) - xy = 0\r\n    b: uint256 = 0\r\n    # p_o_up * unsafe_sub(A, 1) * x / p_o + A * p_o**2 / p_o_up * y / 10**18\r\n    if x != 0:\r\n        b = unsafe_div(p_o_up * Aminus1 * x, p_o)\r\n    if y != 0:\r\n        b += unsafe_div(A * p_o**2 / p_o_up * y, 10**18)\r\n    if x > 0 and y > 0:\r\n        D: uint256 = b**2 + unsafe_div(((4 * A) * p_o) * y, 10**18) * x\r\n        return unsafe_div((b + self.sqrt_int(D)) * 10**18, unsafe_mul(2 * A, p_o))\r\n    else:\r\n        return unsafe_div(b * 10**18, unsafe_mul(A, p_o))\r\n\r\n\r\n@internal\r\n@view\r\ndef _get_p(n: int256, x: uint256, y: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get current AMM price in band\r\n    @param n Band number\r\n    @param x Amount of stablecoin in band\r\n    @param y Amount of collateral in band\r\n    @return Current price at 1e18 base\r\n    \"\"\"\r\n    p_o_up: uint256 = self._p_oracle_up(n)\r\n    p_o: uint256 = self._price_oracle_ro()[0]\r\n    assert p_o_up != 0\r\n\r\n    # Special cases\r\n    if x == 0:\r\n        if y == 0:  # x and y are 0\r\n            # Return mid-band\r\n            return unsafe_div((unsafe_div(unsafe_div(p_o**2, p_o_up) * p_o, p_o_up) * A), Aminus1)\r\n        # if x == 0: # Lowest point of this band -> p_current_down\r\n        return unsafe_div(unsafe_div(p_o**2, p_o_up) * p_o, p_o_up)\r\n    if y == 0: # Highest point of this band -> p_current_up\r\n        p_o_up = unsafe_div(p_o_up * Aminus1, A)  # now this is _actually_ p_o_down\r\n        return unsafe_div(p_o**2 / p_o_up * p_o, p_o_up)\r\n\r\n    y0: uint256 = self._get_y0(x, y, p_o, p_o_up)\r\n    # ^ that call also checks that p_o != 0\r\n\r\n    # (f(y0) + x) / (g(y0) + y)\r\n    f: uint256 = unsafe_div(A * y0 * p_o, p_o_up) * p_o\r\n    g: uint256 = unsafe_div(Aminus1 * y0 * p_o_up, p_o)\r\n    return (f + x * 10**18) / (g + y)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef get_p() -> uint256:\r\n    \"\"\"\r\n    @notice Get current AMM price in active_band\r\n    @return Current price at 1e18 base\r\n    \"\"\"\r\n    n: int256 = self.active_band\r\n    return self._get_p(n, self.bands_x[n], self.bands_y[n])\r\n\r\n\r\n@internal\r\n@view\r\ndef _read_user_tick_numbers(user: address) -> int256[2]:\r\n    \"\"\"\r\n    @notice Unpacks and reads user tick numbers\r\n    @param user User address\r\n    @return Lowest and highest band the user deposited into\r\n    \"\"\"\r\n    ns: int256 = self.user_shares[user].ns\r\n    n2: int256 = unsafe_div(ns, 2**128)\r\n    n1: int256 = ns % 2**128\r\n    if n1 >= 2**127:\r\n        n1 = unsafe_sub(n1, 2**128)\r\n        n2 = unsafe_add(n2, 1)\r\n    return [n1, n2]\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef read_user_tick_numbers(user: address) -> int256[2]:\r\n    \"\"\"\r\n    @notice Unpacks and reads user tick numbers\r\n    @param user User address\r\n    @return Lowest and highest band the user deposited into\r\n    \"\"\"\r\n    return self._read_user_tick_numbers(user)\r\n\r\n\r\n@internal\r\n@view\r\ndef _read_user_ticks(user: address, ns: int256[2]) -> DynArray[uint256, MAX_TICKS_UINT]:\r\n    \"\"\"\r\n    @notice Unpacks and reads user ticks (shares) for all the ticks user deposited into\r\n    @param user User address\r\n    @param size Number of ticks the user deposited into\r\n    @return Array of shares the user has\r\n    \"\"\"\r\n    ticks: DynArray[uint256, MAX_TICKS_UINT] = []\r\n    size: uint256 = convert(ns[1] - ns[0] + 1, uint256)\r\n    for i in range(MAX_TICKS / 2):\r\n        if len(ticks) == size:\r\n            break\r\n        tick: uint256 = self.user_shares[user].ticks[i]\r\n        ticks.append(tick & (2**128 - 1))\r\n        if len(ticks) == size:\r\n            break\r\n        ticks.append(shift(tick, -128))\r\n    return ticks\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef can_skip_bands(n_end: int256) -> bool:\r\n    \"\"\"\r\n    @notice Check that we have no liquidity between active_band and `n_end`\r\n    \"\"\"\r\n    n: int256 = self.active_band\r\n    for i in range(MAX_SKIP_TICKS):\r\n        if n_end > n:\r\n            if self.bands_y[n] != 0:\r\n                return False\r\n            n = unsafe_add(n, 1)\r\n        else:\r\n            if self.bands_x[n] != 0:\r\n                return False\r\n            n = unsafe_sub(n, 1)\r\n        if n == n_end:  # not including n_end\r\n            break\r\n    return True\r\n    # Actually skipping bands:\r\n    # * change self.active_band to the new n\r\n    # * change self.p_base_mul\r\n    # to do n2-n1 times (if n2 > n1):\r\n    # out.base_mul = unsafe_div(out.base_mul * Aminus1, A)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef active_band_with_skip() -> int256:\r\n    n0: int256 = self.active_band\r\n    n: int256 = n0\r\n    min_band: int256 = self.min_band\r\n    for i in range(MAX_SKIP_TICKS):\r\n        if n < min_band:\r\n            n = n0 - MAX_SKIP_TICKS\r\n            break\r\n        if self.bands_x[n] != 0:\r\n            break\r\n        n -= 1\r\n    return n\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef has_liquidity(user: address) -> bool:\r\n    \"\"\"\r\n    @notice Check if `user` has any liquidity in the AMM\r\n    \"\"\"\r\n    return self.user_shares[user].ticks[0] != 0\r\n\r\n\r\n@internal\r\ndef save_user_shares(user: address, user_shares: DynArray[uint256, MAX_TICKS_UINT]):\r\n    ptr: uint256 = 0\r\n    for j in range(MAX_TICKS_UINT / 2):\r\n        if ptr >= len(user_shares):\r\n            break\r\n        tick: uint256 = user_shares[ptr]\r\n        ptr = unsafe_add(ptr, 1)\r\n        if len(user_shares) != ptr:\r\n            tick = tick | shift(user_shares[ptr], 128)\r\n        ptr = unsafe_add(ptr, 1)\r\n        self.user_shares[user].ticks[j] = tick\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef deposit_range(user: address, amount: uint256, n1: int256, n2: int256):\r\n    \"\"\"\r\n    @notice Deposit for a user in a range of bands. Only admin contract (Controller) can do it\r\n    @param user User address\r\n    @param amount Amount of collateral to deposit\r\n    @param n1 Lower band in the deposit range\r\n    @param n2 Upper band in the deposit range\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n\r\n    user_shares: DynArray[uint256, MAX_TICKS_UINT] = []\r\n    collateral_shares: DynArray[uint256, MAX_TICKS_UINT] = []\r\n\r\n    n0: int256 = self.active_band\r\n\r\n    # We assume that n1,n2 area already sorted (and they are in Controller)\r\n    assert n2 < 2**127\r\n    assert n1 > -2**127\r\n\r\n    lm: LMGauge = self.liquidity_mining_callback\r\n\r\n    # Autoskip bands if we can\r\n    for i in range(MAX_SKIP_TICKS + 1):\r\n        if n1 > n0:\r\n            if i != 0:\r\n                self.active_band = n0\r\n            break\r\n        assert self.bands_x[n0] == 0 and i < MAX_SKIP_TICKS, \"Deposit below current band\"\r\n        n0 -= 1\r\n\r\n    n_bands: uint256 = unsafe_add(convert(unsafe_sub(n2, n1), uint256), 1)\r\n    assert n_bands <= MAX_TICKS_UINT\r\n\r\n    y_per_band: uint256 = unsafe_div(amount * COLLATERAL_PRECISION, n_bands)\r\n    assert y_per_band > 100, \"Amount too low\"\r\n\r\n    assert self.user_shares[user].ticks[0] == 0  # dev: User must have no liquidity\r\n    self.user_shares[user].ns = unsafe_add(n1, unsafe_mul(n2, 2**128))\r\n\r\n    for i in range(MAX_TICKS):\r\n        band: int256 = unsafe_add(n1, i)\r\n        if band > n2:\r\n            break\r\n\r\n        assert self.bands_x[band] == 0, \"Band not empty\"\r\n        y: uint256 = y_per_band\r\n        if i == 0:\r\n            y = amount * COLLATERAL_PRECISION - y * unsafe_sub(n_bands, 1)\r\n\r\n        total_y: uint256 = self.bands_y[band]\r\n\r\n        # Total / user share\r\n        s: uint256 = self.total_shares[band]\r\n        ds: uint256 = unsafe_div((s + DEAD_SHARES) * y, total_y + 1)\r\n        assert ds > 0, \"Amount too low\"\r\n        user_shares.append(ds)\r\n        s += ds\r\n        assert s <= 2**128 - 1\r\n        self.total_shares[band] = s\r\n\r\n        total_y += y\r\n        self.bands_y[band] = total_y\r\n\r\n        if lm.address != empty(address):\r\n            # If initial s == 0 - s becomes equal to y which is > 100 => nonzero\r\n            collateral_shares.append(unsafe_div(total_y * 10**18, s))\r\n\r\n    self.min_band = min(self.min_band, n1)\r\n    self.max_band = max(self.max_band, n2)\r\n\r\n    self.save_user_shares(user, user_shares)\r\n\r\n    self.rate_mul = self._rate_mul()\r\n    self.rate_time = block.timestamp\r\n\r\n    log Deposit(user, amount, n1, n2)\r\n\r\n    if lm.address != empty(address):\r\n        lm.callback_collateral_shares(n1, collateral_shares)\r\n        lm.callback_user_shares(user, n1, user_shares)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw(user: address, frac: uint256) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Withdraw liquidity for the user. Only admin contract can do it\r\n    @param user User who owns liquidity\r\n    @param frac Fraction to withdraw (1e18 being 100%)\r\n    @return Amount of [stablecoins, collateral] withdrawn\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    assert frac <= 10**18\r\n\r\n    lm: LMGauge = self.liquidity_mining_callback\r\n\r\n    ns: int256[2] = self._read_user_tick_numbers(user)\r\n    n: int256 = ns[0]\r\n    user_shares: DynArray[uint256, MAX_TICKS_UINT] = self._read_user_ticks(user, ns)\r\n    assert user_shares[0] > 0, \"No deposits\"\r\n\r\n    total_x: uint256 = 0\r\n    total_y: uint256 = 0\r\n    min_band: int256 = self.min_band\r\n    old_min_band: int256 = min_band\r\n    old_max_band: int256 = self.max_band\r\n    max_band: int256 = n - 1\r\n\r\n    for i in range(MAX_TICKS):\r\n        x: uint256 = self.bands_x[n]\r\n        y: uint256 = self.bands_y[n]\r\n        ds: uint256 = unsafe_div(frac * user_shares[i], 10**18)  # Can ONLY zero out when frac == 10**18\r\n        user_shares[i] = unsafe_sub(user_shares[i], ds)\r\n        s: uint256 = self.total_shares[n]\r\n        new_shares: uint256 = s - ds\r\n        self.total_shares[n] = new_shares\r\n        s += DEAD_SHARES\r\n        dx: uint256 = (x + 1) * ds / s\r\n        dy: uint256 = unsafe_div((y + 1) * ds, s)\r\n\r\n        x -= dx\r\n        y -= dy\r\n\r\n        # If withdrawal is the last one - tranfer dust to admin fees\r\n        if new_shares == 0:\r\n            if x > 0:\r\n                self.admin_fees_x += x\r\n            if y > 0:\r\n                self.admin_fees_y += y / COLLATERAL_PRECISION\r\n            x = 0\r\n            y = 0\r\n\r\n        if n == min_band:\r\n            if x == 0:\r\n                if y == 0:\r\n                    min_band += 1\r\n        if x > 0 or y > 0:\r\n            max_band = n\r\n        self.bands_x[n] = x\r\n        self.bands_y[n] = y\r\n        total_x += dx\r\n        total_y += dy\r\n\r\n        if n == ns[1]:\r\n            break\r\n        else:\r\n            n = unsafe_add(n, 1)\r\n\r\n    # Empty the ticks\r\n    if frac == 10**18:\r\n        self.user_shares[user].ticks[0] = 0\r\n    else:\r\n        self.save_user_shares(user, user_shares)\r\n\r\n    if old_min_band != min_band:\r\n        self.min_band = min_band\r\n    if old_max_band <= ns[1]:\r\n        self.max_band = max_band\r\n\r\n    total_x = unsafe_div(total_x, BORROWED_PRECISION)\r\n    total_y = unsafe_div(total_y, COLLATERAL_PRECISION)\r\n    log Withdraw(user, total_x, total_y)\r\n\r\n    self.rate_mul = self._rate_mul()\r\n    self.rate_time = block.timestamp\r\n\r\n    if lm.address != empty(address):\r\n        lm.callback_collateral_shares(0, [])  # collateral/shares ratio is unchanged\r\n        lm.callback_user_shares(user, ns[0], user_shares)\r\n\r\n    return [total_x, total_y]\r\n\r\n\r\n@internal\r\n@view\r\ndef calc_swap_out(pump: bool, in_amount: uint256, p_o: uint256[2], in_precision: uint256, out_precision: uint256) -> DetailedTrade:\r\n    \"\"\"\r\n    @notice Calculate the amount which can be obtained as a result of exchange.\r\n            If couldn't exchange all - will also update the amount which was actually used.\r\n            Also returns other parameters related to state after swap.\r\n            This function is core to the AMM functionality.\r\n    @param pump Indicates whether the trade buys or sells collateral\r\n    @param in_amount Amount of token going in\r\n    @param p_o Current oracle price and ratio (p_o, dynamic_fee)\r\n    @return Amounts spent and given out, initial and final bands of the AMM, new\r\n            amounts of coins in bands in the AMM, as well as admin fee charged,\r\n            all in one data structure\r\n    \"\"\"\r\n    # pump = True: borrowable (USD) in, collateral (ETH) out; going up\r\n    # pump = False: collateral (ETH) in, borrowable (USD) out; going down\r\n    min_band: int256 = self.min_band\r\n    max_band: int256 = self.max_band\r\n    out: DetailedTrade = empty(DetailedTrade)\r\n    out.n2 = self.active_band\r\n    p_o_up: uint256 = self._p_oracle_up(out.n2)\r\n    x: uint256 = self.bands_x[out.n2]\r\n    y: uint256 = self.bands_y[out.n2]\r\n\r\n    in_amount_left: uint256 = in_amount\r\n    antifee: uint256 = unsafe_div(\r\n        (10**18)**2,\r\n        unsafe_sub(10**18, max(self.fee, p_o[1]))\r\n    )\r\n    admin_fee: uint256 = self.admin_fee\r\n    j: uint256 = MAX_TICKS_UINT\r\n\r\n    for i in range(MAX_TICKS + MAX_SKIP_TICKS):\r\n        y0: uint256 = 0\r\n        f: uint256 = 0\r\n        g: uint256 = 0\r\n        Inv: uint256 = 0\r\n\r\n        if x > 0 or y > 0:\r\n            if j == MAX_TICKS_UINT:\r\n                out.n1 = out.n2\r\n                j = 0\r\n            y0 = self._get_y0(x, y, p_o[0], p_o_up)  # <- also checks p_o\r\n            f = unsafe_div(A * y0 * p_o[0] / p_o_up * p_o[0], 10**18)\r\n            g = unsafe_div(Aminus1 * y0 * p_o_up, p_o[0])\r\n            Inv = (f + x) * (g + y)\r\n\r\n        if j != MAX_TICKS_UINT:\r\n            # Initialize\r\n            _tick: uint256 = y\r\n            if pump:\r\n                _tick = x\r\n            out.ticks_in.append(_tick)\r\n\r\n        # Need this to break if price is too far\r\n        p_ratio: uint256 = unsafe_div(p_o_up * 10**18, p_o[0])\r\n\r\n        if pump:\r\n            if y != 0:\r\n                if g != 0:\r\n                    x_dest: uint256 = (unsafe_div(Inv, g) - f) - x\r\n                    dx: uint256 = unsafe_div(x_dest * antifee, 10**18)\r\n                    if dx >= in_amount_left:\r\n                        # This is the last band\r\n                        x_dest = unsafe_div(in_amount_left * 10**18, antifee)  # LESS than in_amount_left\r\n                        out.last_tick_j = min(Inv / (f + (x + x_dest)) - g + 1, y)  # Should be always >= 0\r\n                        x_dest = unsafe_div(unsafe_sub(in_amount_left, x_dest) * admin_fee, 10**18)  # abs admin fee now\r\n                        x += in_amount_left  # x is precise after this\r\n                        # Round down the output\r\n                        out.out_amount += y - out.last_tick_j\r\n                        out.ticks_in[j] = x - x_dest\r\n                        out.in_amount = in_amount\r\n                        out.admin_fee = unsafe_add(out.admin_fee, x_dest)\r\n                        break\r\n\r\n                    else:\r\n                        # We go into the next band\r\n                        dx = max(dx, 1)  # Prevents from leaving dust in the band\r\n                        x_dest = unsafe_div(unsafe_sub(dx, x_dest) * admin_fee, 10**18)  # abs admin fee now\r\n                        in_amount_left -= dx\r\n                        out.ticks_in[j] = x + dx - x_dest\r\n                        out.in_amount += dx\r\n                        out.out_amount += y\r\n                        out.admin_fee = unsafe_add(out.admin_fee, x_dest)\r\n\r\n            if i != MAX_TICKS + MAX_SKIP_TICKS - 1:\r\n                if out.n2 == max_band:\r\n                    break\r\n                if j == MAX_TICKS_UINT - 1:\r\n                    break\r\n                if p_ratio < 10**36 / MAX_ORACLE_DN_POW:\r\n                    # Don't allow to be away by more than ~50 ticks\r\n                    break\r\n                out.n2 += 1\r\n                p_o_up = unsafe_div(p_o_up * Aminus1, A)\r\n                x = 0\r\n                y = self.bands_y[out.n2]\r\n\r\n        else:  # dump\r\n            if x != 0:\r\n                if f != 0:\r\n                    y_dest: uint256 = (unsafe_div(Inv, f) - g) - y\r\n                    dy: uint256 = unsafe_div(y_dest * antifee, 10**18)\r\n                    if dy >= in_amount_left:\r\n                        # This is the last band\r\n                        y_dest = unsafe_div(in_amount_left * 10**18, antifee)\r\n                        out.last_tick_j = min(Inv / (g + (y + y_dest)) - f + 1, x)\r\n                        y_dest = unsafe_div(unsafe_sub(in_amount_left, y_dest) * admin_fee, 10**18)  # abs admin fee now\r\n                        y += in_amount_left\r\n                        out.out_amount += x - out.last_tick_j\r\n                        out.ticks_in[j] = y - y_dest\r\n                        out.in_amount = in_amount\r\n                        out.admin_fee = unsafe_add(out.admin_fee, y_dest)\r\n                        break\r\n\r\n                    else:\r\n                        # We go into the next band\r\n                        dy = max(dy, 1)  # Prevents from leaving dust in the band\r\n                        y_dest = unsafe_div(unsafe_sub(dy, y_dest) * admin_fee, 10**18)  # abs admin fee now\r\n                        in_amount_left -= dy\r\n                        out.ticks_in[j] = y + dy - y_dest\r\n                        out.in_amount += dy\r\n                        out.out_amount += x\r\n                        out.admin_fee = unsafe_add(out.admin_fee, y_dest)\r\n\r\n            if i != MAX_TICKS + MAX_SKIP_TICKS - 1:\r\n                if out.n2 == min_band:\r\n                    break\r\n                if j == MAX_TICKS_UINT - 1:\r\n                    break\r\n                if p_ratio > MAX_ORACLE_DN_POW:\r\n                    # Don't allow to be away by more than ~50 ticks\r\n                    break\r\n                out.n2 -= 1\r\n                p_o_up = unsafe_div(p_o_up * A, Aminus1)\r\n                x = self.bands_x[out.n2]\r\n                y = 0\r\n\r\n        if j != MAX_TICKS_UINT:\r\n            j = unsafe_add(j, 1)\r\n\r\n    # Round up what goes in and down what goes out\r\n    # ceil(in_amount_used/BORROWED_PRECISION) * BORROWED_PRECISION\r\n    out.in_amount = unsafe_mul(unsafe_div(unsafe_add(out.in_amount, unsafe_sub(in_precision, 1)), in_precision), in_precision)\r\n    out.out_amount = unsafe_mul(unsafe_div(out.out_amount, out_precision), out_precision)\r\n\r\n    return out\r\n\r\n\r\n@internal\r\n@view\r\ndef _get_dxdy(i: uint256, j: uint256, amount: uint256, is_in: bool) -> DetailedTrade:\r\n    \"\"\"\r\n    @notice Method to use to calculate out amount and spent in amount\r\n    @param i Input coin index\r\n    @param j Output coin index\r\n    @param amount Amount of input or output coin to swap\r\n    @param is_in Whether IN our OUT amount is known\r\n    @return DetailedTrade with all swap results\r\n    \"\"\"\r\n    # i = 0: borrowable (USD) in, collateral (ETH) out; going up\r\n    # i = 1: collateral (ETH) in, borrowable (USD) out; going down\r\n    assert (i == 0 and j == 1) or (i == 1 and j == 0), \"Wrong index\"\r\n    out: DetailedTrade = empty(DetailedTrade)\r\n    if amount == 0:\r\n        return out\r\n    in_precision: uint256 = COLLATERAL_PRECISION\r\n    out_precision: uint256 = BORROWED_PRECISION\r\n    if i == 0:\r\n        in_precision = BORROWED_PRECISION\r\n        out_precision = COLLATERAL_PRECISION\r\n    p_o: uint256[2] = self._price_oracle_ro()\r\n    if is_in:\r\n        out = self.calc_swap_out(i == 0, amount * in_precision, p_o, in_precision, out_precision)\r\n    else:\r\n        out = self.calc_swap_in(i == 0, amount * out_precision, p_o, in_precision, out_precision)\r\n    out.in_amount = unsafe_div(out.in_amount, in_precision)\r\n    out.out_amount = unsafe_div(out.out_amount, out_precision)\r\n    return out\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef get_dy(i: uint256, j: uint256, in_amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Method to use to calculate out amount\r\n    @param i Input coin index\r\n    @param j Output coin index\r\n    @param in_amount Amount of input coin to swap\r\n    @return Amount of coin j to give out\r\n    \"\"\"\r\n    return self._get_dxdy(i, j, in_amount, True).out_amount\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef get_dxdy(i: uint256, j: uint256, in_amount: uint256) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Method to use to calculate out amount and spent in amount\r\n    @param i Input coin index\r\n    @param j Output coin index\r\n    @param in_amount Amount of input coin to swap\r\n    @return A tuple with in_amount used and out_amount returned\r\n    \"\"\"\r\n    out: DetailedTrade = self._get_dxdy(i, j, in_amount, True)\r\n    return (out.in_amount, out.out_amount)\r\n\r\n\r\n@internal\r\ndef _exchange(i: uint256, j: uint256, amount: uint256, minmax_amount: uint256, _for: address, use_in_amount: bool) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Exchanges two coins, callable by anyone\r\n    @param i Input coin index\r\n    @param j Output coin index\r\n    @param amount Amount of input/output coin to swap\r\n    @param minmax_amount Minimal/maximum amount to get as output/input\r\n    @param _for Address to send coins to\r\n    @param use_in_amount Whether input or output amount is specified\r\n    @return Amount of coins given in and out\r\n    \"\"\"\r\n    assert (i == 0 and j == 1) or (i == 1 and j == 0), \"Wrong index\"\r\n    p_o: uint256[2] = self._price_oracle_w()  # Let's update the oracle even if we exchange 0\r\n    if amount == 0:\r\n        return [0, 0]\r\n\r\n    lm: LMGauge = self.liquidity_mining_callback\r\n    collateral_shares: DynArray[uint256, MAX_TICKS_UINT] = []\r\n\r\n    in_coin: ERC20 = BORROWED_TOKEN\r\n    out_coin: ERC20 = COLLATERAL_TOKEN\r\n    in_precision: uint256 = BORROWED_PRECISION\r\n    out_precision: uint256 = COLLATERAL_PRECISION\r\n    if i == 1:\r\n        in_precision = out_precision\r\n        in_coin = out_coin\r\n        out_precision = BORROWED_PRECISION\r\n        out_coin = BORROWED_TOKEN\r\n\r\n    out: DetailedTrade = empty(DetailedTrade)\r\n    if use_in_amount:\r\n        out = self.calc_swap_out(i == 0, amount * in_precision, p_o, in_precision, out_precision)\r\n    else:\r\n        out = self.calc_swap_in(i == 0, amount * out_precision, p_o, in_precision, out_precision)\r\n    in_amount_done: uint256 = unsafe_div(out.in_amount, in_precision)\r\n    out_amount_done: uint256 = unsafe_div(out.out_amount, out_precision)\r\n    if use_in_amount:\r\n        assert out_amount_done >= minmax_amount, \"Slippage\"\r\n    else:\r\n        assert in_amount_done <= minmax_amount, \"Slippage\"\r\n    if out_amount_done == 0 or in_amount_done == 0:\r\n        return [0, 0]\r\n\r\n    out.admin_fee = unsafe_div(out.admin_fee, in_precision)\r\n    if i == 0:\r\n        self.admin_fees_x += out.admin_fee\r\n    else:\r\n        self.admin_fees_y += out.admin_fee\r\n\r\n    n: int256 = min(out.n1, out.n2)\r\n    n_start: int256 = n\r\n    n_diff: int256 = abs(unsafe_sub(out.n2, out.n1))\r\n\r\n    for k in range(MAX_TICKS):\r\n        x: uint256 = 0\r\n        y: uint256 = 0\r\n        if i == 0:\r\n            x = out.ticks_in[k]\r\n            if n == out.n2:\r\n                y = out.last_tick_j\r\n        else:\r\n            y = out.ticks_in[unsafe_sub(n_diff, k)]\r\n            if n == out.n2:\r\n                x = out.last_tick_j\r\n        self.bands_x[n] = x\r\n        self.bands_y[n] = y\r\n        if lm.address != empty(address):\r\n            s: uint256 = 0\r\n            if y > 0:\r\n                s = unsafe_div(y * 10**18, self.total_shares[n])\r\n            collateral_shares.append(s)\r\n        if k == n_diff:\r\n            break\r\n        n = unsafe_add(n, 1)\r\n\r\n    self.active_band = out.n2\r\n\r\n    log TokenExchange(_for, i, in_amount_done, j, out_amount_done)\r\n\r\n    if lm.address != empty(address):\r\n        lm.callback_collateral_shares(n_start, collateral_shares)\r\n\r\n    assert in_coin.transferFrom(msg.sender, self, in_amount_done, default_return_value=True)\r\n    assert out_coin.transfer(_for, out_amount_done, default_return_value=True)\r\n\r\n    return [in_amount_done, out_amount_done]\r\n\r\n\r\n@internal\r\n@view\r\ndef calc_swap_in(pump: bool, out_amount: uint256, p_o: uint256[2], in_precision: uint256, out_precision: uint256) -> DetailedTrade:\r\n    \"\"\"\r\n    @notice Calculate the input amount required to receive the desired output amount.\r\n            If couldn't exchange all - will also update the amount which was actually received.\r\n            Also returns other parameters related to state after swap.\r\n    @param pump Indicates whether the trade buys or sells collateral\r\n    @param out_amount Desired amount of token going out\r\n    @param p_o Current oracle price and antisandwich fee (p_o, dynamic_fee)\r\n    @return Amounts required and given out, initial and final bands of the AMM, new\r\n            amounts of coins in bands in the AMM, as well as admin fee charged,\r\n            all in one data structure\r\n    \"\"\"\r\n    # pump = True: borrowable (USD) in, collateral (ETH) out; going up\r\n    # pump = False: collateral (ETH) in, borrowable (USD) out; going down\r\n    min_band: int256 = self.min_band\r\n    max_band: int256 = self.max_band\r\n    out: DetailedTrade = empty(DetailedTrade)\r\n    out.n2 = self.active_band\r\n    p_o_up: uint256 = self._p_oracle_up(out.n2)\r\n    x: uint256 = self.bands_x[out.n2]\r\n    y: uint256 = self.bands_y[out.n2]\r\n\r\n    out_amount_left: uint256 = out_amount\r\n    antifee: uint256 = unsafe_div(\r\n        (10**18)**2,\r\n        unsafe_sub(10**18, max(self.fee, p_o[1]))\r\n    )\r\n    admin_fee: uint256 = self.admin_fee\r\n    j: uint256 = MAX_TICKS_UINT\r\n\r\n    for i in range(MAX_TICKS + MAX_SKIP_TICKS):\r\n        y0: uint256 = 0\r\n        f: uint256 = 0\r\n        g: uint256 = 0\r\n        Inv: uint256 = 0\r\n\r\n        if x > 0 or y > 0:\r\n            if j == MAX_TICKS_UINT:\r\n                out.n1 = out.n2\r\n                j = 0\r\n            y0 = self._get_y0(x, y, p_o[0], p_o_up)  # <- also checks p_o\r\n            f = unsafe_div(A * y0 * p_o[0] / p_o_up * p_o[0], 10**18)\r\n            g = unsafe_div(Aminus1 * y0 * p_o_up, p_o[0])\r\n            Inv = (f + x) * (g + y)\r\n\r\n        if j != MAX_TICKS_UINT:\r\n            # Initialize\r\n            _tick: uint256 = y\r\n            if pump:\r\n                _tick = x\r\n            out.ticks_in.append(_tick)\r\n\r\n        # Need this to break if price is too far\r\n        p_ratio: uint256 = unsafe_div(p_o_up * 10**18, p_o[0])\r\n\r\n        if pump:\r\n            if y != 0:\r\n                if g != 0:\r\n                    if y >= out_amount_left:\r\n                        # This is the last band\r\n                        out.last_tick_j = unsafe_sub(y, out_amount_left)\r\n                        x_dest: uint256 = Inv / (g + out.last_tick_j) - f - x\r\n                        dx: uint256 = unsafe_div(x_dest * antifee, 10**18)  # MORE than x_dest\r\n                        out.out_amount = out_amount  # We successfully found liquidity for all the out_amount\r\n                        out.in_amount += dx\r\n                        x_dest = unsafe_div(unsafe_sub(dx, x_dest) * admin_fee, 10**18)  # abs admin fee now\r\n                        out.ticks_in[j] = x + dx - x_dest\r\n                        out.admin_fee = unsafe_add(out.admin_fee, x_dest)\r\n                        break\r\n\r\n                    else:\r\n                        # We go into the next band\r\n                        x_dest: uint256 = (unsafe_div(Inv, g) - f) - x\r\n                        dx: uint256 = max(unsafe_div(x_dest * antifee, 10**18), 1)\r\n                        out_amount_left -= y\r\n                        out.in_amount += dx\r\n                        out.out_amount += y\r\n                        x_dest = unsafe_div(unsafe_sub(dx, x_dest) * admin_fee, 10**18)  # abs admin fee now\r\n                        out.ticks_in[j] = x + dx - x_dest\r\n                        out.admin_fee = unsafe_add(out.admin_fee, x_dest)\r\n\r\n            if i != MAX_TICKS + MAX_SKIP_TICKS - 1:\r\n                if out.n2 == max_band:\r\n                    break\r\n                if j == MAX_TICKS_UINT - 1:\r\n                    break\r\n                if p_ratio < 10**36 / MAX_ORACLE_DN_POW:\r\n                    # Don't allow to be away by more than ~50 ticks\r\n                    break\r\n                out.n2 += 1\r\n                p_o_up = unsafe_div(p_o_up * Aminus1, A)\r\n                x = 0\r\n                y = self.bands_y[out.n2]\r\n\r\n        else:  # dump\r\n            if x != 0:\r\n                if f != 0:\r\n                    if x >= out_amount_left:\r\n                        # This is the last band\r\n                        out.last_tick_j = unsafe_sub(x, out_amount_left)\r\n                        y_dest: uint256 = Inv / (f + out.last_tick_j) - g - y\r\n                        dy: uint256 = unsafe_div(y_dest * antifee, 10**18)  # MORE than y_dest\r\n                        out.out_amount = out_amount\r\n                        out.in_amount += dy\r\n                        y_dest = unsafe_div(unsafe_sub(dy, y_dest) * admin_fee, 10**18)  # abs admin fee now\r\n                        out.ticks_in[j] = y + dy - y_dest\r\n                        out.admin_fee = unsafe_add(out.admin_fee, y_dest)\r\n                        break\r\n\r\n                    else:\r\n                        # We go into the next band\r\n                        y_dest: uint256 = (unsafe_div(Inv, f) - g) - y\r\n                        dy: uint256 = max(unsafe_div(y_dest * antifee, 10**18), 1)\r\n                        out_amount_left -= x\r\n                        out.in_amount += dy\r\n                        out.out_amount += x\r\n                        y_dest = unsafe_div(unsafe_sub(dy, y_dest) * admin_fee, 10**18)  # abs admin fee now\r\n                        out.ticks_in[j] = y + dy - y_dest\r\n                        out.admin_fee = unsafe_add(out.admin_fee, y_dest)\r\n\r\n            if i != MAX_TICKS + MAX_SKIP_TICKS - 1:\r\n                if out.n2 == min_band:\r\n                    break\r\n                if j == MAX_TICKS_UINT - 1:\r\n                    break\r\n                if p_ratio > MAX_ORACLE_DN_POW:\r\n                    # Don't allow to be away by more than ~50 ticks\r\n                    break\r\n                out.n2 -= 1\r\n                p_o_up = unsafe_div(p_o_up * A, Aminus1)\r\n                x = self.bands_x[out.n2]\r\n                y = 0\r\n\r\n        if j != MAX_TICKS_UINT:\r\n            j = unsafe_add(j, 1)\r\n\r\n    # Round up what goes in and down what goes out\r\n    # ceil(in_amount_used/BORROWED_PRECISION) * BORROWED_PRECISION\r\n    out.in_amount = unsafe_mul(unsafe_div(unsafe_add(out.in_amount, unsafe_sub(in_precision, 1)), in_precision), in_precision)\r\n    out.out_amount = unsafe_mul(unsafe_div(out.out_amount, out_precision), out_precision)\r\n\r\n    return out\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef get_dx(i: uint256, j: uint256, out_amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Method to use to calculate in amount required to receive the desired out_amount\r\n    @param i Input coin index\r\n    @param j Output coin index\r\n    @param out_amount Desired amount of output coin to receive\r\n    @return Amount of coin i to spend\r\n    \"\"\"\r\n    # i = 0: borrowable (USD) in, collateral (ETH) out; going up\r\n    # i = 1: collateral (ETH) in, borrowable (USD) out; going down\r\n    return self._get_dxdy(i, j, out_amount, False).in_amount\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef get_dydx(i: uint256, j: uint256, out_amount: uint256) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Method to use to calculate in amount required and out amount received\r\n    @param i Input coin index\r\n    @param j Output coin index\r\n    @param out_amount Desired amount of output coin to receive\r\n    @return A tuple with out_amount received and in_amount returned\r\n    \"\"\"\r\n    # i = 0: borrowable (USD) in, collateral (ETH) out; going up\r\n    # i = 1: collateral (ETH) in, borrowable (USD) out; going down\r\n    out: DetailedTrade = self._get_dxdy(i, j, out_amount, False)\r\n    return (out.out_amount, out.in_amount)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange(i: uint256, j: uint256, in_amount: uint256, min_amount: uint256, _for: address = msg.sender) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Exchanges two coins, callable by anyone\r\n    @param i Input coin index\r\n    @param j Output coin index\r\n    @param in_amount Amount of input coin to swap\r\n    @param min_amount Minimal amount to get as output\r\n    @param _for Address to send coins to\r\n    @return Amount of coins given in/out\r\n    \"\"\"\r\n    return self._exchange(i, j, in_amount, min_amount, _for, True)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange_dy(i: uint256, j: uint256, out_amount: uint256, max_amount: uint256, _for: address = msg.sender) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Exchanges two coins, callable by anyone\r\n    @param i Input coin index\r\n    @param j Output coin index\r\n    @param out_amount Desired amount of output coin to receive\r\n    @param max_amount Maximum amount to spend (revert if more)\r\n    @param _for Address to send coins to\r\n    @return Amount of coins given in/out\r\n    \"\"\"\r\n    return self._exchange(i, j, out_amount, max_amount, _for, False)\r\n\r\n\r\n@internal\r\n@view\r\ndef get_xy_up(user: address, use_y: bool) -> uint256:\r\n    \"\"\"\r\n    @notice Measure the amount of y (collateral) in the band n if we adiabatically trade near p_oracle on the way up,\r\n            or the amount of x (stablecoin) if we trade adiabatically down\r\n    @param user User the amount is calculated for\r\n    @param use_y Calculate amount of collateral if True and of stablecoin if False\r\n    @return Amount of coins\r\n    \"\"\"\r\n    ns: int256[2] = self._read_user_tick_numbers(user)\r\n    ticks: DynArray[uint256, MAX_TICKS_UINT] = self._read_user_ticks(user, ns)\r\n    if ticks[0] == 0:  # Even dynamic array will have 0th element set here\r\n        return 0\r\n    p_o: uint256 = self._price_oracle_ro()[0]\r\n    assert p_o != 0\r\n\r\n    n: int256 = ns[0] - 1\r\n    n_active: int256 = self.active_band\r\n    p_o_down: uint256 = self._p_oracle_up(ns[0])\r\n    XY: uint256 = 0\r\n\r\n    for i in range(MAX_TICKS):\r\n        n += 1\r\n        if n > ns[1]:\r\n            break\r\n        x: uint256 = 0\r\n        y: uint256 = 0\r\n        if n >= n_active:\r\n            y = self.bands_y[n]\r\n        if n <= n_active:\r\n            x = self.bands_x[n]\r\n        # p_o_up: uint256 = self._p_oracle_up(n)\r\n        p_o_up: uint256 = p_o_down\r\n        # p_o_down = self._p_oracle_up(n + 1)\r\n        p_o_down = unsafe_div(p_o_down * Aminus1, A)\r\n        if x == 0:\r\n            if y == 0:\r\n                continue\r\n\r\n        total_share: uint256 = self.total_shares[n]\r\n        user_share: uint256 = ticks[i]\r\n        if total_share == 0:\r\n            continue\r\n        if user_share == 0:\r\n            continue\r\n        total_share += DEAD_SHARES\r\n        # Also ideally we'd want to add +1 to all quantities when calculating with shares\r\n        # but we choose to save bytespace and slightly under-estimate the result of this call\r\n        # which is also more conservative\r\n\r\n        # Also this will revert if p_o_down is 0, and p_o_down is 0 if p_o_up is 0\r\n        p_current_mid: uint256 = unsafe_div(p_o**2 / p_o_down * p_o, p_o_up)\r\n\r\n        # if p_o > p_o_up - we \"trade\" everything to y and then convert to the result\r\n        # if p_o < p_o_down - \"trade\" to x, then convert to result\r\n        # otherwise we are in-band, so we do the more complex logic to trade\r\n        # to p_o rather than to the edge of the band\r\n        # trade to the edge of the band == getting to the band edge while p_o=const\r\n\r\n        # Cases when special conversion is not needed (to save on computations)\r\n        if x == 0 or y == 0:\r\n            if p_o > p_o_up:  # p_o < p_current_down\r\n                # all to y at constant p_o, then to target currency adiabatically\r\n                y_equiv: uint256 = y\r\n                if y == 0:\r\n                    y_equiv = x * 10**18 / p_current_mid\r\n                if use_y:\r\n                    XY += unsafe_div(y_equiv * user_share, total_share)\r\n                else:\r\n                    XY += unsafe_div(unsafe_div(y_equiv * p_o_up, SQRT_BAND_RATIO) * user_share, total_share)\r\n                continue\r\n\r\n            elif p_o < p_o_down:  # p_o > p_current_up\r\n                # all to x at constant p_o, then to target currency adiabatically\r\n                x_equiv: uint256 = x\r\n                if x == 0:\r\n                    x_equiv = unsafe_div(y * p_current_mid, 10**18)\r\n                if use_y:\r\n                    XY += unsafe_div(unsafe_div(x_equiv * SQRT_BAND_RATIO, p_o_up) * user_share, total_share)\r\n                else:\r\n                    XY += unsafe_div(x_equiv * user_share, total_share)\r\n                continue\r\n\r\n        # If we are here - we need to \"trade\" to somewhere mid-band\r\n        # So we need more heavy math\r\n\r\n        y0: uint256 = self._get_y0(x, y, p_o, p_o_up)\r\n        f: uint256 = unsafe_div(unsafe_div(A * y0 * p_o, p_o_up) * p_o, 10**18)\r\n        g: uint256 = unsafe_div(Aminus1 * y0 * p_o_up, p_o)\r\n        # (f + x)(g + y) = const = p_top * A**2 * y0**2 = I\r\n        Inv: uint256 = (f + x) * (g + y)\r\n        # p = (f + x) / (g + y) => p * (g + y)**2 = I or (f + x)**2 / p = I\r\n\r\n        # First, \"trade\" in this band to p_oracle\r\n        x_o: uint256 = 0\r\n        y_o: uint256 = 0\r\n\r\n        if p_o > p_o_up:  # p_o < p_current_down, all to y\r\n            # x_o = 0\r\n            y_o = unsafe_sub(max(Inv / f, g), g)\r\n            if use_y:\r\n                XY += unsafe_div(y_o * user_share, total_share)\r\n            else:\r\n                XY += unsafe_div(unsafe_div(y_o * p_o_up, SQRT_BAND_RATIO) * user_share, total_share)\r\n\r\n        elif p_o < p_o_down:  # p_o > p_current_up, all to x\r\n            # y_o = 0\r\n            x_o = unsafe_sub(max(Inv / g, f), f)\r\n            if use_y:\r\n                XY += unsafe_div(unsafe_div(x_o * SQRT_BAND_RATIO, p_o_up) * user_share, total_share)\r\n            else:\r\n                XY += unsafe_div(x_o * user_share, total_share)\r\n\r\n        else:\r\n            # Equivalent from Chainsecurity (which also has less numerical errors):\r\n            y_o = unsafe_div(A * y0 * unsafe_sub(p_o, p_o_down), p_o)\r\n            # x_o = unsafe_div(A * y0 * p_o, p_o_up) * unsafe_sub(p_o_up, p_o)\r\n            # Old math\r\n            # y_o = unsafe_sub(max(self.sqrt_int(unsafe_div(Inv * 10**18, p_o)), g), g)\r\n            x_o = unsafe_sub(max(Inv / (g + y_o), f), f)\r\n\r\n            # Now adiabatic conversion from definitely in-band\r\n            if use_y:\r\n                XY += unsafe_div((y_o + x_o * 10**18 / self.sqrt_int(p_o_up * p_o)) * user_share, total_share)\r\n\r\n            else:\r\n                XY += unsafe_div((x_o + unsafe_div(y_o * self.sqrt_int(p_o_down * p_o), 10**18)) * user_share, total_share)\r\n\r\n    if use_y:\r\n        return unsafe_div(XY, COLLATERAL_PRECISION)\r\n    else:\r\n        return unsafe_div(XY, BORROWED_PRECISION)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef get_y_up(user: address) -> uint256:\r\n    \"\"\"\r\n    @notice Measure the amount of y (collateral) in the band n if we adiabatically trade near p_oracle on the way up\r\n    @param user User the amount is calculated for\r\n    @return Amount of coins\r\n    \"\"\"\r\n    return self.get_xy_up(user, True)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef get_x_down(user: address) -> uint256:\r\n    \"\"\"\r\n    @notice Measure the amount of x (stablecoin) if we trade adiabatically down\r\n    @param user User the amount is calculated for\r\n    @return Amount of coins\r\n    \"\"\"\r\n    return self.get_xy_up(user, False)\r\n\r\n@internal\r\n@view\r\ndef _get_xy(user: address, is_sum: bool) -> DynArray[uint256, MAX_TICKS_UINT][2]:\r\n    \"\"\"\r\n    @notice A low-gas function to measure amounts of stablecoins and collateral which user currently owns\r\n    @param user User address\r\n    @param is_sum Return sum or amounts by bands\r\n    @return Amounts of (stablecoin, collateral) in a tuple\r\n    \"\"\"\r\n    xs: DynArray[uint256, MAX_TICKS_UINT] = []\r\n    ys: DynArray[uint256, MAX_TICKS_UINT] = []\r\n    if is_sum:\r\n        xs.append(0)\r\n        ys.append(0)\r\n    ns: int256[2] = self._read_user_tick_numbers(user)\r\n    ticks: DynArray[uint256, MAX_TICKS_UINT] = self._read_user_ticks(user, ns)\r\n    if ticks[0] != 0:\r\n        for i in range(MAX_TICKS):\r\n            total_shares: uint256 = self.total_shares[ns[0]] + DEAD_SHARES\r\n            ds: uint256 = ticks[i]\r\n            dx: uint256 = unsafe_div((self.bands_x[ns[0]] + 1) * ds, total_shares)\r\n            dy: uint256 = unsafe_div((self.bands_y[ns[0]] + 1) * ds, total_shares)\r\n            if is_sum:\r\n                xs[0] += dx\r\n                ys[0] += dy\r\n            else:\r\n                xs.append(unsafe_div(dx, BORROWED_PRECISION))\r\n                ys.append(unsafe_div(dy, COLLATERAL_PRECISION))\r\n            if ns[0] == ns[1]:\r\n                break\r\n            ns[0] = unsafe_add(ns[0], 1)\r\n\r\n    if is_sum:\r\n        xs[0] = unsafe_div(xs[0], BORROWED_PRECISION)\r\n        ys[0] = unsafe_div(ys[0], COLLATERAL_PRECISION)\r\n\r\n    return [xs, ys]\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef get_sum_xy(user: address) -> uint256[2]:\r\n    \"\"\"\r\n    @notice A low-gas function to measure amounts of stablecoins and collateral which user currently owns\r\n    @param user User address\r\n    @return Amounts of (stablecoin, collateral) in a tuple\r\n    \"\"\"\r\n    xy: DynArray[uint256, MAX_TICKS_UINT][2] = self._get_xy(user, True)\r\n    return [xy[0][0], xy[1][0]]\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef get_xy(user: address) -> DynArray[uint256, MAX_TICKS_UINT][2]:\r\n    \"\"\"\r\n    @notice A low-gas function to measure amounts of stablecoins and collateral by bands which user currently owns\r\n    @param user User address\r\n    @return Amounts of (stablecoin, collateral) by bands in a tuple\r\n    \"\"\"\r\n    return self._get_xy(user, False)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef get_amount_for_price(p: uint256) -> (uint256, bool):\r\n    \"\"\"\r\n    @notice Amount necessary to be exchanged to have the AMM at the final price `p`\r\n    @return (amount, is_pump)\r\n    \"\"\"\r\n    min_band: int256 = self.min_band\r\n    max_band: int256 = self.max_band\r\n    n: int256 = self.active_band\r\n    p_o: uint256[2] = self._price_oracle_ro()\r\n    p_o_up: uint256 = self._p_oracle_up(n)\r\n    p_down: uint256 = unsafe_div(unsafe_div(p_o[0]**2, p_o_up) * p_o[0], p_o_up)  # p_current_down\r\n    p_up: uint256 = unsafe_div(p_down * A2, Aminus12)  # p_crurrent_up\r\n    amount: uint256 = 0\r\n    y0: uint256 = 0\r\n    f: uint256 = 0\r\n    g: uint256 = 0\r\n    Inv: uint256 = 0\r\n    j: uint256 = MAX_TICKS_UINT\r\n    pump: bool = True\r\n\r\n    for i in range(MAX_TICKS + MAX_SKIP_TICKS):\r\n        assert p_o_up > 0\r\n        x: uint256 = self.bands_x[n]\r\n        y: uint256 = self.bands_y[n]\r\n        if i == 0:\r\n            if p < self._get_p(n, x, y):\r\n                pump = False\r\n        not_empty: bool = x > 0 or y > 0\r\n        if not_empty:\r\n            y0 = self._get_y0(x, y, p_o[0], p_o_up)\r\n            f = unsafe_div(unsafe_div(A * y0 * p_o[0], p_o_up) * p_o[0], 10**18)\r\n            g = unsafe_div(Aminus1 * y0 * p_o_up, p_o[0])\r\n            Inv = (f + x) * (g + y)\r\n            if j == MAX_TICKS_UINT:\r\n                j = 0\r\n\r\n        if p <= p_up:\r\n            if p >= p_down:\r\n                if not_empty:\r\n                    ynew: uint256 = unsafe_sub(max(self.sqrt_int(Inv * 10**18 / p), g), g)\r\n                    xnew: uint256 = unsafe_sub(max(Inv / (g + ynew), f), f)\r\n                    if pump:\r\n                        amount += unsafe_sub(max(xnew, x), x)\r\n                    else:\r\n                        amount += unsafe_sub(max(ynew, y), y)\r\n                break\r\n\r\n        # Need this to break if price is too far\r\n        p_ratio: uint256 = unsafe_div(p_o_up * 10**18, p_o[0])\r\n\r\n        if pump:\r\n            if not_empty:\r\n                amount += (Inv / g - f) - x\r\n            if n == max_band:\r\n                break\r\n            if j == MAX_TICKS_UINT - 1:\r\n                break\r\n            if p_ratio < 10**36 / MAX_ORACLE_DN_POW:\r\n                # Don't allow to be away by more than ~50 ticks\r\n                break\r\n            n += 1\r\n            p_down = p_up\r\n            p_up = unsafe_div(p_up * A2, Aminus12)\r\n            p_o_up = unsafe_div(p_o_up * Aminus1, A)\r\n\r\n        else:\r\n            if not_empty:\r\n                amount += (Inv / f - g) - y\r\n            if n == min_band:\r\n                break\r\n            if j == MAX_TICKS_UINT - 1:\r\n                break\r\n            if p_ratio > MAX_ORACLE_DN_POW:\r\n                # Don't allow to be away by more than ~50 ticks\r\n                break\r\n            n -= 1\r\n            p_up = p_down\r\n            p_down = unsafe_div(p_down * Aminus12, A2)\r\n            p_o_up = unsafe_div(p_o_up * A, Aminus1)\r\n\r\n        if j != MAX_TICKS_UINT:\r\n            j = unsafe_add(j, 1)\r\n\r\n    amount = amount * 10**18 / unsafe_sub(10**18, max(self.fee, p_o[1]))\r\n    if amount == 0:\r\n        return 0, pump\r\n\r\n    # Precision and round up\r\n    if pump:\r\n        amount = unsafe_add(unsafe_div(unsafe_sub(amount, 1), BORROWED_PRECISION), 1)\r\n    else:\r\n        amount = unsafe_add(unsafe_div(unsafe_sub(amount, 1), COLLATERAL_PRECISION), 1)\r\n\r\n    return amount, pump\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef set_rate(rate: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Set interest rate. That affects the dependence of AMM base price over time\r\n    @param rate New rate in units of int(fraction * 1e18) per second\r\n    @return rate_mul multiplier (e.g. 1.0 + integral(rate, dt))\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    rate_mul: uint256 = self._rate_mul()\r\n    self.rate_mul = rate_mul\r\n    self.rate_time = block.timestamp\r\n    self.rate = rate\r\n    log SetRate(rate, rate_mul, block.timestamp)\r\n    return rate_mul\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef set_fee(fee: uint256):\r\n    \"\"\"\r\n    @notice Set AMM fee\r\n    @param fee Fee where 1e18 == 100%\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    self.fee = fee\r\n    log SetFee(fee)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef set_admin_fee(fee: uint256):\r\n    \"\"\"\r\n    @notice Set admin fee - fraction of the AMM fee to go to admin\r\n    @param fee Admin fee where 1e18 == 100%\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    self.admin_fee = fee\r\n    log SetAdminFee(fee)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef reset_admin_fees():\r\n    \"\"\"\r\n    @notice Zero out AMM fees collected\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    self.admin_fees_x = 0\r\n    self.admin_fees_y = 0\r\n\r\n\r\n# nonreentrant decorator is in Controller which is admin\r\n@external\r\ndef set_callback(liquidity_mining_callback: LMGauge):\r\n    \"\"\"\r\n    @notice Set a gauge address with callbacks for liquidity mining for collateral\r\n    @param liquidity_mining_callback Gauge address\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    self.liquidity_mining_callback = liquidity_mining_callback", "ABI": "[{\"name\":\"TokenExchange\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"sold_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tokens_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"bought_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tokens_bought\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"n1\",\"type\":\"int256\",\"indexed\":false},{\"name\":\"n2\",\"type\":\"int256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount_borrowed\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount_collateral\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetRate\",\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"rate_mul\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetFee\",\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetAdminFee\",\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_borrowed_token\",\"type\":\"address\"},{\"name\":\"_borrowed_precision\",\"type\":\"uint256\"},{\"name\":\"_collateral_token\",\"type\":\"address\"},{\"name\":\"_collateral_precision\",\"type\":\"uint256\"},{\"name\":\"_A\",\"type\":\"uint256\"},{\"name\":\"_sqrt_band_ratio\",\"type\":\"uint256\"},{\"name\":\"_log_A_ratio\",\"type\":\"int256\"},{\"name\":\"_base_price\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"admin_fee\",\"type\":\"uint256\"},{\"name\":\"_price_oracle_contract\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_admin\",\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"coins\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_oracle\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"dynamic_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_rate_mul\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_base_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"p_current_up\",\"inputs\":[{\"name\":\"n\",\"type\":\"int256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"p_current_down\",\"inputs\":[{\"name\":\"n\",\"type\":\"int256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"p_oracle_up\",\"inputs\":[{\"name\":\"n\",\"type\":\"int256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"p_oracle_down\",\"inputs\":[{\"name\":\"n\",\"type\":\"int256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_p\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"read_user_tick_numbers\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int256[2]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"can_skip_bands\",\"inputs\":[{\"name\":\"n_end\",\"type\":\"int256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"active_band_with_skip\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"has_liquidity\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit_range\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"n1\",\"type\":\"int256\"},{\"name\":\"n2\",\"type\":\"int256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"frac\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"in_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dxdy\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"in_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"out_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dydx\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"out_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"in_amount\",\"type\":\"uint256\"},{\"name\":\"min_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"in_amount\",\"type\":\"uint256\"},{\"name\":\"min_amount\",\"type\":\"uint256\"},{\"name\":\"_for\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"out_amount\",\"type\":\"uint256\"},{\"name\":\"max_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"out_amount\",\"type\":\"uint256\"},{\"name\":\"max_amount\",\"type\":\"uint256\"},{\"name\":\"_for\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_y_up\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_x_down\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_sum_xy\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_xy\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[][2]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_amount_for_price\",\"inputs\":[{\"name\":\"p\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_rate\",\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_fee\",\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_admin_fee\",\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"reset_admin_fees\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_callback\",\"inputs\":[{\"name\":\"liquidity_mining_callback\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"active_band\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"min_band\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"max_band\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_fees_x\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_fees_y\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_oracle_contract\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bands_x\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"int256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bands_y\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"int256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"liquidity_mining_callback\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "LLAMMA - crvUSD AMM", "CompilerVersion": "vyper:0.3.9", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000f939e0a03fb07f59a73314e73794be0e57ac1b4e000000000000000000000000000000000000000000000000000000000000000100000000000000000000000018084fba666a33d37592fa2633fd49a74dd93a88000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000df29c916c5c292b0000000000000000000000000000000000000000000000000023b4ba2a6bdbf700000000000000000000000000000000000000000000057d4d28d2dfa0b4c9ea000000000000000000000000000000000000000000000000001550f7dca700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000bef434e2acf0fbad1f0579d2376fed0d1cfc4217", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}