{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.7/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248) {\\n        require(value >= type(int248).min && value <= type(int248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return int248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240) {\\n        require(value >= type(int240).min && value <= type(int240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return int240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232) {\\n        require(value >= type(int232).min && value <= type(int232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return int232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224) {\\n        require(value >= type(int224).min && value <= type(int224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return int224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216) {\\n        require(value >= type(int216).min && value <= type(int216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return int216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208) {\\n        require(value >= type(int208).min && value <= type(int208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return int208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200) {\\n        require(value >= type(int200).min && value <= type(int200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return int200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192) {\\n        require(value >= type(int192).min && value <= type(int192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return int192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184) {\\n        require(value >= type(int184).min && value <= type(int184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return int184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176) {\\n        require(value >= type(int176).min && value <= type(int176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return int176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168) {\\n        require(value >= type(int168).min && value <= type(int168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return int168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160) {\\n        require(value >= type(int160).min && value <= type(int160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return int160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152) {\\n        require(value >= type(int152).min && value <= type(int152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return int152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144) {\\n        require(value >= type(int144).min && value <= type(int144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return int144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136) {\\n        require(value >= type(int136).min && value <= type(int136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return int136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120) {\\n        require(value >= type(int120).min && value <= type(int120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return int120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112) {\\n        require(value >= type(int112).min && value <= type(int112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return int112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104) {\\n        require(value >= type(int104).min && value <= type(int104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return int104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96) {\\n        require(value >= type(int96).min && value <= type(int96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return int96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88) {\\n        require(value >= type(int88).min && value <= type(int88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return int88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80) {\\n        require(value >= type(int80).min && value <= type(int80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return int80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72) {\\n        require(value >= type(int72).min && value <= type(int72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return int72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56) {\\n        require(value >= type(int56).min && value <= type(int56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return int56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48) {\\n        require(value >= type(int48).min && value <= type(int48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return int48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40) {\\n        require(value >= type(int40).min && value <= type(int40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return int40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24) {\\n        require(value >= type(int24).min && value <= type(int24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return int24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IAdminACLV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAdminACLV0 {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     * @param previousSuperAdmin The previous superAdmin address.\\n     * @param newSuperAdmin The new superAdmin address.\\n     * @param genArt721CoreAddressesToUpdate Array of genArt721Core\\n     * addresses to update to the new superAdmin, for indexing purposes only.\\n     */\\n    event SuperAdminTransferred(\\n        address indexed previousSuperAdmin,\\n        address indexed newSuperAdmin,\\n        address[] genArt721CoreAddressesToUpdate\\n    );\\n\\n    /// Type of the Admin ACL contract, e.g. \\\"AdminACLV0\\\"\\n    function AdminACLType() external view returns (string memory);\\n\\n    /// super admin address\\n    function superAdmin() external view returns (address);\\n\\n    /**\\n     * @notice Calls transferOwnership on other contract from this contract.\\n     * This is useful for updating to a new AdminACL contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function transferOwnershipOn(\\n        address _contract,\\n        address _newAdminACL\\n    ) external;\\n\\n    /**\\n     * @notice Calls renounceOwnership on other contract from this contract.\\n     * @dev this function should be gated to only superAdmin-like addresses.\\n     */\\n    function renounceOwnershipOn(address _contract) external;\\n\\n    /**\\n     * @notice Checks if sender `_sender` is allowed to call function with selector\\n     * `_selector` on contract `_contract`.\\n     */\\n    function allowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/ICoreRegistryV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IEngineRegistryV0.sol\\\";\\n\\ninterface ICoreRegistryV1 is IEngineRegistryV0 {\\n    function registerContracts(\\n        address[] calldata contractAddresses,\\n        bytes32[] calldata coreVersions,\\n        bytes32[] calldata coreTypes\\n    ) external;\\n\\n    function unregisterContracts(address[] calldata contractAddresses) external;\\n\\n    function getNumRegisteredContracts() external view returns (uint256);\\n\\n    function getRegisteredContractAt(\\n        uint256 index\\n    ) external view returns (address);\\n\\n    function isRegisteredContract(\\n        address contractAddress\\n    ) external view returns (bool isRegistered);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IEngineRegistryV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\npragma solidity ^0.8.0;\\n\\ninterface IEngineRegistryV0 {\\n    /// ADDRESS\\n    /**\\n     * @notice contract has been registered as a contract that is powered by the Art Blocks Engine.\\n     */\\n    event ContractRegistered(\\n        address indexed _contractAddress,\\n        bytes32 _coreVersion,\\n        bytes32 _coreType\\n    );\\n\\n    /// ADDRESS\\n    /**\\n     * @notice contract has been unregistered as a contract that is powered by the Art Blocks Engine.\\n     */\\n    event ContractUnregistered(address indexed _contractAddress);\\n\\n    /**\\n     * @notice Emits a `ContractRegistered` event with the provided information.\\n     * @dev this function should be gated to only deployer addresses.\\n     */\\n    function registerContract(\\n        address _contractAddress,\\n        bytes32 _coreVersion,\\n        bytes32 _coreType\\n    ) external;\\n\\n    /**\\n     * @notice Emits a `ContractUnregistered` event with the provided information, validating that the provided\\n     *         address was indeed previously registered.\\n     * @dev this function should be gated to only deployer addresses.\\n     */\\n    function unregisterContract(address _contractAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IFilteredMinterV0 {\\n    /**\\n     * @notice Price per token in wei updated for project `_projectId` to\\n     * `_pricePerTokenInWei`.\\n     */\\n    event PricePerTokenInWeiUpdated(\\n        uint256 indexed _projectId,\\n        uint256 indexed _pricePerTokenInWei\\n    );\\n\\n    /**\\n     * @notice Currency updated for project `_projectId` to symbol\\n     * `_currencySymbol` and address `_currencyAddress`.\\n     */\\n    event ProjectCurrencyInfoUpdated(\\n        uint256 indexed _projectId,\\n        address indexed _currencyAddress,\\n        string _currencySymbol\\n    );\\n\\n    /// togglePurchaseToDisabled updated\\n    event PurchaseToDisabledUpdated(\\n        uint256 indexed _projectId,\\n        bool _purchaseToDisabled\\n    );\\n\\n    // getter function of public variable\\n    function minterType() external view returns (string memory);\\n\\n    function genArt721CoreAddress() external returns (address);\\n\\n    function minterFilterAddress() external returns (address);\\n\\n    // Triggers a purchase of a token from the desired project, to the\\n    // TX-sending address.\\n    function purchase(\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId);\\n\\n    // Triggers a purchase of a token from the desired project, to the specified\\n    // receiving address.\\n    function purchaseTo(\\n        address _to,\\n        uint256 _projectId\\n    ) external payable returns (uint256 tokenId);\\n\\n    // Toggles the ability for `purchaseTo` to be called directly with a\\n    // specified receiving address that differs from the TX-sending address.\\n    function togglePurchaseToDisabled(uint256 _projectId) external;\\n\\n    // Called to make the minter contract aware of the max invocations for a\\n    // given project.\\n    function setProjectMaxInvocations(uint256 _projectId) external;\\n\\n    // Gets if token price is configured, token price in wei, currency symbol,\\n    // and currency address, assuming this is project's minter.\\n    // Supersedes any defined core price.\\n    function getPriceInfo(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV0.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterV0 interface in order to\\n * add support for generic project minter configuration updates.\\n * @dev keys represent strings of finite length encoded in bytes32 to minimize\\n * gas.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterV1 is IFilteredMinterV0 {\\n    /// ANY\\n    /**\\n     * @notice Generic project minter configuration event. Removes key `_key`\\n     * for project `_projectId`.\\n     */\\n    event ConfigKeyRemoved(uint256 indexed _projectId, bytes32 _key);\\n\\n    /// BOOL\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(uint256 indexed _projectId, bytes32 _key, bool _value);\\n\\n    /// UINT256\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of uint256 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of uint256 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        uint256 _value\\n    );\\n\\n    /// ADDRESS\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of addresses at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of addresses at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        address _value\\n    );\\n\\n    /// BYTES32\\n    /**\\n     * @notice Generic project minter configuration event. Sets value of key\\n     * `_key` to `_value` for project `_projectId`.\\n     */\\n    event ConfigValueSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Adds value `_value`\\n     * to the set of bytes32 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueAddedToSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @notice Generic project minter configuration event. Removes value\\n     * `_value` to the set of bytes32 at key `_key` for project `_projectId`.\\n     */\\n    event ConfigValueRemovedFromSet(\\n        uint256 indexed _projectId,\\n        bytes32 _key,\\n        bytes32 _value\\n    );\\n\\n    /**\\n     * @dev Strings not supported. Recommend conversion of (short) strings to\\n     * bytes32 to remain gas-efficient.\\n     */\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IFilteredMinterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV1.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface extends the IFilteredMinterV1 interface in order to\\n * add support for manually setting project max invocations.\\n * @author Art Blocks Inc.\\n */\\ninterface IFilteredMinterV2 is IFilteredMinterV1 {\\n    /**\\n     * @notice Local max invocations for project `_projectId`, tied to core contract `_coreContractAddress`,\\n     * updated to `_maxInvocations`.\\n     */\\n    event ProjectMaxInvocationsLimitUpdated(\\n        uint256 indexed _projectId,\\n        uint256 _maxInvocations\\n    );\\n\\n    // Sets the local max invocations for a given project, checking that the provided max invocations is\\n    // less than or equal to the global max invocations for the project set on the core contract.\\n    // This does not impact the max invocations value defined on the core contract.\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 _projectId,\\n        uint256 _maxInvocations\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\n/// use the Royalty Registry's IManifold interface for token royalties\\nimport \\\"./IManifold.sol\\\";\\n\\n/**\\n * @title This interface is intended to house interface items that are common\\n * across all GenArt721CoreContractV3 flagship and derivative implementations.\\n * This interface extends the IManifold royalty interface in order to\\n * add support the Royalty Registry by default.\\n * @author Art Blocks Inc.\\n */\\ninterface IGenArt721CoreContractV3_Base is IManifold {\\n    /**\\n     * @notice Token ID `_tokenId` minted to `_to`.\\n     */\\n    event Mint(address indexed _to, uint256 indexed _tokenId);\\n\\n    /**\\n     * @notice currentMinter updated to `_currentMinter`.\\n     * @dev Implemented starting with V3 core\\n     */\\n    event MinterUpdated(address indexed _currentMinter);\\n\\n    /**\\n     * @notice Platform updated on bytes32-encoded field `_field`.\\n     */\\n    event PlatformUpdated(bytes32 indexed _field);\\n\\n    /**\\n     * @notice Project ID `_projectId` updated on bytes32-encoded field\\n     * `_update`.\\n     */\\n    event ProjectUpdated(uint256 indexed _projectId, bytes32 indexed _update);\\n\\n    event ProposedArtistAddressesAndSplits(\\n        uint256 indexed _projectId,\\n        address _artistAddress,\\n        address _additionalPayeePrimarySales,\\n        uint256 _additionalPayeePrimarySalesPercentage,\\n        address _additionalPayeeSecondarySales,\\n        uint256 _additionalPayeeSecondarySalesPercentage\\n    );\\n\\n    event AcceptedArtistAddressesAndSplits(uint256 indexed _projectId);\\n\\n    // version and type of the core contract\\n    // coreVersion is a string of the form \\\"0.x.y\\\"\\n    function coreVersion() external view returns (string memory);\\n\\n    // coreType is a string of the form \\\"GenArt721CoreV3\\\"\\n    function coreType() external view returns (string memory);\\n\\n    // owner (pre-V3 was named admin) of contract\\n    // this is expected to be an Admin ACL contract for V3\\n    function owner() external view returns (address);\\n\\n    // Admin ACL contract for V3, will be at the address owner()\\n    function adminACLContract() external returns (IAdminACLV0);\\n\\n    // backwards-compatible (pre-V3) admin - equal to owner()\\n    function admin() external view returns (address);\\n\\n    /**\\n     * Function determining if _sender is allowed to call function with\\n     * selector _selector on contract `_contract`. Intended to be used with\\n     * peripheral contracts such as minters, as well as internally by the\\n     * core contract itself.\\n     */\\n    function adminACLAllowed(\\n        address _sender,\\n        address _contract,\\n        bytes4 _selector\\n    ) external returns (bool);\\n\\n    /// getter function of public variable\\n    function startingProjectId() external view returns (uint256);\\n\\n    // getter function of public variable\\n    function nextProjectId() external view returns (uint256);\\n\\n    // getter function of public mapping\\n    function tokenIdToProjectId(\\n        uint256 tokenId\\n    ) external view returns (uint256 projectId);\\n\\n    // @dev this is not available in V0\\n    function isMintWhitelisted(address minter) external view returns (bool);\\n\\n    function projectIdToArtistAddress(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySales(\\n        uint256 _projectId\\n    ) external view returns (address payable);\\n\\n    function projectIdToAdditionalPayeePrimarySalesPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectIdToSecondaryMarketRoyaltyPercentage(\\n        uint256 _projectId\\n    ) external view returns (uint256);\\n\\n    function projectURIInfo(\\n        uint256 _projectId\\n    ) external view returns (string memory projectBaseURI);\\n\\n    // @dev new function in V3\\n    function projectStateData(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 invocations,\\n            uint256 maxInvocations,\\n            bool active,\\n            bool paused,\\n            uint256 completedTimestamp,\\n            bool locked\\n        );\\n\\n    function projectDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory projectName,\\n            string memory artist,\\n            string memory description,\\n            string memory website,\\n            string memory license\\n        );\\n\\n    function projectScriptDetails(\\n        uint256 _projectId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory scriptTypeAndVersion,\\n            string memory aspectRatio,\\n            uint256 scriptCount\\n        );\\n\\n    function projectScriptByIndex(\\n        uint256 _projectId,\\n        uint256 _index\\n    ) external view returns (string memory);\\n\\n    function tokenIdToHash(uint256 _tokenId) external view returns (bytes32);\\n\\n    // function to set a token's hash (must be guarded)\\n    function setTokenHash_8PT(uint256 _tokenId, bytes32 _hash) external;\\n\\n    // @dev gas-optimized signature in V3 for `mint`\\n    function mint_Ecf(\\n        address _to,\\n        uint256 _projectId,\\n        address _by\\n    ) external returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3_Engine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\nimport \\\"./IGenArt721CoreContractV3_Base.sol\\\";\\n\\ninterface IGenArt721CoreContractV3_Engine is IGenArt721CoreContractV3_Base {\\n    // @dev new function in V3\\n    function getPrimaryRevenueSplits(\\n        uint256 _projectId,\\n        uint256 _price\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 renderProviderRevenue_,\\n            address payable renderProviderAddress_,\\n            uint256 platformProviderRevenue_,\\n            address payable platformProviderAddress_,\\n            uint256 artistRevenue_,\\n            address payable artistAddress_,\\n            uint256 additionalPayeePrimaryRevenue_,\\n            address payable additionalPayeePrimaryAddress_\\n        );\\n\\n    // @dev The render provider primary sales payment address\\n    function renderProviderPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev The platform provider primary sales payment address\\n    function platformProviderPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Percentage of primary sales allocated to the render provider\\n    function renderProviderPrimarySalesPercentage()\\n        external\\n        view\\n        returns (uint256);\\n\\n    // @dev Percentage of primary sales allocated to the platform provider\\n    function platformProviderPrimarySalesPercentage()\\n        external\\n        view\\n        returns (uint256);\\n\\n    // @dev The render provider secondary sales royalties payment address\\n    function renderProviderSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev The platform provider secondary sales royalties payment address\\n    function platformProviderSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Basis points of secondary sales allocated to the render provider\\n    function renderProviderSecondarySalesBPS() external view returns (uint256);\\n\\n    // @dev Basis points of secondary sales allocated to the platform provider\\n    function platformProviderSecondarySalesBPS()\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IGenArt721CoreContractV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAdminACLV0.sol\\\";\\nimport \\\"./IGenArt721CoreContractV3_Base.sol\\\";\\n\\n/**\\n * @title This interface extends IGenArt721CoreContractV3_Base with functions\\n * that are part of the Art Blocks Flagship core contract.\\n * @author Art Blocks Inc.\\n */\\n// This interface extends IGenArt721CoreContractV3_Base with functions that are\\n// in part of the Art Blocks Flagship core contract.\\ninterface IGenArt721CoreContractV3 is IGenArt721CoreContractV3_Base {\\n    // @dev new function in V3\\n    function getPrimaryRevenueSplits(\\n        uint256 _projectId,\\n        uint256 _price\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 artblocksRevenue_,\\n            address payable artblocksAddress_,\\n            uint256 artistRevenue_,\\n            address payable artistAddress_,\\n            uint256 additionalPayeePrimaryRevenue_,\\n            address payable additionalPayeePrimaryAddress_\\n        );\\n\\n    // @dev Art Blocks primary sales payment address\\n    function artblocksPrimarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\\n     * primary sales payment address (now called artblocksPrimarySalesAddress).\\n     */\\n    function artblocksAddress() external view returns (address payable);\\n\\n    // @dev Percentage of primary sales allocated to Art Blocks\\n    function artblocksPrimarySalesPercentage() external view returns (uint256);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\\n     * primary sales percentage (now called artblocksPrimarySalesPercentage).\\n     */\\n    function artblocksPercentage() external view returns (uint256);\\n\\n    // @dev Art Blocks secondary sales royalties payment address\\n    function artblocksSecondarySalesAddress()\\n        external\\n        view\\n        returns (address payable);\\n\\n    // @dev Basis points of secondary sales allocated to Art Blocks\\n    function artblocksSecondarySalesBPS() external view returns (uint256);\\n\\n    /**\\n     * @notice Backwards-compatible (pre-V3) function  that gets artist +\\n     * artist's additional payee royalty data for token ID `_tokenId`.\\n     * WARNING: Does not include Art Blocks portion of royalties.\\n     */\\n    function getRoyaltyData(\\n        uint256 _tokenId\\n    )\\n        external\\n        view\\n        returns (\\n            address artistAddress,\\n            address additionalPayee,\\n            uint256 additionalPayeePercentage,\\n            uint256 royaltyFeeByID\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IManifold.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @dev Royalty Registry interface, used to support the Royalty Registry.\\n/// @dev Source: https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/specs/IManifold.sol\\n\\n/// @author: manifold.xyz\\n\\n/**\\n * @dev Royalty interface for creator core classes\\n */\\ninterface IManifold {\\n    /**\\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\\n     *\\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\\n     *\\n     *  => 0xbb3bafd6 = 0xbb3bafd6\\n     */\\n    function getRoyalties(\\n        uint256 tokenId\\n    ) external view returns (address payable[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IMinterBaseV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\nimport \\\"./IFilteredMinterV2.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title This interface defines any events or functions required for a minter\\n * to conform to the MinterBase contract.\\n * @dev The MinterBase contract was not implemented from the beginning of the\\n * MinterSuite contract suite, therefore early versions of some minters may not\\n * conform to this interface.\\n * @author Art Blocks Inc.\\n */\\ninterface IMinterBaseV0 {\\n    // Function that returns if a minter is configured to integrate with a V3 flagship or V3 engine contract.\\n    // Returns true only if the minter is configured to integrate with an engine contract.\\n    function isEngine() external returns (bool isEngine);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/IMinterFilterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ICoreRegistryV1.sol\\\";\\nimport \\\"./IAdminACLV0.sol\\\";\\n\\n/**\\n * @title IMinterFilterV1\\n * @author Art Blocks Inc.\\n * @notice Interface for a new minter filter contract.\\n * This interface does not extend the previous version of the minter filter\\n * interface, as the previous version is not compatible with the new\\n * minter filter architecture.\\n * @dev This interface is for a minter filter that supports multiple core\\n * contracts, and allows for a minter to be set on a per-project basis.\\n */\\ninterface IMinterFilterV1 {\\n    /**\\n     * @notice Emitted when contract is deployed to notify indexing services\\n     * of the new contract deployment.\\n     */\\n    event Deployed();\\n\\n    /**\\n     * @notice Globally approved minter `minter`.\\n     */\\n    event MinterApprovedGlobally(address indexed minter, string minterType);\\n\\n    /**\\n     * @notice Globally revoked minter `minter`.\\n     * @dev contract owner may still approve this minter on a per-contract\\n     * basis.\\n     */\\n    event MinterRevokedGlobally(address indexed minter);\\n\\n    /**\\n     * @notice Approved minter `minter` on core contract\\n     * `coreContract`.\\n     */\\n    event MinterApprovedForContract(\\n        address indexed coreContract,\\n        address indexed minter,\\n        string minterType\\n    );\\n\\n    /**\\n     * @notice Revoked minter `minter` on core contract `coreContract`.\\n     * @dev minter filter owner may still globally approve this minter for all\\n     * contracts.\\n     */\\n    event MinterRevokedForContract(\\n        address indexed coreContract,\\n        address indexed minter\\n    );\\n\\n    /**\\n     * @notice Minter at address `minter` set as minter for project\\n     * `projectId` on core contract `coreContract`.\\n     */\\n    event ProjectMinterRegistered(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        address indexed minter,\\n        string minterType\\n    );\\n\\n    /**\\n     * @notice Minter removed for project `projectId` on core contract\\n     * `coreContract`.\\n     */\\n    event ProjectMinterRemoved(\\n        uint256 indexed projectId,\\n        address indexed coreContract\\n    );\\n\\n    /**\\n     * @notice Admin ACL contract updated to `adminACLContract`.\\n     */\\n    event AdminACLUpdated(address indexed adminACLContract);\\n\\n    /**\\n     * @notice Core Registry contract updated to `coreRegistry`.\\n     */\\n    event CoreRegistryUpdated(address indexed coreRegistry);\\n\\n    // struct used to return minter info\\n    // @dev this is not used for storage of data\\n    struct MinterWithType {\\n        address minterAddress;\\n        string minterType;\\n    }\\n\\n    function setMinterForProject(\\n        uint256 projectId,\\n        address coreContract,\\n        address minter\\n    ) external;\\n\\n    function removeMinterForProject(\\n        uint256 projectId,\\n        address coreContract\\n    ) external;\\n\\n    // @dev function name is optimized for gas\\n    function mint_joo(\\n        address to,\\n        uint256 projectId,\\n        address coreContract,\\n        address sender\\n    ) external returns (uint256);\\n\\n    function updateCoreRegistry(address coreRegistry) external;\\n\\n    /**\\n     * @notice Returns if `sender` is allowed to call function on `contract`\\n     * with `selector` selector, according to the MinterFilter's Admin ACL.\\n     */\\n    function adminACLAllowed(\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) external returns (bool);\\n\\n    function minterFilterType() external pure returns (string memory);\\n\\n    function getMinterForProject(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (address);\\n\\n    function projectHasMinter(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice View that returns if a core contract is registered with the\\n     * core registry, allowing this minter filter to service it.\\n     * @param coreContract core contract address to be checked\\n     */\\n    function isRegisteredCoreContract(\\n        address coreContract\\n    ) external view returns (bool);\\n\\n    /// Address of current core registry contract\\n    function coreRegistry() external view returns (ICoreRegistryV1);\\n\\n    /// The current admin ACL contract\\n    function adminACLContract() external view returns (IAdminACLV0);\\n\\n    /// The quantity of projects on a core contract that have assigned minters\\n    function getNumProjectsOnContractWithMinters(\\n        address coreContract\\n    ) external view returns (uint256);\\n\\n    function getProjectAndMinterInfoOnContractAt(\\n        address coreContract,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 projectId,\\n            address minterAddress,\\n            string memory minterType\\n        );\\n\\n    function getAllGloballyApprovedMinters()\\n        external\\n        view\\n        returns (MinterWithType[] memory mintersWithTypes);\\n\\n    function getAllContractApprovedMinters(\\n        address coreContract\\n    ) external view returns (MinterWithType[] memory mintersWithTypes);\\n\\n    /**\\n     * Owner of contract.\\n     * @dev This returns the address of the Admin ACL contract.\\n     */\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/v0.8.x/ISharedMinterV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\ninterface ISharedMinterV0 {\\n    // Sets the local max invocations for a given project, checking that the provided max invocations is\\n    // less than or equal to the global max invocations for the project set on the core contract.\\n    // This does not impact the max invocations value defined on the core contract.\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 projectId,\\n        address coreContract,\\n        uint24 maxInvocations\\n    ) external;\\n\\n    // Called to make the minter contract aware of the max invocations for a\\n    // given project.\\n    function syncProjectMaxInvocationsToCore(\\n        uint256 projectId,\\n        address coreContract\\n    ) external;\\n\\n    // getter function of public variable\\n    function minterType() external view returns (string memory);\\n\\n    function minterFilterAddress() external returns (address);\\n\\n    // Gets if token price is configured, token price in wei, currency symbol,\\n    // and currency address, assuming this is project's minter.\\n    // Supersedes any defined core price.\\n    function getPriceInfo(\\n        uint256 projectId,\\n        address coreContract\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/ABHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Art Blocks Helpers Library\\n * @notice This library contains helper functions for common operations in the\\n * Art Blocks ecosystem of smart contracts.\\n * @author Art Blocks Inc.\\n */\\n\\nlibrary ABHelpers {\\n    uint256 constant ONE_MILLION = 1_000_000;\\n\\n    /**\\n     * @notice Function to convert token id to project id.\\n     * @param tokenId The id of the token.\\n     */\\n    function tokenIdToProjectId(\\n        uint256 tokenId\\n    ) internal pure returns (uint256) {\\n        // int division properly rounds down\\n        // @dev unchecked because will never divide by zero\\n        unchecked {\\n            return tokenId / ONE_MILLION;\\n        }\\n    }\\n\\n    /**\\n     * @notice Function to convert token id to token number.\\n     * @param tokenId The id of the token.\\n     */\\n    function tokenIdToTokenNumber(\\n        uint256 tokenId\\n    ) internal pure returns (uint256) {\\n        // mod returns remainder, which is the token number\\n        // @dev no way to disable mod zero check in solidity, so not unchecked\\n        return tokenId % ONE_MILLION;\\n    }\\n\\n    /**\\n     * @notice Function to convert token id to token invocation.\\n     * @dev token invocation is the token number plus one, because token #0 is\\n     * invocation 1.\\n     * @param tokenId The id of the token.\\n     */\\n    function tokenIdToTokenInvocation(\\n        uint256 tokenId\\n    ) internal pure returns (uint256) {\\n        // mod returns remainder, which is the token number\\n        // @dev no way to disable mod zero check in solidity, so not unchecked\\n        return (tokenId % ONE_MILLION) + 1;\\n    }\\n\\n    /**\\n     * @notice Function to convert project id and token number to token id.\\n     * @param projectId The id of the project.\\n     * @param tokenNumber The token number.\\n     */\\n    function tokenIdFromProjectIdAndTokenNumber(\\n        uint256 projectId,\\n        uint256 tokenNumber\\n    ) internal pure returns (uint256) {\\n        // @dev intentionally not unchecked to ensure overflow detection, which\\n        // would likley only occur in a malicious call\\n        return (projectId * ONE_MILLION) + tokenNumber;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/AuthLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport {IGenArt721CoreContractV3_Base} from \\\"../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\nimport {IMinterFilterV1} from \\\"../../interfaces/v0.8.x/IMinterFilterV1.sol\\\";\\n\\n/**\\n * @title Art Blocks Authorization Minter Library\\n * @notice This library contains helper functions that may be used contracts to\\n * check authorization for performing operations in the Art Blocks V3 core\\n * contract ecosystem.\\n * @author Art Blocks Inc.\\n */\\n\\nlibrary AuthLib {\\n    /**\\n     * @notice Function to restrict access to only AdminACL allowed calls, where\\n     * AdminACL is the admin of an IMinterFilterV1.\\n     * Reverts if not allowed.\\n     * @param minterFilterAddress address of the minter filter to be checked,\\n     * should implement IMinterFilterV1\\n     * @param sender address of the caller\\n     * @param contract_ address of the contract being called\\n     * @param selector selector of the function being called\\n     */\\n    function onlyMinterFilterAdminACL(\\n        address minterFilterAddress,\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) internal {\\n        require(\\n            _minterFilterAdminACLAllowed({\\n                minterFilterAddress: minterFilterAddress,\\n                sender: sender,\\n                contract_: contract_,\\n                selector: selector\\n            }),\\n            \\\"Only MinterFilter AdminACL\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Function to restrict access to only AdminACL allowed calls, where\\n     * AdminACL is the admin of a core contract at `coreContract`.\\n     * Reverts if not allowed.\\n     * @param coreContract address of the core contract to be checked\\n     * @param sender address of the caller\\n     * @param contract_ address of the contract being called\\n     * @param selector selector of the function being called\\n     */\\n    function onlyCoreAdminACL(\\n        address coreContract,\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) internal {\\n        require(\\n            _coreAdminACLAllowed({\\n                coreContract: coreContract,\\n                sender: sender,\\n                contract_: contract_,\\n                selector: selector\\n            }),\\n            \\\"Only Core AdminACL allowed\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Throws if `sender` is any account other than the artist of the\\n     * specified project `projectId` on core contract `coreContract`.\\n     * @param projectId The ID of the project being checked.\\n     * @param coreContract The address of the GenArt721CoreContractV3_Base\\n     * contract.\\n     * @param sender Wallet to check. Typically, the address of the caller.\\n     * @dev `sender` must be the artist associated with `projectId` on `coreContract`.\\n     */\\n    function onlyArtist(\\n        uint256 projectId,\\n        address coreContract,\\n        address sender\\n    ) internal view {\\n        require(\\n            _senderIsArtist({\\n                projectId: projectId,\\n                coreContract: coreContract,\\n                sender: sender\\n            }),\\n            \\\"Only Artist\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Function to restrict access to only the artist of a project, or AdminACL\\n     * allowed calls, where AdminACL is the admin of a core contract at\\n     * `coreContract`.\\n     * @param projectId id of the project\\n     * @param coreContract address of the core contract to be checked\\n     * @param sender address of the caller\\n     * @param contract_ address of the contract being called\\n     * @param selector selector of the function being called\\n     */\\n    function onlyCoreAdminACLOrArtist(\\n        uint256 projectId,\\n        address coreContract,\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) internal {\\n        require(\\n            _senderIsArtist({\\n                projectId: projectId,\\n                coreContract: coreContract,\\n                sender: sender\\n            }) ||\\n                _coreAdminACLAllowed({\\n                    coreContract: coreContract,\\n                    sender: sender,\\n                    contract_: contract_,\\n                    selector: selector\\n                }),\\n            \\\"Only Artist or Core Admin ACL\\\"\\n        );\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Private functions used internally by this library\\n    // ------------------------------------------------------------------------\\n\\n    /**\\n     * @notice Private function that returns if minter filter contract's AdminACL\\n     * allows `sender` to call function with selector `selector` on contract\\n     * `contract`.\\n     * @param minterFilterAddress address of the minter filter to be checked.\\n     * Should implement IMinterFilterV1.\\n     * @param sender address of the caller\\n     * @param contract_ address of the contract being called\\n     * @param selector selector of the function being called\\n     */\\n    function _minterFilterAdminACLAllowed(\\n        address minterFilterAddress,\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) private returns (bool) {\\n        return\\n            IMinterFilterV1(minterFilterAddress).adminACLAllowed({\\n                sender: sender,\\n                contract_: contract_,\\n                selector: selector\\n            });\\n    }\\n\\n    /**\\n     * @notice Private function that returns if core contract's AdminACL allows\\n     * `sender` to call function with selector `selector` on contract\\n     * `contract`.\\n     * @param coreContract address of the core contract to be checked\\n     * @param sender address of the caller\\n     * @param contract_ address of the contract being called\\n     * @param selector selector of the function being called\\n     */\\n    function _coreAdminACLAllowed(\\n        address coreContract,\\n        address sender,\\n        address contract_,\\n        bytes4 selector\\n    ) private returns (bool) {\\n        return\\n            IGenArt721CoreContractV3_Base(coreContract).adminACLAllowed({\\n                _sender: sender,\\n                _contract: contract_,\\n                _selector: selector\\n            });\\n    }\\n\\n    /**\\n     * @notice Private function that returns if `sender` is the artist of `projectId`\\n     * on `coreContract`.\\n     * @param projectId project ID to check\\n     * @param coreContract core contract to check\\n     * @param sender wallet to check\\n     */\\n    function _senderIsArtist(\\n        uint256 projectId,\\n        address coreContract,\\n        address sender\\n    ) private view returns (bool senderIsArtist) {\\n        return\\n            sender ==\\n            IGenArt721CoreContractV3_Base(coreContract)\\n                .projectIdToArtistAddress(projectId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/minter-libs/MaxInvocationsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport {IGenArt721CoreContractV3_Base} from \\\"../../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\n\\nimport {ABHelpers} from \\\"../ABHelpers.sol\\\";\\n\\nimport {Math} from \\\"@openzeppelin-4.7/contracts/utils/math/Math.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin-4.7/contracts/utils/math/SafeCast.sol\\\";\\n\\n/**\\n * @title Art Blocks Max Invocations Library\\n * @notice This library manages the maximum invocation limits for Art Blocks\\n * projects. It provides functionality for synchronizing, manually limiting, and\\n * updating these limits, ensuring the integrity in relation to the core Art\\n * Blocks contract, and managing updates upon token minting.\\n * @dev Functions include `syncProjectMaxInvocationsToCore`,\\n * `manuallyLimitProjectMaxInvocations`, and `purchaseEffectsInvocations`.\\n * @author Art Blocks Inc.\\n */\\n\\nlibrary MaxInvocationsLib {\\n    using SafeCast for uint256;\\n\\n    /**\\n     * @notice Local max invocations for project `projectId`, tied to core contract `coreContractAddress`,\\n     * updated to `maxInvocations`.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     * @param maxInvocations The new max invocations limit.\\n     */\\n    event ProjectMaxInvocationsLimitUpdated(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        uint256 maxInvocations\\n    );\\n\\n    // position of Max Invocations Lib storage, using a diamond storage pattern\\n    // for this library\\n    bytes32 constant MAX_INVOCATIONS_LIB_STORAGE_POSITION =\\n        keccak256(\\\"maxinvocationslib.storage\\\");\\n\\n    uint256 internal constant ONE_MILLION = 1_000_000;\\n\\n    /**\\n     * @notice Data structure that holds max invocations project configuration.\\n     */\\n    struct MaxInvocationsProjectConfig {\\n        bool maxHasBeenInvoked;\\n        uint24 maxInvocations;\\n    }\\n\\n    // Diamond storage pattern is used in this library\\n    struct MaxInvocationsLibStorage {\\n        mapping(address coreContract => mapping(uint256 projectId => MaxInvocationsProjectConfig)) maxInvocationsProjectConfigs;\\n    }\\n\\n    /**\\n     * @notice Syncs project's max invocations to core contract value.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function syncProjectMaxInvocationsToCore(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal {\\n        (\\n            uint256 coreInvocations,\\n            uint256 coreMaxInvocations\\n        ) = coreContractInvocationData({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // update storage with results\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // @dev only bugged core would return > 1e6 invocations, but safe-cast\\n        // for additional overflow safety\\n        maxInvocationsProjectConfig.maxInvocations = coreMaxInvocations\\n            .toUint24();\\n\\n        // We need to ensure maxHasBeenInvoked is correctly set after manually syncing the\\n        // local maxInvocations value with the core contract's maxInvocations value.\\n        maxInvocationsProjectConfig.maxHasBeenInvoked =\\n            coreInvocations == coreMaxInvocations;\\n\\n        emit ProjectMaxInvocationsLimitUpdated({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            maxInvocations: coreMaxInvocations\\n        });\\n    }\\n\\n    /**\\n     * @notice Manually limits project's max invocations.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     * @param maxInvocations The new max invocations limit.\\n     */\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 projectId,\\n        address coreContract,\\n        uint24 maxInvocations\\n    ) internal {\\n        // CHECKS\\n        (\\n            uint256 coreInvocations,\\n            uint256 coreMaxInvocations\\n        ) = coreContractInvocationData({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        require(\\n            maxInvocations <= coreMaxInvocations,\\n            \\\"Invalid max invocations\\\"\\n        );\\n        require(maxInvocations >= coreInvocations, \\\"Invalid max invocations\\\");\\n\\n        // EFFECTS\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // update storage with results\\n        maxInvocationsProjectConfig.maxInvocations = uint24(maxInvocations);\\n        // We need to ensure maxHasBeenInvoked is correctly set after manually setting the\\n        // local maxInvocations value.\\n        maxInvocationsProjectConfig.maxHasBeenInvoked =\\n            coreInvocations == maxInvocations;\\n\\n        emit ProjectMaxInvocationsLimitUpdated({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            maxInvocations: maxInvocations\\n        });\\n    }\\n\\n    /**\\n     * @notice Validate effects on invocations after purchase. This ensures\\n     * that the token invocation is less than or equal to the local max\\n     * invocations, and also updates the local maxHasBeenInvoked value.\\n     * @dev This function checks that the token invocation is less than or\\n     * equal to the local max invocations, and also updates the local\\n     * maxHasBeenInvoked value.\\n     * @param tokenId The id of the token.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function validateMintEffectsInvocations(\\n        uint256 tokenId,\\n        address coreContract\\n    ) internal {\\n        uint256 projectId = ABHelpers.tokenIdToProjectId(tokenId);\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // invocation is token number plus one, and will never overflow due to\\n        // limit of 1e6 invocations per project. block scope for gas efficiency\\n        // (i.e. avoid an unnecessary var initialization to 0).\\n        unchecked {\\n            uint256 tokenInvocation = ABHelpers.tokenIdToTokenInvocation(\\n                tokenId\\n            );\\n            uint256 localMaxInvocations = maxInvocationsProjectConfig\\n                .maxInvocations;\\n            // handle the case where the token invocation == minter local max\\n            // invocations occurred on a different minter, and we have a stale\\n            // local maxHasBeenInvoked value returning a false negative.\\n            // @dev this is a CHECK after EFFECTS, so security was considered\\n            // in detail here.\\n            require(\\n                tokenInvocation <= localMaxInvocations,\\n                \\\"Max invocations reached\\\"\\n            );\\n            // in typical case, update the local maxHasBeenInvoked value\\n            // to true if the token invocation == minter local max invocations\\n            // (enables gas efficient reverts after sellout)\\n            if (tokenInvocation == localMaxInvocations) {\\n                maxInvocationsProjectConfig.maxHasBeenInvoked = true;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks that the max invocations have not been reached for a\\n     * given project. This only checks the minter's local max invocations, and\\n     * does not consider the core contract's max invocations.\\n     * The function reverts if the max invocations have been reached.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function preMintChecks(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view {\\n        // check that max invocations have not been reached\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        require(\\n            !maxInvocationsProjectConfig.maxHasBeenInvoked,\\n            \\\"Max invocations reached\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Helper function to check if max invocations has not been initialized.\\n     * Returns true if not initialized, false if initialized.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     * @return bool\\n     * @dev We know a project's max invocations have never been initialized if\\n     * both max invocations and maxHasBeenInvoked are still initial values.\\n     * This is because if maxInvocations were ever set to zero,\\n     * maxHasBeenInvoked would be set to true.\\n     */\\n    function maxInvocationsIsUnconfigured(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (bool) {\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        return\\n            maxInvocationsProjectConfig.maxInvocations == 0 &&\\n            !maxInvocationsProjectConfig.maxHasBeenInvoked;\\n    }\\n\\n    /**\\n     * @notice Function returns if invocations remain available for a given project.\\n     * This function calls the core contract to get the most up-to-date\\n     * invocation data (which may be useful to avoid reverts during mint).\\n     * This function considers core contract max invocations, and minter local\\n     * max invocations, and returns a response based on the most limiting\\n     * max invocations value.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function invocationsRemain(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (bool) {\\n        // get up-to-data invocation data from core contract\\n        (\\n            uint256 coreInvocations,\\n            uint256 coreMaxInvocations\\n        ) = coreContractInvocationData({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // load minter-local max invocations into memory\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // invocations remain available if the core contract has not reached\\n        // the most limiting max invocations, either on minter or core contract\\n        uint256 limitingMaxInvocations = Math.min(\\n            coreMaxInvocations,\\n            maxInvocationsProjectConfig.maxInvocations // local max invocations\\n        );\\n        return coreInvocations < limitingMaxInvocations;\\n    }\\n\\n    /**\\n     * @notice Pulls core contract invocation data for a given project.\\n     * @dev This function calls the core contract to get the invocation data\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     * @return coreInvocations The number of invocations for the project.\\n     * @return coreMaxInvocations The max invocations for the project, as\\n     * defined on the core contract.\\n     */\\n    function coreContractInvocationData(\\n        uint256 projectId,\\n        address coreContract\\n    )\\n        internal\\n        view\\n        returns (uint256 coreInvocations, uint256 coreMaxInvocations)\\n    {\\n        (\\n            coreInvocations,\\n            coreMaxInvocations,\\n            ,\\n            ,\\n            ,\\n\\n        ) = IGenArt721CoreContractV3_Base(coreContract).projectStateData(\\n            projectId\\n        );\\n    }\\n\\n    /**\\n     * @notice Function returns the max invocations for a given project.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     * to be queried.\\n     */\\n    function getMaxInvocations(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (uint256) {\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        return maxInvocationsProjectConfig.maxInvocations;\\n    }\\n\\n    /**\\n     * @notice Function returns if max has been invoked for a given project.\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     * to be queried.\\n     */\\n    function getMaxHasBeenInvoked(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (bool) {\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        return maxInvocationsProjectConfig.maxHasBeenInvoked;\\n    }\\n\\n    /**\\n     * @notice Function returns if a project has reached its max invocations.\\n     * Function is labelled as \\\"safe\\\" because it checks the core contract's\\n     * invocations and max invocations. If the local max invocations is greater\\n     * than the core contract's max invocations, it will defer to the core\\n     * contract's max invocations (since those are the limiting factor).\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function projectMaxHasBeenInvokedSafe(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (bool) {\\n        // get max invocations from core contract\\n        (\\n            uint256 coreInvocations,\\n            uint256 coreMaxInvocations\\n        ) = coreContractInvocationData({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        uint256 localMaxInvocations = maxInvocationsProjectConfig\\n            .maxInvocations;\\n        // value is locally defined, and could be out of date.\\n        // only possible illogical state is if local max invocations is\\n        // greater than core contract's max invocations, in which case\\n        // we should use the core contract's max invocations\\n        if (localMaxInvocations > coreMaxInvocations) {\\n            // local max invocations is stale and illogical, defer to core\\n            // contract's max invocations since it is the limiting factor\\n            return (coreMaxInvocations == coreInvocations);\\n        }\\n        // local max invocations is limiting, so check core invocations against\\n        // local max invocations\\n        return (coreInvocations >= localMaxInvocations);\\n    }\\n\\n    /**\\n     * @notice Refreshes max invocations to account for core contract max\\n     * invocations state, without imposing any additional restrictions on the\\n     * minter's max invocations state.\\n     * If minter max invocations have never been populated, this function will\\n     * populate them to equal the core contract's max invocations state (which\\n     * is the least restrictive state).\\n     * If minter max invocations have been populated, this function will ensure\\n     * the minter's max invocations are not greater than the core contract's\\n     * max invocations (which would be stale and illogical), and update the\\n     * minter's max invocations and maxHasBeenInvoked state to be consistent\\n     * with the core contract's max invocations.\\n     * If the minter max invocations have been populated and are not greater\\n     * than the core contract's max invocations, this function will do nothing,\\n     * since that is a valid state in which the minter has been configured to\\n     * be more restrictive than the core contract.\\n     * @dev assumes core contract's max invocations may only be reduced, which\\n     * is the case for all V3 core contracts\\n     * @param projectId The id of the project.\\n     * @param coreContract The address of the core contract.\\n     */\\n    function refreshMaxInvocations(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal {\\n        MaxInvocationsProjectConfig\\n            storage maxInvocationsProjectConfig = getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        if (maxInvocationsIsUnconfigured(projectId, coreContract)) {\\n            // populate the minter max invocation state to equal the values on\\n            // the core contract (least restrictive state)\\n            syncProjectMaxInvocationsToCore({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        } else {\\n            // if local max invocations were already populated, validate the local state\\n            (\\n                uint256 coreInvocations,\\n                uint256 coreMaxInvocations\\n            ) = coreContractInvocationData({\\n                    projectId: projectId,\\n                    coreContract: coreContract\\n                });\\n\\n            uint256 localMaxInvocations = maxInvocationsProjectConfig\\n                .maxInvocations;\\n            if (localMaxInvocations > coreMaxInvocations) {\\n                // if local max invocations are greater than core max invocations, make\\n                // them equal since that is the least restrictive logical state\\n                // @dev this is only possible if the core contract's max invocations\\n                // have been reduced since the minter's max invocations were last\\n                // updated\\n                // set local max invocations to core contract's max invocations\\n                maxInvocationsProjectConfig.maxInvocations = uint24(\\n                    coreMaxInvocations\\n                );\\n                // update the minter's `maxHasBeenInvoked` state\\n                maxInvocationsProjectConfig\\n                    .maxHasBeenInvoked = (coreMaxInvocations ==\\n                    coreInvocations);\\n                emit ProjectMaxInvocationsLimitUpdated({\\n                    projectId: projectId,\\n                    coreContract: coreContract,\\n                    maxInvocations: coreMaxInvocations\\n                });\\n            } else if (coreInvocations >= localMaxInvocations) {\\n                // core invocations are greater than this minter's max\\n                // invocations, indicating that minting must have occurred on\\n                // another minter. update the minter's `maxHasBeenInvoked` to\\n                // true to prevent any false negatives on\\n                // `getMaxHasBeenInvoked'\\n                maxInvocationsProjectConfig.maxHasBeenInvoked = true;\\n                // @dev do not emit event, because we did not change the value\\n                // of minter-local max invocations\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Loads the MaxInvocationsProjectConfig for a given project and core\\n     * contract.\\n     * @param projectId Project Id to get config for\\n     * @param coreContract Core contract address to get config for\\n     */\\n    function getMaxInvocationsProjectConfig(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (MaxInvocationsProjectConfig storage) {\\n        return s().maxInvocationsProjectConfigs[coreContract][projectId];\\n    }\\n\\n    /**\\n     * @notice Return the storage struct for reading and writing. This library\\n     * uses a diamond storage pattern when managing storage.\\n     * @return storageStruct The MaxInvocationsLibStorage struct.\\n     */\\n    function s()\\n        internal\\n        pure\\n        returns (MaxInvocationsLibStorage storage storageStruct)\\n    {\\n        bytes32 position = MAX_INVOCATIONS_LIB_STORAGE_POSITION;\\n        assembly (\\\"memory-safe\\\") {\\n            storageStruct.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/minter-libs/SetPriceLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Art Blocks Set Price Minter Library\\n * @notice This library is designed for the Art Blocks platform. It provides a\\n * struct and functions that falicitate the configuring of projects that use a\\n * fixed-price minting model.\\n * @author Art Blocks Inc.\\n */\\n\\nlibrary SetPriceLib {\\n    /**\\n     * @notice Price per token updated for project `projectId` to\\n     * `pricePerToken`.\\n     * @param projectId Project Id price was updated for\\n     * @param coreContract Core contract address price was updated for\\n     * @param pricePerToken price per token, no decimals (e.g. in wei for ETH)\\n     */\\n    event PricePerTokenUpdated(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        uint256 indexed pricePerToken\\n    );\\n\\n    /**\\n     * @notice Price per token reset (unconfigured) for project `projectId`.\\n     * @param projectId Project Id price was reset for\\n     * @param coreContract Core contract address price was reset for\\n     */\\n    event PricePerTokenReset(\\n        uint256 indexed projectId,\\n        address indexed coreContract\\n    );\\n\\n    // position of Set Price Lib storage, using a diamond storage pattern\\n    // for this library\\n    bytes32 constant SET_PRICE_LIB_STORAGE_POSITION =\\n        keccak256(\\\"setpricelib.storage\\\");\\n\\n    // project-level variables\\n    /**\\n     * Struct used to store a project's currently configured price, and\\n     * whether or not the price has been configured.\\n     */\\n    struct SetPriceProjectConfig {\\n        // @dev The price is stored with no accounting for decimals. e.g. in\\n        // wei for ETH.\\n        uint248 pricePerToken; // 0 if not configured\\n        bool priceIsConfigured;\\n    }\\n\\n    // Diamond storage pattern is used in this library\\n    struct SetPriceLibStorage {\\n        mapping(address coreContract => mapping(uint256 projectId => SetPriceProjectConfig)) setPriceProjectConfigs;\\n    }\\n\\n    /**\\n     * @notice Updates the minter's price per token to be `pricePerToken`.\\n     * @dev Note that it is intentionally supported here that the configured\\n     * price may be explicitly set to `0`.\\n     * @param projectId Project Id to update price for\\n     * @param coreContract Core contract address to update price for\\n     * @param pricePerToken price per token, no decimals (e.g. in wei for ETH)\\n     */\\n    function updatePricePerToken(\\n        uint256 projectId,\\n        address coreContract,\\n        uint256 pricePerToken\\n    ) internal {\\n        SetPriceProjectConfig\\n            storage setPriceProjectConfig = getSetPriceProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // update storage with new values\\n        setPriceProjectConfig.pricePerToken = uint248(pricePerToken);\\n        setPriceProjectConfig.priceIsConfigured = true;\\n\\n        emit PricePerTokenUpdated({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            pricePerToken: pricePerToken\\n        });\\n    }\\n\\n    /**\\n     * @notice Resets the minter's price per token to be unconfigured.\\n     * @param projectId Project Id to reset price for\\n     * @param coreContract Core contract address to reset the price for\\n     */\\n    function resetPricePerToken(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal {\\n        // @dev all fields must be deleted, and none of them are a complex type\\n        // @dev getSetPriceProjectConfig not used, as deletion of storage\\n        // pointers is not supported\\n        delete s().setPriceProjectConfigs[coreContract][projectId];\\n\\n        emit PricePerTokenReset({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n    }\\n\\n    /**\\n     * @notice Checks that the minter's price per token is configured, and\\n     * returns the price per token.\\n     * Reverts if the price is not configured.\\n     * @param projectId Project Id to check and get price for\\n     * @param coreContract Core contract address to check and get price for\\n     * @return pricePerToken price per token, no decimals (e.g. in wei for ETH)\\n     */\\n    function preMintChecksAndGetPrice(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (uint256 pricePerToken) {\\n        SetPriceProjectConfig\\n            storage setPriceProjectConfig = getSetPriceProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n\\n        // require artist to have configured price of token on this minter\\n        require(\\n            setPriceProjectConfig.priceIsConfigured,\\n            \\\"Price not configured\\\"\\n        );\\n        return setPriceProjectConfig.pricePerToken;\\n    }\\n\\n    /**\\n     * @notice Loads the SetPriceProjectConfig for a given project and core contract.\\n     * @param projectId Project Id to get config for\\n     * @param coreContract Core contract address to get config for\\n     */\\n    function getSetPriceProjectConfig(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (SetPriceProjectConfig storage) {\\n        return s().setPriceProjectConfigs[coreContract][projectId];\\n    }\\n\\n    /**\\n     * @notice Return the storage struct for reading and writing. This library\\n     * uses a diamond storage pattern when managing storage.\\n     * @return storageStruct The SetPriceLibStorage struct.\\n     */\\n    function s()\\n        internal\\n        pure\\n        returns (SetPriceLibStorage storage storageStruct)\\n    {\\n        bytes32 position = SET_PRICE_LIB_STORAGE_POSITION;\\n        assembly (\\\"memory-safe\\\") {\\n            storageStruct.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/v0.8.x/minter-libs/SplitFundsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\npragma solidity ^0.8.0;\\n\\nimport {IMinterBaseV0} from \\\"../../../interfaces/v0.8.x/IMinterBaseV0.sol\\\";\\nimport {IGenArt721CoreContractV3_Base} from \\\"../../../interfaces/v0.8.x/IGenArt721CoreContractV3_Base.sol\\\";\\nimport {IGenArt721CoreContractV3} from \\\"../../../interfaces/v0.8.x/IGenArt721CoreContractV3.sol\\\";\\nimport {IGenArt721CoreContractV3_Engine} from \\\"../../../interfaces/v0.8.x/IGenArt721CoreContractV3_Engine.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Art Blocks Split Funds Library\\n * @notice This library is designed for the Art Blocks platform. It splits\\n * Ether (ETH) and ERC20 token funds among stakeholders, such as sender\\n * (if refund is applicable), providers, artists, and artists' additional\\n * payees.\\n * @author Art Blocks Inc.\\n */\\n\\nlibrary SplitFundsLib {\\n    /**\\n     * @notice Currency updated for project `projectId` to symbol\\n     * `currencySymbol` and address `currencyAddress`.\\n     * @param projectId Project ID currency was updated for\\n     * @param coreContract Core contract address currency was updated for\\n     * @param currencyAddress Currency address\\n     * @param currencySymbol Currency symbol\\n     */\\n    event ProjectCurrencyInfoUpdated(\\n        uint256 indexed projectId,\\n        address indexed coreContract,\\n        address indexed currencyAddress,\\n        string currencySymbol\\n    );\\n\\n    // position of Split Funds Lib storage, using a diamond storage pattern\\n    // for this library\\n    bytes32 constant SPLIT_FUNDS_LIB_STORAGE_POSITION =\\n        keccak256(\\\"splitfundslib.storage\\\");\\n\\n    // contract-level variables\\n    struct IsEngineCache {\\n        bool isEngine;\\n        bool isCached;\\n    }\\n\\n    // project-level variables\\n    struct SplitFundsProjectConfig {\\n        address currencyAddress; // address(0) if ETH\\n        string currencySymbol; // Assumed to be ETH if null\\n    }\\n\\n    // Diamond storage pattern is used in this library\\n    struct SplitFundsLibStorage {\\n        mapping(address coreContract => mapping(uint256 projectId => SplitFundsProjectConfig)) splitFundsProjectConfigs;\\n        mapping(address coreContract => IsEngineCache) isEngineCacheConfigs;\\n    }\\n\\n    /**\\n     * @notice splits ETH funds between sender (if refund), providers,\\n     * artist, and artist's additional payee for a token purchased on\\n     * project `projectId`.\\n     * WARNING: This function uses msg.value and msg.sender to determine\\n     * refund amounts, and therefore may not be applicable to all use cases\\n     * (e.g. do not use with Dutch Auctions with on-chain settlement).\\n     * @dev This function relies on msg.sender and msg.value, so it must be\\n     * called directly from the contract that is receiving the payment.\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     * @param projectId Project ID for which funds shall be split.\\n     * @param pricePerTokenInWei Current price of token, in Wei.\\n     * @param coreContract Address of the GenArt721CoreContract associated\\n     * with the project.\\n     */\\n    function splitFundsETHRefundSender(\\n        uint256 projectId,\\n        uint256 pricePerTokenInWei,\\n        address coreContract\\n    ) internal {\\n        if (msg.value > 0) {\\n            // send refund to sender\\n            uint256 refund = msg.value - pricePerTokenInWei;\\n            if (refund > 0) {\\n                (bool success_, ) = msg.sender.call{value: refund}(\\\"\\\");\\n                require(success_, \\\"Refund failed\\\");\\n            }\\n            // split revenues\\n            splitRevenuesETHNoRefund({\\n                projectId: projectId,\\n                valueInWei: pricePerTokenInWei,\\n                coreContract: coreContract\\n            });\\n        }\\n    }\\n\\n    /**\\n     * @notice Splits ETH revenues between providers, artist, and artist's\\n     * additional payee for revenue generated by project `projectId`.\\n     * This function does NOT refund msg.sender, and does NOT use msg.value\\n     * when determining the value to be split.\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     * @param projectId Project ID for which funds shall be split.\\n     * @param valueInWei Value to be split, in Wei.\\n     * @param coreContract Address of the GenArt721CoreContract\\n     * associated with the project.\\n     */\\n    function splitRevenuesETHNoRefund(\\n        uint256 projectId,\\n        uint256 valueInWei,\\n        address coreContract\\n    ) internal {\\n        if (valueInWei == 0) {\\n            return; // return early\\n        }\\n        // split funds between platforms, artist, and artist's\\n        // additional payee\\n        bool isEngine_ = isEngine(coreContract);\\n        uint256 renderProviderRevenue;\\n        address payable renderProviderAddress;\\n        uint256 platformProviderRevenue;\\n        address payable platformProviderAddress;\\n        uint256 artistRevenue;\\n        address payable artistAddress;\\n        uint256 additionalPayeePrimaryRevenue;\\n        address payable additionalPayeePrimaryAddress;\\n        if (isEngine_) {\\n            // get engine splits\\n            (\\n                renderProviderRevenue,\\n                renderProviderAddress,\\n                platformProviderRevenue,\\n                platformProviderAddress,\\n                artistRevenue,\\n                artistAddress,\\n                additionalPayeePrimaryRevenue,\\n                additionalPayeePrimaryAddress\\n            ) = IGenArt721CoreContractV3_Engine(coreContract)\\n                .getPrimaryRevenueSplits({\\n                    _projectId: projectId,\\n                    _price: valueInWei\\n                });\\n        } else {\\n            // get flagship splits\\n            // @dev note that platformProviderAddress and\\n            // platformProviderRevenue remain 0 for flagship\\n            (\\n                renderProviderRevenue, // artblocks revenue\\n                renderProviderAddress, // artblocks address\\n                artistRevenue,\\n                artistAddress,\\n                additionalPayeePrimaryRevenue,\\n                additionalPayeePrimaryAddress\\n            ) = IGenArt721CoreContractV3(coreContract).getPrimaryRevenueSplits({\\n                _projectId: projectId,\\n                _price: valueInWei\\n            });\\n        }\\n        // require total revenue split is 100%\\n        // @dev note that platformProviderRevenue remains 0 for flagship\\n        require(\\n            renderProviderRevenue +\\n                platformProviderRevenue +\\n                artistRevenue +\\n                additionalPayeePrimaryRevenue ==\\n                valueInWei,\\n            \\\"Invalid revenue split totals\\\"\\n        );\\n        // distribute revenues\\n        // @dev note that platformProviderAddress and platformProviderRevenue\\n        // remain 0 for flagship\\n        _sendPaymentsETH({\\n            platformProviderRevenue: platformProviderRevenue,\\n            platformProviderAddress: platformProviderAddress,\\n            renderProviderRevenue: renderProviderRevenue,\\n            renderProviderAddress: renderProviderAddress,\\n            artistRevenue: artistRevenue,\\n            artistAddress: artistAddress,\\n            additionalPayeePrimaryRevenue: additionalPayeePrimaryRevenue,\\n            additionalPayeePrimaryAddress: additionalPayeePrimaryAddress\\n        });\\n    }\\n\\n    /**\\n     * @notice Splits ERC20 funds between providers, artist, and artist's\\n     * additional payee, for a token purchased on project `projectId`.\\n     * The function performs checks to ensure that the ERC20 token is\\n     * approved for transfer, and that a non-zero ERC20 token address is\\n     * configured.\\n     * @dev This function relies on msg.sender, so it must be\\n     * called directly from the contract that is receiving the payment.\\n     * @dev possible DoS during splits is acknowledged, and mitigated by\\n     * business practices, including end-to-end testing on mainnet, and\\n     * admin-accepted artist payment addresses.\\n     * @param projectId Project ID for which funds shall be split.\\n     * @param pricePerToken Current price of token, in base units. For example,\\n     * if the ERC20 token has 6 decimals, an input value of `1_000_000` would\\n     * represent a price of `1.000000` tokens.\\n     * @param coreContract Core contract address.\\n     */\\n    function splitFundsERC20(\\n        uint256 projectId,\\n        uint256 pricePerToken,\\n        address coreContract\\n    ) internal {\\n        if (pricePerToken == 0) {\\n            return; // nothing to split, return early\\n        }\\n        IERC20 projectCurrency;\\n        // block scope to avoid stack too deep error\\n        {\\n            SplitFundsProjectConfig\\n                storage splitFundsProjectConfig = getSplitFundsProjectConfig({\\n                    projectId: projectId,\\n                    coreContract: coreContract\\n                });\\n            address currencyAddress = splitFundsProjectConfig.currencyAddress;\\n            require(\\n                currencyAddress != address(0),\\n                \\\"ERC20: payment not configured\\\"\\n            );\\n            // ERC20 token is used for payment\\n            validateERC20Approvals({\\n                msgSender: msg.sender,\\n                currencyAddress: currencyAddress,\\n                pricePerToken: pricePerToken\\n            });\\n            projectCurrency = IERC20(currencyAddress);\\n        }\\n        // split remaining funds between foundation, artist, and artist's\\n        bool isEngine_ = isEngine(coreContract);\\n        uint256 renderProviderRevenue;\\n        address payable renderProviderAddress;\\n        uint256 platformProviderRevenue;\\n        address payable platformProviderAddress;\\n        uint256 artistRevenue;\\n        address payable artistAddress;\\n        uint256 additionalPayeePrimaryRevenue;\\n        address payable additionalPayeePrimaryAddress;\\n        if (isEngine_) {\\n            // get engine splits\\n            (\\n                renderProviderRevenue,\\n                renderProviderAddress,\\n                platformProviderRevenue,\\n                platformProviderAddress,\\n                artistRevenue,\\n                artistAddress,\\n                additionalPayeePrimaryRevenue,\\n                additionalPayeePrimaryAddress\\n            ) = IGenArt721CoreContractV3_Engine(coreContract)\\n                .getPrimaryRevenueSplits({\\n                    _projectId: projectId,\\n                    _price: pricePerToken\\n                });\\n        } else {\\n            // get flagship splits\\n            // @dev note that platformProviderAddress and\\n            // platformProviderRevenue remain 0 for flagship\\n            (\\n                renderProviderRevenue, // artblocks revenue\\n                renderProviderAddress, // artblocks address\\n                artistRevenue,\\n                artistAddress,\\n                additionalPayeePrimaryRevenue,\\n                additionalPayeePrimaryAddress\\n            ) = IGenArt721CoreContractV3(coreContract).getPrimaryRevenueSplits({\\n                _projectId: projectId,\\n                _price: pricePerToken\\n            });\\n        }\\n        // require total revenue split is 100%\\n        // @dev note that platformProviderRevenue remains 0 for flagship\\n        require(\\n            renderProviderRevenue +\\n                platformProviderRevenue +\\n                artistRevenue +\\n                additionalPayeePrimaryRevenue ==\\n                pricePerToken,\\n            \\\"Invalid revenue split totals\\\"\\n        );\\n        // distribute revenues\\n        // @dev note that platformProviderAddress and platformProviderRevenue\\n        // remain 0 for flagship\\n        _sendPaymentsERC20({\\n            projectCurrency: projectCurrency,\\n            platformProviderRevenue: platformProviderRevenue,\\n            platformProviderAddress: platformProviderAddress,\\n            renderProviderRevenue: renderProviderRevenue,\\n            renderProviderAddress: renderProviderAddress,\\n            artistRevenue: artistRevenue,\\n            artistAddress: artistAddress,\\n            additionalPayeePrimaryRevenue: additionalPayeePrimaryRevenue,\\n            additionalPayeePrimaryAddress: additionalPayeePrimaryAddress\\n        });\\n    }\\n\\n    /**\\n     * @notice Updates payment currency of the referenced\\n     * SplitFundsProjectConfig to be `currencySymbol` at address\\n     * `currencyAddress`.\\n     * Only supports setting currency info of ERC20 tokens.\\n     * Returns bool that is true if the price should be reset after this\\n     * update. Price is recommended to be reset if the currency address was\\n     * previously configured, but is now being updated to a different currency\\n     * address. This is to protect accidental price reductions when changing\\n     * currency if an artist is changing currencies in an unpaused state.\\n     * @dev artist-defined currency symbol is used instead of any on-chain\\n     * currency symbol.\\n     * @param projectId Project ID to update.\\n     * @param coreContract Core contract address.\\n     * @param currencySymbol Currency symbol.\\n     * @param currencyAddress Currency address.\\n     * @return recommendPriceReset True if the price should be reset after this\\n     * update.\\n     */\\n    function updateProjectCurrencyInfoERC20(\\n        uint256 projectId,\\n        address coreContract,\\n        string memory currencySymbol,\\n        address currencyAddress\\n    ) internal returns (bool recommendPriceReset) {\\n        // CHECKS\\n        require(currencyAddress != address(0), \\\"null address, only ERC20\\\");\\n        require(bytes(currencySymbol).length > 0, \\\"only non-null symbol\\\");\\n        // EFFECTS\\n        SplitFundsProjectConfig\\n            storage splitFundsProjectConfig = getSplitFundsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        // recommend price reset if currency address was previously configured\\n        recommendPriceReset = (splitFundsProjectConfig.currencyAddress !=\\n            address(0));\\n        splitFundsProjectConfig.currencySymbol = currencySymbol;\\n        splitFundsProjectConfig.currencyAddress = currencyAddress;\\n\\n        emit ProjectCurrencyInfoUpdated({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            currencyAddress: currencyAddress,\\n            currencySymbol: currencySymbol\\n        });\\n    }\\n\\n    /**\\n     * @notice Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n     * equal to `minterRefundGasLimit`.\\n     * If sending via the normal procedure fails, force sends the ETH by\\n     * creating a temporary contract which uses `SELFDESTRUCT` to force send\\n     * the ETH.\\n     * Reverts if the current contract has insufficient balance.\\n     * @param to The address to send ETH to.\\n     * @param amount The amount of ETH to send.\\n     * @param minterRefundGasLimit The gas limit to use when sending ETH, prior\\n     * to fallback.\\n     * @dev This function is adapted from the `forceSafeTransferETH` function\\n     * in the `https://github.com/Vectorized/solady` repository, with\\n     * modifications to not check if the current contract has sufficient\\n     * balance. Therefore, the contract should be checked for sufficient\\n     * balance before calling this function in the minter itself, if\\n     * applicable.\\n     */\\n    function forceSafeTransferETH(\\n        address to,\\n        uint256 amount,\\n        uint256 minterRefundGasLimit\\n    ) internal {\\n        // Manually inlined because the compiler doesn't inline functions with\\n        // branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // @dev intentionally do not check if this contract has sufficient\\n            // balance, because that is not intended to be a valid state.\\n\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(minterRefundGasLimit, to, amount, 0, 0, 0, 0)) {\\n                // if the transfer failed, we create a temporary contract with\\n                // initialization code that uses `SELFDESTRUCT` to force send\\n                // the ETH.\\n                // note: Compatible with `SENDALL`:\\n                // https://eips.ethereum.org/EIPS/eip-4758\\n\\n                //---------------------------------------------------------------------------------------------------------------//\\n                // Opcode  | Opcode + Arguments  | Description        | Stack View                                               //\\n                //---------------------------------------------------------------------------------------------------------------//\\n                // Contract creation code that uses `SELFDESTRUCT` to force send ETH to a specified address.                     //\\n                // Creation code summary: 0x73<20-byte toAddress>0xff                                                            //\\n                //---------------------------------------------------------------------------------------------------------------//\\n                // 0x73    |  0x73_toAddress     | PUSH20 toAddress   | toAddress                                                //\\n                // 0xFF    |  0xFF               | SELFDESTRUCT       |                                                          //\\n                //---------------------------------------------------------------------------------------------------------------//\\n                // Store the address in scratch space, starting at 0x00, which begins the 20-byte address at 32-20=12 in memory\\n                // @dev use scratch space because we have enough space for simple creation code (less than 0x40 bytes)\\n                mstore(0x00, to)\\n                // store opcode PUSH20 immediately before the address, starting at 0x0b (11) in memory\\n                mstore8(0x0b, 0x73)\\n                // store opcode SELFDESTRUCT immediately after the address, starting at 0x20 (32) in memory\\n                mstore8(0x20, 0xff)\\n                // this will always succeed because the contract creation code is\\n                // valid, and the address is valid because it is a 20-byte value\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // @dev For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) {\\n                        revert(0, 0)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns whether or not the provided address `coreContract`\\n     * is an Art Blocks Engine core contract. Caches the result for future access.\\n     * @param coreContract Address of the core contract to check.\\n     */\\n    function isEngine(address coreContract) internal returns (bool) {\\n        IsEngineCache storage isEngineCache = getIsEngineCacheConfig(\\n            coreContract\\n        );\\n        // check cache, return early if cached\\n        if (isEngineCache.isCached) {\\n            return isEngineCache.isEngine;\\n        }\\n        // populate cache and return result\\n        bool isEngine_ = getV3CoreIsEngineView(coreContract);\\n        isEngineCache.isCached = true;\\n        isEngineCache.isEngine = isEngine_;\\n        return isEngine_;\\n    }\\n\\n    /**\\n     * @notice Returns whether a V3 core contract is an Art Blocks Engine\\n     * contract or not. Return value of false indicates that the core is a\\n     * flagship contract. This function does not update the cache state for the\\n     * given V3 core contract.\\n     * @dev this function reverts if a core contract does not return the\\n     * expected number of return values from getPrimaryRevenueSplits() for\\n     * either a flagship or engine core contract.\\n     * @dev this function uses the length of the return data (in bytes) to\\n     * determine whether the core is an engine or not.\\n     * @param coreContract The address of the deployed core contract.\\n     */\\n    function getV3CoreIsEngineView(\\n        address coreContract\\n    ) internal view returns (bool) {\\n        // call getPrimaryRevenueSplits() on core contract\\n        bytes memory payload = abi.encodeWithSignature(\\n            \\\"getPrimaryRevenueSplits(uint256,uint256)\\\",\\n            0,\\n            0\\n        );\\n        (bool success, bytes memory returnData) = coreContract.staticcall(\\n            payload\\n        );\\n        require(success, \\\"getPrimaryRevenueSplits() call failed\\\");\\n        // determine whether core is engine or not, based on return data length\\n        uint256 returnDataLength = returnData.length;\\n        if (returnDataLength == 6 * 32) {\\n            // 6 32-byte words returned if flagship (not engine)\\n            // @dev 6 32-byte words are expected because the non-engine core\\n            // contracts return a payout address and uint256 payment value for\\n            // the artist, and artist's additional payee, and Art Blocks.\\n            // also note that per Solidity ABI encoding, the address return\\n            // values are padded to 32 bytes.\\n\\n            return false;\\n        } else if (returnDataLength == 8 * 32) {\\n            // 8 32-byte words returned if engine\\n            // @dev 8 32-byte words are expected because the engine core\\n            // contracts return a payout address and uint256 payment value for\\n            // the artist, artist's additional payee, render provider\\n            // typically Art Blocks, and platform provider (partner).\\n            // also note that per Solidity ABI encoding, the address return\\n            // values are padded to 32 bytes.\\n            return true;\\n        }\\n        // unexpected return value length\\n        revert(\\\"Unexpected revenue split bytes\\\");\\n    }\\n\\n    /**\\n     * @notice Gets the currency address and symbol for the referenced\\n     * SplitFundsProjectConfig.\\n     * Only supports ERC20 tokens - returns currencySymbol of `UNCONFIG` if\\n     * `currencyAddress` is zero.\\n     * @param projectId Project ID to get config for\\n     * @param coreContract Core contract address to get config for\\n     * @return currencyAddress\\n     * @return currencySymbol\\n     */\\n    function getCurrencyInfoERC20(\\n        uint256 projectId,\\n        address coreContract\\n    )\\n        internal\\n        view\\n        returns (address currencyAddress, string memory currencySymbol)\\n    {\\n        SplitFundsProjectConfig\\n            storage splitFundsProjectConfig = getSplitFundsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        currencyAddress = splitFundsProjectConfig.currencyAddress;\\n        // default to \\\"UNCONFIG\\\" if project currency address is initial value\\n        currencySymbol = currencyAddress == address(0)\\n            ? \\\"UNCONFIG\\\"\\n            : splitFundsProjectConfig.currencySymbol;\\n    }\\n\\n    /**\\n     * @notice Gets the balance of `currencyAddress` ERC20 tokens for `walletAddress`.\\n     * @param currencyAddress ERC20 token address.\\n     * @param walletAddress wallet address.\\n     * @return balance\\n     */\\n    function getERC20Balance(\\n        address currencyAddress,\\n        address walletAddress\\n    ) internal view returns (uint256) {\\n        return IERC20(currencyAddress).balanceOf(walletAddress);\\n    }\\n\\n    /**\\n     * @notice Gets the allowance of `spenderAddress` to spend `walletAddress`'s\\n     * `currencyAddress` ERC20 tokens.\\n     * @param currencyAddress ERC20 token address.\\n     * @param walletAddress wallet address.\\n     * @param spenderAddress spender address.\\n     * @return allowance\\n     */\\n    function getERC20Allowance(\\n        address currencyAddress,\\n        address walletAddress,\\n        address spenderAddress\\n    ) internal view returns (uint256 allowance) {\\n        allowance = IERC20(currencyAddress).allowance({\\n            owner: walletAddress,\\n            spender: spenderAddress\\n        });\\n        return allowance;\\n    }\\n\\n    /**\\n     * @notice Function validates that `msgSender` has approved the contract to spend at least\\n     * `pricePerToken` of `currencyAddress` ERC20 tokens, and that\\n     * `msgSender` has a balance of at least `pricePerToken` of\\n     * `currencyAddress` ERC20 tokens.\\n     * Reverts if insufficient allowance or balance.\\n     * @param msgSender Address of the message sender to validate.\\n     * @param currencyAddress Address of the ERC20 token to validate.\\n     * @param pricePerToken Price of token, in base units. For example,\\n     * if the ERC20 token has 6 decimals, an input value of `1_000_000` would\\n     * represent a price of `1.000000` tokens.\\n     */\\n    function validateERC20Approvals(\\n        address msgSender,\\n        address currencyAddress,\\n        uint256 pricePerToken\\n    ) private view {\\n        require(\\n            IERC20(currencyAddress).allowance({\\n                owner: msgSender,\\n                spender: address(this)\\n            }) >= pricePerToken,\\n            \\\"Insufficient ERC20 allowance\\\"\\n        );\\n        require(\\n            IERC20(currencyAddress).balanceOf(msgSender) >= pricePerToken,\\n            \\\"Insufficient ERC20 balance\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Sends ETH revenues between providers, artist, and artist's\\n     * additional payee. Reverts if any payment fails.\\n     * @dev This function pays priviliged addresses. DoS is acknowledged, and\\n     * mitigated by business practices, including end-to-end testing on\\n     * mainnet, and admin-accepted artist payment addresses.\\n     * @param platformProviderRevenue Platform Provider revenue.\\n     * @param platformProviderAddress Platform Provider address.\\n     * @param renderProviderRevenue Render Provider revenue.\\n     * @param renderProviderAddress Render Provider address.\\n     * @param artistRevenue Artist revenue.\\n     * @param artistAddress Artist address.\\n     * @param additionalPayeePrimaryRevenue Additional Payee revenue.\\n     * @param additionalPayeePrimaryAddress Additional Payee address.\\n     */\\n    function _sendPaymentsETH(\\n        uint256 platformProviderRevenue,\\n        address payable platformProviderAddress,\\n        uint256 renderProviderRevenue,\\n        address payable renderProviderAddress,\\n        uint256 artistRevenue,\\n        address payable artistAddress,\\n        uint256 additionalPayeePrimaryRevenue,\\n        address payable additionalPayeePrimaryAddress\\n    ) private {\\n        // Platform Provider payment (only possible if engine)\\n        if (platformProviderRevenue > 0) {\\n            (bool success, ) = platformProviderAddress.call{\\n                value: platformProviderRevenue\\n            }(\\\"\\\");\\n            require(success, \\\"Platform Provider payment failed\\\");\\n        }\\n        // Render Provider / Art Blocks payment\\n        if (renderProviderRevenue > 0) {\\n            (bool success, ) = renderProviderAddress.call{\\n                value: renderProviderRevenue\\n            }(\\\"\\\");\\n            require(success, \\\"Render Provider payment failed\\\");\\n        }\\n        // artist payment\\n        if (artistRevenue > 0) {\\n            (bool success, ) = artistAddress.call{value: artistRevenue}(\\\"\\\");\\n            require(success, \\\"Artist payment failed\\\");\\n        }\\n        // additional payee payment\\n        if (additionalPayeePrimaryRevenue > 0) {\\n            (bool success, ) = additionalPayeePrimaryAddress.call{\\n                value: additionalPayeePrimaryRevenue\\n            }(\\\"\\\");\\n            require(success, \\\"Additional Payee payment failed\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Sends ERC20 revenues between providers, artist, and artist's\\n     * additional payee. Reverts if any payment fails. All revenue values\\n     * should use base units. For example, if the ERC20 token has 6 decimals,\\n     * an input value of `1_000_000` would represent an amount of `1.000000`\\n     * tokens.\\n     * @dev This function relies on msg.sender, so it must be called from\\n     * the contract that is receiving the payment.\\n     * @param projectCurrency IERC20 payment token.\\n     * @param platformProviderRevenue Platform Provider revenue.\\n     * @param platformProviderAddress Platform Provider address.\\n     * @param renderProviderRevenue Render Provider revenue.\\n     * @param renderProviderAddress Render Provider address.\\n     * @param artistRevenue Artist revenue.\\n     * @param artistAddress Artist address.\\n     * @param additionalPayeePrimaryRevenue Additional Payee revenue.\\n     * @param additionalPayeePrimaryAddress Additional Payee address.\\n     */\\n    function _sendPaymentsERC20(\\n        IERC20 projectCurrency,\\n        uint256 platformProviderRevenue,\\n        address payable platformProviderAddress,\\n        uint256 renderProviderRevenue,\\n        address payable renderProviderAddress,\\n        uint256 artistRevenue,\\n        address payable artistAddress,\\n        uint256 additionalPayeePrimaryRevenue,\\n        address payable additionalPayeePrimaryAddress\\n    ) private {\\n        // Platform Provider payment (only possible if engine)\\n        if (platformProviderRevenue > 0) {\\n            require(\\n                projectCurrency.transferFrom({\\n                    from: msg.sender,\\n                    to: platformProviderAddress,\\n                    amount: platformProviderRevenue\\n                }),\\n                \\\"Platform Provider payment failed\\\"\\n            );\\n        }\\n        // Art Blocks payment\\n        if (renderProviderRevenue > 0) {\\n            require(\\n                projectCurrency.transferFrom({\\n                    from: msg.sender,\\n                    to: renderProviderAddress,\\n                    amount: renderProviderRevenue\\n                }),\\n                \\\"Render Provider payment failed\\\"\\n            );\\n        }\\n        // artist payment\\n        if (artistRevenue > 0) {\\n            require(\\n                projectCurrency.transferFrom({\\n                    from: msg.sender,\\n                    to: artistAddress,\\n                    amount: artistRevenue\\n                }),\\n                \\\"Artist payment failed\\\"\\n            );\\n        }\\n        // additional payee payment\\n        if (additionalPayeePrimaryRevenue > 0) {\\n            // @dev some ERC20 may not revert on transfer failure, so we\\n            // check the return value\\n            require(\\n                projectCurrency.transferFrom({\\n                    from: msg.sender,\\n                    to: additionalPayeePrimaryAddress,\\n                    amount: additionalPayeePrimaryRevenue\\n                }),\\n                \\\"Additional Payee payment failed\\\"\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Loads the SplitFundsProjectConfig for a given project and core\\n     * contract.\\n     * @param projectId Project Id to get config for\\n     * @param coreContract Core contract address to get config for\\n     */\\n    function getSplitFundsProjectConfig(\\n        uint256 projectId,\\n        address coreContract\\n    ) internal view returns (SplitFundsProjectConfig storage) {\\n        return s().splitFundsProjectConfigs[coreContract][projectId];\\n    }\\n\\n    /**\\n     * @notice Loads the IsEngineCache for a given core contract.\\n     * @param coreContract Core contract address to get config for\\n     */\\n    function getIsEngineCacheConfig(\\n        address coreContract\\n    ) internal view returns (IsEngineCache storage) {\\n        return s().isEngineCacheConfigs[coreContract];\\n    }\\n\\n    /**\\n     * @notice Return the storage struct for reading and writing. This library\\n     * uses a diamond storage pattern when managing storage.\\n     * @return storageStruct The SetPriceLibStorage struct.\\n     */\\n    function s()\\n        internal\\n        pure\\n        returns (SplitFundsLibStorage storage storageStruct)\\n    {\\n        bytes32 position = SPLIT_FUNDS_LIB_STORAGE_POSITION;\\n        assembly (\\\"memory-safe\\\") {\\n            storageStruct.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/minter-suite/Minters/MinterSetPriceERC20V5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n// Created By: Art Blocks Inc.\\n\\n// @dev fixed to specific solidity version for clarity and for more clear\\n// source code verification purposes.\\npragma solidity 0.8.19;\\n\\nimport {ISharedMinterV0} from \\\"../../interfaces/v0.8.x/ISharedMinterV0.sol\\\";\\nimport {IMinterFilterV1} from \\\"../../interfaces/v0.8.x/IMinterFilterV1.sol\\\";\\n\\nimport {AuthLib} from \\\"../../libs/v0.8.x/AuthLib.sol\\\";\\nimport {SplitFundsLib} from \\\"../../libs/v0.8.x/minter-libs/SplitFundsLib.sol\\\";\\nimport {MaxInvocationsLib} from \\\"../../libs/v0.8.x/minter-libs/MaxInvocationsLib.sol\\\";\\nimport {SetPriceLib} from \\\"../../libs/v0.8.x/minter-libs/SetPriceLib.sol\\\";\\n\\nimport {ReentrancyGuard} from \\\"@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol\\\";\\n\\n/**\\n * @title Shared, filtered Minter contract that allows tokens to be minted with\\n * artist-configured ERC20 tokens.\\n * This is designed to be used with GenArt721CoreContractV3 flagship or\\n * engine contracts.\\n * @author Art Blocks Inc.\\n * @notice Privileged Roles and Ownership:\\n * This contract is designed to be managed, with limited powers.\\n * Privileged roles and abilities are controlled by the project's artist, which\\n * can be modified by the core contract's Admin ACL contract. Both of these\\n * roles hold extensive power and can modify minter details.\\n * Care must be taken to ensure that the admin ACL contract and artist\\n * addresses are secure behind a multi-sig or other access control mechanism.\\n * ----------------------------------------------------------------------------\\n * The following functions are restricted to a project's artist:\\n * - updatePricePerTokenInWei\\n * - updateProjectCurrencyInfo\\n * - setProjectMaxInvocations\\n * - syncProjectMaxInvocationsToCore\\n * - manuallyLimitProjectMaxInvocations\\n * ----------------------------------------------------------------------------\\n * Additional admin and artist privileged roles may be described on other\\n * contracts that this minter integrates with.\\n * ----------------------------------------------------------------------------\\n * @notice Caution: While Engine projects must be registered on the Art Blocks\\n * Core Registry to assign this minter, this minter does not enforce that a\\n * project is registered when configured or queried. This is primarily for gas\\n * optimization purposes. It is, therefore, possible that fake projects may be\\n * configured on this minter, but they will not be able to mint tokens due to\\n * checks performed by this minter's Minter Filter.\\n */\\ncontract MinterSetPriceERC20V5 is ReentrancyGuard, ISharedMinterV0 {\\n    /// Minter filter address this minter interacts with\\n    address public immutable minterFilterAddress;\\n\\n    /// Minter filter this minter may interact with.\\n    IMinterFilterV1 private immutable _minterFilter;\\n\\n    /// minterType for this minter\\n    string public constant minterType = \\\"MinterSetPriceERC20V5\\\";\\n\\n    /// minter version for this minter\\n    string public constant minterVersion = \\\"v5.0.0\\\";\\n\\n    // MODIFIERS\\n    // @dev contract uses modifier-like internal functions instead of modifiers\\n    // to reduce contract bytecode size\\n    // @dev contract uses AuthLib for some modifier-like functions\\n\\n    /**\\n     * @notice Initializes contract to be a Filtered Minter for\\n     * `minterFilter` minter filter.\\n     * @param minterFilter Minter filter for which this will be a\\n     * filtered minter.\\n     */\\n    constructor(address minterFilter) ReentrancyGuard() {\\n        minterFilterAddress = minterFilter;\\n        _minterFilter = IMinterFilterV1(minterFilter);\\n    }\\n\\n    /**\\n     * @notice Manually sets the local maximum invocations of project `projectId`\\n     * with the provided `maxInvocations`, checking that `maxInvocations` is less\\n     * than or equal to the value of project `project_id`'s maximum invocations that is\\n     * set on the core contract.\\n     * @dev Note that a `maxInvocations` of 0 can only be set if the current `invocations`\\n     * value is also 0 and this would also set `maxHasBeenInvoked` to true, correctly short-circuiting\\n     * this minter's purchase function, avoiding extra gas costs from the core contract's maxInvocations check.\\n     * @param projectId Project ID to set the maximum invocations for.\\n     * @param coreContract Core contract address for the given project.\\n     * @param maxInvocations Maximum invocations to set for the project.\\n     */\\n    function manuallyLimitProjectMaxInvocations(\\n        uint256 projectId,\\n        address coreContract,\\n        uint24 maxInvocations\\n    ) external {\\n        AuthLib.onlyArtist({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            sender: msg.sender\\n        });\\n        MaxInvocationsLib.manuallyLimitProjectMaxInvocations({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            maxInvocations: maxInvocations\\n        });\\n    }\\n\\n    /**\\n     * @notice Updates this minter's price per token of project `projectId`\\n     * to be `pricePerTokenInWei`. Note that \\\"in wei\\\" is a misnomer on this\\n     * ERC20 minter, but is used for consistency with the ETH minters. The\\n     * price value represents the ERC20 token price in base units.\\n     * @dev Note that it is intentionally supported here that the configured\\n     * price may be explicitly set to `0`.\\n     * @param projectId Project ID to set the price per token for.\\n     * @param coreContract Core contract address for the given project.\\n     * @param pricePerTokenInWei Price per token to set for the project.\\n     * Represents the ERC20 token price in base units. For example, if the\\n     * ERC20 token has 6 decimals, an input value of `1_000_000` would\\n     * represent a price of `1.000000` tokens.\\n     */\\n    function updatePricePerTokenInWei(\\n        uint256 projectId,\\n        address coreContract,\\n        uint248 pricePerTokenInWei\\n    ) external {\\n        AuthLib.onlyArtist({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            sender: msg.sender\\n        });\\n        SetPriceLib.updatePricePerToken({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            pricePerToken: pricePerTokenInWei\\n        });\\n\\n        // for convenience, sync local max invocations to the core contract if\\n        // and only if max invocations have not already been synced.\\n        // @dev do not sync if max invocations have already been synced, as\\n        // local max invocations could have been manually set to be\\n        // intentionally less than the core contract's max invocations.\\n        // @dev if local maxInvocations and maxHasBeenInvoked are both\\n        // initial values, we know they have not been populated on this minter\\n        if (\\n            MaxInvocationsLib.maxInvocationsIsUnconfigured({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            })\\n        ) {\\n            MaxInvocationsLib.syncProjectMaxInvocationsToCore({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates payment currency of project `projectId` on core\\n     * contract `coreContract` to be `currencySymbol` at address\\n     * `currencyAddress`.\\n     * Only supports ERC20 tokens - for ETH minting, use a different minter.\\n     * Resets price to be unconfigured if currency was previously configured,\\n     * as a safeguard against accidentally setting a price in one currency\\n     * and then changing the currency but not the price.\\n     * @dev nonReentrant because no reentrant use cases, and to eliminate an\\n     * entire branch of reentrancy attack vectors.\\n     * @param projectId Project ID to update.\\n     * @param coreContract Core contract address for the given project.\\n     * @param currencySymbol Currency symbol.\\n     * @param currencyAddress Currency address.\\n     */\\n    function updateProjectCurrencyInfo(\\n        uint256 projectId,\\n        address coreContract,\\n        string memory currencySymbol,\\n        address currencyAddress\\n    ) external nonReentrant {\\n        AuthLib.onlyArtist({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            sender: msg.sender\\n        });\\n        bool recommendPriceReset = SplitFundsLib\\n            .updateProjectCurrencyInfoERC20({\\n                projectId: projectId,\\n                coreContract: coreContract,\\n                currencySymbol: currencySymbol,\\n                currencyAddress: currencyAddress\\n            });\\n        if (recommendPriceReset) {\\n            SetPriceLib.resetPricePerToken({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n        }\\n    }\\n\\n    /**\\n     * @notice Purchases a token from project `projectId`.\\n     * @param projectId Project ID to mint a token on.\\n     * @param coreContract Core contract address for the given project.\\n     * @param maxPricePerToken Maximum price of token being allowed by the\\n     * purchaser, in base units. For example, if the ERC20 token has 6\\n     * decimals, an input value of `1_000_000` would represent a maximum price\\n     * of `1.000000` tokens.\\n     * @param currencyAddress Currency address of token.\\n     * @return tokenId Token ID of minted token\\n     */\\n    function purchase(\\n        uint256 projectId,\\n        address coreContract,\\n        uint256 maxPricePerToken,\\n        address currencyAddress\\n    ) external returns (uint256 tokenId) {\\n        tokenId = purchaseTo({\\n            to: msg.sender,\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            maxPricePerToken: maxPricePerToken,\\n            currencyAddress: currencyAddress\\n        });\\n        return tokenId;\\n    }\\n\\n    // public getter functions\\n    /**\\n     * @notice Gets the maximum invocations project configuration.\\n     * @param projectId The ID of the project whose data needs to be fetched.\\n     * @param coreContract The address of the core contract.\\n     * @return MaxInvocationsLib.MaxInvocationsProjectConfig instance with the\\n     * configuration data.\\n     */\\n    function maxInvocationsProjectConfig(\\n        uint256 projectId,\\n        address coreContract\\n    )\\n        external\\n        view\\n        returns (MaxInvocationsLib.MaxInvocationsProjectConfig memory)\\n    {\\n        return\\n            MaxInvocationsLib.getMaxInvocationsProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n    }\\n\\n    /**\\n     * @notice Gets the set price project configuration.\\n     * @param projectId The ID of the project whose data needs to be fetched.\\n     * @param coreContract The address of the core contract.\\n     * @return SetPriceProjectConfig struct with the fixed price project\\n     * configuration data.\\n     */\\n    function setPriceProjectConfig(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (SetPriceLib.SetPriceProjectConfig memory) {\\n        return\\n            SetPriceLib.getSetPriceProjectConfig({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n    }\\n\\n    /**\\n     * @notice Checks if the specified `coreContract` is a valid engine contract.\\n     * @dev This function retrieves the cached value of `isEngine` from\\n     * the `isEngineCache` mapping. If the cached value is already set, it\\n     * returns the cached value. Otherwise, it calls the `getV3CoreIsEngineView`\\n     * function from the `SplitFundsLib` library to check if `coreContract`\\n     * is a valid engine contract.\\n     * @dev This function will revert if the provided `coreContract` is not\\n     * a valid Engine or V3 Flagship contract.\\n     * @param coreContract The address of the contract to check.\\n     * @return bool indicating if `coreContract` is a valid engine contract.\\n     */\\n    function isEngineView(address coreContract) external view returns (bool) {\\n        SplitFundsLib.IsEngineCache storage isEngineCache = SplitFundsLib\\n            .getIsEngineCacheConfig(coreContract);\\n        if (isEngineCache.isCached) {\\n            return isEngineCache.isEngine;\\n        } else {\\n            // @dev this calls the non-state-modifying variant of isEngine\\n            return SplitFundsLib.getV3CoreIsEngineView(coreContract);\\n        }\\n    }\\n\\n    /**\\n     * @notice projectId => has project reached its maximum number of\\n     * invocations? Note that this returns a local cache of the core contract's\\n     * state, and may be out of sync with the core contract. This is\\n     * intentional, as it only enables gas optimization of mints after a\\n     * project's maximum invocations has been reached. A false negative will\\n     * only result in a gas cost increase, since the core contract will still\\n     * enforce a maxInvocation check during minting. A false positive is not\\n     * possible because the V3 core contract only allows maximum invocations\\n     * to be reduced, not increased. Based on this rationale, we intentionally\\n     * do not do input validation in this method as to whether or not the input\\n     * @param projectId is an existing project ID.\\n     * @param coreContract is an existing core contract address.\\n     */\\n    function projectMaxHasBeenInvoked(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (bool) {\\n        return\\n            MaxInvocationsLib.getMaxHasBeenInvoked({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n    }\\n\\n    /**\\n     * @notice projectId => project's maximum number of invocations.\\n     * Optionally synced with core contract value, for gas optimization.\\n     * Note that this returns a local cache of the core contract's\\n     * state, and may be out of sync with the core contract. This is\\n     * intentional, as it only enables gas optimization of mints after a\\n     * project's maximum invocations has been reached.\\n     * @dev A number greater than the core contract's project max invocations\\n     * will only result in a gas cost increase, since the core contract will\\n     * still enforce a maxInvocation check during minting. A number less than\\n     * the core contract's project max invocations is only possible when the\\n     * project's max invocations have not been synced on this minter, since the\\n     * V3 core contract only allows maximum invocations to be reduced, not\\n     * increased. When this happens, the minter will enable minting, allowing\\n     * the core contract to enforce the max invocations check. Based on this\\n     * rationale, we intentionally do not do input validation in this method as\\n     * to whether or not the input `projectId` is an existing project ID.\\n     * @param projectId is an existing project ID.\\n     * @param coreContract is an existing core contract address.\\n     */\\n    function projectMaxInvocations(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (uint256) {\\n        return\\n            MaxInvocationsLib.getMaxInvocations({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n    }\\n\\n    /**\\n     * @notice Gets your balance of the ERC20 token currently set\\n     * as the payment currency for project `projectId` in the core\\n     * contract `coreContract`.\\n     * @param projectId Project ID to be queried.\\n     * @param coreContract The address of the core contract.\\n     * @return balance Balance of ERC20\\n     */\\n    function getYourBalanceOfProjectERC20(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (uint256 balance) {\\n        (address currencyAddress, ) = SplitFundsLib.getCurrencyInfoERC20({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n        balance = SplitFundsLib.getERC20Balance({\\n            currencyAddress: currencyAddress,\\n            walletAddress: msg.sender\\n        });\\n        return balance;\\n    }\\n\\n    /**\\n     * @notice Gets your allowance for this minter of the ERC20\\n     * token currently set as the payment currency for project\\n     * `projectId`.\\n     * @param projectId Project ID to be queried.\\n     * @param coreContract The address of the core contract.\\n     * @return remaining Remaining allowance of ERC20\\n     */\\n    function checkYourAllowanceOfProjectERC20(\\n        uint256 projectId,\\n        address coreContract\\n    ) external view returns (uint256 remaining) {\\n        (address currencyAddress, ) = SplitFundsLib.getCurrencyInfoERC20({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n        remaining = SplitFundsLib.getERC20Allowance({\\n            currencyAddress: currencyAddress,\\n            walletAddress: msg.sender,\\n            spenderAddress: address(this)\\n        });\\n        return remaining;\\n    }\\n\\n    /**\\n     * @notice Gets if price of token is configured, price of minting a\\n     * token on project `projectId`, and currency symbol and address to be\\n     * used as payment.\\n     * `isConfigured` is only true if a price has been configured, and an ERC20\\n     * token has been configured.\\n     * @param projectId Project ID to get price information for\\n     * @param coreContract Contract address of the core contract\\n     * @return isConfigured true only if token price has been configured on\\n     * this minter and an ERC20 token has been configured\\n     * @return tokenPriceInWei current price of token on this minter - invalid\\n     * if price has not yet been configured. Note that \\\"in wei\\\" is a misnomer\\n     * for ERC20 tokens, but is used here for ABI consistency with the ETH\\n     * minters. The value returned represents the price per token in base units.\\n     * For example, if the ERC20 token has 6 decimals, an input value of\\n     * `1_000_000` would represent a price of `1.000000` tokens.\\n     * @return currencySymbol currency symbol for purchases of project on this\\n     * minter. \\\"UNCONFIG\\\" if not yet configured. Note that currency symbol is\\n     * defined by the artist, and is not necessarily the same as the ERC20\\n     * token symbol on-chain.\\n     * @return currencyAddress currency address for purchases of project on\\n     * this minter. Null address if not yet configured.\\n     */\\n    function getPriceInfo(\\n        uint256 projectId,\\n        address coreContract\\n    )\\n        external\\n        view\\n        returns (\\n            bool isConfigured,\\n            uint256 tokenPriceInWei,\\n            string memory currencySymbol,\\n            address currencyAddress\\n        )\\n    {\\n        SetPriceLib.SetPriceProjectConfig\\n            storage setPriceProjectConfig_ = SetPriceLib\\n                .getSetPriceProjectConfig({\\n                    projectId: projectId,\\n                    coreContract: coreContract\\n                });\\n        tokenPriceInWei = setPriceProjectConfig_.pricePerToken;\\n        (currencyAddress, currencySymbol) = SplitFundsLib.getCurrencyInfoERC20({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n        // report if price and ERC20 token are configured\\n        // @dev currencyAddress is non-zero if an ERC20 token is configured\\n        isConfigured =\\n            setPriceProjectConfig_.priceIsConfigured &&\\n            currencyAddress != address(0);\\n    }\\n\\n    /**\\n     * @notice Syncs local maximum invocations of project `projectId` based on\\n     * the value currently defined in the core contract.\\n     * @param projectId Project ID to set the maximum invocations for.\\n     * @param coreContract Core contract address for the given project.\\n     * @dev this enables gas reduction after maxInvocations have been reached -\\n     * core contracts shall still enforce a maxInvocation check during mint.\\n     */\\n    function syncProjectMaxInvocationsToCore(\\n        uint256 projectId,\\n        address coreContract\\n    ) public {\\n        AuthLib.onlyArtist({\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            sender: msg.sender\\n        });\\n\\n        MaxInvocationsLib.syncProjectMaxInvocationsToCore({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n    }\\n\\n    /**\\n     * @notice Purchases a token from project `projectId` and sets\\n     * the token's owner to `to`.\\n     * @param to Address to be the new token's owner.\\n     * @param projectId Project ID to mint a token on.\\n     * @param coreContract Core contract address for the given project.\\n     * @param maxPricePerToken Maximum price of token being allowed by the\\n     * purchaser, in base units. For example, if the ERC20 token has 6\\n     * decimals, an input value of `1_000_000` would represent a maximum price\\n     * of `1.000000` tokens.\\n     * @param currencyAddress Currency address of token.\\n     * @return tokenId Token ID of minted token\\n     */\\n    function purchaseTo(\\n        address to,\\n        uint256 projectId,\\n        address coreContract,\\n        uint256 maxPricePerToken,\\n        address currencyAddress\\n    ) public nonReentrant returns (uint256 tokenId) {\\n        // CHECKS\\n        // pre-mint MaxInvocationsLib checks\\n        // Note that `maxHasBeenInvoked` is only checked here to reduce gas\\n        // consumption after a project has been fully minted.\\n        // `maxInvocationsProjectConfig.maxHasBeenInvoked` is locally cached to reduce\\n        // gas consumption, but if not in sync with the core contract's value,\\n        // the core contract also enforces its own max invocation check during\\n        // minting.\\n        MaxInvocationsLib.preMintChecks({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n\\n        // pre-mint checks for set price lib, and get price per token\\n        // @dev price per token is loaded into memory here for gas efficiency\\n        uint256 pricePerToken = SetPriceLib.preMintChecksAndGetPrice({\\n            projectId: projectId,\\n            coreContract: coreContract\\n        });\\n\\n        // get the currency address configured on the project\\n        // @dev revert occurs during payment split if ERC20 token is not\\n        // configured (i.e. address(0)), so check is not performed here\\n        (address configuredCurrencyAddress, ) = SplitFundsLib\\n            .getCurrencyInfoERC20({\\n                projectId: projectId,\\n                coreContract: coreContract\\n            });\\n\\n        // validate that the currency address matches the project configured currency\\n        require(\\n            currencyAddress == configuredCurrencyAddress,\\n            \\\"Currency addresses must match\\\"\\n        );\\n\\n        // validate that the specified maximum price is greater than or equal to the price per token\\n        require(\\n            maxPricePerToken >= pricePerToken,\\n            \\\"Only max price gte token price\\\"\\n        );\\n\\n        // EFFECTS\\n        tokenId = _minterFilter.mint_joo({\\n            to: to,\\n            projectId: projectId,\\n            coreContract: coreContract,\\n            sender: msg.sender\\n        });\\n\\n        MaxInvocationsLib.validateMintEffectsInvocations({\\n            tokenId: tokenId,\\n            coreContract: coreContract\\n        });\\n\\n        // INTERACTIONS\\n        // split ERC20 funds\\n        SplitFundsLib.splitFundsERC20({\\n            projectId: projectId,\\n            pricePerToken: pricePerToken,\\n            coreContract: coreContract\\n        });\\n\\n        return tokenId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 25\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minterFilter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"checkYourAllowanceOfProjectERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"getPriceInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isConfigured\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenPriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"currencySymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"getYourBalanceOfProjectERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"isEngineView\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"maxInvocations\",\"type\":\"uint24\"}],\"name\":\"manuallyLimitProjectMaxInvocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"maxInvocationsProjectConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"maxHasBeenInvoked\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"maxInvocations\",\"type\":\"uint24\"}],\"internalType\":\"struct MaxInvocationsLib.MaxInvocationsProjectConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterFilterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"projectMaxHasBeenInvoked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"projectMaxInvocations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxPricePerToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxPricePerToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"}],\"name\":\"purchaseTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"setPriceProjectConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint248\",\"name\":\"pricePerToken\",\"type\":\"uint248\"},{\"internalType\":\"bool\",\"name\":\"priceIsConfigured\",\"type\":\"bool\"}],\"internalType\":\"struct SetPriceLib.SetPriceProjectConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"}],\"name\":\"syncProjectMaxInvocationsToCore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"uint248\",\"name\":\"pricePerTokenInWei\",\"type\":\"uint248\"}],\"name\":\"updatePricePerTokenInWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coreContract\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"currencySymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"}],\"name\":\"updateProjectCurrencyInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MinterSetPriceERC20V5", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "25", "ConstructorArguments": "000000000000000000000000a2ccfe293bc2cdd78d8166a82d1e18cd2148122b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}