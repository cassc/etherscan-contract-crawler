{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BIFI/interfaces/aura/IAuraBooster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAuraBooster {\\n    function deposit(uint256 pid, uint256 amount, bool stake) external returns (bool);\\n    function withdraw(uint256 _pid, uint256 _amount) external returns(bool);\\n    function earmarkRewards(uint256 _pid) external;\\n    function poolInfo(uint256 pid) external view returns (\\n        address lptoken,\\n        address token,\\n        address gauge,\\n        address crvRewards,\\n        address stash,\\n        bool shutdown\\n    );\\n    function staker() external view returns(address);\\n}\"\r\n    },\r\n    \"contracts/BIFI/interfaces/aura/IAuraClaimZapV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAuraClaimZapV3 {\\n  /**\\n   * @dev Claim rewards amounts.\\n   * - depositCrvMaxAmount    The max amount of CRV to deposit if converting to crvCvx\\n   * - minAmountOut           The min amount out for crv:cvxCrv swaps if swapping. Set this to zero if you\\n   *                          want to use CrvDepositor instead of balancer swap\\n   * - depositCvxMaxAmount    The max amount of CVX to deposit if locking CVX\\n   * - depositCvxCrvMaxAmount The max amount of CVXCVR to stake.\\n   */\\n  struct ClaimRewardsAmounts {\\n    uint256 depositCrvMaxAmount;\\n    uint256 minAmountOut;\\n    uint256 depositCvxMaxAmount;\\n    uint256 depositCvxCrvMaxAmount;\\n  }\\n\\n  /**\\n   * @dev options.\\n   * - claimCvxCrv             Flag: claim from the cvxCrv rewards contract\\n   * - claimLockedCvx          Flag: claim from the cvx locker contract\\n   * - lockCvxCrv              Flag: pull users cvxCrvBalance ready for locking\\n   * - lockCrvDeposit          Flag: locks crv rewards as cvxCrv\\n   * - useAllWalletFunds       Flag: lock rewards and existing balance\\n   * - useCompounder           Flag: deposit cvxCrv into autocompounder\\n   * - lockCvx                 Flag: lock cvx rewards in locker\\n   */\\n  struct Options {\\n    bool claimCvxCrv;\\n    bool claimLockedCvx;\\n    bool lockCvxCrv;\\n    bool lockCrvDeposit;\\n    bool useAllWalletFunds;\\n    bool useCompounder;\\n    bool lockCvx;\\n  }\\n\\n  /**\\n   * @notice Claim all the rewards\\n   * @param rewardContracts        Array of addresses for LP token rewards\\n   * @param extraRewardContracts   Array of addresses for extra rewards\\n   * @param tokenRewardContracts   Array of addresses for token rewards e.g vlCvxExtraRewardDistribution\\n   * @param tokenRewardTokens      Array of token reward addresses to use with tokenRewardContracts\\n   * @param amounts                Claim rewards amounts.\\n   * @param options                Claim options\\n   */\\n  function claimRewards(\\n    address[] calldata rewardContracts,\\n    address[] calldata extraRewardContracts,\\n    address[] calldata tokenRewardContracts,\\n    address[] calldata tokenRewardTokens,\\n    ClaimRewardsAmounts calldata amounts,\\n    Options calldata options\\n  ) external;\\n}\"\r\n    },\r\n    \"contracts/BIFI/interfaces/aura/IBaseRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IBaseRewards {\\n  function extraRewardsLength() external view returns (uint256);\\n  function extraRewards(uint256 index) external view returns(address);\\n  function rewardToken() external view returns(address);\\n  function earned(address account) external view returns(uint256);\\n  function withdrawAndUnwrap(uint256 amount, bool claim) external returns(bool);\\n  function withdraw(uint256 amount, bool claim) external returns(bool);\\n}\"\r\n    },\r\n    \"contracts/BIFI/interfaces/aura/IStaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IStaker {\\n  function balanceOfPool(address _gauge) external view returns(uint256);\\n}\"\r\n    },\r\n    \"contracts/BIFI/interfaces/balancer/IStablePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IStablePool {\\n  function getLastInvariant() external view returns(uint256, uint256);\\n  function getSwapFeePercentage() external view returns(uint256);\\n  function totalSupply() external view returns(uint256);\\n  function getVault() external view returns (address);\\n  function getPoolId() external view returns (bytes32);\\n}\"\r\n    },\r\n    \"contracts/BIFI/interfaces/beethovenx/IBalancerVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface IBalancerVault {\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        SwapKind kind;\\n        address assetIn;\\n        address assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    struct BatchSwapStep {\\n        bytes32 poolId;\\n        uint256 assetInIndex;\\n        uint256 assetOutIndex;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address payable recipient;\\n        bool toInternalBalance;\\n    }\\n\\n    struct JoinPoolRequest {\\n        address[] assets;\\n        uint256[] maxAmountsIn;\\n        bytes userData;\\n        bool fromInternalBalance;\\n    }\\n\\n    struct ExitPoolRequest {\\n        address[] assets;\\n        uint256[] minAmountsOut;\\n        bytes userData;\\n        bool toInternalBalance;\\n    }\\n\\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\\n\\n    function swap(\\n        SingleSwap memory singleSwap,\\n        FundManagement memory funds,\\n        uint256 limit,\\n        uint256 deadline\\n    ) external payable returns (uint256);\\n\\n    function batchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        address[] memory assets,\\n        FundManagement memory funds,\\n        int256[] memory limits,\\n        uint256 deadline\\n    ) external returns (int256[] memory assetDeltas);\\n\\n    function joinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        JoinPoolRequest memory request\\n    ) external;\\n\\n    function exitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address payable recipient,\\n        ExitPoolRequest memory request\\n    ) external;\\n\\n    function getPoolTokens(bytes32 poolId)\\n        external\\n        view\\n        returns (\\n            address[] memory tokens,\\n            uint256[] memory balances,\\n            uint256 lastChangeBlock\\n        );\\n\\n    function getPool(bytes32 poolId)\\n        external\\n        view\\n        returns (address, uint8);\\n\\n    function flashLoan(\\n        address recipient,\\n        address[] memory tokens,\\n        uint256[] memory amounts,\\n        bytes memory userData\\n    ) external;\\n    \\n    function queryBatchSwap(\\n       SwapKind kind,\\n       BatchSwapStep[] memory swaps,\\n       address[] memory assets,\\n       FundManagement memory funds\\n    ) external returns (int256[] memory);\\n\\n}\"\r\n    },\r\n    \"contracts/BIFI/libraries/AuraLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0; \\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"../interfaces/aura/IAuraBooster.sol\\\";\\nimport \\\"../interfaces/aura/IBaseRewards.sol\\\";\\nimport \\\"../interfaces/aura/IAuraClaimZapV3.sol\\\";\\nimport \\\"../libraries/BalancerLib.sol\\\";\\nimport \\\"../interfaces/aura/IStaker.sol\\\";\\nimport \\\"../strategies/Aura/ConfigAaveBalAura.sol\\\";\\n\\nlibrary AuraLibPub {\\n  using SafeERC20 for IERC20;\\n\\n  /******************************************************\\n   *                                                    *\\n   *                  ACTIONS FUNCTIONS                 *\\n   *                                                    *\\n   ******************************************************/\\n  \\n  function harvest(address _booster, address _auraClaimZapV3, uint256 _pid) external {\\n    (,,,address rewardContract,,) = IAuraBooster(_booster).poolInfo(_pid);\\n    uint256 extraRewardsLength = IBaseRewards(rewardContract).extraRewardsLength();\\n    address[] memory extraRewardContracts = new address[](extraRewardsLength);\\n\\n    for(uint256 i = 0; i < extraRewardsLength;) {\\n      extraRewardContracts[i] = IBaseRewards(rewardContract).extraRewards(i);\\n      unchecked { ++i; }\\n    }\\n\\n    address[] memory rewardContracts = new address[](1);\\n    rewardContracts[0] = rewardContract;\\n    IAuraClaimZapV3(_auraClaimZapV3).claimRewards(\\n      rewardContracts,\\n      extraRewardContracts,\\n      new address[](0),\\n      new address[](0),\\n      IAuraClaimZapV3.ClaimRewardsAmounts(0, 0, 0, 0),\\n      IAuraClaimZapV3.Options(false, false, false, false, false, false, false)\\n    );\\n  }\\n\\n  // Remove liquidity from Aura and Balancer\\n  function removeLiqAuraBal2Pools(\\n    Config.Data memory config,\\n    uint256 _withdrawMin,\\n    uint256 _stakedWithdrawAmount\\n  ) external {\\n    IBaseRewards(config.auraContracts.stakingToken).withdraw(_stakedWithdrawAmount, false); // TODO: maybe claim should be true\\n    IAuraBooster(config.auraContracts.booster).withdraw(config.poolIds.pidAura, _stakedWithdrawAmount);\\n\\n    // Remove liquidity from Balancer (Pool 2)\\n    uint256 bptPool1Amount = BalancerLib.getTokenOutGivenExactBptInStable(\\n      config.balancerContracts.balancerVault, \\n      config.poolIds.poolId2, \\n      config.balancerContracts.bptPool1, \\n      config.balancerContracts.bptPool2, \\n      type(uint).max\\n    );\\n    BalancerLib.balancerExit(\\n      config.balancerContracts.balancerVault, \\n      config.poolIds.poolId2, \\n      config.balancerContracts.bptPool1, \\n      IERC20(config.balancerContracts.bptPool2).balanceOf(address(this)), \\n      bptPool1Amount * _withdrawMin / 1 ether\\n    );\\n\\n    // Remove liquidity from Balancer (Pool 1)\\n    uint256[] memory withdrawAmounts = BalancerLib.getTokensOutGivenExactBptInWeighted(\\n      config.balancerContracts.balancerVault, \\n      config.poolIds.poolId1, \\n      config.balancerContracts.bptPool1, \\n      type(uint).max\\n    );\\n\\n    uint256[] memory minAmounts = new uint256[](2);\\n    minAmounts[0] = withdrawAmounts[0] * _withdrawMin / 1 ether;\\n    minAmounts[1] = withdrawAmounts[1] * _withdrawMin / 1 ether;\\n\\n    BalancerLib.balancerExitMany(\\n      config.balancerContracts.balancerVault, \\n      config.poolIds.poolId1, \\n      IERC20(config.balancerContracts.bptPool1).balanceOf(address(this)), \\n      minAmounts\\n    );\\n  }\\n\\n  function calcRemoveLiqAuraBal2Pools(\\n    address _vault,\\n    bytes32 _pid1,\\n    bytes32 _pid2,\\n    address _bptPool1,\\n    address _bptPool2,\\n    uint256 _stakedWithdrawAmount\\n  ) public view returns(uint256[] memory withdrawAmounts) {\\n    uint256 bptPool1Amount = BalancerLib.getTokenOutGivenExactBptInStable(_vault, _pid2, _bptPool1, _bptPool2, _stakedWithdrawAmount);\\n    withdrawAmounts = BalancerLib.getTokensOutGivenExactBptInWeighted(_vault, _pid1, _bptPool1, bptPool1Amount);\\n  }\\n\\n  /******************************************************\\n   *                                                    *\\n   *                    VIEW FUNCTIONS                  *\\n   *                                                    *\\n   ******************************************************/\\n\\n  // Get total underlying liquidity on Aura\\n  function getUnderlyingAuraBal2Pools(\\n    address _bptPool1,\\n    address _bptPool2,\\n    address _stakingToken,\\n    bytes32 _poolId1,\\n    bytes32 _poolId2,\\n    address _vault\\n  ) external view returns(uint256, uint256) {\\n    uint256 bptPool2Amount = IERC20(_stakingToken).balanceOf(address(this));\\n\\n    uint256[] memory withdrawAmounts = calcRemoveLiqAuraBal2Pools(\\n      _vault,\\n      _poolId1,\\n      _poolId2,\\n      _bptPool1,\\n      _bptPool2,\\n      bptPool2Amount\\n    );\\n\\n    return (withdrawAmounts[0], withdrawAmounts[1]);\\n  }\\n}\\n\\nlibrary AuraLib {\\n  function harvest(address _booster, address _auraClaimZapV3, uint256 _pid) internal {\\n    AuraLibPub.harvest(_booster, _auraClaimZapV3, _pid);\\n  }\\n\\n  function removeLiqAuraBal2Pools(\\n    Config.Data memory config,\\n    uint256 _withdrawMin,\\n    uint256 _stakedWithdrawAmount\\n  ) internal {\\n    return AuraLibPub.removeLiqAuraBal2Pools(\\n      config,\\n      _withdrawMin,\\n      _stakedWithdrawAmount\\n    );\\n  }\\n\\n  function getUnderlyingAuraBal2Pools(\\n    address _bptPool1,\\n    address _bptPool2,\\n    address _stakingToken,\\n    bytes32 _poolId1,\\n    bytes32 _poolId2,\\n    address _vault\\n  ) internal view returns(uint256, uint256) {\\n    return AuraLibPub.getUnderlyingAuraBal2Pools(\\n      _bptPool1,\\n      _bptPool2,\\n      _stakingToken,\\n      _poolId1,\\n      _poolId2,\\n      _vault\\n    );\\n  }\\n}\"\r\n    },\r\n    \"contracts/BIFI/libraries/BalancerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0; \\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\n\\r\\nimport \\\"../interfaces/beethovenx/IBalancerVault.sol\\\";\\r\\nimport \\\"../interfaces/balancer/IStablePool.sol\\\";\\r\\nimport \\\"../strategies/Balancer/WeightedMath.sol\\\";\\r\\nimport \\\"../strategies/Balancer/BeefyBalancerStructs.sol\\\";\\r\\nimport \\\"../strategies/Balancer/StableMath.sol\\\";\\r\\n\\r\\nlibrary BalancerLibPub {\\r\\n  function balancerJoin(address _vault, bytes32 _poolId, address _tokenIn, uint256 _amountIn) external {\\r\\n    BalancerLib.balancerJoin(_vault, _poolId, _tokenIn, _amountIn);\\r\\n  }\\r\\n\\r\\n  function balancerJoinMany(address _vault, bytes32 _poolId, uint256[] memory _amountsIn) external {\\r\\n    BalancerLib.balancerJoinMany(_vault, _poolId, _amountsIn);\\r\\n  }\\r\\n\\r\\n  function balancerSwap(\\r\\n      BalancerLib.SwapParams memory params,\\r\\n      IBalancerVault.FundManagement memory funds,\\r\\n      IBalancerVault.SwapKind swapKind\\r\\n  ) external returns (uint256) {\\r\\n    return BalancerLib.balancerSwap(params, funds, swapKind);\\r\\n  }\\r\\n\\r\\n  function balancerBatchSwap(address _vault, IBalancerVault.SwapKind _swapKind, address[] memory _route, bytes32[] memory pools, IBalancerVault.FundManagement memory _funds, uint256 _amountIn) internal returns (int256[] memory) {\\r\\n    return BalancerLib.balancerBatchSwap(_vault, _swapKind, _route, pools, _funds, _amountIn);\\r\\n  }\\r\\n\\r\\n  function balancerBatchQuote(address _vault, IBalancerVault.SwapKind _swapKind, address[] memory _route, bytes32[] memory pools, IBalancerVault.FundManagement memory _funds, uint256 _amountIn) internal returns (int256[] memory) {\\r\\n    return BalancerLib.balancerBatchQuote(_vault, _swapKind, _route, pools, _funds, _amountIn);\\r\\n  }\\r\\n}\\r\\n\\r\\nlibrary BalancerLib {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    struct SwapParams {\\r\\n        address vault;\\r\\n        bytes32 poolId; \\r\\n        address tokenIn; \\r\\n        address tokenOut; \\r\\n        uint256 amountIn;\\r\\n\\t  }\\r\\n\\r\\n    /******************************************************\\r\\n     *                                                    *\\r\\n     *                  ACTIONS FUNCTIONS                 *\\r\\n     *                                                    *\\r\\n     ******************************************************/\\r\\n\\r\\n    function balancerJoin(address _vault, bytes32 _poolId, address _tokenIn, uint256 _amountIn) internal {\\r\\n        (address[] memory lpTokens,,) = IBalancerVault(_vault).getPoolTokens(_poolId);\\r\\n        uint256[] memory amounts = new uint256[](lpTokens.length);\\r\\n        for (uint256 i = 0; i < amounts.length;) {\\r\\n            amounts[i] = lpTokens[i] == _tokenIn ? _amountIn : 0;\\r\\n            unchecked { ++i; }\\r\\n        }\\r\\n        bytes memory userData = abi.encode(1, amounts, 1);\\r\\n\\r\\n        IBalancerVault.JoinPoolRequest memory request = IBalancerVault.JoinPoolRequest(lpTokens, amounts, userData, false);\\r\\n        IBalancerVault(_vault).joinPool(_poolId, address(this), address(this), request);\\r\\n    }\\r\\n\\r\\n    function balancerExit(address _vault, bytes32 _poolId, address _tokenOut, uint256 bptAmountIn, uint256 _minAmountOut) internal {\\r\\n        (address[] memory lpTokens,,) = IBalancerVault(_vault).getPoolTokens(_poolId);\\r\\n        uint256[] memory amounts = new uint256[](lpTokens.length);\\r\\n        for (uint256 i = 0; i < amounts.length;) {\\r\\n            amounts[i] = lpTokens[i] == _tokenOut ? _minAmountOut : 0;\\r\\n            unchecked { ++i; }\\r\\n        }\\r\\n\\r\\n        bytes memory userData = abi.encode(0, bptAmountIn, 0);\\r\\n\\r\\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault.ExitPoolRequest(lpTokens, amounts, userData, false);\\r\\n        IBalancerVault(_vault).exitPool(_poolId, address(this), payable(address(this)), request);\\r\\n    }\\r\\n    \\r\\n    function balancerJoinMany(address _vault, bytes32 _poolId, uint256[] memory _amountsIn) internal {\\r\\n        (address[] memory lpTokens,,) = IBalancerVault(_vault).getPoolTokens(_poolId);\\r\\n   \\r\\n        bytes memory userData = abi.encode(1, _amountsIn, 1);\\r\\n\\r\\n        IBalancerVault.JoinPoolRequest memory request = IBalancerVault.JoinPoolRequest(lpTokens, _amountsIn, userData, false);\\r\\n        IBalancerVault(_vault).joinPool(_poolId, address(this), address(this), request);\\r\\n    }\\r\\n\\r\\n    function balancerExitMany(address _vault, bytes32 _poolId, uint256 bptAmountIn, uint256[] memory _minAmountsOut) internal {\\r\\n        (address[] memory lpTokens,,) = IBalancerVault(_vault).getPoolTokens(_poolId);\\r\\n\\r\\n        bytes memory userData = abi.encode(1, bptAmountIn);\\r\\n\\r\\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault.ExitPoolRequest(lpTokens, _minAmountsOut, userData, false);\\r\\n        IBalancerVault(_vault).exitPool(_poolId, address(this), payable(address(this)), request);\\r\\n    }\\r\\n\\r\\n\\r\\n    // Swap funds on Balancer\\r\\n    function balancerSwap(\\r\\n        SwapParams memory params,\\r\\n        IBalancerVault.FundManagement memory funds,\\r\\n        IBalancerVault.SwapKind swapKind\\r\\n    ) internal returns (uint256) {\\r\\n      IBalancerVault.SingleSwap memory singleSwap = IBalancerVault.SingleSwap(params.poolId, swapKind, params.tokenIn, params.tokenOut, params.amountIn, \\\"\\\");\\r\\n      return IBalancerVault(params.vault).swap(singleSwap, funds, 1, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function balancerBatchSwap(address _vault, IBalancerVault.SwapKind _swapKind, address[] memory _route, bytes32[] memory pools, IBalancerVault.FundManagement memory _funds, uint256 _amountIn) internal returns (int256[] memory) {\\r\\n      IBalancerVault.BatchSwapStep[] memory _swaps = new IBalancerVault.BatchSwapStep[](_route.length - 1); \\r\\n      int256[] memory limits = new int256[](_route.length);\\r\\n      require(_route.length > 1, \\\"Too short route\\\");\\r\\n      require(pools.length + 1 >= _route.length, \\\"Too short pools\\\");\\r\\n      for (uint i; i < _route.length; i++) {\\r\\n          if (i == 0) {\\r\\n              limits[0] = int(_amountIn);\\r\\n          }\\r\\n          \\r\\n          if (i == _route.length - 1) {\\r\\n              limits[i] = 0; // TODO: it was -1, must be reviewed\\r\\n          } else {\\r\\n              _swaps[i] = IBalancerVault.BatchSwapStep({\\r\\n                poolId: pools[i],\\r\\n                assetInIndex: i,\\r\\n                assetOutIndex: i + 1,\\r\\n                amount: i == 0 ? _amountIn : 0,\\r\\n                userData: \\\"\\\"\\r\\n            });\\r\\n          }\\r\\n      }\\r\\n      return IBalancerVault(_vault).batchSwap(_swapKind, _swaps, _route, _funds, limits, block.timestamp);\\r\\n    }\\r\\n\\r\\n  /******************************************************\\r\\n   *                                                    *\\r\\n   *                    VIEW FUNCTIONS                  *\\r\\n   *                                                    *\\r\\n   ******************************************************/\\r\\n\\r\\n   // Get Balancer pool token balances\\r\\n  function getPoolBalances(address _vault, bytes32 _poolId) internal view returns(uint256[] memory) {\\r\\n    (,uint256[] memory balances,) = IBalancerVault(_vault).getPoolTokens(_poolId);\\r\\n    return balances;\\r\\n  }\\r\\n\\r\\n  // Get Token index\\r\\n  function getPoolTokenIndex(address _vault, bytes32 _poolId, address _token) internal view returns(uint256) {\\r\\n    (address[] memory poolTokens,,) = IBalancerVault(_vault).getPoolTokens(_poolId);\\r\\n    for (uint256 i = 0; i < poolTokens.length;) {\\r\\n      if(poolTokens[i] == _token) {\\r\\n        return i;\\r\\n      }\\r\\n      unchecked { ++i; }\\r\\n    }\\r\\n    revert(\\\"index not found\\\");\\r\\n  }\\r\\n\\r\\n  // Get Balancer single amount to withdraw from Stable Pool from exact BPT amount\\r\\n  function getTokenOutGivenExactBptInStable(address _vault, bytes32 _poolId, address _token, address _bptPool, uint lpBalance) internal view returns(uint256) {\\r\\n    if (lpBalance == type(uint).max) {\\r\\n      lpBalance = IERC20(_bptPool).balanceOf(address(this));\\r\\n    }\\r\\n    \\r\\n    uint256[] memory poolTokenBalances = getPoolBalances(_vault, _poolId);\\r\\n    (, uint256 amp) = IStablePool(_bptPool).getLastInvariant();\\r\\n    uint256 invariant = StableMath._calculateInvariant(amp, poolTokenBalances);\\r\\n    uint256 totalSupply = IStablePool(_bptPool).totalSupply();\\r\\n    uint256 index = getPoolTokenIndex(_vault, _poolId, _token);\\r\\n    uint256 swapFeePercentage = IStablePool(_bptPool).getSwapFeePercentage();\\r\\n\\r\\n    return StableMath._calcTokenOutGivenExactBptIn(amp, poolTokenBalances, index, lpBalance, totalSupply, invariant, swapFeePercentage);\\r\\n  }\\r\\n\\r\\n  // Get Balancer amounts to withdraw from Weighted pools from exact BPT amount\\r\\n  function getTokensOutGivenExactBptInWeighted(address _vault, bytes32 _poolId, address _bptPool, uint lpBalance) internal view returns(uint256[] memory) {\\r\\n    if (lpBalance == type(uint).max) {\\r\\n      lpBalance = IERC20(_bptPool).balanceOf(address(this));\\r\\n    }\\r\\n    \\r\\n    uint256[] memory poolTokenBalances = getPoolBalances(_vault, _poolId);\\r\\n    uint256 totalSupply = IStablePool(_bptPool).totalSupply();\\r\\n\\r\\n    return WeightedMath._calcTokensOutGivenExactBptIn(poolTokenBalances, lpBalance, totalSupply);\\r\\n  }\\r\\n\\r\\n  function getPoolAddress(bytes32 poolId) internal pure returns (address) {\\r\\n    // 12 byte logical shift left to remove the nonce and specialization setting. We don't need to mask,\\r\\n    // since the logical shift already sets the upper bits to zero.\\r\\n    return address(bytes20(poolId));\\r\\n  }\\r\\n\\r\\n  function balancerBatchQuote(address _vault, IBalancerVault.SwapKind _swapKind, address[] memory _route, bytes32[] memory pools, IBalancerVault.FundManagement memory _funds, uint256 _amountIn) internal returns (int256[] memory) {\\r\\n    IBalancerVault.BatchSwapStep[] memory _swaps = new IBalancerVault.BatchSwapStep[](_route.length - 1); \\r\\n    require(_route.length > 1, \\\"Too short route\\\");\\r\\n    require(pools.length + 1 >= _route.length, \\\"Too short pools\\\");\\r\\n    for (uint i; i < _route.length; i++) {          \\r\\n        if (i < _route.length - 1) {\\r\\n            _swaps[i] = IBalancerVault.BatchSwapStep({\\r\\n              poolId: pools[i],\\r\\n              assetInIndex: i,\\r\\n              assetOutIndex: i + 1,\\r\\n              amount: i == 0 ? _amountIn : 0,\\r\\n              userData: \\\"\\\"\\r\\n          });\\r\\n        }\\r\\n    }\\r\\n    return IBalancerVault(_vault).queryBatchSwap(_swapKind, _swaps, _route, _funds);\\r\\n  }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/BIFI/strategies/Aura/ConfigAaveBalAura.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/beethovenx/IBalancerVault.sol\\\";\\n\\nuint constant WANT_INDEX = 2;\\nuint constant INTEREST_RATE_MODE = 2;\\nuint8 constant BASE_TOKENS_COUNT = 3;\\n\\ninterface Config {\\n  struct Data {\\n    address loanToken0;\\n    address loanToken1;\\n    address want;\\n    bytes32 decimals;\\n    uint nativeIndex;\\n\\n    uint proportion;\\n    uint borrowRate;\\n\\n    AaveContracts aaveContracts;\\n    BalancerContracts balancerContracts;\\n    AuraContracts auraContracts;\\n    PoolIds poolIds;\\n  }\\n\\n  struct AaveContracts {\\n    address lendingPool; // Aave lending pool\\n    address priceOracle; // Aave price oracle\\n    address dataProvider; // Aave data provider\\n    address rewardsController; // Aave rewards controller\\n  }\\n\\n  struct BalancerContracts {\\n    address balancerVault; // Balancer Vault\\n    address bptPool1; // balancer LP\\n    address bptPool2; // balancer LP\\n  }\\n\\n  struct AuraContracts {\\n    address booster; // Aura booster\\n    address auraClaimZapV3; // Aura rewards claimer\\n    address stakingToken; // Aura staking token\\n  }\\n\\n  struct PoolIds {\\n    bytes32 poolId1; // Balancer pool Id\\n    bytes32 poolId2; // Balancer pool Id\\n    uint256 pidAura; // Aura staking pool id\\n  }\\n\\n  // struct getter\\n  function get() external view returns (Data memory);\\n}\\n\\ninterface ConfigExt {\\n  struct Data {\\n    address[] tokens;\\n    bytes32[] routing; // routing[sourceTokenIndex][targetTokenIndex] = nextTokenIndex or (poolIndex + tokensCount)\\n                       // routing[poolIndex + tokensCount] = poolId\\n    address[] rewardersAura;\\n    bytes32 rewardTokens; // tokenIndexesAura | tokenIndexesAave, last byte is length \\n    bool harvestOnDeposit;\\n    uint withdrawMin; // min rate to be withdrawn from Balancer\\n  }\\n\\n  function get() external view returns (Data memory);\\n}\\n\\nstruct Configs {\\n  Config.Data base;\\n  ConfigExt.Data ext;\\n}\\n\\nfunction getRoute(Configs memory configs, uint tokenInIndex, uint tokenOutIndex) pure returns (uint[] memory path, bytes32[] memory pools) {\\n  (path, pools) = buildRoute(configs.ext, tokenInIndex, tokenOutIndex, 1);\\n  path[0] = tokenInIndex;\\n}\\n\\nfunction buildRoute(ConfigExt.Data memory configExt, uint tokenInIndex, uint tokenOutIndex, uint depth) pure returns (uint[] memory path, bytes32[] memory pools) {\\n  unchecked {\\n    bytes32 route = configExt.routing[tokenInIndex];\\n    uint step = uint8(route[tokenOutIndex]);\\n    uint poolIndex;\\n    uint tokenIndex;\\n    if (step < configExt.tokens.length + BASE_TOKENS_COUNT) {\\n      tokenIndex = step;\\n      poolIndex = uint8(route[tokenIndex]);\\n      (path, pools) = buildRoute(configExt, tokenIndex, tokenOutIndex, depth + 1);\\n    } else {\\n      require(step < type(uint8).max, \\\"No route found\\\");\\n      tokenIndex = tokenOutIndex;\\n      poolIndex = step;\\n      path = new uint[](depth + 1);\\n      pools = new bytes32[](depth);\\n    }\\n\\n    path[depth] = tokenIndex;\\n    pools[depth - 1] = configExt.routing[poolIndex];\\n  }\\n}\\n\\nfunction getProportion(Configs memory configs, uint tokenIndex) pure returns (uint) {\\n  if (tokenIndex == 0) {\\n    return configs.base.proportion;\\n  }\\n  if (tokenIndex == 1) {\\n    return 1 ether - configs.base.proportion;\\n  }\\n  revert(\\\"Proportion not found\\\");\\n}\\n\\nfunction getTokenAddress(Configs memory configs, uint tokenIndex) pure returns (address) {\\n  if (tokenIndex == 0) {\\n    return configs.base.loanToken0;\\n  }\\n  if (tokenIndex == 1) {\\n    return configs.base.loanToken1;\\n  }\\n  if (tokenIndex == WANT_INDEX) {\\n    return configs.base.want;\\n  }\\n\\n  return configs.ext.tokens[tokenIndex - BASE_TOKENS_COUNT];\\n}\\n\\nfunction getTokenIndex(Configs memory configs, address tokenAddress) pure returns (uint tokenIndex) {\\n  unchecked {\\n    for(tokenIndex = 0; tokenIndex < BASE_TOKENS_COUNT + configs.ext.tokens.length; tokenIndex++) {\\n      if (getTokenAddress(configs, tokenIndex) == tokenAddress) {\\n        return tokenIndex;\\n      }\\n    }\\n\\n    revert(\\\"Token not found\\\");\\n  }\\n}\\n\\nfunction getRouteAddresses(Configs memory configs, uint tokenInIndex, uint tokenOutIndex) pure returns (address[] memory tokens, bytes32[] memory pools) {\\n  uint[] memory route;\\n  (route, pools) = getRoute(configs, tokenInIndex, tokenOutIndex);\\n  tokens = new address[](route.length);\\n  unchecked {\\n    for(uint i = 0; i < route.length; i++) {\\n      tokens[i] = getTokenAddress(configs, route[i]);\\n    }\\n  }\\n}\\n\\nfunction getRewardTokensCount(Configs memory configs) pure returns (uint) {\\n  return uint8(uint(configs.ext.rewardTokens));\\n}\\n\\nfunction getRewardToken(Configs memory configs, uint rewardTokenIndex) pure returns (uint) {\\n  return uint8(configs.ext.rewardTokens[rewardTokenIndex]);\\n}\"\r\n    },\r\n    \"contracts/BIFI/strategies/Balancer/BalancerErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.7.1 <0.9.0;\\n\\n// solhint-disable\\n\\n/**\\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\\n * supported.\\n * Uses the default 'BAL' prefix for the error code\\n */\\nfunction _require(bool condition, uint256 errorCode) pure {\\n    if (!condition) _revert(errorCode);\\n}\\n\\n/**\\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\\n * supported.\\n */\\nfunction _require(\\n    bool condition,\\n    uint256 errorCode,\\n    bytes3 prefix\\n) pure {\\n    if (!condition) _revert(errorCode, prefix);\\n}\\n\\n/**\\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\\n * Uses the default 'BAL' prefix for the error code\\n */\\nfunction _revert(uint256 errorCode) pure {\\n    _revert(errorCode, 0x42414c); // This is the raw byte representation of \\\"BAL\\\"\\n}\\n\\n/**\\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\\n */\\nfunction _revert(uint256 errorCode, bytes3 prefix) pure {\\n    uint256 prefixUint = uint256(uint24(prefix));\\n    // We're going to dynamically create a revert string based on the error code, with the following format:\\n    // 'BAL#{errorCode}'\\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\\n    //\\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\\n    // number (8 to 16 bits) than the individual string characters.\\n    //\\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\\n    assembly {\\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\\n        // the '0' character.\\n\\n        let units := add(mod(errorCode, 10), 0x30)\\n\\n        errorCode := div(errorCode, 10)\\n        let tenths := add(mod(errorCode, 10), 0x30)\\n\\n        errorCode := div(errorCode, 10)\\n        let hundreds := add(mod(errorCode, 10), 0x30)\\n\\n        // With the individual characters, we can now construct the full string.\\n        // We first append the '#' character (0x23) to the prefix. In the case of 'BAL', it results in 0x42414c23 ('BAL#')\\n        // Then, we shift this by 24 (to provide space for the 3 bytes of the error code), and add the\\n        // characters to it, each shifted by a multiple of 8.\\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\\n        // array).\\n        let formattedPrefix := shl(24, add(0x23, shl(8, prefixUint)))\\n\\n        let revertReason := shl(200, add(formattedPrefix, add(add(units, shl(8, tenths)), shl(16, hundreds))))\\n\\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\\n        // message will have the following layout:\\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\\n\\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\\n        // The string length is fixed: 7 characters.\\n        mstore(0x24, 7)\\n        // Finally, the string itself is stored.\\n        mstore(0x44, revertReason)\\n\\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\\n        revert(0, 100)\\n    }\\n}\\n\\nlibrary Errors {\\n    // Math\\n    uint256 internal constant ADD_OVERFLOW = 0;\\n    uint256 internal constant SUB_OVERFLOW = 1;\\n    uint256 internal constant SUB_UNDERFLOW = 2;\\n    uint256 internal constant MUL_OVERFLOW = 3;\\n    uint256 internal constant ZERO_DIVISION = 4;\\n    uint256 internal constant DIV_INTERNAL = 5;\\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\\n    uint256 internal constant INVALID_EXPONENT = 9;\\n\\n    // Input\\n    uint256 internal constant OUT_OF_BOUNDS = 100;\\n    uint256 internal constant UNSORTED_ARRAY = 101;\\n    uint256 internal constant UNSORTED_TOKENS = 102;\\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\\n    uint256 internal constant ZERO_TOKEN = 104;\\n    uint256 internal constant INSUFFICIENT_DATA = 105;\\n\\n    // Shared pools\\n    uint256 internal constant MIN_TOKENS = 200;\\n    uint256 internal constant MAX_TOKENS = 201;\\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\\n    uint256 internal constant MINIMUM_BPT = 204;\\n    uint256 internal constant CALLER_NOT_VAULT = 205;\\n    uint256 internal constant UNINITIALIZED = 206;\\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\\n    uint256 internal constant EXPIRED_PERMIT = 209;\\n    uint256 internal constant NOT_TWO_TOKENS = 210;\\n    uint256 internal constant DISABLED = 211;\\n\\n    // Pools\\n    uint256 internal constant MIN_AMP = 300;\\n    uint256 internal constant MAX_AMP = 301;\\n    uint256 internal constant MIN_WEIGHT = 302;\\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\\n    uint256 internal constant MAX_IN_RATIO = 304;\\n    uint256 internal constant MAX_OUT_RATIO = 305;\\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\\n    uint256 internal constant INVALID_TOKEN = 309;\\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\\n    uint256 internal constant ZERO_INVARIANT = 311;\\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\\n    uint256 internal constant ORACLE_BAD_SECS = 316;\\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\\n    uint256 internal constant SWAPS_DISABLED = 327;\\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\\n    uint256 internal constant INVALID_INITIALIZATION = 342;\\n    uint256 internal constant OUT_OF_NEW_TARGET_RANGE = 343;\\n    uint256 internal constant FEATURE_DISABLED = 344;\\n    uint256 internal constant UNINITIALIZED_POOL_CONTROLLER = 345;\\n    uint256 internal constant SET_SWAP_FEE_DURING_FEE_CHANGE = 346;\\n    uint256 internal constant SET_SWAP_FEE_PENDING_FEE_CHANGE = 347;\\n    uint256 internal constant CHANGE_TOKENS_DURING_WEIGHT_CHANGE = 348;\\n    uint256 internal constant CHANGE_TOKENS_PENDING_WEIGHT_CHANGE = 349;\\n    uint256 internal constant MAX_WEIGHT = 350;\\n    uint256 internal constant UNAUTHORIZED_JOIN = 351;\\n    uint256 internal constant MAX_MANAGEMENT_AUM_FEE_PERCENTAGE = 352;\\n    uint256 internal constant FRACTIONAL_TARGET = 353;\\n    uint256 internal constant ADD_OR_REMOVE_BPT = 354;\\n    uint256 internal constant INVALID_CIRCUIT_BREAKER_BOUNDS = 355;\\n    uint256 internal constant CIRCUIT_BREAKER_TRIPPED = 356;\\n    uint256 internal constant MALICIOUS_QUERY_REVERT = 357;\\n    uint256 internal constant JOINS_EXITS_DISABLED = 358;\\n\\n    // Lib\\n    uint256 internal constant REENTRANCY = 400;\\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\\n    uint256 internal constant PAUSED = 402;\\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\\n    uint256 internal constant NOT_PAUSED = 431;\\n    uint256 internal constant ADDRESS_ALREADY_ALLOWLISTED = 432;\\n    uint256 internal constant ADDRESS_NOT_ALLOWLISTED = 433;\\n    uint256 internal constant ERC20_BURN_EXCEEDS_BALANCE = 434;\\n    uint256 internal constant INVALID_OPERATION = 435;\\n    uint256 internal constant CODEC_OVERFLOW = 436;\\n    uint256 internal constant IN_RECOVERY_MODE = 437;\\n    uint256 internal constant NOT_IN_RECOVERY_MODE = 438;\\n    uint256 internal constant INDUCED_FAILURE = 439;\\n    uint256 internal constant EXPIRED_SIGNATURE = 440;\\n    uint256 internal constant MALFORMED_SIGNATURE = 441;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_UINT64 = 442;\\n    uint256 internal constant UNHANDLED_FEE_TYPE = 443;\\n    uint256 internal constant BURN_FROM_ZERO = 444;\\n\\n    // Vault\\n    uint256 internal constant INVALID_POOL_ID = 500;\\n    uint256 internal constant CALLER_NOT_POOL = 501;\\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\\n    uint256 internal constant INVALID_SIGNATURE = 504;\\n    uint256 internal constant EXIT_BELOW_MIN = 505;\\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\\n    uint256 internal constant SWAP_LIMIT = 507;\\n    uint256 internal constant SWAP_DEADLINE = 508;\\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\\n    uint256 internal constant INSUFFICIENT_ETH = 516;\\n    uint256 internal constant UNALLOCATED_ETH = 517;\\n    uint256 internal constant ETH_TRANSFER = 518;\\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\\n    uint256 internal constant TOKENS_MISMATCH = 520;\\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\\n    uint256 internal constant POOL_NO_TOKENS = 527;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\\n\\n    // Fees\\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\\n    uint256 internal constant AUM_FEE_PERCENTAGE_TOO_HIGH = 603;\\n\\n    // FeeSplitter\\n    uint256 internal constant SPLITTER_FEE_PERCENTAGE_TOO_HIGH = 700;\\n\\n    // Misc\\n    uint256 internal constant UNIMPLEMENTED = 998;\\n    uint256 internal constant SHOULD_NOT_HAPPEN = 999;\\n}\"\r\n    },\r\n    \"contracts/BIFI/strategies/Balancer/BeefyBalancerStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0; \\r\\n\\r\\nlibrary BeefyBalancerStructs {\\r\\n    struct BatchSwapStruct {\\r\\n        bytes32 poolId;\\r\\n        uint256 assetInIndex;\\r\\n        uint256 assetOutIndex;\\r\\n    }\\r\\n\\r\\n    struct Reward {\\r\\n        mapping(uint => BatchSwapStruct) swapInfo;\\r\\n        address[] assets;\\r\\n        bytes routeToNative; // backup route in case there is no Balancer liquidity for reward\\r\\n        uint minAmount; // minimum amount to be swapped to native\\r\\n    }\\r\\n\\r\\n     struct Input {\\r\\n        address input;\\r\\n        bool isComposable;\\r\\n        bool isBeets;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/BIFI/strategies/Balancer/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./LogExpMath.sol\\\";\\nimport \\\"./BalancerErrors.sol\\\";\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\nlibrary FixedPoint {\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\\n\\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        _require(b <= a, Errors.SUB_OVERFLOW);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\\n\\n        return product / ONE;\\n    }\\n\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\\n\\n        if (product == 0) {\\n            return 0;\\n        } else {\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((product - 1) / ONE) + 1;\\n        }\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\\n\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\\n\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((aInflated - 1) / b) + 1;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\\n     * the true value (that is, the error function expected - actual is always positive).\\n     */\\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        if (raw < maxError) {\\n            return 0;\\n        } else {\\n            return sub(raw, maxError);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\\n     * the true value (that is, the error function expected - actual is always negative).\\n     */\\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        return add(raw, maxError);\\n    }\\n\\n    /**\\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\\n     *\\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\\n     * prevents intermediate negative values.\\n     */\\n    function complement(uint256 x) internal pure returns (uint256) {\\n        return (x < ONE) ? (ONE - x) : 0;\\n    }\\n}\"\r\n    },\r\n    \"contracts/BIFI/strategies/Balancer/LogExpMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\\n// documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\\n\\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\\n// Software.\\n\\n// THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\n/* solhint-disable */\\n\\n/**\\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\\n *\\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\\n * exponentiation and logarithm (where the base is Euler's number).\\n *\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\\n    // two numbers, and multiply by ONE when dividing them.\\n\\n    // All arguments and return values are 18 decimal fixed point numbers.\\n    int256 constant ONE_18 = 1e18;\\n\\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\\n    // case of ln36, 36 decimals.\\n    int256 constant ONE_20 = 1e20;\\n    int256 constant ONE_36 = 1e36;\\n\\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\\n    //\\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\\n    // The smallest possible result is 10^(-18), which makes largest negative argument\\n    // ln(10^(-18)) = -41.446531673892822312.\\n    // We use 130.0 and -41.0 to have some safety margin.\\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\\n\\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\\n    // 256 bit integer.\\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\\n\\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\\n\\n    // 18 decimal constants\\n    int256 constant x0 = 128000000000000000000; // 2\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\u02c6(x0) (no decimals)\\n    int256 constant x1 = 64000000000000000000; // 2\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; // e\u02c6(x1) (no decimals)\\n\\n    // 20 decimal constants\\n    int256 constant x2 = 3200000000000000000000; // 2\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; // e\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; // 2\u02c64\\n    int256 constant a3 = 888611052050787263676000000; // e\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; // 2\u02c63\\n    int256 constant a4 = 298095798704172827474000; // e\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; // 2\u02c62\\n    int256 constant a5 = 5459815003314423907810; // e\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; // 2\u02c61\\n    int256 constant a6 = 738905609893065022723; // e\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; // 2\u02c60\\n    int256 constant a7 = 271828182845904523536; // e\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; // 2\u02c6-1\\n    int256 constant a8 = 164872127070012814685; // e\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; // 2\u02c6-2\\n    int256 constant a9 = 128402541668774148407; // e\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; // 2\u02c6-3\\n    int256 constant a10 = 113314845306682631683; // e\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; // 2\u02c6-4\\n    int256 constant a11 = 106449445891785942956; // e\u02c6(x11)\\n\\n    /**\\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\\n     *\\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        if (y == 0) {\\n            // We solve the 0^0 indetermination by making it equal one.\\n            return uint256(ONE_18);\\n        }\\n\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\\n        // x^y = exp(y * ln(x)).\\n\\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\\n        _require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\\n        int256 x_int256 = int256(x);\\n\\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\\n\\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\\n        _require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\\n        int256 y_int256 = int256(y);\\n\\n        int256 logx_times_y;\\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\\n            int256 ln_36_x = _ln_36(x_int256);\\n\\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\\n            // (downscaled) last 18 decimals.\\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\\n        } else {\\n            logx_times_y = _ln(x_int256) * y_int256;\\n        }\\n        logx_times_y /= ONE_18;\\n\\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\\n        _require(\\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\\n            Errors.PRODUCT_OUT_OF_BOUNDS\\n        );\\n\\n        return uint256(exp(logx_times_y));\\n    }\\n\\n    /**\\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\\n     *\\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function exp(int256 x) internal pure returns (int256) {\\n        _require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\\n\\n        if (x < 0) {\\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\\n            // Fixed point division requires multiplying by ONE_18.\\n            return ((ONE_18 * ONE_18) / exp(-x));\\n        }\\n\\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\\n        // decomposition.\\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\\n        // decomposition, which will be lower than the smallest x_n.\\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\\n\\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\\n        // decomposition.\\n\\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\\n        // it and compute the accumulated product.\\n\\n        int256 firstAN;\\n        if (x >= x0) {\\n            x -= x0;\\n            firstAN = a0;\\n        } else if (x >= x1) {\\n            x -= x1;\\n            firstAN = a1;\\n        } else {\\n            firstAN = 1; // One with no decimal places\\n        }\\n\\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\\n        // smaller terms.\\n        x *= 100;\\n\\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\\n        int256 product = ONE_20;\\n\\n        if (x >= x2) {\\n            x -= x2;\\n            product = (product * a2) / ONE_20;\\n        }\\n        if (x >= x3) {\\n            x -= x3;\\n            product = (product * a3) / ONE_20;\\n        }\\n        if (x >= x4) {\\n            x -= x4;\\n            product = (product * a4) / ONE_20;\\n        }\\n        if (x >= x5) {\\n            x -= x5;\\n            product = (product * a5) / ONE_20;\\n        }\\n        if (x >= x6) {\\n            x -= x6;\\n            product = (product * a6) / ONE_20;\\n        }\\n        if (x >= x7) {\\n            x -= x7;\\n            product = (product * a7) / ONE_20;\\n        }\\n        if (x >= x8) {\\n            x -= x8;\\n            product = (product * a8) / ONE_20;\\n        }\\n        if (x >= x9) {\\n            x -= x9;\\n            product = (product * a9) / ONE_20;\\n        }\\n\\n        // x10 and x11 are unnecessary here since we have high enough precision already.\\n\\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\\n\\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\\n\\n        // The first term is simply x.\\n        term = x;\\n        seriesSum += term;\\n\\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\\n\\n        term = ((term * x) / ONE_20) / 2;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 3;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 4;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 5;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 6;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 7;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 8;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 9;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 10;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 11;\\n        seriesSum += term;\\n\\n        term = ((term * x) / ONE_20) / 12;\\n        seriesSum += term;\\n\\n        // 12 Taylor terms are sufficient for 18 decimal precision.\\n\\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\\n        // and then drop two digits to return an 18 decimal value.\\n\\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\\n    }\\n\\n    /**\\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\\n     */\\n    function log(int256 arg, int256 base) internal pure returns (int256) {\\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\\n\\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\\n        // upscaling.\\n\\n        int256 logBase;\\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\\n            logBase = _ln_36(base);\\n        } else {\\n            logBase = _ln(base) * ONE_18;\\n        }\\n\\n        int256 logArg;\\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\\n            logArg = _ln_36(arg);\\n        } else {\\n            logArg = _ln(arg) * ONE_18;\\n        }\\n\\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\\n        return (logArg * ONE_18) / logBase;\\n    }\\n\\n    /**\\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function ln(int256 a) internal pure returns (int256) {\\n        // The real natural logarithm is not defined for negative numbers or zero.\\n        _require(a > 0, Errors.OUT_OF_BOUNDS);\\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\\n            return _ln_36(a) / ONE_18;\\n        } else {\\n            return _ln(a);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function _ln(int256 a) private pure returns (int256) {\\n        if (a < ONE_18) {\\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\\n            // Fixed point division requires multiplying by ONE_18.\\n            return (-_ln((ONE_18 * ONE_18) / a));\\n        }\\n\\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\\n        // decomposition, which will be lower than the smallest a_n.\\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\\n\\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\\n        // ONE_18 to convert them to fixed point.\\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\\n        // by it and compute the accumulated sum.\\n\\n        int256 sum = 0;\\n        if (a >= a0 * ONE_18) {\\n            a /= a0; // Integer, not fixed point division\\n            sum += x0;\\n        }\\n\\n        if (a >= a1 * ONE_18) {\\n            a /= a1; // Integer, not fixed point division\\n            sum += x1;\\n        }\\n\\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\\n        sum *= 100;\\n        a *= 100;\\n\\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\\n\\n        if (a >= a2) {\\n            a = (a * ONE_20) / a2;\\n            sum += x2;\\n        }\\n\\n        if (a >= a3) {\\n            a = (a * ONE_20) / a3;\\n            sum += x3;\\n        }\\n\\n        if (a >= a4) {\\n            a = (a * ONE_20) / a4;\\n            sum += x4;\\n        }\\n\\n        if (a >= a5) {\\n            a = (a * ONE_20) / a5;\\n            sum += x5;\\n        }\\n\\n        if (a >= a6) {\\n            a = (a * ONE_20) / a6;\\n            sum += x6;\\n        }\\n\\n        if (a >= a7) {\\n            a = (a * ONE_20) / a7;\\n            sum += x7;\\n        }\\n\\n        if (a >= a8) {\\n            a = (a * ONE_20) / a8;\\n            sum += x8;\\n        }\\n\\n        if (a >= a9) {\\n            a = (a * ONE_20) / a9;\\n            sum += x9;\\n        }\\n\\n        if (a >= a10) {\\n            a = (a * ONE_20) / a10;\\n            sum += x10;\\n        }\\n\\n        if (a >= a11) {\\n            a = (a * ONE_20) / a11;\\n            sum += x11;\\n        }\\n\\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\\n        // Let z = (a - 1) / (a + 1).\\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\\n        // division by ONE_20.\\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\\n        int256 z_squared = (z * z) / ONE_20;\\n\\n        // num is the numerator of the series: the z^(2 * n + 1) term\\n        int256 num = z;\\n\\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n        int256 seriesSum = num;\\n\\n        // In each step, the numerator is multiplied by z^2\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 3;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 5;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 7;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 9;\\n\\n        num = (num * z_squared) / ONE_20;\\n        seriesSum += num / 11;\\n\\n        // 6 Taylor terms are sufficient for 36 decimal precision.\\n\\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\\n        seriesSum *= 2;\\n\\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\\n        // value.\\n\\n        return (sum + seriesSum) / 100;\\n    }\\n\\n    /**\\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\\n     * for x close to one.\\n     *\\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\\n     */\\n    function _ln_36(int256 x) private pure returns (int256) {\\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\\n        // worthwhile.\\n\\n        // First, we transform x to a 36 digit fixed point value.\\n        x *= ONE_18;\\n\\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\\n        // division by ONE_36.\\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\\n        int256 z_squared = (z * z) / ONE_36;\\n\\n        // num is the numerator of the series: the z^(2 * n + 1) term\\n        int256 num = z;\\n\\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n        int256 seriesSum = num;\\n\\n        // In each step, the numerator is multiplied by z^2\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 3;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 5;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 7;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 9;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 11;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 13;\\n\\n        num = (num * z_squared) / ONE_36;\\n        seriesSum += num / 15;\\n\\n        // 8 Taylor terms are sufficient for 36 decimal precision.\\n\\n        // All that remains is multiplying by 2 (non fixed point).\\n        return seriesSum * 2;\\n    }\\n}\"\r\n    },\r\n    \"contracts/BIFI/strategies/Balancer/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\\n * Adapted from OpenZeppelin's SafeMath library\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        _require((b >= 0 && c >= a) || (b < 0 && c < a), Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b <= a, Errors.SUB_OVERFLOW);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        _require((b >= 0 && c <= a) || (b < 0 && c > a), Errors.SUB_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers of 256 bits.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers of 256 bits.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a * b;\\n        _require(a == 0 || c / a == b, Errors.MUL_OVERFLOW);\\n        return c;\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n        return a / b;\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            return 1 + (a - 1) / b;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/BIFI/strategies/Balancer/StableMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0; \\n\\nimport \\\"./FixedPoint.sol\\\";\\nimport \\\"./Math.sol\\\";\\nimport \\\"./BalancerErrors.sol\\\";\\n\\nlibrary StableMath {\\n  using FixedPoint for uint256;\\n\\n  uint256 internal constant _AMP_PRECISION = 1e3;\\n  \\n  function _calcTokenOutGivenExactBptIn(\\n    uint256 amp,\\n    uint256[] memory balances,\\n    uint256 tokenIndex,\\n    uint256 bptAmountIn,\\n    uint256 bptTotalSupply,\\n    uint256 currentInvariant,\\n    uint256 swapFeePercentage\\n  ) internal pure returns (uint256) {\\n    // Token out, so we round down overall.\\n\\n    uint256 newInvariant = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply).mulUp(currentInvariant);\\n\\n    // Calculate amount out without fee\\n    uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\\n      amp,\\n      balances,\\n      newInvariant,\\n      tokenIndex\\n    );\\n    uint256 amountOutWithoutFee = balances[tokenIndex].sub(newBalanceTokenIndex);\\n\\n    // First calculate the sum of all token balances, which will be used to calculate\\n    // the current weight of each token\\n    uint256 sumBalances = 0;\\n    for (uint256 i = 0; i < balances.length; i++) {\\n      sumBalances = sumBalances.add(balances[i]);\\n    }\\n\\n    // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\\n    // in swap fees.\\n    uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\\n    uint256 taxablePercentage = currentWeight.complement();\\n\\n    // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\\n    // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\\n    uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\\n    uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\\n\\n    // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\\n    return nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\\n  }\\n\\n  // This function calculates the balance of a given token (tokenIndex)\\n    // given all the other balances and the invariant\\n    function _getTokenBalanceGivenInvariantAndAllOtherBalances(\\n        uint256 amplificationParameter,\\n        uint256[] memory balances,\\n        uint256 invariant,\\n        uint256 tokenIndex\\n    ) internal pure returns (uint256) {\\n        // Rounds result up overall\\n\\n        uint256 ampTimesTotal = amplificationParameter * balances.length;\\n        uint256 sum = balances[0];\\n        uint256 P_D = balances[0] * balances.length;\\n        for (uint256 j = 1; j < balances.length; j++) {\\n            P_D = Math.divDown(Math.mul(Math.mul(P_D, balances[j]), balances.length), invariant);\\n            sum = sum.add(balances[j]);\\n        }\\n        // No need to use safe math, based on the loop above `sum` is greater than or equal to `balances[tokenIndex]`\\n        sum = sum - balances[tokenIndex];\\n\\n        uint256 inv2 = Math.mul(invariant, invariant);\\n        // We remove the balance from c by multiplying it\\n        uint256 c = Math.mul(\\n            Math.mul(Math.divUp(inv2, Math.mul(ampTimesTotal, P_D)), _AMP_PRECISION),\\n            balances[tokenIndex]\\n        );\\n        uint256 b = sum.add(Math.mul(Math.divDown(invariant, ampTimesTotal), _AMP_PRECISION));\\n\\n        // We iterate to find the balance\\n        uint256 prevTokenBalance = 0;\\n        // We multiply the first iteration outside the loop with the invariant to set the value of the\\n        // initial approximation.\\n        uint256 tokenBalance = Math.divUp(inv2.add(c), invariant.add(b));\\n\\n        for (uint256 i = 0; i < 255; i++) {\\n            prevTokenBalance = tokenBalance;\\n\\n            tokenBalance = Math.divUp(\\n                Math.mul(tokenBalance, tokenBalance).add(c),\\n                Math.mul(tokenBalance, 2).add(b).sub(invariant)\\n            );\\n\\n            if (tokenBalance > prevTokenBalance) {\\n                if (tokenBalance - prevTokenBalance <= 1) {\\n                    return tokenBalance;\\n                }\\n            } else if (prevTokenBalance - tokenBalance <= 1) {\\n                return tokenBalance;\\n            }\\n        }\\n\\n        _revert(Errors.STABLE_GET_BALANCE_DIDNT_CONVERGE);\\n    }\\n\\n    function _calculateInvariant(uint256 amplificationParameter, uint256[] memory balances)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        /**********************************************************************************************\\n        // invariant                                                                                 //\\n        // D = invariant                                                  D^(n+1)                    //\\n        // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\\n        // S = sum of balances                                             n^n P                     //\\n        // P = product of balances                                                                   //\\n        // n = number of tokens                                                                      //\\n        **********************************************************************************************/\\n\\n        // Always round down, to match Vyper's arithmetic (which always truncates).\\n\\n        uint256 sum = 0; // S in the Curve version\\n        uint256 numTokens = balances.length;\\n        for (uint256 i = 0; i < numTokens; i++) {\\n            sum = sum.add(balances[i]);\\n        }\\n        if (sum == 0) {\\n            return 0;\\n        }\\n\\n        uint256 prevInvariant; // Dprev in the Curve version\\n        uint256 invariant = sum; // D in the Curve version\\n        uint256 ampTimesTotal = amplificationParameter * numTokens; // Ann in the Curve version\\n\\n        for (uint256 i = 0; i < 255; i++) {\\n            uint256 D_P = invariant;\\n\\n            for (uint256 j = 0; j < numTokens; j++) {\\n                // (D_P * invariant) / (balances[j] * numTokens)\\n                D_P = Math.divDown(Math.mul(D_P, invariant), Math.mul(balances[j], numTokens));\\n            }\\n\\n            prevInvariant = invariant;\\n\\n            invariant = Math.divDown(\\n                Math.mul(\\n                    // (ampTimesTotal * sum) / AMP_PRECISION + D_P * numTokens\\n                    (Math.divDown(Math.mul(ampTimesTotal, sum), _AMP_PRECISION).add(Math.mul(D_P, numTokens))),\\n                    invariant\\n                ),\\n                // ((ampTimesTotal - _AMP_PRECISION) * invariant) / _AMP_PRECISION + (numTokens + 1) * D_P\\n                (\\n                    Math.divDown(Math.mul((ampTimesTotal - _AMP_PRECISION), invariant), _AMP_PRECISION).add(\\n                        Math.mul((numTokens + 1), D_P)\\n                    )\\n                )\\n            );\\n\\n            if (invariant > prevInvariant) {\\n                if (invariant - prevInvariant <= 1) {\\n                    return invariant;\\n                }\\n            } else if (prevInvariant - invariant <= 1) {\\n                return invariant;\\n            }\\n        }\\n\\n        _revert(Errors.STABLE_INVARIANT_DIDNT_CONVERGE);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BIFI/strategies/Balancer/WeightedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0; \\n\\nimport \\\"./FixedPoint.sol\\\";\\n\\nlibrary WeightedMath {\\n  using FixedPoint for uint256;\\n  \\n  // Invariant shrink limit: non-proportional exits cannot cause the invariant to decrease by less than this ratio.\\n  uint256 internal constant _MIN_INVARIANT_RATIO = 0.7e18;\\n\\n  function _calcTokenOutGivenExactBptIn(\\n    uint256 balance,\\n    uint256 normalizedWeight,\\n    uint256 bptAmountIn,\\n    uint256 bptTotalSupply,\\n    uint256 swapFeePercentage\\n  ) internal pure returns (uint256) {\\n    /*****************************************************************************************\\n    // exactBPTInForTokenOut                                                                //\\n    // a = amountOut                                                                        //\\n    // b = balance                     /      /    totalBPT - bptIn       \\\\    (1 / w)  \\\\   //\\n    // bptIn = bptAmountIn    a = b * |  1 - | --------------------------  | ^           |  //\\n    // bpt = totalBPT                  \\\\      \\\\       totalBPT            /             /   //\\n    // w = weight                                                                           //\\n    *****************************************************************************************/\\n\\n    // Token out, so we round down overall. The multiplication rounds down, but the power rounds up (so the base\\n    // rounds up). Because (totalBPT - bptIn) / totalBPT <= 1, the exponent rounds down.\\n\\n    // Calculate the factor by which the invariant will decrease after burning BPTAmountIn\\n    uint256 invariantRatio = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply);\\n    require(invariantRatio >= _MIN_INVARIANT_RATIO, \\\"balancer: MIN_BPT_IN_FOR_TOKEN_OUT\\\");\\n\\n    // Calculate by how much the token balance has to decrease to match invariantRatio\\n    uint256 balanceRatio = invariantRatio.powUp(FixedPoint.ONE.divDown(normalizedWeight));\\n\\n    // Because of rounding up, balanceRatio can be greater than one. Using complement prevents reverts.\\n    uint256 amountOutWithoutFee = balance.mulDown(balanceRatio.complement());\\n\\n    // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\\n    // in swap fees.\\n\\n    // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\\n    // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\\n    uint256 taxableAmount = amountOutWithoutFee.mulUp(normalizedWeight.complement());\\n    uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\\n    uint256 taxableAmountMinusFees = taxableAmount.mulUp(swapFeePercentage.complement());\\n\\n    return nonTaxableAmount.add(taxableAmountMinusFees);\\n  }\\n\\n  function _calcTokensOutGivenExactBptIn(\\n    uint256[] memory balances,\\n    uint256 bptAmountIn,\\n    uint256 bptTotalSupply\\n  ) internal pure returns (uint256[] memory) {\\n    /**********************************************************************************************\\n    // exactBPTInForTokensOut                                                                    //\\n    // (per token)                                                                               //\\n    // aO = amountOut                  /        bptIn         \\\\                                  //\\n    // b = balance           a0 = b * | ---------------------  |                                 //\\n    // bptIn = bptAmountIn             \\\\       totalBPT       /                                  //\\n    // bpt = totalBPT                                                                            //\\n    **********************************************************************************************/\\n\\n    uint256[] memory amounts = new uint256[](balances.length);\\n    for (uint256 i = 0; i < balances.length;) {\\n      amounts[i] = balances[i].mulDown(bptAmountIn).divDown(bptTotalSupply);\\n      unchecked { ++i; }\\n    }\\n    return amounts;\\n  }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_pid1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_pid2\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_bptPool1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bptPool2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakedWithdrawAmount\",\"type\":\"uint256\"}],\"name\":\"calcRemoveLiqAuraBal2Pools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"withdrawAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bptPool1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bptPool2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_poolId1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_poolId2\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"getUnderlyingAuraBal2Pools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AuraLibPub", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}