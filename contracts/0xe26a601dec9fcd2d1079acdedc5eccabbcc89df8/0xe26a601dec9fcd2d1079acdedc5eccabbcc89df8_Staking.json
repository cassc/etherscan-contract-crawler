{"SourceCode": "// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/elmo_staking_v2.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\n\r\n\r\n\r\ninterface IBurn {\r\n    function publicBurn(uint256 amount) external;\r\n}\r\ninterface IBalanceOf721 {\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n}\r\n\r\ncontract Staking is Ownable, ReentrancyGuard {\r\n//constant\r\n    uint256 public constant BURN_OPTION_ONE = 25;\r\n    uint256 public constant BURN_OPTION_TWO = 50;\r\n    uint256 public constant BURN_OPTION_THREE = 75;\r\n    uint256 public constant DELAY_WITHDRAW = 14 days;\r\n    uint256 public constant EMERGENCY_FEE = 10;\r\n    uint256 public immutable MAX_DEPOSIT_LIMIT; \r\n    uint256 public immutable PRECISION_FACTOR;\r\n    uint256 public immutable TOKEN_DECIMALS;\r\n    \r\n// bool\r\n    bool public hasUserLimit;\r\n    bool public isInitialized;\r\n    bool public poolIsOnline;\r\n    bool public depositEnabled = true;\r\n    bool public compoundEnabled = true;\r\n//address\r\n    address public nftContractAddress;\r\n// uint\r\n    uint256 public totalUsersInStaking;\r\n    uint256 public poolTotalReward;\r\n    uint256 public accTokenPerShare;\r\n    uint256 public startBlock;\r\n    uint256 public lastRewardBlock;\r\n    uint256 public rewardPerBlock;\r\n    uint256 public totalBurned;\r\n    uint256 public totalUsersStake;\r\n    uint256 public totalUsersRewards;\r\n    uint256 public nftBoostPercentage;\r\n    \r\n// staking tokens\r\n    IERC20Metadata public rewardToken;\r\n\r\n// mapping\r\n    mapping(address => UserInfo) public userInfo;\r\n    mapping(uint => uint) public optionToBurn; //0=None 1=25% 2=50% 3=75%\r\n// struct\r\n    struct UserInfo {\r\n        uint256 amount; // How many staked tokens the user has provided\r\n        uint256 rewardDebt; // Reward debt\r\n        uint256 withdrawInitTime; // // init the cooldown timer to withdraw, save block.timestamp\r\n        uint256 burnChosen; // burn option  \r\n        uint256 amountToWithdraw; // amount to withdraw\r\n    }\r\n\r\n// event\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event PoolFunded(uint256 amount);\r\n    event Compound(address indexed user, uint256 amount);\r\n    event ClaimReward(address indexed user, uint256 amount);\r\n    event UserCompoundUpdated(address indexed user, bool onDeposit, bool onWithdraw);\r\n    event WithdrawInitiated(address indexed user, uint256 amount, uint256 burnedAmount);\r\n    event PoolStateUpdated(bool poolIsOnline, bool depositEnabled, bool compoundEnabled);\r\n    event NftBoostUpdated(uint256 percentage);\r\n    event TokenRecovered(address indexed tokenAddress, uint256 tokenAmount);\r\n    event BlockRewardUpdated(uint256 rewardPerBlock);\r\n    event PoolStarted(uint256 startBlock, uint256 rewardPerBlock);\r\n\r\n//constructor\r\n    /// @notice Contract constructor that initializes the Smart Contract.\r\n    /// @param _rewardToken The address of the ERC20 token used as a reward.\r\n    /// @param _nftContractAddress The address of the NFT contract used as reward boost.\r\n    constructor(IERC20Metadata _rewardToken, address _nftContractAddress) {\r\n        rewardToken = _rewardToken;\r\n        TOKEN_DECIMALS = uint256(rewardToken.decimals());\r\n        require(TOKEN_DECIMALS < 30, \"Must be inferior to 30\");\r\n        MAX_DEPOSIT_LIMIT= 2000000*10**TOKEN_DECIMALS;\r\n        PRECISION_FACTOR = uint256(10**(uint256(30) - TOKEN_DECIMALS));\r\n        optionToBurn[1] = BURN_OPTION_ONE;\r\n        optionToBurn[2] = BURN_OPTION_TWO;\r\n        optionToBurn[3] = BURN_OPTION_THREE;\r\n        nftContractAddress = _nftContractAddress;\r\n    }\r\n\r\n//owner function\r\n    /// @notice Allows the contract owner to set the state of the pool.\r\n    /// @param _poolIsOnline Enable or disable the pool.\r\n    /// @param _depositEnabled Enable or disable user deposits.\r\n    /// @param _compoundEnabled Enable or disable user compound functionality.\r\n    function setPoolState(bool _poolIsOnline, bool _depositEnabled, bool _compoundEnabled) external onlyOwner {\r\n        poolIsOnline = _poolIsOnline;\r\n        depositEnabled = _depositEnabled;\r\n        compoundEnabled = _compoundEnabled; \r\n        emit PoolStateUpdated(_poolIsOnline, _depositEnabled, _compoundEnabled);\r\n    }\r\n\r\n    /// @notice Allows the contract owner to set the NFT boost percentage.\r\n    /// @param _percentage The new NFT boost percentage to be set.\r\n    function setNftBoostPercentage(uint256 _percentage) external onlyOwner {\r\n        nftBoostPercentage = _percentage;\r\n        emit NftBoostUpdated(_percentage);\r\n    }\r\n\r\n    /// @notice Allows the contract owner to recover wrongly sent tokens to the contract.\r\n    /// @param _tokenAddress The address of the token to be recovered.\r\n    /// @param _tokenAmount The amount of tokens to be recovered.\r\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner { //@msg NOT Withdraw any tokens from the contract\r\n        require(_tokenAddress != address(rewardToken), \"Cannot be staked or reward tokens\");\r\n        IERC20Metadata(_tokenAddress).transfer(address(msg.sender), _tokenAmount);\r\n        emit TokenRecovered(_tokenAddress, _tokenAmount);\r\n    }\r\n\r\n    /// @notice Allows the contract owner to update the reward rate per block.\r\n    /// @param _rewardPerBlock The new token amount per block to be set.\r\n    function updateRewardPerBlock(uint256 _rewardPerBlock) external onlyOwner { //@msg Update APY\r\n        require(_rewardPerBlock > 0, \"Reward per block should be greater than 0\");\r\n        rewardPerBlock = _rewardPerBlock;\r\n        emit BlockRewardUpdated(_rewardPerBlock);\r\n    }\r\n\r\n    /// @notice Initializes the staking pool with the provided reward rate per block.\r\n    /// @param _rewardPerBlock The reward rate per block to be set for the staking pool.\r\n    function istart(uint256 _rewardPerBlock) external onlyOwner {\r\n        require(!isInitialized, \"Already initialized\");\r\n        isInitialized = true;\r\n        rewardPerBlock = _rewardPerBlock;\r\n        startBlock = block.number;\r\n        poolIsOnline = true;\r\n        lastRewardBlock = startBlock;\r\n        emit PoolStarted(startBlock, _rewardPerBlock);\r\n    }\r\n\r\n//modifier\r\n    /// @notice Modifier to check if the staking pool is online and available for certain actions.\r\n    /// @param actionType The type of action: 0 for deposit, 1 for compound.\r\n    modifier isPoolOnline(uint8 actionType) {\r\n        require(poolIsOnline || msg.sender == owner(),\"staking platform not available now.\");\r\n        if (actionType == 0) {\r\n            require(depositEnabled || msg.sender == owner(),\"deposits not available now.\");\r\n        }\r\n        else if (actionType == 1) {\r\n            require(compoundEnabled || msg.sender == owner(),\"compounds not available now.\");\r\n        } \r\n        _;\r\n    }\r\n\r\n\r\n// user functions\r\n    /// @notice Allows users to top up the staking pool with additional reward tokens.\r\n    /// @param amount The amount of reward tokens to be added to the pool.\r\n    function fundPool(uint256 amount) external {\r\n        poolTotalReward += amount;\r\n        rewardToken.transferFrom(address(msg.sender), address(this), amount);\r\n        emit PoolFunded(amount);\r\n    }\r\n\r\n    /// @notice Allows users to deposit tokens into the staking pool.\r\n    /// @param _amount The amount of reward tokens to be deposited into the staking pool.\r\n    /// @param _burnOption The chosen burn option (1-25%, 2-50%, 3-75%) for the user's rewards.\r\n    function deposit(uint256 _amount, uint256 _burnOption) external isPoolOnline(0) nonReentrant {\r\n        require(_burnOption == 1 || _burnOption == 2 || _burnOption == 3, \"invalid burn option\");\r\n        require(userInfo[msg.sender].withdrawInitTime < block.timestamp, \"cooldown not passed\");\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint userAmountBefore = user.amount;\r\n        require(_amount + userAmountBefore <= MAX_DEPOSIT_LIMIT, \"User amount above limit\");\r\n        if (_amount != 0) {\r\n            user.amount = userAmountBefore + _amount;\r\n            totalUsersStake += _amount;\r\n            rewardToken.transferFrom(address(msg.sender), address(this), _amount);\r\n        }else{\r\n            revert(\"can't deposit 0 tokens\");\r\n        }\r\n        if (userAmountBefore == 0) {\r\n            totalUsersInStaking += 1;\r\n            user.burnChosen = _burnOption;\r\n        }\r\n\r\n        _updatePool();\r\n\r\n        user.rewardDebt = user.amount * accTokenPerShare / PRECISION_FACTOR;\r\n\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    /// @notice Initiates the withdrawal process for the staked reward tokens.\r\n    function initWithdraw() external nonReentrant {// unstack init\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint userAmnt = user.amount;\r\n        require(userAmnt != 0, \"No amount stacked\");\r\n        require(user.amountToWithdraw == 0, \"Withdraw already initiated\");\r\n        _updatePool();\r\n        uint burnAmnout;\r\n        uint256 pending =_internalPendingCalc(userAmnt, accTokenPerShare, user.rewardDebt); \r\n        if (pending != 0) {\r\n            totalUsersRewards += pending;\r\n            poolTotalReward -= pending;\r\n            burnAmnout = pending * optionToBurn[user.burnChosen] / 100;\r\n            totalBurned += burnAmnout;\r\n            user.amountToWithdraw = userAmnt + (pending - burnAmnout);\r\n            IBurn(address(rewardToken)).publicBurn(burnAmnout);\r\n            emit ClaimReward(msg.sender,pending - burnAmnout);\r\n        }else{\r\n            user.amountToWithdraw = userAmnt;\r\n        }\r\n        totalUsersInStaking -= 1;\r\n        totalUsersStake -= userAmnt;\r\n        user.withdrawInitTime = block.timestamp;\r\n        user.rewardDebt = userAmnt * accTokenPerShare / PRECISION_FACTOR;\r\n        emit WithdrawInitiated(msg.sender, userAmnt + (pending - burnAmnout), burnAmnout);\r\n    }\r\n\r\n    /// @notice Allows users to withdraw their pending rewards from the staking pool.\r\n    function withdrawReward() external nonReentrant{ \r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.amountToWithdraw == 0, \"Cant have rewards if withdraw initiated\");\r\n        uint userAmnt = user.amount;\r\n        require(userAmnt != 0, \"0 stacked\");\r\n        _updatePool();\r\n\r\n        uint256 pending = _internalPendingCalc(userAmnt, accTokenPerShare, user.rewardDebt); \r\n        if (pending > 0) {\r\n            totalUsersRewards += pending;\r\n            poolTotalReward -= pending;\r\n            uint burnAmnout = pending * optionToBurn[user.burnChosen] / 100;\r\n            totalBurned += burnAmnout;\r\n            IBurn(address(rewardToken)).publicBurn(burnAmnout);\r\n            rewardToken.transfer(address(msg.sender), pending-burnAmnout);\r\n            emit ClaimReward(msg.sender,pending - burnAmnout);\r\n        }\r\n        user.rewardDebt = userAmnt * accTokenPerShare / PRECISION_FACTOR;\r\n    }\r\n\r\n    /// @notice Allows users to withdraw their staked reward tokens after the lock time has passed.\r\n    function withdraw() external nonReentrant {// unstack\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 amountToWithdraw = user.amountToWithdraw;\r\n        require(amountToWithdraw != 0, \"No amount to withdraw\");\r\n        require(user.withdrawInitTime + DELAY_WITHDRAW <= block.timestamp, \"Minimum lock time not reached\");\r\n        \r\n        delete userInfo[msg.sender];\r\n        rewardToken.transfer(address(msg.sender), amountToWithdraw);\r\n        \r\n        emit Withdraw(msg.sender, amountToWithdraw);\r\n    }\r\n\r\n\r\n    /// @notice Allows users to compound their pending rewards by adding them to their staked amount.\r\n    function compound() external isPoolOnline(1) nonReentrant {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint userAmnt = user.amount;\r\n        require(userAmnt != 0, \"No amount stacked\");\r\n        require(user.amountToWithdraw == 0, \"Cant compound if withdraw initiated\");\r\n        if(userAmnt != 0) {\r\n            _updatePool();\r\n            uint pending = _internalPendingCalc(userAmnt, accTokenPerShare, user.rewardDebt);\r\n            if(pending != 0) {\r\n                totalUsersRewards += pending;\r\n                poolTotalReward -= pending;\r\n                uint burnAmnout = pending * optionToBurn[user.burnChosen] / 100;\r\n                uint effectivePending = pending - burnAmnout;\r\n                totalBurned += burnAmnout;\r\n                totalUsersStake += effectivePending;\r\n                user.amount = user.amount + effectivePending;\r\n                user.rewardDebt = user.amount * accTokenPerShare / PRECISION_FACTOR;\r\n                IBurn(address(rewardToken)).publicBurn(burnAmnout);\r\n                emit Compound(msg.sender, effectivePending);\r\n            }\r\n        } else {\r\n            revert(\"nothing to compound\");\r\n        }\r\n    }\r\n\r\n    // @notice Allows users to perform an emergency withdrawal from the staking pool.\r\n    function emergencyWithdraw() external nonReentrant {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 amountToWithdraw = user.amount;\r\n        require(amountToWithdraw != 0, \"No amount to withdraw\");\r\n        totalUsersStake -= amountToWithdraw;\r\n        uint256 feePart = (amountToWithdraw * EMERGENCY_FEE / 100);\r\n        amountToWithdraw = amountToWithdraw - feePart; //fee back to pool\r\n        poolTotalReward += feePart;\r\n        totalUsersInStaking -= 1;\r\n        delete userInfo[msg.sender];\r\n        rewardToken.transfer(address(msg.sender), amountToWithdraw);\r\n        emit EmergencyWithdraw(msg.sender, amountToWithdraw);\r\n    }\r\n\r\n\r\n\r\n    /// @notice Calculates the pending rewards for a user's staked amount, considering the NFT boost.\r\n    /// @param amnt The user's staked amount for which the pending rewards are calculated.\r\n    /// @param accTokenShare The accumulated token share in the staking pool at the time of calculation.\r\n    /// @param debt The user's reward debt at the time of calculation.\r\n    /// @return pending The calculated pending rewards for the user's staked amount, considering the NFT boost.\r\n    function _internalPendingCalc(uint amnt, uint accTokenShare, uint debt) internal view returns(uint256 pending) { \r\n        pending = amnt * accTokenShare / PRECISION_FACTOR - debt;\r\n        uint hasNft = IBalanceOf721(nftContractAddress).balanceOf(msg.sender); \r\n        if(hasNft != 0) {\r\n            pending = pending+(pending * nftBoostPercentage / 100);\r\n        }\r\n        return pending;\r\n    }\r\n\r\n\r\n    /// @notice Calculates the pending and effective pending rewards for a specific user, considering the NFT boost(if applicable).\r\n    /// @param _user The address of the user for whom the rewards are to be calculated.\r\n    /// @return pending The total pending rewards for the user's staked amount, including the NFT boost if applicable.\r\n    /// @return effectivePending The effective pending rewards after considering the burn option (if any) and NFT boost (if applicable).\r\n    function pendingReward(address _user) external view returns (uint256 pending, uint256 effectivePending) {\r\n        UserInfo storage user = userInfo[_user];\r\n        if(user.amountToWithdraw != 0){\r\n            pending = 0;\r\n            effectivePending = user.amountToWithdraw;\r\n        } else {\r\n            if (block.number > lastRewardBlock && totalUsersStake != 0) {\r\n                uint256 multiplier = block.number - lastRewardBlock;\r\n                uint256 cakeReward = multiplier * rewardPerBlock;\r\n                uint256 adjustedTokenPerShare = accTokenPerShare + (cakeReward * PRECISION_FACTOR / totalUsersStake);\r\n                pending = user.amount * adjustedTokenPerShare / PRECISION_FACTOR - user.rewardDebt;\r\n\r\n            } else {\r\n                pending = user.amount * accTokenPerShare / PRECISION_FACTOR - user.rewardDebt;\r\n            }\r\n            uint hasNft = IBalanceOf721(nftContractAddress).balanceOf(_user); \r\n            if(hasNft != 0) {\r\n                pending = pending + (pending * nftBoostPercentage / 100);\r\n            }\r\n            uint burnAmnout = pending * optionToBurn[user.burnChosen] / 100;\r\n            effectivePending = pending - burnAmnout;\r\n        }\r\n    }\r\n\r\n    /// @notice Updates the staking pool by calculating and accumulating the reward tokens (cakeReward) per share of staked tokens.\r\n    function _updatePool() internal {\r\n        if (block.number <= lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 stakedTokenSupply = totalUsersStake;\r\n        if (stakedTokenSupply == 0) {\r\n            lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        uint256 multiplier = block.number - lastRewardBlock;\r\n        uint256 cakeReward = multiplier * rewardPerBlock;\r\n        accTokenPerShare = accTokenPerShare + (cakeReward * PRECISION_FACTOR / stakedTokenSupply);\r\n        lastRewardBlock = block.number;\r\n    }\r\n\r\n    /// @notice Get the available balance of the staking pool.\r\n    /// @return calc The available balance of the staking pool (total reward tokens available for distribution).\r\n    function getPoolEffectiveBalance() external view returns(uint256 calc){\r\n        calc = rewardToken.balanceOf(address(this)) - totalUsersStake;\r\n        return calc;\r\n    }\r\n\r\n    /// @notice Calculate the Annual Percentage Yield (APY) for the staking pool.\r\n    /// @return calculatedApr The calculated Annual Percentage Yield (APY) for the staking pool.\r\n    function calculateAPR() external view returns (uint256 calculatedApr, uint256 aprWithNft) {\r\n        uint blockPerYear = (86400/12)*365; \r\n        if (totalUsersStake == 0 || poolTotalReward == 0) {\r\n            calculatedApr = 0;\r\n            aprWithNft = 0;\r\n        }else{\r\n            calculatedApr = (rewardPerBlock * blockPerYear) / totalUsersStake;\r\n            uint blockBoosted = rewardPerBlock + (rewardPerBlock * nftBoostPercentage / 100);\r\n            aprWithNft = (blockBoosted * blockPerYear) / totalUsersStake;\r\n        }\r\n        \r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20Metadata\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"BlockRewardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Compound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"NftBoostUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PoolFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"PoolStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"poolIsOnline\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"depositEnabled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"compoundEnabled\",\"type\":\"bool\"}],\"name\":\"PoolStateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"TokenRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"onDeposit\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"onWithdraw\",\"type\":\"bool\"}],\"name\":\"UserCompoundUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnedAmount\",\"type\":\"uint256\"}],\"name\":\"WithdrawInitiated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BURN_OPTION_ONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BURN_OPTION_THREE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BURN_OPTION_TWO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DELAY_WITHDRAW\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EMERGENCY_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DEPOSIT_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECISION_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accTokenPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateAPR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"calculatedApr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aprWithNft\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compoundEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnOption\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fundPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolEffectiveBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"calc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasUserLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"istart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftBoostPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"optionToBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"effectivePending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolIsOnline\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTotalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverWrongTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20Metadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"setNftBoostPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_poolIsOnline\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_depositEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_compoundEnabled\",\"type\":\"bool\"}],\"name\":\"setPoolState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsersInStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsersRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsersStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"updateRewardPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawInitTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnChosen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000335f4e66b9b61cee5ceade4e727fcec20156b2f00000000000000000000000009122f8948dba98b049f61ce6632fad85d82e5348", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://741ce9fc56b66a15dd7ab369005d4961fb742b3da5b4a41221cf140431c91cab"}