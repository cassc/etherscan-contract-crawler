{"SourceCode": "// SPDX-License-Identifier: BUSL-1.1\r\n// File: lib/ipor-protocol/contracts/libraries/StorageLib.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Storage ID's associated with the IPOR Protocol Router.\r\nlibrary StorageLib {\r\n    uint256 constant STORAGE_SLOT_BASE = 1_000_000;\r\n\r\n    // append only\r\n    enum StorageId {\r\n        /// @dev The address of the contract owner.\r\n        Owner,\r\n        AppointedOwner,\r\n        Paused,\r\n        PauseGuardian,\r\n        ReentrancyStatus,\r\n        RouterFunctionPaused,\r\n        AmmSwapsLiquidators,\r\n        AmmPoolsAppointedToRebalance,\r\n        AmmPoolsParams\r\n    }\r\n\r\n    /// @notice Struct which contains owner address of IPOR Protocol Router.\r\n    struct OwnerStorage {\r\n        address owner;\r\n    }\r\n\r\n    /// @notice Struct which contains appointed owner address of IPOR Protocol Router.\r\n    struct AppointedOwnerStorage {\r\n        address appointedOwner;\r\n    }\r\n\r\n    /// @notice Struct which contains reentrancy status of IPOR Protocol Router.\r\n    struct ReentrancyStatusStorage {\r\n        uint256 value;\r\n    }\r\n\r\n    /// @notice Struct which contains information about swap liquidators.\r\n    /// @dev First key is an asset (pool), second key is an liquidator address in the asset pool,\r\n    /// value is a flag to indicate whether account is a liquidator.\r\n    /// True - account is a liquidator, False - account is not a liquidator.\r\n    struct AmmSwapsLiquidatorsStorage {\r\n        mapping(address => mapping(address => bool)) value;\r\n    }\r\n\r\n    /// @notice Struct which contains information about accounts appointed to rebalance.\r\n    /// @dev first key - asset address, second key - account address which is allowed to rebalance in the asset pool,\r\n    /// value - flag to indicate whether account is allowed to rebalance. True - allowed, False - not allowed.\r\n    struct AmmPoolsAppointedToRebalanceStorage {\r\n        mapping(address => mapping(address => bool)) value;\r\n    }\r\n\r\n    struct AmmPoolsParamsValue {\r\n        /// @dev max liquidity pool balance in the asset pool, represented without 18 decimals\r\n        uint32 maxLiquidityPoolBalance;\r\n        /// @dev The threshold for auto-rebalancing the pool. Value represented without 18 decimals.\r\n        /// Value represents multiplication of 1000.\r\n        uint32 autoRebalanceThresholdInThousands;\r\n        /// @dev asset management ratio, represented without 18 decimals, value represents percentage with 2 decimals\r\n        /// 65% = 6500, 99,99% = 9999, this is a percentage which stay in Amm Treasury in opposite to Asset Management\r\n        /// based on AMM Treasury balance (100%).\r\n        uint16 ammTreasuryAndAssetManagementRatio;\r\n    }\r\n\r\n    /// @dev key - asset address, value - struct AmmOpenSwapParamsValue\r\n    struct AmmPoolsParamsStorage {\r\n        mapping(address => AmmPoolsParamsValue) value;\r\n    }\r\n\r\n    /// @dev key - function sig, value - 1 if function is paused, 0 if not\r\n    struct RouterFunctionPausedStorage {\r\n        mapping(bytes4 => uint256) value;\r\n    }\r\n\r\n    /// @notice Gets Ipor Protocol Router owner address.\r\n    function getOwner() internal pure returns (OwnerStorage storage owner) {\r\n        uint256 slot = _getStorageSlot(StorageId.Owner);\r\n        assembly {\r\n            owner.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets Ipor Protocol Router appointed owner address.\r\n    function getAppointedOwner() internal pure returns (AppointedOwnerStorage storage appointedOwner) {\r\n        uint256 slot = _getStorageSlot(StorageId.AppointedOwner);\r\n        assembly {\r\n            appointedOwner.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets Ipor Protocol Router reentrancy status.\r\n    function getReentrancyStatus() internal pure returns (ReentrancyStatusStorage storage reentrancyStatus) {\r\n        uint256 slot = _getStorageSlot(StorageId.ReentrancyStatus);\r\n        assembly {\r\n            reentrancyStatus.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets information if function is paused in Ipor Protocol Router.\r\n    function getRouterFunctionPaused() internal pure returns (RouterFunctionPausedStorage storage paused) {\r\n        uint256 slot = _getStorageSlot(StorageId.RouterFunctionPaused);\r\n        assembly {\r\n            paused.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets point to pause guardian storage.\r\n    function getPauseGuardianStorage() internal pure returns (mapping(address => bool) storage store) {\r\n        uint256 slot = _getStorageSlot(StorageId.PauseGuardian);\r\n        assembly {\r\n            store.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets point to liquidators storage.\r\n    /// @return store - point to liquidators storage.\r\n    function getAmmSwapsLiquidatorsStorage() internal pure returns (AmmSwapsLiquidatorsStorage storage store) {\r\n        uint256 slot = _getStorageSlot(StorageId.AmmSwapsLiquidators);\r\n        assembly {\r\n            store.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets point to accounts appointed to rebalance storage.\r\n    /// @return store - point to accounts appointed to rebalance storage.\r\n    function getAmmPoolsAppointedToRebalanceStorage()\r\n        internal\r\n        pure\r\n        returns (AmmPoolsAppointedToRebalanceStorage storage store)\r\n    {\r\n        uint256 slot = _getStorageSlot(StorageId.AmmPoolsAppointedToRebalance);\r\n        assembly {\r\n            store.slot := slot\r\n        }\r\n    }\r\n\r\n    /// @notice Gets point to amm pools params storage.\r\n    /// @return store - point to amm pools params storage.\r\n    function getAmmPoolsParamsStorage() internal pure returns (AmmPoolsParamsStorage storage store) {\r\n        uint256 slot = _getStorageSlot(StorageId.AmmPoolsParams);\r\n        assembly {\r\n            store.slot := slot\r\n        }\r\n    }\r\n\r\n    function _getStorageSlot(StorageId storageId) private pure returns (uint256 slot) {\r\n        return uint256(storageId) + STORAGE_SLOT_BASE;\r\n    }\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/security/PauseManager.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n/// @title Ipor Protocol Router Pause Manager library\r\nlibrary PauseManager {\r\n    /// @notice Emitted when new pause guardian is added\r\n    /// @param guardians List of addresses of guardian\r\n    event PauseGuardiansAdded(address[] indexed guardians);\r\n\r\n    /// @notice Emitted when pause guardian is removed\r\n    /// @param guardians List of addresses of guardian\r\n    event PauseGuardiansRemoved(address[] indexed guardians);\r\n\r\n    /// @notice Checks if account is Ipor Protocol Router pause guardian\r\n    /// @param account Address of guardian\r\n    /// @return true if account is Ipor Protocol Router pause guardian\r\n    function isPauseGuardian(address account) internal view returns (bool) {\r\n        mapping(address => bool) storage pauseGuardians = StorageLib.getPauseGuardianStorage();\r\n        return pauseGuardians[account];\r\n    }\r\n\r\n    /// @notice Adds Ipor Protocol Router pause guardian\r\n    /// @param newGuardians Addresses of guardians\r\n    function addPauseGuardians(address[] calldata newGuardians) internal {\r\n        uint256 length = newGuardians.length;\r\n        if (length == 0) {\r\n            return;\r\n        }\r\n\r\n        mapping(address => bool) storage pauseGuardians = StorageLib.getPauseGuardianStorage();\r\n\r\n        for (uint256 i; i < length; ) {\r\n            pauseGuardians[newGuardians[i]] = true;\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n        emit PauseGuardiansAdded(newGuardians);\r\n    }\r\n\r\n    /// @notice Removes Ipor Protocol Router pause guardian\r\n    /// @param guardians Addresses of guardians\r\n    function removePauseGuardians(address[] calldata guardians) internal {\r\n        uint256 length = guardians.length;\r\n\r\n        if (length == 0) {\r\n            return;\r\n        }\r\n\r\n        mapping(address => bool) storage pauseGuardians = StorageLib.getPauseGuardianStorage();\r\n\r\n        for (uint256 i; i < length; ) {\r\n            pauseGuardians[guardians[i]] = false;\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n        emit PauseGuardiansRemoved(guardians);\r\n    }\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/libraries/errors/IporErrors.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\nlibrary IporErrors {\r\n    // 000-199 - general codes\r\n\r\n    /// @notice General problem, address is wrong\r\n    string public constant WRONG_ADDRESS = \"IPOR_000\";\r\n\r\n    /// @notice General problem. Wrong decimals\r\n    string public constant WRONG_DECIMALS = \"IPOR_001\";\r\n\r\n    /// @notice General problem, addresses mismatch\r\n    string public constant ADDRESSES_MISMATCH = \"IPOR_002\";\r\n\r\n    /// @notice Sender's asset balance is too low to transfer and to open a swap\r\n    string public constant SENDER_ASSET_BALANCE_TOO_LOW = \"IPOR_003\";\r\n\r\n    /// @notice Value is not greater than zero\r\n    string public constant VALUE_NOT_GREATER_THAN_ZERO = \"IPOR_004\";\r\n\r\n    /// @notice Input arrays length mismatch\r\n    string public constant INPUT_ARRAYS_LENGTH_MISMATCH = \"IPOR_005\";\r\n\r\n    /// @notice Amount is too low to transfer\r\n    string public constant NOT_ENOUGH_AMOUNT_TO_TRANSFER = \"IPOR_006\";\r\n\r\n    /// @notice msg.sender is not an appointed owner, so cannot confirm his appointment to be an owner of a specific smart contract\r\n    string public constant SENDER_NOT_APPOINTED_OWNER = \"IPOR_007\";\r\n\r\n    /// @notice only Router can have access to function\r\n    string public constant CALLER_NOT_IPOR_PROTOCOL_ROUTER = \"IPOR_008\";\r\n\r\n    /// @notice Chunk size is equal to zero\r\n    string public constant CHUNK_SIZE_EQUAL_ZERO = \"IPOR_009\";\r\n\r\n    /// @notice Chunk size is too big\r\n    string public constant CHUNK_SIZE_TOO_BIG = \"IPOR_010\";\r\n\r\n    /// @notice Caller is not a  guardian\r\n    string public constant CALLER_NOT_GUARDIAN = \"IPOR_011\";\r\n\r\n    /// @notice Request contains invalid method signature, which is not supported by the Ipor Protocol Router\r\n    string public constant ROUTER_INVALID_SIGNATURE = \"IPOR_012\";\r\n\r\n    /// @notice Only AMM Treasury can have access to function\r\n    string public constant CALLER_NOT_AMM_TREASURY = \"IPOR_013\";\r\n\r\n    /// @notice Caller is not an owner\r\n    string public constant CALLER_NOT_OWNER = \"IPOR_014\";\r\n\r\n    /// @notice Method is paused\r\n    string public constant METHOD_PAUSED = \"IPOR_015\";\r\n\r\n    /// @notice Reentrancy appears\r\n    string public constant REENTRANCY = \"IPOR_016\";\r\n\r\n    /// @notice Asset is not supported\r\n    string public constant ASSET_NOT_SUPPORTED = \"IPOR_017\";\r\n\r\n    /// @notice Return back ETH failed in Ipor Protocol Router\r\n    string public constant ROUTER_RETURN_BACK_ETH_FAILED = \"IPOR_018\";\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/security/OwnerManager.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n\r\n/// @title Ipor Protocol Router Owner Manager library\r\nlibrary OwnerManager {\r\n    /// @notice Emitted when account is appointed to transfer ownership\r\n    /// @param appointedOwner Address of appointed owner\r\n    event AppointedToTransferOwnership(address indexed appointedOwner);\r\n\r\n    /// @notice Emitted when ownership is transferred\r\n    /// @param previousOwner Address of previous owner\r\n    /// @param newOwner Address of new owner\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Gets the current owner of Ipor Protocol Router\r\n    function getOwner() internal view returns (address) {\r\n        return StorageLib.getOwner().owner;\r\n    }\r\n\r\n    /// @notice Oppoint account to transfer ownership\r\n    /// @param newAppointedOwner Address of appointed owner\r\n    function appointToOwnership(address newAppointedOwner) internal {\r\n        require(newAppointedOwner != address(0), IporErrors.WRONG_ADDRESS);\r\n        StorageLib.AppointedOwnerStorage storage appointedOwnerStorage = StorageLib.getAppointedOwner();\r\n        appointedOwnerStorage.appointedOwner = newAppointedOwner;\r\n        emit AppointedToTransferOwnership(newAppointedOwner);\r\n    }\r\n\r\n    /// @notice Confirm appointment to ownership\r\n    /// @dev This is real transfer ownership in second step by appointed account\r\n    function confirmAppointmentToOwnership() internal {\r\n        StorageLib.AppointedOwnerStorage storage appointedOwnerStorage = StorageLib.getAppointedOwner();\r\n        appointedOwnerStorage.appointedOwner = address(0);\r\n        transferOwnership(msg.sender);\r\n    }\r\n\r\n    /// @notice Renounce ownership\r\n    function renounceOwnership() internal {\r\n        transferOwnership(address(0));\r\n        StorageLib.AppointedOwnerStorage storage appointedOwnerStorage = StorageLib.getAppointedOwner();\r\n        appointedOwnerStorage.appointedOwner = address(0);\r\n    }\r\n\r\n    /// @notice Immediately transfers ownership\r\n    function transferOwnership(address newOwner) internal {\r\n        StorageLib.OwnerStorage storage ownerStorage = StorageLib.getOwner();\r\n        address oldOwner = ownerStorage.owner;\r\n        ownerStorage.owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/router/AccessControl.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Smart contract reponsible for managing access to administative functions in IporProtocolRouter\r\ncontract AccessControl {\r\n    /// @dev Reentrancy - flag when thread is left method\r\n    uint256 internal constant _NOT_ENTERED = 1;\r\n    /// @dev Reentrancy - flag when thread is entered to method\r\n    uint256 internal constant _ENTERED = 2;\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n\r\n    /// @notice Checks if sender is owner\r\n    modifier onlyOwner() {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    /// @notice Checks if sender is appointed owner\r\n    modifier onlyAppointedOwner() {\r\n        require(StorageLib.getAppointedOwner().appointedOwner == msg.sender, IporErrors.SENDER_NOT_APPOINTED_OWNER);\r\n        _;\r\n    }\r\n\r\n    /// @notice Checks if sender is pause guardian\r\n    modifier onlyPauseGuardian() {\r\n        require(PauseManager.isPauseGuardian(msg.sender), IporErrors.CALLER_NOT_GUARDIAN);\r\n        _;\r\n    }\r\n\r\n    /// @notice Steps before and after method execution to prevent reentrancy\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    /// @notice Gets IPOR Protocol Owner on Router\r\n    /// @return IPOR Protocol Owner address\r\n    function owner() external view returns (address) {\r\n        return OwnerManager.getOwner();\r\n    }\r\n\r\n    /// @notice Appoint new account to ownership\r\n    /// @param appointedOwner New appointed owner address\r\n    function appointToOwnership(address appointedOwner) public onlyOwner {\r\n        OwnerManager.appointToOwnership(appointedOwner);\r\n    }\r\n\r\n    /// @notice Confirm appointed ownership\r\n    function confirmAppointmentToOwnership() public onlyAppointedOwner {\r\n        OwnerManager.confirmAppointmentToOwnership();\r\n    }\r\n\r\n    /// @notice Renounce ownership\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        OwnerManager.renounceOwnership();\r\n    }\r\n\r\n    /// @notice Checks if function is paused\r\n    /// @param functionSig Function signature\r\n    /// @return 1 if function is paused, 0 otherwise\r\n    function paused(bytes4 functionSig) external view returns (uint256) {\r\n        return StorageLib.getRouterFunctionPaused().value[functionSig];\r\n    }\r\n\r\n    /// @notice Pauses list of functions in IporProtocolRouter\r\n    /// @dev Can be called only by pause guardian\r\n    function pause(bytes4[] calldata functionSigs) external onlyPauseGuardian {\r\n        uint256 len = functionSigs.length;\r\n        for (uint256 i; i < len; ) {\r\n            StorageLib.getRouterFunctionPaused().value[functionSigs[i]] = 1;\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Unpauses list of functions in IporProtocolRouter\r\n    /// @dev Can be called only by Owner of Ipor Protocol Router\r\n    function unpause(bytes4[] calldata functionSigs) external onlyOwner {\r\n        uint256 len = functionSigs.length;\r\n        for (uint256 i; i < len; ) {\r\n            StorageLib.getRouterFunctionPaused().value[functionSigs[i]] = 0;\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Checks if address is pause guardian\r\n    /// @param account Pause guardian address\r\n    /// @return true if address is pause guardian, false otherwise\r\n    function isPauseGuardian(address account) external view returns (bool) {\r\n        return PauseManager.isPauseGuardian(account);\r\n    }\r\n\r\n    /// @notice Adds new pause guardians\r\n    /// @param guardians List of new pause guardians addresses\r\n    function addPauseGuardians(address[] calldata guardians) external onlyOwner {\r\n        PauseManager.addPauseGuardians(guardians);\r\n    }\r\n\r\n    /// @notice Removes pause guardian\r\n    /// @param guardians List of pause guardians addresses\r\n    function removePauseGuardians(address[] calldata guardians) external onlyOwner {\r\n        PauseManager.removePauseGuardians(guardians);\r\n    }\r\n\r\n    function _checkFunctionSigAndIsNotPause(bytes4 functionSig, bytes4 expectedSig) internal view returns (bool) {\r\n        if (functionSig == expectedSig) {\r\n            require(StorageLib.getRouterFunctionPaused().value[functionSig] == 0, IporErrors.METHOD_PAUSED);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _onlyOwner() internal view {\r\n        require(StorageLib.getOwner().owner == msg.sender, IporErrors.CALLER_NOT_OWNER);\r\n    }\r\n\r\n    function _nonReentrantBefore() internal {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(StorageLib.getReentrancyStatus().value != _ENTERED, IporErrors.REENTRANCY);\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        StorageLib.getReentrancyStatus().value = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() internal {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        if (StorageLib.getReentrancyStatus().value == _ENTERED) {\r\n            StorageLib.getReentrancyStatus().value = _NOT_ENTERED;\r\n        }\r\n    }\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/libraries/IporContractValidator.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\nlibrary IporContractValidator {\r\n    function checkAddress(address addr) internal pure returns (address) {\r\n        require(addr != address(0), IporErrors.WRONG_ADDRESS);\r\n        return addr;\r\n    }\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/amm-eth/interfaces/IAmmPoolsLensEth.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface of the AmmPoolsLensEth contract.\r\ninterface IAmmPoolsLensEth {\r\n    /// @notice Retrieves the exchange rate between stEth and ipstEth using the AmmLibEth library.\r\n    /// @return The exchange rate calculated based on the balance of stEth in the AMM Treasury and the total supply of ipstEth.\r\n    /// @dev This function acts as a wrapper around the `getExchangeRate` function in the AmmLibEth library.\r\n    function getIpstEthExchangeRate() external view returns (uint256);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/amm-eth/interfaces/IAmmPoolsServiceEth.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface of the AmmPoolsServiceEth contract.\r\ninterface IAmmPoolsServiceEth {\r\n    /// @notice Allows the router to provide liquidity in the form of stEth to the AMM pool.\r\n    /// @param beneficiary Address that will receive the minted ipstEth tokens in exchange for the provided stEth.\r\n    /// @param stEthAmount Amount of stEth tokens to be provided as liquidity.\r\n    /// @dev This function can only be called by the router. It calculates the new pool balance, checks if it's within the allowed limit,\r\n    /// calculates the exchange rate, transfers the stEth from the sender to the AmmTreasury contract, and mints ipstEth tokens to the beneficiary.\r\n    /// An event IAmmPoolsServiceEth.ProvideLiquidityStEth is emitted after the liquidity is provided.\r\n    /// require the new pool balance after adding the provided stEth should not exceed the maximum allowed pool balance.\r\n    function provideLiquidityStEth(address beneficiary, uint256 stEthAmount) external payable;\r\n\r\n    /// @notice Allows the router to provide liquidity in the form of wEth to the AMM pool.\r\n    /// @param beneficiary Address that will benefit from the provided liquidity.\r\n    /// @param assetAmount Amount of wEth tokens to be provided as liquidity.\r\n    /// @dev This function can only be called by the router. It checks the validity of the provided wEth amount and beneficiary address,\r\n    /// calculates the new pool balance, checks if it's within the allowed limit.\r\n    /// @dev Flow is following: Transfers the wEth from the sender to Router contract, Router withdraws the wEth to convert it to Ether,\r\n    /// Router submit  the Ether to stETH contract and transfer stETH to AmmTreasury contract, mints ipstETH to the beneficiary.\r\n    /// An event IAmmPoolsServiceEth.ProvideLiquidityEth is emitted after the liquidity is provided.\r\n    /// require The provided wEth amount should be greater than zero.\r\n    /// require The beneficiary address should not be the zero address.\r\n    /// require The new pool balance after adding the provided wEth should not exceed the maximum allowed pool balance.\r\n    function provideLiquidityWEth(address beneficiary, uint256 assetAmount) external payable;\r\n\r\n    /// @notice Allows the router to provide liquidity in the form of Ether to the AMM pool.\r\n    /// @param beneficiary Address that will benefit from the provided liquidity.\r\n    /// @param assetAmount Amount of Ether to be provided as liquidity.\r\n    /// @dev This function can only be called by the router. It checks the validity of the provided Ether amount, the sent Ether value,\r\n    /// and the beneficiary address, calculates the new pool balance, and checks if it's within the allowed limit.\r\n    /// @dev Flow is following: User transfer to Router ETH, Router submit ETH to stETH contract and transfer stETH to AmmTreasury contract,\r\n    /// Router mints ipstETH to the beneficiary.\r\n    /// An event IAmmPoolsServiceEth.ProvideLiquidityEth is emitted after the liquidity is provided.\r\n    /// require The provided Ether amount should be greater than zero.\r\n    /// require The sent Ether value with the transaction should be greater than zero.\r\n    /// require The beneficiary address should not be the zero address.\r\n    /// require The new pool balance after adding the provided Ether should not exceed the maximum allowed pool balance.\r\n    function provideLiquidityEth(address beneficiary, uint256 assetAmount) external payable;\r\n\r\n    /// @notice Allows the router to redeem stEth from the AMM pool in exchange for ipstEth tokens.\r\n    /// @param beneficiary Address that will receive the redeemed stEth.\r\n    /// @param ipTokenAmount Amount of ipstEth tokens to be redeemed.\r\n    /// @dev This function can only be called by the router. It checks the validity of the provided ipstEth amount and beneficiary address,\r\n    /// calculates the exchange rate, determines the amount of stEth equivalent to the provided ipstEth, and transfers the stEth to the beneficiary.\r\n    /// The function also accounts for a redemption fee. An event is emitted after the redemption.\r\n    /// require The provided ipstEth amount should be greater than zero and less than or equal to the sender's balance.\r\n    /// require The beneficiary address should not be the zero address.\r\n    /// require The calculated stEth amount to redeem after accounting for the fee should be greater than zero.\r\n    function redeemFromAmmPoolStEth(address beneficiary, uint256 ipTokenAmount) external;\r\n\r\n    /// @notice Error appeared when submitted ETH amount to in stETH contract is too high.\r\n    /// @param amount Amount of ETH which was submitted to stETH contract.\r\n    /// @param errorCode IPOR Protocol error code.\r\n    error StEthSubmitFailed(uint256 amount, string errorCode);\r\n\r\n    /// @notice Event emitted when liquidity is provided in the form of stEth.\r\n    /// @param from Address of the sender.\r\n    /// @param beneficiary Address that will receive the minted ipstEth tokens in exchange for the provided stEth.\r\n    /// @param to Address of the AMM treasury.\r\n    /// @param exchangeRate Exchange rate between stEth and ipstEth.\r\n    /// @param assetAmount Amount of stEth tokens provided as liquidity.\r\n    /// @param ipTokenAmount Amount of ipstEth tokens minted in exchange for the provided stEth.\r\n    event ProvideLiquidityStEth(\r\n        address indexed from,\r\n        address indexed beneficiary,\r\n        address indexed to,\r\n        uint256 exchangeRate,\r\n        uint256 assetAmount,\r\n        uint256 ipTokenAmount\r\n    );\r\n\r\n    /// @notice Event emitted when liquidity is provided in the form of wEth.\r\n    /// @param from Address of the sender.\r\n    /// @param beneficiary Address that will benefit from the provided liquidity.\r\n    /// @param to Address of the AMM treasury.\r\n    /// @param exchangeRate Exchange rate between wEth and ipstEth.\r\n    /// @param amountEth Amount of ETH provided as liquidity.\r\n    /// @param amountStEth Amount of stEth tokens submitted to StETH contract based on amountEth\r\n    /// @param ipTokenAmount Amount of ipstEth tokens minted in exchange for the provided stEth.\r\n    event ProvideLiquidityEth(\r\n        address indexed from,\r\n        address indexed beneficiary,\r\n        address indexed to,\r\n        uint256 exchangeRate,\r\n        uint256 amountEth,\r\n        uint256 amountStEth,\r\n        uint256 ipTokenAmount\r\n    );\r\n\r\n    /// @notice Event emitted when liquidity is redeemed from the AMM pool in exchange for stEth.\r\n    /// @param ammTreasuryEth Address of the AMM Treasury contract.\r\n    /// @param from Address of the sender. From who ipstEth tokens were burned.\r\n    /// @param beneficiary Address that will receive the redeemed stEth tokens.\r\n    /// @param exchangeRate Exchange rate between stEth and ipstEth.\r\n    /// @param amountStEth Amount of stEth tokens redeemed.\r\n    /// @param redeemedAmountStEth Amount of stEth tokens redeemed after accounting for the fee.\r\n    /// @param ipTokenAmount Amount of ipstEth tokens redeemed.\r\n    event RedeemStEth(\r\n        address indexed ammTreasuryEth,\r\n        address indexed from,\r\n        address indexed beneficiary,\r\n        uint256 exchangeRate,\r\n        uint256 amountStEth,\r\n        uint256 redeemedAmountStEth,\r\n        uint256 ipTokenAmount\r\n    );\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IProxyImplementation.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Technical interface for reading data related to the UUPS proxy pattern in Ipor Protocol.\r\ninterface IProxyImplementation {\r\n    /// @notice Retrieves the address of the implementation contract for UUPS proxy.\r\n    /// @return The address of the implementation contract.\r\n    /// @dev The function returns the value stored in the implementation storage slot.\r\n    function getImplementation() external view returns (address);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IPowerTokenStakeService.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface for interaction with PowerToken and LiquidityMining contracts.\r\ninterface IPowerTokenStakeService {\r\n    /// @notice Stakes the specified amounts of LP tokens into the LiquidityMining contract.\r\n    /// @dev This function allows the caller to stake their LP tokens on behalf of another address (`beneficiary`).\r\n    /// @param beneficiary The address on behalf of which the LP tokens are being staked.\r\n    /// @param lpTokens An array of LP token addresses to be staked.\r\n    /// @param lpTokenAmounts An array of corresponding LP token amounts to be staked, represented with 18 decimals.\r\n    /// @dev Both `lpTokens` and `lpTokenAmounts` arrays must have the same length.\r\n    /// @dev The `beneficiary` address must not be the zero address.\r\n    /// @dev The function ensures that the provided LP token addresses are valid and the amounts to be staked are greater than zero.\r\n    /// @dev The function transfers the LP tokens from the caller's address to the LiquidityMining contract.\r\n    /// @dev Finally, the function calls the `addLpTokens` function of the LiquidityMining contract to update the staked LP tokens.\r\n    /// @dev Reverts if any of the requirements is not met or if the transfer of LP tokens fails.\r\n    function stakeLpTokensToLiquidityMining(\r\n        address beneficiary,\r\n        address[] calldata lpTokens,\r\n        uint256[] calldata lpTokenAmounts\r\n    ) external;\r\n\r\n    /// @notice Unstakes the specified amounts of LP tokens from the LiquidityMining contract and transfers them to the specified address.\r\n    /// @param transferTo The address to which the unstaked LP tokens will be transferred.\r\n    /// @param lpTokens An array of LP token addresses to be unstaked.\r\n    /// @param lpTokenAmounts An array of corresponding LP token amounts to be unstaked, represented with 18 decimals.\r\n    /// @dev Both `lpTokens` and `lpTokenAmounts` arrays must have the same length.\r\n    /// @dev The function ensures that the provided LP token addresses are valid and the amounts to be unstaked are greater than zero.\r\n    /// @dev The function calls the `removeLpTokens` function of the LiquidityMining contract to update the unstaked LP tokens.\r\n    /// @dev Finally, the function transfers the unstaked LP tokens from the LiquidityMining contract to the specified address.\r\n    /// @dev Reverts if any of the requirements is not met or if the transfer of LP tokens fails.\r\n    function unstakeLpTokensFromLiquidityMining(\r\n        address transferTo,\r\n        address[] calldata lpTokens,\r\n        uint256[] calldata lpTokenAmounts\r\n    ) external;\r\n\r\n    /// @notice Stakes the specified amount of IPOR tokens on behalf of the specified address.\r\n    /// @param beneficiary The address on whose behalf the IPOR tokens will be staked.\r\n    /// @param iporTokenAmount The amount of IPOR tokens to be staked, represented with 18 decimals.\r\n    /// @dev The function ensures that the provided `beneficiary` address is valid and the `iporTokenAmount` is greater than zero.\r\n    /// @dev The function calls the `addStakedToken` function of the PowerToken contract to update the staked IPOR tokens.\r\n    /// @dev Finally, the function transfers the IPOR tokens from the sender to the PowerToken contract for staking.\r\n    /// @dev Reverts if any of the requirements is not met or if the transfer of IPOR tokens fails.\r\n    function stakeGovernanceTokenToPowerToken(address beneficiary, uint256 iporTokenAmount) external;\r\n\r\n    /// @notice Stakes a specified amount of governance tokens and delegates power tokens to a specific beneficiary.\r\n    /// @param beneficiary The address on whose behalf the governance tokens will be staked and power tokens will be delegated.\r\n    /// @param governanceTokenAmount The amount of governance tokens to be staked, represented with 18 decimals.\r\n    /// @param lpTokens An array of addresses representing the liquidity pool tokens.\r\n    /// @param pwTokenAmounts An array of amounts of power tokens to be delegated corresponding to each liquidity pool token.\r\n    /// @dev The function ensures that the `beneficiary` address is valid and the `governanceTokenAmount` is greater than zero.\r\n    /// @dev The function also requires that the length of the `lpTokens` array is equal to the length of the `pwTokenAmounts` array.\r\n    /// @dev For each liquidity pool token in `lpTokens`, the function creates an `UpdatePwToken` structure to be used for updating the power tokens in the Liquidity Mining contract.\r\n    /// @dev The function checks if the total amount of power tokens to be delegated is less or equal to the amount of staked governance tokens.\r\n    /// @dev The function calls the `addGovernanceTokenInternal` function of the PowerToken contract to update the staked governance tokens for the `beneficiary`.\r\n    /// @dev The function transfers the governance tokens from the sender to the PowerToken contract for staking.\r\n    /// @dev The function calls the `delegateInternal` function of the PowerToken contract to delegate power tokens to the `beneficiary`.\r\n    /// @dev Finally, the function calls the `addPwTokensInternal` function of the Liquidity Mining contract to update the staked power tokens.\r\n    /// @dev Reverts if any of the requirements is not met or if the transfer of governance tokens fails.\r\n    function stakeGovernanceTokenToPowerTokenAndDelegate(\r\n        address beneficiary,\r\n        uint256 governanceTokenAmount,\r\n        address[] calldata lpTokens,\r\n        uint256[] calldata pwTokenAmounts\r\n    ) external;\r\n\r\n    /// @notice Unstakes the specified amount of IPOR tokens and transfers them to the specified address.\r\n    /// @param transferTo The address to which the unstaked IPOR tokens will be transferred.\r\n    /// @param iporTokenAmount The amount of IPOR tokens to be unstaked, represented with 18 decimals.\r\n    /// @dev The function ensures that the `iporTokenAmount` is greater than zero.\r\n    /// @dev The function calls the `removeStakedTokenWithFee` function of the PowerToken contract to remove the staked IPOR tokens.\r\n    /// @dev Finally, the function transfers the corresponding staked token amount to the `transferTo` address.\r\n    /// @dev Reverts if the `iporTokenAmount` is not greater than zero, or if the transfer of staked tokens fails.\r\n    function unstakeGovernanceTokenFromPowerToken(address transferTo, uint256 iporTokenAmount) external;\r\n\r\n    /// @notice Initiates a cooldown period for the specified amount of Power Tokens.\r\n    /// @param pwTokenAmount The amount of Power Tokens to be put into cooldown, represented with 18 decimals.\r\n    /// @dev The function ensures that the `pwTokenAmount` is greater than zero.\r\n    /// @dev The function calls the `cooldown` function of the PowerToken contract to initiate the cooldown.\r\n    /// @dev Reverts if the `pwTokenAmount` is not greater than zero.\r\n    function pwTokenCooldown(uint256 pwTokenAmount) external;\r\n\r\n    /// @notice Cancels the active cooldown for the sender.\r\n    /// @dev The function calls the `cancelCooldown` function of the PowerToken contract to cancel the cooldown.\r\n    function pwTokenCancelCooldown() external;\r\n\r\n    /// @notice Redeems Power Tokens and transfers the corresponding Staked Tokens to the specified address.\r\n    /// @dev The function calls the `redeem` function of the PowerToken contract to redeem Power Tokens.\r\n    /// @param transferTo The address to which the Staked Tokens will be transferred.\r\n    function redeemPwToken(address transferTo) external;\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IPowerTokenFlowsService.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface for interaction with PowerToken and LiquidityMining contracts.\r\ninterface IPowerTokenFlowsService {\r\n    /// @notice Claims rewards for the caller by transferring them from the LiquidityMining contract to the PowerToken contract.\r\n    /// @param lpTokens An array of LP tokens for which the rewards are to be claimed.\r\n    /// @dev This function calls the `claim` function of the `ILiquidityMiningV2` contract to retrieve the rewards amount to transfer.\r\n    /// It then adds the staked tokens to the `powerToken` contract and transfers the rewards from the `liquidityMining` contract to the `powerToken` contract.\r\n    /// @dev Reverts if the `lpTokens` array is empty.\r\n    /// @dev Reverts if there are no rewards to claim.\r\n    function claimRewardsFromLiquidityMining(address[] calldata lpTokens) external;\r\n\r\n    /// @notice Updates the indicators for a given account and LP tokens.\r\n    /// @param account The account address for which the indicators are to be updated.\r\n    /// @param lpTokens An array of LP tokens for which the indicators are to be updated.\r\n    /// @dev This function calls the `updateIndicators` function of the `ILiquidityMiningV2` contract to update the indicators.\r\n    /// @dev Reverts if the `lpTokens` array is empty.\r\n    function updateIndicatorsInLiquidityMining(address account, address[] calldata lpTokens) external;\r\n\r\n    /// @notice Delegates staked tokens by providing LP tokens and corresponding amounts.\r\n    /// @param lpTokens An array of LP tokens to delegate.\r\n    /// @param lpTokenAmounts An array of corresponding amounts of LP tokens to delegate.\r\n    /// @dev This function allows the caller to delegate their staked tokens by providing the LP tokens and their corresponding amounts.\r\n    /// @dev It requires that the length of `lpTokens` is equal to the length of `lpTokenAmounts`.\r\n    /// @dev It reverts if either `lpTokens` or `lpTokenAmounts` arrays are empty.\r\n    function delegatePwTokensToLiquidityMining(address[] calldata lpTokens, uint256[] calldata lpTokenAmounts) external;\r\n\r\n    /// @notice Undelegates staked tokens by providing LP tokens and corresponding amounts.\r\n    /// @param lpTokens An array of LP tokens to undelegate.\r\n    /// @param lpTokenAmounts An array of corresponding amounts of LP tokens to undelegate.\r\n    /// @dev This function allows the caller to undelegate their staked tokens by providing the LP tokens and their corresponding amounts.\r\n    /// @dev It requires that the length of `lpTokens` is equal to the length of `lpTokenAmounts`.\r\n    /// @dev It reverts if either `lpTokens` or `lpTokenAmounts` arrays are empty.\r\n    /// @dev It reverts if the total staked token amount to undelegate is not greater than zero.\r\n    function undelegatePwTokensFromLiquidityMining(\r\n        address[] calldata lpTokens,\r\n        uint256[] calldata lpTokenAmounts\r\n    ) external;\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IAmmPoolsService.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface responsible for managing liquidity in the AMM Pools.\r\ninterface IAmmPoolsService {\r\n    /// @notice A struct to represent a pool configuration in AmmPoolsService.\r\n    struct AmmPoolsServicePoolConfiguration {\r\n        /// @notice The address of the asset.\r\n        address asset;\r\n        /// @notice The number of decimals the asset uses.\r\n        uint256 decimals;\r\n        /// @notice The address of the ipToken associated with the asset.\r\n        address ipToken;\r\n        /// @notice The address of the AMM's storage contract.\r\n        address ammStorage;\r\n        /// @notice The address of the AMM's treasury contract.\r\n        address ammTreasury;\r\n        /// @notice The address of the asset management contract.\r\n        address assetManagement;\r\n        /// @notice Redeem fee rate, value represented in 18 decimals. 1e18 = 100%\r\n        /// @dev Percentage of redeemed amount which stay in liquidity pool balance.\r\n        uint256 redeemFeeRate;\r\n        /// @notice Redeem liquidity pool max collateral ratio. Value describes what is maximal allowed collateral ratio for liquidity pool.\r\n        /// @dev Collateral ratio is a proportion between liquidity pool balance and sum of all active swap collateral. Value represented in 18 decimals. 1e18 = 100%\r\n        uint256 redeemLpMaxCollateralRatio;\r\n    }\r\n\r\n    /// @notice Emitted when `from` account provides liquidity (ERC20 token supported by IPOR Protocol) to AmmTreasury Liquidity Pool\r\n    event ProvideLiquidity(\r\n        /// @notice address that provides liquidity\r\n        address indexed from,\r\n        /// @notice Address that will receive ipTokens representing the provided liquidity.\r\n        address indexed beneficiary,\r\n        /// @notice AmmTreasury's address where liquidity is received\r\n        address indexed to,\r\n        /// @notice current ipToken exchange rate\r\n        /// @dev value represented in 18 decimals\r\n        uint256 exchangeRate,\r\n        /// @notice amount of asset provided by user to AmmTreasury's liquidity pool\r\n        /// @dev value represented in 18 decimals\r\n        uint256 assetAmount,\r\n        /// @notice amount of ipToken issued to represent user's share in the liquidity pool.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 ipTokenAmount\r\n    );\r\n\r\n    /// @notice Emitted when `to` account executes redeem ipTokens\r\n    event Redeem(\r\n        /// @notice Address of the AMM Treasury contract\r\n        address indexed ammTreasury,\r\n        /// @notice AmmTreasury's address from which underlying asset - ERC20 Tokens, are transferred to `to` account\r\n        address indexed from,\r\n        /// @notice account where underlying asset tokens are transferred after redeem\r\n        address indexed beneficiary,\r\n        /// @notice ipToken exchange rate used for calculating `assetAmount`\r\n        /// @dev value represented in 18 decimals\r\n        uint256 exchangeRate,\r\n        /// @notice underlying asset value calculated based on `exchangeRate` and `ipTokenAmount`\r\n        /// @dev value represented in 18 decimals\r\n        uint256 assetAmount,\r\n        /// @notice redeemed IP Token value\r\n        /// @dev value represented in 18 decimals\r\n        uint256 ipTokenAmount,\r\n        /// @notice underlying asset fee deducted when redeeming ipToken.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 redeemFee,\r\n        /// @notice net asset amount transferred from AmmTreasury to `to`/sender's account, reduced by the redeem fee\r\n        /// @dev value represented in 18 decimals\r\n        uint256 redeemAmount\r\n    );\r\n\r\n    /// @notice Gets the configuration of the pool for the given asset in AmmPoolsService.\r\n    /// @param asset The address of the asset.\r\n    /// @return The pool configuration.\r\n    function getAmmPoolServiceConfiguration(\r\n        address asset\r\n    ) external view returns (AmmPoolsServicePoolConfiguration memory);\r\n\r\n    /// @notice Providing USDT to the AMM Liquidity Pool by the sender on behalf of beneficiary.\r\n    /// @dev Emits {ProvideLiquidity} event and transfers ERC20 tokens from the sender to the AmmTreasury,\r\n    /// emits {Transfer} event from ERC20 asset, emits {Mint} event from ipToken.\r\n    /// Transfers minted ipTokens to the beneficiary. Amount of transferred ipTokens is based on current ipToken exchange rate\r\n    /// @param beneficiary Account receiving receive ipUSDT liquidity tokens.\r\n    /// @param assetAmount Amount of ERC20 tokens transferred from the sender to the AmmTreasury. Represented in decimals specific for asset. Value represented in 18 decimals.\r\n    function provideLiquidityUsdt(address beneficiary, uint256 assetAmount) external;\r\n\r\n    /// @notice Providing USDC to the AMM Liquidity Pool by the sender on behalf of beneficiary.\r\n    /// @dev Emits {ProvideLiquidity} event and transfers ERC20 tokens from the sender to the AmmTreasury,\r\n    /// emits {Transfer} event from ERC20 asset, emits {Mint} event from ipToken.\r\n    /// @param beneficiary Account receiving receive ipUSDT liquidity tokens.\r\n    /// @param assetAmount Amount of ERC20 tokens transferred from the sender to the AmmTreasury. Represented in decimals specific for asset. Value represented in 18 decimals.\r\n    function provideLiquidityUsdc(address beneficiary, uint256 assetAmount) external;\r\n\r\n    /// @notice Providing DAI to the AMM Liquidity Pool by the sender on behalf of beneficiary.\r\n    /// @dev Emits {ProvideLiquidity} event and transfers ERC20 tokens from the sender tothe AmmTreasury,\r\n    /// emits {Transfer} event from ERC20 asset, emits {Mint} event from ipToken.\r\n    /// @param beneficiary Account receiving receive ipUSDT liquidity tokens.\r\n    /// @param assetAmount Amount of ERC20 tokens transferred from the sender to the AmmTreasury. Represented in decimals specific for asset. Value represented in 18 decimals.\r\n    /// @dev Value represented in 18 decimals.\r\n    function provideLiquidityDai(address beneficiary, uint256 assetAmount) external;\r\n\r\n    /// @notice Redeems `ipTokenAmount` ipUSDT for underlying asset\r\n    /// @dev Emits {Redeem} event, emits {Transfer} event from ERC20 asset, emits {Burn} event from ipToken.\r\n    /// Transfers ERC20 tokens from the AmmTreasury to the beneficiary based on current exchange rate of ipUSDT.\r\n    /// @param beneficiary Account receiving underlying tokens.\r\n    /// @param ipTokenAmount redeem amount of ipUSDT tokens, represented in 18 decimals.\r\n    /// @dev sender's ipUSDT tokens are burned, asset: USDT tokens are transferred to the beneficiary.\r\n    function redeemFromAmmPoolUsdt(address beneficiary, uint256 ipTokenAmount) external;\r\n\r\n    /// @notice Redeems `ipTokenAmount` ipUSDC for underlying asset\r\n    /// @dev Emits {Redeem} event, emits {Transfer} event from ERC20 asset, emits {Burn} event from ipToken.\r\n    /// Transfers ERC20 tokens from the AmmTreasury to the beneficiary based on current exchange rate of ipUSDC.\r\n    /// @param beneficiary Account receiving underlying tokens.\r\n    /// @param ipTokenAmount redeem amount of ipUSDC tokens, represented in 18 decimals.\r\n    /// @dev sender's ipUSDC tokens are burned, asset: USDC tokens are transferred to the beneficiary.\r\n    function redeemFromAmmPoolUsdc(address beneficiary, uint256 ipTokenAmount) external;\r\n\r\n    /// @notice Redeems `ipTokenAmount` ipDAI for underlying asset\r\n    /// @dev Emits {Redeem} event, emits {Transfer} event from ERC20 asset, emits {Burn} event from ipToken.\r\n    /// Transfers ERC20 tokens from the AmmTreasury to the beneficiary based on current exchange rate of ipDAI.\r\n    /// @param beneficiary Account receiving underlying tokens.\r\n    /// @param ipTokenAmount redeem amount of ipDAI tokens, represented in 18 decimals.\r\n    /// @dev sender's ipDAI tokens are burned, asset: DAI tokens are transferred to the beneficiary.\r\n    function redeemFromAmmPoolDai(address beneficiary, uint256 ipTokenAmount) external;\r\n\r\n    /// @notice Rebalances given assets between the AmmTreasury and the AssetManagement, based on configuration stored\r\n    /// in the `AmmPoolsParamsValue.ammTreasuryAndAssetManagementRatio` field .\r\n    /// @dev Emits {Deposit} or {Withdraw} event from AssetManagement depends on current asset balance on AmmTreasury and AssetManagement.\r\n    /// @dev Emits {Transfer} from ERC20 asset.\r\n    /// @param asset Address of the asset.\r\n    function rebalanceBetweenAmmTreasuryAndAssetManagement(address asset) external;\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IAmmOpenSwapLens.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface of the service allowing to open new swaps.\r\ninterface IAmmOpenSwapLens {\r\n    /// @notice Structure representing configuration of the AmmOpenSwapServicePool for specific asset (pool).\r\n    struct AmmOpenSwapServicePoolConfiguration {\r\n        /// @notice address of the asset\r\n        address asset;\r\n        /// @notice asset decimals\r\n        uint256 decimals;\r\n        /// @notice address of the AMM Storage\r\n        address ammStorage;\r\n        /// @notice address of the AMM Treasury\r\n        address ammTreasury;\r\n        /// @notice ipor publication fee, fee used when opening swap, represented in 18 decimals.\r\n        uint256 iporPublicationFee;\r\n        /// @notice maximum swap collateral amount, represented in 18 decimals.\r\n        uint256 maxSwapCollateralAmount;\r\n        /// @notice liquidation deposit amount, represented WITHOUT 18 decimals. Example 25 = 25 USDT.\r\n        uint256 liquidationDepositAmount;\r\n        /// @notice minimum leverage, represented in 18 decimals.\r\n        uint256 minLeverage;\r\n        /// @notice swap's opening fee rate, represented in 18 decimals. 1e18 = 100%\r\n        uint256 openingFeeRate;\r\n        /// @notice swap's opening fee rate, portion of the rate which is allocated to \"treasury\" balance\r\n        /// @dev Value describes what percentage of opening fee amount is allocated to \"treasury\" balance. Value represented in 18 decimals. 1e18 = 100%\r\n        uint256 openingFeeTreasuryPortionRate;\r\n    }\r\n\r\n    /// @notice Returns configuration of the AmmOpenSwapServicePool for specific asset (pool).\r\n    /// @param asset address of the asset\r\n    /// @return AmmOpenSwapServicePoolConfiguration structure representing configuration of the AmmOpenSwapServicePool for specific asset (pool).\r\n    function getAmmOpenSwapServicePoolConfiguration(\r\n        address asset\r\n    ) external view returns (AmmOpenSwapServicePoolConfiguration memory);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IAmmGovernanceLens.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface for interacting with AmmGovernanceLens. Interface responsible for reading data from AMM Governance.\r\ninterface IAmmGovernanceLens {\r\n    /// @notice Structure of common params described AMM Pool configuration\r\n    struct AmmGovernancePoolConfiguration {\r\n        /// @notice address of asset which represents specific pool\r\n        address asset;\r\n        /// @notice asset decimals\r\n        uint256 decimals;\r\n        /// @notice address of AMM Storage\r\n        address ammStorage;\r\n        /// @notice address of AMM Treasury\r\n        address ammTreasury;\r\n        /// @notice address of AMM Pools Treasury Wallet\r\n        address ammPoolsTreasury;\r\n        /// @notice address of user which is allowed to manage AMM Pools Treasury Wallet\r\n        address ammPoolsTreasuryManager;\r\n        /// @notice address of AMM Charlie Treasury Wallet\r\n        address ammCharlieTreasury;\r\n        /// @notice address of user which is allowed to manage AMM Charlie Treasury Wallet\r\n        address ammCharlieTreasuryManager;\r\n    }\r\n\r\n    /// @dev A struct to represent a pool's parameters configuration.\r\n    struct AmmPoolsParamsConfiguration {\r\n        /// @dev max liquidity pool balance in the asset pool, represented in 18 decimals\r\n        uint256 maxLiquidityPoolBalance;\r\n        /// @dev The threshold for auto-rebalancing the pool. Value represented without 18 decimals.\r\n        /// Value represents multiplication of 1000.\r\n        uint256 autoRebalanceThresholdInThousands;\r\n        /// @dev asset management ratio, represented without 18 decimals, value represents percentage with 2 decimals\r\n        /// 65% = 6500, 99,99% = 9999, this is a percentage which stay in Amm Treasury in opposite to Asset Management\r\n        /// based on AMM Treasury balance (100%).\r\n        uint256 ammTreasuryAndAssetManagementRatio;\r\n    }\r\n\r\n    /// @notice Gets the structure or common params described AMM Pool configuration\r\n    /// @param asset Address of asset which represents specific pool\r\n    /// @return poolConfiguration Structure of common params described AMM Pool configuration\r\n    function getAmmGovernancePoolConfiguration(\r\n        address asset\r\n    ) external view returns (AmmGovernancePoolConfiguration memory);\r\n\r\n    /// @notice Flag which indicates if given account is an liquidator for given asset\r\n    /// @param asset Address of asset which represents specific pool\r\n    /// @param account Address of account which is checked if is an liquidator\r\n    /// @return isSwapLiquidator Flag which indicates if given account is an liquidator for given asset\r\n    function isSwapLiquidator(address asset, address account) external view returns (bool);\r\n\r\n    /// @notice Flag which indicates if given account is an appointed to rebalance in AMM for given asset\r\n    /// @param asset Address of asset which represents specific pool\r\n    /// @param account Address of account which is checked if is an appointed to rebalance in AMM\r\n    /// @return isAppointedToRebalanceInAmm Flag which indicates if given account is an appointed to rebalance in AMM for given asset\r\n    function isAppointedToRebalanceInAmm(address asset, address account) external view returns (bool);\r\n\r\n    /// @notice Gets the structure or common params described AMM Pool configuration\r\n    /// @param asset Address of asset which represents specific pool\r\n    /// @return ammPoolsParams Structure of common params described AMM Pool configuration\r\n    function getAmmPoolsParams(address asset) external view returns (AmmPoolsParamsConfiguration memory);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IAmmGovernanceService.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface for interacting with the AmmGovernanceService. Interface responsible for managing AMM Pools.\r\ninterface IAmmGovernanceService {\r\n    /// @notice Transfers the asset amount from the AmmTreasury to the AssetManagement. Action available only to the IPOR Protocol Owner.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param assetAmount Amount of asset to transfer\r\n    function depositToAssetManagement(address asset, uint256 assetAmount) external;\r\n\r\n    /// @notice Transfers the asset amount from the AssetManagement to the AmmTreasury. Action available only to the IPOR Protocol Owner.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param assetAmount Amount of asset to transfer\r\n    function withdrawFromAssetManagement(address asset, uint256 assetAmount) external;\r\n\r\n    /// @notice Transfers all of the asset from the AssetManagement to the AmmTreasury. Action available only to the IPOR Protocol Owner.\r\n    /// @param asset Address of the asset representing specific pool\r\n    function withdrawAllFromAssetManagement(address asset) external;\r\n\r\n    /// @notice Transfers the asset amount from the AmmTreasury to the Treasury Wallet. Action available only to the AMM Treasury Manager.\r\n    /// @dev The AMM collects a part of swap's opening fee adn accounts it towards the \"treasury\".\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param assetAmount Amount of asset to transfer\r\n    function transferToTreasury(address asset, uint256 assetAmount) external;\r\n\r\n    /// @notice Transfers the asset amount from the AmmTreasury to Oracle Treasury Wallet. Action available only to the  AMM Charlie Treasury Manager.\r\n    /// @dev A specific balance known as \"iporPublicationFee\" exists in AmmTreasury, which is used to collect IPOR publication fees from traders when they initiate swaps.\r\n    /// @dev Within the AmmTreasury, there exists a distinct balance known as \"iporPublicationFee,\" which is utilized by the AMM to accumulate IPOR publication fees from traders as they open swaps.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param assetAmount Amount of asset to transfer\r\n    function transferToCharlieTreasury(address asset, uint256 assetAmount) external;\r\n\r\n    /// @notice Adds an account to the list of swap liquidators for a given asset. Action available only to IPOR Protocol Owner.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param account Address of an account added to the list of swap liquidators\r\n    function addSwapLiquidator(address asset, address account) external;\r\n\r\n    /// @notice Removes an account from the list of swap liquidators for a given asset. Action available only to IPOR Protocol Owner.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param account Address of an account removed to the list of swap liquidators\r\n    function removeSwapLiquidator(address asset, address account) external;\r\n\r\n    /// @notice Add an account to the list of addresses appointed to rebalance AMM for given asset. Action available only to the IPOR Protocol Owner.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param account Address of an account added to the list of addresses appointed to rebalance in AMM\r\n    /// @dev Rebalancing the AMM is a process of moving liquidity between the AMM and the AssetManagement in the amount defined in param called \"ammTreasuryAndAssetManagementRatio\".\r\n    function addAppointedToRebalanceInAmm(address asset, address account) external;\r\n\r\n    /// @notice Remove account from the list of appointed to rebalance in AMM for given asset.\r\n    /// @param asset Address of asset which represents specific pool\r\n    /// @param account Address of account which is removed from the list of appointed to rebalance in AMM\r\n    /// @dev Rebalancing the AMM is a process of moving liquidity between the AMM and the AssetManagement in the amount defined in param called \"ammTreasuryAndAssetManagementRatio\".\r\n    function removeAppointedToRebalanceInAmm(address asset, address account) external;\r\n\r\n    /// @notice Sets AMM Pools params for a given asset (pool). Action available only to IPOR Protocol Owner.\r\n    /// @param asset Address of asset representing specific pool\r\n    /// @param newMaxLiquidityPoolBalance New max liquidity pool balance threshold. Value represented WITHOUT 18 decimals.\r\n    /// @param newAutoRebalanceThresholdInThousands New auto rebalance threshold in thousands. Value represented WITHOUT 18 decimals. Value represents multiplication of 1000.\r\n    /// @param newAmmTreasuryAndAssetManagementRatio New AMM Treasury and Asset Management ratio, represented WITHOUT 18 decimals, value represents percentage with 2 decimals. Example: 65% = 6500, 99,99% = 9999\r\n    function setAmmPoolsParams(\r\n        address asset,\r\n        uint32 newMaxLiquidityPoolBalance,\r\n        uint32 newAutoRebalanceThresholdInThousands,\r\n        uint16 newAmmTreasuryAndAssetManagementRatio\r\n    ) external;\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/ILiquidityMiningLens.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title LiquidityMiningLens interface responsible for reading data from LiquidityMining.\r\ninterface ILiquidityMiningLens {\r\n\r\n    /// @title Struct pair representing delegated pwToken balance\r\n    struct DelegatedPwTokenBalance {\r\n        /// @notice lpToken address\r\n        address lpToken;\r\n        /// @notice The amount of Power Token delegated to lpToken staking pool\r\n        /// @dev value represented in 18 decimals\r\n        uint256 pwTokenAmount;\r\n    }\r\n\r\n    /// @title Global indicators used in rewards calculation.\r\n    struct GlobalRewardsIndicators {\r\n        /// @notice powerUp indicator aggregated\r\n        /// @dev It can be changed many times during transaction, represented with 18 decimals\r\n        uint256 aggregatedPowerUp;\r\n        /// @notice composite multiplier in a block described in field blockNumber\r\n        /// @dev It can be changed many times during transaction, represented with 27 decimals\r\n        uint128 compositeMultiplierInTheBlock;\r\n        /// @notice Composite multiplier updated in block {blockNumber} but calculated for PREVIOUS (!) block.\r\n        /// @dev It can be changed once per block, represented with 27 decimals\r\n        uint128 compositeMultiplierCumulativePrevBlock;\r\n        /// @dev It can be changed once per block. Block number in which all other params of this structure are updated\r\n        uint32 blockNumber;\r\n        /// @notice value describing amount of rewards issued per block,\r\n        /// @dev It can be changed at most once per block, represented with 8 decimals\r\n        uint32 rewardsPerBlock;\r\n        /// @notice amount of accrued rewards since inception\r\n        /// @dev It can be changed at most once per block, represented with 18 decimals\r\n        uint88 accruedRewards;\r\n    }\r\n\r\n    /// @title Params recorded for a given account. These params are used by the algorithm responsible for rewards distribution.\r\n    /// @dev The structure in storage is updated when account interacts with the LiquidityMining smart contract (stake, unstake, delegate, undelegate, claim)\r\n    struct AccountRewardsIndicators {\r\n        /// @notice `composite multiplier cumulative` is calculated for previous block\r\n        /// @dev represented in 27 decimals\r\n        uint128 compositeMultiplierCumulativePrevBlock;\r\n        /// @notice lpToken account's balance\r\n        uint128 lpTokenBalance;\r\n        /// @notive PowerUp is a result of logarithmic equastion,\r\n        /// @dev  powerUp < 100 *10^18\r\n        uint72 powerUp;\r\n        /// @notice balance of Power Tokens delegated to LiquidityMining\r\n        /// @dev delegatedPwTokenBalance < 10^26 < 2^87\r\n        uint96 delegatedPwTokenBalance;\r\n    }\r\n\r\n    struct UpdateLpToken {\r\n        address beneficiary;\r\n        address lpToken;\r\n        uint256 lpTokenAmount;\r\n    }\r\n\r\n    struct UpdatePwToken {\r\n        address beneficiary;\r\n        address lpToken;\r\n        uint256 pwTokenAmount;\r\n    }\r\n\r\n    struct AccruedRewardsResult {\r\n        address lpToken;\r\n        uint256 rewardsAmount;\r\n    }\r\n\r\n    struct AccountRewardResult {\r\n        address lpToken;\r\n        uint256 rewardsAmount;\r\n        uint256 allocatedPwTokens;\r\n    }\r\n\r\n    struct AccountIndicatorsResult {\r\n        address lpToken;\r\n        AccountRewardsIndicators indicators;\r\n    }\r\n\r\n    struct GlobalIndicatorsResult {\r\n        address lpToken;\r\n        GlobalRewardsIndicators indicators;\r\n    }\r\n\r\n    /// @notice Returns the balance of LP tokens staked by the specified account in the Liquidity Mining contract.\r\n    /// @param account The address of the account for which the LP token balance is queried.\r\n    /// @param lpToken The address of the LP token for which the balance is queried.\r\n    /// @return The balance of LP tokens staked by the specified account.\r\n    function balanceOfLpTokensStakedInLiquidityMining(address account, address lpToken) external view returns (uint256);\r\n\r\n    /// @notice It returns the balance of delegated Power Tokens for a given `account` and the list of lpToken addresses.\r\n    /// @param account address for which to fetch the information about balance of delegated Power Tokens\r\n    /// @param lpTokens list of lpTokens addresses(lpTokens)\r\n    /// @return balances list of {LiquidityMiningTypes.DelegatedPwTokenBalance} structure, with information how much Power Token is delegated per lpToken address.\r\n    function balanceOfPowerTokensDelegatedToLiquidityMining(\r\n        address account,\r\n        address[] memory lpTokens\r\n    ) external view returns (DelegatedPwTokenBalance[] memory balances);\r\n\r\n    /// @notice Calculates the accrued rewards for the specified LP tokens in the Liquidity Mining contract.\r\n    /// @param lpTokens An array of LP tokens for which the accrued rewards are to be calculated.\r\n    /// @return result An array of `AccruedRewardsResult` structs containing the accrued rewards information for each LP token.\r\n    function getAccruedRewardsInLiquidityMining(\r\n        address[] calldata lpTokens\r\n    ) external view returns (AccruedRewardsResult[] memory result);\r\n\r\n    /// @notice Calculates the rewards for the specified account and LP tokens in the Liquidity Mining contract.\r\n    /// @param account The address of the account for which the rewards are to be calculated.\r\n    /// @param lpTokens An array of LP tokens for which the rewards are to be calculated.\r\n    /// @return An array of `AccountRewardResult` structs containing the rewards information for each LP token.\r\n    function getAccountRewardsInLiquidityMining(\r\n        address account,\r\n        address[] calldata lpTokens\r\n    ) external view returns (AccountRewardResult[] memory);\r\n\r\n    /// @notice Retrieves the global indicators for the specified LP tokens in the Liquidity Mining contract.\r\n    /// @param lpTokens An array of LP tokens for which the global indicators are to be retrieved.\r\n    /// @return An array of `GlobalIndicatorsResult` structs containing the global indicators information for each LP token.\r\n    function getGlobalIndicatorsFromLiquidityMining(\r\n        address[] memory lpTokens\r\n    ) external view returns (GlobalIndicatorsResult[] memory);\r\n\r\n    /// @notice Retrieves the account indicators for the specified account and LP tokens in the Liquidity Mining contract.\r\n    /// @param account The address of the account for which the account indicators are to be retrieved.\r\n    /// @param lpTokens An array of LP tokens for which the account indicators are to be retrieved.\r\n    /// @return An array of `AccountIndicatorsResult` structs containing the account indicators information for each LP token.\r\n    function getAccountIndicatorsFromLiquidityMining(\r\n        address account,\r\n        address[] memory lpTokens\r\n    ) external view returns (AccountIndicatorsResult[] memory);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IPowerTokenLens.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface responsible for viewing data from PowerToken smart contract.\r\ninterface IPowerTokenLens {\r\n\r\n    struct PwTokenCooldown {\r\n        // @dev The timestamp when the account can redeem Power Tokens\r\n        uint256 endTimestamp;\r\n        // @dev The amount of Power Tokens which can be redeemed without fee when the cooldown reaches `endTimestamp`\r\n        uint256 pwTokenAmount;\r\n    }\r\n\r\n    struct UpdateStakedToken {\r\n        address beneficiary;\r\n        uint256 stakedTokenAmount;\r\n    }\r\n\r\n    /// @notice Gets the total supply of the Power Token.\r\n    /// @dev Value is calculated in runtime using baseTotalSupply and internal exchange rate.\r\n    /// @return Total supply of Power tokens, represented with 18 decimals\r\n    function totalSupplyOfPwToken() external view returns (uint256);\r\n\r\n    /// @notice Gets the balance of Power Tokens for a given account\r\n    /// @param account account address for which the balance of Power Tokens is fetched\r\n    /// @return Returns the amount of the Power Tokens owned by the `account`.\r\n    function balanceOfPwToken(address account) external view returns (uint256);\r\n\r\n    /// @notice Gets the delegated balance of the Power Tokens for a given account.\r\n    /// Tokens are delegated from PowerToken to LiquidityMining smart contract (reponsible for rewards distribution).\r\n    /// @param account account address for which the balance of delegated Power Tokens is checked\r\n    /// @return  Returns the amount of the Power Tokens owned by the `account` and delegated to the LiquidityMining contracts.\r\n    function balanceOfPwTokenDelegatedToLiquidityMining(address account) external view returns (uint256);\r\n\r\n    /// @notice Gets the rate of the fee from the configuration. This fee is applied when the owner of Power Tokens wants to unstake them immediately.\r\n    /// @dev Fee value represented in as a percentage with 18 decimals\r\n    /// @return value, a percentage represented with 18 decimal\r\n    function getPwTokenUnstakeFee() external view returns (uint256);\r\n\r\n    /// @notice Gets the state of the active cooldown for the sender.\r\n    /// @dev If PowerTokenCoolDown contains only zeros it represents no active cool down.\r\n    /// Struct containing information on when the cooldown end and what is the quantity of the Power Tokens locked.\r\n    /// @param account account address that owns Power Tokens in the cooldown\r\n    /// @return Object PowerTokenCoolDown represents active cool down\r\n    function getPwTokensInCooldown(address account) external view returns (PwTokenCooldown memory);\r\n\r\n    /// @notice Gets the power token cool down time in seconds.\r\n    /// @return uint256 cool down time in seconds\r\n    function getPwTokenCooldownTime() external view returns (uint256);\r\n\r\n    /// @notice Calculates the internal exchange rate between the Staked Token and total supply of a base amount\r\n    /// @return Current exchange rate between the Staked Token and the total supply of a base amount, represented with 18 decimals.\r\n    function getPwTokenExchangeRate() external view returns (uint256);\r\n\r\n    /// @notice Gets the total supply base amount\r\n    /// @return total supply base amount, represented with 18 decimals\r\n    function getPwTokenTotalSupplyBase() external view returns (uint256);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IAssetManagementLens.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title AssetManagementLens interface responsible for reading data from AssetManagement.\r\ninterface IAssetManagementLens {\r\n    /// @dev A struct to represent an asset configuration.\r\n    struct AssetManagementConfiguration {\r\n        /// @notice The address of the asset.\r\n        address asset;\r\n        /// @notice Asset decimals.\r\n        uint256 decimals;\r\n        /// @notice The address of the asset management contract.\r\n        address assetManagement;\r\n        /// @notice The address of the AMM treasury contract.\r\n        address ammTreasury;\r\n    }\r\n\r\n    /// @notice Gets the AssetManagement configuration for the given asset.\r\n    /// @param asset The address of the asset.\r\n    /// @return AssetManagementConfiguration The AssetManagement configuration for the given asset.\r\n    function getAssetManagementConfiguration(address asset) external view returns (AssetManagementConfiguration memory);\r\n\r\n    /// @notice Gets balance of the AmmTreasury contract in the AssetManagement.\r\n    /// @dev This includes assets transferred to AssetManagement.\r\n    /// @param asset The address of the asset.\r\n    /// @return uint256 The total balance for the specified account, represented in 18 decimals.\r\n    function balanceOfAmmTreasuryInAssetManagement(address asset) external view returns (uint256);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/types/IporTypes.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Struct used across various interfaces in IPOR Protocol.\r\nlibrary IporTypes {\r\n    /// @notice enum describing Swap's state, ACTIVE - when the swap is opened, INACTIVE when it's closed\r\n    enum SwapState {\r\n        INACTIVE,\r\n        ACTIVE\r\n    }\r\n\r\n    /// @notice enum describing Swap's duration, 28 days, 60 days or 90 days\r\n    enum SwapTenor {\r\n        DAYS_28,\r\n        DAYS_60,\r\n        DAYS_90\r\n    }\r\n\r\n    /// @notice The struct describing the IPOR and its params calculated for the time when it was most recently updated and the change that took place since the update.\r\n    /// Namely, the interest that would be computed into IBT should the rebalance occur.\r\n    struct  AccruedIpor {\r\n        /// @notice IPOR Index Value\r\n        /// @dev value represented in 18 decimals\r\n        uint256 indexValue;\r\n        /// @notice IBT Price (IBT - Interest Bearing Token). For more information refer to the documentation:\r\n        /// https://ipor-labs.gitbook.io/ipor-labs/interest-rate-derivatives/ibt\r\n        /// @dev value represented in 18 decimals\r\n        uint256 ibtPrice;\r\n    }\r\n\r\n    /// @notice Struct representing balances used internally for asset calculations\r\n    /// @dev all balances in 18 decimals\r\n    struct AmmBalancesMemory {\r\n        /// @notice Sum of all collateral put forward by the derivative buyer's on  Pay Fixed & Receive Floating leg.\r\n        uint256 totalCollateralPayFixed;\r\n        /// @notice Sum of all collateral put forward by the derivative buyer's on  Pay Floating & Receive Fixed leg.\r\n        uint256 totalCollateralReceiveFixed;\r\n        /// @notice Liquidity Pool Balance. This balance is where the liquidity from liquidity providers and the opening fee are accounted for,\r\n        /// @dev Amount of opening fee accounted in this balance is defined by _OPENING_FEE_FOR_TREASURY_PORTION_RATE param.\r\n        uint256 liquidityPool;\r\n        /// @notice Vault's balance, describes how much asset has been transferred to Asset Management Vault (AssetManagement)\r\n        uint256 vault;\r\n    }\r\n\r\n    struct AmmBalancesForOpenSwapMemory {\r\n        /// @notice Sum of all collateral put forward by the derivative buyer's on  Pay Fixed & Receive Floating leg.\r\n        uint256 totalCollateralPayFixed;\r\n        /// @notice Total notional amount of all swaps on  Pay Fixed leg (denominated in 18 decimals).\r\n        uint256 totalNotionalPayFixed;\r\n        /// @notice Sum of all collateral put forward by the derivative buyer's on  Pay Floating & Receive Fixed leg.\r\n        uint256 totalCollateralReceiveFixed;\r\n        /// @notice Total notional amount of all swaps on  Receive Fixed leg (denominated in 18 decimals).\r\n        uint256 totalNotionalReceiveFixed;\r\n        /// @notice Liquidity Pool Balance.\r\n        uint256 liquidityPool;\r\n    }\r\n\r\n    struct SpreadInputs {\r\n        //// @notice Swap's assets DAI/USDC/USDT\r\n        address asset;\r\n        /// @notice Swap's notional value\r\n        uint256 swapNotional;\r\n        /// @notice demand spread factor used in demand spread calculation\r\n        uint256 demandSpreadFactor;\r\n        /// @notice Base spread\r\n        int256 baseSpreadPerLeg;\r\n        /// @notice Swap's balance for Pay Fixed leg\r\n        uint256 totalCollateralPayFixed;\r\n        /// @notice Swap's balance for Receive Fixed leg\r\n        uint256 totalCollateralReceiveFixed;\r\n        /// @notice Liquidity Pool's Balance\r\n        uint256 liquidityPoolBalance;\r\n        /// @notice Ipor index value at the time of swap creation\r\n        uint256 iporIndexValue;\r\n        // @notice fixed rate cap for given leg for offered rate without demandSpread in 18 decimals\r\n        uint256 fixedRateCapPerLeg;\r\n    }\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IAmmPoolsLens.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n/// @title Interface responsible for reading the AMM Pools state and configuration.\r\ninterface IAmmPoolsLens {\r\n    /// @dev A struct to represent a pool configuration.\r\n    /// @param asset The address of the asset.\r\n    /// @param decimals The number of decimal places the asset uses.\r\n    /// @param ipToken The address of the ipToken associated with the asset.\r\n    /// @param ammStorage The address of the AMM's storage contract.\r\n    /// @param ammTreasury The address of the AMM's treasury contract.\r\n    /// @param assetManagement The address of the asset management contract.\r\n    struct AmmPoolsLensPoolConfiguration {\r\n        address asset;\r\n        uint256 decimals;\r\n        address ipToken;\r\n        address ammStorage;\r\n        address ammTreasury;\r\n        address assetManagement;\r\n    }\r\n\r\n    /// @notice Gets Ipor Orale address\r\n    function iporOracle() external view returns (address);\r\n\r\n    /// @notice Retrieves the configuration of a specific asset's pool.\r\n    /// @param asset The address of the asset.\r\n    /// @return PoolConfiguration The pool's configuration.\r\n    function getAmmPoolsLensConfiguration(address asset) external view returns (AmmPoolsLensPoolConfiguration memory);\r\n\r\n    /// @notice Calculates the ipToken exchange rate.\r\n    /// @dev The exchange rate is a ratio between the Liquidity Pool Balance and the ipToken's total supply.\r\n    /// @param asset The address of the asset.\r\n    /// @return uint256 The ipToken exchange rate for the specific asset, represented in 18 decimals.\r\n    function getIpTokenExchangeRate(address asset) external view returns (uint256);\r\n\r\n    /// @notice Retrieves the AmmTreasury balance for a given asset.\r\n    /// @param asset The address of the asset.\r\n    /// @return IporTypes.AmmBalancesMemory The balance of the AMM Treasury.\r\n    function getAmmBalance(address asset) external view returns (IporTypes.AmmBalancesMemory memory);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/types/AmmTypes.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n/// @title Types used in interfaces strictly related to AMM (Automated Market Maker).\r\n/// @dev Used by IAmmTreasury and IAmmStorage interfaces.\r\nlibrary AmmTypes {\r\n    /// @notice Struct describing AMM Pool's core addresses.\r\n    struct AmmPoolCoreModel {\r\n        /// @notice asset address\r\n        address asset;\r\n        /// @notice asset decimals\r\n        uint256 assetDecimals;\r\n        /// @notice ipToken address associated to the asset\r\n        address ipToken;\r\n        /// @notice AMM Storage address\r\n        address ammStorage;\r\n        /// @notice AMM Treasury address\r\n        address ammTreasury;\r\n        /// @notice Asset Management address\r\n        address assetManagement;\r\n        /// @notice IPOR Oracle address\r\n        address iporOracle;\r\n        /// @notice IPOR Risk Management Oracle address\r\n        address iporRiskManagementOracle;\r\n    }\r\n\r\n    /// @notice Structure which represents Swap's data that will be saved in the storage.\r\n    /// Refer to the documentation https://ipor-labs.gitbook.io/ipor-labs/automated-market-maker/ipor-swaps for more information.\r\n    struct NewSwap {\r\n        /// @notice Account / trader who opens the Swap\r\n        address buyer;\r\n        /// @notice Epoch timestamp of when position was opened by the trader.\r\n        uint256 openTimestamp;\r\n        /// @notice Swap's collateral amount.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 collateral;\r\n        /// @notice Swap's notional amount.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 notional;\r\n        /// @notice Quantity of Interest Bearing Token (IBT) at moment when position was opened.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 ibtQuantity;\r\n        /// @notice Fixed interest rate at which the position has been opened.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 fixedInterestRate;\r\n        /// @notice Liquidation deposit is retained when the swap is opened. It is then paid back to agent who closes the derivative at maturity.\r\n        /// It can be both trader or community member. Trader receives the deposit back when he chooses to close the derivative before maturity.\r\n        /// @dev value represented WITHOUT 18 decimals\r\n        uint256 liquidationDepositAmount;\r\n        /// @notice Opening fee amount part which is allocated in Liquidity Pool Balance. This fee is calculated as a rate of the swap's collateral.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 openingFeeLPAmount;\r\n        /// @notice Opening fee amount part which is allocated in Treasury Balance. This fee is calculated as a rate of the swap's collateral.\r\n        /// @dev value represented in 18 decimals\r\n        uint256 openingFeeTreasuryAmount;\r\n        /// @notice Swap's tenor, 0 - 28 days, 1 - 60 days or 2 - 90 days\r\n        IporTypes.SwapTenor tenor;\r\n    }\r\n\r\n    /// @notice Struct representing swap item, used for listing and in internal calculations\r\n    struct Swap {\r\n        /// @notice Swap's unique ID\r\n        uint256 id;\r\n        /// @notice Swap's buyer\r\n        address buyer;\r\n        /// @notice Swap opening epoch timestamp\r\n        uint256 openTimestamp;\r\n        /// @notice Swap's tenor\r\n        IporTypes.SwapTenor tenor;\r\n        /// @notice Index position of this Swap in an array of swaps' identification associated to swap buyer\r\n        /// @dev Field used for gas optimization purposes, it allows for quick removal by id in the array.\r\n        /// During removal the last item in the array is switched with the one that just has been removed.\r\n        uint256 idsIndex;\r\n        /// @notice Swap's collateral\r\n        /// @dev value represented in 18 decimals\r\n        uint256 collateral;\r\n        /// @notice Swap's notional amount\r\n        /// @dev value represented in 18 decimals\r\n        uint256 notional;\r\n        /// @notice Swap's notional amount denominated in the Interest Bearing Token (IBT)\r\n        /// @dev value represented in 18 decimals\r\n        uint256 ibtQuantity;\r\n        /// @notice Fixed interest rate at which the position has been opened\r\n        /// @dev value represented in 18 decimals\r\n        uint256 fixedInterestRate;\r\n        /// @notice Liquidation deposit amount\r\n        /// @dev value represented in 18 decimals\r\n        uint256 liquidationDepositAmount;\r\n        /// @notice State of the swap\r\n        /// @dev 0 - INACTIVE, 1 - ACTIVE\r\n        IporTypes.SwapState state;\r\n    }\r\n\r\n    /// @notice Struct representing amounts related to Swap that is presently being opened.\r\n    /// @dev all values represented in 18 decimals\r\n    struct OpenSwapAmount {\r\n        /// @notice Total Amount of asset that is sent from buyer to AmmTreasury when opening swap.\r\n        uint256 totalAmount;\r\n        /// @notice Swap's collateral\r\n        uint256 collateral;\r\n        /// @notice Swap's notional\r\n        uint256 notional;\r\n        /// @notice Opening Fee - part allocated as a profit of the Liquidity Pool\r\n        uint256 openingFeeLPAmount;\r\n        /// @notice  Part of the fee set aside for subsidizing the oracle that publishes IPOR rate. Flat fee set by the DAO.\r\n        /// @notice Opening Fee - part allocated in Treasury balance. Part of the fee set asside for subsidising the oracle that publishes IPOR rate. Flat fee set by the DAO.\r\n        uint256 openingFeeTreasuryAmount;\r\n        /// @notice Fee set aside for subsidizing the oracle that publishes IPOR rate. Flat fee set by the DAO.\r\n        uint256 iporPublicationFee;\r\n        /// @notice Liquidation deposit is retained when the swap is opened. Value represented in 18 decimals.\r\n        uint256 liquidationDepositAmount;\r\n    }\r\n\r\n    /// @notice Structure describes one swap processed by closeSwaps method, information about swap ID and flag if this swap was closed during execution closeSwaps method.\r\n    struct IporSwapClosingResult {\r\n        /// @notice Swap ID\r\n        uint256 swapId;\r\n        /// @notice Flag describe if swap was closed during this execution\r\n        bool closed;\r\n    }\r\n\r\n    /// @notice Technical structure used for storing information about amounts used during redeeming assets from liquidity pool.\r\n    struct RedeemAmount {\r\n        /// @notice Asset amount represented in 18 decimals\r\n        /// @dev Asset amount is a sum of wadRedeemFee and wadRedeemAmount\r\n        uint256 wadAssetAmount;\r\n        /// @notice Redeemed amount represented in decimals of asset\r\n        uint256 redeemAmount;\r\n        /// @notice Redeem fee value represented in 18 decimals\r\n        uint256 wadRedeemFee;\r\n        /// @notice Redeem amount represented in 18 decimals\r\n        uint256 wadRedeemAmount;\r\n    }\r\n\r\n    /// @notice Swap direction (long = Pay Fixed and Receive a Floating or short = receive fixed and pay a floating)\r\n    enum SwapDirection {\r\n        /// @notice When taking the \"long\" position the trader will pay a fixed rate and receive a floating rate.\r\n        /// for more information refer to the documentation https://ipor-labs.gitbook.io/ipor-labs/automated-market-maker/ipor-swaps\r\n        PAY_FIXED_RECEIVE_FLOATING,\r\n        /// @notice When taking the \"short\" position the trader will pay a floating rate and receive a fixed rate.\r\n        PAY_FLOATING_RECEIVE_FIXED\r\n    }\r\n    /// @notice List of closable statuses for a given swap\r\n    /// @dev Closable status is a one of the following values:\r\n    /// 0 - Swap is closable\r\n    /// 1 - Swap is already closed\r\n    /// 2 - Swap state required Buyer or Liquidator to close. Sender is not Buyer nor Liquidator.\r\n    /// 3 - Cannot close swap, closing is too early for Community\r\n    enum SwapClosableStatus {\r\n        SWAP_IS_CLOSABLE,\r\n        SWAP_ALREADY_CLOSED,\r\n        SWAP_REQUIRED_BUYER_OR_LIQUIDATOR_TO_CLOSE,\r\n        SWAP_CANNOT_CLOSE_CLOSING_TOO_EARLY_FOR_COMMUNITY\r\n    }\r\n\r\n    /// @notice Collection of swap attributes connected with IPOR Index and swap itself.\r\n    /// @dev all values are in 18 decimals\r\n    struct IporSwapIndicator {\r\n        /// @notice IPOR Index value at the time of swap opening\r\n        uint256 iporIndexValue;\r\n        /// @notice IPOR Interest Bearing Token (IBT) price at the time of swap opening\r\n        uint256 ibtPrice;\r\n        /// @notice Swap's notional denominated in IBT\r\n        uint256 ibtQuantity;\r\n        /// @notice Fixed interest rate at which the position has been opened,\r\n        /// it is quote from spread documentation\r\n        uint256 fixedInterestRate;\r\n    }\r\n\r\n    /// @notice Risk indicators calculated for swap opening\r\n    struct OpenSwapRiskIndicators {\r\n        /// @notice Maximum collateral ratio in general\r\n        uint256 maxCollateralRatio;\r\n        /// @notice Maximum collateral ratio for a given leg\r\n        uint256 maxCollateralRatioPerLeg;\r\n        /// @notice Maximum leverage for a given leg\r\n        uint256 maxLeveragePerLeg;\r\n        /// @notice Base Spread for a given leg (without demand part)\r\n        int256 baseSpreadPerLeg;\r\n        /// @notice Fixed rate cap\r\n        uint256 fixedRateCapPerLeg;\r\n        /// @notice Demand spread factor used to calculate demand spread\r\n        uint256 demandSpreadFactor;\r\n    }\r\n\r\n    /// @notice Structure containing information about swap's closing status, unwind values and PnL for a given swap and time.\r\n    struct ClosingSwapDetails {\r\n        /// @notice Swap's closing status\r\n        AmmTypes.SwapClosableStatus closableStatus;\r\n        /// @notice Flag indicating if swap unwind is required\r\n        bool swapUnwindRequired;\r\n        /// @notice Swap's unwind PnL Value, part of PnL corresponded to virtual swap (unwinded swap), represented in 18 decimals\r\n        int256 swapUnwindPnlValue;\r\n        /// @notice Unwind opening fee amount it is a sum of `swapUnwindFeeLPAmount` and `swapUnwindFeeTreasuryAmount`\r\n        uint256 swapUnwindOpeningFeeAmount;\r\n        /// @notice Part of unwind opening fee allocated as a profit of the Liquidity Pool\r\n        uint256 swapUnwindFeeLPAmount;\r\n        /// @notice Part of unwind opening fee allocated in Treasury Balance\r\n        uint256 swapUnwindFeeTreasuryAmount;\r\n        /// @notice Final Profit and Loss which takes into account the swap unwind and limits the PnL to the collateral amount. Represented in 18 decimals.\r\n        int256 pnlValue;\r\n    }\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IAmmCloseSwapLens.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n/// @title Interface of the CloseSwap Lens.\r\ninterface IAmmCloseSwapLens {\r\n    /// @notice Structure representing the configuration of the AmmCloseSwapService for a given pool (asset).\r\n    struct AmmCloseSwapServicePoolConfiguration {\r\n        /// @notice asset address\r\n        address asset;\r\n        /// @notice asset decimals\r\n        uint256 decimals;\r\n        /// @notice Amm Storage contract address\r\n        address ammStorage;\r\n        /// @notice Amm Treasury contract address\r\n        address ammTreasury;\r\n        /// @notice Asset Management contract address\r\n        address assetManagement;\r\n        /// @notice Unwinding Fee Rate for unwinding the swap, represented in 18 decimals, 1e18 = 100%\r\n        uint256 unwindingFeeRate;\r\n        /// @notice Unwinding Fee Rate for unwinding the swap, part earmarked for the treasury, represented in 18 decimals, 1e18 = 100%\r\n        uint256 unwindingFeeTreasuryPortionRate;\r\n        /// @notice Max number of swaps (per leg) that can be liquidated in one call, represented without decimals\r\n        uint256 maxLengthOfLiquidatedSwapsPerLeg;\r\n        /// @notice Time before maturity when the community is allowed to close the swap, represented in seconds\r\n        uint256 timeBeforeMaturityAllowedToCloseSwapByCommunity;\r\n        /// @notice Time before maturity then the swap owner can close it, represented in seconds\r\n        uint256 timeBeforeMaturityAllowedToCloseSwapByBuyer;\r\n        /// @notice Min liquidation threshold allowing community to close the swap ahead of maturity, represented in 18 decimals\r\n        uint256 minLiquidationThresholdToCloseBeforeMaturityByCommunity;\r\n        /// @notice Min liquidation threshold allowing the owner to close the swap ahead of maturity, represented in 18 decimals\r\n        uint256 minLiquidationThresholdToCloseBeforeMaturityByBuyer;\r\n        /// @notice Min leverage of the virtual swap used in unwinding, represented in 18 decimals\r\n        uint256 minLeverage;\r\n    }\r\n\r\n    /// @notice Returns the configuration of the AmmCloseSwapService for a given pool (asset).\r\n    /// @param asset asset address\r\n    /// @return AmmCloseSwapServicePoolConfiguration struct representing the configuration of the AmmCloseSwapService for a given pool (asset).\r\n    function getAmmCloseSwapServicePoolConfiguration(\r\n        address asset\r\n    ) external view returns (AmmCloseSwapServicePoolConfiguration memory);\r\n\r\n    /// @notice Returns the closing swap details for a given swap and closing timestamp.\r\n    /// @param asset asset address\r\n    /// @param account account address for which are returned closing swap details, for example closableStatus depends on the account\r\n    /// @param direction swap direction\r\n    /// @param swapId swap id\r\n    /// @param closeTimestamp closing timestamp\r\n    /// @return closingSwapDetails struct representing the closing swap details for a given swap and closing timestamp.\r\n    function getClosingSwapDetails(\r\n        address asset,\r\n        address account,\r\n        AmmTypes.SwapDirection direction,\r\n        uint256 swapId,\r\n        uint256 closeTimestamp\r\n    ) external view returns (AmmTypes.ClosingSwapDetails memory closingSwapDetails);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IAmmCloseSwapService.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n/// @title Interface of the service allowing to close swaps.\r\ninterface IAmmCloseSwapService {\r\n    /// @notice Emitted when the trader closes the swap.\r\n    event CloseSwap(\r\n        /// @notice swap ID.\r\n        uint256 indexed swapId,\r\n        /// @notice underlying asset\r\n        address asset,\r\n        /// @notice the moment when swap was closed\r\n        uint256 closeTimestamp,\r\n        /// @notice account that liquidated the swap\r\n        address liquidator,\r\n        /// @notice asset amount after closing swap that has been transferred from AmmTreasury to the Buyer. Value represented in 18 decimals.\r\n        uint256 transferredToBuyer,\r\n        /// @notice asset amount after closing swap that has been transferred from AmmTreasury to the Liquidator. Value represented in 18 decimals.\r\n        uint256 transferredToLiquidator\r\n    );\r\n\r\n    /// @notice Emitted when unwind is performed during closing swap.\r\n    event SwapUnwind(\r\n        /// @notice underlying asset\r\n        address asset,\r\n        /// @notice swap ID.\r\n        uint256 indexed swapId,\r\n        /// @notice Profit and Loss to date without unwind value, represented in 18 decimals\r\n        int256 swapPnlValueToDate,\r\n        /// @notice swap unwind amount, represented in 18 decimals\r\n        int256 swapUnwindAmount,\r\n        /// @notice unwind fee amount, part earmarked for the liquidity pool, represented in 18 decimals\r\n        uint256 unwindFeeLPAmount,\r\n        /// @notice unwind fee amount, part earmarked for the treasury, represented in 18 decimals\r\n        uint256 unwindFeeTreasuryAmount\r\n    );\r\n\r\n    /// @notice Closes batch of USDT swaps on both legs.\r\n    /// @param beneficiary account - receiver of liquidation deposit.\r\n    /// @param payFixedSwapIds array of pay-fixed swap IDs.\r\n    /// @param receiveFixedSwapIds array of receive-fixed swap IDs.\r\n    /// @dev Swap PnL is always transferred to the swaps's owner.\r\n    /// @return closedPayFixedSwaps array of closed pay-fixed swaps.\r\n    /// @return closedReceiveFixedSwaps array of closed receive-fixed swaps.\r\n    function closeSwapsUsdt(\r\n        address beneficiary,\r\n        uint256[] memory payFixedSwapIds,\r\n        uint256[] memory receiveFixedSwapIds\r\n    )\r\n        external\r\n        returns (\r\n            AmmTypes.IporSwapClosingResult[] memory closedPayFixedSwaps,\r\n            AmmTypes.IporSwapClosingResult[] memory closedReceiveFixedSwaps\r\n        );\r\n\r\n    /// @notice Closes batch of USDC swaps on both legs.\r\n    /// @param beneficiary account - receiver of liquidation deposit.\r\n    /// @param payFixedSwapIds array of pay fixed swap IDs.\r\n    /// @param receiveFixedSwapIds array of receive fixed swap IDs.\r\n    /// @dev Swap PnL is always transferred to the swaps's owner.\r\n    /// @return closedPayFixedSwaps array of closed pay-fixed swaps.\r\n    /// @return closedReceiveFixedSwaps array of closed receive-fixed swaps.\r\n    function closeSwapsUsdc(\r\n        address beneficiary,\r\n        uint256[] memory payFixedSwapIds,\r\n        uint256[] memory receiveFixedSwapIds\r\n    )\r\n        external\r\n        returns (\r\n            AmmTypes.IporSwapClosingResult[] memory closedPayFixedSwaps,\r\n            AmmTypes.IporSwapClosingResult[] memory closedReceiveFixedSwaps\r\n        );\r\n\r\n    /// @notice Closes batch of DAI swaps on both legs.\r\n    /// @param beneficiary account - receiver of liquidation deposit.\r\n    /// @param payFixedSwapIds array of pay fixed swap IDs.\r\n    /// @param receiveFixedSwapIds array of receive fixed swap IDs.\r\n    /// @dev Swap PnL is always transferred to the swaps's owner.\r\n    /// @return closedPayFixedSwaps array of closed pay-fixed swaps.\r\n    /// @return closedReceiveFixedSwaps array of closed receive-fixed swaps.\r\n    function closeSwapsDai(\r\n        address beneficiary,\r\n        uint256[] memory payFixedSwapIds,\r\n        uint256[] memory receiveFixedSwapIds\r\n    )\r\n        external\r\n        returns (\r\n            AmmTypes.IporSwapClosingResult[] memory closedPayFixedSwaps,\r\n            AmmTypes.IporSwapClosingResult[] memory closedReceiveFixedSwaps\r\n        );\r\n\r\n    /// @notice Closes batch of USDT swaps on both legs in emergency mode by Owner of Ipor Protocol Router.\r\n    /// @param payFixedSwapIds array of pay-fixed swap IDs.\r\n    /// @param receiveFixedSwapIds array of receive-fixed swap IDs.\r\n    /// @return closedPayFixedSwaps array of closed pay-fixed swaps.\r\n    /// @return closedReceiveFixedSwaps array of closed receive-fixed swaps.\r\n    function emergencyCloseSwapsUsdt(\r\n        uint256[] memory payFixedSwapIds,\r\n        uint256[] memory receiveFixedSwapIds\r\n    )\r\n        external\r\n        returns (\r\n            AmmTypes.IporSwapClosingResult[] memory closedPayFixedSwaps,\r\n            AmmTypes.IporSwapClosingResult[] memory closedReceiveFixedSwaps\r\n        );\r\n\r\n    /// @notice Closes batch of USDC swaps on both legs in emergency mode by Owner of Ipor Protocol Router.\r\n    /// @param payFixedSwapIds array of pay-fixed swap IDs.\r\n    /// @param receiveFixedSwapIds array of receive-fixed swap IDs.\r\n    /// @return closedPayFixedSwaps array of closed pay-fixed swaps.\r\n    /// @return closedReceiveFixedSwaps array of closed receive-fixed swaps.\r\n    function emergencyCloseSwapsUsdc(\r\n        uint256[] memory payFixedSwapIds,\r\n        uint256[] memory receiveFixedSwapIds\r\n    )\r\n        external\r\n        returns (\r\n            AmmTypes.IporSwapClosingResult[] memory closedPayFixedSwaps,\r\n            AmmTypes.IporSwapClosingResult[] memory closedReceiveFixedSwaps\r\n        );\r\n\r\n    /// @notice Closes batch of DAI swaps on both legs in emergency mode by Owner of Ipor Protocol Router.\r\n    /// @param payFixedSwapIds array of pay-fixed swap IDs.\r\n    /// @param receiveFixedSwapIds array of receive-fixed swap IDs.\r\n    /// @return closedPayFixedSwaps array of closed pay-fixed swaps.\r\n    /// @return closedReceiveFixedSwaps array of closed receive-fixed swaps.\r\n    function emergencyCloseSwapsDai(\r\n        uint256[] memory payFixedSwapIds,\r\n        uint256[] memory receiveFixedSwapIds\r\n    )\r\n        external\r\n        returns (\r\n            AmmTypes.IporSwapClosingResult[] memory closedPayFixedSwaps,\r\n            AmmTypes.IporSwapClosingResult[] memory closedReceiveFixedSwaps\r\n        );\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IAmmOpenSwapService.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n/// @title Interface of the service allowing to open new swaps.\r\ninterface IAmmOpenSwapService {\r\n    /// @notice Emitted when the trader opens new swap.\r\n    event OpenSwap(\r\n        /// @notice swap ID.\r\n        uint256 indexed swapId,\r\n        /// @notice trader that opened the swap\r\n        address indexed buyer,\r\n        /// @notice underlying asset\r\n        address asset,\r\n        /// @notice swap direction, Pay Fixed Receive Floating or Pay Floating Receive Fixed.\r\n        AmmTypes.SwapDirection direction,\r\n        /// @notice technical structure with amounts related with this swap\r\n        AmmTypes.OpenSwapAmount amounts,\r\n        /// @notice the moment when swap was opened\r\n        uint256 openTimestamp,\r\n        /// @notice the moment when swap will achieve maturity\r\n        uint256 endTimestamp,\r\n        /// @notice specific indicators related with this swap\r\n        AmmTypes.IporSwapIndicator indicator\r\n    );\r\n\r\n    /// @notice It opens a swap for USDT pay-fixed receive-floating with a tenor of 28 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapPayFixed28daysUsdt(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for USDT pay-fixed receive-floating with a tenor of 60 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapPayFixed60daysUsdt(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for USDT pay-fixed receive-floating with a tenor of 90 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapPayFixed90daysUsdt(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for USDT receive-fixed pay-floating with a tenor of 28 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapReceiveFixed28daysUsdt(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for USDT receive-fixed pay-floating with a tenor of 60 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapReceiveFixed60daysUsdt(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for USDT receive-fixed pay-floating with a tenor of 90 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapReceiveFixed90daysUsdt(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for USDC pay-fixed receive-floating with a tenor of 28 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapPayFixed28daysUsdc(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for USDC pay-fixed receive-floating with a tenor of 60 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapPayFixed60daysUsdc(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for USDC pay-fixed receive-floating with a tenor of 90 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapPayFixed90daysUsdc(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for USDC receive-fixed pay-floating with a tenor of 28 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapReceiveFixed28daysUsdc(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for USDC receive-fixed pay-floating with a tenor of 60 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapReceiveFixed60daysUsdc(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for USDC receive-fixed pay-floating with a tenor of 90 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapReceiveFixed90daysUsdc(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for DAI pay-fixed receive-floating with a tenor of 28 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapPayFixed28daysDai(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for DAI pay-fixed receive-floating with a tenor of 60 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapPayFixed60daysDai(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for DAI pay-fixed receive-floating with a tenor of 90 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapPayFixed90daysDai(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for DAI receive-fixed pay-floating with a tenor of 28 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapReceiveFixed28daysDai(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for DAI receive-fixed pay-floating with a tenor of 60 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapReceiveFixed60daysDai(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n\r\n    /// @notice It opens a swap for DAI receive-fixed pay-floating with a tenor of 90 days.\r\n    /// @param beneficiary address of the owner of the swap.\r\n    /// @param totalAmount total amount used by sender to open the swap, represented in decimals specific to the asset.\r\n    /// @param acceptableFixedInterestRate acceptable fixed interest rate, represented in 18 decimals.\r\n    /// @param leverage swap leverage, represented in 18 decimals.\r\n    /// @return swapId ID of the opened swap.\r\n    /// @dev The address `beneficiary` is the swap's owner. Sender pays for the swap.\r\n    function openSwapReceiveFixed90daysDai(\r\n        address beneficiary,\r\n        uint256 totalAmount,\r\n        uint256 acceptableFixedInterestRate,\r\n        uint256 leverage\r\n    ) external returns (uint256);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IAmmSwapsLens.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n\r\n/// @title AmmSwapsLens interface responsible for reading data related with swaps.\r\ninterface IAmmSwapsLens {\r\n    /// @notice IPOR Swap structure.\r\n    struct IporSwap {\r\n        /// @notice Swap's ID.\r\n        uint256 id;\r\n        /// @notice Swap's asset (stablecoin / underlying token)\r\n        address asset;\r\n        /// @notice Swap's buyer address\r\n        address buyer;\r\n        /// @notice Swap's collateral, represented in 18 decimals.\r\n        uint256 collateral;\r\n        /// @notice Notional amount, represented in 18 decimals.\r\n        uint256 notional;\r\n        /// @notice Swap's leverage, represented in 18 decimals.\r\n        uint256 leverage;\r\n        /// @notice Swap's direction\r\n        /// @dev 0 - Pay Fixed-Receive Floating, 1 - Receive Fixed - Pay Floading\r\n        uint256 direction;\r\n        /// @notice Swap's notional amount denominated in the Interest Bearing Token (IBT)\r\n        /// @dev value represented in 18 decimals\r\n        uint256 ibtQuantity;\r\n        /// @notice Fixed interest rate.\r\n        uint256 fixedInterestRate;\r\n        /// @notice Current PnL value (Profit and Loss Value), represented in 18 decimals.\r\n        int256 pnlValue;\r\n        /// @notice Moment when swap was opened.\r\n        uint256 openTimestamp;\r\n        /// @notice Moment when swap achieve its maturity.\r\n        uint256 endTimestamp;\r\n        /// @notice Liquidation deposit value on day when swap was opened. Value represented in 18 decimals.\r\n        uint256 liquidationDepositAmount;\r\n        /// @notice State of the swap\r\n        /// @dev 0 - INACTIVE, 1 - ACTIVE\r\n        uint256 state;\r\n    }\r\n\r\n    /// @notice Lens Configuration structure for AmmSwapsLens for a given asset (ppol)\r\n    struct SwapLensPoolConfiguration {\r\n        /// @notice Asset address\r\n        address asset;\r\n        /// @notice Address of the AMM (Automated Market Maker) storage contract\r\n        address ammStorage;\r\n        /// @notice Address of the AMM Treasury contract\r\n        address ammTreasury;\r\n        /// @notice minimum leverage, represented in 18 decimals.\r\n        uint256 minLeverage;\r\n    }\r\n\r\n    /// @notice Gets pool configuration for AmmSwapsLens\r\n    /// @param asset asset address\r\n    /// @return SwapLensPoolConfiguration pool configuration\r\n    function getSwapLensPoolConfiguration(address asset) external view returns (SwapLensPoolConfiguration memory);\r\n\r\n    /// @notice Gets active swaps for a given asset sender address (aka buyer).\r\n    /// @param asset asset address\r\n    /// @param offset offset for paging\r\n    /// @param chunkSize page size for paging\r\n    /// @return totalCount total number of sender's active swaps in AmmTreasury\r\n    /// @return swaps list of active sender's swaps\r\n    function getSwaps(\r\n        address asset,\r\n        address account,\r\n        uint256 offset,\r\n        uint256 chunkSize\r\n    ) external view returns (uint256 totalCount, IporSwap[] memory swaps);\r\n\r\n    /// @notice Gets the swap's PnL (Profit and Loss) for a pay-fixed, given asset and swap ID.\r\n    /// @param asset asset address\r\n    /// @param swapId swap ID\r\n    /// @return pnlValue PnL for a pay fixed swap\r\n    function getPnlPayFixed(address asset, uint256 swapId) external view returns (int256 pnlValue);\r\n\r\n    /// @notice Gets the swap's PnL (Profit and Loss) for a receive-fixed, given asset and swap ID.\r\n    /// @param asset asset address\r\n    /// @param swapId swap ID\r\n    /// @return pnlValue PnL for a receive fixed swap\r\n    function getPnlReceiveFixed(address asset, uint256 swapId) external view returns (int256 pnlValue);\r\n\r\n    /// @notice Gets the balances structure required to open a swap.\r\n    /// @param asset The address of the asset.\r\n    /// @return AmmBalancesForOpenSwapMemory The balances required for opening a swap.\r\n    function getBalancesForOpenSwap(\r\n        address asset\r\n    ) external view returns (IporTypes.AmmBalancesForOpenSwapMemory memory);\r\n\r\n    /// @notice Gets the SOAP value for a given asset.\r\n    /// @param asset The address of the asset.\r\n    /// @return soapPayFixed SOAP value for pay fixed swaps.\r\n    /// @return soapReceiveFixed SOAP value for receive fixed swaps.\r\n    /// @return soap SOAP value which is a sum of soapPayFixed and soapReceiveFixed.\r\n    function getSoap(address asset) external view returns (int256 soapPayFixed, int256 soapReceiveFixed, int256 soap);\r\n\r\n    /// @notice Gets the offered rate value for a given asset, tenor and notional.\r\n    /// @param asset The address of the asset.\r\n    /// @param tenor The duration of the swap.\r\n    /// @param notional The notional amount of the swap, represented in 18 decimals.\r\n    /// @return offeredRatePayFixed The offered rate for pay fixed swaps.\r\n    /// @return offeredRateReceiveFixed The offered rate for receive fixed swaps.\r\n    function getOfferedRate(\r\n        address asset,\r\n        IporTypes.SwapTenor tenor,\r\n        uint256 notional\r\n    ) external view returns (uint256 offeredRatePayFixed, uint256 offeredRateReceiveFixed);\r\n\r\n    /**\r\n     * @dev Returns the Risk indicators when open swap for a given asse, direction and tenor.\r\n     * @param asset The address of the asset.\r\n     * @param direction The direction of the swap\r\n     * @param tenor The duration of the swap\r\n     * @return riskIndicators The open swap configuration details.\r\n     */\r\n    function getOpenSwapRiskIndicators(\r\n        address asset,\r\n        uint256 direction,\r\n        IporTypes.SwapTenor tenor\r\n    ) external view returns (AmmTypes.OpenSwapRiskIndicators memory riskIndicators);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\r\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for reading and writing primitive types to specific storage slots.\r\n *\r\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\r\n * This library helps with reading and writing to such slots without the need for inline assembly.\r\n *\r\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\r\n *\r\n * Example usage to set ERC1967 implementation slot:\r\n * ```solidity\r\n * contract ERC1967 {\r\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n *\r\n *     function _getImplementation() internal view returns (address) {\r\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n *     }\r\n *\r\n *     function _setImplementation(address newImplementation) internal {\r\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\r\n * _Available since v4.9 for `string`, `bytes`._\r\n */\r\nlibrary StorageSlotUpgradeable {\r\n    struct AddressSlot {\r\n        address value;\r\n    }\r\n\r\n    struct BooleanSlot {\r\n        bool value;\r\n    }\r\n\r\n    struct Bytes32Slot {\r\n        bytes32 value;\r\n    }\r\n\r\n    struct Uint256Slot {\r\n        uint256 value;\r\n    }\r\n\r\n    struct StringSlot {\r\n        string value;\r\n    }\r\n\r\n    struct BytesSlot {\r\n        bytes value;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\r\n     */\r\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\r\n     */\r\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\r\n     */\r\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\r\n     */\r\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\r\n     */\r\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := store.slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\r\n     */\r\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := store.slot\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```solidity\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n *\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n    uint8 private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint8 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\r\n     * constructor.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        bool isTopLevelCall = !_initializing;\r\n        require(\r\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = 1;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier reinitializer(uint8 version) {\r\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\r\n        _initialized = version;\r\n        _initializing = true;\r\n        _;\r\n        _initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        require(!_initializing, \"Initializable: contract is initializing\");\r\n        if (_initialized != type(uint8).max) {\r\n            _initialized = type(uint8).max;\r\n            emit Initialized(type(uint8).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\r\n     */\r\n    function _getInitializedVersion() internal view returns (uint8) {\r\n        return _initialized;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     */\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _initializing;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\r\n *\r\n * _Available since v4.8.3._\r\n */\r\ninterface IERC1967Upgradeable {\r\n    /**\r\n     * @dev Emitted when the implementation is upgraded.\r\n     */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * @dev Emitted when the admin account has changed.\r\n     */\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @dev Emitted when the beacon is changed.\r\n     */\r\n    event BeaconUpgraded(address indexed beacon);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\r\n */\r\ninterface IBeaconUpgradeable {\r\n    /**\r\n     * @dev Must return an address that can be used as a delegate call target.\r\n     *\r\n     * {BeaconProxy} will check that this address is a contract.\r\n     */\r\n    function implementation() external view returns (address);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\r\n * proxy whose upgrades are fully controlled by the current implementation.\r\n */\r\ninterface IERC1822ProxiableUpgradeable {\r\n    /**\r\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\r\n     * address.\r\n     *\r\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\r\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\r\n     * function revert if invoked through a proxy.\r\n     */\r\n    function proxiableUUID() external view returns (bytes32);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev This abstract contract provides getters and event emitting update functions for\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\r\n *\r\n * _Available since v4.1._\r\n */\r\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\r\n    function __ERC1967Upgrade_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\r\n    }\r\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\r\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n     * @dev Returns the current implementation address.\r\n     */\r\n    function _getImplementation() internal view returns (address) {\r\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 implementation slot.\r\n     */\r\n    function _setImplementation(address newImplementation) private {\r\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade with additional setup call.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\r\n        _upgradeTo(newImplementation);\r\n        if (data.length > 0 || forceCall) {\r\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\r\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\r\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\r\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\r\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\r\n            _setImplementation(newImplementation);\r\n        } else {\r\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\r\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\r\n            } catch {\r\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\r\n            }\r\n            _upgradeToAndCall(newImplementation, data, forceCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Storage slot with the admin of the contract.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     */\r\n    function _getAdmin() internal view returns (address) {\r\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 admin slot.\r\n     */\r\n    function _setAdmin(address newAdmin) private {\r\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\r\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of the proxy.\r\n     *\r\n     * Emits an {AdminChanged} event.\r\n     */\r\n    function _changeAdmin(address newAdmin) internal {\r\n        emit AdminChanged(_getAdmin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\r\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\r\n     */\r\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\r\n\r\n    /**\r\n     * @dev Returns the current beacon.\r\n     */\r\n    function _getBeacon() internal view returns (address) {\r\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\r\n     */\r\n    function _setBeacon(address newBeacon) private {\r\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\r\n        require(\r\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\r\n            \"ERC1967: beacon implementation is not a contract\"\r\n        );\r\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\r\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\r\n     *\r\n     * Emits a {BeaconUpgraded} event.\r\n     */\r\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\r\n        _setBeacon(newBeacon);\r\n        emit BeaconUpgraded(newBeacon);\r\n        if (data.length > 0 || forceCall) {\r\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\r\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\r\n *\r\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\r\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\r\n * `UUPSUpgradeable` with a custom implementation of upgrades.\r\n *\r\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\r\n *\r\n * _Available since v4.1._\r\n */\r\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\r\n    function __UUPSUpgradeable_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\r\n    }\r\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\r\n    address private immutable __self = address(this);\r\n\r\n    /**\r\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\r\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\r\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\r\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\r\n     * fail.\r\n     */\r\n    modifier onlyProxy() {\r\n        require(address(this) != __self, \"Function must be called through delegatecall\");\r\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\r\n     * callable on the implementing contract but not through proxies.\r\n     */\r\n    modifier notDelegated() {\r\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\r\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\r\n     *\r\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\r\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\r\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\r\n     */\r\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\r\n        return _IMPLEMENTATION_SLOT;\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\r\n     *\r\n     * Calls {_authorizeUpgrade}.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     *\r\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\r\n     */\r\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\r\n        _authorizeUpgrade(newImplementation);\r\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\r\n     * encoded in `data`.\r\n     *\r\n     * Calls {_authorizeUpgrade}.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     *\r\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\r\n     */\r\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\r\n        _authorizeUpgrade(newImplementation);\r\n        _upgradeToAndCallUUPS(newImplementation, data, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\r\n     * {upgradeTo} and {upgradeToAndCall}.\r\n     *\r\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\r\n     *\r\n     * ```solidity\r\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\r\n     * ```\r\n     */\r\n    function _authorizeUpgrade(address newImplementation) internal virtual;\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/router/IporProtocolRouter.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Entry point for IPOR protocol\r\ncontract IporProtocolRouter is UUPSUpgradeable, AccessControl, IProxyImplementation {\r\n    using Address for address;\r\n    using IporContractValidator for address;\r\n\r\n    uint256 private constant SINGLE_OPERATION = 0;\r\n    uint256 private constant BATCH_OPERATION = 1;\r\n\r\n    address public immutable _ammSwapsLens;\r\n    address public immutable _ammPoolsLens;\r\n    address public immutable _assetManagementLens;\r\n    address public immutable _ammOpenSwapService;\r\n    address public immutable _ammCloseSwapService;\r\n    address public immutable _ammPoolsService;\r\n    address public immutable _ammGovernanceService;\r\n    address public immutable _liquidityMiningLens;\r\n    address public immutable _powerTokenLens;\r\n    address public immutable _flowService;\r\n    address public immutable _stakeService;\r\n    address public immutable _ammPoolsServiceEth;\r\n    address public immutable _ammPoolsLensEth;\r\n\r\n    struct DeployedContracts {\r\n        address ammSwapsLens;\r\n        address ammPoolsLens;\r\n        address assetManagementLens;\r\n        address ammOpenSwapService;\r\n        address ammCloseSwapService;\r\n        address ammPoolsService;\r\n        address ammGovernanceService;\r\n        address liquidityMiningLens;\r\n        address powerTokenLens;\r\n        address flowService;\r\n        address stakeService;\r\n        address ammPoolsServiceEth;\r\n        address ammPoolsLensEth;\r\n    }\r\n\r\n    constructor(DeployedContracts memory deployedContracts) {\r\n        _ammSwapsLens = deployedContracts.ammSwapsLens.checkAddress();\r\n        _ammPoolsLens = deployedContracts.ammPoolsLens.checkAddress();\r\n        _assetManagementLens = deployedContracts.assetManagementLens.checkAddress();\r\n        _ammOpenSwapService = deployedContracts.ammOpenSwapService.checkAddress();\r\n        _ammCloseSwapService = deployedContracts.ammCloseSwapService.checkAddress();\r\n        _ammPoolsService = deployedContracts.ammPoolsService.checkAddress();\r\n        _ammGovernanceService = deployedContracts.ammGovernanceService.checkAddress();\r\n        _liquidityMiningLens = deployedContracts.liquidityMiningLens.checkAddress();\r\n        _powerTokenLens = deployedContracts.powerTokenLens.checkAddress();\r\n        _flowService = deployedContracts.flowService.checkAddress();\r\n        _stakeService = deployedContracts.stakeService.checkAddress();\r\n        _ammPoolsServiceEth = deployedContracts.ammPoolsServiceEth.checkAddress();\r\n        _ammPoolsLensEth = deployedContracts.ammPoolsLensEth.checkAddress();\r\n        _disableInitializers();\r\n    }\r\n\r\n    fallback() external payable {\r\n        _delegate(_getRouterImplementation(msg.sig, SINGLE_OPERATION));\r\n    }\r\n\r\n    function initialize(bool paused) external initializer {\r\n        __UUPSUpgradeable_init();\r\n        OwnerManager.transferOwnership(msg.sender);\r\n        StorageLib.getReentrancyStatus().value = _NOT_ENTERED;\r\n    }\r\n\r\n    /// @notice Gets the implementation of the router\r\n    /// @return implementation address\r\n    function getImplementation() external view override returns (address) {\r\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n    }\r\n\r\n    /// @notice Gets the Router configuration\r\n    /// @return DeployedContracts struct\r\n    function getConfiguration() external view returns (DeployedContracts memory) {\r\n        return\r\n            DeployedContracts({\r\n                ammSwapsLens: _ammSwapsLens,\r\n                ammPoolsLens: _ammPoolsLens,\r\n                assetManagementLens: _assetManagementLens,\r\n                ammOpenSwapService: _ammOpenSwapService,\r\n                ammCloseSwapService: _ammCloseSwapService,\r\n                ammPoolsService: _ammPoolsService,\r\n                ammGovernanceService: _ammGovernanceService,\r\n                liquidityMiningLens: _liquidityMiningLens,\r\n                powerTokenLens: _powerTokenLens,\r\n                flowService: _flowService,\r\n                stakeService: _stakeService,\r\n                ammPoolsServiceEth: _ammPoolsServiceEth,\r\n                ammPoolsLensEth: _ammPoolsLensEth\r\n            });\r\n    }\r\n\r\n    /// @notice Allows to execute batch of calls in one transaction using IPOR protocol business methods\r\n    /// @param calls array of encoded calls\r\n    function batchExecutor(bytes[] calldata calls) external payable nonReentrant {\r\n        uint256 length = calls.length;\r\n        address implementation;\r\n\r\n        for (uint256 i; i != length; ) {\r\n            implementation = _getRouterImplementation(bytes4(calls[i][:4]), BATCH_OPERATION);\r\n            implementation.functionDelegateCall(calls[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        _returnBackRemainingEth();\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function _getRouterImplementation(bytes4 sig, uint256 batchOperation) internal returns (address) {\r\n        if (\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapPayFixed60daysUsdt.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapPayFixed28daysUsdt.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapPayFixed90daysUsdt.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapReceiveFixed28daysUsdt.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapReceiveFixed60daysUsdt.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapReceiveFixed90daysUsdt.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapPayFixed28daysUsdc.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapPayFixed60daysUsdc.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapPayFixed90daysUsdc.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapReceiveFixed28daysUsdc.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapReceiveFixed60daysUsdc.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapReceiveFixed90daysUsdc.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapPayFixed28daysDai.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapPayFixed60daysDai.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapPayFixed90daysDai.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapReceiveFixed28daysDai.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapReceiveFixed60daysDai.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmOpenSwapService.openSwapReceiveFixed90daysDai.selector)\r\n        ) {\r\n            if (batchOperation == 0) {\r\n                _nonReentrantBefore();\r\n            }\r\n            return _ammOpenSwapService;\r\n        } else if (\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmCloseSwapService.closeSwapsUsdt.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmCloseSwapService.closeSwapsUsdc.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmCloseSwapService.closeSwapsDai.selector)\r\n        ) {\r\n            if (batchOperation == 0) {\r\n                _nonReentrantBefore();\r\n            }\r\n            return _ammCloseSwapService;\r\n        } else if (\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmPoolsServiceEth.provideLiquidityStEth.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmPoolsServiceEth.provideLiquidityWEth.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmPoolsServiceEth.provideLiquidityEth.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmPoolsServiceEth.redeemFromAmmPoolStEth.selector)\r\n        ) {\r\n            if (batchOperation == 0) {\r\n                _nonReentrantBefore();\r\n            }\r\n            return _ammPoolsServiceEth;\r\n        } else if (\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmPoolsService.provideLiquidityUsdt.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmPoolsService.provideLiquidityUsdc.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmPoolsService.provideLiquidityDai.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmPoolsService.redeemFromAmmPoolUsdt.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmPoolsService.redeemFromAmmPoolUsdc.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmPoolsService.redeemFromAmmPoolDai.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IAmmPoolsService.rebalanceBetweenAmmTreasuryAndAssetManagement.selector)\r\n        ) {\r\n            if (batchOperation == 0) {\r\n                _nonReentrantBefore();\r\n            }\r\n            return _ammPoolsService;\r\n        } else if (\r\n            _checkFunctionSigAndIsNotPause(sig, IPowerTokenStakeService.stakeLpTokensToLiquidityMining.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IPowerTokenStakeService.unstakeLpTokensFromLiquidityMining.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IPowerTokenStakeService.stakeGovernanceTokenToPowerToken.selector) ||\r\n            _checkFunctionSigAndIsNotPause(\r\n                sig,\r\n                IPowerTokenStakeService.stakeGovernanceTokenToPowerTokenAndDelegate.selector\r\n            ) ||\r\n            _checkFunctionSigAndIsNotPause(\r\n                sig,\r\n                IPowerTokenStakeService.unstakeGovernanceTokenFromPowerToken.selector\r\n            ) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IPowerTokenStakeService.pwTokenCooldown.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IPowerTokenStakeService.pwTokenCancelCooldown.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IPowerTokenStakeService.redeemPwToken.selector)\r\n        ) {\r\n            if (batchOperation == 0) {\r\n                _nonReentrantBefore();\r\n            }\r\n            return _stakeService;\r\n        } else if (\r\n            _checkFunctionSigAndIsNotPause(sig, IPowerTokenFlowsService.delegatePwTokensToLiquidityMining.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IPowerTokenFlowsService.updateIndicatorsInLiquidityMining.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IPowerTokenFlowsService.undelegatePwTokensFromLiquidityMining.selector) ||\r\n            _checkFunctionSigAndIsNotPause(sig, IPowerTokenFlowsService.claimRewardsFromLiquidityMining.selector)\r\n        ) {\r\n            if (batchOperation == 0) {\r\n                _nonReentrantBefore();\r\n            }\r\n            return _flowService;\r\n        } else if (\r\n            sig == IAmmGovernanceService.transferToTreasury.selector ||\r\n            sig == IAmmGovernanceService.transferToCharlieTreasury.selector\r\n        ) {\r\n            if (batchOperation == 0) {\r\n                _nonReentrantBefore();\r\n            }\r\n            return _ammGovernanceService;\r\n        } else if (\r\n            sig == IAmmGovernanceService.addSwapLiquidator.selector ||\r\n            sig == IAmmGovernanceService.removeSwapLiquidator.selector ||\r\n            sig == IAmmGovernanceService.addAppointedToRebalanceInAmm.selector ||\r\n            sig == IAmmGovernanceService.removeAppointedToRebalanceInAmm.selector ||\r\n            sig == IAmmGovernanceService.depositToAssetManagement.selector ||\r\n            sig == IAmmGovernanceService.withdrawFromAssetManagement.selector ||\r\n            sig == IAmmGovernanceService.withdrawAllFromAssetManagement.selector ||\r\n            sig == IAmmGovernanceService.setAmmPoolsParams.selector\r\n        ) {\r\n            _onlyOwner();\r\n            return _ammGovernanceService;\r\n        } else if (\r\n            sig == IAmmCloseSwapService.emergencyCloseSwapsUsdt.selector ||\r\n            sig == IAmmCloseSwapService.emergencyCloseSwapsUsdc.selector ||\r\n            sig == IAmmCloseSwapService.emergencyCloseSwapsDai.selector\r\n        ) {\r\n            _onlyOwner();\r\n            return _ammCloseSwapService;\r\n        } else if (\r\n            sig == IAmmGovernanceLens.isSwapLiquidator.selector ||\r\n            sig == IAmmGovernanceLens.isAppointedToRebalanceInAmm.selector ||\r\n            sig == IAmmGovernanceLens.getAmmPoolsParams.selector ||\r\n            sig == IAmmGovernanceLens.getAmmGovernancePoolConfiguration.selector\r\n        ) {\r\n            return _ammGovernanceService;\r\n        } else if (sig == IAmmOpenSwapLens.getAmmOpenSwapServicePoolConfiguration.selector) {\r\n            return _ammOpenSwapService;\r\n        } else if (\r\n            sig == IAmmSwapsLens.getSwaps.selector ||\r\n            sig == IAmmSwapsLens.getPnlPayFixed.selector ||\r\n            sig == IAmmSwapsLens.getPnlReceiveFixed.selector ||\r\n            sig == IAmmSwapsLens.getBalancesForOpenSwap.selector ||\r\n            sig == IAmmSwapsLens.getSoap.selector ||\r\n            sig == IAmmSwapsLens.getOpenSwapRiskIndicators.selector ||\r\n            sig == IAmmSwapsLens.getOfferedRate.selector ||\r\n            sig == IAmmSwapsLens.getSwapLensPoolConfiguration.selector\r\n        ) {\r\n            return _ammSwapsLens;\r\n        } else if (\r\n            sig == IAmmPoolsLens.getAmmPoolsLensConfiguration.selector ||\r\n            sig == IAmmPoolsLens.getIpTokenExchangeRate.selector ||\r\n            sig == IAmmPoolsLens.getAmmBalance.selector\r\n        ) {\r\n            return _ammPoolsLens;\r\n        } else if (\r\n            sig == IAssetManagementLens.balanceOfAmmTreasuryInAssetManagement.selector ||\r\n            sig == IAssetManagementLens.getAssetManagementConfiguration.selector\r\n        ) {\r\n            return _assetManagementLens;\r\n        } else if (\r\n            sig == ILiquidityMiningLens.balanceOfLpTokensStakedInLiquidityMining.selector ||\r\n            sig == ILiquidityMiningLens.balanceOfPowerTokensDelegatedToLiquidityMining.selector ||\r\n            sig == ILiquidityMiningLens.getAccruedRewardsInLiquidityMining.selector ||\r\n            sig == ILiquidityMiningLens.getAccountIndicatorsFromLiquidityMining.selector ||\r\n            sig == ILiquidityMiningLens.getGlobalIndicatorsFromLiquidityMining.selector ||\r\n            sig == ILiquidityMiningLens.getAccountRewardsInLiquidityMining.selector\r\n        ) {\r\n            return _liquidityMiningLens;\r\n        } else if (\r\n            sig == IPowerTokenLens.totalSupplyOfPwToken.selector ||\r\n            sig == IPowerTokenLens.balanceOfPwToken.selector ||\r\n            sig == IPowerTokenLens.balanceOfPwTokenDelegatedToLiquidityMining.selector ||\r\n            sig == IPowerTokenLens.getPwTokensInCooldown.selector ||\r\n            sig == IPowerTokenLens.getPwTokenUnstakeFee.selector ||\r\n            sig == IPowerTokenLens.getPwTokenCooldownTime.selector ||\r\n            sig == IPowerTokenLens.getPwTokenExchangeRate.selector ||\r\n            sig == IPowerTokenLens.getPwTokenTotalSupplyBase.selector\r\n        ) {\r\n            return _powerTokenLens;\r\n        } else if (\r\n            sig == IAmmCloseSwapLens.getAmmCloseSwapServicePoolConfiguration.selector ||\r\n            sig == IAmmCloseSwapLens.getClosingSwapDetails.selector\r\n        ) {\r\n            return _ammCloseSwapService;\r\n        } else if (sig == IAmmPoolsLensEth.getIpstEthExchangeRate.selector) {\r\n            return _ammPoolsLensEth;\r\n        } else if (sig == IAmmPoolsService.getAmmPoolServiceConfiguration.selector) {\r\n            return _ammPoolsService;\r\n        }\r\n\r\n        revert(IporErrors.ROUTER_INVALID_SIGNATURE);\r\n    }\r\n\r\n    /// @dev Delegates the current call to `implementation`.\r\n    /// This function does not return to its internal call site, it will return directly to the external caller.\r\n    function _delegate(address implementation) private {\r\n        bytes memory result;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n        }\r\n\r\n        _returnBackRemainingEth();\r\n        _nonReentrantAfter();\r\n\r\n        assembly {\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    function _returnBackRemainingEth() private {\r\n        uint256 routerEthBalance = address(this).balance;\r\n\r\n        if (routerEthBalance > 0) {\r\n            (bool success, ) = msg.sender.call{value: routerEthBalance}(\"\");\r\n\r\n            if (!success) {\r\n                revert(IporErrors.ROUTER_RETURN_BACK_ETH_FAILED);\r\n            }\r\n        }\r\n    }\r\n\r\n    //solhint-disable no-empty-blocks\r\n    function _authorizeUpgrade(address) internal view override onlyOwner {}\r\n}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"ammSwapsLens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsLens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetManagementLens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammOpenSwapService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammCloseSwapService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammGovernanceService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityMiningLens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"powerTokenLens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"flowService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakeService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsServiceEth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsLensEth\",\"type\":\"address\"}],\"internalType\":\"struct IporProtocolRouter.DeployedContracts\",\"name\":\"deployedContracts\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"appointedOwner\",\"type\":\"address\"}],\"name\":\"AppointedToTransferOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"guardians\",\"type\":\"address[]\"}],\"name\":\"PauseGuardiansAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"guardians\",\"type\":\"address[]\"}],\"name\":\"PauseGuardiansRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_ammCloseSwapService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ammGovernanceService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ammOpenSwapService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ammPoolsLens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ammPoolsLensEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ammPoolsService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ammPoolsServiceEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ammSwapsLens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_assetManagementLens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_flowService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquidityMiningLens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_powerTokenLens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_stakeService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"guardians\",\"type\":\"address[]\"}],\"name\":\"addPauseGuardians\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"appointedOwner\",\"type\":\"address\"}],\"name\":\"appointToOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"calls\",\"type\":\"bytes[]\"}],\"name\":\"batchExecutor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmAppointmentToOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfiguration\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"ammSwapsLens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsLens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"assetManagementLens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammOpenSwapService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammCloseSwapService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammGovernanceService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityMiningLens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"powerTokenLens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"flowService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakeService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsServiceEth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammPoolsLensEth\",\"type\":\"address\"}],\"internalType\":\"struct IporProtocolRouter.DeployedContracts\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauseGuardian\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"functionSigs\",\"type\":\"bytes4[]\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSig\",\"type\":\"bytes4\"}],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"guardians\",\"type\":\"address[]\"}],\"name\":\"removePauseGuardians\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"functionSigs\",\"type\":\"bytes4[]\"}],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "IporProtocolRouter", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08000000000000000000000000550979a2a37ec9fb50e7b360eb70feae488a5f08", "EVMVersion": "paris", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://67cc3e8335797fabdd5330df2edc4a75f74144c75884adca80502992030e4f48"}