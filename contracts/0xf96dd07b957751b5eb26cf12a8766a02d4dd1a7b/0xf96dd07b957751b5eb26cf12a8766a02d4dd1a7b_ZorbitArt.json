{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/library/ColorLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\n/**\\n////////////////////////////////////////////////////////////////////\\n//   modified zorb color library\\n//   originally created by the wonderful folks at zora\\n//   love, ripe\\n////////////////////////////////////////////////////////////////////\\n*/\\n\\n/**\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BBB#RROOOOOOOOOOOOOOORR#BBB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BBROOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZOORBB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BB#ROOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZORB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B#ROOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZORB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BRROOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@BBRRROOOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZO#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@B#RRRRROOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZRB@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@B#RRRRRROOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOB@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@B#RRRRRRRROOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOB@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@B#RRRRRRRROOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZRB@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@B###RRRRRRRROOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ#@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@BB####RRRRRRRROOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZO@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@BB#####RRRRRRRROOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOB@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@BB######RRRRRRRROOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZO#@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@BBB######RRRRRRRROOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZO#@@@@@@@@@@@@@@\\n@@@@@@@@@@@BBBBB#####RRRRRRRROOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZR@@@@@@@@@@@@@\\n@@@@@@@@@@BBBBBB#####RRRRRRRROOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZO#@@@@@@@@@@@@\\n@@@@@@@@@BBBBBBB#####RRRRRRRRROOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOB@@@@@@@@@@@\\n@@@@@@@@BBBBBBBB######RRRRRRRROOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOOB@@@@@@@@@@\\n@@@@@@@@BBBBBBBBB#####RRRRRRRRROOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOR@@@@@@@@@@\\n@@@@@@@BBBBBBBBBB######RRRRRRRROOOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOOOB@@@@@@@@@\\n@@@@@@@BBBBBBBBBBB#####RRRRRRRRROOOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOOOOOR@@@@@@@@@\\n@@@@@@@BBBBBBBBBBB######RRRRRRRRROOOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOOOOOOOB@@@@@@@@\\n@@@@@@BBBBBBBBBBBBB######RRRRRRRRROOOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOOOOOOOOB@@@@@@@@\\n@@@@@@BBBBBBBBBBBBBB######RRRRRRRRROOOOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOOOOOOOOOO#@@@@@@@@\\n@@@@@@BBBBBBBBBBBBBBB######RRRRRRRRROOOOOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOOOOOOOOOOOO#@@@@@@@@\\n@@@@@@BBBBBBBBBBBBBBB######RRRRRRRRRROOOOOOOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOOOOOOOOOOOOOOR@@@@@@@@\\n@@@@@@BBBBBBBBBBBBBBBB#######RRRRRRRRRROOOOOOOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOOOOOOOOOOOOOOOOO#@@@@@@@@\\n@@@@@@BBBBBBBBBBBBBBBBB#######RRRRRRRRRROOOOOOOOOOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZOOOOOOOOOOOOOOOOOOOO#@@@@@@@@\\n@@@@@@BBBBBBBBBBBBBBBBBBB######RRRRRRRRRRROOOOOOOOOOOOOOOOOOOOOOOOOOZZZZZZZZZZZZZZZZZZZZOOOOOOOOOOOOOOOOOOOOOOOOORB@@@@@@@@\\n@@@@@@BBBBBBBBBBBBBBBBBBBB#######RRRRRRRRRRROOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOORB@@@@@@@@\\n@@@@@@@BBBBBBBBBBBBBBBBBBBBB#######RRRRRRRRRRROOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOORRRR@@@@@@@@@\\n@@@@@@@BBBBBBBBBBBBBBBBBBBBBB########RRRRRRRRRRRROOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOORRRRRB@@@@@@@@@\\n@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBB########RRRRRRRRRRRRROOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOORRRRRRR#@@@@@@@@@@\\n@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBB########RRRRRRRRRRRRRROOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOORRRRRRRRRRB@@@@@@@@@@\\n@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBB########RRRRRRRRRRRRRRRRROOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOORRRRRRRRRRRRRRB@@@@@@@@@@@\\n@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBB#########RRRRRRRRRRRRRRRRRRROOOOOOOOOOOOOOOOOOOOOOOOOORRRRRRRRRRRRRRRRRR##@@@@@@@@@@@@\\n@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBB#########RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR###B@@@@@@@@@@@@\\n@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB###########RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR######B@@@@@@@@@@@@@\\n@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB#############RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR########BB@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB###############RRRRRRRRRRRRRRRRRRRRRRRRRRR#############BB@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB#################################################BBB@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB#######################################BBBBBBB@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB########################BBBBBBBBBBBBB@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BBBBBBBBBBBBBBBBBBBBBBBBBBBB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n*/\\n\\n/// Color lib is a custom library for handling the math functions required to generate the gradient step colors\\n/// Originally written in javascript, this is a solidity port.\\nlibrary ColorLib {\\n    using Strings for string;\\n    struct HSL {\\n        uint256 h;\\n        uint256 s;\\n        uint256 l;\\n    }\\n\\n    /// Lookup table for cubicinout range 0-99\\n    function cubicInOut(uint16 p) internal pure returns (int256) {\\n        if (p < 13) {\\n            return 0;\\n        }\\n        if (p < 17) {\\n            return 1;\\n        }\\n        if (p < 19) {\\n            return 2;\\n        }\\n        if (p < 21) {\\n            return 3;\\n        }\\n        if (p < 23) {\\n            return 4;\\n        }\\n        if (p < 24) {\\n            return 5;\\n        }\\n        if (p < 25) {\\n            return 6;\\n        }\\n        if (p < 27) {\\n            return 7;\\n        }\\n        if (p < 28) {\\n            return 8;\\n        }\\n        if (p < 29) {\\n            return 9;\\n        }\\n        if (p < 30) {\\n            return 10;\\n        }\\n        if (p < 31) {\\n            return 11;\\n        }\\n        if (p < 32) {\\n            return 13;\\n        }\\n        if (p < 33) {\\n            return 14;\\n        }\\n        if (p < 34) {\\n            return 15;\\n        }\\n        if (p < 35) {\\n            return 17;\\n        }\\n        if (p < 36) {\\n            return 18;\\n        }\\n        if (p < 37) {\\n            return 20;\\n        }\\n        if (p < 38) {\\n            return 21;\\n        }\\n        if (p < 39) {\\n            return 23;\\n        }\\n        if (p < 40) {\\n            return 25;\\n        }\\n        if (p < 41) {\\n            return 27;\\n        }\\n        if (p < 42) {\\n            return 29;\\n        }\\n        if (p < 43) {\\n            return 31;\\n        }\\n        if (p < 44) {\\n            return 34;\\n        }\\n        if (p < 45) {\\n            return 36;\\n        }\\n        if (p < 46) {\\n            return 38;\\n        }\\n        if (p < 47) {\\n            return 41;\\n        }\\n        if (p < 48) {\\n            return 44;\\n        }\\n        if (p < 49) {\\n            return 47;\\n        }\\n        if (p < 50) {\\n            return 50;\\n        }\\n        if (p < 51) {\\n            return 52;\\n        }\\n        if (p < 52) {\\n            return 55;\\n        }\\n        if (p < 53) {\\n            return 58;\\n        }\\n        if (p < 54) {\\n            return 61;\\n        }\\n        if (p < 55) {\\n            return 63;\\n        }\\n        if (p < 56) {\\n            return 65;\\n        }\\n        if (p < 57) {\\n            return 68;\\n        }\\n        if (p < 58) {\\n            return 70;\\n        }\\n        if (p < 59) {\\n            return 72;\\n        }\\n        if (p < 60) {\\n            return 74;\\n        }\\n        if (p < 61) {\\n            return 76;\\n        }\\n        if (p < 62) {\\n            return 78;\\n        }\\n        if (p < 63) {\\n            return 79;\\n        }\\n        if (p < 64) {\\n            return 81;\\n        }\\n        if (p < 65) {\\n            return 82;\\n        }\\n        if (p < 66) {\\n            return 84;\\n        }\\n        if (p < 67) {\\n            return 85;\\n        }\\n        if (p < 68) {\\n            return 86;\\n        }\\n        if (p < 69) {\\n            return 88;\\n        }\\n        if (p < 70) {\\n            return 89;\\n        }\\n        if (p < 71) {\\n            return 90;\\n        }\\n        if (p < 72) {\\n            return 91;\\n        }\\n        if (p < 74) {\\n            return 92;\\n        }\\n        if (p < 75) {\\n            return 93;\\n        }\\n        if (p < 76) {\\n            return 94;\\n        }\\n        if (p < 78) {\\n            return 95;\\n        }\\n        if (p < 80) {\\n            return 96;\\n        }\\n        if (p < 82) {\\n            return 97;\\n        }\\n        if (p < 86) {\\n            return 98;\\n        }\\n        return 99;\\n    }\\n\\n    /// Lookup table for cubicid range 0-99\\n    function cubicIn(uint256 p) internal pure returns (uint8) {\\n        if (p < 22) {\\n            return 0;\\n        }\\n        if (p < 28) {\\n            return 1;\\n        }\\n        if (p < 32) {\\n            return 2;\\n        }\\n        if (p < 32) {\\n            return 3;\\n        }\\n        if (p < 34) {\\n            return 3;\\n        }\\n        if (p < 36) {\\n            return 4;\\n        }\\n        if (p < 39) {\\n            return 5;\\n        }\\n        if (p < 41) {\\n            return 6;\\n        }\\n        if (p < 43) {\\n            return 7;\\n        }\\n        if (p < 46) {\\n            return 9;\\n        }\\n        if (p < 47) {\\n            return 10;\\n        }\\n        if (p < 49) {\\n            return 11;\\n        }\\n        if (p < 50) {\\n            return 12;\\n        }\\n        if (p < 51) {\\n            return 13;\\n        }\\n        if (p < 53) {\\n            return 14;\\n        }\\n        if (p < 54) {\\n            return 15;\\n        }\\n        if (p < 55) {\\n            return 16;\\n        }\\n        if (p < 56) {\\n            return 17;\\n        }\\n        if (p < 57) {\\n            return 18;\\n        }\\n        if (p < 58) {\\n            return 19;\\n        }\\n        if (p < 59) {\\n            return 20;\\n        }\\n        if (p < 60) {\\n            return 21;\\n        }\\n        if (p < 61) {\\n            return 22;\\n        }\\n        if (p < 62) {\\n            return 23;\\n        }\\n        if (p < 63) {\\n            return 25;\\n        }\\n        if (p < 64) {\\n            return 26;\\n        }\\n        if (p < 65) {\\n            return 27;\\n        }\\n        if (p < 66) {\\n            return 28;\\n        }\\n        if (p < 67) {\\n            return 30;\\n        }\\n        if (p < 68) {\\n            return 31;\\n        }\\n        if (p < 69) {\\n            return 32;\\n        }\\n        if (p < 70) {\\n            return 34;\\n        }\\n        if (p < 71) {\\n            return 35;\\n        }\\n        if (p < 72) {\\n            return 37;\\n        }\\n        if (p < 73) {\\n            return 38;\\n        }\\n        if (p < 74) {\\n            return 40;\\n        }\\n        if (p < 75) {\\n            return 42;\\n        }\\n        if (p < 76) {\\n            return 43;\\n        }\\n        if (p < 77) {\\n            return 45;\\n        }\\n        if (p < 78) {\\n            return 47;\\n        }\\n        if (p < 79) {\\n            return 49;\\n        }\\n        if (p < 80) {\\n            return 51;\\n        }\\n        if (p < 81) {\\n            return 53;\\n        }\\n        if (p < 82) {\\n            return 55;\\n        }\\n        if (p < 83) {\\n            return 57;\\n        }\\n        if (p < 84) {\\n            return 59;\\n        }\\n        if (p < 85) {\\n            return 61;\\n        }\\n        if (p < 86) {\\n            return 63;\\n        }\\n        if (p < 87) {\\n            return 65;\\n        }\\n        if (p < 88) {\\n            return 68;\\n        }\\n        if (p < 89) {\\n            return 70;\\n        }\\n        if (p < 90) {\\n            return 72;\\n        }\\n        if (p < 91) {\\n            return 75;\\n        }\\n        if (p < 92) {\\n            return 77;\\n        }\\n        if (p < 93) {\\n            return 80;\\n        }\\n        if (p < 94) {\\n            return 83;\\n        }\\n        if (p < 95) {\\n            return 85;\\n        }\\n        if (p < 96) {\\n            return 88;\\n        }\\n        if (p < 97) {\\n            return 91;\\n        }\\n        if (p < 98) {\\n            return 94;\\n        }\\n        return 97;\\n    }\\n\\n    /// Lookup table for quintin range 0-99\\n    function quintIn(uint256 p) internal pure returns (uint8) {\\n        if (p < 39) {\\n            return 0;\\n        }\\n        if (p < 45) {\\n            return 1;\\n        }\\n        if (p < 49) {\\n            return 2;\\n        }\\n        if (p < 52) {\\n            return 3;\\n        }\\n        if (p < 53) {\\n            return 4;\\n        }\\n        if (p < 54) {\\n            return 4;\\n        }\\n        if (p < 55) {\\n            return 5;\\n        }\\n        if (p < 56) {\\n            return 5;\\n        }\\n        if (p < 57) {\\n            return 6;\\n        }\\n        if (p < 58) {\\n            return 6;\\n        }\\n        if (p < 59) {\\n            return 7;\\n        }\\n        if (p < 60) {\\n            return 7;\\n        }\\n        if (p < 61) {\\n            return 8;\\n        }\\n        if (p < 62) {\\n            return 9;\\n        }\\n        if (p < 63) {\\n            return 9;\\n        }\\n        if (p < 64) {\\n            return 10;\\n        }\\n        if (p < 65) {\\n            return 11;\\n        }\\n        if (p < 66) {\\n            return 12;\\n        }\\n        if (p < 67) {\\n            return 13;\\n        }\\n        if (p < 68) {\\n            return 14;\\n        }\\n        if (p < 69) {\\n            return 15;\\n        }\\n        if (p < 70) {\\n            return 16;\\n        }\\n        if (p < 71) {\\n            return 18;\\n        }\\n        if (p < 72) {\\n            return 19;\\n        }\\n        if (p < 73) {\\n            return 20;\\n        }\\n        if (p < 74) {\\n            return 22;\\n        }\\n        if (p < 75) {\\n            return 23;\\n        }\\n        if (p < 76) {\\n            return 25;\\n        }\\n        if (p < 77) {\\n            return 27;\\n        }\\n        if (p < 78) {\\n            return 28;\\n        }\\n        if (p < 79) {\\n            return 30;\\n        }\\n        if (p < 80) {\\n            return 32;\\n        }\\n        if (p < 81) {\\n            return 34;\\n        }\\n        if (p < 82) {\\n            return 37;\\n        }\\n        if (p < 83) {\\n            return 39;\\n        }\\n        if (p < 84) {\\n            return 41;\\n        }\\n        if (p < 85) {\\n            return 44;\\n        }\\n        if (p < 86) {\\n            return 47;\\n        }\\n        if (p < 87) {\\n            return 49;\\n        }\\n        if (p < 88) {\\n            return 52;\\n        }\\n        if (p < 89) {\\n            return 55;\\n        }\\n        if (p < 90) {\\n            return 59;\\n        }\\n        if (p < 91) {\\n            return 62;\\n        }\\n        if (p < 92) {\\n            return 65;\\n        }\\n        if (p < 93) {\\n            return 69;\\n        }\\n        if (p < 94) {\\n            return 73;\\n        }\\n        if (p < 95) {\\n            return 77;\\n        }\\n        if (p < 96) {\\n            return 81;\\n        }\\n        if (p < 97) {\\n            return 85;\\n        }\\n        if (p < 98) {\\n            return 90;\\n        }\\n        return 95;\\n    }\\n\\n    // Util for keeping hue range in 0-360 positive\\n    function clampHue(int256 h) internal pure returns (uint256) {\\n        unchecked {\\n            h /= 100;\\n            if (h >= 0) {\\n                return uint256(h) % 360;\\n            } else {\\n                return (uint256(-1 * h) % 360);\\n            }\\n        }\\n    }\\n\\n    /// find hue within range\\n    function lerpHue(\\n        uint8 optionNum,\\n        uint256 direction,\\n        uint256 uhue,\\n        uint8 pct\\n    ) internal pure returns (uint256) {\\n        // unchecked {\\n        uint256 option = optionNum % 4;\\n        int256 hue = int256(uhue);\\n        if (option == 0) {\\n            return\\n                clampHue(\\n                    (((100 - int256(uint256(pct))) * hue) +\\n                        (int256(uint256(pct)) *\\n                            (direction == 0 ? hue - 0 : hue + 10)))\\n                );\\n        }\\n        if (option == 1) {\\n            return\\n                clampHue(\\n                    (((100 - int256(uint256(pct))) * hue) +\\n                        (int256(uint256(pct)) *\\n                            (direction == 0 ? hue - 30 : hue + 30)))\\n                );\\n        }\\n        if (option == 2) {\\n            return\\n                clampHue(\\n                    (\\n                        (((100 - cubicInOut(pct)) * hue) +\\n                            (cubicInOut(pct) *\\n                                (direction == 0 ? hue - 50 : hue + 50)))\\n                    )\\n                );\\n        }\\n\\n        return\\n            clampHue(\\n                ((100 - cubicInOut(pct)) * hue) +\\n                    (cubicInOut(pct) *\\n                        int256(\\n                            hue +\\n                                ((direction == 0 ? int256(-60) : int256(60)) *\\n                                    int256(uint256(optionNum > 128 ? 1 : 0))) +\\n                                30\\n                        ))\\n            );\\n    }\\n\\n    /// find lightness within range\\n    function lerpLightness(\\n        uint8 optionNum,\\n        uint256 start,\\n        uint256 end,\\n        uint256 pct\\n    ) internal pure returns (uint256) {\\n        uint256 lerpPercent;\\n        if (optionNum == 0) {\\n            lerpPercent = quintIn(pct);\\n        } else {\\n            lerpPercent = cubicIn(pct);\\n        }\\n        return\\n            1 + (((100.0 - lerpPercent) * start + (lerpPercent * end)) / 100);\\n    }\\n\\n    /// find saturation within range\\n    function lerpSaturation(\\n        uint8 optionNum,\\n        uint256 start,\\n        uint256 end,\\n        uint256 pct\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 lerpPercent;\\n            if (optionNum == 0) {\\n                lerpPercent = quintIn(pct);\\n                return\\n                    1 +\\n                    (((100.0 - lerpPercent) * start + lerpPercent * end) / 100);\\n            }\\n            lerpPercent = pct;\\n            return ((100.0 - lerpPercent) * start + lerpPercent * end) / 100;\\n        }\\n    }\\n\\n    /// encode a color string\\n    function encodeStr(\\n        uint256 h,\\n        uint256 s,\\n        uint256 l\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                \\\"hsl(\\\",\\n                Strings.toString(h),\\n                \\\", \\\",\\n                Strings.toString(s),\\n                \\\"%, \\\",\\n                Strings.toString(l),\\n                \\\"%)\\\"\\n            );\\n    }\\n\\n    function gradientForZero() internal pure returns (bytes[4] memory) {\\n        return [\\n            encodeStr(0, 0, 4),\\n            encodeStr(0, 0, 7),\\n            encodeStr(0, 0, 12),\\n            encodeStr(0, 0, 15)\\n        ];\\n    }\\n\\n    /// get gradient color strings for the given addresss\\n    function gradientForAddress(\\n        address addr\\n    ) internal pure returns (bytes[4] memory) {\\n        unchecked {\\n            if (addr == address(0)) {\\n                return gradientForZero();\\n            }\\n            uint256 addrInt = uint256(uint160(addr));\\n            bytes32 addrBytes = bytes32(uint256(uint160(addr)));\\n            uint256 startHue = (uint256(uint8(addrBytes[31 - 12])) *\\n                (addrInt % 24)) / 17; // 255 - 360\\n            uint256 endLightness = 97;\\n            endLightness += (((uint256(uint8(addrBytes[31 - 8])) * 5) / 51) +\\n                72); // 72-97\\n            endLightness /= 2;\\n\\n            uint256 startSaturation = uint256(uint8(addrBytes[31 - 7])) /\\n                16 +\\n                81; // 0-16 + 72\\n\\n            uint256 endSaturation = uint256(uint8(addrBytes[31 - 10]) * 11) /\\n                128 +\\n                70; // 0-22 + 70\\n            if (endSaturation > startSaturation - 10) {\\n                endSaturation = startSaturation - 10;\\n            }\\n            uint256 hueRange = uint8(addrBytes[31 - 3]) % 100;\\n            return [\\n                // 4 - darkest\\n                encodeStr(\\n                    lerpHue(\\n                        uint8(addrBytes[31 - 3]) % 4,\\n                        uint8(addrBytes[31 - 6]) % 2,\\n                        startHue + (uint8(addrBytes[31 - 1]) % hueRange),\\n                        uint8(addrInt % 70)\\n                    ),\\n                    lerpSaturation(\\n                        uint8(addrBytes[31 - 3]) % 2,\\n                        42,\\n                        70,\\n                        ((startHue * 7) % 100)\\n                    ),\\n                    lerpLightness(\\n                        uint8(addrBytes[31 - 5]) % 2,\\n                        10,\\n                        20,\\n                        (startHue % 100)\\n                    )\\n                ),\\n                // 2\\n                encodeStr(\\n                    lerpHue(\\n                        uint8(addrBytes[31 - 3]) % 4,\\n                        uint8(addrBytes[31 - 6]) % 2,\\n                        startHue + (uint8(addrBytes[31 - 5]) % hueRange),\\n                        uint8(addrInt % 80)\\n                    ),\\n                    lerpSaturation(\\n                        uint8(addrBytes[31 - 3]) % 2,\\n                        50,\\n                        75,\\n                        ((startHue * 3) % 100)\\n                    ),\\n                    lerpLightness(\\n                        uint8(addrBytes[31 - 5]) % 2,\\n                        20,\\n                        30,\\n                        (startHue % 100)\\n                    )\\n                ),\\n                // 1\\n                encodeStr(\\n                    lerpHue(\\n                        uint8(addrBytes[31 - 3]) % 4,\\n                        uint8(addrBytes[31 - 6]) % 2,\\n                        startHue + (uint8(addrBytes[31 - 11]) % hueRange),\\n                        uint8(addrInt % 90)\\n                    ),\\n                    lerpSaturation(\\n                        uint8(addrBytes[31 - 3]) % 2,\\n                        50,\\n                        80,\\n                        ((startHue * 3) % 100)\\n                    ),\\n                    lerpLightness(\\n                        uint8(addrBytes[31 - 5]) % 2,\\n                        35,\\n                        50,\\n                        (startHue % 100)\\n                    )\\n                ),\\n                // BRIGHTEST\\n                encodeStr(\\n                    lerpHue(\\n                        uint8(addrBytes[31 - 3]) % 4,\\n                        uint8(addrBytes[31 - 6]) % 2,\\n                        startHue + (uint8(addrBytes[31 - 16]) % hueRange),\\n                        uint8(addrInt % 100)\\n                    ),\\n                    lerpSaturation(\\n                        uint8(addrBytes[31 - 3]) % 2,\\n                        80,\\n                        100,\\n                        ((startHue * 3) % 100)\\n                    ),\\n                    lerpLightness(\\n                        uint8(addrBytes[31 - 5]) % 2,\\n                        60,\\n                        80,\\n                        (startHue % 100)\\n                    )\\n                )\\n            ];\\n        }\\n    }\\n\\n    function gradientForHash(\\n        bytes32 addr\\n    ) internal pure returns (bytes[4] memory) {\\n        unchecked {\\n            if (addr == bytes32(0)) {\\n                return gradientForZero();\\n            }\\n            uint256 addrInt = uint256(\\n                bytes32(keccak256(abi.encodePacked(addr)))\\n            );\\n            bytes32 addrBytes = addr;\\n            uint256 startHue = (uint256(uint8(addrBytes[31 - 12])) *\\n                (addrInt % 24)) / 17; // 255 - 360\\n            uint256 endLightness = 97;\\n            endLightness += (((uint256(uint8(addrBytes[31 - 8])) * 5) / 51) +\\n                72); // 72-97\\n            endLightness /= 2;\\n\\n            uint256 startSaturation = uint256(uint8(addrBytes[31 - 7])) /\\n                16 +\\n                81; // 0-16 + 72\\n\\n            uint256 endSaturation = uint256(uint8(addrBytes[31 - 10]) * 11) /\\n                128 +\\n                70; // 0-22 + 70\\n            if (endSaturation > startSaturation - 10) {\\n                endSaturation = startSaturation - 10;\\n            }\\n\\n            uint256 hueRange = (uint8(addrBytes[31 - 3]) % 100) + 1;\\n            return [\\n                // 4 - darkest\\n                encodeStr(\\n                    lerpHue(\\n                        uint8(addrBytes[31 - 3]) % 4,\\n                        uint8(addrBytes[31 - 6]) % 2,\\n                        startHue + (uint8(addrBytes[31 - 1]) % hueRange),\\n                        uint8(addrInt % 70)\\n                    ),\\n                    lerpSaturation(\\n                        uint8(addrBytes[31 - 3]) % 2,\\n                        42,\\n                        70,\\n                        ((startHue * 7) % 100)\\n                    ),\\n                    lerpLightness(\\n                        uint8(addrBytes[31 - 5]) % 2,\\n                        10,\\n                        20,\\n                        (startHue % 100)\\n                    )\\n                ),\\n                // 2\\n                encodeStr(\\n                    lerpHue(\\n                        uint8(addrBytes[31 - 3]) % 4,\\n                        uint8(addrBytes[31 - 6]) % 2,\\n                        startHue + (uint8(addrBytes[31 - 5]) % hueRange),\\n                        uint8(addrInt % 80)\\n                    ),\\n                    lerpSaturation(\\n                        uint8(addrBytes[31 - 3]) % 2,\\n                        50,\\n                        75,\\n                        ((startHue * 3) % 100)\\n                    ),\\n                    lerpLightness(\\n                        uint8(addrBytes[31 - 5]) % 2,\\n                        20,\\n                        30,\\n                        (startHue % 100)\\n                    )\\n                ),\\n                // 1\\n                encodeStr(\\n                    lerpHue(\\n                        uint8(addrBytes[31 - 3]) % 4,\\n                        uint8(addrBytes[31 - 6]) % 2,\\n                        startHue + (uint8(addrBytes[31 - 11]) % hueRange),\\n                        uint8(addrInt % 90)\\n                    ),\\n                    lerpSaturation(\\n                        uint8(addrBytes[31 - 3]) % 2,\\n                        50,\\n                        80,\\n                        ((startHue * 3) % 100)\\n                    ),\\n                    lerpLightness(\\n                        uint8(addrBytes[31 - 5]) % 2,\\n                        35,\\n                        50,\\n                        (startHue % 100)\\n                    )\\n                ),\\n                // BRIGHTEST\\n                encodeStr(\\n                    lerpHue(\\n                        uint8(addrBytes[31 - 3]) % 4,\\n                        uint8(addrBytes[31 - 6]) % 2,\\n                        startHue + (uint8(addrBytes[31 - 16]) % hueRange),\\n                        uint8(addrInt % 100)\\n                    ),\\n                    lerpSaturation(\\n                        uint8(addrBytes[31 - 3]) % 2,\\n                        80,\\n                        100,\\n                        ((startHue * 3) % 100)\\n                    ),\\n                    lerpLightness(\\n                        uint8(addrBytes[31 - 5]) % 2,\\n                        60,\\n                        80,\\n                        (startHue % 100)\\n                    )\\n                )\\n            ];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ZorbitArt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./library/ColorLib.sol\\\";\\n\\n/**\\n/////////////////////////////////////////////////////////////\\n//   contract to return simple data used in zorbit art\\n//   love, ripe\\n/////////////////////////////////////////////////////////////\\n@title  zorbit art\\n@author ripe\\n*/\\n\\ncontract ZorbitArt {\\n    // x coords for each rect in a zorbit node\\n    uint8[] xCoords = [\\n        7,\\n        9,\\n        11,\\n        13,\\n        15,\\n        17,\\n        8,\\n        12,\\n        16,\\n        20,\\n        5,\\n        7,\\n        9,\\n        11,\\n        13,\\n        15,\\n        17,\\n        19,\\n        21,\\n        10,\\n        12,\\n        14,\\n        16,\\n        18,\\n        20,\\n        22,\\n        5,\\n        7,\\n        9,\\n        11,\\n        13,\\n        15,\\n        17,\\n        19,\\n        21,\\n        23,\\n        8,\\n        12,\\n        14,\\n        16,\\n        17,\\n        18,\\n        20,\\n        22,\\n        24,\\n        3,\\n        5,\\n        7,\\n        9,\\n        11,\\n        13,\\n        15,\\n        17,\\n        19,\\n        21,\\n        23,\\n        25,\\n        10,\\n        12,\\n        14,\\n        16,\\n        18,\\n        20,\\n        22,\\n        24,\\n        26,\\n        1,\\n        5,\\n        7,\\n        9,\\n        11,\\n        13,\\n        15,\\n        17,\\n        19,\\n        21,\\n        23,\\n        25,\\n        8,\\n        12,\\n        14,\\n        16,\\n        17,\\n        18,\\n        20,\\n        24,\\n        3,\\n        5,\\n        7,\\n        9,\\n        11,\\n        13,\\n        15,\\n        17,\\n        19,\\n        21,\\n        23,\\n        25,\\n        27,\\n        10,\\n        12,\\n        14,\\n        16,\\n        18,\\n        20,\\n        22,\\n        1,\\n        5,\\n        7,\\n        9,\\n        11,\\n        13,\\n        15,\\n        17,\\n        19,\\n        21,\\n        23,\\n        25,\\n        27,\\n        8,\\n        12,\\n        16,\\n        20,\\n        24,\\n        3,\\n        5,\\n        7,\\n        9,\\n        11,\\n        13,\\n        15,\\n        17,\\n        19,\\n        21,\\n        23,\\n        25,\\n        27,\\n        14,\\n        18,\\n        22,\\n        1,\\n        5,\\n        9,\\n        11,\\n        13,\\n        15,\\n        17,\\n        19,\\n        21,\\n        23,\\n        25,\\n        27,\\n        12,\\n        16,\\n        20,\\n        7,\\n        9,\\n        11,\\n        13,\\n        15,\\n        17,\\n        19,\\n        21,\\n        23,\\n        25,\\n        27,\\n        5,\\n        9,\\n        13,\\n        15,\\n        17,\\n        19,\\n        21,\\n        25,\\n        11,\\n        13,\\n        15,\\n        17,\\n        19,\\n        21,\\n        23,\\n        9,\\n        13,\\n        17,\\n        21\\n    ];\\n\\n    // number of rects on each line\\n    uint8[] yLineCounts = [\\n        6,\\n        4,\\n        9,\\n        7,\\n        10,\\n        9,\\n        12,\\n        9,\\n        12,\\n        8,\\n        13,\\n        7,\\n        13,\\n        5,\\n        13,\\n        3,\\n        12,\\n        3,\\n        11,\\n        0,\\n        8,\\n        0,\\n        7,\\n        0,\\n        4\\n    ];\\n\\n    // @notice returns the x and y coords for the zorbit art as two arrays of uint8\\n    function zorbCoords() public view returns (uint8[] memory, uint8[] memory) {\\n        return (xCoords, yLineCounts);\\n    }\\n\\n    // @notice returns an empty zorbit element as a string of rects without animation or colors\\n    // @dev used for nodes where colors are set at the parent level\\n    function emptyZorb() external view returns (string memory) {\\n        string memory rects;\\n        uint8 incrementNumber = 1; // This number will only increment based on the condition\\n        uint8 currentIndex = 1; // This keeps track of the current index in yLineCounts. offset to 1 because the first line is empty\\n        for (uint8 i = 0; i < xCoords.length; i++) {\\n            if (yLineCounts[currentIndex - 1] == 0) {\\n                // If the current index is empty, increment the currentIndex\\n                currentIndex++;\\n            }\\n            string memory rect = string(\\n                abi.encodePacked(\\n                    '<rect width=\\\"1\\\" height=\\\"1\\\" x=\\\"',\\n                    Strings.toString(xCoords[i]),\\n                    '\\\" y=\\\"',\\n                    Strings.toString(currentIndex),\\n                    '\\\" />'\\n                )\\n            );\\n            rects = string(abi.encodePacked(rects, rect));\\n            if ((incrementNumber < yLineCounts[currentIndex - 1])) {\\n                incrementNumber++; // Increment only when the loop index matches the count\\n            } else {\\n                currentIndex++; // Move to the next index in yLineCounts\\n                incrementNumber = 1; // Increment only when the loop index matches the count\\n            }\\n        }\\n        return rects;\\n    }\\n\\n    function colorsForHash(\\n        bytes32 blockHash\\n    ) external pure returns (bytes[4] memory) {\\n        return ColorLib.gradientForHash(blockHash);\\n    }\\n\\n    function colorsForAddress(\\n        address addr\\n    ) external pure returns (bytes[4] memory) {\\n        return ColorLib.gradientForAddress(addr);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"colorsForAddress\",\"outputs\":[{\"internalType\":\"bytes[4]\",\"name\":\"\",\"type\":\"bytes[4]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"}],\"name\":\"colorsForHash\",\"outputs\":[{\"internalType\":\"bytes[4]\",\"name\":\"\",\"type\":\"bytes[4]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emptyZorb\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zorbCoords\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"},{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ZorbitArt", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}