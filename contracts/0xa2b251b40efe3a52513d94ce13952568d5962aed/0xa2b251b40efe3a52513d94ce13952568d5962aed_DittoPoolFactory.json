{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/pool/DittoPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport {IDittoPoolFactory} from \\\"../interface/IDittoPoolFactory.sol\\\";\\nimport {PoolManagerTemplate, PermitterTemplate, PoolTemplate} from \\\"../struct/FactoryTemplates.sol\\\";\\nimport {IDittoPool} from \\\"../interface/IDittoPool.sol\\\";\\nimport {IDittoRouter} from \\\"../interface/IDittoRouter.sol\\\";\\nimport {IPoolManager} from \\\"../interface/IPoolManager.sol\\\";\\nimport {IMetadataGenerator} from \\\"../interface/IMetadataGenerator.sol\\\";\\n\\nimport {LpNft} from \\\"./lpNft/LpNft.sol\\\";\\nimport {OwnerTwoStep} from \\\"../utils/OwnerTwoStep.sol\\\";\\nimport {IPermitter} from \\\"../interface/IPermitter.sol\\\";\\n\\nimport {ReentrancyGuard} from \\\"../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\\\";\\nimport {Clones} from \\\"../../lib/openzeppelin-contracts/contracts/proxy/Clones.sol\\\";\\nimport {IERC721} from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\\\";\\nimport {ERC20} from \\\"../../lib/solmate/src/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"../../lib/solmate/src/utils/SafeTransferLib.sol\\\";\\n\\ncontract DittoPoolFactory is IDittoPoolFactory, OwnerTwoStep, ReentrancyGuard {\\n    using SafeTransferLib for ERC20;\\n    using Clones for address;\\n\\n    ///@dev The protocol fee is a 1e18 based number that is multiplied by the proceeds of a trade to determine the protocol fee\\n    ///@dev Packed tightly with _feeProtocolRecipient\\n    uint96 private _feeProtocol;\\n    uint96 internal constant MAX_PROTOCOL_FEE = 0.1e18;\\n\\n    /// @dev The address that receives the protocol fee\\n    address private _feeProtocolRecipient;\\n\\n    /// @dev The NFT that represents LP positions\\n    LpNft private _lpNft;\\n\\n    ///@dev Implementations of DittoPool that can be cloned to create new pools\\n    address[] private _poolTemplates;\\n\\n    ///@dev Implementations of PoolManager that can be cloned to create new pool managers on pool creation\\n    IPoolManager[] private _poolManagerTemplates;\\n\\n    ///@dev Implementations of Permitter that can be cloned to create new permitter on pool creation\\n    IPermitter[] private _permitterTemplates;\\n\\n    ///@dev The routers that are allowed to interact with pools\\n    mapping(address => bool) private _routers;\\n\\n    // ***************************************************************\\n    // * ========================= EVENTS ========================== *\\n    // ***************************************************************\\n    event DittoPoolFactoryDittoPoolCreated(\\n        PoolTemplate poolTemplate,\\n        address dittoPool,\\n        PoolManagerTemplate poolManagerTemplate,\\n        address poolManager,\\n        PermitterTemplate permitterTemplate,\\n        address permitter,\\n        bytes permitterInitData\\n    );\\n    event DittoPoolFactoryAdminAddedPoolTemplate(address poolTemplate);\\n    event DittoPoolFactoryAdminAddedPoolManagerTemplate(address poolManagerTemplate);\\n    event DittoPoolFactoryAdminAddedPermitterTemplate(address permitterTemplate);\\n    event DittoPoolFactoryAdminAddedRouter(address router);\\n    event DittoPoolFactoryAdminUpdatedLpNft(address lpNft);\\n    event DittoPoolFactoryAdminSetProtocolFeeRecipient(address protocolFeeRecipient);\\n    event DittoPoolFactoryAdminSetProtocolFeeMultiplier(uint96 protocolFeeMultiplier);\\n\\n    // ***************************************************************\\n    // * ========================= ERRORS ========================== *\\n    // ***************************************************************\\n    error DittoPoolFactoryInvalidTemplateIndex(uint256 templateIndex);\\n    error DittoPoolFactoryInvalidProtocolFee();\\n\\n    /**\\n     * @notice Instantiates a new DittoPoolFactory by deploying a new liquidity position NFT, settting state,\\n     *   and adding the initial templates\\n     *\\n     */\\n    constructor(\\n        LpNft lpNft_,\\n        address feeProtocolRecipient_,\\n        uint96 feeProtocol_,\\n        address[] memory poolTemplates_,\\n        IPoolManager[] memory poolManagerTemplates_,\\n        IPermitter[] memory permitterTemplates_\\n    ) {\\n        _setLpNft(lpNft_);\\n        _setProtocolFee(feeProtocol_);\\n        _setProtocolFeeRecipient(feeProtocolRecipient_);\\n        _addPoolTemplates(poolTemplates_);\\n        _addPoolManagerTemplates(poolManagerTemplates_);\\n        _addPermitterTemplates(permitterTemplates_);\\n    }\\n\\n    // ***************************************************************\\n    // * ================== MAIN INTERFACE ========================= *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function createDittoPool(\\n        PoolTemplate memory poolTemplate_,\\n        PoolManagerTemplate calldata poolManagerTemplate_,\\n        PermitterTemplate calldata permitterTemplate_\\n    )\\n        external\\n        nonReentrant\\n        returns (IDittoPool dittoPool, uint256 lpId, IPoolManager poolManager, IPermitter permitter)\\n    {\\n        // STEP 0: CHECK PRECONDITIONS AND CACHE LIQUIDITY PROVIDER\\n        if (poolTemplate_.templateIndex >= _poolTemplates.length) {\\n            revert DittoPoolFactoryInvalidTemplateIndex(poolTemplate_.templateIndex);\\n        }\\n\\n        address liquidityProvider = poolTemplate_.owner;\\n        bytes memory permitterInitData;\\n\\n        // STEP 1: CREATE THE PERMITTER\\n        if (permitterTemplate_.templateIndex < _permitterTemplates.length) {\\n            permitter = IPermitter(address(_permitterTemplates[permitterTemplate_.templateIndex]).clone());\\n            permitterInitData = permitter.initialize(permitterTemplate_.templateInitData);\\n        }\\n\\n        // STEP 2: CREATE THE DITTOPOOL\\n        address templateAddr = _poolTemplates[poolTemplate_.templateIndex];\\n        dittoPool = IDittoPool(templateAddr.clone());\\n\\n        // STEP 3: CREATE THE POOL MANAGER\\n        if (poolManagerTemplate_.templateIndex < _poolManagerTemplates.length) {\\n            poolManager = IPoolManager(address(_poolManagerTemplates[poolManagerTemplate_.templateIndex]).clone());\\n            poolManager.initialize(address(dittoPool), poolManagerTemplate_.templateInitData);\\n            poolTemplate_.owner = address(poolManager);\\n        }\\n\\n        emit DittoPoolFactoryDittoPoolCreated(\\n            poolTemplate_,\\n            address(dittoPool),\\n            poolManagerTemplate_,\\n            address(poolManager),\\n            permitterTemplate_,\\n            address(permitter),\\n            permitterInitData\\n        );\\n\\n        // STEP 4: INITIALIZE DITTOPOOL\\n        dittoPool.initPool(poolTemplate_, templateAddr, _lpNft, permitter);\\n\\n        // STEP 5: REGISTER NEW DITTOPOOL\\n        _lpNft.setApprovedDittoPool(address(dittoPool), IERC721(poolTemplate_.nft));\\n\\n        // STEP 6: ADDLIQUIDITY IF REQUESTED\\n        lpId = _addLiquidityIfRequested(poolTemplate_, permitterTemplate_, dittoPool, liquidityProvider);\\n    }\\n\\n    // ***************************************************************\\n    // * ============== EXTERNAL VIEW FUNCTIONS ===================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function poolTemplates() external view override returns (address[] memory) {\\n        return _poolTemplates;\\n    }\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function poolManagerTemplates() external view override returns (IPoolManager[] memory) {\\n        return _poolManagerTemplates;\\n    }\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function permitterTemplates() external view override returns (IPermitter[] memory) {\\n        return _permitterTemplates;\\n    }\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function isWhitelistedRouter(address router_) external view override returns (bool) {\\n        return _routers[router_];\\n    }\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function protocolFeeRecipient() external view returns (address) {\\n        return _feeProtocolRecipient;\\n    }\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function getProtocolFee() external view returns (uint96) {\\n        return _feeProtocol;\\n    }\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function lpNft() external view returns (LpNft lpNft_) {\\n        return _lpNft;\\n    }\\n\\n    // ***************************************************************\\n    // * ==================== ADMIN FUNCTIONS ====================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function addPoolTemplates(address[] calldata poolTemplates_) external onlyOwner {\\n        _addPoolTemplates(poolTemplates_);\\n    }\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function addPoolManagerTemplates(IPoolManager[] calldata poolManagerTemplates_) external onlyOwner {\\n        _addPoolManagerTemplates(poolManagerTemplates_);\\n    }\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function addPermitterTemplates(IPermitter[] calldata permitterTemplates_) external onlyOwner {\\n        _addPermitterTemplates(permitterTemplates_);\\n    }\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function addRouters(IDittoRouter[] calldata routers_) external onlyOwner {\\n        uint256 routerCount = routers_.length;\\n        for (uint256 i = 0; i < routerCount;) {\\n            address router = address(routers_[i]);\\n            _routers[router] = true;\\n            emit DittoPoolFactoryAdminAddedRouter(router);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function setProtocolFee(uint96 feeProtocol_) external onlyOwner {\\n        _setProtocolFee(feeProtocol_);\\n    }\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function setProtocolFeeRecipient(address feeProtocolRecipient_) external onlyOwner {\\n        _setProtocolFeeRecipient(feeProtocolRecipient_);\\n    }\\n\\n    ///@inheritdoc IDittoPoolFactory\\n    function setLpNft(LpNft lpNft_) external onlyOwner {\\n        _setLpNft(lpNft_);\\n    }\\n\\n    // ***************************************************************\\n    // * ============= PRIVATE HELPER FUNCTIONS ==================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Adds liquidity to the new pool if requested.\\n     *   In a separate function to avoid stack too deep errors\\n     *\\n     * @param poolTemplate_ The pool template\\n     * @param permitterTemplate_ The permitter template\\n     * @param dittoPool_ The DittoPool\\n     * @param liquidityProvider_ The liquidity provider\\n     * @return lpId The lp id\\n     */\\n    function _addLiquidityIfRequested(\\n        PoolTemplate memory poolTemplate_,\\n        PermitterTemplate calldata permitterTemplate_,\\n        IDittoPool dittoPool_,\\n        address liquidityProvider_\\n    ) private returns (uint256 lpId) {\\n        bool areNftsToAdd = poolTemplate_.nftIdList.length != 0;\\n        bool areErc20sToAdd = poolTemplate_.initialTokenBalance != 0;\\n        if (areErc20sToAdd || areNftsToAdd) {\\n            if (areErc20sToAdd) {\\n                ERC20(poolTemplate_.token).safeTransferFrom(\\n                    liquidityProvider_, address(this), poolTemplate_.initialTokenBalance\\n                );\\n                ERC20(poolTemplate_.token).safeApprove(address(dittoPool_), poolTemplate_.initialTokenBalance);\\n            }\\n            if (areNftsToAdd) {\\n                _transferNftsToFactory(IERC721(poolTemplate_.nft), liquidityProvider_, poolTemplate_.nftIdList);\\n                IERC721(poolTemplate_.nft).setApprovalForAll(address(dittoPool_), true);\\n            }\\n\\n            lpId = dittoPool_.createLiquidity(\\n                liquidityProvider_,\\n                poolTemplate_.nftIdList,\\n                poolTemplate_.initialTokenBalance,\\n                permitterTemplate_.liquidityDepositPermissionData,\\n                poolTemplate_.referrer\\n            );\\n\\n            if (areNftsToAdd) {\\n                IERC721(poolTemplate_.nft).setApprovalForAll(address(dittoPool_), false);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice maximum 10%, must <= 1 - MAX_FEE\\n     *\\n     * @param feeProtocol_ proposed protocol fee\\n     */\\n    function _setProtocolFee(uint96 feeProtocol_) private {\\n        if (feeProtocol_ > MAX_PROTOCOL_FEE) {\\n            revert DittoPoolFactoryInvalidProtocolFee();\\n        }\\n        _feeProtocol = feeProtocol_;\\n        emit DittoPoolFactoryAdminSetProtocolFeeMultiplier(feeProtocol_);\\n    }\\n\\n    /**\\n     * @notice Set the protocol fee recipient\\n     *\\n     * @param feeProtocolRecipient_ address of the protocol fee recipient to set\\n     */\\n    function _setProtocolFeeRecipient(address feeProtocolRecipient_) private {\\n        _feeProtocolRecipient = feeProtocolRecipient_;\\n\\n        emit DittoPoolFactoryAdminSetProtocolFeeRecipient(feeProtocolRecipient_);\\n    }\\n\\n    /**\\n     * @notice set the LP NFT collection that represents liquidity created by this factory\\n     * \\n     * @param lpNft_ address of the LP NFT collection\\n     */\\n    function _setLpNft(LpNft lpNft_) private {\\n        _lpNft = lpNft_;\\n\\n        emit DittoPoolFactoryAdminUpdatedLpNft(address(lpNft_));\\n    }\\n\\n    /**\\n     * @notice Transfer the NFTs to the factory, so that it pass them to the pool.\\n     *\\n     * @param nft_ address of the NFT collection\\n     * @param from_ address to transfer from\\n     * @param nftIdList_ array of token IDs for the NFT to transfer\\n     */\\n    function _transferNftsToFactory(IERC721 nft_, address from_, uint256[] memory nftIdList_) private {\\n        uint256 countTokenIds = nftIdList_.length;\\n        uint256 tokenId;\\n        for (uint256 i = 0; i < countTokenIds;) {\\n            tokenId = nftIdList_[i];\\n            nft_.transferFrom(from_, address(this), tokenId);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Adds pool templates to the registry of templates stored on this contract\\n     * @param poolTemplates_ array of addresses of pool templates to add\\n     */\\n    function _addPoolTemplates(address[] memory poolTemplates_) private {\\n        uint256 countPoolTemplates = poolTemplates_.length;\\n        address poolTemplate;\\n        for (uint256 i = 0; i < countPoolTemplates;) {\\n            poolTemplate = poolTemplates_[i];\\n            _poolTemplates.push(poolTemplate);\\n            emit DittoPoolFactoryAdminAddedPoolTemplate(poolTemplate);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Adds pool manager templates to the registry of templates stored on this contract\\n     * @param poolManagerTemplates_ array of addresses of pool manager templates to add\\n     */\\n    function _addPoolManagerTemplates(IPoolManager[] memory poolManagerTemplates_) private {\\n        uint256 countPoolManagerTemplates = poolManagerTemplates_.length;\\n        IPoolManager poolManagerTemplate;\\n        for (uint256 i = 0; i < countPoolManagerTemplates;) {\\n            poolManagerTemplate = poolManagerTemplates_[i];\\n            _poolManagerTemplates.push(poolManagerTemplate);\\n            emit DittoPoolFactoryAdminAddedPoolManagerTemplate(address(poolManagerTemplate));\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Adds permitter templates to the registry of templates stored on this contract\\n     * @param permitterTemplates_ array of addresses of permitter templates to add\\n     */\\n    function _addPermitterTemplates(IPermitter[] memory permitterTemplates_) private {\\n        uint256 countPermitterTemplates = permitterTemplates_.length;\\n        IPermitter permitterTemplate;\\n        for (uint256 i = 0; i < countPermitterTemplates;) {\\n            permitterTemplate = permitterTemplates_[i];\\n            _permitterTemplates.push(permitterTemplate);\\n            emit DittoPoolFactoryAdminAddedPermitterTemplate(address(permitterTemplate));\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IDittoPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { PoolTemplate } from \\\"../struct/FactoryTemplates.sol\\\";\\nimport { LpNft } from \\\"../pool/lpNft/LpNft.sol\\\";\\nimport { IOwnerTwoStep } from \\\"./IOwnerTwoStep.sol\\\";\\nimport { IDittoPool } from \\\"./IDittoPool.sol\\\";\\nimport { IDittoRouter } from \\\"./IDittoRouter.sol\\\";\\nimport { IPermitter } from \\\"./IPermitter.sol\\\";\\nimport { IMetadataGenerator } from \\\"./IMetadataGenerator.sol\\\";\\nimport { IPoolManager } from \\\"./IPoolManager.sol\\\";\\nimport { PoolManagerTemplate, PermitterTemplate } from \\\"../struct/FactoryTemplates.sol\\\";\\n\\ninterface IDittoPoolFactory is IOwnerTwoStep {\\n    // ***************************************************************\\n    // * ====================== MAIN INTERFACE ===================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Create a ditto pool along with a permitter and pool manager if requested. \\n     *\\n     * @param params_ The pool creation parameters including initial liquidity and fee settings\\n     *   **uint256 templateIndex** The index of the pool template to clone\\n     *   **address token** ERC20 token address trading against the nft collection\\n     *   **address nft** the address of the NFT collection that we are creating a pool for\\n     *   **uint96 feeLp** the fee percentage paid to LPers when they are the counterparty in a trade\\n     *   **address owner** The liquidity initial provider and owner of the pool, overwritten by pool manager if present\\n     *   **uint96 feeAdmin** the fee percentage paid to the pool admin \\n     *   **uint128 delta** the delta of the pool, see bonding curve documentation\\n     *   **uint128 basePrice** the base price of the pool, see bonding curve documentation\\n     *   **uint256[] nftIdList** the token IDs of NFTs to deposit into the pool as it is created. Empty arrays are allowed\\n     *   **uint256 initialTokenBalance** the number of ERC20 tokens to transfer to the pool as you create it. Zero is allowed\\n     *   **bytes initialTemplateData** initial data to pass to the pool contract in its initializer\\n     * @param poolManagerTemplate_ The template for the pool manager to manage the pool. Provide type(uint256).max to opt out\\n     * @param permitterTemplate_  The template for the permitter to manage the pool. Provide type(uint256).max to opt out\\n     * @return dittoPool The newly created DittoPool\\n     * @return lpId The ID of the LP position NFT representing the initial liquidity deposited, or zero, if none deposited\\n     * @return poolManager The pool manager or the zero address if none was created\\n     * @return permitter The permitter or the zero address if none was created\\n     */\\n    function createDittoPool(\\n        PoolTemplate memory params_,\\n        PoolManagerTemplate calldata poolManagerTemplate_,\\n        PermitterTemplate calldata permitterTemplate_\\n    )\\n        external\\n        returns (IDittoPool dittoPool, uint256 lpId, IPoolManager poolManager, IPermitter permitter);\\n\\n    // ***************************************************************\\n    // * ============== EXTERNAL VIEW FUNCTIONS ==================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Get the list of pool templates that can be used to create new pools\\n     * @return poolTemplates_ The list of pool templates that can be used to create new pools\\n     */\\n    function poolTemplates() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Get the list of pool manager templates that can be used to manage a new pool\\n     * @return poolManagerTemplates_ The list of pool manager templates that can be used to manage a new pool\\n     */\\n    function poolManagerTemplates() external view returns (IPoolManager[] memory);\\n\\n    /**\\n     * @notice Get the list of permitter templates that can be used to restrict nft ids in a pool\\n     * @return permitterTemplates_ The list of permitter templates that can be used to restrict nft ids in a pool\\n     */\\n    function permitterTemplates() external view returns (IPermitter[] memory);\\n\\n    /**\\n     * @notice Check if an address is an approved whitelisted router that can trade with the pools\\n     * @param potentialRouter_ The address to check if it is a whitelisted router\\n     * @return isWhitelistedRouter True if the address is a whitelisted router\\n     */\\n    function isWhitelistedRouter(address potentialRouter_) external view returns (bool);\\n\\n    /**\\n     * @notice Get the protocol fee recipient address\\n     * @return poolFeeRecipient of the protocol fee recipient\\n     */\\n    function protocolFeeRecipient() external view returns (address);\\n\\n    /**\\n     * @notice Get the protocol fee multiplier used to calculate fees on all trades \\n     * @return protocolFeeMultiplier the multiplier for global protocol fees on all trades\\n     */\\n    function getProtocolFee() external view returns (uint96);\\n\\n    /**\\n     * @notice The nft used to represent liquidity positions\\n     */\\n    function lpNft() external view returns (LpNft lpNft_);\\n\\n    // ***************************************************************\\n    // * ==================== ADMIN FUNCTIONS ====================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Admin function to add additional pool templates \\n     * @param poolTemplates_ addresses of the new pool templates\\n     */\\n    function addPoolTemplates(address[] calldata poolTemplates_) external;\\n\\n    /**\\n     * @notice Admin function to add additional pool manager templates\\n     * @param poolManagerTemplates_ addresses of the new pool manager templates\\n     */\\n    function addPoolManagerTemplates(IPoolManager[] calldata poolManagerTemplates_) external;\\n\\n    /**\\n     * @notice Admin function to add additional permitter templates\\n     * @param permitterTemplates_ addresses of the new permitter templates\\n     */\\n    function addPermitterTemplates(IPermitter[] calldata permitterTemplates_) external;\\n\\n    /**\\n     * @notice Admin function to add additional whitelisted routers\\n     * @param routers_ addresses of the new routers to whitelist\\n     */\\n    function addRouters(IDittoRouter[] calldata routers_) external;\\n\\n    /**\\n     * @notice Admin function to set the protocol fee recipient\\n     * @param feeProtocolRecipient_ address of the new protocol fee recipient\\n     */\\n    function setProtocolFeeRecipient(address feeProtocolRecipient_) external;\\n\\n    /**\\n     * @notice Admin function to set the protocol fee multiplier used to calculate fees on all trades, base 1e18\\n     * @param feeProtocol_ the new protocol fee multiplier\\n     */\\n    function setProtocolFee(uint96 feeProtocol_) external;\\n\\n    /**\\n     * @notice Admin function to change the LP position NFT collection used by this Ditto Pool Factory\\n     * @param lpNft_ address of the new LpNft\\n     */\\n    function setLpNft(LpNft lpNft_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/struct/FactoryTemplates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @notice A struct for creating a DittoSwap pool.\\n */\\nstruct PoolTemplate {\\n    bool isPrivatePool; // whether the pool is private or not\\n    uint256 templateIndex; // which DittoSwap template to use. Must be less than the number of available templates\\n    address token; // ERC20 token address\\n    address nft; // the address of the NFT collection that we are creating a pool for\\n    uint96 feeLp; // set by owner, paid to LPers only when they are the counterparty in a trade\\n    address owner; // owner creating the pool\\n    uint96 feeAdmin; // set by owner, paid to admin fee recipient\\n    uint128 delta; // the delta of the pool, see bonding curve documentation\\n    uint128 basePrice; // the base price of the pool, see bonding curve documentation\\n    uint256[] nftIdList; // the token IDs of NFTs to deposit into the pool\\n    uint256 initialTokenBalance; // the number of ERC20 tokens to transfer to the pool\\n    bytes templateInitData; // initial data to pass to the pool contract in its initializer\\n    bytes referrer; // the address of the referrer\\n}\\n\\n/**\\n * @notice A struct for containing Pool Manager template data.\\n *  \\n * @dev **templateIndex** Which DittoSwap template to use. If templateIndex is set to a value \\n *   larger than the number of templates, no pool manager is created\\n * @dev **templateInitData** initial data to pass to the poolManager contract in its initializer.\\n */\\nstruct PoolManagerTemplate {\\n    uint256 templateIndex;\\n    bytes templateInitData;\\n}\\n\\n/**\\n * @notice A struct for containing Permitter template data.\\n * @dev **templateIndex** Which DittoSwap template to use. If templateIndex is set to a value \\n *   larger than the number of templates, no permitter is created.\\n * @dev **templateInitData** initial data to pass to the permitter contract in its initializer.\\n * @dev **liquidityDepositPermissionData** Deposit data to pass in an all-in-one step to create a pool and deposit liquidity at the same time\\n */\\nstruct PermitterTemplate {\\n    uint256 templateIndex;\\n    bytes templateInitData;\\n    bytes liquidityDepositPermissionData;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IDittoPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { Fee } from \\\"../struct/Fee.sol\\\";\\nimport { SwapNftsForTokensArgs, SwapTokensForNftsArgs } from \\\"../struct/SwapArgs.sol\\\";\\nimport { LpNft } from \\\"../pool/lpNft/LpNft.sol\\\";\\nimport { PoolTemplate } from \\\"../struct/FactoryTemplates.sol\\\";\\nimport { LpIdToTokenBalance } from \\\"../struct/LpIdToTokenBalance.sol\\\";\\nimport { NftCostData } from \\\"../struct/NftCostData.sol\\\";\\nimport { IPermitter } from \\\"../interface/IPermitter.sol\\\";\\n\\nimport { IERC721 } from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\\\";\\nimport { CurveErrorCode } from \\\"../utils/CurveErrorCode.sol\\\";\\n\\nimport { IOwnerTwoStep } from \\\"./IOwnerTwoStep.sol\\\";\\n\\ninterface IDittoPool is IOwnerTwoStep {\\n    // ***************************************************************\\n    // * =============== ADMINISTRATIVE FUNCTIONS ================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice For use in tokenURI function metadata\\n     * @return curve type of curve\\n     */\\n    function bondingCurve() external pure returns (string memory curve);\\n\\n    /**\\n     * @notice Used by the Contract Factory to set the initial state & parameters of the pool.\\n     * @dev Necessarily separate from constructor due to [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167) factory clone paradigm.\\n     * @param params_ A struct that contains various initialization parameters for the pool. See `PoolTemplate.sol` for details.\\n     * @param template_ which address was used to clone business logic for this pool.\\n     * @param lpNft_ The Liquidity Provider Positions NFT contract that tokenizes liquidity provisions in the protocol\\n     * @param permitter_ Contract to authorize which tokenIds from the underlying nft collection are allowed to be traded in this pool.\\n     * @dev Set permitter to address(0) to allow any tokenIds from the underlying NFT collection.\\n     */\\n    function initPool(\\n        PoolTemplate calldata params_,\\n        address template_,\\n        LpNft lpNft_,\\n        IPermitter permitter_\\n    ) external;\\n\\n    /**\\n     * @notice Admin function to change the base price charged to buy an NFT from the pair. Each bonding curve uses this differently.\\n     * @param newBasePrice_ The updated base price\\n     */\\n    function changeBasePrice(uint128 newBasePrice_) external;\\n\\n    /**\\n     * @notice Admin function to change the delta parameter associated with the bonding curve. Each bonding curve uses this differently. \\n     * @param newDelta_ The updated delta\\n     */\\n    function changeDelta(uint128 newDelta_) external;\\n\\n    /**\\n     * @notice Admin function to change the pool lp fee, set by owner, paid to LPers only when they are the counterparty in a trade\\n     * @param newFeeLp_ New fee, in wei / 1e18, charged by the pool for trades with it (i.e. 1% = 0.01e18)\\n     */\\n    function changeLpFee(uint96 newFeeLp_) external;\\n\\n    /**\\n     * @notice Change the pool admin fee, set by owner, paid to an address of the owner's choosing\\n     * @param newFeeAdmin_ New fee, in wei / 1e18, charged by the pool for trades with it (i.e. 1% = 0.01e18)\\n     */\\n    function changeAdminFee(uint96 newFeeAdmin_) external;\\n\\n    /**\\n     * @notice Change who the pool admin fee for this pool is sent to.\\n     * @param newAdminFeeRecipient_ New address to send admin fees to\\n     */\\n    function changeAdminFeeRecipient(address newAdminFeeRecipient_) external;\\n\\n    // ***************************************************************\\n    // * ================== LIQUIDITY FUNCTIONS ==================== *\\n    // ***************************************************************\\n    /**\\n     * @notice Function for liquidity providers to create new Liquidity Positions within the pool by depositing liquidity.\\n     * @dev Provides the liquidity provider with a new liquidity position tracking NFT every time. \\n     * @dev This function assumes that msg.sender is the owner of the NFTs and Tokens.\\n     * @dev This function expects that this contract has permission to move NFTs and tokens to itself from the owner.\\n     * @dev The **lpRecipient_** parameter to this function is intended to allow creating positions on behalf of\\n     * another party. msg.sender can send nfts and tokens to the pool and then have the pool create the liquidity position\\n     * for someone who is not msg.sender. The `DittoPoolFactory` uses this feature to create a new DittoPool and deposit\\n     * liquidity into it in one step. NFTs flow from user -> factory -> pool and then lpRecipient_ is set to the user.\\n     * @dev `lpRecipient_` can steal liquidity deposited by msg.sender if lpRecipient_ is not set to msg.sender.\\n     * @param lpRecipient_ The address that will receive the LP position ownership NFT.\\n     * @param nftIdList_ The list of NFT tokenIds msg.sender wishes to deposit into the pool.\\n     * @param tokenDepositAmount_ The amount of ERC20 tokens msg.sender wishes to deposit into the pool.\\n     * @param permitterData_ Data to check that the NFT Token IDs are permitted to deposited into this pool if a permitter is set.\\n     * @return lpId The tokenId of the LP position NFT that was minted as a result of this liquidity deposit.\\n     */\\n    function createLiquidity(\\n        address lpRecipient_,\\n        uint256[] calldata nftIdList_,\\n        uint256 tokenDepositAmount_,\\n        bytes calldata permitterData_,\\n        bytes calldata referrer_\\n    ) external returns (uint256 lpId);\\n\\n    /**\\n     * @notice Function for market makers / liquidity providers to deposit NFTs and ERC20s into existing LP Positions.\\n     * @dev Anybody may add liquidity to existing LP Positions, regardless of whether they own the position or not.\\n     * @dev This function expects that this contract has permission to move NFTs and tokens to itself from the msg.sender.\\n     * @param lpId_ TokenId of existing LP position to add liquidity to. Does not have to be owned by msg.sender!\\n     * @param nftIdList_ The list of NFT tokenIds msg.sender wishes to deposit into the pool.\\n     * @param tokenDepositAmount_ The amount of ERC20 tokens msg.sender wishes to deposit into the pool.\\n     * @param permitterData_ Data to check that the NFT Token IDs are permitted to deposited into this pool if a permitter is set.\\n     */\\n    function addLiquidity(\\n        uint256 lpId_,\\n        uint256[] calldata nftIdList_,\\n        uint256 tokenDepositAmount_,\\n        bytes calldata permitterData_,\\n        bytes calldata referrer_\\n    ) external;\\n\\n    /**\\n     * @notice Function for liquidity providers to withdraw NFTs and ERC20 tokens from their LP positions.\\n     * @dev Can be called to change an existing liquidity position, or remove an LP position by withdrawing all liquidity.\\n     * @dev May be called by an authorized party (approved on the LP NFT) to withdraw liquidity on behalf of the LP Position owner.\\n     * @param withdrawalAddress_ the address that will receive the ERC20 tokens and NFTs withdrawn from the pool.\\n     * @param lpId_ LP Position TokenID that liquidity is being removed from. Does not have to be owned by msg.sender if the msg.sender is authorized.\\n     * @param nftIdList_ The list of NFT tokenIds msg.sender wishes to withdraw from the pool.\\n     * @param tokenWithdrawAmount_ The amount of ERC20 tokens the msg.sender wishes to withdraw from the pool.\\n     */\\n    function pullLiquidity(\\n        address withdrawalAddress_,\\n        uint256 lpId_,\\n        uint256[] calldata nftIdList_,\\n        uint256 tokenWithdrawAmount_\\n    ) external;\\n\\n    // ***************************************************************\\n    // * =================== TRADE FUNCTIONS ======================= *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Trade ERC20s for a specific list of NFT token ids.\\n     * @dev To compute the amount of token to send, call bondingCurve.getBuyInfo\\n     * This swap is meant for users who want specific IDs. \\n     * \\n     * @param args_ The arguments for the swap. See SwapArgs.sol for parameters\\n     * @return inputAmount The actual amount of tokens spent to purchase the NFTs.\\n     */\\n    function swapTokensForNfts(\\n        SwapTokensForNftsArgs calldata args_\\n    ) external returns (uint256 inputAmount);\\n\\n    /**\\n     * @notice Trade a list of allowed nft ids for ERC20s.\\n     * @dev To compute the amount of token to that will be received, call bondingCurve.getSellInfo.\\n     * @dev Key difference with sudoswap here:\\n     * In sudoswap, each market maker has a separate smart contract with their liquidity.\\n     * To sell to a market maker, you just check if their specific `LSSVMPair` contract has enough money.\\n     * In DittoSwap, we share different market makers' liquidity in the same pool contract.\\n     * So this function has an additional parameter `lpIds` forcing the buyer to check\\n     * off-chain which market maker's LP position that they want to trade with, for each specific NFT\\n     * that they are selling into the pool. The lpIds array should correspond with the nftIds\\n     * array in the same order & indexes. e.g. to sell NFT with tokenId 1337 to the market maker who's\\n     * LP position has id 42, the buyer would call this function with\\n     * nftIds = [1337] and lpIds = [42].\\n     *\\n     * @param args_ The arguments for the swap. See SwapArgs.sol for parameters\\n     * @return outputAmount The amount of token received\\n     */\\n    function swapNftsForTokens(\\n        SwapNftsForTokensArgs calldata args_\\n    ) external returns (uint256 outputAmount);\\n\\n    /**\\n     * @notice Read-only function used to query the bonding curve for buy pricing info.\\n     * @param numNfts The number of NFTs to buy out of the pair\\n     * @param swapData_ Extra data to pass to the curve\\n     * @return error any errors that would be throw if trying to buy that many NFTs\\n     * @return newBasePrice the new base price after the trade\\n     * @return newDelta the new delta after the trade\\n     * @return inputAmount the amount of token to send to the pool to purchase that many NFTs\\n     * @return nftCostData the cost data for each NFT purchased\\n     */\\n    function getBuyNftQuote(uint256 numNfts, bytes calldata swapData_)\\n        external\\n        view\\n        returns (\\n            CurveErrorCode error,\\n            uint256 newBasePrice,\\n            uint256 newDelta,\\n            uint256 inputAmount,\\n            NftCostData[] memory nftCostData\\n        );\\n\\n    /**\\n     * @notice Read-only function used to query the bonding curve for sell pricing info\\n     * @param numNfts The number of NFTs to sell into the pair\\n     * @param swapData_ Extra data to pass to the curve\\n     * @return error any errors that would be throw if trying to sell that many NFTs\\n     * @return newBasePrice the new base price after the trade\\n     * @return newDelta the new delta after the trade\\n     * @return outputAmount the amount of tokens the pool will send out for selling that many NFTs\\n     * @return nftCostData the cost data for each NFT sold\\n     */\\n    function getSellNftQuote(uint256 numNfts, bytes calldata swapData_)\\n        external\\n        view\\n        returns (\\n            CurveErrorCode error,\\n            uint256 newBasePrice,\\n            uint256 newDelta,\\n            uint256 outputAmount,\\n            NftCostData[] memory nftCostData\\n        );\\n\\n    // ***************************************************************\\n    // * ===================== VIEW FUNCTIONS ====================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice returns the status of whether this contract has been initialized\\n     * @dev see [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167) factory clone paradigm\\n     * and also `DittoPoolFactory.sol`\\n     *\\n     * @return initialized whether the contract has been initialized\\n     */\\n    function initialized() external view returns (bool);\\n\\n    /**\\n     * @notice returns which DittoPool Template this pool was created with.\\n     * @dev see [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167) factory clone paradigm\\n     * @return template the address of the DittoPool template used to create this pool.\\n     */\\n    function template() external view returns (address);\\n\\n    /**\\n     * @notice Function to determine if a given DittoPool can support muliple LP providers or not.\\n     * @return isPrivatePool_ boolean value indicating if the pool is private or not\\n     */\\n    function isPrivatePool() external view returns (bool isPrivatePool_);\\n\\n    /**\\n     * @notice Returns the cumulative fee associated with trading with this pool as a 1e18 based percentage.\\n     * @return fee_ the total fee(s) associated with this pool, for display purposes.\\n     */\\n    function fee() external view returns (uint256 fee_);\\n\\n    /**\\n     * @notice Returns the protocol fee associated with trading with this pool as a 1e18 based percentage.\\n     * @return feeProtocol_ the protocol fee associated with trading with this pool\\n     */\\n    function protocolFee() external view returns (uint256 feeProtocol_);\\n\\n    /**\\n     * @notice Returns the admin fee given to the pool admin as a 1e18 based percentage.\\n     * @return adminFee_ the fee associated with trading with any pair of this pool\\n     */\\n    function adminFee() external view returns (uint96 adminFee_);\\n\\n    /**\\n     * @notice Returns the fee given to liquidity providers for trading with this pool.\\n     * @return lpFee_ the fee associated with trading with a particular pair of this pool.\\n     */\\n    function lpFee() external view returns (uint96 lpFee_);\\n\\n    /**\\n     * @notice Returns the delta parameter for the bonding curve associated this pool\\n     * Each bonding curve uses delta differently, but in general it is used as an input\\n     *   to determine the next price on the bonding curve.\\n     * @return delta_ The delta parameter for the bonding curve of this pool\\n     */\\n    function delta() external view returns (uint128 delta_);\\n\\n    /**\\n     * @notice Returns the base price to sell the next NFT into this pool, base+delta to buy\\n     * Each bonding curve uses base price differently, but in general it is used as the current price of the pool.\\n     * @return basePrice_ this pool's current base price\\n     */\\n    function basePrice() external view returns (uint128 basePrice_);\\n\\n    /**\\n     * @notice Returns the factory that created this pool.\\n     * @return dittoPoolFactory the ditto pool factory for the contract\\n     */\\n    function dittoPoolFactory() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address that recieves admin fees from trades with this pool\\n     * @return adminFeeRecipient The admin fee recipient of this pool\\n     */\\n    function adminFeeRecipient() external view returns (address);\\n\\n    /**\\n     * @notice Returns the NFT collection that represents liquidity positions in this pool\\n     * @return lpNft The LP Position NFT collection for this pool\\n     */\\n    function getLpNft() external view returns (address);\\n\\n    /**\\n     * @notice Returns the nft collection that this pool trades \\n     * @return nft_ the address of the underlying nft collection contract\\n     */\\n    function nft() external view returns (IERC721 nft_);\\n\\n    /**\\n     * @notice Returns the address of the ERC20 token that this pool is trading NFTs against.\\n     * @return token_ The address of the ERC20 token that this pool is trading NFTs against.\\n     */\\n    function token() external view returns (address token_);\\n\\n    /**\\n     * @notice Returns the permitter contract that allows or denies specific NFT tokenIds to be traded in this pool\\n     * @dev if this address is zero, then all NFTs from the underlying collection are allowed to be traded in this pool\\n     * @return permitter the address of this pool's permitter contract, or zero if no permitter is set\\n     */\\n    function permitter() external view returns (IPermitter);\\n\\n    /**\\n     * @notice Returns how many ERC20 tokens a liquidity provider has in the pool\\n     * @dev this function mimics mappings: an invalid lpId_ will return 0 rather than throwing for being invalid\\n     * @param lpId_ LP Position NFT token ID to query for\\n     * @return lpTokenBalance the amount of ERC20 tokens the liquidity provider has in the pool\\n     */\\n    function getTokenBalanceForLpId(uint256 lpId_) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the full list of NFT tokenIds that are owned by a specific liquidity provider in this pool\\n     * @dev This function is not gas efficient and not-meant to be used on chain, only as a convenience for off-chain.\\n     * @dev worst-case is O(n) over the length of all the NFTs owned by the pool\\n     * @param lpId_ an LP position NFT token Id for a user providing liquidity to this pool\\n     * @return nftIds the list of NFT tokenIds in this pool that are owned by the specific liquidity provider\\n     */\\n    function getNftIdsForLpId(uint256 lpId_) external view returns (uint256[] memory nftIds);\\n\\n    /**\\n     * @notice returns the number of NFTs owned by a specific liquidity provider in this pool\\n     * @param lpId_ a user providing liquidity to this pool for trading with\\n     * @return userNftCount the number of NFTs in this pool owned by the liquidity provider\\n     */\\n    function getNftCountForLpId(uint256 lpId_) external view returns (uint256);\\n\\n    /**\\n     * @notice returns the number of NFTs and number of ERC20s owned by a specific liquidity provider in this pool\\n     * pretty much equivalent to the user's liquidity position in non-nft form.\\n     * @dev this function mimics mappings: an invalid lpId_ will return (0,0) rather than throwing for being invalid\\n     * @param lpId_ a user providing liquidity to this pool for trading with\\n     * @return tokenBalance the amount of ERC20 tokens the liquidity provider has in the pool\\n     * @return nftBalance the number of NFTs in this pool owned by the liquidity provider\\n     */\\n    function getTotalBalanceForLpId(uint256 lpId_)\\n        external\\n        view\\n        returns (uint256 tokenBalance, uint256 nftBalance);\\n\\n    /**\\n     * @notice returns the Lp Position NFT token Id that owns a specific NFT token Id in this pool\\n     * @dev this function mimics mappings: an invalid NFT token Id will return 0 rather than throwing for being invalid\\n     * @param nftId_ an NFT token Id that is owned by a liquidity provider in this pool\\n     * @return lpId the Lp Position NFT token Id that owns the NFT token Id\\n     */\\n    function getLpIdForNftId(uint256 nftId_) external view returns (uint256);\\n\\n    /**\\n     * @notice returns the full list of all NFT tokenIds that are owned by this pool\\n     * @dev does not have to match what the underlying NFT contract balanceOf(dittoPool)\\n     * thinks is owned by this pool: this is only valid liquidity tradeable in this pool\\n     * NFTs can be lost by unsafe transferring them to a dittoPool\\n     * also this function is O(n) gas efficient, only really meant to be used off-chain\\n     * @return nftIds the list of all NFT Token Ids in this pool, across all liquidity positions\\n     */\\n    function getAllPoolHeldNftIds() external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns the number of NFTs owned by the pool\\n     * @return nftBalance_ The number of NFTs owned by the pool\\n     */\\n    function getPoolTotalNftBalance() external view returns (uint256);\\n\\n    /**\\n     * @notice returns the full list of all LP Position NFT tokenIds that represent liquidity in this pool\\n     * @return lpIds the list of all LP Position NFT Token Ids corresponding to liquidity in this pool\\n     */\\n    function getAllPoolLpIds() external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice returns the full amount of all ERC20 tokens that the pool thinks it owns\\n     * @dev may not match the underlying ERC20 contract balanceOf() because of unsafe transfers\\n     * this is only accounting for valid liquidity tradeable in the pool\\n     * @dev this function is not gas efficient and almost certainly should never actually be used on chain\\n     * @return totalPoolTokenBalance the amount of ERC20 tokens the pool thinks it owns\\n     */\\n    function getPoolTotalTokenBalance() external view returns (uint256);\\n\\n    /**\\n     * @notice returns the enumerated list of all token balances for all LP positions in this pool\\n     * @dev this function is not gas efficient and almost certainly should never actually be used on chain\\n     * @return balances the list of all LP Position NFT Token Ids and the amount of ERC20 tokens they are apportioned in the pool\\n     */\\n    function getAllLpIdTokenBalances()\\n        external\\n        view\\n        returns (LpIdToTokenBalance[] memory balances);\\n\\n    /**\\n     * @notice function called on SafeTransferFrom of NFTs to this contract\\n     * @dev see [ERC-721](https://eips.ethereum.org/EIPS/eip-721) for details\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IDittoRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport {\\n    Swap,\\n    NftInSwap,\\n    RobustSwap,\\n    RobustNftInSwap,\\n    ComplexSwap,\\n    RobustComplexSwap\\n} from \\\"../struct/RouterStructs.sol\\\";\\nimport { IERC721 } from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\\\";\\nimport { ERC20 } from \\\"../../lib/solmate/src/tokens/ERC20.sol\\\";\\n\\n/**\\n * @title Ditto Swap Router Interface\\n * @notice Performs swaps between Nfts and ERC20 tokens, across multiple pools, or more complicated multi-swap paths\\n * @dev All swaps assume that a single ERC20 token is used for all the pools involved.\\n * Swapping using multiple tokens in the same transaction is possible, but the slippage checks and the return values\\n * will be meaningless, and may lead to undefined behavior.\\n * @dev UX: The sender should grant infinite token approvals to the router in order for Nft-to-Nft swaps to work smoothly.\\n * @dev This router has a notion of robust, and non-robust swaps. \\\"Robust\\\" versions of a swap will never revert due to\\n * slippage. Instead, users specify a per-swap max cost. If the price changes more than the user specifies, no swap is\\n * attempted. This allows users to specify a batch of swaps, and execute as many of them as possible.\\n * On non-robust swaps, if any slippage check per trade fails in the chain, the entire transaction reverts.\\n */\\ninterface IDittoRouter {\\n    // ***************************************************************\\n    // * ============ TRADING ERC20 TOKENS FOR STUFF =============== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Swaps ERC20 tokens into specific Nfts using multiple pools.\\n     * @param swapList The list of pools to trade with and the IDs of the Nfts to buy from each.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-Nft swaps\\n     * @param nftRecipient The address that will receive the Nft output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function swapTokensForNfts(\\n        Swap[] calldata swapList,\\n        uint256 inputAmount,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external returns (uint256 remainingValue);\\n\\n    /**\\n     * @notice Swaps as many ERC20 tokens for specific Nfts as possible, respecting the per-swap max cost.\\n     * @param swapList The list of pools to trade with and the IDs of the Nfts to buy from each.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-Nft swaps\\n     *\\n     * @param nftRecipient The address that will receive the Nft output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return remainingValue The unspent token amount\\n     */\\n    function robustSwapTokensForNfts(\\n        RobustSwap[] calldata swapList,\\n        uint256 inputAmount,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external returns (uint256 remainingValue);\\n\\n    /**\\n     * @notice Buys Nfts with ERC20, and sells them for tokens in one transaction\\n     * @param params All the parameters for the swap (packed in struct to avoid stack too deep), containing:\\n     * - ethToNftSwapList The list of Nfts to buy\\n     * - nftToTokenSwapList The list of Nfts to sell\\n     * - inputAmount The max amount of tokens to send (if ERC20)\\n     * - tokenRecipient The address that receives tokens from the Nfts sold\\n     * - nftRecipient The address that receives Nfts\\n     * - deadline UNIX timestamp deadline for the swap\\n     */\\n    function robustSwapTokensForNftsAndNftsForTokens(RobustComplexSwap calldata params)\\n        external\\n        returns (uint256 remainingValue, uint256 outputAmount);\\n\\n    // ***************************************************************\\n    // * ================= TRADING NFTs FOR STUFF ================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Swaps Nfts into ETH/ERC20 using multiple pools.\\n     * @param swapList The list of pools to trade with and the IDs of the Nfts to sell to each.\\n     * @param minOutput The minimum acceptable total tokens received\\n     * @param tokenRecipient The address that will receive the token output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total tokens received\\n     */\\n    function swapNftsForTokens(\\n        NftInSwap[] calldata swapList,\\n        uint256 minOutput,\\n        address tokenRecipient,\\n        uint256 deadline\\n    ) external returns (uint256 outputAmount);\\n\\n    /**\\n     * @notice Swaps as many Nfts for tokens as possible, respecting the per-swap min output\\n     * @param swapList The list of pools to trade with and the IDs of the Nfts to sell to each.\\n     * @param tokenRecipient The address that will receive the token output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ETH/ERC20 received\\n     */\\n    function robustSwapNftsForTokens(\\n        RobustNftInSwap[] calldata swapList,\\n        address tokenRecipient,\\n        uint256 deadline\\n    ) external returns (uint256 outputAmount);\\n\\n    /**\\n     * @notice Swaps one set of Nfts into another set of specific Nfts using multiple pools, using\\n     * an ERC20 token as the intermediary.\\n     * @param trade The struct containing all Nft-to-ERC20 swaps and ERC20-to-Nft swaps.\\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-Nft swaps\\n     * @param minOutput The minimum acceptable total excess tokens received\\n     * @param nftRecipient The address that will receive the Nft output\\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\\n     * @return outputAmount The total ERC20 tokens received\\n     */\\n    function swapNftsForSpecificNftsThroughTokens(\\n        ComplexSwap calldata trade,\\n        uint256 inputAmount,\\n        uint256 minOutput,\\n        address nftRecipient,\\n        uint256 deadline\\n    ) external returns (uint256 outputAmount);\\n\\n    // ***************************************************************\\n    // * ================= RESTRICTED FUNCTIONS ==================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Allows pool contracts to transfer ERC20 tokens directly from\\n     * the sender, in order to minimize the number of token transfers.\\n     * @dev Only callable by valid IDittoPools.\\n     * @param token The ERC20 token to transfer\\n     * @param from The address to transfer tokens from\\n     * @param to The address to transfer tokens to\\n     * @param amount The amount of tokens to transfer\\n     */\\n    function poolTransferErc20From(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice Allows pool contracts to transfer ERC721 NFTs directly from\\n     * the sender, in order to minimize the number of token transfers.\\n     * @dev Only callable by valid IDittoPools.\\n     * @param nft The ERC721 NFT to transfer\\n     * @param from The address to transfer tokens from\\n     * @param to The address to transfer tokens to\\n     * @param id The ID of the NFT to transfer\\n     */\\n    function poolTransferNftFrom(IERC721 nft, address from, address to, uint256 id) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPoolManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @title IPoolManager\\n * @notice Interface for the PoolManager contract\\n */\\ninterface IPoolManager {\\n    /**\\n     * @notice Initializes the permitter contract with some initial state.\\n     * @param dittoPool_ the address of the DittoPool that this manager is managing.\\n     * @param data_ any data necessary for initializing the permitter.\\n     */\\n    function initialize(address dittoPool_, bytes memory data_) external;\\n\\n    /**\\n     * @notice Returns whether or not the contract has been initialized.\\n     * @return initialized Whether or not the contract has been initialized.\\n     */\\n    function initialized() external view returns (bool);\\n\\n    /**\\n     * @notice Change the base price charged to buy an NFT from the pair\\n     * @param newBasePrice_ New base price: now NFTs purchased at this price, sold at `newBasePrice_ + Delta`\\n     */\\n    function changeBasePrice(uint128 newBasePrice_) external;\\n\\n    /**\\n     * @notice Change the delta parameter associated with the bonding curve\\n     * @dev see the bonding curve documentation on bonding curves for additional information\\n     * Each bonding curve uses delta differently, but in general it is used as an input\\n     * to determine the next price on the bonding curve\\n     * @param newDelta_ New delta parameter\\n     */\\n    function changeDelta(uint128 newDelta_) external;\\n\\n    /**\\n     * @notice Change the pool lp fee, set by owner, paid to LPers only when they are the counterparty in a trade\\n     * @param newFeeLp_ New fee, in wei / 1e18, charged by the pool for trades with it (i.e. 1% = 0.01e18)\\n     */\\n    function changeLpFee(uint96 newFeeLp_) external;\\n\\n    /**\\n     * @notice Change the pool admin fee, set by owner, paid to admin (or whoever they want)\\n     * @param newFeeAdmin_ New fee, in wei / 1e18, charged by the pool for trades with it (i.e. 1% = 0.01e18)\\n     */\\n    function changeAdminFee(uint96 newFeeAdmin_) external;\\n\\n    /**\\n     * @notice Change who the pool admin fee for this pool is sent to.\\n     * @param newAdminFeeRecipient_ New address to send admin fees to.\\n     */\\n    function changeAdminFeeRecipient(address newAdminFeeRecipient_) external;\\n\\n    /**\\n     * @notice Change the owner of the underlying DittoPool, functions independently of PoolManager\\n     *   ownership transfer.\\n     * @param newOwner_ The new owner of the underlying DittoPool\\n     */\\n    function transferPoolOwnership(address newOwner_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IMetadataGenerator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { IDittoPool } from \\\"./IDittoPool.sol\\\";\\n\\n/**\\n * @title IMetadataGenerator\\n * @notice Provides a standard interface for interacting with the MetadataGenerator contract \\n *   to return a base64 encoded tokenURI for a given tokenId.\\n */\\ninterface IMetadataGenerator {\\n    /**\\n     * @notice Called in the tokenURI() function of the LpNft contract.\\n     * @param lpId_ The identifier for a liquidity position NFT\\n     * @param pool_ The DittoPool address associated with this liquidity position NFT\\n     * @param countToken_ Count of all ERC20 tokens assigned to the owner of the liquidity position NFT in the DittoPool\\n     * @param countNft_ Count of all NFTs assigned to the owner of the liquidity position NFT in the DittoPool\\n     * @return tokenUri A distinct Uniform Resource Identifier (URI) for a given asset.\\n     */\\n    function payloadTokenUri(\\n        uint256 lpId_,\\n        IDittoPool pool_,\\n        uint256 countToken_,\\n        uint256 countNft_\\n    ) external view returns (string memory tokenUri);\\n\\n    /**\\n     * @notice Called in the contractURI() function of the LpNft contract.\\n     * @return contractUri A distinct Uniform Resource Identifier (URI) for a given asset.\\n     */\\n    function payloadContractUri() external view returns (string memory contractUri);\\n}\\n\"\r\n    },\r\n    \"contracts/pool/lpNft/LpNft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { ILpNft } from \\\"../../interface/ILpNft.sol\\\";\\nimport { IMetadataGenerator } from \\\"../../interface/IMetadataGenerator.sol\\\";\\nimport { MetadataGeneratorError } from \\\"../metadata/MetadataGeneratorError.sol\\\";\\nimport { IDittoPool } from \\\"../../interface/IDittoPool.sol\\\";\\nimport { IDittoPoolFactory } from \\\"../../interface/IDittoPoolFactory.sol\\\";\\nimport { OwnerTwoStep } from \\\"../../utils/OwnerTwoStep.sol\\\";\\n\\nimport { IERC721 } from \\\"../../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\\\";\\nimport { ERC721 } from \\\"../../../lib/solmate/src/tokens/ERC721.sol\\\";\\n\\n/**\\n * @title LpNft\\n * @notice LpNft is an ERC721 NFT collection that tokenizes market makers' liquidity positions in the Ditto protocol.\\n */\\ncontract LpNft is ILpNft, ERC721, OwnerTwoStep {\\n    IDittoPoolFactory internal _dittoPoolFactory;\\n\\n    ///@dev stores which pool each lpId corresponds to\\n    mapping(uint256 => IDittoPool) internal _lpIdToPool;\\n\\n    /// @dev dittoPool address is the key of the mapping, underlying NFT address traded by that pool is the value\\n    mapping(address => IERC721) internal _approvedDittoPoolToNft;\\n\\n    IMetadataGenerator internal _metadataGenerator;\\n\\n    ///@dev NFTs are minted sequentially, starting at tokenId 1\\n    uint96 internal _nextId = 1;\\n\\n    // ***************************************************************\\n    // * ========================= EVENTS ========================== *\\n    // ***************************************************************\\n\\n    event LpNftAdminUpdatedMetadataGenerator(address metadataGenerator);\\n    event LpNftAdminUpdatedDittoPoolFactory(address dittoPoolFactory);\\n\\n    // ***************************************************************\\n    // * ========================= ERRORS ========================== *\\n    // ***************************************************************\\n    error LpNftDittoFactoryOnly();\\n    error LpNftDittoPoolOnly();\\n\\n    // ***************************************************************\\n    // * ==================== ADMIN FUNCTIONS ====================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Constructor. Records the DittoPoolFactory address. Sets the owner of this contract. \\n     *   Assigns the metadataGenerator address.\\n     */\\n    constructor(\\n        address initialOwner_,\\n        address metadataGenerator_\\n    ) ERC721(\\\"Ditto V1 LP Positions\\\", \\\"DITTO-V1-POS\\\") {\\n        _transferOwnership(initialOwner_);\\n        _metadataGenerator = IMetadataGenerator(metadataGenerator_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function setDittoPoolFactory(IDittoPoolFactory dittoPoolFactory_) external onlyOwner {\\n        _dittoPoolFactory = dittoPoolFactory_;\\n        emit LpNftAdminUpdatedDittoPoolFactory(address(dittoPoolFactory_));\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function setMetadataGenerator(IMetadataGenerator metadataGenerator_) external onlyOwner {\\n        _metadataGenerator = metadataGenerator_;\\n\\n        emit LpNftAdminUpdatedMetadataGenerator(address(metadataGenerator_));\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function setApprovedDittoPool(address dittoPool_, IERC721 nft_) external onlyDittoPoolFactory {\\n        _approvedDittoPoolToNft[dittoPool_] = nft_;\\n    }\\n\\n    // ***************************************************************\\n    // * =============== PROTECTED POOL FUNCTIONS ================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc ILpNft\\n    function mint(address to_) public onlyApprovedDittoPools returns (uint256 lpId) {\\n        lpId = _nextId;\\n\\n        _lpIdToPool[lpId] = IDittoPool(msg.sender);\\n\\n        _safeMint(to_, lpId);\\n        unchecked {\\n            ++_nextId;\\n        }\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function burn(uint256 lpId_) external onlyApprovedDittoPools {\\n        delete _lpIdToPool[lpId_];\\n\\n        _burn(lpId_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function emitMetadataUpdate(uint256 lpId_) external onlyApprovedDittoPools {\\n        emit MetadataUpdate(lpId_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function emitMetadataUpdateForAll() external onlyApprovedDittoPools {\\n        if (totalSupply > 0) {\\n            emit BatchMetadataUpdate(1, totalSupply);\\n        }\\n    }\\n\\n    // ***************************************************************\\n    // * ==================== AUTH MODIFIERS ======================= *\\n    // ***************************************************************\\n    /**\\n     * @notice Modifier that restricts access to the DittoPoolFactory contract \\n     *   that created this NFT collection.\\n     */\\n    modifier onlyDittoPoolFactory() {\\n        if (msg.sender != address(_dittoPoolFactory)) {\\n            revert LpNftDittoFactoryOnly();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @notice Modifier that restricts access to DittoPool contracts that have been \\n     *   approved to mint and burn liquidity position NFTs by the DittoPoolFactory.\\n     */\\n    modifier onlyApprovedDittoPools() {\\n        if (address(_approvedDittoPoolToNft[msg.sender]) == address(0)) {\\n            revert LpNftDittoPoolOnly();\\n        }\\n        _;\\n    }\\n\\n    // ***************************************************************\\n    // * ====================== VIEW FUNCTIONS ===================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc ILpNft\\n    function isApproved(address spender_, uint256 lpId_) external view returns (bool) {\\n        address ownerOf = ownerOf[lpId_];\\n        return (\\n            spender_ == ownerOf || isApprovedForAll[ownerOf][spender_]\\n                || spender_ == getApproved[lpId_]\\n        );\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function isApprovedDittoPool(address pool_) external view returns (bool) {\\n        return address(_approvedDittoPoolToNft[pool_]) != address(0);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getPoolForLpId(uint256 lpId_) external view returns (IDittoPool) {\\n        return _lpIdToPool[lpId_];\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getPoolAndOwnerForLpId(uint256 lpId_)\\n        external\\n        view\\n        returns (IDittoPool pool, address owner)\\n    {\\n        pool = _lpIdToPool[lpId_];\\n        owner = ownerOf[lpId_];\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getNftForLpId(uint256 lpId_) external view returns (IERC721) {\\n        return _approvedDittoPoolToNft[address(_lpIdToPool[lpId_])];\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getLpValueToken(uint256 lpId_) public view returns (uint256) {\\n        return _lpIdToPool[lpId_].getTokenBalanceForLpId(lpId_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getAllHeldNftIds(uint256 lpId_) external view returns (uint256[] memory) {\\n        return _lpIdToPool[lpId_].getNftIdsForLpId(lpId_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getNumNftsHeld(uint256 lpId_) public view returns (uint256) {\\n        return _lpIdToPool[lpId_].getNftCountForLpId(lpId_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getLpValueNft(uint256 lpId_) public view returns (uint256) {\\n        return getNumNftsHeld(lpId_) * _lpIdToPool[lpId_].basePrice();\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function getLpValue(uint256 lpId_) external view returns (uint256) {\\n        return getLpValueToken(lpId_) + getLpValueNft(lpId_);\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function dittoPoolFactory() external view returns (IDittoPoolFactory) {\\n        return _dittoPoolFactory;\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function nextId() external view returns (uint256) {\\n        return _nextId;\\n    }\\n\\n    ///@inheritdoc ILpNft\\n    function metadataGenerator() external view returns (IMetadataGenerator) {\\n        return _metadataGenerator;\\n    }\\n\\n    // ***************************************************************\\n    // * ================== ERC721 INTERFACE ======================= *\\n    // ***************************************************************\\n\\n    /**\\n     *  @notice returns storefront-level metadata to be viewed on marketplaces.\\n     */\\n    function contractURI() external view returns (string memory) {\\n        return _metadataGenerator.payloadContractUri();\\n    }\\n\\n    /**\\n     * @notice returns the metadata for a given token, to be viewed on marketplaces and off-chain\\n     * @dev see [EIP-721](https://eips.ethereum.org/EIPS/eip-721) EIP-721 Metadata Extension\\n     * @param lpId_ the tokenId of the NFT to get metadata for\\n     */\\n    function tokenURI(uint256 lpId_) public view override returns (string memory) {\\n        IDittoPool pool = IDittoPool(_lpIdToPool[lpId_]);\\n        uint256 tokenCount = getLpValueToken(lpId_);\\n        uint256 nftCount = getNumNftsHeld(lpId_);\\n        try _metadataGenerator.payloadTokenUri(lpId_, pool, tokenCount, nftCount) returns (string memory tokenUri) {\\n            return tokenUri;\\n        } catch (bytes memory reason) {\\n            return MetadataGeneratorError.errorTokenUri(lpId_, address(pool), tokenCount, nftCount, reason);\\n        }\\n    }\\n\\n    /**\\n     * @notice Whether or not this contract supports the given interface. \\n     *   See [EIP-165](https://eips.ethereum.org/EIPS/eip-165)\\n     */\\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\\n            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721\\n            || interfaceId == 0x49064906 // ERC165 Interface ID for ERC4906\\n            || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/OwnerTwoStep.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnerTwoStep } from \\\"../interface/IOwnerTwoStep.sol\\\";\\n\\nabstract contract OwnerTwoStep is IOwnerTwoStep {\\n\\n    /// @dev The owner of the contract\\n    address private _owner;\\n\\n    /// @dev The pending owner of the contract\\n    address private _pendingOwner;\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    // ***************************************************************\\n    // * ========================= EVENTS ========================== *\\n    // ***************************************************************\\n\\n    event OwnerTwoStepOwnerStartedTransfer(address currentOwner, address newPendingOwner);\\n    event OwnerTwoStepPendingOwnerAcceptedTransfer(address newOwner);\\n    event OwnerTwoStepOwnershipTransferred(address previousOwner, address newOwner);\\n    event OwnerTwoStepOwnerRenouncedOwnership(address previousOwner);\\n\\n    // ***************************************************************\\n    // * ========================= ERRORS ========================== *\\n    // ***************************************************************\\n\\n    error OwnerTwoStepNotOwner();\\n    error OwnerTwoStepNotPendingOwner();\\n\\n    // ***************************************************************\\n    // * =================== USER INTERFACE ======================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IOwnerTwoStep\\n    function transferOwnership(address newPendingOwner_) public virtual override onlyOwner {\\n        _pendingOwner = newPendingOwner_;\\n\\n        emit OwnerTwoStepOwnerStartedTransfer(_owner, newPendingOwner_);\\n    }\\n\\n    ///@inheritdoc IOwnerTwoStep\\n    function acceptOwnership() public virtual override onlyPendingOwner {\\n        emit OwnerTwoStepPendingOwnerAcceptedTransfer(msg.sender);\\n\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    ///@inheritdoc IOwnerTwoStep\\n    function renounceOwnership() public virtual onlyOwner {\\n\\n        emit OwnerTwoStepOwnerRenouncedOwnership(msg.sender);\\n\\n        _transferOwnership(address(0));\\n    }\\n\\n    // ***************************************************************\\n    // * =================== VIEW FUNCTIONS ======================== *\\n    // ***************************************************************\\n\\n    ///@inheritdoc IOwnerTwoStep\\n    function owner() public view virtual override returns (address) {\\n        return _owner;\\n    }\\n\\n    ///@inheritdoc IOwnerTwoStep\\n    function pendingOwner() external view override returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    // ***************************************************************\\n    // * ===================== MODIFIERS =========================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the pending owner.\\n     */\\n    modifier onlyPendingOwner {\\n        if (msg.sender != _pendingOwner) {\\n            revert OwnerTwoStepNotPendingOwner();\\n        }\\n        _;\\n    }\\n\\n    // ***************************************************************\\n    // * ================== INTERNAL HELPERS ======================= *\\n    // ***************************************************************\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner. Saves contract size over copying \\n     *   implementation into every function that uses the modifier.\\n     */\\n    function _onlyOwner() internal view virtual {\\n        if (msg.sender != _owner) {\\n            revert OwnerTwoStepNotOwner();\\n        }\\n    }\\n\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * @param newOwner_ New owner to transfer to\\n     */\\n    function _transferOwnership(address newOwner_) internal {\\n        delete _pendingOwner;\\n\\n        emit OwnerTwoStepOwnershipTransferred(_owner, newOwner_);\\n\\n        _owner = newOwner_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPermitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @title IPermitter\\n * @notice Interface for the Permitter contracts. They are used to check whether a set of tokenIds\\n *   are are allowed in a pool.\\n */\\ninterface IPermitter {\\n    /**\\n     * @notice Initializes the permitter contract with initial state.\\n     * @param data_ Any data necessary for initializing the permitter implementation.\\n     */\\n    function initialize(bytes memory data_) external returns (bytes memory);\\n\\n    /**\\n     * @notice Returns whether or not the contract has been initialized.\\n     * @return initialized Whether or not the contract has been initialized.\\n     */\\n    function initialized() external view returns (bool);\\n\\n    /**\\n     * @notice Checks that the provided permission data are valid for the provided tokenIds.\\n     * @param tokenIds_ The token ids to check.\\n     * @param permitterData_ data used by the permitter to perform checking.\\n     * @return permitted Whether or not the tokenIds are permitted to be added to the pool.\\n     */\\n    function checkPermitterData(uint256[] calldata tokenIds_, bytes memory permitterData_)\\n        external\\n        view\\n        returns (bool permitted);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        if (_status == _ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev A clone instance deployment failed.\\n     */\\n    error ERC1167FailedCreateClone();\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IOwnerTwoStep.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @title IOwnerTwoStep\\n * @notice Interface for the OwnerTwoStep contract\\n */\\ninterface IOwnerTwoStep {\\n\\n    // ***************************************************************\\n    // * =================== USER INTERFACE ======================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Starts the ownership transfer of the contract to a new account. Replaces the \\n     *   pending transfer if there is one. \\n     * @dev Can only be called by the current owner.\\n     * @param newOwner_ The address of the new owner\\n     */\\n    function transferOwnership(address newOwner_) external;\\n\\n    /**\\n     * @notice Completes the transfer process to a new owner.\\n     * @dev only callable by the pending owner that is accepting the new ownership.\\n     */\\n    function acceptOwnership() external;\\n\\n    /**\\n     * @notice Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     */\\n    function renounceOwnership() external;\\n\\n    // ***************************************************************\\n    // * =================== VIEW FUNCTIONS ======================== *\\n    // ***************************************************************\\n\\n    /**\\n     * @notice Getter function to find out the current owner address\\n     * @return owner The current owner address\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Getter function to find out the pending owner address\\n     * @dev The pending address is 0 when there is no transfer of owner in progress\\n     * @return pendingOwner The pending owner address, if any\\n     */\\n    function pendingOwner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/struct/Fee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @title Fee\\n * @notice Struct to hold the fee amounts for LP, admin and protocol. Is used in the protocol to \\n *   pass the fee percentages and the total fee amount depending on the context.\\n */\\nstruct Fee {\\n    uint256 lp;\\n    uint256 admin;\\n    uint256 protocol;\\n}\\n\"\r\n    },\r\n    \"contracts/struct/SwapArgs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @param nftIds The list of IDs of the NFTs to purchase\\n * @param maxExpectedTokenInput The maximum acceptable cost from the sender (in wei or base units of ERC20).\\n *   If the actual amount is greater than this value, the transaction will be reverted.\\n * @param tokenSender ERC20 sender. Only used if msg.sender is an approved IDittoRouter, else msg.sender is used.\\n * @param nftRecipient Address to send the purchased NFTs to.\\n */\\nstruct SwapTokensForNftsArgs {\\n    uint256[] nftIds;\\n    uint256 maxExpectedTokenInput;\\n    address tokenSender;\\n    address nftRecipient;\\n    bytes swapData;\\n}\\n\\n/**\\n * @param nftIds The list of IDs of the NFTs to sell to the pair\\n * @param lpIds The list of IDs of the LP positions sell the NFTs to\\n * @param minExpectedTokenOutput The minimum acceptable token count received by the sender. \\n *   If the actual amount is less than this value, the transaction will be reverted.\\n * @param nftSender NFT sender. Only used if msg.sender is an approved IDittoRouter, else msg.sender is used.\\n * @param tokenRecipient The recipient of the ERC20 proceeds.\\n * @param permitterData Data to profe that the NFT Token IDs are permitted to be sold to this pool if a permitter is set.\\n * @param swapData Extra data to pass to the curve\\n */\\nstruct SwapNftsForTokensArgs {\\n    uint256[] nftIds;\\n    uint256[] lpIds;\\n    uint256 minExpectedTokenOutput;\\n    address nftSender;\\n    address tokenRecipient;\\n    bytes permitterData;\\n    bytes swapData;\\n}\\n\\n\"\r\n    },\r\n    \"contracts/struct/LpIdToTokenBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @notice Tuple struct to encapsulate a LP Position NFT token Id and the amount of ERC20 tokens it owns in the pool\\n * @dev **lpId** the LP Position NFT token Id of a liquidity provider\\n * @dev **tokenBalance** the amount of ERC20 tokens the liquidity provider has in the pool attributed to them\\n */\\nstruct LpIdToTokenBalance {\\n    uint256 lpId;\\n    uint256 tokenBalance;\\n}\\n\"\r\n    },\r\n    \"contracts/struct/NftCostData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.19;\\n\\nimport { Fee } from \\\"./Fee.sol\\\";\\n\\nstruct NftCostData {\\n    bool specificNftId;\\n    uint256 nftId;\\n    uint256 price;\\n    Fee fee;\\n}\"\r\n    },\r\n    \"contracts/utils/CurveErrorCode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nenum CurveErrorCode {\\n    OK, // No error\\n    INVALID_NUMITEMS, // The numItem value is 0 or too large\\n    BASE_PRICE_OVERFLOW, // The updated base price doesn't fit into 128 bits\\n    SELL_NOT_SUPPORTED, // The pool doesn't support sell\\n    BUY_NOT_SUPPORTED, // The pool doesn't support buy\\n    MISSING_SWAP_DATA, // No swap data provided for a pool that requires it\\n    NOOP // No operation was performed\\n}\\n\"\r\n    },\r\n    \"contracts/struct/RouterStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { IDittoPool } from \\\"../interface/IDittoPool.sol\\\";\\n\\n/**\\n * @notice Basic Struct used by DittoRouter For Specifying trades\\n * @dev **pool** the pool to trade with\\n * @dev **nftIds** which Nfts you wish to buy out of or sell into the pool\\n */\\nstruct Swap {\\n    IDittoPool pool;\\n    uint256[] nftIds;\\n    bytes swapData;\\n}\\n\\n/**\\n * @notice Struct used by DittoRouter when selling Nfts into a pool.\\n * @dev **swapInfo** Swap info with pool and and Nfts being traded\\n * @dev **lpIds** The LP Position TokenIds of the counterparties you wish to sell to in the pool\\n * @dev **permitterData** Optional: data to pass to the pool for permission checks that the tokenIds are allowed in the pool\\n */\\nstruct NftInSwap {\\n    IDittoPool pool;\\n    uint256[] nftIds;\\n    uint256[] lpIds;\\n    bytes permitterData;\\n    bytes swapData;\\n}\\n\\n/**\\n * @notice Struct used for \\\"robust\\\" swaps that may have partial fills buying NFTs out of a pool\\n * @dev **swapInfo** Swap info with pool and and Nfts being traded\\n * @dev **maxCost** The maximum amount of tokens you are willing to pay for the Nfts total\\n */\\nstruct RobustSwap {\\n    IDittoPool pool;\\n    uint256[] nftIds;\\n    uint256 maxCost;\\n    bytes swapData;\\n}\\n\\n/**\\n * @notice Struct used for \\\"robust\\\" swaps that may have partial fills selling NFTs into a pool\\n * @dev **nftSwapInfo** Swap info with pool, Nfts being traded, lp counterparties, and permitter data\\n * @dev **minOutput** The total minimum amount of tokens you are willing to receive for the Nfts you sell, or abort\\n */\\nstruct RobustNftInSwap {\\n    IDittoPool pool;\\n    uint256[] nftIds;\\n    uint256[] lpIds;\\n    bytes permitterData;\\n    uint256 minOutput;\\n    bytes swapData;\\n}\\n\\n/**\\n * @notice DittoRouter struct for complex swaps with tokens bought and sold in one transaction\\n * @dev **nftToTokenTrades** array of trade info where you are selling Nfts into pools\\n * @dev **tokenToNftTrades** array of trade info where you are buying Nfts out of pools\\n */\\nstruct ComplexSwap {\\n    NftInSwap[] nftToTokenTrades;\\n    Swap[] tokenToNftTrades;\\n}\\n\\n/**\\n * @notice DittoRouter struct for robust partially-fillable complex swaps with tokens bought and sold in one transaction\\n * @dev **nftToTokenTrades** array of trade info where you are selling Nfts into pools\\n * @dev **tokenToNftTrades** array of trade info where you are buying Nfts out of pools\\n * @dev **inputAmount** The total amount of tokens you are willing to spend on the Nfts you buy\\n * @dev **tokenRecipient** The address to send the tokens to after the swap\\n * @dev **nftRecipient** The address to send the Nfts to after the swap\\n */\\nstruct RobustComplexSwap {\\n    RobustSwap[] tokenToNftTrades;\\n    RobustNftInSwap[] nftToTokenTrades;\\n    uint256 inputAmount;\\n    address tokenRecipient;\\n    address nftRecipient;\\n    uint256 deadline;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ILpNft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport { IERC4906 } from \\\"./IERC4906.sol\\\";\\nimport { IDittoPool } from \\\"./IDittoPool.sol\\\";\\nimport { IDittoPoolFactory } from \\\"./IDittoPoolFactory.sol\\\";\\nimport { IMetadataGenerator } from \\\"./IMetadataGenerator.sol\\\";\\nimport { IERC721 } from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface ILpNft is IERC4906 {\\n    // * =============== State Changing Functions ================== *\\n\\n    /**\\n     * @notice Allows an administrator to change the DittoPoolFactory contract that interacts with this LP NFT.\\n     * @param dittoPoolFactory_ The address of a Ditto Pool Factory contract.\\n     */\\n    function setDittoPoolFactory(IDittoPoolFactory dittoPoolFactory_) external;\\n\\n    /**\\n     * @notice Allows an admin to update the metadata generator through the pool factory.\\n     * @dev only the Ditto Pool Factory is allowed to call this function\\n     * @param metadataGenerator_ The address of the metadata generator contract.\\n     */\\n    function setMetadataGenerator(IMetadataGenerator metadataGenerator_) external;\\n\\n    /**\\n     * @notice Allows the factory to whitelist DittoPool contracts as allowed to mint and burn liquidity position NFTs.\\n     * @dev only the Ditto Pool Factory is allowed to call this function\\n     * @param dittoPool_ The address of the DittoPool contract to whitelist.\\n     * @param nft_ The address of the NFT contract that the DittoPool trades.\\n     */\\n    function setApprovedDittoPool(address dittoPool_, IERC721 nft_) external;\\n\\n    /**\\n     * @notice mint function used to create new LP Position NFTs \\n     * @dev only callable by approved DittoPool contracts\\n     * @param to_ The address of the user who will own the new NFT.\\n     * @return lpId The tokenId of the newly minted NFT.\\n     */\\n    function mint(address to_) external returns (uint256 lpId);\\n\\n    /**\\n     * @notice burn function used to destroy LP Position NFTs\\n     * @dev only callable approved DittoPool contracts\\n     * @param lpId_ The tokenId of the NFT to burn.\\n     */\\n    function burn(uint256 lpId_) external;\\n\\n    /**\\n     * @notice Updates LP position NFT metadata on trades, as LP's LP information changes due to the trade\\n     * @dev see [EIP-4906](https://eips.ethereum.org/EIPS/eip-4906) EIP-721 Metadata Update Extension\\n     * @dev only callable by approved DittoPool contracts\\n     * @param lpId_ the tokenId of the NFT who's metadata needs to be updated\\n     */\\n    function emitMetadataUpdate(uint256 lpId_) external;\\n\\n    /**\\n     * @notice Tells off-chain actors to update LP position NFT metadata for all tokens in the collection\\n     * @dev see [EIP-4906](https://eips.ethereum.org/EIPS/eip-4906) EIP-721 Metadata Update Extension\\n     * @dev only callable by approved DittoPool contracts\\n     */\\n    function emitMetadataUpdateForAll() external;\\n\\n    // * ======= EXTERNALLY CALLABLE READ-ONLY VIEW FUNCTIONS ====== *\\n\\n    /**\\n     * @notice Tells you whether a given tokenId is allowed to be spent/used by a given spender on behalf of its owner.\\n     * @dev see EIP-721 approve() and setApprovalForAll() functions\\n     * @param spender_ The address of the operator/spender to check.\\n     * @param lpId_ The tokenId of the NFT to check.\\n     * @return approved Whether the spender is allowed to send or manipulate the NFT.\\n     */\\n    function isApproved(address spender_, uint256 lpId_) external view returns (bool);\\n\\n    /**\\n     * @notice Check if an address has been approved as a DittoPool on the LpNft contract\\n     * @param dittoPool_ The address of the DittoPool contract to check.\\n     * @return approved Whether the DittoPool is approved to mint and burn liquidity position NFTs.\\n     */\\n    function isApprovedDittoPool(address dittoPool_) external view returns (bool);\\n\\n    /**\\n     * @notice Returns which DittoPool applies to a given LP Position NFT tokenId.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return pool The DittoPool contract that the LP Position NFT is tied to.\\n     */\\n    function getPoolForLpId(uint256 lpId_) external view returns (IDittoPool pool);\\n\\n    /**\\n     * @notice Returns the DittoPool and liquidity provider's address for a given LP Position NFT tokenId.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return pool The DittoPool contract that the LP Position NFT is tied to.\\n     * @return owner The owner of the lpId.\\n     */\\n    function getPoolAndOwnerForLpId(uint256 lpId_)\\n        external\\n        view\\n        returns (IDittoPool pool, address owner);\\n\\n    /**\\n     * @notice Returns the address of the underlying NFT collection traded by the DittoPool corresponding to an LP Position NFT tokenId.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return nft The address of the underlying NFT collection for that LP position\\n     */\\n    function getNftForLpId(uint256 lpId_) external view returns (IERC721);\\n\\n    /**\\n     * @notice Returns the amount of ERC20 tokens held by a liquidity provider in a given LP Position.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return value the amount of ERC20 tokens held by the liquidity provider in the given LP Position.\\n     */\\n    function getLpValueToken(uint256 lpId_) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the list of NFT Ids (of the underlying NFT collection) held by a liquidity provider in a given LP Position.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return nftIds the list of NFT Ids held by the liquidity provider in the given LP Position.\\n     */\\n    function getAllHeldNftIds(uint256 lpId_) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice Returns the count of NFTs held by a liquidity provider in a given LP Position.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return nftCount the count of NFTs held by the liquidity provider in the given LP Position.\\n     */\\n    function getNumNftsHeld(uint256 lpId_) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the \\\"value\\\" of an LP positions NFT holdings in ERC20 Tokens,\\n     *   if it were to be sold at the current base price.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return value the \\\"value\\\" of an LP positions NFT holdings in ERC20 Tokens.\\n     */\\n    function getLpValueNft(uint256 lpId_) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the \\\"value\\\" of an LP positions total holdings in ERC20s + NFTs,\\n     *   if all the Nfts in the holdings were sold at the current base price.\\n     * @param lpId_ The LP Position tokenId to get info for.\\n     * @return value the \\\"value\\\" of an LP positions sum total holdings in ERC20s + NFTs.\\n     */\\n    function getLpValue(uint256 lpId_) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the address of the DittoPoolFactory contract\\n     * @return factory the address of the DittoPoolFactory contract\\n     */\\n    function dittoPoolFactory() external view returns (IDittoPoolFactory);\\n\\n    /**\\n     * @notice returns the next tokenId to be minted\\n     * @dev NFTs are minted sequentially, starting at tokenId 1\\n     * @return nextId the next tokenId to be minted\\n     */\\n    function nextId() external view returns (uint256);\\n\\n    /**\\n     * @notice returns the address of the contract that generates the metadata for LP Position NFTs\\n     * @return metadataGenerator the address of the contract that generates the metadata for LP Position NFTs\\n     */\\n    function metadataGenerator() external view returns (IMetadataGenerator);\\n}\\n\"\r\n    },\r\n    \"contracts/pool/metadata/MetadataGeneratorError.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.19;\\n\\nimport {Base64} from \\\"./library/Base64.sol\\\";\\nimport {Strings} from \\\"../../../lib/openzeppelin-contracts/contracts/utils/Strings.sol\\\";\\n\\nlibrary MetadataGeneratorError {\\n    string internal constant SVG_PREFIX = \\\"<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"UTF-8\\\\\\\"?>\\\"\\n        \\\"<svg xmlns=\\\\\\\"http://www.w3.org/2000/svg\\\\\\\" viewBox=\\\\\\\"0 0 768 768\\\\\\\">\\\"\\n        \\\"<style>.t{font:bold 13px monospace}</style>\\\"\\n        \\\"<rect width=\\\\\\\"768\\\\\\\" height=\\\\\\\"768\\\\\\\" style=\\\\\\\"fill:#e5e5e5;stroke:#000;stroke-width:1.5px;\\\\\\\"/>\\\"\\n        \\\"<text class=\\\\\\\"t\\\\\\\" x=\\\\\\\"1\\\\\\\" y=\\\\\\\"300\\\\\\\">Unable to make LP NFT Image. Funds are unaffected by this error.</text>\\\";\\n    string internal constant SVG_POSTFIX = \\\"</svg>\\\";\\n\\n    ///@notice A human readable description of the item.\\n    string internal constant DESCRIPTION =\\n        \\\"Ditto is a gas-efficient, DeFi-optimized automated market maker (AMM) that enables efficient and seamless trading between NFTs and ERC-20 tokens. \\\"\\n        \\\"Users can effortlessly create on-chain pools for trading NFTs, allowing for more composable NFT liquidity provision. \\\"\\n        \\\"Ditto streamlines the process of exchanging digital assets in the ever-growing NFT market and makes them more compatible with the growing vertical at the intersection of DeFi and NFTs.\\\";\\n\\n    function uint8ToHexChar(uint8 raw) internal pure returns (uint8) {\\n        return (raw > 9)\\n            ? (raw + (0x61 - 0xa)) // ascii lowercase a\\n            : (raw + 0x30); // ascii 0\\n    }\\n\\n    function bytesToHexString(bytes memory buffer) internal pure returns (string memory) {\\n        bytes memory hexBuffer = new bytes(buffer.length * 2);\\n        for (uint256 i = 0; i < buffer.length; i++) {\\n            uint8 raw = uint8(buffer[i]);\\n            uint8 highNibble = raw >> 4;\\n            uint8 lowNibble = raw & 0x0f;\\n            hexBuffer[i * 2] = bytes1(uint8ToHexChar(highNibble));\\n            hexBuffer[i * 2 + 1] = bytes1(uint8ToHexChar(lowNibble));\\n        }\\n        return string(abi.encodePacked(\\\"0x\\\", hexBuffer));\\n    }\\n\\n    function generateLpIdString(uint256 lpId_) internal pure returns (string memory) {\\n        return string.concat(\\\"<text class=\\\\\\\"t\\\\\\\" x=\\\\\\\"1\\\\\\\" y=\\\\\\\"350\\\\\\\">LpId: \\\", Strings.toString(lpId_), \\\"</text>\\\");\\n    }\\n\\n    function generatePoolString(address pool_) internal pure returns (string memory) {\\n        return\\n            string.concat(\\\"<text class=\\\\\\\"t\\\\\\\" x=\\\\\\\"1\\\\\\\" y=\\\\\\\"375\\\\\\\">Pool: \\\", Strings.toHexString(uint160(pool_)), \\\"</text>\\\");\\n    }\\n\\n    function generateTokenCount(uint256 tokenCount_) internal pure returns (string memory) {\\n        return\\n            string.concat(\\\"<text class=\\\\\\\"t\\\\\\\" x=\\\\\\\"1\\\\\\\" y=\\\\\\\"400\\\\\\\">Token Count: \\\", Strings.toString(tokenCount_), \\\"</text>\\\");\\n    }\\n\\n    function generateNftCount(uint256 nftCount_) internal pure returns (string memory) {\\n        return string.concat(\\\"<text class=\\\\\\\"t\\\\\\\" x=\\\\\\\"1\\\\\\\" y=\\\\\\\"425\\\\\\\">NFT Count: \\\", Strings.toString(nftCount_), \\\"</text>\\\");\\n    }\\n\\n    function generateErrorComment(bytes memory reasonCode_) internal pure returns (string memory) {\\n        return string.concat(\\\"<!-- Error Reason Code: \\\", bytesToHexString(reasonCode_), \\\"-->\\\");\\n    }\\n\\n    function _generateImage(\\n        uint256 lpId_,\\n        address pool_,\\n        uint256 tokenCount_,\\n        uint256 nftCount_,\\n        bytes memory reasonCode_\\n    ) internal pure returns (string memory) {\\n        return string.concat(\\n            SVG_PREFIX,\\n            generateLpIdString(lpId_),\\n            generatePoolString(pool_),\\n            generateTokenCount(tokenCount_),\\n            generateNftCount(nftCount_),\\n            generateErrorComment(reasonCode_),\\n            SVG_POSTFIX\\n        );\\n    }\\n\\n    function errorTokenUri(\\n        uint256 lpId_,\\n        address pool_,\\n        uint256 tokenCount_,\\n        uint256 nftCount_,\\n        bytes memory reasonCode_\\n    ) internal pure returns (string memory) {\\n        string memory image = Base64.encode(bytes(_generateImage(lpId_, pool_, tokenCount_, nftCount_, reasonCode_)));\\n        return string(\\n            abi.encodePacked(\\n                \\\"data:application/json;base64,\\\",\\n                Base64.encode(\\n                    bytes(\\n                        abi.encodePacked(\\n                            '{\\\"name\\\":\\\"',\\n                            string(abi.encodePacked(\\\"Ditto V1 LP Position #\\\", Strings.toString(lpId_))),\\n                            '\\\", \\\"description\\\":\\\"',\\n                            DESCRIPTION,\\n                            '\\\", \\\"image\\\": \\\"',\\n                            \\\"data:image/svg+xml;base64,\\\",\\n                            image,\\n                            '\\\"}'\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC721 STORAGE                        \\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(uint256 => address) public ownerOf;\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        delete getApproved[id];\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            totalSupply++;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(ownerOf[id] != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            totalSupply--;\\n\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC4906.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity 0.8.19;\\n\\n/**\\n * @title IERC4906\\n * @notice Copied from https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4906.md\\n */\\ninterface IERC4906 {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFT.\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    /// @dev This event emits when the metadata of a range of tokens is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFTs.\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/pool/metadata/library/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n    bytes internal constant TABLE_DECODE =\\n        hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n        hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n        hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n        hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for { } lt(dataPtr, endPtr) { } {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) { decodedLen := sub(decodedLen, 1) }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for { } lt(dataPtr, endPtr) { } {\\n                // read 4 characters\\n                dataPtr := add(dataPtr, 4)\\n                let input := mload(dataPtr)\\n\\n                // write 3 bytes\\n                let output :=\\n                    add(\\n                        add(\\n                            shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                            shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))\\n                        ),\\n                        add(\\n                            shl(6, and(mload(add(tablePtr, and(shr(8, input), 0xFF))), 0xFF)),\\n                            and(mload(add(tablePtr, and(input, 0xFF))), 0xFF)\\n                        )\\n                    )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"manifoldxyz/=lib/manifoldxyz/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@manifoldxyz/libraries-solidity/=lib/manifold-libraries-solidity/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"manifold-libraries-solidity/=lib/manifold-libraries-solidity/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"upshot-oracle/=lib/upshot-oracle/contracts/\",\r\n      \"weird-erc20/=lib/solmate/lib/weird-erc20/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract LpNft\",\"name\":\"lpNft_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeProtocolRecipient_\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeProtocol_\",\"type\":\"uint96\"},{\"internalType\":\"address[]\",\"name\":\"poolTemplates_\",\"type\":\"address[]\"},{\"internalType\":\"contract IPoolManager[]\",\"name\":\"poolManagerTemplates_\",\"type\":\"address[]\"},{\"internalType\":\"contract IPermitter[]\",\"name\":\"permitterTemplates_\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DittoPoolFactoryInvalidProtocolFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"templateIndex\",\"type\":\"uint256\"}],\"name\":\"DittoPoolFactoryInvalidTemplateIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1167FailedCreateClone\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerTwoStepNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerTwoStepNotPendingOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"permitterTemplate\",\"type\":\"address\"}],\"name\":\"DittoPoolFactoryAdminAddedPermitterTemplate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolManagerTemplate\",\"type\":\"address\"}],\"name\":\"DittoPoolFactoryAdminAddedPoolManagerTemplate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolTemplate\",\"type\":\"address\"}],\"name\":\"DittoPoolFactoryAdminAddedPoolTemplate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"DittoPoolFactoryAdminAddedRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"protocolFeeMultiplier\",\"type\":\"uint96\"}],\"name\":\"DittoPoolFactoryAdminSetProtocolFeeMultiplier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"protocolFeeRecipient\",\"type\":\"address\"}],\"name\":\"DittoPoolFactoryAdminSetProtocolFeeRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpNft\",\"type\":\"address\"}],\"name\":\"DittoPoolFactoryAdminUpdatedLpNft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isPrivatePool\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"templateIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeLp\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeAdmin\",\"type\":\"uint96\"},{\"internalType\":\"uint128\",\"name\":\"delta\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"basePrice\",\"type\":\"uint128\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIdList\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"initialTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"templateInitData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"referrer\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct PoolTemplate\",\"name\":\"poolTemplate\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dittoPool\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"templateIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"templateInitData\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct PoolManagerTemplate\",\"name\":\"poolManagerTemplate\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolManager\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"templateIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"templateInitData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"liquidityDepositPermissionData\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct PermitterTemplate\",\"name\":\"permitterTemplate\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"permitter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"permitterInitData\",\"type\":\"bytes\"}],\"name\":\"DittoPoolFactoryDittoPoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnerTwoStepOwnerRenouncedOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"OwnerTwoStepOwnerStartedTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerTwoStepOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerTwoStepPendingOwnerAcceptedTransfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPermitter[]\",\"name\":\"permitterTemplates_\",\"type\":\"address[]\"}],\"name\":\"addPermitterTemplates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPoolManager[]\",\"name\":\"poolManagerTemplates_\",\"type\":\"address[]\"}],\"name\":\"addPoolManagerTemplates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"poolTemplates_\",\"type\":\"address[]\"}],\"name\":\"addPoolTemplates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDittoRouter[]\",\"name\":\"routers_\",\"type\":\"address[]\"}],\"name\":\"addRouters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isPrivatePool\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"templateIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeLp\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeAdmin\",\"type\":\"uint96\"},{\"internalType\":\"uint128\",\"name\":\"delta\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"basePrice\",\"type\":\"uint128\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIdList\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"initialTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"templateInitData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"referrer\",\"type\":\"bytes\"}],\"internalType\":\"struct PoolTemplate\",\"name\":\"poolTemplate_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"templateIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"templateInitData\",\"type\":\"bytes\"}],\"internalType\":\"struct PoolManagerTemplate\",\"name\":\"poolManagerTemplate_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"templateIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"templateInitData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"liquidityDepositPermissionData\",\"type\":\"bytes\"}],\"internalType\":\"struct PermitterTemplate\",\"name\":\"permitterTemplate_\",\"type\":\"tuple\"}],\"name\":\"createDittoPool\",\"outputs\":[{\"internalType\":\"contract IDittoPool\",\"name\":\"dittoPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpId\",\"type\":\"uint256\"},{\"internalType\":\"contract IPoolManager\",\"name\":\"poolManager\",\"type\":\"address\"},{\"internalType\":\"contract IPermitter\",\"name\":\"permitter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolFee\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"}],\"name\":\"isWhitelistedRouter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpNft\",\"outputs\":[{\"internalType\":\"contract LpNft\",\"name\":\"lpNft_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permitterTemplates\",\"outputs\":[{\"internalType\":\"contract IPermitter[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolManagerTemplates\",\"outputs\":[{\"internalType\":\"contract IPoolManager[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTemplates\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LpNft\",\"name\":\"lpNft_\",\"type\":\"address\"}],\"name\":\"setLpNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"feeProtocol_\",\"type\":\"uint96\"}],\"name\":\"setProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeProtocolRecipient_\",\"type\":\"address\"}],\"name\":\"setProtocolFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DittoPoolFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008a036d6350a9794ae94b486a516cca7b9d80c0db000000000000000000000000d196938d24e4b223f445c90e82118545411142c500000000000000000000000000000000000000000000000000005af3107a400000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000260000000000000000000000000000000000000000000000000000000000000000900000000000000000000000027e3d0b88403e65fe051a16efa19af66df26ba9a000000000000000000000000cf5e1da991988b69392301a95ca57ce20165673600000000000000000000000091359c7bd3428484cf31ca43465cdeb2ba048f9a000000000000000000000000fd9d485cfa73f94403685909d1b58cb8e2ce6c010000000000000000000000006317c322cd1bd2535728bed5cdb183f21b36cf13000000000000000000000000f40e36669cf5a44bf232150a2c86dfeb13afe2b900000000000000000000000089731e37785ea940d7329e34ffd4587a14fdcd000000000000000000000000001ef36ddfa0158bd8caa1935fe11ea6c4f387f1060000000000000000000000001b6130e57f983b3c3faccbceca4958665d657bb100000000000000000000000000000000000000000000000000000000000000020000000000000000000000006c1c3012f6ac0dbb750e33f93e1ba350012a6653000000000000000000000000aa85f347b25fb61175ff7d89a5cb79674249e7b900000000000000000000000000000000000000000000000000000000000000010000000000000000000000004dfd894ce9959e1887f4b859590b85c1eb2f62a8", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}