{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"EEFI_Furnace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\n/* ========== Requirements and Imports ========== \\n================================================\\n*/\\n\\npragma solidity 0.8.9;\\n\\nimport {IWETH} from \\\"IERCWETHInterfaces.sol\\\";\\nimport {IEEFIToken} from \\\"IERCWETHInterfaces.sol\\\";\\nimport {ITokenRewards} from \\\"ITokenRewards.sol\\\";\\nimport {IPodToken} from \\\"IPodToken.sol\\\";\\nimport \\\"Ownable.sol\\\";\\nimport \\\"TransferHelper.sol\\\";\\n\\n/* ========== Contract ========== \\n=================================\\n*/\\n\\ncontract EEFIFurnace is Ownable {\\n    // State Variables //\\n\\n    //Addresses\\n    address private constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address private constant _EEFI = 0x857FfC55B1Aa61A7fF847C82072790cAE73cd883;\\n    address private constant _USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n    address private constant _PEAS = 0x02f92800F57BCD74066F5709F1Daa1A4302Df875;\\n\\n    //New partner address (receives fees)\\n    address public newPartnerAddress;\\n\\n    //Treasury address\\n    address payable immutable TREASURY =\\n        payable(0xf950a86013bAA227009771181a885E369e158da3);\\n\\n    //Interfaces //\\n    IWETH public constant weth = IWETH(_WETH);\\n    IEEFIToken public constant eefi = IEEFIToken(_EEFI);\\n    ITokenRewards public podTokenRewardsContract;\\n    IPodToken public podTokenContract;\\n\\n    //PTokens/PEAS in contract are retained by default\\n    bool public sendToTreasury = false;\\n\\n    //Events //\\n    event EEFIBurn(address source, uint256 amount);\\n    event PEASRewardsClaimed(address destination, uint256 amount);\\n    event PEASRewardsTransferred(address destination, uint256 amount);\\n    event PTokenUnwrapped(address asset, uint256 amount);\\n    event PartnerAddressChanged(address newAddress);\\n    event PodRewardsAndTokenContractsChanged(\\n        ITokenRewards newpodTokenRewardsContract,\\n        IPodToken newpodTokenContract\\n    );\\n\\n    constructor(\\n        ITokenRewards _podTokenRewardsContract, // pToken LP Pool Rewards Contract\\n        IPodToken _podTokenContract // pToken Contract\\n    ) {\\n        require(\\n            address(_podTokenRewardsContract) != address(0),\\n            \\\"EEFIFurnance: Invalid pod token rewards contract address.\\\"\\n        );\\n\\n        require(\\n            address(_podTokenContract) != address(0),\\n            \\\"EEFIFurnance: Invalid pod token contract address.\\\"\\n        );\\n\\n        podTokenRewardsContract = _podTokenRewardsContract;\\n\\n        podTokenContract = _podTokenContract;\\n    }\\n\\n    /**\\n     * @notice Modifier to restrict certain functions to multisig only (Treasury) calls\\n     * @dev Reverts if the caller is not the Treasury.\\n     */\\n    modifier multiSigOnly() {\\n        require(msg.sender == TREASURY, \\\"EEFIFurnance: Multisig not caller\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Re-set rewards and pod token addresses\\n     * @dev Only owner can initiate token and rewards address changes\\n     */\\n    function resetRewardsAndTokenAddresses(\\n        ITokenRewards _newRewardsContract,\\n        IPodToken _newPodTokenContract\\n    ) external onlyOwner {\\n        podTokenRewardsContract = _newRewardsContract;\\n\\n        podTokenContract = _newPodTokenContract;\\n\\n        emit PodRewardsAndTokenContractsChanged(\\n            _newRewardsContract,\\n            _newPodTokenContract\\n        );\\n    }\\n\\n    //Transfer ERC20s from contract //\\n    /**\\n     * @notice Transfer deposited assets from contract\\n     * @dev Reverts if caller is not the Treasury (multisig)\\n     */\\n    function transferAssetsFromFurnance(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) public multiSigOnly {\\n        uint256 erc20balance = token.balanceOf(address(this));\\n        require(\\n            amount <= erc20balance,\\n            \\\"EEFIFurnance: Balance too low to transfer token\\\"\\n        );\\n        TransferHelper.safeTransfer(address(token), to, amount);\\n    }\\n\\n    //Convert Assets sent to Furnance to WETH Using 0x //\\n\\n    /**\\n     * @notice Convert non-WETH asset to WETH using 0x.\\n     */\\n    function _convertAssetToWETH(\\n        bytes calldata swapCallData,\\n        address spender,\\n        address payable swapTarget,\\n        IERC20 sellToken,\\n        IWETH buyToken,\\n        uint256 sellAmount\\n    ) internal {\\n        // Give `spender` an allowance to spend this contract's `sellToken`.\\n        // Note that for some tokens (e.g., USDT, KNC), any existing\\n        // allowance must be set to 0, before being able to update it.\\n\\n        require(buyToken == weth, \\\"EEFIFurnance: Buy token not WETH.\\\");\\n\\n        if (address(sellToken) == _USDT) {\\n            //Reset approval to 0\\n            uint256 initialUSDTApprovalAmount = 0;\\n\\n            TransferHelper.safeApprove(\\n                address(sellToken),\\n                address(spender),\\n                initialUSDTApprovalAmount\\n            );\\n        }\\n\\n        //Approve WETH for intermediate step swaps\\n        TransferHelper.safeApprove(\\n            address(weth),\\n            address(spender),\\n            type(uint256).max\\n        );\\n\\n        //Approve sell token for sell amount\\n        TransferHelper.safeApprove(\\n            address(sellToken),\\n            address(spender),\\n            sellAmount\\n        );\\n\\n        // Call the encoded swap function at `swapTarget`,\\n        (bool success, ) = swapTarget.call{value: msg.value}(swapCallData);\\n        require(success, \\\"EEFIFurnance: Swap failed. Low balance / error.\\\");\\n    }\\n\\n    /**\\n     * @notice Convert non-WETH asset sent to Furnace to WETH.\\n     * @dev Only owner can initiate swap. Owner does not have access to swapped assets.\\n     */\\n    function convertAssetToWETH(\\n        bytes calldata swapCallData,\\n        address spender,\\n        address payable swapTarget,\\n        IERC20 sellToken,\\n        IWETH buyToken,\\n        uint256 sellAmount\\n    ) external payable onlyOwner {\\n        _convertAssetToWETH(\\n            swapCallData,\\n            spender,\\n            swapTarget,\\n            sellToken,\\n            buyToken,\\n            sellAmount\\n        );\\n    }\\n\\n    //Sell contract WETH for EEFI and Burn //\\n\\n    /**\\n     * @notice Purchase EEFI using contract WETH and burn asset.\\n     * @dev Only owner can initiate swap and burn. Requires that contract has WETH and permission to burn EEFI.\\n     */\\n    function buyAndBurnEEFI(\\n        bytes calldata swapCallData,\\n        address spender,\\n        address payable swapTarget,\\n        IWETH sellToken,\\n        IEEFIToken buyToken\\n    ) external payable onlyOwner {\\n        //Trade WETH for EEFI //\\n\\n        require(sellToken == weth, \\\"EEFIFurnance: Sell token not WETH.\\\");\\n        require(buyToken == eefi, \\\"EEFIFurnance: Buy token not EEFI.\\\");\\n        require(\\n            weth.balanceOf(address(this)) > 0,\\n            \\\"EEFIFurnance: No WETH available to trade\\\"\\n        );\\n\\n        //Approve WETH for trade\\n        TransferHelper.safeApprove(\\n            address(weth),\\n            address(spender),\\n            type(uint256).max\\n        );\\n\\n        // Call the encoded swap function at `swapTarget`,\\n        (bool success, ) = swapTarget.call{value: msg.value}(swapCallData);\\n        require(success, \\\"EEFIFurnance: Swap failed. Low balance / error.\\\");\\n\\n        //Burn Swapped EEFI //\\n        uint256 _contractEEFIAmount = eefi.balanceOf(address(this));\\n\\n        require(\\n            _contractEEFIAmount > 0,\\n            \\\"EEFIFurnance: Insufficient EEFI in contract to burn\\\"\\n        );\\n\\n        eefi.burn(_contractEEFIAmount);\\n        emit EEFIBurn(address(this), _contractEEFIAmount);\\n    }\\n\\n    //Claim Peapods LP Rewards and Convert to WETH //\\n\\n    /**\\n     * @notice Claim PEAS LP token rewards and Convert to WETH\\n     * @dev Only owner can initiate claim. Owner does not have access to claimed PEAS\\n     */\\n\\n    function claimPEASAndConvertToWETH(\\n        address claimAddress,\\n        uint256 claimableReward,\\n        bytes calldata swapCallData,\\n        address spender,\\n        address payable swapTarget,\\n        IERC20 sellToken,\\n        IWETH buyToken,\\n        uint256 sellAmount,\\n        uint256 buyAmount,\\n        bool sendWETHToTreasury\\n    ) external payable onlyOwner {\\n        //Claim PEAS rewards\\n\\n        require(claimableReward > 0, \\\"EEFIFurnance: No rewards to claim\\\");\\n        require(buyToken == weth, \\\"EEFIFurnance: Buy token not WETH\\\");\\n\\n        podTokenRewardsContract.claimReward(claimAddress);\\n\\n        emit PEASRewardsClaimed(claimAddress, claimableReward);\\n\\n        uint256 peasTokenBalance = IERC20(_PEAS).balanceOf(address(this));\\n\\n        require(\\n            peasTokenBalance > 0,\\n            \\\"EEFIFurnance: No rewards to convert\\\" //\\n        );\\n\\n        //Convert PEAS to WETH //\\n        _convertAssetToWETH(\\n            swapCallData,\\n            spender,\\n            swapTarget,\\n            sellToken,\\n            buyToken,\\n            sellAmount\\n        );\\n\\n        if (sendWETHToTreasury == true) {\\n            TransferHelper.safeTransfer(_WETH, TREASURY, buyAmount);\\n        }\\n    }\\n\\n    // Claim Peapods Rewards and Send to Treasury //\\n\\n    /**\\n     * @notice Claim PEAS LP token rewards (if rewards are deposited to contract, send to Treasury)\\n     * @dev Only owner can initiate claim.\\n     */\\n    function claimLPRewardsAndSendToTreasury(\\n        address claimAddress,\\n        uint256 claimableReward\\n    ) external payable onlyOwner {\\n        //Claim PEAS rewards //\\n\\n        require(claimableReward > 0, \\\"EEFIFurnance: No rewards to claim\\\");\\n\\n        podTokenRewardsContract.claimReward(claimAddress);\\n\\n        emit PEASRewardsClaimed(claimAddress, claimableReward);\\n\\n        //If any PEAS rewards are in contract, transfer to Treasury\\n        uint256 peasTokenBalance = IERC20(_PEAS).balanceOf(address(this));\\n\\n        if (peasTokenBalance > 0) {\\n            TransferHelper.safeTransfer(_PEAS, TREASURY, peasTokenBalance);\\n            emit PEASRewardsTransferred(TREASURY, peasTokenBalance);\\n        }\\n    }\\n\\n    // Unwrap pToken and optionally burn EEFI //\\n\\n    /**\\n     * @notice Unwrap pToken; If token is EEFI burn it; Optionally send pAsset to Treasury\\n     * @dev Only owner can initiate unwrap.\\n     */\\n    function unWrapAndBurnPToken(\\n        address pTokenToUnwrap,\\n        uint8 tokenIndex,\\n        bool sendPTokenToTreasury\\n    ) external onlyOwner {\\n        //Unwrap PToken //\\n\\n        uint256 pTokenAmount = podTokenContract.balanceOf(address(this));\\n        address[] memory unwrappedPToken = new address[](1);\\n        uint8[] memory unwrapPercentage = new uint8[](1);\\n\\n        unwrappedPToken[0] = pTokenToUnwrap;\\n        unwrapPercentage[0] = 100;\\n\\n        require(\\n            pTokenAmount > 0,\\n            \\\"EEFIFurnance: Not enough pToken in contract to unwrap\\\"\\n        );\\n\\n        podTokenContract.debond(\\n            pTokenAmount,\\n            unwrappedPToken,\\n            unwrapPercentage\\n        );\\n\\n        if (sendPTokenToTreasury == true) {\\n            //Retrive token address associated with pod asset index\\n            (address podTokenAddress, , , , ) = podTokenContract.indexTokens(\\n                tokenIndex\\n            );\\n\\n            uint256 unwrappedTokenAmount = IERC20(podTokenAddress).balanceOf(\\n                address(this)\\n            );\\n\\n            TransferHelper.safeTransfer(\\n                podTokenAddress,\\n                TREASURY,\\n                unwrappedTokenAmount\\n            );\\n        }\\n\\n        //Burn unwrapped EEFI (or EEFI in contract) //\\n\\n        uint256 _contractEEFIAmount = eefi.balanceOf(address(this));\\n\\n        if (_contractEEFIAmount > 0) {\\n            eefi.burn(_contractEEFIAmount);\\n            emit EEFIBurn(address(this), _contractEEFIAmount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Re-set partner address (receives fees)\\n     * @dev Only owner can initiate partner address change\\n     */\\n    function resetPartnerAddress(address _newPartner) external onlyOwner {\\n        newPartnerAddress = _newPartner;\\n\\n        podTokenContract.setPartner(newPartnerAddress);\\n        emit PartnerAddressChanged(_newPartner);\\n    }\\n}\\n\"\r\n    },\r\n    \"IERCWETHInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.23 <0.9.0;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function transfer(address recipient, uint amount) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint);\\n\\n    function approve(address spender, uint amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n    function withdraw(uint amount) external;\\n}\\n\\ninterface IEEFIToken is IERC20 {\\n    function mint(address to, uint256 amount) external;\\n    function burn(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"ITokenRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.23 <0.9.0;\\n\\ninterface ITokenRewards {\\n    \\n    function getUnpaid(address _wallet) external returns (uint256);\\n    function claimReward(address wallet) external;\\n}\\n\"\r\n    },\r\n    \"IPodToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.23 <0.9.0;\\n\\ninterface IPodToken {\\n    function balanceOf(address account) external view returns (uint);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function debond(uint256 _amount, address[] memory, uint8[] memory) external;\\n    function indexTokens(uint256) external view returns (address _address, uint256 _weight, uint256 _basePrice, address _c1, uint256 _q1);\\n    function transfer(address recipient, uint amount) external returns (bool);\\n    function setPartner(address _partner) external;\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nimport \\\"IERC20.sol\\\";\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"EEFI_Furnace.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ITokenRewards\",\"name\":\"_podTokenRewardsContract\",\"type\":\"address\"},{\"internalType\":\"contract IPodToken\",\"name\":\"_podTokenContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EEFIBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PEASRewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PEASRewardsTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PTokenUnwrapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"PartnerAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ITokenRewards\",\"name\":\"newpodTokenRewardsContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IPodToken\",\"name\":\"newpodTokenContract\",\"type\":\"address\"}],\"name\":\"PodRewardsAndTokenContractsChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"contract IWETH\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"contract IEEFIToken\",\"name\":\"buyToken\",\"type\":\"address\"}],\"name\":\"buyAndBurnEEFI\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"claimableReward\",\"type\":\"uint256\"}],\"name\":\"claimLPRewardsAndSendToTreasury\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"claimableReward\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"contract IWETH\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sendWETHToTreasury\",\"type\":\"bool\"}],\"name\":\"claimPEASAndConvertToWETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"sellToken\",\"type\":\"address\"},{\"internalType\":\"contract IWETH\",\"name\":\"buyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"}],\"name\":\"convertAssetToWETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eefi\",\"outputs\":[{\"internalType\":\"contract IEEFIToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newPartnerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"podTokenContract\",\"outputs\":[{\"internalType\":\"contract IPodToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"podTokenRewardsContract\",\"outputs\":[{\"internalType\":\"contract ITokenRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPartner\",\"type\":\"address\"}],\"name\":\"resetPartnerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITokenRewards\",\"name\":\"_newRewardsContract\",\"type\":\"address\"},{\"internalType\":\"contract IPodToken\",\"name\":\"_newPodTokenContract\",\"type\":\"address\"}],\"name\":\"resetRewardsAndTokenAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendToTreasury\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferAssetsFromFurnance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pTokenToUnwrap\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndex\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"sendPTokenToTreasury\",\"type\":\"bool\"}],\"name\":\"unWrapAndBurnPToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EEFIFurnace", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ec2eb58b1f6612021029fbd004f3aff42ee4634c0000000000000000000000000bcfb6b59b76fcca52f4daa39223f97042460ccc", "EVMVersion": "istanbul", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}