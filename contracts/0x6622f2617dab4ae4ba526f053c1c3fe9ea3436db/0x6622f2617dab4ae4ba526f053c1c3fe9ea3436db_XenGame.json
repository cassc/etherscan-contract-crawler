{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"XengameV2Live/xenGameV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/*\\r\\n\\r\\n\\r\\n\u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\r\\n\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\r\\n \u255a\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \\r\\n \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \\r\\n\u2588\u2588\u2554\u255d \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\r\\n\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\r\\n\\r\\n\\r\\n\\r\\nThis project has been developed under the guidelines set forth by the Fair Crypto Foundation, adhering to its first principles of self-custody, transparency, consensus-based trust, and permissionless value exchange. Accordingly, this project values the ethos of decentralization and exercises these principles by not incorporating any administrative access keys or functions.\\r\\n\\r\\nGiven these considerations, it is important to note that all users are encouraged to conduct their own research and due diligence prior to using this contract. Potential users should understand, evaluate, and accept the inherent risks associated with its use, owing to the blockchain and smart contract technology underpinning it.\\r\\n\\r\\nPlease be advised, due to the intentional absence of administrative access keys in this smart contract, and the elimination of central authority, the original developers or contributors maintain no control over the system once it is deployed, placing them on an equivalent footing with any other user.\\r\\n\\r\\nThe developers, hence, assume no liability or responsibility whatsoever for any future errors, exploits, or security breaches that may occur, unforeseen or otherwise. This software is distributed \\\"AS-IS\\\" without warranties or conditions of any kind, either expressed or implied.\\r\\n\\r\\nAs an open-source project, all users participate at their own risk and assume full responsibility for all actions undertaken in connection with this contract, including but not limited to any loss or damage incurred. Each user, by engaging with the contract and its functionalities, comprehensively and irrevocably accepts this accountability.\\r\\n\\r\\nMoreover, potential and existing users should be fully aware of and stay compliant with the laws and regulations in their respective jurisdictions. It is the sole responsibility of each user to understand and adhere to the relevant laws and regulations applicable in their location.\\r\\n\\r\\nPlease be advised that interactions with cryptocurrencies and blockchain-based technologies come with significant risk. Users should always exercise utmost caution, and use this contract only after fully appreciating the implications on both a technical and legal level.\\r\\n\\r\\nBy using this contract, the user explicitly acknowledges and agrees to these terms and conditions. Failure to heed these disclaimers and instructions may lead to adversarial consequences for which neither the developers nor any other associated party shall be held responsible.\\r\\n\\r\\n             \\r\\n\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IXENnftContract {\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n}\\r\\n\\r\\ninterface INFTRegistry {\\r\\n    function registerNFT(uint256 tokenId) external;\\r\\n    function isNFTRegistered(uint256 tokenId) external view returns (bool);\\r\\n    function addToPool() external payable;\\r\\n}\\r\\n\\r\\ninterface XENBurn {\\r\\n    function deposit() external payable returns (bool);\\r\\n}\\r\\n\\r\\ninterface IPlayerNameRegistry {\\r\\n    function registerPlayerName(address _address, string memory _name) external payable;\\r\\n    function getPlayerAddress(string memory _name) external view returns (address);\\r\\n    function getPlayerFirstName(address playerAddress) external view returns (string memory);\\r\\n}\\r\\n\\r\\ncontract XenGame {\\r\\n    IXENnftContract public nftContract;\\r\\n    INFTRegistry public nftRegistry;\\r\\n    XENBurn public xenBurn;\\r\\n    IPlayerNameRegistry private playerNameRegistry;\\r\\n\\r\\n    uint256 constant KEY_RESET_PERCENTAGE = 1; // 0.001% or 1 basis point\\r\\n    uint256 constant NAME_REGISTRATION_FEE = 20000000000000000; // 0.02 Ether in Wei\\r\\n    uint256 constant KEY_PRICE_INCREMENT_PERCENTAGE = 10; // 0.099% or approx 10 basis points\\r\\n    uint256 constant REFERRAL_REWARD_PERCENTAGE = 1000; // 10% or 1000 basis points\\r\\n    uint256 constant NFT_POOL_PERCENTAGE = 500; // 5% or 500 basis points\\r\\n    uint256 constant ROUND_GAP = 24 hours;// 24 hours round gap\\r\\n    uint256 constant EARLY_BUYIN_DURATION = 300; // *********************************************************** updated to 5 min  \\r\\n\\r\\n    uint256 constant KEYS_FUND_PERCENTAGE = 5000; // 50% or 5000 basis points\\r\\n    uint256 constant JACKPOT_PERCENTAGE = 3000; // 30% or 3000 basis points\\r\\n    uint256 constant BURN_FUND_PERCENTAGE = 1500; // 15% or 1500 basis points\\r\\n    uint256 constant APEX_FUND_PERCENTAGE = 500; // 5% or 5000 basis points\\r\\n    uint256 constant PRECISION = 10 ** 18;\\r\\n    address private playerNames;\\r\\n    uint256 private loadedPlayers = 0;\\r\\n    bool public migrationLocked = false;\\r\\n    bool public migrationPhaseTwoCompleted = false;\\r\\n\\r\\n    \\r\\n    struct Player {\\r\\n        mapping(uint256 => uint256) keyCount; //round to keys\\r\\n        mapping(uint256 => uint256) burntKeys;\\r\\n        mapping(uint256 => uint256) earlyBuyinPoints; // Track early buyin points for each round\\r\\n        uint256 referralRewards;\\r\\n        string lastReferrer; // Track last referrer name\\r\\n        mapping(uint256 => uint256) lastRewardRatio; // New variable\\r\\n        uint256 keyRewards;\\r\\n        uint256 numberOfReferrals; \\r\\n    }\\r\\n\\r\\n    struct Round {\\r\\n        uint256 totalKeys ;\\r\\n        uint256 burntKeys; \\r\\n        \\r\\n        uint256 start;\\r\\n        uint256 end;\\r\\n        address activePlayer;\\r\\n        bool ended;\\r\\n        bool isEarlyBuyin;\\r\\n        uint256 keysFunds; // not used in logic, old code \\r\\n        uint256 jackpot; // ETH for the jackpot\\r\\n        uint256 earlyBuyinEth; // Total ETH received during the early buy-in period\\r\\n        uint256 lastKeyPrice; // The last key price for this round\\r\\n        uint256 rewardRatio;\\r\\n        uint256 BurntKeyFunds;\\r\\n        uint256 uniquePlayers;\\r\\n        address[] playerAddresses;\\r\\n        \\r\\n    }\\r\\n\\r\\n    uint256 public currentRound = 0;\\r\\n    mapping(address => Player) public players;\\r\\n    mapping(uint256 => Round) public rounds;\\r\\n    mapping(uint256 => mapping(address => bool)) public isPlayerInRound;\\r\\n    mapping(string => address) public nameToAddress;\\r\\n    mapping(address => mapping(uint256 => bool)) public earlyKeysReceived;\\r\\n\\r\\n    constructor(\\r\\n        \\r\\n    \\r\\n    ) {\\r\\n\\r\\n        \\r\\n\\r\\n        nftContract = IXENnftContract(0x0a252663DBCc0b073063D6420a40319e438Cfa59);  // Eth address\\r\\n        nftRegistry = INFTRegistry(0xEDa159A0339826C96c30D39A1be8588d82212395); // X1 Eth address\\r\\n        xenBurn = XENBurn(0x573E18d9dF2496B1768139Eb4c712B9b086be294); // Eth address\\r\\n        playerNameRegistry = IPlayerNameRegistry(0x68317FE2590DC605C730628fb645DE0F17F86BFc); // Eth address\\r\\n        playerNames = 0x68317FE2590DC605C730628fb645DE0F17F86BFc; // Eth address\\r\\n\\r\\n        currentRound = 1;\\r\\n        rounds[currentRound].totalKeys = 10097300000000000000000000;\\r\\n        rounds[currentRound].burntKeys = 338175000000000000000000;\\r\\n        rounds[currentRound].jackpot = 63566409521227276389;\\r\\n        rounds[currentRound].earlyBuyinEth = 59101124779840297779;\\r\\n        rounds[currentRound].lastKeyPrice = 44087673862494;\\r\\n        rounds[currentRound].rewardRatio = 994363746378;\\r\\n        rounds[currentRound].uniquePlayers = 198;        \\r\\n        rounds[currentRound].start = 1694966400;     \\r\\n        rounds[currentRound].end = block.timestamp + 12 hours;  // Update to set new end time on migration        \\r\\n        rounds[currentRound].ended = false;\\r\\n\\r\\n        \\r\\n        \\r\\n    }\\r\\n\\r\\n    function migrateUserBasicData(\\r\\n        address[] calldata playeraddresses,\\r\\n        uint256[] calldata playerRound1KeyCount,\\r\\n        uint256[] calldata playerRound1BurntKeys,\\r\\n        uint256[] calldata playerRound1EarlyBuyinPoints,\\r\\n        string[] calldata playerLastReferrer\\r\\n    ) external {\\r\\n        require(!migrationLocked, \\\"Migration has been locked\\\");\\r\\n        require(loadedPlayers + playeraddresses.length == 198, \\\"Cannot exceed 198 users\\\");\\r\\n\\r\\n        for (uint i = 0; i < 198; i++) {\\r\\n            players[playeraddresses[i]].keyCount[1] = playerRound1KeyCount[i];\\r\\n\\r\\n            if (playerRound1BurntKeys[i] > 0) {\\r\\n                players[playeraddresses[i]].burntKeys[1] = playerRound1BurntKeys[i];\\r\\n            }\\r\\n            if (playerRound1EarlyBuyinPoints[i] > 0) {\\r\\n                players[playeraddresses[i]].earlyBuyinPoints[1] = playerRound1EarlyBuyinPoints[i];\\r\\n            }\\r\\n\\r\\n            if (bytes(playerLastReferrer[i]).length > 0) {\\r\\n                players[playeraddresses[i]].lastReferrer = playerLastReferrer[i];\\r\\n            }\\r\\n\\r\\n            isPlayerInRound[currentRound][playeraddresses[i]] = true;\\r\\n\\r\\n            rounds[currentRound].playerAddresses.push(playeraddresses[i]);\\r\\n            loadedPlayers++;\\r\\n            if (loadedPlayers == 198) {\\r\\n                migrationLocked = true;\\r\\n            }\\r\\n        }\\r\\n    } \\r\\n\\r\\n    function migrateUserReferralAndRewardData(\\r\\n        address[] calldata playeraddresses,\\r\\n        uint256[] calldata playerReferralRewards,\\r\\n        uint256[] calldata playerRound1RewardRatio,\\r\\n        uint256[] calldata playerKeyRewards,\\r\\n        uint256[] calldata playerNumberOfReferrals\\r\\n        \\r\\n    ) external {\\r\\n        require(migrationLocked, \\\"Migrate base users first\\\");\\r\\n        require(loadedPlayers == 198, \\\"All players must be loaded first\\\");\\r\\n        require(!migrationPhaseTwoCompleted, \\\"Phase two migration already completed\\\");\\r\\n\\r\\n        for (uint i = 0; i < 198; i++) {\\r\\n            if (playerReferralRewards[i] > 0) {\\r\\n                players[playeraddresses[i]].referralRewards = playerReferralRewards[i];\\r\\n            }\\r\\n\\r\\n            players[playeraddresses[i]].lastRewardRatio[1] = playerRound1RewardRatio[i];\\r\\n\\r\\n            \\r\\n\\r\\n            players[playeraddresses[i]].keyRewards = playerKeyRewards[i];\\r\\n\\r\\n            if (playerNumberOfReferrals[i] > 0) {\\r\\n                players[playeraddresses[i]].numberOfReferrals = playerNumberOfReferrals[i];\\r\\n            }\\r\\n\\r\\n            if (players[playeraddresses[i]].earlyBuyinPoints[1] > 0 && players[playeraddresses[i]].keyCount[1] > 0) {\\r\\n                earlyKeysReceived[playeraddresses[i]][1] = true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        migrationPhaseTwoCompleted = true;\\r\\n    }  \\r\\n\\r\\n    function seedEth() external payable {\\r\\n        // This function is only here to reseed the eth from the migration         \\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Allows a player to buy keys with a referral.\\r\\n    * @param _referrerName The name of the referrer.\\r\\n    * @param _numberOfKeys The number of keys to purchase.\\r\\n    */\\r\\n    function buyWithReferral(string memory _referrerName, uint256 _numberOfKeys) public payable {\\r\\n        Player storage player = players[msg.sender];\\r\\n\\r\\n        // Get the player and referrer information\\r\\n        string memory referrerName = bytes(_referrerName).length > 0 ? _referrerName : player.lastReferrer;\\r\\n        address referrer = playerNameRegistry.getPlayerAddress(referrerName);\\r\\n\\r\\n        Round storage round = rounds[currentRound];\\r\\n\\r\\n            // Check if the player is not already in the current round\\r\\n            if (!isPlayerInRound[currentRound][msg.sender]) {\\r\\n                // Add the player address to the list of player addresses for the current round\\r\\n                round.playerAddresses.push(msg.sender);\\r\\n                // Set isPlayerInRound to true for the current player in the current round\\r\\n                isPlayerInRound[currentRound][msg.sender] = true;\\r\\n                // Increment the uniquePlayers count for the current round\\r\\n                round.uniquePlayers++;\\r\\n            }\\r\\n\\r\\n            // Calculate the referral reward as a percentage of the incoming ETH\\r\\n            uint256 referralReward = (msg.value * REFERRAL_REWARD_PERCENTAGE) / 10000; // 10% of the incoming ETH\\r\\n\\r\\n            if (referralReward > 0) {\\r\\n                // Added check here to ensure referral reward is greater than 0\\r\\n                uint256 splitReward = referralReward / 2; // Split the referral reward\\r\\n\\r\\n                // Add half of the referral reward to the referrer's stored rewards\\r\\n                players[referrer].referralRewards += splitReward;\\r\\n                players[referrer].numberOfReferrals++;\\r\\n\\r\\n                if (referrer != address(0)){\\r\\n                // Add the other half of the referral reward to the player's stored rewards\\r\\n                player.referralRewards += splitReward;\\r\\n                }\\r\\n\\r\\n                emit ReferralPaid(msg.sender, referrer, splitReward, block.timestamp);\\r\\n            }\\r\\n\\r\\n            \\r\\n            if (_numberOfKeys > 0) {\\r\\n                buyCoreWithKeys(msg.value, _numberOfKeys);\\r\\n            } else {\\r\\n                buyCore(msg.value);\\r\\n            }\\r\\n\\r\\n            // Set the referrer name for the player\\r\\n            player.lastReferrer = referrerName;\\r\\n        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Handles the core logic of purchasing keys based on the amount of ETH sent.\\r\\n    * @param _amount The amount of ETH sent by the player.\\r\\n    */\\r\\n    function buyCore(uint256 _amount) private {\\r\\n        // Check if the round is active or has ended\\r\\n        require(isRoundActive() || isRoundEnded(), \\\"Cannot purchase keys during the round gap\\\");\\r\\n\\r\\n        uint256 _roundId = currentRound;\\r\\n        Round storage round = rounds[currentRound];\\r\\n\\r\\n        // If the round has ended and there are no total keys, set a new end time for the round\\r\\n        if (isRoundEnded()) {\\r\\n\\r\\n            if (round.totalKeys == 0){\\r\\n                round.end = block.timestamp + 600;\\r\\n                players[msg.sender].keyRewards += (_amount * 90 / 100);\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            endRound();\\r\\n            startNewRound();\\r\\n            players[msg.sender].keyRewards += (_amount * 90 / 100);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // If the round is active\\r\\n        if (isRoundActive()) {\\r\\n            if (block.timestamp <= round.start + EARLY_BUYIN_DURATION) {\\r\\n                // If we are in the early buy-in period, follow early buy-in logic\\r\\n                buyCoreEarly(_amount);\\r\\n            } else if (!round.ended) {\\r\\n                \\r\\n                // Check if this is the first transaction after the early buy-in period\\r\\n                if (round.isEarlyBuyin) {\\r\\n                    updateTotalKeysForRound();\\r\\n                    finalizeEarlyBuyinPeriod();\\r\\n                }\\r\\n\\r\\n                // Check if the last key price exceeds the jackpot threshold and reset it if necessary\\r\\n                if (round.lastKeyPrice > calculateJackpotThreshold()) {\\r\\n                    uint256 newPrice = resetPrice();\\r\\n                    round.lastKeyPrice = newPrice;\\r\\n                    emit PriceReset(msg.sender, newPrice, block.timestamp);\\r\\n                }\\r\\n\\r\\n                // Calculate the maximum number of keys to purchase and the total cost\\r\\n                (uint256 maxKeysToPurchase, ) = calculateMaxKeysToPurchase(_amount);\\r\\n                    \\r\\n\\r\\n                // Process users rewards for the current round\\r\\n                processRewards(_roundId);\\r\\n\\r\\n                // Set the last reward ratio for the player in the current round\\r\\n                if (players[msg.sender].lastRewardRatio[_roundId] == 0) {\\r\\n                    players[msg.sender].lastRewardRatio[_roundId] = round.rewardRatio;\\r\\n                }\\r\\n\\r\\n                // Process the key purchase with the maximum number of keys and total cost\\r\\n                processKeyPurchase(maxKeysToPurchase, _amount);\\r\\n\\r\\n                // Set the active player for the round\\r\\n                round.activePlayer = msg.sender;\\r\\n\\r\\n                // Adjust the end time of the round based on the number of keys purchased\\r\\n                adjustRoundEndTime(maxKeysToPurchase);\\r\\n            }\\r\\n        } \\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Handles the core logic of purchasing keys with a specified number of keys and amount of ETH.\\r\\n    * @param _amount The amount of ETH sent by the player.\\r\\n    * @param _numberOfKeys The number of keys to purchase.\\r\\n    */\\r\\n    function buyCoreWithKeys(uint256 _amount, uint256 _numberOfKeys) private {\\r\\n        // Check if the round is active or has ended\\\\\\r\\n        require(isRoundActive() || isRoundEnded(), \\\"Cannot purchase keys during the round gap\\\");\\r\\n\\r\\n        uint256 _roundId = currentRound;\\r\\n        Round storage round = rounds[currentRound];\\r\\n        // If the round has ended and there are no total keys, set a new end time for the round\\r\\n        if (isRoundEnded()) {\\r\\n\\r\\n            if (round.totalKeys == 0){\\r\\n                round.end = block.timestamp + 600;\\r\\n                players[msg.sender].keyRewards += (_amount * 90 / 100);\\r\\n                return;\\r\\n            }\\r\\n            \\r\\n            // End the current round and start a new one\\r\\n            endRound();\\r\\n            startNewRound();\\r\\n            players[msg.sender].keyRewards += (_amount * 90 / 100);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        if (isRoundActive()) {\\r\\n\\r\\n            if (block.timestamp <= round.start + EARLY_BUYIN_DURATION) {\\r\\n                // If we are in the early buy-in period, follow early buy-in logic\\r\\n                buyCoreEarly(_amount);\\r\\n            } else if (!round.ended) {\\r\\n                // Check if this is the first transaction after the early buy-in period\\r\\n                if (round.isEarlyBuyin) {\\r\\n                    updateTotalKeysForRound();\\r\\n                    finalizeEarlyBuyinPeriod();\\r\\n                }\\r\\n\\r\\n                // Check if the last key price exceeds the jackpot threshold and reset it if necessary\\r\\n                if (round.lastKeyPrice > calculateJackpotThreshold()) {\\r\\n                    uint256 newPrice = resetPrice();\\r\\n                    round.lastKeyPrice = newPrice;\\r\\n                    emit PriceReset(msg.sender, newPrice, block.timestamp);\\r\\n\\r\\n                }\\r\\n\\r\\n                // Calculate cost for _numberOfKeys\\r\\n                uint256 cost = calculatePriceForKeys(_numberOfKeys);\\r\\n                require(cost <= _amount, \\\"Not enough ETH to buy the specified number of keys\\\");\\r\\n\\r\\n                \\r\\n                // Process user rewards for the current round\\r\\n                processRewards(_roundId);\\r\\n\\r\\n                // Set the last reward ratio for the player in the current round if first user key buy. \\r\\n                if (players[msg.sender].lastRewardRatio[_roundId] == 0) {\\r\\n                    players[msg.sender].lastRewardRatio[_roundId] = round.rewardRatio;\\r\\n                }\\r\\n\\r\\n                // Process the key purchase with the specified number of keys and cost\\r\\n                processKeyPurchase(_numberOfKeys, _amount);\\r\\n\\r\\n                // Set the active player for the round\\r\\n                round.activePlayer = msg.sender;\\r\\n\\r\\n                // Adjust the end time of the round based on the number of keys purchased\\r\\n                adjustRoundEndTime(_numberOfKeys);\\r\\n\\r\\n                \\r\\n            }\\r\\n        } \\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Allows a player to purchase keys using their accumulated rewards.\\r\\n    */\\r\\n    function buyKeysWithRewards() public {\\r\\n        // Check if the current round is active\\r\\n        require(isRoundActive(), \\\"Round is not active\\\");\\r\\n\\r\\n        Player storage player = players[msg.sender];\\r\\n\\r\\n        // Check for any early keys\\r\\n        checkForEarlyKeys(currentRound);\\r\\n\\r\\n        // Calculate the player's rewards unprocessed \\r\\n        uint256 reward = (\\r\\n            (player.keyCount[currentRound] / 1 ether)\\r\\n                * (rounds[currentRound].rewardRatio - player.lastRewardRatio[currentRound])\\r\\n        ); // using full keys for reward calc\\r\\n\\r\\n        // Add any processed keyRewards to the calculated reward\\r\\n        reward += player.keyRewards;\\r\\n\\r\\n        // Reset player's keyRewards\\r\\n        player.keyRewards = 0;\\r\\n\\r\\n        require(reward > 0, \\\"No rewards to buy keys with\\\");\\r\\n\\r\\n        // Reset player's lastRewardRatio for the round\\r\\n        player.lastRewardRatio[currentRound] = rounds[currentRound].rewardRatio; //\\r\\n\\r\\n        // Calculate max keys that can be purchased with the reward\\r\\n        (uint256 maxKeysToPurchase,) = calculateMaxKeysToPurchase(reward);\\r\\n\\r\\n        // Make sure there are enough rewards to purchase at least one key\\r\\n        require(maxKeysToPurchase > 0, \\\"Not enough rewards to purchase any keys\\\");\\r\\n\\r\\n        address referrer = playerNameRegistry.getPlayerAddress(players[msg.sender].lastReferrer);\\r\\n                   \\r\\n\\r\\n            // Calculate the referral reward as a percentage of the incoming ETH\\r\\n            uint256 referralReward = (reward * REFERRAL_REWARD_PERCENTAGE) / 10000; // 10% of the incoming ETH\\r\\n\\r\\n            if (referralReward > 0) {\\r\\n                // Added check here to ensure referral reward is greater than 0\\r\\n                uint256 splitReward = referralReward / 2; // Split the referral reward\\r\\n\\r\\n                // Add half of the referral reward to the referrer's stored rewards\\r\\n                players[referrer].referralRewards += splitReward;\\r\\n                players[referrer].numberOfReferrals++;\\r\\n\\r\\n                if (referrer != address(0)){\\r\\n                // Add the other half of the referral reward to the player's stored rewards\\r\\n                player.referralRewards += splitReward;\\r\\n                }\\r\\n\\r\\n                emit ReferralPaid(msg.sender, referrer, splitReward, block.timestamp);\\r\\n            }            \\r\\n            \\r\\n                \\r\\n            \\r\\n        // Buy keys using rewards\\r\\n        buyCore(reward);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Handles the logic of purchasing keys during the early buy-in period.\\r\\n    * @param _amount The amount of ETH sent by the player.\\r\\n    */\\r\\n    function buyCoreEarly(uint256 _amount) private {\\r\\n        // Accumulate the ETH and track the user's early buy-in points\\r\\n\\r\\n        // Calculate the referral reward as a percentage of the incoming ETH\\r\\n        uint256 referralReward = (_amount * REFERRAL_REWARD_PERCENTAGE) / 10000;\\r\\n\\r\\n        // Check if the player's last referrer is not valid, and halve the referral reward\\r\\n        if (playerNameRegistry.getPlayerAddress(players[msg.sender].lastReferrer) == address(0)){\\r\\n            referralReward = (referralReward / 2);\\r\\n        }\\r\\n\\r\\n        // Calculate the amount of ETH without the referral reward\\r\\n        uint256 amount = _amount - referralReward;\\r\\n\\r\\n        // Accumulate the amount of ETH sent during the early buy-in period\\r\\n        rounds[currentRound].earlyBuyinEth += amount;\\r\\n\\r\\n        // Accumulate the early buy-in points for the player\\r\\n        players[msg.sender].earlyBuyinPoints[currentRound] += amount;\\r\\n\\r\\n        // Set the last reward ratio for the player in the current round to 1\\r\\n        players[msg.sender].lastRewardRatio[currentRound] = 1;\\r\\n\\r\\n        // Set isEarlyBuyin to true to indicate the early buy-in period is active\\r\\n        rounds[currentRound].isEarlyBuyin = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Fallback function to handle incoming ETH payments and execute buy or withdraw rewards logic.\\r\\n    */\\r\\nfallback() external payable {\\r\\n    // If the incoming value is 0, withdraw rewards for all rounds\\r\\n    if (msg.value == 0) {\\r\\n        for (uint256 i = 1; i <= currentRound; i++) {\\r\\n            withdrawRewards(i);\\r\\n        }\\r\\n    }\\r\\n    // Call buyWithReferral function with empty referrer name and 0 number of keys\\r\\n    buyWithReferral(\\\"\\\", 0);\\r\\n}\\r\\n\\r\\n/**\\r\\n    * @dev Receive function to handle incoming ETH payments and execute buy or withdraw rewards logic.\\r\\n    */\\r\\nreceive() external payable {\\r\\n    // If the incoming value is 0, withdraw rewards for all rounds\\r\\n    if (msg.value == 0) {\\r\\n        for (uint256 i = 1; i <= currentRound; i++) {\\r\\n            withdrawRewards(i);\\r\\n        }\\r\\n    }\\r\\n    // Call buyWithReferral function with empty referrer name and 0 number of keys\\r\\n    buyWithReferral(\\\"\\\", 0);\\r\\n}\\r\\n\\r\\n    /**\\r\\n    * @dev Checks if the current round is active.\\r\\n    * @return bool indicating whether the round is active or not.\\r\\n    */\\r\\n    function isRoundActive() public view returns (bool) {\\r\\n        uint256 _roundId = currentRound;\\r\\n        return block.timestamp >= rounds[_roundId].start && block.timestamp < rounds[_roundId].end;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Checks if the current round has ended.\\r\\n    * @return bool indicating whether the round has ended or not.\\r\\n    */\\r\\n    function isRoundEnded() public view returns (bool) {\\r\\n        uint256 _roundId = currentRound;\\r\\n        return block.timestamp >= rounds[_roundId].end;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Updates the total number of keys for the current round.\\r\\n    * If there was early buy-in ETH, it adds 10,000,000 keys. Otherwise, it adds 1 key.\\r\\n    */\\r\\n    function updateTotalKeysForRound() private {\\r\\n        // Check if there was early buy-in ETH        \\r\\n        if (rounds[currentRound].earlyBuyinEth > 0) {\\r\\n            // Add 10,000,000 keys to the total keys count for the round\\r\\n            rounds[currentRound].totalKeys += 10000000 ether;\\r\\n\\r\\n        } else {\\r\\n\\r\\n            // Add 1 key to the total keys count for the round if no early buyin.\\r\\n            rounds[currentRound].totalKeys += 1 ether;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Finalizes the early buy-in period by setting necessary variables and adding early buy-in funds to the jackpot.\\r\\n    */\\r\\n    function finalizeEarlyBuyinPeriod() private {\\r\\n        // Set isEarlyBuyin to false to signify the early buy-in period is over\\r\\n        Round storage round = rounds[currentRound];\\r\\n        \\r\\n        round.isEarlyBuyin = false;\\r\\n\\r\\n        // Calculate the last key price for the round\\r\\n        if (round.earlyBuyinEth > 0) {\\r\\n            round.lastKeyPrice = round.earlyBuyinEth / (10 ** 7); // using full keys\\r\\n        } else {\\r\\n            round.lastKeyPrice = 0.000000009 ether; // Set to 0.000000009 ether if there is no early buying ETH or no keys purchased\\r\\n        }\\r\\n\\r\\n        \\r\\n\\r\\n        // Add early buy-in funds to the jackpot\\r\\n        round.jackpot += round.earlyBuyinEth;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Calculates the maximum number of keys that can be purchased and the total cost within a given amount of ETH.\\r\\n    * @param _amount The amount of ETH to spend on keys.\\r\\n    * @return maxKeys The maximum number of keys that can be purchased.\\r\\n    * @return totalCost The total cost in ETH to purchase the maximum number of keys.\\r\\n    */\\r\\n    function calculateMaxKeysToPurchase(uint256 _amount) public view returns (uint256 maxKeys, uint256 totalCost) {\\r\\n        // Fetch the initial price of a key\\r\\n        uint256 initialKeyPrice = getKeyPrice();\\r\\n\\r\\n        // If the user's amount is less than the price of a single key, return as no keys can be bought\\r\\n        if (_amount < initialKeyPrice) {\\r\\n            return (0, 0);\\r\\n        }\\r\\n\\r\\n        // left and right are the boundaries for the binary search of the maximum number of keys that can be bought.\\r\\n        // Initialize the left to zero and right to the maximum number of keys that could be bought if the price never increased.\\r\\n        uint256 left = 0;\\r\\n        uint256 right = _amount / initialKeyPrice;\\r\\n\\r\\n        // Variable to store the total cost of keys\\r\\n        uint256 _totalCost;\\r\\n\\r\\n        // Binary search to find the maximum number of keys the user can buy\\r\\n        while (left < right) {\\r\\n            // Find the mid point\\r\\n            uint256 mid = (left + right) / 2;\\r\\n\\r\\n            // Calculate the cost to purchase mid number of keys\\r\\n            _totalCost = calculatePriceForKeys(mid);\\r\\n            \\r\\n            uint256 nextCost;\\r\\n\\r\\n            // Ensure we don't get an overflow when we add 1 to mid\\r\\n            if (mid + 1 > mid) {\\r\\n                // Calculate the cost to purchase mid + 1 keys\\r\\n                nextCost = calculatePriceForKeys(mid + 1);\\r\\n            }\\r\\n\\r\\n            // Check to see if the user is able to purchase mid keys.\\r\\n            // If not, decrease the upper limit. If they can, increase the lower limit\\r\\n            // If the user can purchase mid+1 keys, then it should not exit, hence nextCost > _amount is required\\r\\n            if (_totalCost <= _amount && (mid == right || nextCost > _amount)) {\\r\\n                maxKeys = mid;\\r\\n                break;\\r\\n            } else if (_totalCost <= _amount) {\\r\\n                left = mid + 1;\\r\\n            } else {\\r\\n                right = mid - 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // If the binary search completes without finding a suitable number of keys, set maxKeys to left\\r\\n        if (maxKeys == 0) {\\r\\n            maxKeys = left;\\r\\n        }\\r\\n\\r\\n        // Calculate the cost for the final number of keys again to ensure accuracy\\r\\n        _totalCost = calculatePriceForKeys(maxKeys);\\r\\n\\r\\n        // Return the maximum number of keys that can be bought and the total cost for those keys\\r\\n        return (maxKeys, _totalCost);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Calculates the total price for a specified number of keys based on the current key price.\\r\\n    * @param _keys The number of keys to calculate the price for.\\r\\n    * @return totalPrice The total price in ETH for the specified number of keys.\\r\\n    */\\r\\n    function calculatePriceForKeys(uint256 _keys) public view returns (uint256 totalPrice) {\\r\\n        uint256 initialKeyPrice = getKeyPrice();\\r\\n        uint256 increasePerKey = 0.000000009 ether;\\r\\n\\r\\n         // Calculate the total price based on the number of keys\\r\\n        if (_keys <= 1) {\\r\\n            totalPrice = initialKeyPrice * _keys;\\r\\n        } else {\\r\\n            uint256 lastPrice = initialKeyPrice + ((_keys - 1) * increasePerKey);\\r\\n            totalPrice = (_keys * (initialKeyPrice + lastPrice)) / 2;\\r\\n        }\\r\\n\\r\\n        return totalPrice;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Handles the purchase of keys by a player and updates relevant data.\\r\\n    * @param maxKeysToPurchase The maximum number of keys to purchase.\\r\\n    * @param _amount The amount of ETH sent by the player.\\r\\n    */\\r\\n    function processKeyPurchase(uint256 maxKeysToPurchase, uint256 _amount) private {\\r\\n        // Check if the amount is greater than or equal to 0\\r\\n        require(_amount > 0, \\\"Not enough Ether to purchase keys\\\");\\r\\n\\r\\n        // Calculate the fractional keys based on the maximum number of keys to purchase\\r\\n        uint256 fractionalKeys = maxKeysToPurchase * 1 ether;\\r\\n        Round storage round = rounds[currentRound];\\r\\n\\r\\n        // Increase the player's key count for the current round\\r\\n        players[msg.sender].keyCount[currentRound] += fractionalKeys;\\r\\n\\r\\n        // Reset the last reward ratio for the player in the current round\\r\\n        players[msg.sender].lastRewardRatio[currentRound] = round.rewardRatio; // reset fallback in case user has gap betewwn burn and next buyin. \\r\\n\\r\\n        // Increase the total keys for the current round\\r\\n        round.totalKeys += fractionalKeys;\\r\\n\\r\\n        // Calculate the final key price based on the last key price and the increase per key\\r\\n        uint256 finalKeyPrice = round.lastKeyPrice;\\r\\n        uint256 increasePerKey = 0.000000009 ether;\\r\\n        finalKeyPrice += increasePerKey * maxKeysToPurchase;\\r\\n\\r\\n        // Update the last key price for the current round\\r\\n        round.lastKeyPrice = finalKeyPrice;\\r\\n\\r\\n        // Distribute the funds to different purposes (keys funds, jackpot, etc.)\\r\\n        distributeFunds(_amount);\\r\\n\\r\\n        emit BuyAndDistribute(msg.sender,  maxKeysToPurchase, finalKeyPrice,  block.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Burns the keys owned by a player in a specific round.\\r\\n    * @param player The address of the player.\\r\\n    * @param roundNumber The round number in which to burn the keys.\\r\\n    */\\r\\n    function BurnKeys(address player, uint roundNumber) private {\\r\\n        \\r\\n        // Check if the round number is the current round\\r\\n        if (roundNumber == currentRound) {\\r\\n            uint256 Keys = players[player].keyCount[roundNumber];\\r\\n\\r\\n            // Reset the key count of the player for the specific round\\r\\n            players[player].keyCount[roundNumber] = 0;\\r\\n\\r\\n            // Update the burnt keys count for the player and round\\r\\n            players[player].burntKeys[roundNumber]+= Keys;\\r\\n            rounds[roundNumber].totalKeys -= Keys;\\r\\n            rounds[roundNumber].burntKeys += Keys;\\r\\n\\r\\n            \\r\\n            emit KeyBurn(player,  Keys,  block.timestamp);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Checks if the player has early buy-in points for the current round and adds early keys if applicable.\\r\\n    */\\r\\n    function checkForEarlyKeys(uint _round) private {\\r\\n\\r\\n        // Check if the player has early buy-in points and has not received early keys for the current round\\r\\n        if (players[msg.sender].earlyBuyinPoints[_round] > 0 && !earlyKeysReceived[msg.sender][_round]) {\\r\\n\\r\\n            // Calculate early keys based on the amount of early ETH sent\\r\\n            uint256 totalPoints = rounds[_round].earlyBuyinEth;\\r\\n            uint256 playerPoints = players[msg.sender].earlyBuyinPoints[_round];\\r\\n            uint256 earlyKeys = ((playerPoints * 10_000_000) / totalPoints) * 1 ether;\\r\\n\\r\\n            // Add the early keys to the player's key count for the current round\\r\\n            players[msg.sender].keyCount[_round] += earlyKeys;\\r\\n            \\r\\n            // Mark that early keys were received for this round\\r\\n            earlyKeysReceived[msg.sender][_round] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Adjusts the end time of the current round based on the maximum number of keys purchased.\\r\\n    * @param maxKeysToPurchase The maximum number of keys purchased in the current transaction.\\r\\n    */\\r\\n    function adjustRoundEndTime(uint256 maxKeysToPurchase) private {\\r\\n        // Calculate the time extension based on the maximum keys purchased\\r\\n        uint256 timeExtension = maxKeysToPurchase * 30 seconds;\\r\\n\\r\\n        // Set the maximum end time as the current timestamp plus 2 hours\\r\\n        uint256 maxEndTime = block.timestamp + 12 hours;\\r\\n\\r\\n        // Adjust the end time of the current round by adding the time extension, capped at the maximum end time\\r\\n        rounds[currentRound].end = min(rounds[currentRound].end + timeExtension, maxEndTime);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Retrieves the current key price for the active round.\\r\\n    * @return The current key price.\\r\\n    */\\r\\n    function getKeyPrice() public view returns (uint256) {\\r\\n        uint256 _roundId = currentRound;\\r\\n\\r\\n        // Fetch the last key price\\r\\n        uint256 lastKeyPrice = rounds[_roundId].lastKeyPrice;\\r\\n\\r\\n        // If the price is 0, return 0.000000009 ether, else return the last set price\\r\\n        if(lastKeyPrice == 0) {\\r\\n            return 0.000000009 ether;\\r\\n        } else {\\r\\n            return lastKeyPrice;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Calculates the jackpot threshold as a percentage of the current round's jackpot.\\r\\n    * @return The jackpot threshold.\\r\\n    */\\r\\n    function calculateJackpotThreshold() private view returns (uint256) {\\r\\n        uint256 _roundId = currentRound;\\r\\n\\r\\n        // Calculate the jackpot threshold as 0.0001% of the jackpot\\r\\n        return rounds[_roundId].jackpot / 1000000; \\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Resets the key price by dividing the current round's jackpot by 10 million.\\r\\n    * @return The new key price after resetting.\\r\\n    */\\r\\n    function resetPrice() private view returns (uint256) {\\r\\n        uint256 _roundId = currentRound;\\r\\n        return rounds[_roundId].jackpot / 10000000; \\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Updates the reward ratio for a specific round based on the amount of ETH received.\\r\\n    * @param _amount The amount of ETH received.\\r\\n    * @param _roundNumber The round number to update the reward ratio for.\\r\\n    */\\r\\n    function updateRoundRatio(uint256 _amount, uint256 _roundNumber) private {\\r\\n\\r\\n        // Calculate the reward ratio by dividing the amount by the total keys in the current round\\r\\n        rounds[_roundNumber].rewardRatio += (_amount / (rounds[currentRound].totalKeys / 1 ether));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Distributes the incoming ETH to different funds and updates the reward ratio.\\r\\n    * @param _amount The amount of ETH received.\\r\\n    */\\r\\n    function distributeFunds(uint256 _amount) private {\\r\\n        // Calculate the referral reward as a percentage of the incoming ETH\\r\\n        uint256 referralReward = (_amount * REFERRAL_REWARD_PERCENTAGE) / 10000;\\r\\n\\r\\n        // Check if the last referrer is not registered and adjust the referral reward\\r\\n        if (playerNameRegistry.getPlayerAddress(players[msg.sender].lastReferrer) == address(0)){\\r\\n            referralReward = (referralReward / 2);\\r\\n        }\\r\\n\\r\\n        // Calculate the remaining amount after deducting the referral reward\\r\\n        uint256 amount = _amount - referralReward;\\r\\n\\r\\n        // Calculate the keys fund as a percentage of the remaining amount\\r\\n        uint256 keysFund = (amount * KEYS_FUND_PERCENTAGE) / 10000;\\r\\n\\r\\n        // Update the reward ratio for the current round based on the keys fund\\r\\n        updateRoundRatio(keysFund, currentRound);\\r\\n        \\r\\n        // Calculate the jackpot as a percentage of the remaining amount\\r\\n        uint256 jackpot = (amount * JACKPOT_PERCENTAGE) / 10000;\\r\\n\\r\\n        // Add the jackpot to the current round's jackpot\\r\\n        rounds[currentRound].jackpot += jackpot;\\r\\n\\r\\n        // Calculate the apex fund as a percentage of the remaining amount\\r\\n        uint256 apexFund = (amount * APEX_FUND_PERCENTAGE) / 10000;\\r\\n\\r\\n        // Transfer the apex fund to the nftRegistry\\r\\n        nftRegistry.addToPool{value: apexFund}();\\r\\n\\r\\n        // Calculate the burn fund as a percentage of the remaining amount\\r\\n        uint256 burnFund = (amount * BURN_FUND_PERCENTAGE) / 10000;\\r\\n\\r\\n        // Deposit the burn fund to the xenBurn contract\\r\\n        xenBurn.deposit{value: burnFund}();\\r\\n\\r\\n        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Allows a player to register a name by paying the registration fee.\\r\\n    * @param name The name to register.\\r\\n    */\\r\\n    function registerPlayerName(string memory name) public payable {\\r\\n        // Check if the player has provided enough funds to register the name\\r\\n        require(msg.value >= NAME_REGISTRATION_FEE, \\\"Insufficient funds to register the name.\\\");\\r\\n\\r\\n        // Call the registerPlayerName function of the playerNameRegistry contract with the player's address and name\\r\\n        playerNameRegistry.registerPlayerName{value: msg.value}(msg.sender, name);\\r\\n\\r\\n        emit PlayerNameRegistered(msg.sender, name, block.timestamp);\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Allows the owner of an NFT to register it.\\r\\n    * @param tokenId The ID of the NFT to register.\\r\\n    */\\r\\n    function registerNFT(uint256 tokenId) external {\\r\\n        // Check if the caller is the owner of the NFT with the given tokenId\\r\\n        require(nftContract.ownerOf(tokenId) == msg.sender, \\\"You don't own this NFT.\\\");\\r\\n\\r\\n        // Call the registerNFT function of the nftRegistry contract with the tokenId\\r\\n        nftRegistry.registerNFT(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Processes the rewards for the specified round and adds them to the player's keyRewards.\\r\\n    * @param roundNumber The round number for which to calculate and process rewards.\\r\\n    */\\r\\n    function processRewards(uint256 roundNumber) private  {\\r\\n        // Get the player's storage reference\\r\\n        Player storage player = players[msg.sender];\\r\\n\\r\\n        // Check for early keys received during the early buy-in period\\r\\n        checkForEarlyKeys(roundNumber);\\r\\n\\r\\n        // Only calculate rewards if player has at least one key\\r\\n        if (player.keyCount[roundNumber] > 0) {\\r\\n            // Calculate the player's rewards based on the difference between reward ratios\\r\\n            uint256 reward = (\\r\\n                (player.keyCount[roundNumber] / 1 ether)\\r\\n                    * (rounds[roundNumber].rewardRatio - player.lastRewardRatio[roundNumber])\\r\\n            ); \\r\\n\\r\\n            // Update the player's last reward ratio to the current round's ratio\\r\\n            player.lastRewardRatio[roundNumber] = rounds[roundNumber].rewardRatio;\\r\\n\\r\\n            // Add the calculated reward to the player's keyRewards\\r\\n            player.keyRewards += reward;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \\r\\n/**\\r\\n    * @dev Allows the player to withdraw their rewards for the specified round.\\r\\n    * @param roundNumber The round number for which to withdraw rewards.\\r\\n    */\\r\\nfunction withdrawRewards(uint256 roundNumber) public {\\r\\n    // Get the player's storage reference\\r\\n    Player storage player = players[msg.sender];\\r\\n\\r\\n    // Convert the player's address to a payable address\\r\\n    address payable senderPayable = payable(msg.sender);  \\r\\n\\r\\n    // Check for early keys received during the early buy-in period\\r\\n    checkForEarlyKeys(roundNumber);\\r\\n\\r\\n    // Calculate the rewards based on the difference between reward ratios\\r\\n    uint256 reward = (\\r\\n        (player.keyCount[roundNumber] / 1 ether)\\r\\n            * (rounds[roundNumber].rewardRatio - player.lastRewardRatio[roundNumber])\\r\\n    );\\r\\n\\r\\n    // Update the player's last reward ratio to the current round's ratio\\r\\n    player.lastRewardRatio[roundNumber] = rounds[roundNumber].rewardRatio;\\r\\n\\r\\n    // Add the unpreprocessed keyRewards to the processed rewards\\r\\n    reward += player.keyRewards;\\r\\n\\r\\n    // Reset the player's keyRewards\\r\\n    player.keyRewards = 0;\\r\\n\\r\\n    // Burn the player's past keys for the current round\\r\\n    if (roundNumber == currentRound){\\r\\n        BurnKeys(msg.sender, roundNumber);\\r\\n\\r\\n    }\\r\\n    \\r\\n\\r\\n    if (reward > 0) {\\r\\n        // Transfer the rewards\\r\\n        senderPayable.transfer(reward);\\r\\n\\r\\n        emit RewardsWithdrawn(msg.sender, reward, block.timestamp);\\r\\n    }\\r\\n}\\r\\n\\r\\n    /**\\r\\n    * @dev Allows a player to withdraw their referral rewards.\\r\\n    */\\r\\nfunction withdrawReferralRewards() public {\\r\\n    // Get the amount of referral rewards for the player\\r\\n    uint256 rewardAmount = players[msg.sender].referralRewards;\\r\\n    require(rewardAmount > 0, \\\"No referral rewards to withdraw\\\");\\r\\n\\r\\n    // Check that the player has a registered name\\r\\n    string memory playerName = getPlayerName(msg.sender);\\r\\n    require(bytes(playerName).length > 0, \\\"Player has no registered names\\\");\\r\\n\\r\\n    // Convert the player's address to a payable address\\r\\n    address payable senderPayable = payable(msg.sender); \\r\\n\\r\\n    // Reset the player's referral rewards \\r\\n    players[msg.sender].referralRewards = 0;\\r\\n\\r\\n    // transfer the rewards\\r\\n    senderPayable.transfer(rewardAmount);\\r\\n\\r\\n    emit ReferralRewardsWithdrawn(msg.sender, rewardAmount, block.timestamp);\\r\\n\\r\\n    rewardAmount = players[address(0)].referralRewards;\\r\\n    if (rewardAmount > 0){\\r\\n        players[address(0)].referralRewards = 0;\\r\\n        (bool success, ) = payable(playerNames).call{value: rewardAmount}(\\\"\\\");\\r\\n        require(success, \\\"Transfer failed.\\\");\\r\\n\\r\\n    }\\r\\n}\\r\\n\\r\\n    /**\\r\\n    * @dev Allows a player to withdraw their burnt keys rewards for a specific round.\\r\\n    * @param _roundNumber The round number for which the player wants to withdraw burnt keys rewards.\\r\\n    */\\r\\nfunction WithdrawBurntKeyRewards(uint _roundNumber) public {\\r\\n    // Check if the round number is valid and not greater than the current round\\r\\n    require( _roundNumber < currentRound , \\\"Can't withdraw BurntKey Rewards tell round end.\\\");\\r\\n\\r\\n    // Check if the player has burnt keys rewards for the specified round\\r\\n    require(players[msg.sender].burntKeys[_roundNumber] > 0 , \\\"Player has no burnt Keys rewards.\\\");\\r\\n\\r\\n    // Calculate the reward amount based on the player's burnt keys and the burnt key funds for the round\\r\\n    uint256 reward = ((players[msg.sender].burntKeys[_roundNumber] * rounds[_roundNumber].BurntKeyFunds) / rounds[_roundNumber].burntKeys);\\r\\n\\r\\n    // Reset the burnt keys rewards for the player\\r\\n    players[msg.sender].burntKeys[_roundNumber] = 0;\\r\\n\\r\\n    // Transfer the reward amount to the player\\r\\n    address payable senderPayable = payable(msg.sender);\\r\\n    senderPayable.transfer(reward);\\r\\n\\r\\n    emit BurnKeysRewardWithdraw(msg.sender, reward, _roundNumber, block.timestamp);\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n    /**\\r\\n    * @dev Ends the current round and distributes the jackpot and funds to the winner and other recipients.\\r\\n    */\\r\\n    function endRound() private {\\r\\n        // Get the current round\\r\\n        Round storage round = rounds[currentRound];\\r\\n\\r\\n        // Check if the current timestamp is after the round end time\\r\\n        require(block.timestamp >= round.end, \\\"Round has not yet ended.\\\");\\r\\n\\r\\n        // Identify the winner as the last person to have bought a key\\r\\n        address winner = round.activePlayer;\\r\\n\\r\\n        // Divide the jackpot\\r\\n        uint256 jackpot = round.jackpot;\\r\\n        uint256 winnerShare = (jackpot * 50) / 100; // 50%\\r\\n        uint256 burntKeysFundsShare = (jackpot * 20) / 100; // 20%\\r\\n        uint256 currentRoundNftShare = (jackpot * 20) / 100; // 20%\\r\\n        uint256 nextRoundJackpot = (jackpot * 10) / 100; // 10%\\r\\n\\r\\n        // Transfer to the winner\\r\\n        players[winner].keyRewards += winnerShare;\\r\\n        \\r\\n\\r\\n        // Add to the burntKeysFunds share to the Burnt keys\\r\\n        round.BurntKeyFunds += burntKeysFundsShare;\\r\\n\\r\\n        // Set the starting jackpot for the next round\\r\\n        rounds[currentRound + 1].jackpot = nextRoundJackpot;\\r\\n\\r\\n        // Send to the NFT contract\\r\\n        nftRegistry.addToPool{value: currentRoundNftShare}();\\r\\n\\r\\n        round.ended = true;\\r\\n\\r\\n        emit RoundEnded(currentRound, winner, jackpot, winnerShare, burntKeysFundsShare, currentRoundNftShare, nextRoundJackpot, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Starts a new round by incrementing the current round number and setting the start and end times.\\r\\n    */\\r\\n    function startNewRound() private {\\r\\n        // Increment the current round number\\r\\n        currentRound += 1;\\r\\n\\r\\n        // Set the start time of the new round by adding ROUND_GAP to the current timestamp\\r\\n        rounds[currentRound].start = block.timestamp + ROUND_GAP;\\r\\n        \\r\\n        // Set the end time of the new round by adding 1 hour to the start time (adjust as needed)\\r\\n        rounds[currentRound].end = rounds[currentRound].start + 12 hours; \\r\\n\\r\\n        // Reset the \\\"ended\\\" flag for the new round\\r\\n        rounds[currentRound].ended = false;\\r\\n\\r\\n        // Set the reward ratio to a low non-zero value\\r\\n        rounds[currentRound].rewardRatio = 1; \\r\\n       \\r\\n        emit NewRoundStarted(currentRound, rounds[currentRound].start, rounds[currentRound].end);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Calculates the pending rewards for a player in a specific round.\\r\\n    * @param playerAddress The address of the player.\\r\\n    * @param roundNumber The round number.\\r\\n    * @return The amount of pending rewards for the player in the specified round.\\r\\n    */\\r\\n    function getPendingRewards(address playerAddress, uint256 roundNumber) public view returns (uint256) {\\r\\n        // Get the player and round information\\r\\n        Player storage player = players[playerAddress];\\r\\n        uint keys = getPlayerKeysCount(playerAddress, roundNumber);\\r\\n\\r\\n        // Calculate the pending rewards based on the player's key count and the difference in reward ratio\\r\\n        uint256 pendingRewards = (\\r\\n            (keys / 1 ether)\\r\\n                * (rounds[roundNumber].rewardRatio - player.lastRewardRatio[roundNumber])\\r\\n        );\\r\\n\\r\\n        // Add the unprocessed keyRewards to the pending rewards\\r\\n\\r\\n        if (roundNumber < currentRound){\\r\\n\\r\\n            return pendingRewards;\\r\\n\\r\\n        } else{\\r\\n\\r\\n            pendingRewards += player.keyRewards;\\r\\n            return pendingRewards;\\r\\n\\r\\n        }\\r\\n\\r\\n        \\r\\n    }\\r\\n\\r\\n\\r\\n    function getPlayerKeysCount(address playerAddress, uint256 _round) public view returns (uint256) {\\r\\n        Player storage player = players[playerAddress];\\r\\n\\r\\n        if (player.earlyBuyinPoints[_round] > 0 && !earlyKeysReceived[playerAddress][_round]) {\\r\\n            // Calculate early keys based on the amount of early ETH sent\\r\\n            uint256 totalPoints = rounds[_round].earlyBuyinEth;\\r\\n            uint256 playerPoints = players[playerAddress].earlyBuyinPoints[_round];\\r\\n\\r\\n            uint256 earlyKeys = ((playerPoints * 10_000_000) / totalPoints) * 1 ether;\\r\\n\\r\\n            return (player.keyCount[_round] + earlyKeys);\\r\\n        } else {\\r\\n            return player.keyCount[_round];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getPlayerName(address playerAddress) public view returns (string memory) {\\r\\n        return playerNameRegistry.getPlayerFirstName(playerAddress);\\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n    function getRoundTotalKeys(uint256 roundId) public view returns (uint256) {\\r\\n        return rounds[roundId].totalKeys;\\r\\n    }\\r\\n\\r\\n    function getRoundBurntKeys(uint256 roundId) public view returns (uint256) {\\r\\n        return rounds[roundId].burntKeys;\\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n    \\r\\n\\r\\n    function getRoundEnd(uint256 roundId) public view returns (uint256) {\\r\\n        return rounds[roundId].end;\\r\\n    }\\r\\n\\r\\n    function getRoundActivePlayer(uint256 roundId) public view returns (address) {\\r\\n        return rounds[roundId].activePlayer;\\r\\n    }\\r\\n\\r\\n    function getRoundEnded(uint256 roundId) public view returns (bool) {\\r\\n        return rounds[roundId].ended;\\r\\n    }\\r\\n\\r\\n    function getRoundIsEarlyBuyin(uint256 roundId) public view returns (bool) {\\r\\n        return rounds[roundId].isEarlyBuyin;\\r\\n    }\\r\\n\\r\\n    function getRoundKeysFunds(uint256 roundId) public view returns (uint256) {\\r\\n        return rounds[roundId].keysFunds;\\r\\n    }\\r\\n\\r\\n    function getRoundJackpot(uint256 roundId) public view returns (uint256) {\\r\\n        return rounds[roundId].jackpot;\\r\\n    }\\r\\n\\r\\n    function getRoundEarlyBuyinEth(uint256 roundId) public view returns (uint256) {\\r\\n        return rounds[roundId].earlyBuyinEth;\\r\\n    }\\r\\n\\r\\n    function getRoundLastKeyPrice(uint256 roundId) public view returns (uint256) {\\r\\n        return rounds[roundId].lastKeyPrice;\\r\\n    }\\r\\n\\r\\n    function getRoundRewardRatio(uint256 roundId) public view returns (uint256) {\\r\\n        return rounds[roundId].rewardRatio;\\r\\n    }\\r\\n\\r\\n    function getRoundBurntKeyFunds(uint256 roundId) public view returns (uint256) {\\r\\n        return rounds[roundId].BurntKeyFunds;\\r\\n    }\\r\\n\\r\\n    function getRoundUniquePlayers(uint256 roundId) public view returns (uint256) {\\r\\n        return rounds[roundId].uniquePlayers;\\r\\n    }\\r\\n\\r\\n    function getRoundPlayerAddresses(uint256 roundId) public view returns (address[] memory) {\\r\\n        return rounds[roundId].playerAddresses;\\r\\n    }\\r\\n\\r\\n    function getRoundIsPlayerInRound(uint256 roundId, address player) public view returns (bool) {\\r\\n        return isPlayerInRound[roundId][player];\\r\\n    }\\r\\n\\r\\n    function getPlayerInfo(address playerAddress, uint256 roundNumber)\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            uint256 keyCount, \\r\\n            uint256 earlyBuyinPoints, \\r\\n            uint256 referralRewards, \\r\\n            uint256 lastRewardRatio,\\r\\n            uint256 keyRewards,\\r\\n            uint256 numberOfReferrals\\r\\n        )\\r\\n    {\\r\\n        keyCount = getPlayerKeysCount(playerAddress, roundNumber);\\r\\n        earlyBuyinPoints = players[playerAddress].earlyBuyinPoints[roundNumber];\\r\\n        referralRewards = players[playerAddress].referralRewards;\\r\\n        lastRewardRatio = players[playerAddress].lastRewardRatio[roundNumber];\\r\\n        keyRewards = getPendingRewards(playerAddress,  roundNumber);\\r\\n        numberOfReferrals = players[playerAddress].numberOfReferrals;\\r\\n    }\\r\\n\\r\\n    function getPlayerKeyCount(address playerAddress, uint256 round) public view returns (uint256) {\\r\\n        return players[playerAddress].keyCount[round];\\r\\n    }\\r\\n\\r\\n    function getPlayerBurntKeys(address playerAddress, uint256 round) public view returns (uint256) {\\r\\n        return players[playerAddress].burntKeys[round];\\r\\n    }\\r\\n\\r\\n    function getPlayerEarlyBuyinPoints(address playerAddress, uint256 round) public view returns (uint256) {\\r\\n        return players[playerAddress].earlyBuyinPoints[round];\\r\\n    }\\r\\n\\r\\n    function getPlayerReferralRewards(address playerAddress) public view returns (uint256) {\\r\\n        return players[playerAddress].referralRewards;\\r\\n    }\\r\\n\\r\\n    function getPlayerLastReferrer(address playerAddress) public view returns (string memory) {\\r\\n        return players[playerAddress].lastReferrer;\\r\\n    }\\r\\n\\r\\n    function getlastRewardRatio(address playerAddress, uint256 round) public view returns (uint256) {\\r\\n        return players[playerAddress].lastRewardRatio[round];\\r\\n    }\\r\\n\\r\\n    function getRoundStart(uint256 roundId) public view returns (uint256) {\\r\\n        return rounds[roundId].start;\\r\\n    }\\r\\n\\r\\n    function getRoundEarlyBuyin(uint256 roundId) public view returns (uint256) {\\r\\n        return rounds[roundId].earlyBuyinEth;\\r\\n    }\\r\\n\\r\\n    function getUniquePlayers(uint256 round) public view returns (uint256) {\\r\\n        return rounds[round].uniquePlayers;\\r\\n    }\\r\\n\\r\\n    function getPlayerAddresses(uint256 round) public view returns (address[] memory) {\\r\\n        return rounds[round].playerAddresses;\\r\\n    }\\r\\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\\r\\n        return a > b ? a : b;\\r\\n    }\\r\\n\\r\\n    event BuyAndDistribute(address buyer, uint256 amount, uint256 keyPrice, uint256 timestamp);\\r\\n    event ReferralRewardsWithdrawn(address indexed player, uint256 amount, uint256 timestamp);\\r\\n    event RewardsWithdrawn(address indexed player, uint256 amount, uint256 timestamp);\\r\\n    event RoundEnded(uint256 roundId, address winner, uint256 jackpot, uint256 winnerShare, uint256 keysFundsShare, uint256 currentRoundNftShare, uint256 nextRoundJackpot, uint256 timestamp);\\r\\n    event NewRoundStarted(uint256 roundId, uint256 startTimestamp, uint256 endTimestamp);\\r\\n    event PlayerNameRegistered(address player, string name, uint256 timestamp);\\r\\n    event ReferralPaid(address player, address referrer, uint256 amount, uint256 timestamp);\\r\\n    event KeyBurn(address player, uint256 Keys, uint256 timestamp);\\r\\n    event BurnKeysRewardWithdraw(address player, uint256 reward, uint256 RoundNumber, uint256 timestamp);\\r\\n    event PriceReset(address player, uint256 newPrice, uint256 timestamp);\\r\\n\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"RoundNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BurnKeysRewardWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"keyPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BuyAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Keys\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"KeyBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"NewRoundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PlayerNameRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PriceReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ReferralPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ReferralRewardsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RewardsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"jackpot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winnerShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"keysFundsShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentRoundNftShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextRoundJackpot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RoundEnded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundNumber\",\"type\":\"uint256\"}],\"name\":\"WithdrawBurntKeyRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyKeysWithRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_referrerName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfKeys\",\"type\":\"uint256\"}],\"name\":\"buyWithReferral\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateMaxKeysToPurchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxKeys\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"calculatePriceForKeys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"earlyKeysReceived\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKeyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundNumber\",\"type\":\"uint256\"}],\"name\":\"getPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getPlayerAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getPlayerBurntKeys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getPlayerEarlyBuyinPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundNumber\",\"type\":\"uint256\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"keyCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earlyBuyinPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keyRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfReferrals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getPlayerKeyCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getPlayerKeysCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerLastReferrer\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"getPlayerReferralRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundActivePlayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundBurntKeyFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundBurntKeys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundEarlyBuyin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundEarlyBuyinEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundIsEarlyBuyin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getRoundIsPlayerInRound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundJackpot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundKeysFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundLastKeyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundPlayerAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundRewardRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundTotalKeys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundUniquePlayers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getUniquePlayers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getlastRewardRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPlayerInRound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRoundActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRoundEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"playeraddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"playerRound1KeyCount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"playerRound1BurntKeys\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"playerRound1EarlyBuyinPoints\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"playerLastReferrer\",\"type\":\"string[]\"}],\"name\":\"migrateUserBasicData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"playeraddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"playerReferralRewards\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"playerRound1RewardRatio\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"playerKeyRewards\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"playerNumberOfReferrals\",\"type\":\"uint256[]\"}],\"name\":\"migrateUserReferralAndRewardData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationPhaseTwoCompleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"nameToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContract\",\"outputs\":[{\"internalType\":\"contract IXENnftContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftRegistry\",\"outputs\":[{\"internalType\":\"contract INFTRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"referralRewards\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"lastReferrer\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"keyRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfReferrals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"registerNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"registerPlayerName\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalKeys\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burntKeys\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"activePlayer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"ended\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEarlyBuyin\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"keysFunds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jackpot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earlyBuyinEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastKeyPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"BurntKeyFunds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uniquePlayers\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seedEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReferralRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundNumber\",\"type\":\"uint256\"}],\"name\":\"withdrawRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xenBurn\",\"outputs\":[{\"internalType\":\"contract XENBurn\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "XenGame", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}