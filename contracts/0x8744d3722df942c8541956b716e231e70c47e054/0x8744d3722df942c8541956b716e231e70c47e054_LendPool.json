{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocol/LendPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {ILendPoolLoan} from \\\"../interfaces/ILendPoolLoan.sol\\\";\\nimport {ILendPool} from \\\"../interfaces/ILendPool.sol\\\";\\nimport {ILendPoolAddressesProvider} from \\\"../interfaces/ILendPoolAddressesProvider.sol\\\";\\n\\nimport {Errors} from \\\"../libraries/helpers/Errors.sol\\\";\\nimport {WadRayMath} from \\\"../libraries/math/WadRayMath.sol\\\";\\nimport {GenericLogic} from \\\"../libraries/logic/GenericLogic.sol\\\";\\nimport {PercentageMath} from \\\"../libraries/math/PercentageMath.sol\\\";\\nimport {ReserveLogic} from \\\"../libraries/logic/ReserveLogic.sol\\\";\\nimport {NftLogic} from \\\"../libraries/logic/NftLogic.sol\\\";\\nimport {ValidationLogic} from \\\"../libraries/logic/ValidationLogic.sol\\\";\\nimport {SupplyLogic} from \\\"../libraries/logic/SupplyLogic.sol\\\";\\nimport {BorrowLogic} from \\\"../libraries/logic/BorrowLogic.sol\\\";\\nimport {LiquidateLogic} from \\\"../libraries/logic/LiquidateLogic.sol\\\";\\n\\nimport {ReserveConfiguration} from \\\"../libraries/configuration/ReserveConfiguration.sol\\\";\\nimport {NftConfiguration} from \\\"../libraries/configuration/NftConfiguration.sol\\\";\\nimport {DataTypes} from \\\"../libraries/types/DataTypes.sol\\\";\\nimport {LendPoolStorage} from \\\"./LendPoolStorage.sol\\\";\\nimport {LendPoolStorageExt} from \\\"./LendPoolStorageExt.sol\\\";\\n\\nimport {AddressUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport {IERC721Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport {IERC721ReceiverUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {ContextUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\";\\n\\n/**\\n * @title LendPool contract\\n * @dev Main point of interaction with an MetaFire protocol's market\\n * - Users can:\\n *   # Deposit\\n *   # Withdraw\\n *   # Borrow\\n *   # Repay\\n *   # Auction\\n *   # Liquidate\\n * - To be covered by a proxy contract, owned by the LendPoolAddressesProvider of the specific market\\n * - All admin functions are callable by the LendPoolConfigurator contract defined also in the\\n *   LendPoolAddressesProvider\\n * @author MetaFire\\n **/\\n// !!! For Upgradable: DO NOT ADJUST Inheritance Order !!!\\ncontract LendPool is\\n  Initializable,\\n  ILendPool,\\n  LendPoolStorage,\\n  ContextUpgradeable,\\n  IERC721ReceiverUpgradeable,\\n  LendPoolStorageExt\\n{\\n  using WadRayMath for uint256;\\n  using PercentageMath for uint256;\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using NftLogic for DataTypes.NftData;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n  using NftConfiguration for DataTypes.NftConfigurationMap;\\n\\n  /**\\n   * @dev Prevents a contract from calling itself, directly or indirectly.\\n   * Calling a `nonReentrant` function from another `nonReentrant`\\n   * function is not supported. It is possible to prevent this from happening\\n   * by making the `nonReentrant` function external, and making it call a\\n   * `private` function that does the actual work.\\n   */\\n  modifier nonReentrant() {\\n    // On the first call to nonReentrant, _notEntered will be true\\n    require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n    // Any calls to nonReentrant after this point will fail\\n    _status = _ENTERED;\\n\\n    _;\\n\\n    // By storing the original value once again, a refund is triggered (see\\n    // https://eips.ethereum.org/EIPS/eip-2200)\\n    _status = _NOT_ENTERED;\\n  }\\n\\n  modifier whenNotPaused() {\\n    _whenNotPaused();\\n    _;\\n  }\\n\\n  modifier onlyLendPoolConfigurator() {\\n    _onlyLendPoolConfigurator();\\n    _;\\n  }\\n\\n  function _whenNotPaused() internal view {\\n    require(!_paused, Errors.LP_IS_PAUSED);\\n  }\\n\\n  function _onlyLendPoolConfigurator() internal view {\\n    require(_addressesProvider.getLendPoolConfigurator() == _msgSender(), Errors.LP_CALLER_NOT_LEND_POOL_CONFIGURATOR);\\n  }\\n\\n  /**\\n   * @dev Function is invoked by the proxy contract when the LendPool contract is added to the\\n   * LendPoolAddressesProvider of the market.\\n   * - Caching the address of the LendPoolAddressesProvider in order to reduce gas consumption\\n   *   on subsequent operations\\n   * @param provider The address of the LendPoolAddressesProvider\\n   **/\\n  function initialize(ILendPoolAddressesProvider provider) public initializer {\\n    _maxNumberOfReserves = 32;\\n    _maxNumberOfNfts = 256;\\n\\n    _addressesProvider = provider;\\n  }\\n\\n  /**\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying mTokens.\\n   * - E.g. User deposits 100 USDC and gets in return 100 bUSDC\\n   * @param asset The address of the underlying asset to deposit\\n   * @param amount The amount to be deposited\\n   * @param onBehalfOf The address that will receive the mTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of mTokens\\n   *   is a different wallet\\n   * @param period The index of period of the deposit\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function deposit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    DataTypes.Period period,\\n    uint16 referralCode\\n  ) external override nonReentrant whenNotPaused {\\n    SupplyLogic.executeDeposit(\\n      _reserves,\\n      DataTypes.ExecuteDepositParams({\\n        initiator: _msgSender(),\\n        asset: asset,\\n        amount: amount,\\n        onBehalfOf: onBehalfOf,\\n        period: period,\\n        referralCode: referralCode\\n      })\\n    );\\n  }\\n\\n  /**\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent mTokens owned\\n   * E.g. User has 100 bUSDC, calls withdraw() and receives 100 USDC, burning the 100 bUSDC\\n   * @param asset The address of the underlying asset to withdraw\\n   * @param amount The underlying amount to be withdrawn\\n   *   - Send the value type(uint256).max in order to withdraw the whole mToken balance\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n   *   different wallet\\n   * @param period The index of period of the deposit\\n   * @return The final amount withdrawn\\n   **/\\n  function withdraw(\\n    address asset,\\n    uint256 amount,\\n    address to,\\n    DataTypes.Period period\\n  ) external override nonReentrant whenNotPaused returns (uint256) {\\n    return\\n      SupplyLogic.executeWithdraw(\\n        _reserves,\\n        DataTypes.ExecuteWithdrawParams({initiator: _msgSender(), asset: asset, amount: amount, to: to, period: period})\\n      );\\n  }\\n\\n  /**\\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset\\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\\n   *   and lock collateral asset in contract\\n   * @param asset The address of the underlying asset to borrow\\n   * @param amount The amount to be borrowed\\n   * @param nftAsset The address of the underlying nft used as collateral\\n   * @param nftTokenId The token ID of the underlying nft used as collateral\\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\\n   * calling the function if he wants to borrow against his own collateral\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function borrow(\\n    address asset,\\n    uint256 amount,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address onBehalfOf,\\n    uint16 referralCode\\n  ) external override nonReentrant whenNotPaused {\\n    BorrowLogic.executeBorrow(\\n      _addressesProvider,\\n      _reserves,\\n      _nfts,\\n      DataTypes.ExecuteBorrowParams({\\n        initiator: _msgSender(),\\n        asset: asset,\\n        amount: amount,\\n        nftAsset: nftAsset,\\n        nftTokenId: nftTokenId,\\n        onBehalfOf: onBehalfOf,\\n        referralCode: referralCode\\n      })\\n    );\\n  }\\n\\n  function batchBorrow(\\n    address[] calldata assets,\\n    uint256[] calldata amounts,\\n    address[] calldata nftAssets,\\n    uint256[] calldata nftTokenIds,\\n    address onBehalfOf,\\n    uint16 referralCode\\n  ) external override nonReentrant whenNotPaused {\\n    DataTypes.ExecuteBatchBorrowParams memory params;\\n    params.initiator = _msgSender();\\n    params.assets = assets;\\n    params.amounts = amounts;\\n    params.nftAssets = nftAssets;\\n    params.nftTokenIds = nftTokenIds;\\n    params.onBehalfOf = onBehalfOf;\\n    params.referralCode = referralCode;\\n\\n    BorrowLogic.executeBatchBorrow(_addressesProvider, _reserves, _nfts, params);\\n  }\\n\\n  /**\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\\n   * @param amount The amount to repay\\n   **/\\n  function repay(\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 amount\\n  ) external override nonReentrant whenNotPaused returns (uint256, bool) {\\n    return\\n      BorrowLogic.executeRepay(\\n        _addressesProvider,\\n        _reserves,\\n        _nfts,\\n        DataTypes.ExecuteRepayParams({\\n          initiator: _msgSender(),\\n          nftAsset: nftAsset,\\n          nftTokenId: nftTokenId,\\n          amount: amount\\n        })\\n      );\\n  }\\n\\n  function batchRepay(\\n    address[] calldata nftAssets,\\n    uint256[] calldata nftTokenIds,\\n    uint256[] calldata amounts\\n  ) external override nonReentrant whenNotPaused returns (uint256[] memory, bool[] memory) {\\n    return\\n      BorrowLogic.executeBatchRepay(\\n        _addressesProvider,\\n        _reserves,\\n        _nfts,\\n        DataTypes.ExecuteBatchRepayParams({\\n          initiator: _msgSender(),\\n          nftAssets: nftAssets,\\n          nftTokenIds: nftTokenIds,\\n          amounts: amounts\\n        })\\n      );\\n  }\\n\\n  /**\\n   * @dev Function to auction a non-healthy position collateral-wise\\n   * - The bidder want to buy collateral asset of the user getting liquidated\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\\n   * @param bidPrice The bid price of the bidder want to buy underlying NFT\\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\\n   *   is a different wallet\\n   **/\\n  function auction(\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 bidPrice,\\n    address onBehalfOf\\n  ) external override nonReentrant whenNotPaused {\\n    LiquidateLogic.executeAuction(\\n      _addressesProvider,\\n      _reserves,\\n      _nfts,\\n      _buildLendPoolVars(),\\n      DataTypes.ExecuteAuctionParams({\\n        initiator: _msgSender(),\\n        nftAsset: nftAsset,\\n        nftTokenId: nftTokenId,\\n        bidPrice: bidPrice,\\n        onBehalfOf: onBehalfOf\\n      })\\n    );\\n  }\\n\\n  /**\\n   * @notice Redeem a NFT loan which state is in Auction\\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\\n   * @param amount The amount to repay the debt\\n   * @param bidFine The amount of bid fine\\n   **/\\n  function redeem(\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 amount,\\n    uint256 bidFine\\n  ) external override nonReentrant whenNotPaused returns (uint256) {\\n    return\\n      LiquidateLogic.executeRedeem(\\n        _addressesProvider,\\n        _reserves,\\n        _nfts,\\n        _buildLendPoolVars(),\\n        DataTypes.ExecuteRedeemParams({\\n          initiator: _msgSender(),\\n          nftAsset: nftAsset,\\n          nftTokenId: nftTokenId,\\n          amount: amount,\\n          bidFine: bidFine\\n        })\\n      );\\n  }\\n\\n  /**\\n   * @dev Function to liquidate a non-healthy position collateral-wise\\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\\n   *   the collateral asset\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\\n   **/\\n  function liquidate(\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 amount\\n  ) external override nonReentrant whenNotPaused returns (uint256) {\\n    return\\n      LiquidateLogic.executeLiquidate(\\n        _addressesProvider,\\n        _reserves,\\n        _nfts,\\n        _buildLendPoolVars(),\\n        DataTypes.ExecuteLiquidateParams({\\n          initiator: _msgSender(),\\n          nftAsset: nftAsset,\\n          nftTokenId: nftTokenId,\\n          amount: amount\\n        })\\n      );\\n  }\\n\\n  /**\\n   * @dev Function to liquidate buy a non-healthy NFT loan whose liquidation factor is beyond 1.\\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\\n   *   the collateral asset\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\\n   * @param liquidatingBuyPrice The price of the liquidating buy\\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\\n   **/\\n  function liquidatingBuy(\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 liquidatingBuyPrice,\\n    address onBehalfOf\\n  ) external override nonReentrant whenNotPaused {\\n    LiquidateLogic.executeLiquidatingBuy(\\n      _addressesProvider,\\n      _reserves,\\n      _nfts,\\n      _buildLendPoolVars(),\\n      DataTypes.ExecuteLiquidatingBuyParams({\\n        initiator: _msgSender(),\\n        nftAsset: nftAsset,\\n        nftTokenId: nftTokenId,\\n        liquidatingBuyPrice: liquidatingBuyPrice,\\n        onBehalfOf: onBehalfOf\\n      })\\n    );\\n  }\\n\\n  function onERC721Received(\\n    address operator,\\n    address from,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external pure override returns (bytes4) {\\n    operator;\\n    from;\\n    tokenId;\\n    data;\\n    return IERC721ReceiverUpgradeable.onERC721Received.selector;\\n  }\\n\\n  /**\\n   * @dev Returns the configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The configuration of the reserve\\n   **/\\n  function getReserveConfiguration(address asset)\\n    external\\n    view\\n    override\\n    returns (DataTypes.ReserveConfigurationMap memory)\\n  {\\n    return _reserves[asset].configuration;\\n  }\\n\\n  /**\\n   * @dev Returns the configuration of the NFT\\n   * @param asset The address of the asset of the NFT\\n   * @return The configuration of the NFT\\n   **/\\n  function getNftConfiguration(address asset) external view override returns (DataTypes.NftConfigurationMap memory) {\\n    return _nfts[asset].configuration;\\n  }\\n\\n  /**\\n   * @dev Returns the normalized income normalized income of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve's normalized income\\n   */\\n  function getReserveNormalizedIncome(address asset, DataTypes.Period period) external view override returns (uint256) {\\n    return _reserves[asset].getNormalizedIncome(period);\\n  }\\n\\n  /**\\n   * @dev Returns the normalized variable debt per unit of asset\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve normalized variable debt\\n   */\\n  function getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\\n    return _reserves[asset].getNormalizedDebt();\\n  }\\n\\n  /**\\n   * @dev Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state of the reserve\\n   **/\\n  function getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\\n    return _reserves[asset];\\n  }\\n\\n  /**\\n   * @dev Returns the state and configuration of the nft\\n   * @param asset The address of the underlying asset of the nft\\n   * @return The state of the nft\\n   **/\\n  function getNftData(address asset) external view override returns (DataTypes.NftData memory) {\\n    return _nfts[asset];\\n  }\\n\\n  /**\\n   * @dev Returns the loan data of the NFT\\n   * @param nftAsset The address of the NFT\\n   * @param reserveAsset The address of the Reserve\\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\\n   * @return ltv the loan to value of the user\\n   * @return liquidationThreshold the liquidation threshold of the NFT\\n   * @return liquidationBonus the liquidation bonus of the NFT\\n   **/\\n  function getNftCollateralData(address nftAsset, address reserveAsset)\\n    external\\n    view\\n    override\\n    returns (\\n      uint256 totalCollateralInETH,\\n      uint256 totalCollateralInReserve,\\n      uint256 availableBorrowsInETH,\\n      uint256 availableBorrowsInReserve,\\n      uint256 ltv,\\n      uint256 liquidationThreshold,\\n      uint256 liquidationBonus\\n    )\\n  {\\n    DataTypes.NftData storage nftData = _nfts[nftAsset];\\n\\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\\n\\n    (ltv, liquidationThreshold, liquidationBonus) = nftData.configuration.getCollateralParams();\\n\\n    (totalCollateralInETH, totalCollateralInReserve) = GenericLogic.calculateNftCollateralData(\\n      reserveAsset,\\n      reserveData,\\n      nftAsset,\\n      nftData,\\n      _addressesProvider.getReserveOracle(),\\n      _addressesProvider.getNFTOracle()\\n    );\\n\\n    availableBorrowsInETH = GenericLogic.calculateAvailableBorrows(totalCollateralInETH, 0, ltv);\\n    availableBorrowsInReserve = GenericLogic.calculateAvailableBorrows(totalCollateralInReserve, 0, ltv);\\n  }\\n\\n  /**\\n   * @dev Returns the debt data of the NFT\\n   * @param nftAsset The address of the NFT\\n   * @param nftTokenId The token id of the NFT\\n   * @return loanId the loan id of the NFT\\n   * @return reserveAsset the address of the Reserve\\n   * @return totalCollateral the total power of the NFT\\n   * @return totalDebt the total debt of the NFT\\n   * @return availableBorrows the borrowing power left of the NFT\\n   * @return healthFactor the current health factor of the NFT\\n   **/\\n  function getNftDebtData(address nftAsset, uint256 nftTokenId)\\n    external\\n    view\\n    override\\n    returns (\\n      uint256 loanId,\\n      address reserveAsset,\\n      uint256 totalCollateral,\\n      uint256 totalDebt,\\n      uint256 availableBorrows,\\n      uint256 healthFactor\\n    )\\n  {\\n    DataTypes.NftData storage nftData = _nfts[nftAsset];\\n\\n    (uint256 ltv, uint256 liquidationThreshold, ) = nftData.configuration.getCollateralParams();\\n\\n    loanId = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getCollateralLoanId(nftAsset, nftTokenId);\\n    if (loanId == 0) {\\n      return (0, address(0), 0, 0, 0, 0);\\n    }\\n\\n    DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\\n\\n    reserveAsset = loan.reserveAsset;\\n    DataTypes.ReserveData storage reserveData = _reserves[reserveAsset];\\n\\n    (, totalCollateral) = GenericLogic.calculateNftCollateralData(\\n      reserveAsset,\\n      reserveData,\\n      nftAsset,\\n      nftData,\\n      _addressesProvider.getReserveOracle(),\\n      _addressesProvider.getNFTOracle()\\n    );\\n\\n    (, totalDebt) = GenericLogic.calculateNftDebtData(\\n      reserveAsset,\\n      reserveData,\\n      _addressesProvider.getLendPoolLoan(),\\n      loanId,\\n      _addressesProvider.getReserveOracle()\\n    );\\n\\n    availableBorrows = GenericLogic.calculateAvailableBorrows(totalCollateral, totalDebt, ltv);\\n\\n    if (loan.state == DataTypes.LoanState.Active) {\\n      healthFactor = GenericLogic.calculateHealthFactorFromBalances(totalCollateral, totalDebt, liquidationThreshold);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the auction data of the NFT\\n   * @param nftAsset The address of the NFT\\n   * @param nftTokenId The token id of the NFT\\n   * @return loanId the loan id of the NFT\\n   * @return bidderAddress the highest bidder address of the loan\\n   * @return bidPrice the highest bid price in Reserve of the loan\\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\\n   * @return bidFine the penalty fine of the loan\\n   **/\\n  function getNftAuctionData(address nftAsset, uint256 nftTokenId)\\n    external\\n    view\\n    override\\n    returns (\\n      uint256 loanId,\\n      address bidderAddress,\\n      uint256 bidPrice,\\n      uint256 bidBorrowAmount,\\n      uint256 bidFine\\n    )\\n  {\\n    DataTypes.NftData storage nftData = _nfts[nftAsset];\\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\\n\\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\\n    if (loanId != 0) {\\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\\n      DataTypes.ReserveData storage reserveData = _reserves[loan.reserveAsset];\\n\\n      bidderAddress = loan.bidderAddress;\\n      bidPrice = loan.bidPrice;\\n      bidBorrowAmount = loan.bidBorrowAmount;\\n\\n      (, bidFine) = GenericLogic.calculateLoanBidFine(\\n        loan.reserveAsset,\\n        reserveData,\\n        nftAsset,\\n        nftData,\\n        loan,\\n        address(poolLoan),\\n        _addressesProvider.getReserveOracle()\\n      );\\n    }\\n  }\\n\\n  function getNftAuctionEndTime(address nftAsset, uint256 nftTokenId)\\n    external\\n    view\\n    override\\n    returns (\\n      uint256 loanId,\\n      uint256 bidStartTimestamp,\\n      uint256 bidEndTimestamp,\\n      uint256 redeemEndTimestamp\\n    )\\n  {\\n    DataTypes.NftData storage nftData = _nfts[nftAsset];\\n    ILendPoolLoan poolLoan = ILendPoolLoan(_addressesProvider.getLendPoolLoan());\\n\\n    loanId = poolLoan.getCollateralLoanId(nftAsset, nftTokenId);\\n    if (loanId != 0) {\\n      DataTypes.LoanData memory loan = ILendPoolLoan(_addressesProvider.getLendPoolLoan()).getLoan(loanId);\\n\\n      bidStartTimestamp = loan.bidStartTimestamp;\\n      if (bidStartTimestamp > 0) {\\n        (bidEndTimestamp, redeemEndTimestamp) = GenericLogic.calculateLoanAuctionEndTimestamp(\\n          nftData,\\n          loan,\\n          _pauseStartTime,\\n          _pauseDurationTime\\n        );\\n      }\\n    }\\n  }\\n\\n  struct GetLiquidationPriceLocalVars {\\n    address poolLoan;\\n    uint256 loanId;\\n    uint256 thresholdPrice;\\n    uint256 liquidatePrice;\\n    uint256 paybackAmount;\\n    uint256 remainAmount;\\n  }\\n\\n  function getNftLiquidatePrice(address nftAsset, uint256 nftTokenId)\\n    external\\n    view\\n    override\\n    returns (uint256 liquidatePrice, uint256 paybackAmount)\\n  {\\n    GetLiquidationPriceLocalVars memory vars;\\n\\n    vars.poolLoan = _addressesProvider.getLendPoolLoan();\\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(nftAsset, nftTokenId);\\n    if (vars.loanId == 0) {\\n      return (0, 0);\\n    }\\n\\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\\n\\n    DataTypes.ReserveData storage reserveData = _reserves[loanData.reserveAsset];\\n    DataTypes.NftData storage nftData = _nfts[nftAsset];\\n\\n    (vars.paybackAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\\n      vars.loanId,\\n      loanData.reserveAsset,\\n      reserveData,\\n      loanData.nftAsset,\\n      nftData,\\n      vars.poolLoan,\\n      _addressesProvider.getReserveOracle(),\\n      _addressesProvider.getNFTOracle()\\n    );\\n\\n    if (vars.liquidatePrice < vars.paybackAmount) {\\n      vars.liquidatePrice = vars.paybackAmount;\\n    }\\n\\n    return (vars.liquidatePrice, vars.paybackAmount);\\n  }\\n\\n  /**\\n   * @dev Validates and finalizes an mToken transfer\\n   * - Only callable by the overlying mToken of the `asset`\\n   * @param asset The address of the underlying asset of the mToken\\n   * @param from The user from which the mToken are transferred\\n   * @param to The user receiving the mTokens\\n   * @param amount The amount being transferred/withdrawn\\n   * @param balanceFromBefore The mToken balance of the `from` user before the transfer\\n   * @param balanceToBefore The mToken balance of the `to` user before the transfer\\n   */\\n  function finalizeTransfer(\\n    address asset,\\n    address from,\\n    address to,\\n    uint256 amount,\\n    uint256 balanceFromBefore,\\n    uint256 balanceToBefore,\\n    DataTypes.Period period\\n  ) external view override whenNotPaused {\\n    asset;\\n    from;\\n    to;\\n    amount;\\n    balanceFromBefore;\\n    balanceToBefore;\\n\\n    uint8 period = uint8(period);\\n    DataTypes.ReserveData storage reserve = _reserves[asset];\\n    require(_msgSender() == reserve.mTokenAddresses[period], Errors.LP_CALLER_MUST_BE_AN_MTOKEN);\\n\\n    ValidationLogic.validateTransfer(from, reserve);\\n  }\\n\\n  /**\\n   * @dev Returns the list of the initialized reserves\\n   **/\\n  function getReservesList() external view override returns (address[] memory) {\\n    address[] memory _activeReserves = new address[](_reservesCount);\\n\\n    for (uint256 i = 0; i < _reservesCount; i++) {\\n      _activeReserves[i] = _reservesList[i];\\n    }\\n    return _activeReserves;\\n  }\\n\\n  /**\\n   * @dev Returns the list of the initialized nfts\\n   **/\\n  function getNftsList() external view override returns (address[] memory) {\\n    address[] memory _activeNfts = new address[](_nftsCount);\\n\\n    for (uint256 i = 0; i < _nftsCount; i++) {\\n      _activeNfts[i] = _nftsList[i];\\n    }\\n    return _activeNfts;\\n  }\\n\\n  /**\\n   * @dev Set the _pause state of the pool\\n   * - Only callable by the LendPoolConfigurator contract\\n   * @param val `true` to pause the pool, `false` to un-pause it\\n   */\\n  function setPause(bool val) external override onlyLendPoolConfigurator {\\n    if (_paused != val) {\\n      _paused = val;\\n      if (_paused) {\\n        _pauseStartTime = block.timestamp;\\n        emit Paused();\\n      } else {\\n        _pauseDurationTime = block.timestamp - _pauseStartTime;\\n        emit Unpaused();\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns if the LendPool is paused\\n   */\\n  function paused() external view override returns (bool) {\\n    return _paused;\\n  }\\n\\n  function setPausedTime(uint256 startTime, uint256 durationTime) external override onlyLendPoolConfigurator {\\n    _pauseStartTime = startTime;\\n    _pauseDurationTime = durationTime;\\n    emit PausedTimeUpdated(startTime, durationTime);\\n  }\\n\\n  function getPausedTime() external view override returns (uint256, uint256) {\\n    return (_pauseStartTime, _pauseDurationTime);\\n  }\\n\\n  /**\\n   * @dev Returns the cached LendPoolAddressesProvider connected to this contract\\n   **/\\n  function getAddressesProvider() external view override returns (ILendPoolAddressesProvider) {\\n    return _addressesProvider;\\n  }\\n\\n  function setMaxNumberOfReserves(uint256 val) external override onlyLendPoolConfigurator {\\n    _maxNumberOfReserves = val;\\n  }\\n\\n  /**\\n   * @dev Returns the maximum number of reserves supported to be listed in this LendPool\\n   */\\n  function getMaxNumberOfReserves() public view override returns (uint256) {\\n    return _maxNumberOfReserves;\\n  }\\n\\n  function setMaxNumberOfNfts(uint256 val) external override onlyLendPoolConfigurator {\\n    _maxNumberOfNfts = val;\\n  }\\n\\n  /**\\n   * @dev Returns the maximum number of nfts supported to be listed in this LendPool\\n   */\\n  function getMaxNumberOfNfts() public view override returns (uint256) {\\n    return _maxNumberOfNfts;\\n  }\\n\\n  /**\\n   * @dev Initializes a reserve, activating it, assigning an mToken and nft loan and an\\n   * interest rate strategy\\n   * - Only callable by the LendPoolConfigurator contract\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param mTokenAddresses The address of the mToken that will be assigned to the reserve\\n   * @param debtTokenAddress The address of the debtToken that will be assigned to the reserve\\n   * @param interestRateAddress The address of the interest rate strategy contract\\n   **/\\n  function initReserve(\\n    address asset,\\n    address[4] memory mTokenAddresses,\\n    address debtTokenAddress,\\n    address interestRateAddress\\n  ) external override onlyLendPoolConfigurator {\\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\\n    _reserves[asset].init(mTokenAddresses, debtTokenAddress, interestRateAddress);\\n    _addReserveToList(asset);\\n  }\\n\\n  /**\\n   * @dev Initializes a nft, activating it, assigning nft loan and an\\n   * interest rate strategy\\n   * - Only callable by the LendPoolConfigurator contract\\n   * @param asset The address of the underlying asset of the nft\\n   **/\\n  function initNft(address asset, address bNftAddress) external override onlyLendPoolConfigurator {\\n    require(AddressUpgradeable.isContract(asset), Errors.LP_NOT_CONTRACT);\\n    _nfts[asset].init(bNftAddress);\\n    _addNftToList(asset);\\n\\n    require(_addressesProvider.getLendPoolLoan() != address(0), Errors.LPC_INVALIED_LOAN_ADDRESS);\\n    IERC721Upgradeable(asset).setApprovalForAll(_addressesProvider.getLendPoolLoan(), true);\\n\\n    ILendPoolLoan(_addressesProvider.getLendPoolLoan()).initNft(asset, bNftAddress);\\n  }\\n\\n  /**\\n   * @dev Updates the address of the interest rate strategy contract\\n   * - Only callable by the LendPoolConfigurator contract\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param rateAddress The address of the interest rate strategy contract\\n   **/\\n  function setReserveInterestRateAddress(address asset, address rateAddress)\\n    external\\n    override\\n    onlyLendPoolConfigurator\\n  {\\n    _reserves[asset].interestRateAddress = rateAddress;\\n  }\\n\\n  /**\\n   * @dev Sets the configuration bitmap of the reserve as a whole\\n   * - Only callable by the LendPoolConfigurator contract\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param configuration The new configuration bitmap\\n   **/\\n  function setReserveConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\\n    _reserves[asset].configuration.data = configuration;\\n  }\\n\\n  /**\\n   * @dev Sets the configuration bitmap of the NFT as a whole\\n   * - Only callable by the LendPoolConfigurator contract\\n   * @param asset The address of the asset of the NFT\\n   * @param configuration The new configuration bitmap\\n   **/\\n  function setNftConfiguration(address asset, uint256 configuration) external override onlyLendPoolConfigurator {\\n    _nfts[asset].configuration.data = configuration;\\n  }\\n\\n  function setNftMaxSupplyAndTokenId(\\n    address asset,\\n    uint256 maxSupply,\\n    uint256 maxTokenId\\n  ) external override onlyLendPoolConfigurator {\\n    _nfts[asset].maxSupply = maxSupply;\\n    _nfts[asset].maxTokenId = maxTokenId;\\n  }\\n\\n  function _addReserveToList(address asset) internal {\\n    uint256 reservesCount = _reservesCount;\\n\\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\\n\\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\\n\\n    if (!reserveAlreadyAdded) {\\n      _reserves[asset].id = uint8(reservesCount);\\n      _reservesList[reservesCount] = asset;\\n\\n      _reservesCount = reservesCount + 1;\\n    }\\n  }\\n\\n  function _addNftToList(address asset) internal {\\n    uint256 nftsCount = _nftsCount;\\n\\n    require(nftsCount < _maxNumberOfNfts, Errors.LP_NO_MORE_NFTS_ALLOWED);\\n\\n    bool nftAlreadyAdded = _nfts[asset].id != 0 || _nftsList[0] == asset;\\n\\n    if (!nftAlreadyAdded) {\\n      _nfts[asset].id = uint8(nftsCount);\\n      _nftsList[nftsCount] = asset;\\n\\n      _nftsCount = nftsCount + 1;\\n    }\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n\\n  function _buildLendPoolVars() internal view returns (DataTypes.ExecuteLendPoolStates memory) {\\n    return DataTypes.ExecuteLendPoolStates({pauseStartTime: _pauseStartTime, pauseDurationTime: _pauseDurationTime});\\n  }\\n}\"\r\n    },\r\n    \"contracts/interfaces/ILendPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {ILendPoolAddressesProvider} from \\\"./ILendPoolAddressesProvider.sol\\\";\\nimport {DataTypes} from \\\"../libraries/types/DataTypes.sol\\\";\\n\\ninterface ILendPool {\\n  /**\\n   * @dev Emitted on deposit()\\n   * @param user The address initiating the deposit\\n   * @param amount The amount deposited\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param onBehalfOf The beneficiary of the deposit, receiving the mTokens\\n   * @param period The period of the deposit\\n   * @param referral The referral code used\\n   **/\\n  event Deposit(\\n    address user,\\n    address indexed reserve,\\n    uint256 amount,\\n    address indexed onBehalfOf,\\n    uint8  period,\\n    uint16 indexed referral\\n  );\\n\\n  /**\\n   * @dev Emitted on withdraw()\\n   * @param user The address initiating the withdrawal, owner of mTokens\\n   * @param reserve The address of the underlyng asset being withdrawn\\n   * @param amount The amount to be withdrawn\\n   * @param to Address that will receive the underlying\\n   **/\\n  event Withdraw(address indexed user, address indexed reserve, uint256 amount, address indexed to, uint8 period);\\n\\n  /**\\n   * @dev Emitted on borrow() when loan needs to be opened\\n   * @param user The address of the user initiating the borrow(), receiving the funds\\n   * @param reserve The address of the underlying asset being borrowed\\n   * @param amount The amount borrowed out\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token id of the underlying NFT used as collateral\\n   * @param onBehalfOf The address that will be getting the loan\\n   * @param referral The referral code used\\n   **/\\n  event Borrow(\\n    address user,\\n    address indexed reserve,\\n    uint256 amount,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address indexed onBehalfOf,\\n    uint256 borrowRate,\\n    uint256 loanId,\\n    uint16 indexed referral\\n  );\\n\\n  /**\\n   * @dev Emitted on repay()\\n   * @param user The address of the user initiating the repay(), providing the funds\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param amount The amount repaid\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token id of the underlying NFT used as collateral\\n   * @param borrower The beneficiary of the repayment, getting his debt reduced\\n   * @param loanId The loan ID of the NFT loans\\n   **/\\n  event Repay(\\n    address user,\\n    address indexed reserve,\\n    uint256 amount,\\n    address indexed nftAsset,\\n    uint256 nftTokenId,\\n    address indexed borrower,\\n    uint256 loanId\\n  );\\n\\n  /**\\n   * @dev Emitted when a borrower's loan is auctioned.\\n   * @param user The address of the user initiating the auction\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param bidPrice The price of the underlying reserve given by the bidder\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token id of the underlying NFT used as collateral\\n   * @param onBehalfOf The address that will be getting the NFT\\n   * @param loanId The loan ID of the NFT loans\\n   **/\\n  event Auction(\\n    address user,\\n    address indexed reserve,\\n    uint256 bidPrice,\\n    address indexed nftAsset,\\n    uint256 nftTokenId,\\n    address onBehalfOf,\\n    address indexed borrower,\\n    uint256 loanId\\n  );\\n\\n  event LiquidatingBuy(\\n    address user,\\n    address indexed reserve,\\n    uint256 liquidatingBuyPrice,\\n    uint256 remainAmount,\\n    address indexed nftAsset,\\n    uint256 nftTokenId,\\n    address onBehalfOf,\\n    address indexed borrower,\\n    uint256 loanId\\n  );\\n\\n  /**\\n   * @dev Emitted on redeem()\\n   * @param user The address of the user initiating the redeem(), providing the funds\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param borrowAmount The borrow amount repaid\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token id of the underlying NFT used as collateral\\n   * @param loanId The loan ID of the NFT loans\\n   **/\\n  event Redeem(\\n    address user,\\n    address indexed reserve,\\n    uint256 borrowAmount,\\n    uint256 fineAmount,\\n    address indexed nftAsset,\\n    uint256 nftTokenId,\\n    address indexed borrower,\\n    uint256 loanId\\n  );\\n\\n  /**\\n   * @dev Emitted when a borrower's loan is liquidated.\\n   * @param user The address of the user initiating the auction\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param repayAmount The amount of reserve repaid by the liquidator\\n   * @param remainAmount The amount of reserve received by the borrower\\n   * @param loanId The loan ID of the NFT loans\\n   **/\\n  event Liquidate(\\n    address user,\\n    address indexed reserve,\\n    uint256 repayAmount,\\n    uint256 remainAmount,\\n    address indexed nftAsset,\\n    uint256 nftTokenId,\\n    address indexed borrower,\\n    uint256 loanId\\n  );\\n\\n  /**\\n   * @dev Emitted when the pause is triggered.\\n   */\\n  event Paused();\\n\\n  /**\\n   * @dev Emitted when the pause is lifted.\\n   */\\n  event Unpaused();\\n\\n  /**\\n   * @dev Emitted when the pause time is updated.\\n   */\\n  event PausedTimeUpdated(uint256 startTime, uint256 durationTime);\\n\\n  /**\\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\\n   * the event will actually be fired by the LendPool contract. The event is therefore replicated here so it\\n   * gets added to the LendPool ABI\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param liquidityRates The new liquidity rate\\n   * @param variableBorrowRate The new variable borrow rate\\n   * @param liquidityIndices The new liquidity index\\n   * @param variableBorrowIndex The new variable borrow index\\n   **/\\n  event ReserveDataUpdated(\\n    address indexed asset,\\n    uint256[4] liquidityRates,\\n    uint256 variableBorrowRate,\\n    uint128[4] liquidityIndices,\\n    uint256 variableBorrowIndex\\n  );\\n\\n  /**\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying mTokens.\\n   * - E.g. User deposits 100 USDC and gets in return 100 bUSDC\\n   * @param reserve The address of the underlying asset to deposit\\n   * @param amount The amount to be deposited\\n   * @param onBehalfOf The address that will receive the mTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of mTokens\\n   *   is a different wallet\\n   * @param period The period of the deposit\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function deposit(\\n    address reserve,\\n    uint256 amount,\\n    address onBehalfOf,\\n    DataTypes.Period period,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent mTokens owned\\n   * E.g. User has 100 bUSDC, calls withdraw() and receives 100 USDC, burning the 100 bUSDC\\n   * @param reserve The address of the underlying asset to withdraw\\n   * @param amount The underlying amount to be withdrawn\\n   *   - Send the value type(uint256).max in order to withdraw the whole mToken balance\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n   *   different wallet\\n   * @return The final amount withdrawn\\n   **/\\n  function withdraw(\\n    address reserve,\\n    uint256 amount,\\n    address to,\\n    DataTypes.Period period\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\n   * already deposited enough collateral\\n   * - E.g. User borrows 100 USDC, receiving the 100 USDC in his wallet\\n   *   and lock collateral asset in contract\\n   * @param reserveAsset The address of the underlying asset to borrow\\n   * @param amount The amount to be borrowed\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\\n   * @param onBehalfOf Address of the user who will receive the loan. Should be the address of the borrower itself\\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\n   * if he has been given credit delegation allowance\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function borrow(\\n    address reserveAsset,\\n    uint256 amount,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address onBehalfOf,\\n    uint16 referralCode\\n  ) external;\\n\\n  function batchBorrow(\\n    address[] calldata assets,\\n    uint256[] calldata amounts,\\n    address[] calldata nftAssets,\\n    uint256[] calldata nftTokenIds,\\n    address onBehalfOf,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent loan owned\\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\\n   * @param amount The amount to repay\\n   * @return The final amount repaid, loan is burned or not\\n   **/\\n  function repay(\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 amount\\n  ) external returns (uint256, bool);\\n\\n  function batchRepay(\\n    address[] calldata nftAssets,\\n    uint256[] calldata nftTokenIds,\\n    uint256[] calldata amounts\\n  ) external returns (uint256[] memory, bool[] memory);\\n\\n  /**\\n   * @dev Function to auction a non-healthy position collateral-wise\\n   * - The caller (liquidator) want to buy collateral asset of the user getting liquidated\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\\n   * @param bidPrice The bid price of the liquidator want to buy the underlying NFT\\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of NFT\\n   *   is a different wallet\\n   **/\\n  function auction(\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 bidPrice,\\n    address onBehalfOf\\n  ) external;\\n\\n  /**\\n   * @notice Redeem a NFT loan which state is in Auction\\n   * - E.g. User repays 100 USDC, burning loan and receives collateral asset\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\\n   * @param amount The amount to repay the debt\\n   * @param bidFine The amount of bid fine\\n   **/\\n  function redeem(\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 amount,\\n    uint256 bidFine\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Function to liquidate a non-healthy position collateral-wise\\n   * - The caller (liquidator) buy collateral asset of the user getting liquidated, and receives\\n   *   the collateral asset\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\\n   **/\\n  function liquidate(\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 amount\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Function to liquidating buy a non-healthy position collateral-wise\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token ID of the underlying NFT used as collateral\\n   * @param liquidatingBuyPrice The bid price of the liquidator want to buy the underlying NFT\\n   * @param onBehalfOf Address of the user who will get the underlying NFT, same as msg.sender if the user\\n   **/\\n  function liquidatingBuy(\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 liquidatingBuyPrice,\\n    address onBehalfOf\\n  ) external;\\n\\n  /**\\n   * @dev Validates and finalizes an mToken transfer\\n   * - Only callable by the overlying mToken of the `asset`\\n   * @param asset The address of the underlying asset of the mToken\\n   * @param from The user from which the mTokens are transferred\\n   * @param to The user receiving the mTokens\\n   * @param amount The amount being transferred/withdrawn\\n   * @param balanceFromBefore The mToken balance of the `from` user before the transfer\\n   * @param balanceToBefore The mToken balance of the `to` user before the transfer\\n   */\\n  function finalizeTransfer(\\n    address asset,\\n    address from,\\n    address to,\\n    uint256 amount,\\n    uint256 balanceFromBefore,\\n    uint256 balanceToBefore,\\n    DataTypes.Period period\\n  ) external view;\\n\\n  function getReserveConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\\n\\n  function getNftConfiguration(address asset) external view returns (DataTypes.NftConfigurationMap memory);\\n\\n  /**\\n   * @dev Returns the normalized income normalized income of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve's normalized income\\n   */\\n  function getReserveNormalizedIncome(address asset, DataTypes.Period period) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the normalized variable debt per unit of asset\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve normalized variable debt\\n   */\\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state of the reserve\\n   **/\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\n\\n  function getReservesList() external view returns (address[] memory);\\n\\n  function getNftData(address asset) external view returns (DataTypes.NftData memory);\\n\\n  /**\\n   * @dev Returns the loan data of the NFT\\n   * @param nftAsset The address of the NFT\\n   * @param reserveAsset The address of the Reserve\\n   * @return totalCollateralInETH the total collateral in ETH of the NFT\\n   * @return totalCollateralInReserve the total collateral in Reserve of the NFT\\n   * @return availableBorrowsInETH the borrowing power in ETH of the NFT\\n   * @return availableBorrowsInReserve the borrowing power in Reserve of the NFT\\n   * @return ltv the loan to value of the user\\n   * @return liquidationThreshold the liquidation threshold of the NFT\\n   * @return liquidationBonus the liquidation bonus of the NFT\\n   **/\\n  function getNftCollateralData(address nftAsset, address reserveAsset)\\n    external\\n    view\\n    returns (\\n      uint256 totalCollateralInETH,\\n      uint256 totalCollateralInReserve,\\n      uint256 availableBorrowsInETH,\\n      uint256 availableBorrowsInReserve,\\n      uint256 ltv,\\n      uint256 liquidationThreshold,\\n      uint256 liquidationBonus\\n    );\\n\\n  /**\\n   * @dev Returns the debt data of the NFT\\n   * @param nftAsset The address of the NFT\\n   * @param nftTokenId The token id of the NFT\\n   * @return loanId the loan id of the NFT\\n   * @return reserveAsset the address of the Reserve\\n   * @return totalCollateral the total power of the NFT\\n   * @return totalDebt the total debt of the NFT\\n   * @return availableBorrows the borrowing power left of the NFT\\n   * @return healthFactor the current health factor of the NFT\\n   **/\\n  function getNftDebtData(address nftAsset, uint256 nftTokenId)\\n    external\\n    view\\n    returns (\\n      uint256 loanId,\\n      address reserveAsset,\\n      uint256 totalCollateral,\\n      uint256 totalDebt,\\n      uint256 availableBorrows,\\n      uint256 healthFactor\\n    );\\n\\n  /**\\n   * @dev Returns the auction data of the NFT\\n   * @param nftAsset The address of the NFT\\n   * @param nftTokenId The token id of the NFT\\n   * @return loanId the loan id of the NFT\\n   * @return bidderAddress the highest bidder address of the loan\\n   * @return bidPrice the highest bid price in Reserve of the loan\\n   * @return bidBorrowAmount the borrow amount in Reserve of the loan\\n   * @return bidFine the penalty fine of the loan\\n   **/\\n  function getNftAuctionData(address nftAsset, uint256 nftTokenId)\\n    external\\n    view\\n    returns (\\n      uint256 loanId,\\n      address bidderAddress,\\n      uint256 bidPrice,\\n      uint256 bidBorrowAmount,\\n      uint256 bidFine\\n    );\\n\\n  function getNftAuctionEndTime(address nftAsset, uint256 nftTokenId)\\n    external\\n    view\\n    returns (\\n      uint256 loanId,\\n      uint256 bidStartTimestamp,\\n      uint256 bidEndTimestamp,\\n      uint256 redeemEndTimestamp\\n    );\\n\\n  function getNftLiquidatePrice(address nftAsset, uint256 nftTokenId)\\n    external\\n    view\\n    returns (uint256 liquidatePrice, uint256 paybackAmount);\\n\\n  function getNftsList() external view returns (address[] memory);\\n\\n  /**\\n   * @dev Set the _pause state of a reserve\\n   * - Only callable by the LendPool contract\\n   * @param val `true` to pause the reserve, `false` to un-pause it\\n   */\\n  function setPause(bool val) external;\\n\\n  function setPausedTime(uint256 startTime, uint256 durationTime) external;\\n\\n  /**\\n   * @dev Returns if the LendPool is paused\\n   */\\n  function paused() external view returns (bool);\\n\\n  function getPausedTime() external view returns (uint256, uint256);\\n\\n  function getAddressesProvider() external view returns (ILendPoolAddressesProvider);\\n\\n  function initReserve(\\n    address asset,\\n    address[4] memory mTokenAddresses,\\n    address debtTokenAddress,\\n    address interestRateAddress\\n  ) external;\\n\\n  function initNft(address asset, address bNftAddress) external;\\n\\n  function setReserveInterestRateAddress(address asset, address rateAddress) external;\\n\\n  function setReserveConfiguration(address asset, uint256 configuration) external;\\n\\n  function setNftConfiguration(address asset, uint256 configuration) external;\\n\\n  function setNftMaxSupplyAndTokenId(\\n    address asset,\\n    uint256 maxSupply,\\n    uint256 maxTokenId\\n  ) external;\\n\\n  function setMaxNumberOfReserves(uint256 val) external;\\n\\n  function setMaxNumberOfNfts(uint256 val) external;\\n\\n  function getMaxNumberOfReserves() external view returns (uint256);\\n\\n  function getMaxNumberOfNfts() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendPoolLoan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {DataTypes} from \\\"../libraries/types/DataTypes.sol\\\";\\n\\ninterface ILendPoolLoan {\\n  /**\\n   * @dev Emitted on initialization to share location of dependent notes\\n   * @param pool The address of the associated lend pool\\n   */\\n  event Initialized(address indexed pool);\\n\\n  /**\\n   * @dev Emitted when a loan is created\\n   * @param user The address initiating the action\\n   */\\n  event LoanCreated(\\n    address indexed user,\\n    address indexed onBehalfOf,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address reserveAsset,\\n    uint256 amount,\\n    uint256 borrowIndex\\n  );\\n\\n  /**\\n   * @dev Emitted when a loan is updated\\n   * @param user The address initiating the action\\n   */\\n  event LoanUpdated(\\n    address indexed user,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address reserveAsset,\\n    uint256 amountAdded,\\n    uint256 amountTaken,\\n    uint256 borrowIndex\\n  );\\n\\n  /**\\n   * @dev Emitted when a loan is repaid by the borrower\\n   * @param user The address initiating the action\\n   */\\n  event LoanRepaid(\\n    address indexed user,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address reserveAsset,\\n    uint256 amount,\\n    uint256 borrowIndex\\n  );\\n\\n  /**\\n   * @dev Emitted when a loan is auction by the liquidator\\n   * @param user The address initiating the action\\n   */\\n  event LoanAuctioned(\\n    address indexed user,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 amount,\\n    uint256 borrowIndex,\\n    address bidder,\\n    uint256 price,\\n    address previousBidder,\\n    uint256 previousPrice\\n  );\\n\\n  /**\\n   * @dev Emitted when a loan is liquidating bought by the liquidator\\n   * @param user The address initiating the action\\n   */\\n  event LoanLiquidatingBought(\\n    address indexed user,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    uint256 amount,\\n    uint256 borrowIndex,\\n    address buyer,\\n    uint256 price\\n  );\\n\\n  /**\\n   * @dev Emitted when a loan is redeemed\\n   * @param user The address initiating the action\\n   */\\n  event LoanRedeemed(\\n    address indexed user,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address reserveAsset,\\n    uint256 amountTaken,\\n    uint256 borrowIndex\\n  );\\n\\n  /**\\n   * @dev Emitted when a loan is liquidate by the liquidator\\n   * @param user The address initiating the action\\n   */\\n  event LoanLiquidated(\\n    address indexed user,\\n    uint256 indexed loanId,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address reserveAsset,\\n    uint256 amount,\\n    uint256 borrowIndex\\n  );\\n\\n  event LoanRepaidInterceptorUpdated(address nftAsset, uint256 tokenId, address indexed interceptor, bool approved);\\n\\n  function initNft(address nftAsset, address bNftAddress) external;\\n\\n  /**\\n   * @dev Create store a loan object with some params\\n   * @param initiator The address of the user initiating the borrow\\n   * @param onBehalfOf The address receiving the loan\\n   */\\n  function createLoan(\\n    address initiator,\\n    address onBehalfOf,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address bNftAddress,\\n    address reserveAsset,\\n    uint256 amount,\\n    uint256 borrowIndex\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Update the given loan with some params\\n   *\\n   * Requirements:\\n   *  - The caller must be a holder of the loan\\n   *  - The loan must be in state Active\\n   * @param initiator The address of the user initiating the borrow\\n   */\\n  function updateLoan(\\n    address initiator,\\n    uint256 loanId,\\n    uint256 amountAdded,\\n    uint256 amountTaken,\\n    uint256 borrowIndex\\n  ) external;\\n\\n  /**\\n   * @dev Repay the given loan\\n   *\\n   * Requirements:\\n   *  - The caller must be a holder of the loan\\n   *  - The caller must send in principal + interest\\n   *  - The loan must be in state Active\\n   *\\n   * @param initiator The address of the user initiating the repay\\n   * @param loanId The loan getting burned\\n   * @param bNftAddress The address of bNFT\\n   */\\n  function repayLoan(\\n    address initiator,\\n    uint256 loanId,\\n    address bNftAddress,\\n    uint256 amount,\\n    uint256 borrowIndex\\n  ) external;\\n\\n  /**\\n   * @dev Auction the given loan\\n   *\\n   * Requirements:\\n   *  - The price must be greater than current highest price\\n   *  - The loan must be in state Active or Auction\\n   *\\n   * @param initiator The address of the user initiating the auction\\n   * @param loanId The loan getting auctioned\\n   * @param bidPrice The bid price of this auction\\n   */\\n  function auctionLoan(\\n    address initiator,\\n    uint256 loanId,\\n    address onBehalfOf,\\n    uint256 bidPrice,\\n    uint256 borrowAmount,\\n    uint256 borrowIndex\\n  ) external;\\n\\n  /**\\n   * @dev Redeem the given loan with some params\\n   *\\n   * Requirements:\\n   *  - The caller must be a holder of the loan\\n   *  - The loan must be in state Auction\\n   * @param initiator The address of the user initiating the borrow\\n   */\\n  function redeemLoan(\\n    address initiator,\\n    uint256 loanId,\\n    uint256 amountTaken,\\n    uint256 borrowIndex\\n  ) external;\\n\\n  /**\\n   * @dev Liquidate the given loan\\n   *\\n   * Requirements:\\n   *  - The caller must send in principal + interest\\n   *  - The loan must be in state Active\\n   *\\n   * @param initiator The address of the user initiating the auction\\n   * @param loanId The loan getting burned\\n   * @param bNftAddress The address of bNFT\\n   */\\n  function liquidateLoan(\\n    address initiator,\\n    uint256 loanId,\\n    address bNftAddress,\\n    uint256 borrowAmount,\\n    uint256 borrowIndex\\n  ) external;\\n\\n\\n  /**\\n   * @dev Liquidating buy the given loan\\n   * @param initiator The address of the user initiating the auction\\n   * @param loanId The loan getting burned\\n   * @param bNftAddress The address of bNFT\\n   * @param onBehalfOf The address receiving the loan\\n   * @param bidPrice The bid price of this auction\\n   * @param borrowAmount The borrow amount of this auction\\n   * @param borrowIndex The borrow index of this auction\\n   */\\n  function liquidatingBuyLoan(\\n    address initiator,\\n    uint256 loanId,\\n    address bNftAddress,\\n    address onBehalfOf,\\n    uint256 bidPrice,\\n    uint256 borrowAmount,\\n    uint256 borrowIndex\\n  ) external;\\n\\n  /**\\n   * @dev Add or remove the interceptor from the whitelist\\n   * @param interceptor The address of the interceptor contract\\n   * @param approved add or remove\\n   */\\n  function approveLoanRepaidInterceptor(address interceptor, bool approved) external;\\n\\n  function isLoanRepaidInterceptorApproved(address interceptor) external view returns (bool);\\n\\n  function purgeLoanRepaidInterceptor(\\n    address nftAddress,\\n    uint256[] calldata tokenIds,\\n    address interceptor\\n  ) external;\\n\\n  function addLoanRepaidInterceptor(address nftAsset, uint256 tokenId) external;\\n\\n  function deleteLoanRepaidInterceptor(address nftAsset, uint256 tokenId) external;\\n\\n  function getLoanRepaidInterceptors(address nftAsset, uint256 tokenId) external view returns (address[] memory);\\n\\n  /**\\n   * @dev Add or remove the locker from the whitelist\\n   * @param locker The address of the locker contract\\n   * @param approved add or remove\\n   */\\n  function approveFlashLoanLocker(address locker, bool approved) external;\\n\\n  function isFlashLoanLockerApproved(address locker) external view returns (bool);\\n\\n  /**\\n   * @dev Lock or unlock the flash loan caller\\n   * @param nftAsset The address of the NFT asset\\n   * @param tokenId The id of the NFT token\\n   * @param locked lock or unlock\\n   */\\n  function setFlashLoanLocking(\\n    address nftAsset,\\n    uint256 tokenId,\\n    bool locked\\n  ) external;\\n\\n  function purgeFlashLoanLocking(\\n    address nftAsset,\\n    uint256[] calldata tokenIds,\\n    address locker\\n  ) external;\\n\\n  function borrowerOf(uint256 loanId) external view returns (address);\\n\\n  function getCollateralLoanId(address nftAsset, uint256 nftTokenId) external view returns (uint256);\\n\\n  function getLoan(uint256 loanId) external view returns (DataTypes.LoanData memory loanData);\\n\\n  function getLoanCollateralAndReserve(uint256 loanId)\\n    external\\n    view\\n    returns (\\n      address nftAsset,\\n      uint256 nftTokenId,\\n      address reserveAsset,\\n      uint256 scaledAmount\\n    );\\n\\n  function getLoanReserveBorrowScaledAmount(uint256 loanId) external view returns (address, uint256);\\n\\n  function getLoanReserveBorrowAmount(uint256 loanId) external view returns (address, uint256);\\n\\n  function getLoanHighestBid(uint256 loanId) external view returns (address, uint256);\\n\\n  function getNftCollateralAmount(address nftAsset) external view returns (uint256);\\n\\n  function getUserNftCollateralAmount(address user, address nftAsset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\n/**\\n * @title LendPoolAddressesProvider contract\\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\\n * - Owned by the MetaFire Governance\\n * @author MetaFire\\n **/\\ninterface ILendPoolAddressesProvider {\\n  event MarketIdSet(string newMarketId);\\n  event LendPoolUpdated(address indexed newAddress, bytes encodedCallData);\\n  event ConfigurationAdminUpdated(address indexed newAddress);\\n  event EmergencyAdminUpdated(address indexed newAddress);\\n  event LendPoolConfiguratorUpdated(address indexed newAddress, bytes encodedCallData);\\n  event ReserveOracleUpdated(address indexed newAddress);\\n  event NftOracleUpdated(address indexed newAddress);\\n  event LendPoolLoanUpdated(address indexed newAddress, bytes encodedCallData);\\n  event ProxyCreated(bytes32 id, address indexed newAddress);\\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy, bytes encodedCallData);\\n  event BNFTRegistryUpdated(address indexed newAddress);\\n  event IncentivesControllerUpdated(address indexed newAddress);\\n  event UIDataProviderUpdated(address indexed newAddress);\\n  event MetaFireDataProviderUpdated(address indexed newAddress);\\n  event WalletBalanceProviderUpdated(address indexed newAddress);\\n\\n  function getMarketId() external view returns (string memory);\\n\\n  function setMarketId(string calldata marketId) external;\\n\\n  function setAddress(bytes32 id, address newAddress) external;\\n\\n  function setAddressAsProxy(\\n    bytes32 id,\\n    address impl,\\n    bytes memory encodedCallData\\n  ) external;\\n\\n  function getAddress(bytes32 id) external view returns (address);\\n\\n  function getLendPool() external view returns (address);\\n\\n  function setLendPoolImpl(address pool, bytes memory encodedCallData) external;\\n\\n  function getLendPoolConfigurator() external view returns (address);\\n\\n  function setLendPoolConfiguratorImpl(address configurator, bytes memory encodedCallData) external;\\n\\n  function getPoolAdmin() external view returns (address);\\n\\n  function setPoolAdmin(address admin) external;\\n\\n  function getEmergencyAdmin() external view returns (address);\\n\\n  function setEmergencyAdmin(address admin) external;\\n\\n  function getReserveOracle() external view returns (address);\\n\\n  function setReserveOracle(address reserveOracle) external;\\n\\n  function getNFTOracle() external view returns (address);\\n\\n  function setNFTOracle(address nftOracle) external;\\n\\n  function getLendPoolLoan() external view returns (address);\\n\\n  function setLendPoolLoanImpl(address loan, bytes memory encodedCallData) external;\\n\\n  function getBNFTRegistry() external view returns (address);\\n\\n  function setBNFTRegistry(address factory) external;\\n\\n  function getIncentivesController() external view returns (address);\\n\\n  function setIncentivesController(address controller) external;\\n\\n  function getUIDataProvider() external view returns (address);\\n\\n  function setUIDataProvider(address provider) external;\\n\\n  function getMetaFireDataProvider() external view returns (address);\\n\\n  function setMetaFireDataProvider(address provider) external;\\n\\n  function getWalletBalanceProvider() external view returns (address);\\n\\n  function setWalletBalanceProvider(address provider) external;\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/LendPoolStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {DataTypes} from \\\"../libraries/types/DataTypes.sol\\\";\\nimport {ReserveLogic} from \\\"../libraries/logic/ReserveLogic.sol\\\";\\nimport {NftLogic} from \\\"../libraries/logic/NftLogic.sol\\\";\\nimport {ILendPoolAddressesProvider} from \\\"../interfaces/ILendPoolAddressesProvider.sol\\\";\\n\\ncontract LendPoolStorage {\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using NftLogic for DataTypes.NftData;\\n\\n  ILendPoolAddressesProvider internal _addressesProvider;\\n\\n  mapping(address => DataTypes.ReserveData) internal _reserves;\\n  mapping(address => DataTypes.NftData) internal _nfts;\\n\\n  mapping(uint256 => address) internal _reservesList;\\n  uint256 internal _reservesCount;\\n\\n  mapping(uint256 => address) internal _nftsList;\\n  uint256 internal _nftsCount;\\n\\n  bool internal _paused;\\n\\n  uint256 internal _maxNumberOfReserves;\\n  uint256 internal _maxNumberOfNfts;\\n\\n  // !!! Never add new variable at here, because this contract is inherited by LendPool !!!\\n  // !!! Add new variable at LendPool directly !!!\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/LendPoolStorageExt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\ncontract LendPoolStorageExt {\\n  // !!! Add new variable MUST append it only, do not insert, update type & name, or change order !!!\\n  // https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#potentially-unsafe-operations\\n\\n  uint256 internal constant _NOT_ENTERED = 0;\\n  uint256 internal constant _ENTERED = 1;\\n  uint256 internal _status;\\n\\n  uint256 internal _pauseStartTime;\\n  uint256 internal _pauseDurationTime;\\n\\n  // For upgradable, add one new variable above, minus 1 at here\\n  uint256[47] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/NftLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\n\\n/**\\n * @title NftLogic library\\n * @author MetaFire\\n * @notice Implements the logic to update the nft state\\n */\\nlibrary NftLogic {\\n  /**\\n   * @dev Initializes a nft\\n   * @param nft The nft object\\n   * @param bNftAddress The address of the bNFT contract\\n   **/\\n  function init(DataTypes.NftData storage nft, address bNftAddress) external {\\n    require(nft.bNftAddress == address(0), Errors.RL_RESERVE_ALREADY_INITIALIZED);\\n\\n    nft.bNftAddress = bNftAddress;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/PercentageMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\n\\n/**\\n * @title PercentageMath library\\n * @author MetaFire\\n * @notice Provides functions to perform percentage calculations\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\n * @dev Operations are rounded half up\\n **/\\n\\nlibrary PercentageMath {\\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\\n  uint256 constant ONE_PERCENT = 1e2; //100, 1%\\n  uint256 constant TEN_PERCENT = 1e3; //1000, 10%\\n  uint256 constant ONE_THOUSANDTH_PERCENT = 1e1; //10, 0.1%\\n  uint256 constant ONE_TEN_THOUSANDTH_PERCENT = 1; //1, 0.01%\\n\\n  /**\\n   * @dev Executes a percentage multiplication\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param percentage The percentage of the value to be calculated\\n   * @return The percentage of value\\n   **/\\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\\n    if (value == 0 || percentage == 0) {\\n      return 0;\\n    }\\n\\n    require(value <= (type(uint256).max - HALF_PERCENT) / percentage, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\\n  }\\n\\n  /**\\n   * @dev Executes a percentage division\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param percentage The percentage of the value to be calculated\\n   * @return The value divided the percentage\\n   **/\\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\\n    require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    uint256 halfPercentage = percentage / 2;\\n\\n    require(value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\n\\n/**\\n * @title WadRayMath library\\n * @author MetaFire\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n **/\\n\\nlibrary WadRayMath {\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant HALF_WAD = WAD / 2;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant HALF_RAY = RAY / 2;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /**\\n   * @return One ray, 1e27\\n   **/\\n  function ray() internal pure returns (uint256) {\\n    return RAY;\\n  }\\n\\n  /**\\n   * @return One wad, 1e18\\n   **/\\n\\n  function wad() internal pure returns (uint256) {\\n    return WAD;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e27/2\\n   **/\\n  function halfRay() internal pure returns (uint256) {\\n    return HALF_RAY;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e18/2\\n   **/\\n  function halfWad() internal pure returns (uint256) {\\n    return HALF_WAD;\\n  }\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n\\n    require(a <= (type(uint256).max - HALF_WAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * b + HALF_WAD) / WAD;\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    uint256 halfB = b / 2;\\n\\n    require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * WAD + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a*b, in ray\\n   **/\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n\\n    require(a <= (type(uint256).max - HALF_RAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * b + HALF_RAY) / RAY;\\n  }\\n\\n  /**\\n   * @dev Divides two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a/b, in ray\\n   **/\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    uint256 halfB = b / 2;\\n\\n    require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * RAY + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Casts ray down to wad\\n   * @param a Ray\\n   * @return a casted to wad, rounded half up to the nearest wad\\n   **/\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\n    uint256 result = halfRatio + a;\\n    require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\\n\\n    return result / WAD_RAY_RATIO;\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @param a Wad\\n   * @return a converted in ray\\n   **/\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    uint256 result = a * WAD_RAY_RATIO;\\n    require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/GenericLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {ILendPoolLoan} from \\\"../../interfaces/ILendPoolLoan.sol\\\";\\nimport {IReserveOracleGetter} from \\\"../../interfaces/IReserveOracleGetter.sol\\\";\\nimport {INFTOracleGetter} from \\\"../../interfaces/INFTOracleGetter.sol\\\";\\nimport {WadRayMath} from \\\"../math/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../math/PercentageMath.sol\\\";\\nimport {ReserveConfiguration} from \\\"../configuration/ReserveConfiguration.sol\\\";\\nimport {NftConfiguration} from \\\"../configuration/NftConfiguration.sol\\\";\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\nimport {ReserveLogic} from \\\"./ReserveLogic.sol\\\";\\n\\n/**\\n * @title GenericLogic library\\n * @author MetaFire\\n * @notice Implements protocol-level logic to calculate and validate the state of a user\\n */\\nlibrary GenericLogic {\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using WadRayMath for uint256;\\n  using PercentageMath for uint256;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n  using NftConfiguration for DataTypes.NftConfigurationMap;\\n\\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\\n\\n  struct CalculateLoanDataVars {\\n    uint256 reserveUnitPrice;\\n    uint256 reserveUnit;\\n    uint256 reserveDecimals;\\n    uint256 healthFactor;\\n    uint256 totalCollateralInETH;\\n    uint256 totalCollateralInReserve;\\n    uint256 totalDebtInETH;\\n    uint256 totalDebtInReserve;\\n    uint256 nftLtv;\\n    uint256 nftLiquidationThreshold;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    uint256 nftUnitPrice;\\n  }\\n\\n  /**\\n   * @dev Calculates the nft loan data.\\n   * this includes the total collateral/borrow balances in Reserve,\\n   * the Loan To Value, the Liquidation Ratio, and the Health factor.\\n   * @param reserveData Data of the reserve\\n   * @param nftData Data of the nft\\n   * @param reserveOracle The price oracle address of reserve\\n   * @param nftOracle The price oracle address of nft\\n   * @return The total collateral and total debt of the loan in Reserve, the ltv, liquidation threshold and the HF\\n   **/\\n  function calculateLoanData(\\n    address reserveAddress,\\n    DataTypes.ReserveData storage reserveData,\\n    address nftAddress,\\n    DataTypes.NftData storage nftData,\\n    address loanAddress,\\n    uint256 loanId,\\n    address reserveOracle,\\n    address nftOracle\\n  )\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    CalculateLoanDataVars memory vars;\\n\\n    (vars.nftLtv, vars.nftLiquidationThreshold, ) = nftData.configuration.getCollateralParams();\\n\\n    // calculate total borrow balance for the loan\\n    if (loanId != 0) {\\n      (vars.totalDebtInETH, vars.totalDebtInReserve) = calculateNftDebtData(\\n        reserveAddress,\\n        reserveData,\\n        loanAddress,\\n        loanId,\\n        reserveOracle\\n      );\\n    }\\n\\n    // calculate total collateral balance for the nft\\n    (vars.totalCollateralInETH, vars.totalCollateralInReserve) = calculateNftCollateralData(\\n      reserveAddress,\\n      reserveData,\\n      nftAddress,\\n      nftData,\\n      reserveOracle,\\n      nftOracle\\n    );\\n\\n    // calculate health by borrow and collateral\\n    vars.healthFactor = calculateHealthFactorFromBalances(\\n      vars.totalCollateralInReserve,\\n      vars.totalDebtInReserve,\\n      vars.nftLiquidationThreshold\\n    );\\n\\n    return (vars.totalCollateralInReserve, vars.totalDebtInReserve, vars.healthFactor);\\n  }\\n\\n  function calculateNftDebtData(\\n    address reserveAddress,\\n    DataTypes.ReserveData storage reserveData,\\n    address loanAddress,\\n    uint256 loanId,\\n    address reserveOracle\\n  ) internal view returns (uint256, uint256) {\\n    CalculateLoanDataVars memory vars;\\n\\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\\n\\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\\n    vars.reserveUnit = 10**vars.reserveDecimals;\\n\\n    vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\\n\\n    (, vars.totalDebtInReserve) = ILendPoolLoan(loanAddress).getLoanReserveBorrowAmount(loanId);\\n    vars.totalDebtInETH = (vars.totalDebtInReserve * vars.reserveUnitPrice) / vars.reserveUnit;\\n\\n    return (vars.totalDebtInETH, vars.totalDebtInReserve);\\n  }\\n\\n  function calculateNftCollateralData(\\n    address reserveAddress,\\n    DataTypes.ReserveData storage reserveData,\\n    address nftAddress,\\n    DataTypes.NftData storage nftData,\\n    address reserveOracle,\\n    address nftOracle\\n  ) internal view returns (uint256, uint256) {\\n    reserveData;\\n    nftData;\\n\\n    CalculateLoanDataVars memory vars;\\n\\n    // calculate total collateral balance for the nft\\n    // all asset price has converted to ETH based, unit is in WEI (18 decimals)\\n\\n    vars.nftUnitPrice = INFTOracleGetter(nftOracle).getAssetPrice(nftAddress);\\n    vars.totalCollateralInETH = vars.nftUnitPrice;\\n\\n    if (reserveAddress != address(0)) {\\n      vars.reserveDecimals = reserveData.configuration.getDecimals();\\n      vars.reserveUnit = 10**vars.reserveDecimals;\\n\\n      vars.reserveUnitPrice = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAddress);\\n\\n      vars.totalCollateralInReserve = (vars.totalCollateralInETH * vars.reserveUnit) / vars.reserveUnitPrice;\\n    }\\n\\n    return (vars.totalCollateralInETH, vars.totalCollateralInReserve);\\n  }\\n\\n  /**\\n   * @dev Calculates the health factor from the corresponding balances\\n   * @param totalCollateral The total collateral\\n   * @param totalDebt The total debt\\n   * @param liquidationThreshold The avg liquidation threshold\\n   * @return The health factor calculated from the balances provided\\n   **/\\n  function calculateHealthFactorFromBalances(\\n    uint256 totalCollateral,\\n    uint256 totalDebt,\\n    uint256 liquidationThreshold\\n  ) internal pure returns (uint256) {\\n    if (totalDebt == 0) return type(uint256).max;\\n\\n    return (totalCollateral.percentMul(liquidationThreshold)).wadDiv(totalDebt);\\n  }\\n\\n  /**\\n   * @dev Calculates the equivalent amount that an user can borrow, depending on the available collateral and the\\n   * average Loan To Value\\n   * @param totalCollateral The total collateral\\n   * @param totalDebt The total borrow balance\\n   * @param ltv The average loan to value\\n   * @return the amount available to borrow for the user\\n   **/\\n\\n  function calculateAvailableBorrows(\\n    uint256 totalCollateral,\\n    uint256 totalDebt,\\n    uint256 ltv\\n  ) internal pure returns (uint256) {\\n    uint256 availableBorrows = totalCollateral.percentMul(ltv);\\n\\n    if (availableBorrows < totalDebt) {\\n      return 0;\\n    }\\n\\n    availableBorrows = availableBorrows - totalDebt;\\n    return availableBorrows;\\n  }\\n\\n  struct CalcLiquidatePriceLocalVars {\\n    uint256 ltv;\\n    uint256 liquidationThreshold;\\n    uint256 liquidationBonus;\\n    uint256 nftPriceInETH;\\n    uint256 nftPriceInReserve;\\n    uint256 reserveDecimals;\\n    uint256 reservePriceInETH;\\n    uint256 thresholdPrice;\\n    uint256 liquidatePrice;\\n    uint256 borrowAmount;\\n  }\\n\\n  function calculateLoanLiquidatePrice(\\n    uint256 loanId,\\n    address reserveAsset,\\n    DataTypes.ReserveData storage reserveData,\\n    address nftAsset,\\n    DataTypes.NftData storage nftData,\\n    address poolLoan,\\n    address reserveOracle,\\n    address nftOracle\\n  )\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    CalcLiquidatePriceLocalVars memory vars;\\n\\n    /*\\n     * 0                   CR                  LH                  100\\n     * |___________________|___________________|___________________|\\n     *  <       Borrowing with Interest        <\\n     * CR: Callteral Ratio;\\n     * LH: Liquidate Threshold;\\n     * Liquidate Trigger: Borrowing with Interest > thresholdPrice;\\n     * Liquidate Price: (100% - BonusRatio) * NFT Price;\\n     */\\n\\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\\n\\n    (, vars.borrowAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanId);\\n\\n    (vars.ltv, vars.liquidationThreshold, vars.liquidationBonus) = nftData.configuration.getCollateralParams();\\n\\n    vars.nftPriceInETH = INFTOracleGetter(nftOracle).getAssetPrice(nftAsset);\\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\\n\\n    vars.nftPriceInReserve = ((10**vars.reserveDecimals) * vars.nftPriceInETH) / vars.reservePriceInETH;\\n\\n    vars.thresholdPrice = vars.nftPriceInReserve.percentMul(vars.liquidationThreshold);\\n\\n    if (vars.liquidationBonus < PercentageMath.PERCENTAGE_FACTOR) {\\n      vars.liquidatePrice = vars.nftPriceInReserve.percentMul(PercentageMath.PERCENTAGE_FACTOR - vars.liquidationBonus);\\n    }\\n\\n    if (vars.liquidatePrice < vars.borrowAmount) {\\n      vars.liquidatePrice = vars.borrowAmount;\\n    }\\n\\n    return (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice);\\n  }\\n  \\n  struct CalcLiquidatingBuyPriceLocalVars {\\n    uint256 ltv;\\n    uint256 liquidationThreshold;\\n    uint256 liquidatingBuyBonus;\\n    uint256 nftPriceInETH;\\n    uint256 nftPriceInReserve;\\n    uint256 reserveDecimals;\\n    uint256 reservePriceInETH;\\n    uint256 thresholdPrice;\\n    uint256 liquidatingBuyPrice;\\n    uint256 borrowAmount;\\n  }\\n\\n  //TODO: finish this function\\n  function calculateLoanLiquidatingBuyPrice(\\n    uint256 loanId,\\n    address reserveAsset,\\n    DataTypes.ReserveData storage reserveData,\\n    address nftAsset,\\n    DataTypes.NftData storage nftData,\\n    address poolLoan,\\n    address reserveOracle,\\n    address nftOracle\\n  )\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    CalcLiquidatingBuyPriceLocalVars memory vars;\\n\\n    /*\\n     * 0                   CR                  LH                  100\\n     * |___________________|___________________|___________________|\\n     *  <       Borrowing with Interest        <\\n     * CR: Callteral Ratio;\\n     * LH: Liquidate Threshold;\\n     * Liquidate Trigger: Borrowing with Interest > thresholdPrice;\\n     * Liquidate Price: (100% - BonusRatio) * NFT Price;\\n     */\\n\\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\\n\\n    (, vars.borrowAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanId);\\n     \\n    (vars.ltv, vars.liquidationThreshold, ) = nftData.configuration.getCollateralParams();\\n    vars.liquidatingBuyBonus = nftData.configuration.getLiquidatingBuyBonus();\\n\\n    vars.nftPriceInETH = INFTOracleGetter(nftOracle).getAssetPrice(nftAsset);\\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\\n\\n    vars.nftPriceInReserve = ((10**vars.reserveDecimals) * vars.nftPriceInETH) / vars.reservePriceInETH;\\n\\n    vars.thresholdPrice = vars.nftPriceInReserve.percentMul(vars.liquidationThreshold);\\n\\n    if (vars.liquidatingBuyBonus < PercentageMath.PERCENTAGE_FACTOR) {\\n      vars.liquidatingBuyPrice = vars.nftPriceInReserve.percentMul(PercentageMath.PERCENTAGE_FACTOR - vars.liquidatingBuyBonus);\\n    }\\n\\n    if (vars.liquidatingBuyPrice < vars.borrowAmount) {\\n      vars.liquidatingBuyPrice = vars.borrowAmount;\\n    }\\n\\n    return (vars.borrowAmount, vars.thresholdPrice, vars.liquidatingBuyPrice);\\n\\n  }\\n\\n  struct CalcLoanBidFineLocalVars {\\n    uint256 reserveDecimals;\\n    uint256 reservePriceInETH;\\n    uint256 baseBidFineInReserve;\\n    uint256 minBidFinePct;\\n    uint256 minBidFineInReserve;\\n    uint256 bidFineInReserve;\\n    uint256 debtAmount;\\n  }\\n\\n  function calculateLoanBidFine(\\n    address reserveAsset,\\n    DataTypes.ReserveData storage reserveData,\\n    address nftAsset,\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData,\\n    address poolLoan,\\n    address reserveOracle\\n  ) internal view returns (uint256, uint256) {\\n    nftAsset;\\n\\n    if (loanData.bidPrice == 0) {\\n      return (0, 0);\\n    }\\n\\n    CalcLoanBidFineLocalVars memory vars;\\n\\n    vars.reserveDecimals = reserveData.configuration.getDecimals();\\n    vars.reservePriceInETH = IReserveOracleGetter(reserveOracle).getAssetPrice(reserveAsset);\\n    vars.baseBidFineInReserve = (1 ether * 10**vars.reserveDecimals) / vars.reservePriceInETH;\\n\\n    vars.minBidFinePct = nftData.configuration.getMinBidFine();\\n    vars.minBidFineInReserve = vars.baseBidFineInReserve.percentMul(vars.minBidFinePct);\\n\\n    (, vars.debtAmount) = ILendPoolLoan(poolLoan).getLoanReserveBorrowAmount(loanData.loanId);\\n\\n    vars.bidFineInReserve = vars.debtAmount.percentMul(nftData.configuration.getRedeemFine());\\n    if (vars.bidFineInReserve < vars.minBidFineInReserve) {\\n      vars.bidFineInReserve = vars.minBidFineInReserve;\\n    }\\n\\n    return (vars.minBidFineInReserve, vars.bidFineInReserve);\\n  }\\n\\n  function calculateLoanAuctionEndTimestamp(\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData,\\n    uint256 pauseStartTime,\\n    uint256 pauseDurationTime\\n  ) internal view returns (uint256 auctionEndTimestamp, uint256 redeemEndTimestamp) {\\n    uint256 extraDuration = 0;\\n\\n    if ((pauseDurationTime > 0) && (loanData.bidStartTimestamp <= pauseStartTime)) {\\n      extraDuration = pauseDurationTime;\\n    }\\n\\n    auctionEndTimestamp =\\n      loanData.bidStartTimestamp +\\n      extraDuration +\\n      (nftData.configuration.getAuctionDuration() * 1 hours);\\n\\n    redeemEndTimestamp =\\n      loanData.bidStartTimestamp +\\n      extraDuration +\\n      (nftData.configuration.getRedeemDuration() * 1 hours);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/ValidationLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {ReserveLogic} from \\\"./ReserveLogic.sol\\\";\\nimport {GenericLogic} from \\\"./GenericLogic.sol\\\";\\nimport {WadRayMath} from \\\"../math/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../math/PercentageMath.sol\\\";\\nimport {ReserveConfiguration} from \\\"../configuration/ReserveConfiguration.sol\\\";\\nimport {NftConfiguration} from \\\"../configuration/NftConfiguration.sol\\\";\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\nimport {IInterestRate} from \\\"../../interfaces/IInterestRate.sol\\\";\\nimport {ILendPoolLoan} from \\\"../../interfaces/ILendPoolLoan.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\n\\n/**\\n * @title ValidationLogic library\\n * @author MetaFire\\n * @notice Implements functions to validate the different actions of the protocol\\n */\\nlibrary ValidationLogic {\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using WadRayMath for uint256;\\n  using PercentageMath for uint256;\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n  using NftConfiguration for DataTypes.NftConfigurationMap;\\n\\n  /**\\n   * @dev Validates a deposit action\\n   * @param reserve The reserve object on which the user is depositing\\n   * @param amount The amount to be deposited\\n   */\\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\\n\\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\\n  }\\n\\n  /**\\n   * @dev Validates a withdraw action\\n   * @param reserveData The reserve state\\n   * @param amount The amount to be withdrawn\\n   * @param userBalance The balance of the user\\n   */\\n  function validateWithdraw(\\n    DataTypes.ReserveData storage reserveData,\\n    uint256 amount,\\n    uint256 userBalance\\n  ) external view {\\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\\n\\n    (bool isActive, , , ) = reserveData.configuration.getFlags();\\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n  }\\n\\n  struct ValidateBorrowLocalVars {\\n    uint256 currentLtv;\\n    uint256 currentLiquidationThreshold;\\n    uint256 amountOfCollateralNeeded;\\n    uint256 userCollateralBalance;\\n    uint256 userBorrowBalance;\\n    uint256 availableLiquidity;\\n    uint256 healthFactor;\\n    bool isActive;\\n    bool isFrozen;\\n    bool borrowingEnabled;\\n    bool stableRateBorrowingEnabled;\\n    bool nftIsActive;\\n    bool nftIsFrozen;\\n    address loanReserveAsset;\\n    address loanBorrower;\\n  }\\n\\n  /**\\n   * @dev Validates a borrow action\\n   * @param reserveAsset The address of the asset to borrow\\n   * @param amount The amount to be borrowed\\n   * @param reserveData The reserve state from which the user is borrowing\\n   * @param nftData The state of the user for the specific nft\\n   */\\n  function validateBorrow(\\n    address user,\\n    address reserveAsset,\\n    uint256 amount,\\n    DataTypes.ReserveData storage reserveData,\\n    address nftAsset,\\n    DataTypes.NftData storage nftData,\\n    address loanAddress,\\n    uint256 loanId,\\n    address reserveOracle,\\n    address nftOracle\\n  ) external view {\\n    ValidateBorrowLocalVars memory vars;\\n\\n    for(uint256 i = 0; i < reserveData.mTokenAddresses.length; i++) {\\n      require(reserveData.mTokenAddresses[i] != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n    }\\n\\n    require(nftData.bNftAddress != address(0), Errors.LPC_INVALIED_BNFT_ADDRESS);\\n    require(amount > 0, Errors.VL_INVALID_AMOUNT);\\n\\n    if (loanId != 0) {\\n      DataTypes.LoanData memory loanData = ILendPoolLoan(loanAddress).getLoan(loanId);\\n\\n      require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\\n      require(reserveAsset == loanData.reserveAsset, Errors.VL_SPECIFIED_RESERVE_NOT_BORROWED_BY_USER);\\n      require(user == loanData.borrower, Errors.VL_SPECIFIED_LOAN_NOT_BORROWED_BY_USER);\\n    }\\n\\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserveData\\n      .configuration\\n      .getFlags();\\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\\n\\n    (vars.nftIsActive, vars.nftIsFrozen) = nftData.configuration.getFlags();\\n    require(vars.nftIsActive, Errors.VL_NO_ACTIVE_NFT);\\n    require(!vars.nftIsFrozen, Errors.VL_NFT_FROZEN);\\n\\n    (vars.currentLtv, vars.currentLiquidationThreshold, ) = nftData.configuration.getCollateralParams();\\n\\n    (vars.userCollateralBalance, vars.userBorrowBalance, vars.healthFactor) = GenericLogic.calculateLoanData(\\n      reserveAsset,\\n      reserveData,\\n      nftAsset,\\n      nftData,\\n      loanAddress,\\n      loanId,\\n      reserveOracle,\\n      nftOracle\\n    );\\n\\n    require(vars.userCollateralBalance > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\\n\\n    require(\\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\\n    );\\n\\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\\n    //LTV is calculated in percentage\\n    vars.amountOfCollateralNeeded = (vars.userBorrowBalance + amount).percentDiv(vars.currentLtv);\\n\\n    require(vars.amountOfCollateralNeeded <= vars.userCollateralBalance, Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW);\\n  }\\n\\n  /**\\n   * @dev Validates a repay action\\n   * @param reserveData The reserve state from which the user is repaying\\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\\n   * @param borrowAmount The borrow balance of the user\\n   */\\n  function validateRepay(\\n    DataTypes.ReserveData storage reserveData,\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData,\\n    uint256 amountSent,\\n    uint256 borrowAmount\\n  ) external view {\\n    require(nftData.bNftAddress != address(0), Errors.LPC_INVALIED_BNFT_ADDRESS);\\n\\n    for(uint256 i = 0; i < reserveData.mTokenAddresses.length; i++) {\\n      require(reserveData.mTokenAddresses[i] != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n    }\\n\\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\\n\\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\\n\\n    require(borrowAmount > 0, Errors.VL_NO_DEBT_OF_SELECTED_TYPE);\\n\\n    require(loanData.state == DataTypes.LoanState.Active, Errors.LPL_INVALID_LOAN_STATE);\\n  }\\n\\n  /**\\n   * @dev Validates the auction action\\n   * @param reserveData The reserve data of the principal\\n   * @param nftData The nft data of the underlying nft\\n   * @param bidPrice Total variable debt balance of the user\\n   **/\\n  function validateAuction(\\n    DataTypes.ReserveData storage reserveData,\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData,\\n    uint256 bidPrice\\n  ) internal view {\\n    require(nftData.bNftAddress != address(0), Errors.LPC_INVALIED_BNFT_ADDRESS);\\n    \\n    for(uint256 i = 0; i < reserveData.mTokenAddresses.length; i++) {\\n      require(reserveData.mTokenAddresses[i] != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n    }\\n\\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\\n\\n    require(\\n      loanData.state == DataTypes.LoanState.Active || loanData.state == DataTypes.LoanState.Auction,\\n      Errors.LPL_INVALID_LOAN_STATE\\n    );\\n\\n    require(bidPrice > 0, Errors.VL_INVALID_AMOUNT);\\n  }\\n\\n  /**\\n   * @dev Validates the liquidating buy\\n   * @param reserveData The reserve data of the principal\\n   * @param nftData The data of the underlying NFT\\n   * @param loanData The loan data of the underlying NFT\\n   * @param liquidatingBuyPrice The liquidating buy price\\n   **/\\n  function validateLiquidatingBuy(\\n    DataTypes.ReserveData storage reserveData,\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData,\\n    uint256 liquidatingBuyPrice\\n  ) internal view {\\n    require(nftData.bNftAddress != address(0), Errors.LPC_INVALIED_BNFT_ADDRESS);\\n    \\n    for(uint256 i = 0; i < reserveData.mTokenAddresses.length; i++) {\\n      require(reserveData.mTokenAddresses[i] != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n    }\\n\\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\\n\\n    require(\\n      loanData.state == DataTypes.LoanState.Active,\\n      Errors.LPL_INVALID_LOAN_STATE\\n    );\\n\\n    require(liquidatingBuyPrice > 0, Errors.VL_INVALID_AMOUNT);\\n  }\\n\\n  /**\\n   * @dev Validates a redeem action\\n   * @param reserveData The reserve state\\n   * @param nftData The nft state\\n   */\\n  function validateRedeem(\\n    DataTypes.ReserveData storage reserveData,\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData,\\n    uint256 amount\\n  ) external view {\\n    require(nftData.bNftAddress != address(0), Errors.LPC_INVALIED_BNFT_ADDRESS);\\n\\n    for(uint256 i = 0; i < reserveData.mTokenAddresses.length; i++) {\\n      require(reserveData.mTokenAddresses[i] != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n    }\\n\\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\\n\\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\\n\\n    require(loanData.bidderAddress != address(0), Errors.LPL_INVALID_BIDDER_ADDRESS);\\n\\n    require(amount > 0, Errors.VL_INVALID_AMOUNT);\\n  }\\n\\n  /**\\n   * @dev Validates the liquidation action\\n   * @param reserveData The reserve data of the principal\\n   * @param nftData The data of the underlying NFT\\n   * @param loanData The loan data of the underlying NFT\\n   **/\\n  function validateLiquidate(\\n    DataTypes.ReserveData storage reserveData,\\n    DataTypes.NftData storage nftData,\\n    DataTypes.LoanData memory loanData\\n  ) internal view {\\n    require(nftData.bNftAddress != address(0), Errors.LPC_INVALIED_BNFT_ADDRESS);\\n\\n    for(uint256 i = 0; i < reserveData.mTokenAddresses.length; i++) {\\n      require(reserveData.mTokenAddresses[i] != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n    }\\n\\n    require(reserveData.configuration.getActive(), Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    require(nftData.configuration.getActive(), Errors.VL_NO_ACTIVE_NFT);\\n\\n    require(loanData.state == DataTypes.LoanState.Auction, Errors.LPL_INVALID_LOAN_STATE);\\n\\n    require(loanData.bidderAddress != address(0), Errors.LPL_INVALID_BIDDER_ADDRESS);\\n  }\\n\\n  /**\\n   * @dev Validates an mToken transfer\\n   * @param from The user from which the mTokens are being transferred\\n   * @param reserveData The state of the reserve\\n   */\\n  function validateTransfer(address from, DataTypes.ReserveData storage reserveData) internal pure {\\n    from;\\n    reserveData;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/helpers/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\n/**\\n * @title Errors library\\n * @author MetaFire\\n * @notice Defines the error messages emitted by the different contracts of the MetaFire protocol\\n */\\nlibrary Errors {\\n  enum ReturnCode {\\n    SUCCESS,\\n    FAILED\\n  }\\n\\n  string public constant SUCCESS = \\\"0\\\";\\n\\n  //common errors\\n  string public constant CALLER_NOT_POOL_ADMIN = \\\"100\\\"; // 'The caller must be the pool admin'\\n  string public constant CALLER_NOT_ADDRESS_PROVIDER = \\\"101\\\";\\n  string public constant INVALID_FROM_BALANCE_AFTER_TRANSFER = \\\"102\\\";\\n  string public constant INVALID_TO_BALANCE_AFTER_TRANSFER = \\\"103\\\";\\n  string public constant CALLER_NOT_ONBEHALFOF_OR_IN_WHITELIST = \\\"104\\\";\\n\\n  //math library erros\\n  string public constant MATH_MULTIPLICATION_OVERFLOW = \\\"200\\\";\\n  string public constant MATH_ADDITION_OVERFLOW = \\\"201\\\";\\n  string public constant MATH_DIVISION_BY_ZERO = \\\"202\\\";\\n\\n  //validation & check errors\\n  string public constant VL_INVALID_AMOUNT = \\\"301\\\"; // 'Amount must be greater than 0'\\n  string public constant VL_NO_ACTIVE_RESERVE = \\\"302\\\"; // 'Action requires an active reserve'\\n  string public constant VL_RESERVE_FROZEN = \\\"303\\\"; // 'Action cannot be performed because the reserve is frozen'\\n  string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = \\\"304\\\"; // 'User cannot withdraw more than the available balance'\\n  string public constant VL_BORROWING_NOT_ENABLED = \\\"305\\\"; // 'Borrowing is not enabled'\\n  string public constant VL_COLLATERAL_BALANCE_IS_0 = \\\"306\\\"; // 'The collateral balance is 0'\\n  string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = \\\"307\\\"; // 'Health factor is lesser than the liquidation threshold'\\n  string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = \\\"308\\\"; // 'There is not enough collateral to cover a new borrow'\\n  string public constant VL_NO_DEBT_OF_SELECTED_TYPE = \\\"309\\\"; // 'for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt'\\n  string public constant VL_NO_ACTIVE_NFT = \\\"310\\\";\\n  string public constant VL_NFT_FROZEN = \\\"311\\\";\\n  string public constant VL_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \\\"312\\\"; // 'User did not borrow the specified currency'\\n  string public constant VL_INVALID_HEALTH_FACTOR = \\\"313\\\";\\n  string public constant VL_INVALID_ONBEHALFOF_ADDRESS = \\\"314\\\";\\n  string public constant VL_INVALID_TARGET_ADDRESS = \\\"315\\\";\\n  string public constant VL_INVALID_RESERVE_ADDRESS = \\\"316\\\";\\n  string public constant VL_SPECIFIED_LOAN_NOT_BORROWED_BY_USER = \\\"317\\\";\\n  string public constant VL_SPECIFIED_RESERVE_NOT_BORROWED_BY_USER = \\\"318\\\";\\n  string public constant VL_HEALTH_FACTOR_HIGHER_THAN_LIQUIDATION_THRESHOLD = \\\"319\\\";\\n\\n  //lend pool errors\\n  string public constant LP_CALLER_NOT_LEND_POOL_CONFIGURATOR = \\\"400\\\"; // 'The caller of the function is not the lending pool configurator'\\n  string public constant LP_IS_PAUSED = \\\"401\\\"; // 'Pool is paused'\\n  string public constant LP_NO_MORE_RESERVES_ALLOWED = \\\"402\\\";\\n  string public constant LP_NOT_CONTRACT = \\\"403\\\";\\n  string public constant LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD = \\\"404\\\";\\n  string public constant LP_BORROW_IS_EXCEED_LIQUIDATION_PRICE = \\\"405\\\";\\n  string public constant LP_NO_MORE_NFTS_ALLOWED = \\\"406\\\";\\n  string public constant LP_INVALIED_USER_NFT_AMOUNT = \\\"407\\\";\\n  string public constant LP_INCONSISTENT_PARAMS = \\\"408\\\";\\n  string public constant LP_NFT_IS_NOT_USED_AS_COLLATERAL = \\\"409\\\";\\n  string public constant LP_CALLER_MUST_BE_AN_MTOKEN = \\\"410\\\";\\n  string public constant LP_INVALIED_NFT_AMOUNT = \\\"411\\\";\\n  string public constant LP_NFT_HAS_USED_AS_COLLATERAL = \\\"412\\\";\\n  string public constant LP_DELEGATE_CALL_FAILED = \\\"413\\\";\\n  string public constant LP_AMOUNT_LESS_THAN_EXTRA_DEBT = \\\"414\\\";\\n  string public constant LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD = \\\"415\\\";\\n  string public constant LP_AMOUNT_GREATER_THAN_MAX_REPAY = \\\"416\\\";\\n  string public constant LP_NFT_TOKEN_ID_EXCEED_MAX_LIMIT = \\\"417\\\";\\n  string public constant LP_NFT_SUPPLY_NUM_EXCEED_MAX_LIMIT = \\\"418\\\";\\n  string public constant LP_CALLER_NOT_VALID_INTERCEPTOR = \\\"419\\\";\\n  string public constant LP_CALLER_NOT_VALID_LOCKER = \\\"420\\\";\\n\\n  //lend pool loan errors\\n  string public constant LPL_INVALID_LOAN_STATE = \\\"480\\\";\\n  string public constant LPL_INVALID_LOAN_AMOUNT = \\\"481\\\";\\n  string public constant LPL_INVALID_TAKEN_AMOUNT = \\\"482\\\";\\n  string public constant LPL_AMOUNT_OVERFLOW = \\\"483\\\";\\n  string public constant LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE = \\\"484\\\";\\n  string public constant LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE = \\\"485\\\";\\n  string public constant LPL_BID_REDEEM_DURATION_HAS_END = \\\"486\\\";\\n  string public constant LPL_BID_USER_NOT_SAME = \\\"487\\\";\\n  string public constant LPL_BID_REPAY_AMOUNT_NOT_ENOUGH = \\\"488\\\";\\n  string public constant LPL_BID_AUCTION_DURATION_HAS_END = \\\"489\\\";\\n  string public constant LPL_BID_AUCTION_DURATION_NOT_END = \\\"490\\\";\\n  string public constant LPL_BID_PRICE_LESS_THAN_BORROW = \\\"491\\\";\\n  string public constant LPL_INVALID_BIDDER_ADDRESS = \\\"492\\\";\\n  string public constant LPL_AMOUNT_LESS_THAN_BID_FINE = \\\"493\\\";\\n  string public constant LPL_INVALID_BID_FINE = \\\"494\\\";\\n\\n  //common token errors\\n  string public constant CT_CALLER_MUST_BE_LEND_POOL = \\\"500\\\"; // 'The caller of this function must be a lending pool'\\n  string public constant CT_INVALID_MINT_AMOUNT = \\\"501\\\"; //invalid amount to mint\\n  string public constant CT_INVALID_BURN_AMOUNT = \\\"502\\\"; //invalid amount to burn\\n  string public constant CT_BORROW_ALLOWANCE_NOT_ENOUGH = \\\"503\\\";\\n\\n  //reserve logic errors\\n  string public constant RL_RESERVE_ALREADY_INITIALIZED = \\\"601\\\"; // 'Reserve has already been initialized'\\n  string public constant RL_LIQUIDITY_INDEX_OVERFLOW = \\\"602\\\"; //  Liquidity index overflows uint128\\n  string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = \\\"603\\\"; //  Variable borrow index overflows uint128\\n  string public constant RL_LIQUIDITY_RATE_OVERFLOW = \\\"604\\\"; //  Liquidity rate overflows uint128\\n  string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = \\\"605\\\"; //  Variable borrow rate overflows uint128\\n\\n  //configure errors\\n  string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = \\\"700\\\"; // 'The liquidity of the reserve needs to be 0'\\n  string public constant LPC_INVALID_CONFIGURATION = \\\"701\\\"; // 'Invalid risk parameters for the reserve'\\n  string public constant LPC_CALLER_NOT_EMERGENCY_ADMIN = \\\"702\\\"; // 'The caller must be the emergency admin'\\n  string public constant LPC_INVALIED_BNFT_ADDRESS = \\\"703\\\";\\n  string public constant LPC_INVALIED_LOAN_ADDRESS = \\\"704\\\";\\n  string public constant LPC_NFT_LIQUIDITY_NOT_0 = \\\"705\\\";\\n\\n  //reserve config errors\\n  string public constant RC_INVALID_LTV = \\\"730\\\";\\n  string public constant RC_INVALID_LIQ_THRESHOLD = \\\"731\\\";\\n  string public constant RC_INVALID_LIQ_BONUS = \\\"732\\\";\\n  string public constant RC_INVALID_DECIMALS = \\\"733\\\";\\n  string public constant RC_INVALID_RESERVE_FACTOR = \\\"734\\\";\\n  string public constant RC_INVALID_REDEEM_DURATION = \\\"735\\\";\\n  string public constant RC_INVALID_AUCTION_DURATION = \\\"736\\\";\\n  string public constant RC_INVALID_REDEEM_FINE = \\\"737\\\";\\n  string public constant RC_INVALID_REDEEM_THRESHOLD = \\\"738\\\";\\n  string public constant RC_INVALID_MIN_BID_FINE = \\\"739\\\";\\n  string public constant RC_INVALID_MAX_BID_FINE = \\\"740\\\";\\n\\n  //address provider erros\\n  string public constant LPAPR_PROVIDER_NOT_REGISTERED = \\\"760\\\"; // 'Provider is not registered'\\n  string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = \\\"761\\\";\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/ReserveLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {IMToken} from \\\"../../interfaces/IMToken.sol\\\";\\nimport {IDebtToken} from \\\"../../interfaces/IDebtToken.sol\\\";\\nimport {IInterestRate} from \\\"../../interfaces/IInterestRate.sol\\\";\\nimport {ReserveConfiguration} from \\\"../configuration/ReserveConfiguration.sol\\\";\\nimport {MathUtils} from \\\"../math/MathUtils.sol\\\";\\nimport {WadRayMath} from \\\"../math/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../math/PercentageMath.sol\\\";\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\n\\n/**\\n * @title ReserveLogic library\\n * @author MetaFire\\n * @notice Implements the logic to update the reserves state\\n */\\nlibrary ReserveLogic {\\n  using WadRayMath for uint256;\\n  using PercentageMath for uint256;\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n  /**\\n   * @dev Emitted when the state of a reserve is updated\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param liquidityRates The new liquidity rate list\\n   * @param variableBorrowRate The new variable borrow rate\\n   * @param liquidityIndices The new liquidity index\\n   * @param variableBorrowIndex The new variable borrow index\\n   **/\\n  event ReserveDataUpdated(\\n    address indexed asset,\\n    uint256[4] liquidityRates,\\n    uint256 variableBorrowRate,\\n    uint128[4] liquidityIndices,\\n    uint256 variableBorrowIndex\\n  );\\n\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n\\n  /**\\n   * @dev Returns the ongoing normalized income for the reserve\\n   * A value of 1e27 means there is no income. As time passes, the income is accrued\\n   * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\\n   * @param reserve The reserve object\\n   * @return the normalized income. expressed in ray\\n   **/\\n   // @Todo: update timestamp choosing\\n  function getNormalizedIncome(DataTypes.ReserveData storage reserve, DataTypes.Period period) internal view returns (uint256) {\\n    uint8 period = uint8(period);\\n    uint40 timestamp = reserve.lastUpdateTimestamp;\\n\\n    //solium-disable-next-line\\n    if (timestamp == uint40(block.timestamp)) {\\n      //if the index was updated in the same block, no need to perform any calculation\\n      return reserve.liquidityIndices[period];\\n    }\\n\\n    uint256 cumulated = MathUtils.calculateLinearInterest(reserve.currentLiquidityRates[period], timestamp).rayMul(\\n      reserve.liquidityIndices[period]\\n    );\\n\\n    return cumulated;\\n  }\\n\\n  /**\\n   * @dev Returns the ongoing normalized variable debt for the reserve\\n   * A value of 1e27 means there is no debt. As time passes, the income is accrued\\n   * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\\n   * @param reserve The reserve object\\n   * @return The normalized variable debt. expressed in ray\\n   **/\\n  function getNormalizedDebt(DataTypes.ReserveData storage reserve) internal view returns (uint256) {\\n    uint40 timestamp = reserve.lastUpdateTimestamp;\\n\\n    //solium-disable-next-line\\n    if (timestamp == uint40(block.timestamp)) {\\n      //if the index was updated in the same block, no need to perform any calculation\\n      return reserve.variableBorrowIndex;\\n    }\\n\\n    uint256 cumulated = MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul(\\n      reserve.variableBorrowIndex\\n    );\\n\\n    return cumulated;\\n  }\\n\\n  /**\\n   * @dev Updates the liquidity cumulative index and the variable borrow index.\\n   * @param reserve the reserve object\\n   **/\\n  function updateState(DataTypes.ReserveData storage reserve) internal {\\n    uint256 scaledVariableDebt = IDebtToken(reserve.debtTokenAddress).scaledTotalSupply();\\n    uint256 previousVariableBorrowIndex = reserve.variableBorrowIndex;\\n    uint128[4] memory previousLiquidityIndices = reserve.liquidityIndices;\\n    uint40 lastUpdatedTimestamp = reserve.lastUpdateTimestamp;\\n\\n    (uint256[4] memory newLiquidityIndices, uint256 newVariableBorrowIndex) = _updateIndexes(\\n      reserve,\\n      scaledVariableDebt,\\n      previousLiquidityIndices,\\n      previousVariableBorrowIndex,\\n      lastUpdatedTimestamp\\n    );\\n\\n    _mintToTreasury(\\n      reserve,\\n      scaledVariableDebt,\\n      previousVariableBorrowIndex,\\n      newLiquidityIndices,\\n      newVariableBorrowIndex,\\n      lastUpdatedTimestamp\\n    );\\n  }\\n\\n  /**\\n   * @dev Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. Used for example to accumulate\\n   * the flashloan fee to the reserve, and spread it between all the depositors\\n   * @param reserve The reserve object\\n   * @param totalLiquidity The total liquidity available in the reserve\\n   * @param amount The amount to accomulate\\n   **/\\n  function cumulateToLiquidityIndex(\\n    DataTypes.ReserveData storage reserve,\\n    uint256 totalLiquidity,\\n    uint256 amount,\\n    uint8 period\\n  ) internal {\\n    uint256 amountToLiquidityRatio = amount.wadToRay().rayDiv(totalLiquidity.wadToRay());\\n\\n    uint256 result = amountToLiquidityRatio + (WadRayMath.ray());\\n\\n    result = result.rayMul(reserve.liquidityIndices[period]);\\n    require(result <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\\n\\n    reserve.liquidityIndices[period] = uint128(result);\\n  }\\n\\n  /**\\n   * @dev Initializes a reserve\\n   * @param reserve The reserve object\\n   * @param mTokenAddresses The address of the overlying mToken contract\\n   * @param debtTokenAddress The address of the overlying debtToken contract\\n   * @param interestRateAddress The address of the interest rate strategy contract\\n   **/\\n  function init(\\n    DataTypes.ReserveData storage reserve,\\n    address[4] memory mTokenAddresses,\\n    address debtTokenAddress,\\n    address interestRateAddress\\n  ) external {\\n    for (uint256 i = 0; i < reserve.mTokenAddresses.length; i++) {\\n        require(reserve.mTokenAddresses[i] == address(0), Errors.RL_RESERVE_ALREADY_INITIALIZED);\\n    }\\n\\n    uint128[4] memory liquidityIndices = [uint128(WadRayMath.ray()),uint128(WadRayMath.ray()),uint128(WadRayMath.ray()),uint128(WadRayMath.ray())];\\n    \\n    reserve.liquidityIndices = liquidityIndices;\\n    reserve.variableBorrowIndex = uint128(WadRayMath.ray());\\n    reserve.mTokenAddresses = mTokenAddresses;\\n    reserve.debtTokenAddress = debtTokenAddress;\\n    reserve.interestRateAddress = interestRateAddress;\\n  }\\n\\n  struct UpdateInterestRatesLocalVars {\\n    uint256 availableLiquidity;\\n    uint256[4] newLiquidityRates;\\n    uint256 newVariableRate;\\n    uint256 totalVariableDebt;\\n  }\\n\\n  /**\\n   * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate\\n   * @param reserve The address of the reserve to be updated\\n   * @param liquidityAdded The amount of liquidity added to the protocol (deposit or repay) in the previous action\\n   * @param liquidityTaken The amount of liquidity taken from the protocol (withdraw or borrow)\\n   **/\\n  function updateInterestRates(\\n    DataTypes.ReserveData storage reserve,\\n    address reserveAddress,\\n    address targetMTokenAddress,\\n    uint256 liquidityAdded,\\n    uint256 liquidityTaken\\n  ) internal {\\n    DataTypes.ReserveData memory _reserve = reserve;\\n    UpdateInterestRatesLocalVars memory vars;\\n    uint256 currentTotalLiquidity;\\n\\n    //calculates the total variable debt locally using the scaled borrow amount instead\\n    //of borrow amount(), as it's noticeably cheaper. Also, the index has been\\n    //updated by the previous updateState() call\\n    vars.totalVariableDebt = IDebtToken(reserve.debtTokenAddress).scaledTotalSupply().rayMul(\\n      reserve.variableBorrowIndex\\n    );\\n\\n    (vars.newLiquidityRates, vars.newVariableRate) = IInterestRate(reserve.interestRateAddress).calculateInterestRates(\\n      _reserve,\\n      targetMTokenAddress,\\n      liquidityAdded,\\n      liquidityTaken,\\n      vars.totalVariableDebt,\\n      reserve.configuration.getReserveFactor()\\n    );\\n\\n    require(vars.newVariableRate <= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW);\\n    for (uint256 i = 0; i < vars.newLiquidityRates.length; i++) {\\n      require(vars.newLiquidityRates[i] <= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW);\\n      reserve.currentLiquidityRates[i] = uint128(vars.newLiquidityRates[i]);\\n    }\\n    \\n    \\n    reserve.currentVariableBorrowRate = uint128(vars.newVariableRate);\\n\\n    emit ReserveDataUpdated(\\n      reserveAddress,\\n      vars.newLiquidityRates,\\n      vars.newVariableRate,\\n      reserve.liquidityIndices,\\n      reserve.variableBorrowIndex\\n    );\\n  }\\n\\n  struct MintToTreasuryLocalVars {\\n    uint256 currentVariableDebt;\\n    uint256 previousVariableDebt;\\n    uint256 totalDebtAccrued;\\n    uint256 amountToMint;\\n    uint256 reserveFactor;\\n  }\\n\\n  /**\\n   * @dev Mints part of the repaid interest to the reserve treasury as a function of the reserveFactor for the\\n   * specific asset.\\n   * @param reserve The reserve reserve to be updated\\n   * @param scaledVariableDebt The current scaled total variable debt\\n   * @param previousVariableBorrowIndex The variable borrow index before the last accumulation of the interest\\n   * @param newLiquidityIndices The new liquidity index\\n   * @param newVariableBorrowIndex The variable borrow index after the last accumulation of the interest\\n   * @param timestamp The timestamp of the action\\n   **/\\n  function _mintToTreasury(\\n    DataTypes.ReserveData storage reserve,\\n    uint256 scaledVariableDebt,\\n    uint256 previousVariableBorrowIndex,\\n    uint256[4] memory newLiquidityIndices,\\n    uint256 newVariableBorrowIndex,\\n    uint40 timestamp\\n  ) internal {\\n    timestamp;\\n    MintToTreasuryLocalVars memory vars;\\n\\n    vars.reserveFactor = reserve.configuration.getReserveFactor();\\n\\n    if (vars.reserveFactor == 0) {\\n      return;\\n    }\\n\\n    //calculate the last principal variable debt\\n    vars.previousVariableDebt = scaledVariableDebt.rayMul(previousVariableBorrowIndex);\\n\\n    //calculate the new total supply after accumulation of the index\\n    vars.currentVariableDebt = scaledVariableDebt.rayMul(newVariableBorrowIndex);\\n\\n    //debt accrued is the sum of the current debt minus the sum of the debt at the last update\\n    vars.totalDebtAccrued = vars.currentVariableDebt - (vars.previousVariableDebt);\\n\\n    vars.amountToMint = vars.totalDebtAccrued.percentMul(vars.reserveFactor);\\n\\n    if (vars.amountToMint != 0) {\\n      IMToken(reserve.mTokenAddresses[0]).mintToTreasury(vars.amountToMint, newLiquidityIndices[0]);\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates the reserve indexes and the timestamp of the update\\n   * @param reserve The reserve reserve to be updated\\n   * @param scaledVariableDebt The scaled variable debt\\n   * @param liquidityIndices The last stored liquidity index\\n   * @param variableBorrowIndex The last stored variable borrow index\\n   * @param timestamp The timestamp of the action\\n   **/\\n  function _updateIndexes(\\n    DataTypes.ReserveData storage reserve,\\n    uint256 scaledVariableDebt,\\n    uint128[4] memory liquidityIndices,\\n    uint256 variableBorrowIndex,\\n    uint40 timestamp\\n  ) internal returns (uint256[4] memory, uint256) {\\n    \\n    uint256 newVariableBorrowIndex = variableBorrowIndex;\\n\\n    uint256[4] memory newLiquidtyIndices;\\n\\n    for (uint8 i = 0; i < newLiquidtyIndices.length; i++) {\\n      newLiquidtyIndices[i] = liquidityIndices[i];\\n\\n      uint256 currentLiquidityRate = reserve.currentLiquidityRates[i];\\n      uint256 newLiquidityIndex = liquidityIndices[i];\\n      \\n      //only cumulating if there is any income being produced\\n      if (currentLiquidityRate > 0) {\\n        uint256 cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(currentLiquidityRate, timestamp);\\n        newLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndices[i]);\\n        require(newLiquidityIndex <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\\n\\n        reserve.liquidityIndices[i] = uint128(newLiquidityIndex);\\n        newLiquidtyIndices[i] = newLiquidityIndex;\\n      }\\n    }\\n\\n    //as the liquidity rate might come only from stable rate loans, we need to ensure\\n    //that there is actual variable debt before accumulating\\n    if (scaledVariableDebt != 0 &&  (reserve.currentLiquidityRates[0] > 0 || reserve.currentLiquidityRates[1] > 0 || reserve.currentLiquidityRates[2] > 0 || reserve.currentLiquidityRates[3] > 0)) {\\n      uint256 cumulatedVariableBorrowInterest = MathUtils.calculateCompoundedInterest(\\n        reserve.currentVariableBorrowRate,\\n        timestamp\\n      );\\n      newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex);\\n      require(newVariableBorrowIndex <= type(uint128).max, Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW);\\n      reserve.variableBorrowIndex = uint128(newVariableBorrowIndex);\\n    }\\n    \\n\\n    //solium-disable-next-line\\n    reserve.lastUpdateTimestamp = uint40(block.timestamp);\\n    return (newLiquidtyIndices, newVariableBorrowIndex);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/BorrowLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {IMToken} from \\\"../../interfaces/IMToken.sol\\\";\\nimport {IDebtToken} from \\\"../../interfaces/IDebtToken.sol\\\";\\nimport {IInterestRate} from \\\"../../interfaces/IInterestRate.sol\\\";\\nimport {ILendPoolAddressesProvider} from \\\"../../interfaces/ILendPoolAddressesProvider.sol\\\";\\nimport {IReserveOracleGetter} from \\\"../../interfaces/IReserveOracleGetter.sol\\\";\\nimport {INFTOracleGetter} from \\\"../../interfaces/INFTOracleGetter.sol\\\";\\nimport {ILendPoolLoan} from \\\"../../interfaces/ILendPoolLoan.sol\\\";\\n\\nimport {ReserveConfiguration} from \\\"../configuration/ReserveConfiguration.sol\\\";\\nimport {MathUtils} from \\\"../math/MathUtils.sol\\\";\\nimport {WadRayMath} from \\\"../math/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../math/PercentageMath.sol\\\";\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport {IERC721Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\\\";\\n\\nimport {ReserveLogic} from \\\"./ReserveLogic.sol\\\";\\nimport {GenericLogic} from \\\"./GenericLogic.sol\\\";\\nimport {ValidationLogic} from \\\"./ValidationLogic.sol\\\";\\n\\n/**\\n * @title BorrowLogic library\\n * @author MetaFire\\n * @notice Implements the logic to borrow feature\\n */\\nlibrary BorrowLogic {\\n  using WadRayMath for uint256;\\n  using PercentageMath for uint256;\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n  using ReserveLogic for DataTypes.ReserveData;\\n\\n  /**\\n   * @dev Emitted on borrow() when loan needs to be opened\\n   * @param user The address of the user initiating the borrow(), receiving the funds\\n   * @param reserve The address of the underlying asset being borrowed\\n   * @param amount The amount borrowed out\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token id of the underlying NFT used as collateral\\n   * @param onBehalfOf The address that will be getting the loan\\n   * @param referral The referral code used\\n   **/\\n  event Borrow(\\n    address user,\\n    address indexed reserve,\\n    uint256 amount,\\n    address nftAsset,\\n    uint256 nftTokenId,\\n    address indexed onBehalfOf,\\n    uint256 borrowRate,\\n    uint256 loanId,\\n    uint16 indexed referral\\n  );\\n\\n  /**\\n   * @dev Emitted on repay()\\n   * @param user The address of the user initiating the repay(), providing the funds\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param amount The amount repaid\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token id of the underlying NFT used as collateral\\n   * @param borrower The beneficiary of the repayment, getting his debt reduced\\n   * @param loanId The loan ID of the NFT loans\\n   **/\\n  event Repay(\\n    address user,\\n    address indexed reserve,\\n    uint256 amount,\\n    address indexed nftAsset,\\n    uint256 nftTokenId,\\n    address indexed borrower,\\n    uint256 loanId\\n  );\\n\\n  struct ExecuteBorrowLocalVars {\\n    address initiator;\\n    uint256 ltv;\\n    uint256 liquidationThreshold;\\n    uint256 liquidationBonus;\\n    uint256 loanId;\\n    address reserveOracle;\\n    address nftOracle;\\n    address loanAddress;\\n    uint256 totalSupply;\\n  }\\n\\n  /**\\n   * @notice Implements the borrow feature. Through `borrow()`, users borrow assets from the protocol.\\n   * @dev Emits the `Borrow()` event.\\n   * @param reservesData The state of all the reserves\\n   * @param nftsData The state of all the nfts\\n   * @param params The additional parameters needed to execute the borrow function\\n   */\\n  function executeBorrow(\\n    ILendPoolAddressesProvider addressesProvider,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    mapping(address => DataTypes.NftData) storage nftsData,\\n    DataTypes.ExecuteBorrowParams memory params\\n  ) external {\\n    _borrow(addressesProvider, reservesData, nftsData, params);\\n  }\\n\\n  /**\\n   * @notice Implements the batch borrow feature. Through `batchBorrow()`, users repay borrow to the protocol.\\n   * @dev Emits the `Borrow()` event.\\n   * @param reservesData The state of all the reserves\\n   * @param nftsData The state of all the nfts\\n   * @param params The additional parameters needed to execute the batchBorrow function\\n   */\\n  function executeBatchBorrow(\\n    ILendPoolAddressesProvider addressesProvider,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    mapping(address => DataTypes.NftData) storage nftsData,\\n    DataTypes.ExecuteBatchBorrowParams memory params\\n  ) external {\\n    require(params.nftAssets.length == params.assets.length, \\\"inconsistent assets length\\\");\\n    require(params.nftAssets.length == params.amounts.length, \\\"inconsistent amounts length\\\");\\n    require(params.nftAssets.length == params.nftTokenIds.length, \\\"inconsistent tokenIds length\\\");\\n\\n    for (uint256 i = 0; i < params.nftAssets.length; i++) {\\n      _borrow(\\n        addressesProvider,\\n        reservesData,\\n        nftsData,\\n        DataTypes.ExecuteBorrowParams({\\n          initiator: params.initiator,\\n          asset: params.assets[i],\\n          amount: params.amounts[i],\\n          nftAsset: params.nftAssets[i],\\n          nftTokenId: params.nftTokenIds[i],\\n          onBehalfOf: params.onBehalfOf,\\n          referralCode: params.referralCode\\n        })\\n      );\\n    }\\n  }\\n\\n  function _borrow(\\n    ILendPoolAddressesProvider addressesProvider,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    mapping(address => DataTypes.NftData) storage nftsData,\\n    DataTypes.ExecuteBorrowParams memory params\\n  ) internal {\\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\\n\\n    ExecuteBorrowLocalVars memory vars;\\n    vars.initiator = params.initiator;\\n\\n    DataTypes.ReserveData storage reserveData = reservesData[params.asset];\\n    DataTypes.NftData storage nftData = nftsData[params.nftAsset];\\n\\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\\n    reserveData.updateState();\\n\\n    // Convert asset amount to ETH\\n    vars.reserveOracle = addressesProvider.getReserveOracle();\\n    vars.nftOracle = addressesProvider.getNFTOracle();\\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\\n\\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\\n\\n    vars.totalSupply = IERC721EnumerableUpgradeable(params.nftAsset).totalSupply();\\n    require(vars.totalSupply <= nftData.maxSupply, Errors.LP_NFT_SUPPLY_NUM_EXCEED_MAX_LIMIT);\\n    require(params.nftTokenId <= nftData.maxTokenId, Errors.LP_NFT_TOKEN_ID_EXCEED_MAX_LIMIT);\\n\\n    ValidationLogic.validateBorrow(\\n      params.onBehalfOf,\\n      params.asset,\\n      params.amount,\\n      reserveData,\\n      params.nftAsset,\\n      nftData,\\n      vars.loanAddress,\\n      vars.loanId,\\n      vars.reserveOracle,\\n      vars.nftOracle\\n    );\\n\\n    if (vars.loanId == 0) {\\n      IERC721Upgradeable(params.nftAsset).safeTransferFrom(vars.initiator, address(this), params.nftTokenId);\\n\\n      vars.loanId = ILendPoolLoan(vars.loanAddress).createLoan(\\n        vars.initiator,\\n        params.onBehalfOf,\\n        params.nftAsset,\\n        params.nftTokenId,\\n        nftData.bNftAddress,\\n        params.asset,\\n        params.amount,\\n        reserveData.variableBorrowIndex\\n      );\\n    } else {\\n      ILendPoolLoan(vars.loanAddress).updateLoan(\\n        vars.initiator,\\n        vars.loanId,\\n        params.amount,\\n        0,\\n        reserveData.variableBorrowIndex\\n      );\\n    }\\n\\n    IDebtToken(reserveData.debtTokenAddress).mint(\\n      vars.initiator,\\n      params.onBehalfOf,\\n      params.amount,\\n      reserveData.variableBorrowIndex\\n    );\\n\\n    // update interest rate according latest borrow amount (utilizaton)\\n    reserveData.updateInterestRates(params.asset, address(0), 0, params.amount);\\n\\n    IERC20Upgradeable(params.asset).safeTransfer(vars.initiator, params.amount);\\n\\n    emit Borrow(\\n      vars.initiator,\\n      params.asset,\\n      params.amount,\\n      params.nftAsset,\\n      params.nftTokenId,\\n      params.onBehalfOf,\\n      reserveData.currentVariableBorrowRate,\\n      vars.loanId,\\n      params.referralCode\\n    );\\n  }\\n\\n  struct RepayLocalVars {\\n    address initiator;\\n    address poolLoan;\\n    address onBehalfOf;\\n    uint256 loanId;\\n    bool isUpdate;\\n    uint256 borrowAmount;\\n    uint256 repayAmount;\\n  }\\n\\n  /**\\n   * @notice Implements the borrow feature. Through `repay()`, users repay assets to the protocol.\\n   * @dev Emits the `Repay()` event.\\n   * @param reservesData The state of all the reserves\\n   * @param nftsData The state of all the nfts\\n   * @param params The additional parameters needed to execute the repay function\\n   */\\n  function executeRepay(\\n    ILendPoolAddressesProvider addressesProvider,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    mapping(address => DataTypes.NftData) storage nftsData,\\n    DataTypes.ExecuteRepayParams memory params\\n  ) external returns (uint256, bool) {\\n    return _repay(addressesProvider, reservesData, nftsData, params);\\n  }\\n\\n  /**\\n   * @notice Implements the batch repay feature. Through `batchRepay()`, users repay assets to the protocol.\\n   * @dev Emits the `repay()` event.\\n   * @param reservesData The state of all the reserves\\n   * @param nftsData The state of all the nfts\\n   * @param params The additional parameters needed to execute the batchRepay function\\n   */\\n  function executeBatchRepay(\\n    ILendPoolAddressesProvider addressesProvider,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    mapping(address => DataTypes.NftData) storage nftsData,\\n    DataTypes.ExecuteBatchRepayParams memory params\\n  ) external returns (uint256[] memory, bool[] memory) {\\n    require(params.nftAssets.length == params.amounts.length, \\\"inconsistent amounts length\\\");\\n    require(params.nftAssets.length == params.nftTokenIds.length, \\\"inconsistent tokenIds length\\\");\\n\\n    uint256[] memory repayAmounts = new uint256[](params.nftAssets.length);\\n    bool[] memory repayAlls = new bool[](params.nftAssets.length);\\n\\n    for (uint256 i = 0; i < params.nftAssets.length; i++) {\\n      (repayAmounts[i], repayAlls[i]) = _repay(\\n        addressesProvider,\\n        reservesData,\\n        nftsData,\\n        DataTypes.ExecuteRepayParams({\\n          initiator: params.initiator,\\n          nftAsset: params.nftAssets[i],\\n          nftTokenId: params.nftTokenIds[i],\\n          amount: params.amounts[i]\\n        })\\n      );\\n    }\\n\\n    return (repayAmounts, repayAlls);\\n  }\\n\\n  function _repay(\\n    ILendPoolAddressesProvider addressesProvider,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    mapping(address => DataTypes.NftData) storage nftsData,\\n    DataTypes.ExecuteRepayParams memory params\\n  ) internal returns (uint256, bool) {\\n    RepayLocalVars memory vars;\\n    vars.initiator = params.initiator;\\n\\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\\n\\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\\n\\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\\n\\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\\n\\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\\n    reserveData.updateState();\\n\\n    (, vars.borrowAmount) = ILendPoolLoan(vars.poolLoan).getLoanReserveBorrowAmount(vars.loanId);\\n\\n    ValidationLogic.validateRepay(reserveData, nftData, loanData, params.amount, vars.borrowAmount);\\n\\n    vars.repayAmount = vars.borrowAmount;\\n    vars.isUpdate = false;\\n    if (params.amount < vars.repayAmount) {\\n      vars.isUpdate = true;\\n      vars.repayAmount = params.amount;\\n    }\\n\\n    if (vars.isUpdate) {\\n      ILendPoolLoan(vars.poolLoan).updateLoan(\\n        vars.initiator,\\n        vars.loanId,\\n        0,\\n        vars.repayAmount,\\n        reserveData.variableBorrowIndex\\n      );\\n    } else {\\n      ILendPoolLoan(vars.poolLoan).repayLoan(\\n        vars.initiator,\\n        vars.loanId,\\n        nftData.bNftAddress,\\n        vars.repayAmount,\\n        reserveData.variableBorrowIndex\\n      );\\n    }\\n\\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\\n\\n    // update interest rate according latest borrow amount (utilizaton)\\n    reserveData.updateInterestRates(loanData.reserveAsset, address(0), vars.repayAmount, 0);\\n\\n    // transfer repay amount to lend pool\\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\\n      vars.initiator,\\n      address(this),\\n      vars.repayAmount\\n    );\\n\\n    // transfer erc721 to borrower\\n    if (!vars.isUpdate) {\\n      IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(address(this), loanData.borrower, params.nftTokenId);\\n    }\\n\\n    emit Repay(\\n      vars.initiator,\\n      loanData.reserveAsset,\\n      vars.repayAmount,\\n      loanData.nftAsset,\\n      loanData.nftTokenId,\\n      loanData.borrower,\\n      vars.loanId\\n    );\\n\\n    return (vars.repayAmount, !vars.isUpdate);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/SupplyLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {IBurnLockMToken} from \\\"../../interfaces/IBurnLockMToken.sol\\\";\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\n\\nimport {ReserveLogic} from \\\"./ReserveLogic.sol\\\";\\nimport {ValidationLogic} from \\\"./ValidationLogic.sol\\\";\\n\\n/**\\n * @title SupplyLogic library\\n * @author MetaFire\\n * @notice Implements the logic to supply feature\\n */\\nlibrary SupplyLogic {\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n  using ReserveLogic for DataTypes.ReserveData;\\n\\n  /**\\n   * @dev Emitted on deposit()\\n   * @param user The address initiating the deposit\\n   * @param amount The amount deposited\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param onBehalfOf The beneficiary of the deposit, receiving the mTokens\\n   * @param referral The referral code used\\n   **/\\n  event Deposit(\\n    address user,\\n    address indexed reserve,\\n    uint256 amount,\\n    address indexed onBehalfOf,\\n    uint8 period,\\n    uint16 indexed referral\\n  );\\n\\n  /**\\n   * @dev Emitted on withdraw()\\n   * @param user The address initiating the withdrawal, owner of mTokens\\n   * @param reserve The address of the underlyng asset being withdrawn\\n   * @param amount The amount to be withdrawn\\n   * @param to Address that will receive the underlying\\n   **/\\n  event Withdraw(address indexed user, address indexed reserve, uint256 amount, address indexed to, uint8 period);\\n\\n  /**\\n   * @notice Implements the supply feature. Through `deposit()`, users deposit assets to the protocol.\\n   * @dev Emits the `Deposit()` event.\\n   * @param reservesData The state of all the reserves\\n   * @param params The additional parameters needed to execute the deposit function\\n   */\\n  function executeDeposit(\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    DataTypes.ExecuteDepositParams memory params\\n  ) external {\\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\\n    uint8 period = uint8(params.period);\\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\\n    address mToken = reserve.mTokenAddresses[period];\\n    require(mToken != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n\\n    ValidationLogic.validateDeposit(reserve, params.amount);\\n\\n    reserve.updateState();\\n    reserve.updateInterestRates(params.asset, mToken, params.amount, 0);\\n\\n    IERC20Upgradeable(params.asset).safeTransferFrom(params.initiator, address(this), params.amount);\\n\\n    IBurnLockMToken(mToken).mint(params.onBehalfOf, params.amount, reserve.liquidityIndices[period]);\\n\\n    emit Deposit(params.initiator, params.asset, params.amount, params.onBehalfOf,uint8(params.period) ,params.referralCode);\\n  }\\n\\n  /**\\n   * @notice Implements the supply feature. Through `withdraw()`, users withdraw assets from the protocol.\\n   * @dev Emits the `Withdraw()` event.\\n   * @param reservesData The state of all the reserves\\n   * @param params The additional parameters needed to execute the withdraw function\\n   */\\n  function executeWithdraw(\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    DataTypes.ExecuteWithdrawParams memory params\\n  ) external returns (uint256) {\\n    require(params.to != address(0), Errors.VL_INVALID_TARGET_ADDRESS);\\n    uint8 period = uint8(params.period);\\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\\n    address mToken = reserve.mTokenAddresses[period];\\n    require(mToken != address(0), Errors.VL_INVALID_RESERVE_ADDRESS);\\n\\n    uint256 userBalance = IBurnLockMToken(mToken).balanceOf(params.initiator,params.period);\\n\\n    uint256 amountToWithdraw = params.amount;\\n\\n    if (params.amount == type(uint256).max) {\\n      amountToWithdraw = userBalance;\\n    }\\n\\n    ValidationLogic.validateWithdraw(reserve, amountToWithdraw, userBalance);\\n\\n    reserve.updateState();\\n\\n    reserve.updateInterestRates(params.asset, mToken, 0, amountToWithdraw);\\n\\n    IBurnLockMToken(mToken).burn(params.initiator, params.to, amountToWithdraw, reserve.liquidityIndices[period]);\\n\\n    IERC20Upgradeable(params.asset).safeTransfer(params.to, amountToWithdraw);\\n\\n    emit Withdraw(params.initiator, params.asset, amountToWithdraw, params.to, period);\\n\\n    return amountToWithdraw;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/LiquidateLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {IMToken} from \\\"../../interfaces/IMToken.sol\\\";\\nimport {IDebtToken} from \\\"../../interfaces/IDebtToken.sol\\\";\\nimport {IInterestRate} from \\\"../../interfaces/IInterestRate.sol\\\";\\nimport {ILendPoolAddressesProvider} from \\\"../../interfaces/ILendPoolAddressesProvider.sol\\\";\\nimport {IReserveOracleGetter} from \\\"../../interfaces/IReserveOracleGetter.sol\\\";\\nimport {INFTOracleGetter} from \\\"../../interfaces/INFTOracleGetter.sol\\\";\\nimport {ILendPoolLoan} from \\\"../../interfaces/ILendPoolLoan.sol\\\";\\n\\nimport {ReserveLogic} from \\\"./ReserveLogic.sol\\\";\\nimport {GenericLogic} from \\\"./GenericLogic.sol\\\";\\nimport {ValidationLogic} from \\\"./ValidationLogic.sol\\\";\\n\\nimport {ReserveConfiguration} from \\\"../configuration/ReserveConfiguration.sol\\\";\\nimport {NftConfiguration} from \\\"../configuration/NftConfiguration.sol\\\";\\nimport {MathUtils} from \\\"../math/MathUtils.sol\\\";\\nimport {WadRayMath} from \\\"../math/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../math/PercentageMath.sol\\\";\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport {IERC721Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title LiquidateLogic library\\n * @author MetaFire\\n * @notice Implements the logic to liquidate feature\\n */\\nlibrary LiquidateLogic {\\n  using WadRayMath for uint256;\\n  using PercentageMath for uint256;\\n  using SafeERC20Upgradeable for IERC20Upgradeable;\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n  using NftConfiguration for DataTypes.NftConfigurationMap;\\n\\n  /**\\n   * @dev Emitted when a borrower's loan is auctioned.\\n   * @param user The address of the user initiating the auction\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param bidPrice The price of the underlying reserve given by the bidder\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token id of the underlying NFT used as collateral\\n   * @param onBehalfOf The address that will be getting the NFT\\n   * @param loanId The loan ID of the NFT loans\\n   **/\\n  event Auction(\\n    address user,\\n    address indexed reserve,\\n    uint256 bidPrice,\\n    address indexed nftAsset,\\n    uint256 nftTokenId,\\n    address onBehalfOf,\\n    address indexed borrower,\\n    uint256 loanId\\n  );\\n\\n  /**\\n   * @dev Emitted on redeem()\\n   * @param user The address of the user initiating the redeem(), providing the funds\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param borrowAmount The borrow amount repaid\\n   * @param nftAsset The address of the underlying NFT used as collateral\\n   * @param nftTokenId The token id of the underlying NFT used as collateral\\n   * @param loanId The loan ID of the NFT loans\\n   **/\\n  event Redeem(\\n    address user,\\n    address indexed reserve,\\n    uint256 borrowAmount,\\n    uint256 fineAmount,\\n    address indexed nftAsset,\\n    uint256 nftTokenId,\\n    address indexed borrower,\\n    uint256 loanId\\n  );\\n\\n  /**\\n   * @dev Emitted when a borrower's loan is liquidated.\\n   * @param user The address of the user initiating the auction\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param repayAmount The amount of reserve repaid by the liquidator\\n   * @param remainAmount The amount of reserve received by the borrower\\n   * @param loanId The loan ID of the NFT loans\\n   **/\\n  event Liquidate(\\n    address user,\\n    address indexed reserve,\\n    uint256 repayAmount,\\n    uint256 remainAmount,\\n    address indexed nftAsset,\\n    uint256 nftTokenId,\\n    address indexed borrower,\\n    uint256 loanId\\n  );\\n\\n  event LiquidatingBuy(\\n    address user,\\n    address indexed reserve,\\n    uint256 liquidatingBuyPrice,\\n    uint256 remainAmount,\\n    address indexed nftAsset,\\n    uint256 nftTokenId,\\n    address onBehalfOf,\\n    address indexed borrower,\\n    uint256 loanId\\n  );\\n\\n  struct AuctionLocalVars {\\n    address loanAddress;\\n    address reserveOracle;\\n    address nftOracle;\\n    address initiator;\\n    uint256 loanId;\\n    uint256 thresholdPrice;\\n    uint256 liquidatePrice;\\n    uint256 borrowAmount;\\n    uint256 auctionEndTimestamp;\\n    uint256 minBidDelta;\\n    uint256 extraAuctionDuration;\\n  }\\n\\n\\n  /**\\n   * @notice Implements the auction feature. Through `auction()`, users auction assets in the protocol.\\n   * @dev Emits the `Auction()` event.\\n   * @param reservesData The state of all the reserves\\n   * @param nftsData The state of all the nfts\\n   * @param poolStates The state of the lend pool\\n   * @param params The additional parameters needed to execute the auction function\\n   */\\n  function executeAuction(\\n    ILendPoolAddressesProvider addressesProvider,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    mapping(address => DataTypes.NftData) storage nftsData,\\n    DataTypes.ExecuteLendPoolStates memory poolStates,\\n    DataTypes.ExecuteAuctionParams memory params\\n  ) external {\\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\\n\\n    AuctionLocalVars memory vars;\\n    vars.initiator = params.initiator;\\n\\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\\n    vars.reserveOracle = addressesProvider.getReserveOracle();\\n    vars.nftOracle = addressesProvider.getNFTOracle();\\n\\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\\n\\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\\n\\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\\n\\n    ValidationLogic.validateAuction(reserveData, nftData, loanData, params.bidPrice);\\n\\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\\n    reserveData.updateState();\\n\\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatePrice) = GenericLogic.calculateLoanLiquidatePrice(\\n      vars.loanId,\\n      loanData.reserveAsset,\\n      reserveData,\\n      loanData.nftAsset,\\n      nftData,\\n      vars.loanAddress,\\n      vars.reserveOracle,\\n      vars.nftOracle\\n    );\\n\\n    // first time bid need to burn debt tokens and transfer reserve to mTokens\\n    if (loanData.state == DataTypes.LoanState.Active) {\\n      // loan's accumulated debt must exceed threshold (heath factor below 1.0)\\n      require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\\n\\n      // bid price must greater than borrow debt\\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\\n\\n      // bid price must greater than liquidate price\\n      require(params.bidPrice >= vars.liquidatePrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\\n    } else {\\n      // bid price must greater than borrow debt\\n      require(params.bidPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\\n\\n      if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\\n        vars.extraAuctionDuration = poolStates.pauseDurationTime;\\n      }\\n      vars.auctionEndTimestamp =\\n        loanData.bidStartTimestamp +\\n        vars.extraAuctionDuration +\\n        (nftData.configuration.getAuctionDuration() * 1 hours);\\n      require(block.timestamp <= vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_HAS_END);\\n\\n      // bid price must greater than highest bid + delta\\n      vars.minBidDelta = vars.borrowAmount.percentMul(PercentageMath.ONE_PERCENT);\\n      require(params.bidPrice >= (loanData.bidPrice + vars.minBidDelta), Errors.LPL_BID_PRICE_LESS_THAN_HIGHEST_PRICE);\\n    }\\n\\n    ILendPoolLoan(vars.loanAddress).auctionLoan(\\n      vars.initiator,\\n      vars.loanId,\\n      params.onBehalfOf,\\n      params.bidPrice,\\n      vars.borrowAmount,\\n      reserveData.variableBorrowIndex\\n    );\\n\\n    // lock highest bidder bid price amount to lend pool\\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.bidPrice);\\n\\n    // transfer (return back) last bid price amount to previous bidder from lend pool\\n    if (loanData.bidderAddress != address(0)) {\\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\\n    }\\n\\n    // update interest rate according latest borrow amount (utilizaton)\\n    reserveData.updateInterestRates(loanData.reserveAsset, address(0), 0, 0);\\n\\n    emit Auction(\\n      vars.initiator,\\n      loanData.reserveAsset,\\n      params.bidPrice,\\n      params.nftAsset,\\n      params.nftTokenId,\\n      params.onBehalfOf,\\n      loanData.borrower,\\n      vars.loanId\\n    );\\n  }\\n\\n  struct LiquidatingBuyLocalVars {\\n    address loanAddress;\\n    address reserveOracle;\\n    address nftOracle;\\n    address initiator;\\n    uint256 loanId;\\n    uint256 thresholdPrice;\\n    uint256 liquidatingBuyPrice;\\n    uint256 borrowAmount;\\n    uint256 remainAmount;\\n  }\\n\\n  /**\\n   * @notice Implements the liquidating buy feature. Through `liquidatingBuy()`, users liquidate assets in the protocol.\\n   * @dev Emits the `LiquidatingBuy()` event.\\n   * @param reservesData The state of all the reserves\\n   * @param nftsData The state of all the nfts\\n   * @param poolStates The state of the lend pool\\n   * @param params The additional parameters needed to execute the auction function\\n   */\\n  function executeLiquidatingBuy(\\n    ILendPoolAddressesProvider addressesProvider,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    mapping(address => DataTypes.NftData) storage nftsData,\\n    DataTypes.ExecuteLendPoolStates memory poolStates,\\n    DataTypes.ExecuteLiquidatingBuyParams memory params\\n  ) external {\\n    require(params.onBehalfOf != address(0), Errors.VL_INVALID_ONBEHALFOF_ADDRESS);\\n\\n    LiquidatingBuyLocalVars memory vars;\\n    vars.initiator = params.initiator;\\n\\n    vars.loanAddress = addressesProvider.getLendPoolLoan();\\n    vars.reserveOracle = addressesProvider.getReserveOracle();\\n    vars.nftOracle = addressesProvider.getNFTOracle();\\n\\n    vars.loanId = ILendPoolLoan(vars.loanAddress).getCollateralLoanId(params.nftAsset, params.nftTokenId);\\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\\n\\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.loanAddress).getLoan(vars.loanId);\\n\\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\\n\\n    ValidationLogic.validateAuction(reserveData, nftData, loanData, params.liquidatingBuyPrice);\\n\\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\\n    reserveData.updateState();\\n\\n    //TODO: write a new liquidating buy price function\\n    (vars.borrowAmount, vars.thresholdPrice, vars.liquidatingBuyPrice) = GenericLogic.calculateLoanLiquidatingBuyPrice(\\n      vars.loanId,\\n      loanData.reserveAsset,\\n      reserveData,\\n      loanData.nftAsset,\\n      nftData,\\n      vars.loanAddress,\\n      vars.reserveOracle,\\n      vars.nftOracle\\n    );\\n\\n    // loan's accumulated debt must exceed threshold (heath factor below 1.0)\\n    require(vars.borrowAmount > vars.thresholdPrice, Errors.LP_BORROW_NOT_EXCEED_LIQUIDATION_THRESHOLD);\\n\\n    // liquidatingBuyPrice price must greater than borrow debt\\n    require(params.liquidatingBuyPrice >= vars.borrowAmount, Errors.LPL_BID_PRICE_LESS_THAN_BORROW);\\n\\n    // bid price must greater than liquidate price\\n    require(params.liquidatingBuyPrice >= vars.liquidatingBuyPrice, Errors.LPL_BID_PRICE_LESS_THAN_LIQUIDATION_PRICE);\\n\\n    if (params.liquidatingBuyPrice > vars.borrowAmount) {\\n      vars.remainAmount = params.liquidatingBuyPrice - vars.borrowAmount;\\n    }\\n\\n    ILendPoolLoan(vars.loanAddress).liquidatingBuyLoan(\\n      vars.initiator,\\n      vars.loanId,\\n      nftData.bNftAddress,\\n      params.onBehalfOf,\\n      params.liquidatingBuyPrice,\\n      vars.borrowAmount,\\n      reserveData.variableBorrowIndex\\n    );\\n\\n    // lock highest bidder bid price amount to lend pool\\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), params.liquidatingBuyPrice);\\n\\n    IDebtToken(reserveData.debtTokenAddress).burn(\\n      loanData.borrower,\\n      vars.borrowAmount,\\n      reserveData.variableBorrowIndex\\n    );\\n\\n    // transfer remain amount to borrower\\n    if (vars.remainAmount > 0) {\\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\\n    }\\n\\n    // transfer erc721 to bidder\\n    IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(address(this), params.onBehalfOf, params.nftTokenId);\\n\\n    // update interest rate according latest borrow amount (utilizaton)\\n    reserveData.updateInterestRates(loanData.reserveAsset, address(0), 0, 0);\\n\\n    emit LiquidatingBuy(\\n      vars.initiator,\\n      loanData.reserveAsset,\\n      params.liquidatingBuyPrice,\\n      vars.remainAmount,\\n      params.nftAsset,\\n      params.nftTokenId,\\n      params.onBehalfOf,\\n      loanData.borrower,\\n      vars.loanId\\n    );\\n  }\\n\\n  struct RedeemLocalVars {\\n    address initiator;\\n    address poolLoan;\\n    address reserveOracle;\\n    address nftOracle;\\n    uint256 loanId;\\n    uint256 borrowAmount;\\n    uint256 repayAmount;\\n    uint256 minRepayAmount;\\n    uint256 maxRepayAmount;\\n    uint256 bidFine;\\n    uint256 redeemEndTimestamp;\\n    uint256 minBidFinePct;\\n    uint256 minBidFine;\\n    uint256 extraRedeemDuration;\\n  }\\n\\n  /**\\n   * @notice Implements the redeem feature. Through `redeem()`, users redeem assets in the protocol.\\n   * @dev Emits the `Redeem()` event.\\n   * @param reservesData The state of all the reserves\\n   * @param nftsData The state of all the nfts\\n   * @param poolStates The state of the lend pool\\n   * @param params The additional parameters needed to execute the redeem function\\n   */\\n  function executeRedeem(\\n    ILendPoolAddressesProvider addressesProvider,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    mapping(address => DataTypes.NftData) storage nftsData,\\n    DataTypes.ExecuteLendPoolStates memory poolStates,\\n    DataTypes.ExecuteRedeemParams memory params\\n  ) external returns (uint256) {\\n    RedeemLocalVars memory vars;\\n    vars.initiator = params.initiator;\\n\\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\\n    vars.reserveOracle = addressesProvider.getReserveOracle();\\n    vars.nftOracle = addressesProvider.getNFTOracle();\\n\\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\\n\\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\\n\\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\\n\\n    ValidationLogic.validateRedeem(reserveData, nftData, loanData, params.amount);\\n\\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\\n      vars.extraRedeemDuration = poolStates.pauseDurationTime;\\n    }\\n    vars.redeemEndTimestamp = (loanData.bidStartTimestamp +\\n      vars.extraRedeemDuration +\\n      nftData.configuration.getRedeemDuration() *\\n      1 hours);\\n    require(block.timestamp <= vars.redeemEndTimestamp, Errors.LPL_BID_REDEEM_DURATION_HAS_END);\\n\\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\\n    reserveData.updateState();\\n\\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\\n      vars.loanId,\\n      loanData.reserveAsset,\\n      reserveData,\\n      loanData.nftAsset,\\n      nftData,\\n      vars.poolLoan,\\n      vars.reserveOracle,\\n      vars.nftOracle\\n    );\\n\\n    // check bid fine in min & max range\\n    (, vars.bidFine) = GenericLogic.calculateLoanBidFine(\\n      loanData.reserveAsset,\\n      reserveData,\\n      loanData.nftAsset,\\n      nftData,\\n      loanData,\\n      vars.poolLoan,\\n      vars.reserveOracle\\n    );\\n\\n    // check bid fine is enough\\n    require(vars.bidFine <= params.bidFine, Errors.LPL_INVALID_BID_FINE);\\n\\n    // check the minimum debt repay amount, use redeem threshold in config\\n    vars.repayAmount = params.amount;\\n    vars.minRepayAmount = vars.borrowAmount.percentMul(nftData.configuration.getRedeemThreshold());\\n    require(vars.repayAmount >= vars.minRepayAmount, Errors.LP_AMOUNT_LESS_THAN_REDEEM_THRESHOLD);\\n\\n    // check the maxinmum debt repay amount, 90%?\\n    vars.maxRepayAmount = vars.borrowAmount.percentMul(PercentageMath.PERCENTAGE_FACTOR - PercentageMath.TEN_PERCENT);\\n    require(vars.repayAmount <= vars.maxRepayAmount, Errors.LP_AMOUNT_GREATER_THAN_MAX_REPAY);\\n\\n    ILendPoolLoan(vars.poolLoan).redeemLoan(\\n      vars.initiator,\\n      vars.loanId,\\n      vars.repayAmount,\\n      reserveData.variableBorrowIndex\\n    );\\n\\n    IDebtToken(reserveData.debtTokenAddress).burn(loanData.borrower, vars.repayAmount, reserveData.variableBorrowIndex);\\n\\n    // update interest rate according latest borrow amount (utilizaton)\\n    reserveData.updateInterestRates(loanData.reserveAsset, address(0), vars.repayAmount, 0);\\n\\n    // transfer repay amount from borrower to the pool\\n    IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\\n      vars.initiator,\\n      address(this),\\n      vars.repayAmount\\n    );\\n\\n    if (loanData.bidderAddress != address(0)) {\\n      // transfer (return back) last bid price amount from lend pool to bidder\\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.bidderAddress, loanData.bidPrice);\\n\\n      // transfer bid penalty fine amount from borrower to the first bidder\\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(\\n        vars.initiator,\\n        loanData.firstBidderAddress,\\n        vars.bidFine\\n      );\\n    }\\n\\n    emit Redeem(\\n      vars.initiator,\\n      loanData.reserveAsset,\\n      vars.repayAmount,\\n      vars.bidFine,\\n      loanData.nftAsset,\\n      loanData.nftTokenId,\\n      loanData.borrower,\\n      vars.loanId\\n    );\\n\\n    return (vars.repayAmount + vars.bidFine);\\n  }\\n\\n  struct LiquidateLocalVars {\\n    address initiator;\\n    address poolLoan;\\n    address reserveOracle;\\n    address nftOracle;\\n    uint256 loanId;\\n    uint256 borrowAmount;\\n    uint256 extraDebtAmount;\\n    uint256 remainAmount;\\n    uint256 auctionEndTimestamp;\\n    uint256 extraAuctionDuration;\\n  }\\n\\n  /**\\n   * @notice Implements the liquidate feature. Through `liquidate()`, users liquidate assets in the protocol.\\n   * @dev Emits the `Liquidate()` event.\\n   * @param reservesData The state of all the reserves\\n   * @param nftsData The state of all the nfts\\n   * @param poolStates The state of the lend pool\\n   * @param params The additional parameters needed to execute the liquidate function\\n   */\\n  function executeLiquidate(\\n    ILendPoolAddressesProvider addressesProvider,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    mapping(address => DataTypes.NftData) storage nftsData,\\n    DataTypes.ExecuteLendPoolStates memory poolStates,\\n    DataTypes.ExecuteLiquidateParams memory params\\n  ) external returns (uint256) {\\n    LiquidateLocalVars memory vars;\\n    vars.initiator = params.initiator;\\n\\n    vars.poolLoan = addressesProvider.getLendPoolLoan();\\n    vars.reserveOracle = addressesProvider.getReserveOracle();\\n    vars.nftOracle = addressesProvider.getNFTOracle();\\n\\n    vars.loanId = ILendPoolLoan(vars.poolLoan).getCollateralLoanId(params.nftAsset, params.nftTokenId);\\n    require(vars.loanId != 0, Errors.LP_NFT_IS_NOT_USED_AS_COLLATERAL);\\n\\n    DataTypes.LoanData memory loanData = ILendPoolLoan(vars.poolLoan).getLoan(vars.loanId);\\n\\n    DataTypes.ReserveData storage reserveData = reservesData[loanData.reserveAsset];\\n    DataTypes.NftData storage nftData = nftsData[loanData.nftAsset];\\n\\n    ValidationLogic.validateLiquidate(reserveData, nftData, loanData);\\n\\n    if ((poolStates.pauseDurationTime > 0) && (loanData.bidStartTimestamp <= poolStates.pauseStartTime)) {\\n      vars.extraAuctionDuration = poolStates.pauseDurationTime;\\n    }\\n    vars.auctionEndTimestamp =\\n      loanData.bidStartTimestamp +\\n      vars.extraAuctionDuration +\\n      (nftData.configuration.getAuctionDuration() * 1 hours);\\n    require(block.timestamp > vars.auctionEndTimestamp, Errors.LPL_BID_AUCTION_DURATION_NOT_END);\\n\\n    // update state MUST BEFORE get borrow amount which is depent on latest borrow index\\n    reserveData.updateState();\\n\\n    (vars.borrowAmount, , ) = GenericLogic.calculateLoanLiquidatePrice(\\n      vars.loanId,\\n      loanData.reserveAsset,\\n      reserveData,\\n      loanData.nftAsset,\\n      nftData,\\n      vars.poolLoan,\\n      vars.reserveOracle,\\n      vars.nftOracle\\n    );\\n\\n    // Last bid price can not cover borrow amount\\n    if (loanData.bidPrice < vars.borrowAmount) {\\n      vars.extraDebtAmount = vars.borrowAmount - loanData.bidPrice;\\n      require(params.amount >= vars.extraDebtAmount, Errors.LP_AMOUNT_LESS_THAN_EXTRA_DEBT);\\n    }\\n\\n    if (loanData.bidPrice > vars.borrowAmount) {\\n      vars.remainAmount = loanData.bidPrice - vars.borrowAmount;\\n    }\\n\\n    ILendPoolLoan(vars.poolLoan).liquidateLoan(\\n      loanData.bidderAddress,\\n      vars.loanId,\\n      nftData.bNftAddress,\\n      vars.borrowAmount,\\n      reserveData.variableBorrowIndex\\n    );\\n\\n    IDebtToken(reserveData.debtTokenAddress).burn(\\n      loanData.borrower,\\n      vars.borrowAmount,\\n      reserveData.variableBorrowIndex\\n    );\\n\\n    // update interest rate according latest borrow amount (utilizaton)\\n    reserveData.updateInterestRates(loanData.reserveAsset, address(0), vars.borrowAmount, 0);\\n\\n    // transfer extra borrow amount from liquidator to lend pool\\n    if (vars.extraDebtAmount > 0) {\\n      IERC20Upgradeable(loanData.reserveAsset).safeTransferFrom(vars.initiator, address(this), vars.extraDebtAmount);\\n    }\\n\\n    // transfer borrow amount from lend pool to mToken, repay debt\\n    // IERC20Upgradeable(loanData.reserveAsset).safeTransfer(reserveData.mTokenAddress, vars.borrowAmount);\\n\\n    // transfer remain amount to borrower\\n    if (vars.remainAmount > 0) {\\n      IERC20Upgradeable(loanData.reserveAsset).safeTransfer(loanData.borrower, vars.remainAmount);\\n    }\\n\\n    // transfer erc721 to bidder\\n    IERC721Upgradeable(loanData.nftAsset).safeTransferFrom(address(this), loanData.bidderAddress, params.nftTokenId);\\n\\n    emit Liquidate(\\n      vars.initiator,\\n      loanData.reserveAsset,\\n      vars.borrowAmount,\\n      vars.remainAmount,\\n      loanData.nftAsset,\\n      loanData.nftTokenId,\\n      loanData.borrower,\\n      vars.loanId\\n    );\\n\\n    return (vars.extraDebtAmount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/configuration/ReserveConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\n\\n/**\\n * @title ReserveConfiguration library\\n * @author MetaFire\\n * @notice Implements the bitmap logic to handle the reserve configuration\\n */\\nlibrary ReserveConfiguration {\\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\\n\\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\\n  uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\\n  uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\\n  uint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\\n  uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\\n  uint256 constant IS_FROZEN_START_BIT_POSITION = 57;\\n  uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;\\n  uint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\\n  uint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;\\n\\n  uint256 constant MAX_VALID_LTV = 65535;\\n  uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\\n  uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\\n  uint256 constant MAX_VALID_DECIMALS = 255;\\n  uint256 constant MAX_VALID_RESERVE_FACTOR = 65535;\\n\\n  /**\\n   * @dev Sets the Loan to Value of the reserve\\n   * @param self The reserve configuration\\n   * @param ltv the new ltv\\n   **/\\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\\n    require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\\n\\n    self.data = (self.data & LTV_MASK) | ltv;\\n  }\\n\\n  /**\\n   * @dev Gets the Loan to Value of the reserve\\n   * @param self The reserve configuration\\n   * @return The loan to value\\n   **/\\n  function getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return self.data & ~LTV_MASK;\\n  }\\n\\n  /**\\n   * @dev Sets the liquidation threshold of the reserve\\n   * @param self The reserve configuration\\n   * @param threshold The new liquidation threshold\\n   **/\\n  function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold) internal pure {\\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\\n\\n    self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the liquidation threshold of the reserve\\n   * @param self The reserve configuration\\n   * @return The liquidation threshold\\n   **/\\n  function getLiquidationThreshold(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the liquidation bonus of the reserve\\n   * @param self The reserve configuration\\n   * @param bonus The new liquidation bonus\\n   **/\\n  function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus) internal pure {\\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\\n\\n    self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the liquidation bonus of the reserve\\n   * @param self The reserve configuration\\n   * @return The liquidation bonus\\n   **/\\n  function getLiquidationBonus(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the decimals of the underlying asset of the reserve\\n   * @param self The reserve configuration\\n   * @param decimals The decimals\\n   **/\\n  function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals) internal pure {\\n    require(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);\\n\\n    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the decimals of the underlying asset of the reserve\\n   * @param self The reserve configuration\\n   * @return The decimals of the asset\\n   **/\\n  function getDecimals(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the active state of the reserve\\n   * @param self The reserve configuration\\n   * @param active The active state\\n   **/\\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\\n    self.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the active state of the reserve\\n   * @param self The reserve configuration\\n   * @return The active state\\n   **/\\n  function getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~ACTIVE_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Sets the frozen state of the reserve\\n   * @param self The reserve configuration\\n   * @param frozen The frozen state\\n   **/\\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\\n    self.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the frozen state of the reserve\\n   * @param self The reserve configuration\\n   * @return The frozen state\\n   **/\\n  function getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~FROZEN_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Enables or disables borrowing on the reserve\\n   * @param self The reserve configuration\\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\\n   **/\\n  function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\\n    self.data = (self.data & BORROWING_MASK) | (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the borrowing state of the reserve\\n   * @param self The reserve configuration\\n   * @return The borrowing state\\n   **/\\n  function getBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~BORROWING_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Enables or disables stable rate borrowing on the reserve\\n   * @param self The reserve configuration\\n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\\n   **/\\n  function setStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\\n    self.data =\\n      (self.data & STABLE_BORROWING_MASK) |\\n      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the stable rate borrowing state of the reserve\\n   * @param self The reserve configuration\\n   * @return The stable rate borrowing state\\n   **/\\n  function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Sets the reserve factor of the reserve\\n   * @param self The reserve configuration\\n   * @param reserveFactor The reserve factor\\n   **/\\n  function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor) internal pure {\\n    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR);\\n\\n    self.data = (self.data & RESERVE_FACTOR_MASK) | (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the reserve factor of the reserve\\n   * @param self The reserve configuration\\n   * @return The reserve factor\\n   **/\\n  function getReserveFactor(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Gets the configuration flags of the reserve\\n   * @param self The reserve configuration\\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\\n   **/\\n  function getFlags(DataTypes.ReserveConfigurationMap storage self)\\n    internal\\n    view\\n    returns (\\n      bool,\\n      bool,\\n      bool,\\n      bool\\n    )\\n  {\\n    uint256 dataLocal = self.data;\\n\\n    return (\\n      (dataLocal & ~ACTIVE_MASK) != 0,\\n      (dataLocal & ~FROZEN_MASK) != 0,\\n      (dataLocal & ~BORROWING_MASK) != 0,\\n      (dataLocal & ~STABLE_BORROWING_MASK) != 0\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the configuration paramters of the reserve\\n   * @param self The reserve configuration\\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\\n   **/\\n  function getParams(DataTypes.ReserveConfigurationMap storage self)\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    uint256 dataLocal = self.data;\\n\\n    return (\\n      dataLocal & ~LTV_MASK,\\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the configuration paramters of the reserve from a memory object\\n   * @param self The reserve configuration\\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\\n   **/\\n  function getParamsMemory(DataTypes.ReserveConfigurationMap memory self)\\n    internal\\n    pure\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return (\\n      self.data & ~LTV_MASK,\\n      (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n      (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\\n      (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\\n      (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the configuration flags of the reserve from a memory object\\n   * @param self The reserve configuration\\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\\n   **/\\n  function getFlagsMemory(DataTypes.ReserveConfigurationMap memory self)\\n    internal\\n    pure\\n    returns (\\n      bool,\\n      bool,\\n      bool,\\n      bool\\n    )\\n  {\\n    return (\\n      (self.data & ~ACTIVE_MASK) != 0,\\n      (self.data & ~FROZEN_MASK) != 0,\\n      (self.data & ~BORROWING_MASK) != 0,\\n      (self.data & ~STABLE_BORROWING_MASK) != 0\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/configuration/NftConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\n\\n/**\\n * @title NftConfiguration library\\n * @author MetaFire\\n * @notice Implements the bitmap logic to handle the NFT configuration\\n */\\nlibrary NftConfiguration {\\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant REDEEM_DURATION_MASK =       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant AUCTION_DURATION_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant REDEEM_FINE_MASK =           0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant REDEEM_THRESHOLD_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant MIN_BIDFINE_MASK      =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant LIQUIDATING_BUY_BONUS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFffffFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n \\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\\n  uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\\n  uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\\n  uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\\n  uint256 constant IS_FROZEN_START_BIT_POSITION = 57;\\n  uint256 constant REDEEM_DURATION_START_BIT_POSITION = 64;\\n  uint256 constant AUCTION_DURATION_START_BIT_POSITION = 72;\\n  uint256 constant REDEEM_FINE_START_BIT_POSITION = 80;\\n  uint256 constant REDEEM_THRESHOLD_START_BIT_POSITION = 96;\\n  uint256 constant MIN_BIDFINE_START_BIT_POSITION = 112;\\n  uint256 constant LIQUIDATING_BUY_BONUS_START_BIT_POSITION = 128;\\n\\n  uint256 constant MAX_VALID_LTV = 65535;\\n  uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\\n  uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\\n  uint256 constant MAX_VALID_REDEEM_DURATION = 255;\\n  uint256 constant MAX_VALID_AUCTION_DURATION = 255;\\n  uint256 constant MAX_VALID_REDEEM_FINE = 65535;\\n  uint256 constant MAX_VALID_REDEEM_THRESHOLD = 65535;\\n  uint256 constant MAX_VALID_MIN_BIDFINE = 65535;\\n  uint256 constant MAX_VALID_LIQUIDATING_BUY_BONUS = 65535;\\n\\n  /**\\n   * @dev Sets the Loan to Value of the NFT\\n   * @param self The NFT configuration\\n   * @param ltv the new ltv\\n   **/\\n  function setLtv(DataTypes.NftConfigurationMap memory self, uint256 ltv) internal pure {\\n    require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\\n\\n    self.data = (self.data & LTV_MASK) | ltv;\\n  }\\n\\n  /**\\n   * @dev Gets the Loan to Value of the NFT\\n   * @param self The NFT configuration\\n   * @return The loan to value\\n   **/\\n  function getLtv(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return self.data & ~LTV_MASK;\\n  }\\n\\n  /**\\n   * @dev Sets the liquidation threshold of the NFT\\n   * @param self The NFT configuration\\n   * @param threshold The new liquidation threshold\\n   **/\\n  function setLiquidationThreshold(DataTypes.NftConfigurationMap memory self, uint256 threshold) internal pure {\\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\\n\\n    self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the liquidation threshold of the NFT\\n   * @param self The NFT configuration\\n   * @return The liquidation threshold\\n   **/\\n  function getLiquidationThreshold(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the liquidation bonus of the NFT\\n   * @param self The NFT configuration\\n   * @param bonus The new liquidation bonus\\n   **/\\n  function setLiquidationBonus(DataTypes.NftConfigurationMap memory self, uint256 bonus) internal pure {\\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\\n\\n    self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the liquidation bonus of the NFT\\n   * @param self The NFT configuration\\n   * @return The liquidation bonus\\n   **/\\n  function getLiquidationBonus(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\\n  }\\n\\n    /**\\n   * @dev Sets the liquidating buy bonus of the NFT\\n   * @param self The NFT configuration\\n   * @param bonus The new liquidating buy bonus\\n   **/\\n  function setLiquidatingBuyBonus(DataTypes.NftConfigurationMap memory self, uint256 bonus) internal pure {\\n    require(bonus <= MAX_VALID_LIQUIDATING_BUY_BONUS, Errors.RC_INVALID_LIQ_BONUS);\\n\\n    self.data = (self.data & LIQUIDATING_BUY_BONUS_MASK) | (bonus << LIQUIDATING_BUY_BONUS_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the liquidating buy bonus of the NFT\\n   * @param self The NFT configuration\\n   * @return The liquidating buy bonus\\n   **/\\n  function getLiquidatingBuyBonus(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATING_BUY_BONUS_MASK) >> LIQUIDATING_BUY_BONUS_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the active state of the NFT\\n   * @param self The NFT configuration\\n   * @param active The active state\\n   **/\\n  function setActive(DataTypes.NftConfigurationMap memory self, bool active) internal pure {\\n    self.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the active state of the NFT\\n   * @param self The NFT configuration\\n   * @return The active state\\n   **/\\n  function getActive(DataTypes.NftConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~ACTIVE_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Sets the frozen state of the NFT\\n   * @param self The NFT configuration\\n   * @param frozen The frozen state\\n   **/\\n  function setFrozen(DataTypes.NftConfigurationMap memory self, bool frozen) internal pure {\\n    self.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the frozen state of the NFT\\n   * @param self The NFT configuration\\n   * @return The frozen state\\n   **/\\n  function getFrozen(DataTypes.NftConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~FROZEN_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Sets the redeem duration of the NFT\\n   * @param self The NFT configuration\\n   * @param redeemDuration The redeem duration\\n   **/\\n  function setRedeemDuration(DataTypes.NftConfigurationMap memory self, uint256 redeemDuration) internal pure {\\n    require(redeemDuration <= MAX_VALID_REDEEM_DURATION, Errors.RC_INVALID_REDEEM_DURATION);\\n\\n    self.data = (self.data & REDEEM_DURATION_MASK) | (redeemDuration << REDEEM_DURATION_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the redeem duration of the NFT\\n   * @param self The NFT configuration\\n   * @return The redeem duration\\n   **/\\n  function getRedeemDuration(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~REDEEM_DURATION_MASK) >> REDEEM_DURATION_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the auction duration of the NFT\\n   * @param self The NFT configuration\\n   * @param auctionDuration The auction duration\\n   **/\\n  function setAuctionDuration(DataTypes.NftConfigurationMap memory self, uint256 auctionDuration) internal pure {\\n    require(auctionDuration <= MAX_VALID_AUCTION_DURATION, Errors.RC_INVALID_AUCTION_DURATION);\\n\\n    self.data = (self.data & AUCTION_DURATION_MASK) | (auctionDuration << AUCTION_DURATION_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the auction duration of the NFT\\n   * @param self The NFT configuration\\n   * @return The auction duration\\n   **/\\n  function getAuctionDuration(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~AUCTION_DURATION_MASK) >> AUCTION_DURATION_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the redeem fine of the NFT\\n   * @param self The NFT configuration\\n   * @param redeemFine The redeem duration\\n   **/\\n  function setRedeemFine(DataTypes.NftConfigurationMap memory self, uint256 redeemFine) internal pure {\\n    require(redeemFine <= MAX_VALID_REDEEM_FINE, Errors.RC_INVALID_REDEEM_FINE);\\n\\n    self.data = (self.data & REDEEM_FINE_MASK) | (redeemFine << REDEEM_FINE_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the redeem fine of the NFT\\n   * @param self The NFT configuration\\n   * @return The redeem fine\\n   **/\\n  function getRedeemFine(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~REDEEM_FINE_MASK) >> REDEEM_FINE_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the redeem threshold of the NFT\\n   * @param self The NFT configuration\\n   * @param redeemThreshold The redeem duration\\n   **/\\n  function setRedeemThreshold(DataTypes.NftConfigurationMap memory self, uint256 redeemThreshold) internal pure {\\n    require(redeemThreshold <= MAX_VALID_REDEEM_THRESHOLD, Errors.RC_INVALID_REDEEM_THRESHOLD);\\n\\n    self.data = (self.data & REDEEM_THRESHOLD_MASK) | (redeemThreshold << REDEEM_THRESHOLD_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the redeem threshold of the NFT\\n   * @param self The NFT configuration\\n   * @return The redeem threshold\\n   **/\\n  function getRedeemThreshold(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~REDEEM_THRESHOLD_MASK) >> REDEEM_THRESHOLD_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the min & max threshold of the NFT\\n   * @param self The NFT configuration\\n   * @param minBidFine The min bid fine\\n   **/\\n  function setMinBidFine(DataTypes.NftConfigurationMap memory self, uint256 minBidFine) internal pure {\\n    require(minBidFine <= MAX_VALID_MIN_BIDFINE, Errors.RC_INVALID_MIN_BID_FINE);\\n\\n    self.data = (self.data & MIN_BIDFINE_MASK) | (minBidFine << MIN_BIDFINE_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the min bid fine of the NFT\\n   * @param self The NFT configuration\\n   * @return The min bid fine\\n   **/\\n  function getMinBidFine(DataTypes.NftConfigurationMap storage self) internal view returns (uint256) {\\n    return ((self.data & ~MIN_BIDFINE_MASK) >> MIN_BIDFINE_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the configuration flags of the NFT\\n   * @param self The NFT configuration\\n   * @return The state flags representing active, frozen\\n   **/\\n  function getFlags(DataTypes.NftConfigurationMap storage self) internal view returns (bool, bool) {\\n    uint256 dataLocal = self.data;\\n\\n    return ((dataLocal & ~ACTIVE_MASK) != 0, (dataLocal & ~FROZEN_MASK) != 0);\\n  }\\n\\n  /**\\n   * @dev Gets the configuration flags of the NFT from a memory object\\n   * @param self The NFT configuration\\n   * @return The state flags representing active, frozen\\n   **/\\n  function getFlagsMemory(DataTypes.NftConfigurationMap memory self) internal pure returns (bool, bool) {\\n    return ((self.data & ~ACTIVE_MASK) != 0, (self.data & ~FROZEN_MASK) != 0);\\n  }\\n\\n  /**\\n   * @dev Gets the collateral configuration paramters of the NFT\\n   * @param self The NFT configuration\\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus\\n   **/\\n  function getCollateralParams(DataTypes.NftConfigurationMap storage self)\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    uint256 dataLocal = self.data;\\n\\n    return (\\n      dataLocal & ~LTV_MASK,\\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the auction configuration paramters of the NFT\\n   * @param self The NFT configuration\\n   * @return The state params representing redeem duration, auction duration, redeem fine\\n   **/\\n  function getAuctionParams(DataTypes.NftConfigurationMap storage self)\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    uint256 dataLocal = self.data;\\n\\n    return (\\n      (dataLocal & ~REDEEM_DURATION_MASK) >> REDEEM_DURATION_START_BIT_POSITION,\\n      (dataLocal & ~AUCTION_DURATION_MASK) >> AUCTION_DURATION_START_BIT_POSITION,\\n      (dataLocal & ~REDEEM_FINE_MASK) >> REDEEM_FINE_START_BIT_POSITION,\\n      (dataLocal & ~REDEEM_THRESHOLD_MASK) >> REDEEM_THRESHOLD_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the collateral configuration paramters of the NFT from a memory object\\n   * @param self The NFT configuration\\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus\\n   **/\\n  function getCollateralParamsMemory(DataTypes.NftConfigurationMap memory self)\\n    internal\\n    pure\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return (\\n      self.data & ~LTV_MASK,\\n      (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n      (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the auction configuration paramters of the NFT from a memory object\\n   * @param self The NFT configuration\\n   * @return The state params representing redeem duration, auction duration, redeem fine\\n   **/\\n  function getAuctionParamsMemory(DataTypes.NftConfigurationMap memory self)\\n    internal\\n    pure\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return (\\n      (self.data & ~REDEEM_DURATION_MASK) >> REDEEM_DURATION_START_BIT_POSITION,\\n      (self.data & ~AUCTION_DURATION_MASK) >> AUCTION_DURATION_START_BIT_POSITION,\\n      (self.data & ~REDEEM_FINE_MASK) >> REDEEM_FINE_START_BIT_POSITION,\\n      (self.data & ~REDEEM_THRESHOLD_MASK) >> REDEEM_THRESHOLD_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the min & max bid fine of the NFT\\n   * @param self The NFT configuration\\n   * @return The min & max bid fine\\n   **/\\n  function getMinBidFineMemory(DataTypes.NftConfigurationMap memory self) internal pure returns (uint256) {\\n    return ((self.data & ~MIN_BIDFINE_MASK) >> MIN_BIDFINE_START_BIT_POSITION);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/types/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nlibrary DataTypes {\\n  \\n  enum Period {\\n    FourMonth,\\n    SevenMonth,\\n    ElevenMonth,\\n    ThirteenMonth\\n  }\\n\\n  // [0] - 4 month\\n  // [1] - 7 month\\n  // [2] - 11 month\\n  // [3] - 13 month\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128[4] liquidityIndices;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128[4] currentLiquidityRates;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    //tokens addresses\\n    address[4] mTokenAddresses;\\n    address debtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateAddress;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint8 id;\\n  }\\n\\n  struct NftData {\\n    //stores the nft configuration\\n    NftConfigurationMap configuration;\\n    //address of the bNFT contract\\n    address bNftAddress;\\n    //the id of the nft. Represents the position in the list of the active nfts\\n    uint8 id;\\n    uint256 maxSupply;\\n    uint256 maxTokenId;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: Reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60-63: reserved\\n    //bit 64-79: reserve factor\\n    uint256 data;\\n  }\\n\\n  struct NftConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 56: NFT is active\\n    //bit 57: NFT is frozen\\n    uint256 data;\\n  }\\n\\n  /**\\n   * @dev Enum describing the current state of a loan\\n   * State change flow:\\n   *  Created -> Active -> Repaid\\n   *                    -> Auction -> Defaulted\\n   */\\n  enum LoanState {\\n    // We need a default that is not 'Created' - this is the zero value\\n    None,\\n    // The loan data is stored, but not initiated yet.\\n    Created,\\n    // The loan has been initialized, funds have been delivered to the borrower and the collateral is held.\\n    Active,\\n    // The loan is in auction, higest price liquidator will got chance to claim it.\\n    Auction,\\n    // The loan has been repaid, and the collateral has been returned to the borrower. This is a terminal state.\\n    Repaid,\\n    // The loan was delinquent and collateral claimed by the liquidator. This is a terminal state.\\n    Defaulted\\n  }\\n\\n  struct LoanData {\\n    //the id of the nft loan\\n    uint256 loanId;\\n    //the current state of the loan\\n    LoanState state;\\n    //address of borrower\\n    address borrower;\\n    //address of nft asset token\\n    address nftAsset;\\n    //the id of nft token\\n    uint256 nftTokenId;\\n    //address of reserve asset token\\n    address reserveAsset;\\n    //scaled borrow amount. Expressed in ray\\n    uint256 scaledAmount;\\n    //start time of first bid time\\n    uint256 bidStartTimestamp;\\n    //bidder address of higest bid\\n    address bidderAddress;\\n    //price of higest bid\\n    uint256 bidPrice;\\n    //borrow amount of loan\\n    uint256 bidBorrowAmount;\\n    //bidder address of first bid\\n    address firstBidderAddress;\\n  }\\n\\n  struct ExecuteDepositParams {\\n    address initiator;\\n    address asset;\\n    uint256 amount;\\n    address onBehalfOf;\\n    Period period;\\n    uint16 referralCode;\\n  }\\n\\n  struct ExecuteWithdrawParams {\\n    address initiator;\\n    address asset;\\n    uint256 amount;\\n    address to;\\n    Period period;\\n  }\\n\\n  struct ExecuteBorrowParams {\\n    address initiator;\\n    address asset;\\n    uint256 amount;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    address onBehalfOf;\\n    uint16 referralCode;\\n  }\\n\\n  struct ExecuteBatchBorrowParams {\\n    address initiator;\\n    address[] assets;\\n    uint256[] amounts;\\n    address[] nftAssets;\\n    uint256[] nftTokenIds;\\n    address onBehalfOf;\\n    uint16 referralCode;\\n  }\\n\\n  struct ExecuteRepayParams {\\n    address initiator;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    uint256 amount;\\n  }\\n\\n  struct ExecuteBatchRepayParams {\\n    address initiator;\\n    address[] nftAssets;\\n    uint256[] nftTokenIds;\\n    uint256[] amounts;\\n  }\\n\\n  struct ExecuteAuctionParams {\\n    address initiator;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    uint256 bidPrice;\\n    address onBehalfOf;\\n  }\\n\\n  struct ExecuteLiquidatingBuyParams {\\n    address initiator;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    uint256 liquidatingBuyPrice;\\n    address onBehalfOf;\\n  }\\n\\n  struct ExecuteRedeemParams {\\n    address initiator;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    uint256 amount;\\n    uint256 bidFine;\\n  }\\n\\n  struct ExecuteLiquidateParams {\\n    address initiator;\\n    address nftAsset;\\n    uint256 nftTokenId;\\n    uint256 amount;\\n  }\\n\\n  struct ExecuteLendPoolStates {\\n    uint256 pauseStartTime;\\n    uint256 pauseDurationTime;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDebtToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {ILendPoolAddressesProvider} from \\\"../interfaces/ILendPoolAddressesProvider.sol\\\";\\nimport {IIncentivesController} from \\\"./IIncentivesController.sol\\\";\\nimport {IScaledBalanceToken} from \\\"./IScaledBalanceToken.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\n/**\\n * @title IDebtToken\\n * @author MetaFire\\n * @notice Defines the basic interface for a debt token.\\n **/\\ninterface IDebtToken is IScaledBalanceToken, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n  /**\\n   * @dev Emitted when a debt token is initialized\\n   * @param underlyingAsset The address of the underlying asset\\n   * @param pool The address of the associated lend pool\\n   * @param incentivesController The address of the incentives controller\\n   * @param debtTokenDecimals the decimals of the debt token\\n   * @param debtTokenName the name of the debt token\\n   * @param debtTokenSymbol the symbol of the debt token\\n   **/\\n  event Initialized(\\n    address indexed underlyingAsset,\\n    address indexed pool,\\n    address incentivesController,\\n    uint8 debtTokenDecimals,\\n    string debtTokenName,\\n    string debtTokenSymbol\\n  );\\n\\n  /**\\n   * @dev Initializes the debt token.\\n   * @param addressProvider The address of the lend pool\\n   * @param underlyingAsset The address of the underlying asset\\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\\n   * @param debtTokenName The name of the token\\n   * @param debtTokenSymbol The symbol of the token\\n   */\\n  function initialize(\\n    ILendPoolAddressesProvider addressProvider,\\n    address underlyingAsset,\\n    uint8 debtTokenDecimals,\\n    string memory debtTokenName,\\n    string memory debtTokenSymbol\\n  ) external;\\n\\n  /**\\n   * @dev Emitted after the mint action\\n   * @param from The address performing the mint\\n   * @param value The amount to be minted\\n   * @param index The last index of the reserve\\n   **/\\n  event Mint(address indexed from, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Mints debt token to the `user` address\\n   * @param user The address receiving the borrowed underlying\\n   * @param amount The amount of debt being minted\\n   * @param index The variable debt index of the reserve\\n   * @return `true` if the the previous balance of the user is 0\\n   **/\\n  function mint(\\n    address user,\\n    address onBehalfOf,\\n    uint256 amount,\\n    uint256 index\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when variable debt is burnt\\n   * @param user The user which debt has been burned\\n   * @param amount The amount of debt being burned\\n   * @param index The index of the user\\n   **/\\n  event Burn(address indexed user, uint256 amount, uint256 index);\\n\\n  /**\\n   * @dev Burns user variable debt\\n   * @param user The user which debt is burnt\\n   * @param index The variable debt index of the reserve\\n   **/\\n  function burn(\\n    address user,\\n    uint256 amount,\\n    uint256 index\\n  ) external;\\n\\n  /**\\n   * @dev Returns the address of the incentives controller contract\\n   **/\\n  function getIncentivesController() external view returns (IIncentivesController);\\n\\n  /**\\n   * @dev delegates borrowing power to a user on the specific debt token\\n   * @param delegatee the address receiving the delegated borrowing power\\n   * @param amount the maximum amount being delegated. Delegation will still\\n   * respect the liquidation constraints (even if delegated, a delegatee cannot\\n   * force a delegator HF to go below 1)\\n   **/\\n  function approveDelegation(address delegatee, uint256 amount) external;\\n\\n  /**\\n   * @dev returns the borrow allowance of the user\\n   * @param fromUser The user to giving allowance\\n   * @param toUser The user to give allowance to\\n   * @return the current allowance of toUser\\n   **/\\n  function borrowAllowance(address fromUser, address toUser) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {ILendPoolAddressesProvider} from \\\"./ILendPoolAddressesProvider.sol\\\";\\nimport {IIncentivesController} from \\\"./IIncentivesController.sol\\\";\\nimport {IScaledBalanceToken} from \\\"./IScaledBalanceToken.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\ninterface IMToken is IScaledBalanceToken, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n  /**\\n   * @dev Emitted when an mToken is initialized\\n   * @param underlyingAsset The address of the underlying asset\\n   * @param pool The address of the associated lending pool\\n   * @param treasury The address of the treasury\\n   * @param incentivesController The address of the incentives controller for this mToken\\n   **/\\n  event Initialized(\\n    address indexed underlyingAsset,\\n    address indexed pool,\\n    address treasury,\\n    address incentivesController\\n  );\\n\\n  /**\\n   * @dev Initializes the mToken\\n   * @param addressProvider The address of the address provider where this mToken will be used\\n   * @param treasury The address of the MetaFire treasury, receiving the fees on this mToken\\n   * @param underlyingAsset The address of the underlying asset of this mToken\\n   */\\n  function initialize(\\n    ILendPoolAddressesProvider addressProvider,\\n    address treasury,\\n    address underlyingAsset,\\n    uint8 mTokenDecimals,\\n    string calldata mTokenName,\\n    string calldata mTokenSymbol\\n  ) external;\\n\\n  /**\\n   * @dev Emitted after the mint action\\n   * @param from The address performing the mint\\n   * @param value The amount being\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Mint(address indexed from, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Mints `amount` mTokens to `user`\\n   * @param user The address receiving the minted tokens\\n   * @param amount The amount of tokens getting minted\\n   * @param index The new liquidity index of the reserve\\n   * @return `true` if the the previous balance of the user was 0\\n   */\\n  function mint(\\n    address user,\\n    uint256 amount,\\n    uint256 index\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted after mTokens are burned\\n   * @param from The owner of the mTokens, getting them burned\\n   * @param target The address that will receive the underlying\\n   * @param value The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Emitted during the transfer action\\n   * @param from The user whose tokens are being transferred\\n   * @param to The recipient\\n   * @param value The amount being transferred\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Burns mTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\n   * @param user The owner of the mTokens, getting them burned\\n   * @param receiverOfUnderlying The address that will receive the underlying\\n   * @param amount The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  function burn(\\n    address user,\\n    address receiverOfUnderlying,\\n    uint256 amount,\\n    uint256 index\\n  ) external;\\n\\n  /**\\n   * @dev Mints mTokens to the reserve treasury\\n   * @param amount The amount of tokens getting minted\\n   * @param index The new liquidity index of the reserve\\n   */\\n  function mintToTreasury(uint256 amount, uint256 index) external;\\n\\n  /**\\n   * @dev Transfers the underlying asset to `target`. Used by the LendPool to transfer\\n   * assets in borrow(), withdraw() and flashLoan()\\n   * @param user The recipient of the underlying\\n   * @param amount The amount getting transferred\\n   * @return The amount transferred\\n   **/\\n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @dev Returns the address of the incentives controller contract\\n   **/\\n  function getIncentivesController() external view returns (IIncentivesController);\\n\\n  /**\\n   * @dev Returns the address of the underlying asset of this mToken\\n   **/\\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterestRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {DataTypes} from \\\"../libraries/types/DataTypes.sol\\\";\\n\\n/**\\n * @title IInterestRate interface\\n * @dev Interface for the calculation of the interest rates\\n * @author MetaFire\\n */\\ninterface IInterestRate {\\n  function baseVariableBorrowRate() external view returns (uint256);\\n\\n  function getMaxVariableBorrowRate() external view returns (uint256);\\n\\n  function calculateInterestRates(\\n    DataTypes.ReserveData memory reserve,\\n    uint256 availableLiquidity,\\n    uint256 totalVariableDebt,\\n    uint256 reserveFactor,\\n    uint256[4] memory liquidities\\n  ) external view returns (uint256[4] memory liquidityRates, uint256 variableBorrowRate);\\n\\n  function calculateInterestRates(\\n    DataTypes.ReserveData memory reserve,\\n    address targetMToken,\\n    uint256 liquidityAdded,\\n    uint256 liquidityTaken,\\n    uint256 totalVariableDebt,\\n    uint256 reserveFactor\\n  ) external view returns (uint256[4] memory liquidityRates, uint256 variableBorrowRate);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/MathUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {WadRayMath} from \\\"./WadRayMath.sol\\\";\\n\\nlibrary MathUtils {\\n  using WadRayMath for uint256;\\n\\n  /// @dev Ignoring leap years\\n  uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n\\n  /**\\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\\n   * @param rate The interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate linearly accumulated during the timeDelta, in ray\\n   **/\\n\\n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\\n    //solium-disable-next-line\\n    uint256 timeDifference = block.timestamp - (uint256(lastUpdateTimestamp));\\n\\n    return ((rate * (timeDifference)) / SECONDS_PER_YEAR) + (WadRayMath.ray());\\n  }\\n\\n  /**\\n   * @dev Function to calculate the interest using a compounded interest rate formula\\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\n   *\\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\n   *\\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\\n   *\\n   * @param rate The interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate compounded during the timeDelta, in ray\\n   **/\\n  function calculateCompoundedInterest(\\n    uint256 rate,\\n    uint40 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    //solium-disable-next-line\\n    uint256 exp = currentTimestamp - (uint256(lastUpdateTimestamp));\\n\\n    if (exp == 0) {\\n      return WadRayMath.ray();\\n    }\\n\\n    uint256 expMinusOne = exp - 1;\\n\\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\\n\\n    uint256 ratePerSecond = rate / SECONDS_PER_YEAR;\\n\\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\\n\\n    uint256 secondTerm = (exp * (expMinusOne) * (basePowerTwo)) / 2;\\n    uint256 thirdTerm = (exp * (expMinusOne) * (expMinusTwo) * (basePowerThree)) / 6;\\n\\n    return WadRayMath.ray() + (ratePerSecond * (exp)) + (secondTerm) + (thirdTerm);\\n  }\\n\\n  /**\\n   * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\\n   * @param rate The interest rate (in ray)\\n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\\n   **/\\n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\\n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IIncentivesController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\ninterface IIncentivesController {\\n  /**\\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\\n   * @param asset The address of the user\\n   * @param totalSupply The total supply of the asset in the lending pool\\n   * @param userBalance The balance of the user of the asset in the lending pool\\n   **/\\n  function handleAction(\\n    address asset,\\n    uint256 totalSupply,\\n    uint256 userBalance\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IScaledBalanceToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\ninterface IScaledBalanceToken {\\n  /**\\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\\n   * @param user The user whose balance is calculated\\n   * @return The scaled balance of the user\\n   **/\\n  function scaledBalanceOf(address user) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the scaled balance of the user and the scaled total supply.\\n   * @param user The address of the user\\n   * @return The scaled balance of the user\\n   * @return The scaled balance and the scaled total supply\\n   **/\\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\\n\\n  /**\\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\\n   * @return The scaled total supply\\n   **/\\n  function scaledTotalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReserveOracleGetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\n/************\\n@title IReserveOracleGetter interface\\n@notice Interface for getting Reserve price oracle.*/\\ninterface IReserveOracleGetter {\\n  /* CAUTION: Price uint is ETH based (WEI, 18 decimals) */\\n  /***********\\n    @dev returns the asset price in ETH\\n     */\\n  function getAssetPrice(address asset) external view returns (uint256);\\n\\n  // get twap price depending on _period\\n  function getTwapPrice(address _priceFeedKey, uint256 _interval) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INFTOracleGetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\n/************\\n@title INFTOracleGetter interface\\n@notice Interface for getting NFT price oracle.*/\\ninterface INFTOracleGetter {\\n  /* CAUTION: Price uint is ETH based (WEI, 18 decimals) */\\n  /***********\\n    @dev returns the asset price in ETH\\n     */\\n  function getAssetPrice(address asset) external view returns (uint256);\\n\\n  // function getNFTPriceFromLink( address asset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBurnLockMToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.4;\\n\\nimport {ILendPoolAddressesProvider} from \\\"./ILendPoolAddressesProvider.sol\\\";\\nimport {IIncentivesController} from \\\"./IIncentivesController.sol\\\";\\nimport {IScaledBalanceToken} from \\\"./IScaledBalanceToken.sol\\\";\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\nimport {DataTypes} from \\\"../libraries/types/DataTypes.sol\\\";\\n\\ninterface IBurnLockMToken is IScaledBalanceToken, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n  /**\\n   * @dev Emitted when an mToken is initialized\\n   * @param underlyingAsset The address of the underlying asset\\n   * @param pool The address of the associated lending pool\\n   * @param treasury The address of the treasury\\n   * @param incentivesController The address of the incentives controller for this mToken\\n   **/\\n  event Initialized(\\n    address indexed underlyingAsset,\\n    address indexed pool,\\n    address treasury,\\n    address incentivesController\\n  );\\n\\n  /**\\n   * @dev Initializes the mToken\\n   * @param addressProvider The address of the address provider where this mToken will be used\\n   * @param treasury The address of the MetaFire treasury, receiving the fees on this mToken\\n   * @param underlyingAsset The address of the underlying asset of this mToken\\n   * @param mTokenDecimals The decimals of this mToken\\n   * @param mTokenName The name of this mToken\\n   * @param mTokenSymbol The symbol of this mToken\\n   * @param lockPeriod The lock period of this mToken\\n   */\\n  function initialize(\\n    ILendPoolAddressesProvider addressProvider,\\n    address treasury,\\n    address underlyingAsset,\\n    uint8 mTokenDecimals,\\n    string calldata mTokenName,\\n    string calldata mTokenSymbol,\\n    uint256 lockPeriod\\n  ) external;\\n\\n  /**\\n   * @dev Emitted after the mint action\\n   * @param from The address performing the mint\\n   * @param value The amount being\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Mint(address indexed from, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Mints `amount` mTokens to `user`\\n   * @param user The address receiving the minted tokens\\n   * @param amount The amount of tokens getting minted\\n   * @param index The new liquidity index of the reserve\\n   * @return `true` if the the previous balance of the user was 0\\n   */\\n  function mint(\\n    address user,\\n    uint256 amount,\\n    uint256 index\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted after mTokens are burned\\n   * @param from The owner of the mTokens, getting them burned\\n   * @param target The address that will receive the underlying\\n   * @param value The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Emitted during the transfer action\\n   * @param from The user whose tokens are being transferred\\n   * @param to The recipient\\n   * @param value The amount being transferred\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Burns mTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\n   * @param user The owner of the mTokens, getting them burned\\n   * @param receiverOfUnderlying The address that will receive the underlying\\n   * @param amount The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  function burn(\\n    address user,\\n    address receiverOfUnderlying,\\n    uint256 amount,\\n    uint256 index\\n  ) external;\\n\\n  function transferFrom(address from, address to, uint256 value, DataTypes.Period period) external returns (bool);\\n\\n  /**\\n   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\\n   * @param user The user whose balance is calculated\\n   * @param period The period of the balance\\n   * @return The balance of the user\\n   **/\\n  function balanceOf(address user, DataTypes.Period period) external returns (uint256);\\n\\n  /**\\n   * @dev Mints mTokens to the reserve treasury\\n   * @param amount The amount of tokens getting minted\\n   * @param index The new liquidity index of the reserve\\n   */\\n  function mintToTreasury(uint256 amount, uint256 index) external;\\n\\n  /**\\n   * @dev Transfers the underlying asset to `target`. Used by the LendPool to transfer\\n   * assets in borrow(), withdraw() and flashLoan()\\n   * @param user The recipient of the underlying\\n   * @param amount The amount getting transferred\\n   * @return The amount transferred\\n   **/\\n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @dev Returns the address of the incentives controller contract\\n   **/\\n  function getIncentivesController() external view returns (IIncentivesController);\\n\\n  /**\\n   * @dev Returns the address of the underlying asset of this mToken\\n   **/\\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/logic/BorrowLogic.sol\": {\r\n        \"BorrowLogic\": \"0x5e7d2f1b3c210e1015d86f4eae8207cdc1daec40\"\r\n      },\r\n      \"contracts/libraries/logic/LiquidateLogic.sol\": {\r\n        \"LiquidateLogic\": \"0x4cff5e23b4c5682e5f56e2567e1d627d1f709eec\"\r\n      },\r\n      \"contracts/libraries/logic/NftLogic.sol\": {\r\n        \"NftLogic\": \"0xb5128735cafa3cc7cf41a6287eca6aeecff5ea58\"\r\n      },\r\n      \"contracts/libraries/logic/ReserveLogic.sol\": {\r\n        \"ReserveLogic\": \"0x1b90091589d4432de83903714513ff8c492553b2\"\r\n      },\r\n      \"contracts/libraries/logic/SupplyLogic.sol\": {\r\n        \"SupplyLogic\": \"0xda5e8efc170311ef2b7b67e61adcc8980a746959\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"Auction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"referral\",\"type\":\"uint16\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"period\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"referral\",\"type\":\"uint16\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"Liquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidatingBuyPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"LiquidatingBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"durationTime\",\"type\":\"uint256\"}],\"name\":\"PausedTimeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fineAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"Repay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[4]\",\"name\":\"liquidityRates\",\"type\":\"uint256[4]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"variableBorrowRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[4]\",\"name\":\"liquidityIndices\",\"type\":\"uint128[4]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"variableBorrowIndex\",\"type\":\"uint256\"}],\"name\":\"ReserveDataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"period\",\"type\":\"uint8\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"}],\"name\":\"auction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"nftAssets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nftTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"referralCode\",\"type\":\"uint16\"}],\"name\":\"batchBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nftAssets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nftTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchRepay\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"referralCode\",\"type\":\"uint16\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"enum DataTypes.Period\",\"name\":\"period\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"referralCode\",\"type\":\"uint16\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceFromBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceToBefore\",\"type\":\"uint256\"},{\"internalType\":\"enum DataTypes.Period\",\"name\":\"period\",\"type\":\"uint8\"}],\"name\":\"finalizeTransfer\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddressesProvider\",\"outputs\":[{\"internalType\":\"contract ILendPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxNumberOfNfts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxNumberOfReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"}],\"name\":\"getNftAuctionData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bidderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidBorrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidFine\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"}],\"name\":\"getNftAuctionEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidStartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemEndTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reserveAsset\",\"type\":\"address\"}],\"name\":\"getNftCollateralData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCollateralInETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateralInReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableBorrowsInETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableBorrowsInReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationBonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getNftConfiguration\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.NftConfigurationMap\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getNftData\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.NftConfigurationMap\",\"name\":\"configuration\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"bNftAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.NftData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"}],\"name\":\"getNftDebtData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"reserveAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableBorrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"healthFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"}],\"name\":\"getNftLiquidatePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidatePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paybackAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNftsList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPausedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getReserveConfiguration\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.ReserveConfigurationMap\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getReserveData\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.ReserveConfigurationMap\",\"name\":\"configuration\",\"type\":\"tuple\"},{\"internalType\":\"uint128[4]\",\"name\":\"liquidityIndices\",\"type\":\"uint128[4]\"},{\"internalType\":\"uint128\",\"name\":\"variableBorrowIndex\",\"type\":\"uint128\"},{\"internalType\":\"uint128[4]\",\"name\":\"currentLiquidityRates\",\"type\":\"uint128[4]\"},{\"internalType\":\"uint128\",\"name\":\"currentVariableBorrowRate\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint40\"},{\"internalType\":\"address[4]\",\"name\":\"mTokenAddresses\",\"type\":\"address[4]\"},{\"internalType\":\"address\",\"name\":\"debtTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interestRateAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"internalType\":\"struct DataTypes.ReserveData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"enum DataTypes.Period\",\"name\":\"period\",\"type\":\"uint8\"}],\"name\":\"getReserveNormalizedIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getReserveNormalizedVariableDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReservesList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bNftAddress\",\"type\":\"address\"}],\"name\":\"initNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address[4]\",\"name\":\"mTokenAddresses\",\"type\":\"address[4]\"},{\"internalType\":\"address\",\"name\":\"debtTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interestRateAddress\",\"type\":\"address\"}],\"name\":\"initReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILendPoolAddressesProvider\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"liquidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidatingBuyPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"}],\"name\":\"liquidatingBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidFine\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setMaxNumberOfNfts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setMaxNumberOfReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"configuration\",\"type\":\"uint256\"}],\"name\":\"setNftConfiguration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokenId\",\"type\":\"uint256\"}],\"name\":\"setNftMaxSupplyAndTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"durationTime\",\"type\":\"uint256\"}],\"name\":\"setPausedTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"configuration\",\"type\":\"uint256\"}],\"name\":\"setReserveConfiguration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rateAddress\",\"type\":\"address\"}],\"name\":\"setReserveInterestRateAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"enum DataTypes.Period\",\"name\":\"period\",\"type\":\"uint8\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LendPool", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}